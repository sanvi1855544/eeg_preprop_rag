[{"name": "abc", "path": "library/abc", "type": "Runtime", "text": "\nSource code: Lib/abc.py\n\n"}, {"name": "abc.ABC", "path": "library/abc#abc.ABC", "type": "Runtime", "text": "\nA helper class that has `ABCMeta` as its metaclass. With this class, an\nabstract base class can be created by simply deriving from `ABC` avoiding\nsometimes confusing metaclass usage, for example:\n\n"}, {"name": "abc.ABCMeta", "path": "library/abc#abc.ABCMeta", "type": "Runtime", "text": "\nMetaclass for defining Abstract Base Classes (ABCs).\n\n"}, {"name": "abc.ABCMeta.register()", "path": "library/abc#abc.ABCMeta.register", "type": "Runtime", "text": "\nRegister subclass as a \u201cvirtual subclass\u201d of this ABC. For example:\n\n"}, {"name": "abc.ABCMeta.__subclasshook__()", "path": "library/abc#abc.ABCMeta.__subclasshook__", "type": "Runtime", "text": "\n(Must be defined as a class method.)\n\n"}, {"name": "abc.abstractclassmethod()", "path": "library/abc#abc.abstractclassmethod", "type": "Runtime", "text": "\nNew in version 3.2.\n\n"}, {"name": "abc.abstractmethod()", "path": "library/abc#abc.abstractmethod", "type": "Runtime", "text": "\nA decorator indicating abstract methods.\n\n"}, {"name": "abc.abstractproperty()", "path": "library/abc#abc.abstractproperty", "type": "Runtime", "text": "\nDeprecated since version 3.3: It is now possible to use `property`,\n`property.getter()`, `property.setter()` and `property.deleter()` with\n`abstractmethod()`, making this decorator redundant.\n\n"}, {"name": "abc.abstractstaticmethod()", "path": "library/abc#abc.abstractstaticmethod", "type": "Runtime", "text": "\nNew in version 3.2.\n\n"}, {"name": "abc.get_cache_token()", "path": "library/abc#abc.get_cache_token", "type": "Runtime", "text": "\nReturns the current abstract base class cache token.\n\n"}, {"name": "abs()", "path": "library/functions#abs", "type": "Built-in Functions", "text": "\nReturn the absolute value of a number. The argument may be an integer, a\nfloating point number, or an object implementing `__abs__()`. If the argument\nis a complex number, its magnitude is returned.\n\n"}, {"name": "aifc", "path": "library/aifc", "type": "Multimedia", "text": "\nSource code: Lib/aifc.py\n\n"}, {"name": "aifc.aifc.aifc()", "path": "library/aifc#aifc.aifc.aifc", "type": "Multimedia", "text": "\nCreate an AIFF-C file. The default is that an AIFF-C file is created, unless\nthe name of the file ends in `'.aiff'` in which case the default is an AIFF\nfile.\n\n"}, {"name": "aifc.aifc.aiff()", "path": "library/aifc#aifc.aifc.aiff", "type": "Multimedia", "text": "\nCreate an AIFF file. The default is that an AIFF-C file is created, unless the\nname of the file ends in `'.aiff'` in which case the default is an AIFF file.\n\n"}, {"name": "aifc.aifc.close()", "path": "library/aifc#aifc.aifc.close", "type": "Multimedia", "text": "\nClose the AIFF file. After calling this method, the object can no longer be\nused.\n\n"}, {"name": "aifc.aifc.getcompname()", "path": "library/aifc#aifc.aifc.getcompname", "type": "Multimedia", "text": "\nReturn a bytes array convertible to a human-readable description of the type\nof compression used in the audio file. For AIFF files, the returned value is\n`b'not compressed'`.\n\n"}, {"name": "aifc.aifc.getcomptype()", "path": "library/aifc#aifc.aifc.getcomptype", "type": "Multimedia", "text": "\nReturn a bytes array of length 4 describing the type of compression used in\nthe audio file. For AIFF files, the returned value is `b'NONE'`.\n\n"}, {"name": "aifc.aifc.getframerate()", "path": "library/aifc#aifc.aifc.getframerate", "type": "Multimedia", "text": "\nReturn the sampling rate (number of audio frames per second).\n\n"}, {"name": "aifc.aifc.getmark()", "path": "library/aifc#aifc.aifc.getmark", "type": "Multimedia", "text": "\nReturn the tuple as described in `getmarkers()` for the mark with the given\nid.\n\n"}, {"name": "aifc.aifc.getmarkers()", "path": "library/aifc#aifc.aifc.getmarkers", "type": "Multimedia", "text": "\nReturn a list of markers in the audio file. A marker consists of a tuple of\nthree elements. The first is the mark ID (an integer), the second is the mark\nposition in frames from the beginning of the data (an integer), the third is\nthe name of the mark (a string).\n\n"}, {"name": "aifc.aifc.getnchannels()", "path": "library/aifc#aifc.aifc.getnchannels", "type": "Multimedia", "text": "\nReturn the number of audio channels (1 for mono, 2 for stereo).\n\n"}, {"name": "aifc.aifc.getnframes()", "path": "library/aifc#aifc.aifc.getnframes", "type": "Multimedia", "text": "\nReturn the number of audio frames in the file.\n\n"}, {"name": "aifc.aifc.getparams()", "path": "library/aifc#aifc.aifc.getparams", "type": "Multimedia", "text": "\nReturns a `namedtuple()` `(nchannels, sampwidth, framerate, nframes, comptype,\ncompname)`, equivalent to output of the `get*()` methods.\n\n"}, {"name": "aifc.aifc.getsampwidth()", "path": "library/aifc#aifc.aifc.getsampwidth", "type": "Multimedia", "text": "\nReturn the size in bytes of individual samples.\n\n"}, {"name": "aifc.aifc.readframes()", "path": "library/aifc#aifc.aifc.readframes", "type": "Multimedia", "text": "\nRead and return the next nframes frames from the audio file. The returned data\nis a string containing for each frame the uncompressed samples of all\nchannels.\n\n"}, {"name": "aifc.aifc.rewind()", "path": "library/aifc#aifc.aifc.rewind", "type": "Multimedia", "text": "\nRewind the read pointer. The next `readframes()` will start from the\nbeginning.\n\n"}, {"name": "aifc.aifc.setcomptype()", "path": "library/aifc#aifc.aifc.setcomptype", "type": "Multimedia", "text": "\nSpecify the compression type. If not specified, the audio data will not be\ncompressed. In AIFF files, compression is not possible. The name parameter\nshould be a human-readable description of the compression type as a bytes\narray, the type parameter should be a bytes array of length 4. Currently the\nfollowing compression types are supported: `b'NONE'`, `b'ULAW'`, `b'ALAW'`,\n`b'G722'`.\n\n"}, {"name": "aifc.aifc.setframerate()", "path": "library/aifc#aifc.aifc.setframerate", "type": "Multimedia", "text": "\nSpecify the sampling frequency in frames per second.\n\n"}, {"name": "aifc.aifc.setmark()", "path": "library/aifc#aifc.aifc.setmark", "type": "Multimedia", "text": "\nAdd a mark with the given id (larger than 0), and the given name at the given\nposition. This method can be called at any time before `close()`.\n\n"}, {"name": "aifc.aifc.setnchannels()", "path": "library/aifc#aifc.aifc.setnchannels", "type": "Multimedia", "text": "\nSpecify the number of channels in the audio file.\n\n"}, {"name": "aifc.aifc.setnframes()", "path": "library/aifc#aifc.aifc.setnframes", "type": "Multimedia", "text": "\nSpecify the number of frames that are to be written to the audio file. If this\nparameter is not set, or not set correctly, the file needs to support seeking.\n\n"}, {"name": "aifc.aifc.setparams()", "path": "library/aifc#aifc.aifc.setparams", "type": "Multimedia", "text": "\nSet all the above parameters at once. The argument is a tuple consisting of\nthe various parameters. This means that it is possible to use the result of a\n`getparams()` call as argument to `setparams()`.\n\n"}, {"name": "aifc.aifc.setpos()", "path": "library/aifc#aifc.aifc.setpos", "type": "Multimedia", "text": "\nSeek to the specified frame number.\n\n"}, {"name": "aifc.aifc.setsampwidth()", "path": "library/aifc#aifc.aifc.setsampwidth", "type": "Multimedia", "text": "\nSpecify the size in bytes of audio samples.\n\n"}, {"name": "aifc.aifc.tell()", "path": "library/aifc#aifc.aifc.tell", "type": "Multimedia", "text": "\nReturn the current frame number.\n\n"}, {"name": "aifc.aifc.writeframes()", "path": "library/aifc#aifc.aifc.writeframes", "type": "Multimedia", "text": "\nWrite data to the output file. This method can only be called after the audio\nfile parameters have been set.\n\n"}, {"name": "aifc.aifc.writeframesraw()", "path": "library/aifc#aifc.aifc.writeframesraw", "type": "Multimedia", "text": "\nLike `writeframes()`, except that the header of the audio file is not updated.\n\n"}, {"name": "aifc.open()", "path": "library/aifc#aifc.open", "type": "Multimedia", "text": "\nOpen an AIFF or AIFF-C file and return an object instance with methods that\nare described below. The argument file is either a string naming a file or a\nfile object. mode must be `'r'` or `'rb'` when the file must be opened for\nreading, or `'w'` or `'wb'` when the file must be opened for writing. If\nomitted, `file.mode` is used if it exists, otherwise `'rb'` is used. When used\nfor writing, the file object should be seekable, unless you know ahead of time\nhow many samples you are going to write in total and use `writeframesraw()`\nand `setnframes()`. The `open()` function may be used in a `with` statement.\nWhen the `with` block completes, the `close()` method is called.\n\n"}, {"name": "all()", "path": "library/functions#all", "type": "Built-in Functions", "text": "\nReturn `True` if all elements of the iterable are true (or if the iterable is\nempty). Equivalent to:\n\n"}, {"name": "any()", "path": "library/functions#any", "type": "Built-in Functions", "text": "\nReturn `True` if any element of the iterable is true. If the iterable is\nempty, return `False`. Equivalent to:\n\n"}, {"name": "argparse", "path": "library/argparse", "type": "Operating System", "text": "\nNew in version 3.2.\n\n"}, {"name": "argparse.Action", "path": "library/argparse#argparse.Action", "type": "Operating System", "text": "\n\n"}, {"name": "argparse.ArgumentDefaultsHelpFormatter", "path": "library/argparse#argparse.ArgumentDefaultsHelpFormatter", "type": "Operating System", "text": "\n\n"}, {"name": "argparse.ArgumentParser", "path": "library/argparse#argparse.ArgumentParser", "type": "Operating System", "text": "\nCreate a new `ArgumentParser` object. All parameters should be passed as\nkeyword arguments. Each parameter has its own more detailed description below,\nbut in short they are:\n\n"}, {"name": "argparse.ArgumentParser.add_argument()", "path": "library/argparse#argparse.ArgumentParser.add_argument", "type": "Operating System", "text": "\nDefine how a single command-line argument should be parsed. Each parameter has\nits own more detailed description below, but in short they are:\n\n"}, {"name": "argparse.ArgumentParser.add_argument_group()", "path": "library/argparse#argparse.ArgumentParser.add_argument_group", "type": "Operating System", "text": "\nBy default, `ArgumentParser` groups command-line arguments into \u201cpositional\narguments\u201d and \u201coptional arguments\u201d when displaying help messages. When there\nis a better conceptual grouping of arguments than this default one,\nappropriate groups can be created using the `add_argument_group()` method:\n\n"}, {"name": "argparse.ArgumentParser.add_mutually_exclusive_group()", "path": "library/argparse#argparse.ArgumentParser.add_mutually_exclusive_group", "type": "Operating System", "text": "\nCreate a mutually exclusive group. `argparse` will make sure that only one of\nthe arguments in the mutually exclusive group was present on the command line:\n\n"}, {"name": "argparse.ArgumentParser.add_subparsers()", "path": "library/argparse#argparse.ArgumentParser.add_subparsers", "type": "Operating System", "text": "\nMany programs split up their functionality into a number of sub-commands, for\nexample, the `svn` program can invoke sub-commands like `svn checkout`, `svn\nupdate`, and `svn commit`. Splitting up functionality this way can be a\nparticularly good idea when a program performs several different functions\nwhich require different kinds of command-line arguments. `ArgumentParser`\nsupports the creation of such sub-commands with the `add_subparsers()` method.\nThe `add_subparsers()` method is normally called with no arguments and returns\na special action object. This object has a single method, `add_parser()`,\nwhich takes a command name and any `ArgumentParser` constructor arguments, and\nreturns an `ArgumentParser` object that can be modified as usual.\n\n"}, {"name": "argparse.ArgumentParser.convert_arg_line_to_args()", "path": "library/argparse#argparse.ArgumentParser.convert_arg_line_to_args", "type": "Operating System", "text": "\nArguments that are read from a file (see the fromfile_prefix_chars keyword\nargument to the `ArgumentParser` constructor) are read one argument per line.\n`convert_arg_line_to_args()` can be overridden for fancier reading.\n\n"}, {"name": "argparse.ArgumentParser.error()", "path": "library/argparse#argparse.ArgumentParser.error", "type": "Operating System", "text": "\nThis method prints a usage message including the message to the standard error\nand terminates the program with a status code of 2.\n\n"}, {"name": "argparse.ArgumentParser.exit()", "path": "library/argparse#argparse.ArgumentParser.exit", "type": "Operating System", "text": "\nThis method terminates the program, exiting with the specified status and, if\ngiven, it prints a message before that. The user can override this method to\nhandle these steps differently:\n\n"}, {"name": "argparse.ArgumentParser.format_help()", "path": "library/argparse#argparse.ArgumentParser.format_help", "type": "Operating System", "text": "\nReturn a string containing a help message, including the program usage and\ninformation about the arguments registered with the `ArgumentParser`.\n\n"}, {"name": "argparse.ArgumentParser.format_usage()", "path": "library/argparse#argparse.ArgumentParser.format_usage", "type": "Operating System", "text": "\nReturn a string containing a brief description of how the `ArgumentParser`\nshould be invoked on the command line.\n\n"}, {"name": "argparse.ArgumentParser.get_default()", "path": "library/argparse#argparse.ArgumentParser.get_default", "type": "Operating System", "text": "\nGet the default value for a namespace attribute, as set by either\n`add_argument()` or by `set_defaults()`:\n\n"}, {"name": "argparse.ArgumentParser.parse_args()", "path": "library/argparse#argparse.ArgumentParser.parse_args", "type": "Operating System", "text": "\nConvert argument strings to objects and assign them as attributes of the\nnamespace. Return the populated namespace.\n\n"}, {"name": "argparse.ArgumentParser.parse_intermixed_args()", "path": "library/argparse#argparse.ArgumentParser.parse_intermixed_args", "type": "Operating System", "text": "\n\n"}, {"name": "argparse.ArgumentParser.parse_known_args()", "path": "library/argparse#argparse.ArgumentParser.parse_known_args", "type": "Operating System", "text": "\n\n"}, {"name": "argparse.ArgumentParser.parse_known_intermixed_args()", "path": "library/argparse#argparse.ArgumentParser.parse_known_intermixed_args", "type": "Operating System", "text": "\n\n"}, {"name": "argparse.ArgumentParser.print_help()", "path": "library/argparse#argparse.ArgumentParser.print_help", "type": "Operating System", "text": "\nPrint a help message, including the program usage and information about the\narguments registered with the `ArgumentParser`. If file is `None`,\n`sys.stdout` is assumed.\n\n"}, {"name": "argparse.ArgumentParser.print_usage()", "path": "library/argparse#argparse.ArgumentParser.print_usage", "type": "Operating System", "text": "\nPrint a brief description of how the `ArgumentParser` should be invoked on the\ncommand line. If file is `None`, `sys.stdout` is assumed.\n\n"}, {"name": "argparse.ArgumentParser.set_defaults()", "path": "library/argparse#argparse.ArgumentParser.set_defaults", "type": "Operating System", "text": "\nMost of the time, the attributes of the object returned by `parse_args()` will\nbe fully determined by inspecting the command-line arguments and the argument\nactions. `set_defaults()` allows some additional attributes that are\ndetermined without any inspection of the command line to be added:\n\n"}, {"name": "argparse.FileType", "path": "library/argparse#argparse.FileType", "type": "Operating System", "text": "\nThe `FileType` factory creates objects that can be passed to the type argument\nof `ArgumentParser.add_argument()`. Arguments that have `FileType` objects as\ntheir type will open command-line arguments as files with the requested modes,\nbuffer sizes, encodings and error handling (see the `open()` function for more\ndetails):\n\n"}, {"name": "argparse.MetavarTypeHelpFormatter", "path": "library/argparse#argparse.MetavarTypeHelpFormatter", "type": "Operating System", "text": "\n\n"}, {"name": "argparse.Namespace", "path": "library/argparse#argparse.Namespace", "type": "Operating System", "text": "\nSimple class used by default by `parse_args()` to create an object holding\nattributes and return it.\n\n"}, {"name": "argparse.RawDescriptionHelpFormatter", "path": "library/argparse#argparse.RawDescriptionHelpFormatter", "type": "Operating System", "text": "\n\n"}, {"name": "argparse.RawTextHelpFormatter", "path": "library/argparse#argparse.RawTextHelpFormatter", "type": "Operating System", "text": "\n\n"}, {"name": "ArithmeticError", "path": "library/exceptions#ArithmeticError", "type": "Built-in Exceptions", "text": "\nThe base class for those built-in exceptions that are raised for various\narithmetic errors: `OverflowError`, `ZeroDivisionError`, `FloatingPointError`.\n\n"}, {"name": "array", "path": "library/array", "type": "Data Types", "text": "\nThis module defines an object type which can compactly represent an array of\nbasic values: characters, integers, floating point numbers. Arrays are\nsequence types and behave very much like lists, except that the type of\nobjects stored in them is constrained. The type is specified at object\ncreation time by using a type code, which is a single character. The following\ntype codes are defined:\n\n"}, {"name": "array.array", "path": "library/array#array.array", "type": "Data Types", "text": "\nA new array whose items are restricted by typecode, and initialized from the\noptional initializer value, which must be a list, a bytes-like object, or\niterable over elements of the appropriate type.\n\n"}, {"name": "array.array.append()", "path": "library/array#array.array.append", "type": "Data Types", "text": "\nAppend a new item with value x to the end of the array.\n\n"}, {"name": "array.array.buffer_info()", "path": "library/array#array.array.buffer_info", "type": "Data Types", "text": "\nReturn a tuple `(address, length)` giving the current memory address and the\nlength in elements of the buffer used to hold array\u2019s contents. The size of\nthe memory buffer in bytes can be computed as `array.buffer_info()[1] *\narray.itemsize`. This is occasionally useful when working with low-level (and\ninherently unsafe) I/O interfaces that require memory addresses, such as\ncertain `ioctl()` operations. The returned numbers are valid as long as the\narray exists and no length-changing operations are applied to it.\n\n"}, {"name": "array.array.byteswap()", "path": "library/array#array.array.byteswap", "type": "Data Types", "text": "\n\u201cByteswap\u201d all items of the array. This is only supported for values which are\n1, 2, 4, or 8 bytes in size; for other types of values, `RuntimeError` is\nraised. It is useful when reading data from a file written on a machine with a\ndifferent byte order.\n\n"}, {"name": "array.array.count()", "path": "library/array#array.array.count", "type": "Data Types", "text": "\nReturn the number of occurrences of x in the array.\n\n"}, {"name": "array.array.extend()", "path": "library/array#array.array.extend", "type": "Data Types", "text": "\nAppend items from iterable to the end of the array. If iterable is another\narray, it must have exactly the same type code; if not, `TypeError` will be\nraised. If iterable is not an array, it must be iterable and its elements must\nbe the right type to be appended to the array.\n\n"}, {"name": "array.array.frombytes()", "path": "library/array#array.array.frombytes", "type": "Data Types", "text": "\nAppends items from the string, interpreting the string as an array of machine\nvalues (as if it had been read from a file using the `fromfile()` method).\n\n"}, {"name": "array.array.fromfile()", "path": "library/array#array.array.fromfile", "type": "Data Types", "text": "\nRead n items (as machine values) from the file object f and append them to the\nend of the array. If less than n items are available, `EOFError` is raised,\nbut the items that were available are still inserted into the array.\n\n"}, {"name": "array.array.fromlist()", "path": "library/array#array.array.fromlist", "type": "Data Types", "text": "\nAppend items from the list. This is equivalent to `for x in list: a.append(x)`\nexcept that if there is a type error, the array is unchanged.\n\n"}, {"name": "array.array.fromunicode()", "path": "library/array#array.array.fromunicode", "type": "Data Types", "text": "\nExtends this array with data from the given unicode string. The array must be\na type `'u'` array; otherwise a `ValueError` is raised. Use\n`array.frombytes(unicodestring.encode(enc))` to append Unicode data to an\narray of some other type.\n\n"}, {"name": "array.array.index()", "path": "library/array#array.array.index", "type": "Data Types", "text": "\nReturn the smallest i such that i is the index of the first occurrence of x in\nthe array.\n\n"}, {"name": "array.array.insert()", "path": "library/array#array.array.insert", "type": "Data Types", "text": "\nInsert a new item with value x in the array before position i. Negative values\nare treated as being relative to the end of the array.\n\n"}, {"name": "array.array.itemsize", "path": "library/array#array.array.itemsize", "type": "Data Types", "text": "\nThe length in bytes of one array item in the internal representation.\n\n"}, {"name": "array.array.pop()", "path": "library/array#array.array.pop", "type": "Data Types", "text": "\nRemoves the item with the index i from the array and returns it. The optional\nargument defaults to `-1`, so that by default the last item is removed and\nreturned.\n\n"}, {"name": "array.array.remove()", "path": "library/array#array.array.remove", "type": "Data Types", "text": "\nRemove the first occurrence of x from the array.\n\n"}, {"name": "array.array.reverse()", "path": "library/array#array.array.reverse", "type": "Data Types", "text": "\nReverse the order of the items in the array.\n\n"}, {"name": "array.array.tobytes()", "path": "library/array#array.array.tobytes", "type": "Data Types", "text": "\nConvert the array to an array of machine values and return the bytes\nrepresentation (the same sequence of bytes that would be written to a file by\nthe `tofile()` method.)\n\n"}, {"name": "array.array.tofile()", "path": "library/array#array.array.tofile", "type": "Data Types", "text": "\nWrite all items (as machine values) to the file object f.\n\n"}, {"name": "array.array.tolist()", "path": "library/array#array.array.tolist", "type": "Data Types", "text": "\nConvert the array to an ordinary list with the same items.\n\n"}, {"name": "array.array.tounicode()", "path": "library/array#array.array.tounicode", "type": "Data Types", "text": "\nConvert the array to a unicode string. The array must be a type `'u'` array;\notherwise a `ValueError` is raised. Use `array.tobytes().decode(enc)` to\nobtain a unicode string from an array of some other type.\n\n"}, {"name": "array.array.typecode", "path": "library/array#array.array.typecode", "type": "Data Types", "text": "\nThe typecode character used to create the array.\n\n"}, {"name": "array.typecodes", "path": "library/array#array.typecodes", "type": "Data Types", "text": "\nA string with all available type codes.\n\n"}, {"name": "ascii()", "path": "library/functions#ascii", "type": "Built-in Functions", "text": "\nAs `repr()`, return a string containing a printable representation of an\nobject, but escape the non-ASCII characters in the string returned by `repr()`\nusing `\\x`, `\\u` or `\\U` escapes. This generates a string similar to that\nreturned by `repr()` in Python 2.\n\n"}, {"name": "AssertionError", "path": "library/exceptions#AssertionError", "type": "Built-in Exceptions", "text": "\nRaised when an `assert` statement fails.\n\n"}, {"name": "ast", "path": "library/ast", "type": "Language", "text": "\nSource code: Lib/ast.py\n\n"}, {"name": "ast.Add", "path": "library/ast#ast.Add", "type": "Language", "text": "\nBinary operator tokens.\n\n"}, {"name": "ast.alias", "path": "library/ast#ast.alias", "type": "Language", "text": "\nBoth parameters are raw strings of the names. `asname` can be `None` if the\nregular name is to be used.\n\n"}, {"name": "ast.And", "path": "library/ast#ast.And", "type": "Language", "text": "\nBoolean operator tokens.\n\n"}, {"name": "ast.AnnAssign", "path": "library/ast#ast.AnnAssign", "type": "Language", "text": "\nAn assignment with a type annotation. `target` is a single node and can be a\n`Name`, a `Attribute` or a `Subscript`. `annotation` is the annotation, such\nas a `Constant` or `Name` node. `value` is a single optional node. `simple` is\na boolean integer set to True for a `Name` node in `target` that do not appear\nin between parenthesis and are hence pure names and not expressions.\n\n"}, {"name": "ast.arg", "path": "library/ast#ast.arg", "type": "Language", "text": "\nA single argument in a list. `arg` is a raw string of the argument name,\n`annotation` is its annotation, such as a `Str` or `Name` node.\n\n"}, {"name": "ast.arg.type_comment", "path": "library/ast#ast.arg.type_comment", "type": "Language", "text": "\n`type_comment` is an optional string with the type annotation as a comment\n\n"}, {"name": "ast.arguments", "path": "library/ast#ast.arguments", "type": "Language", "text": "\nThe arguments for a function.\n\n"}, {"name": "ast.Assert", "path": "library/ast#ast.Assert", "type": "Language", "text": "\nAn assertion. `test` holds the condition, such as a `Compare` node. `msg`\nholds the failure message.\n\n"}, {"name": "ast.Assign", "path": "library/ast#ast.Assign", "type": "Language", "text": "\nAn assignment. `targets` is a list of nodes, and `value` is a single node.\n\n"}, {"name": "ast.Assign.type_comment", "path": "library/ast#ast.Assign.type_comment", "type": "Language", "text": "\n`type_comment` is an optional string with the type annotation as a comment.\n\n"}, {"name": "ast.AST", "path": "library/ast#ast.AST", "type": "Language", "text": "\nThis is the base of all AST node classes. The actual node classes are derived\nfrom the `Parser/Python.asdl` file, which is reproduced below. They are\ndefined in the `_ast` C module and re-exported in `ast`.\n\n"}, {"name": "ast.AST.col_offset", "path": "library/ast#ast.AST.col_offset", "type": "Language", "text": "\nInstances of `ast.expr` and `ast.stmt` subclasses have `lineno`, `col_offset`,\n`lineno`, and `col_offset` attributes. The `lineno` and `end_lineno` are the\nfirst and last line numbers of source text span (1-indexed so the first line\nis line 1) and the `col_offset` and `end_col_offset` are the corresponding\nUTF-8 byte offsets of the first and last tokens that generated the node. The\nUTF-8 offset is recorded because the parser uses UTF-8 internally.\n\n"}, {"name": "ast.AST.end_col_offset", "path": "library/ast#ast.AST.end_col_offset", "type": "Language", "text": "\nInstances of `ast.expr` and `ast.stmt` subclasses have `lineno`, `col_offset`,\n`lineno`, and `col_offset` attributes. The `lineno` and `end_lineno` are the\nfirst and last line numbers of source text span (1-indexed so the first line\nis line 1) and the `col_offset` and `end_col_offset` are the corresponding\nUTF-8 byte offsets of the first and last tokens that generated the node. The\nUTF-8 offset is recorded because the parser uses UTF-8 internally.\n\n"}, {"name": "ast.AST.end_lineno", "path": "library/ast#ast.AST.end_lineno", "type": "Language", "text": "\nInstances of `ast.expr` and `ast.stmt` subclasses have `lineno`, `col_offset`,\n`lineno`, and `col_offset` attributes. The `lineno` and `end_lineno` are the\nfirst and last line numbers of source text span (1-indexed so the first line\nis line 1) and the `col_offset` and `end_col_offset` are the corresponding\nUTF-8 byte offsets of the first and last tokens that generated the node. The\nUTF-8 offset is recorded because the parser uses UTF-8 internally.\n\n"}, {"name": "ast.AST.lineno", "path": "library/ast#ast.AST.lineno", "type": "Language", "text": "\nInstances of `ast.expr` and `ast.stmt` subclasses have `lineno`, `col_offset`,\n`lineno`, and `col_offset` attributes. The `lineno` and `end_lineno` are the\nfirst and last line numbers of source text span (1-indexed so the first line\nis line 1) and the `col_offset` and `end_col_offset` are the corresponding\nUTF-8 byte offsets of the first and last tokens that generated the node. The\nUTF-8 offset is recorded because the parser uses UTF-8 internally.\n\n"}, {"name": "ast.AST._fields", "path": "library/ast#ast.AST._fields", "type": "Language", "text": "\nEach concrete class has an attribute `_fields` which gives the names of all\nchild nodes.\n\n"}, {"name": "ast.AsyncFor", "path": "library/ast#ast.AsyncFor", "type": "Language", "text": "\n`async for` loops and `async with` context managers. They have the same fields\nas `For` and `With`, respectively. Only valid in the body of an\n`AsyncFunctionDef`.\n\n"}, {"name": "ast.AsyncFunctionDef", "path": "library/ast#ast.AsyncFunctionDef", "type": "Language", "text": "\nAn `async def` function definition. Has the same fields as `FunctionDef`.\n\n"}, {"name": "ast.AsyncWith", "path": "library/ast#ast.AsyncWith", "type": "Language", "text": "\n`async for` loops and `async with` context managers. They have the same fields\nas `For` and `With`, respectively. Only valid in the body of an\n`AsyncFunctionDef`.\n\n"}, {"name": "ast.Attribute", "path": "library/ast#ast.Attribute", "type": "Language", "text": "\nAttribute access, e.g. `d.keys`. `value` is a node, typically a `Name`. `attr`\nis a bare string giving the name of the attribute, and `ctx` is `Load`,\n`Store` or `Del` according to how the attribute is acted on.\n\n"}, {"name": "ast.AugAssign", "path": "library/ast#ast.AugAssign", "type": "Language", "text": "\nAugmented assignment, such as `a += 1`. In the following example, `target` is\na `Name` node for `x` (with the `Store` context), `op` is `Add`, and `value`\nis a `Constant` with value for 1.\n\n"}, {"name": "ast.Await", "path": "library/ast#ast.Await", "type": "Language", "text": "\nAn `await` expression. `value` is what it waits for. Only valid in the body of\nan `AsyncFunctionDef`.\n\n"}, {"name": "ast.BinOp", "path": "library/ast#ast.BinOp", "type": "Language", "text": "\nA binary operation (like addition or division). `op` is the operator, and\n`left` and `right` are any expression nodes.\n\n"}, {"name": "ast.BitAnd", "path": "library/ast#ast.BitAnd", "type": "Language", "text": "\nBinary operator tokens.\n\n"}, {"name": "ast.BitOr", "path": "library/ast#ast.BitOr", "type": "Language", "text": "\nBinary operator tokens.\n\n"}, {"name": "ast.BitXor", "path": "library/ast#ast.BitXor", "type": "Language", "text": "\nBinary operator tokens.\n\n"}, {"name": "ast.BoolOp", "path": "library/ast#ast.BoolOp", "type": "Language", "text": "\nA boolean operation, \u2018or\u2019 or \u2018and\u2019. `op` is `Or` or `And`. `values` are the\nvalues involved. Consecutive operations with the same operator, such as `a or\nb or c`, are collapsed into one node with several values.\n\n"}, {"name": "ast.Break", "path": "library/ast#ast.Break", "type": "Language", "text": "\nThe `break` and `continue` statements.\n\n"}, {"name": "ast.Call", "path": "library/ast#ast.Call", "type": "Language", "text": "\nA function call. `func` is the function, which will often be a `Name` or\n`Attribute` object. Of the arguments:\n\n"}, {"name": "ast.ClassDef", "path": "library/ast#ast.ClassDef", "type": "Language", "text": "\nA class definition.\n\n"}, {"name": "ast.Compare", "path": "library/ast#ast.Compare", "type": "Language", "text": "\nA comparison of two or more values. `left` is the first value in the\ncomparison, `ops` the list of operators, and `comparators` the list of values\nafter the first element in the comparison.\n\n"}, {"name": "ast.comprehension", "path": "library/ast#ast.comprehension", "type": "Language", "text": "\nOne `for` clause in a comprehension. `target` is the reference to use for each\nelement - typically a `Name` or `Tuple` node. `iter` is the object to iterate\nover. `ifs` is a list of test expressions: each `for` clause can have multiple\n`ifs`.\n\n"}, {"name": "ast.Constant", "path": "library/ast#ast.Constant", "type": "Language", "text": "\nA constant value. The `value` attribute of the `Constant` literal contains the\nPython object it represents. The values represented can be simple types such\nas a number, string or `None`, but also immutable container types (tuples and\nfrozensets) if all of their elements are constant.\n\n"}, {"name": "ast.Continue", "path": "library/ast#ast.Continue", "type": "Language", "text": "\nThe `break` and `continue` statements.\n\n"}, {"name": "ast.copy_location()", "path": "library/ast#ast.copy_location", "type": "Language", "text": "\nCopy source location (`lineno`, `col_offset`, `end_lineno`, and\n`end_col_offset`) from old_node to new_node if possible, and return new_node.\n\n"}, {"name": "ast.Del", "path": "library/ast#ast.Del", "type": "Language", "text": "\nVariable references can be used to load the value of a variable, to assign a\nnew value to it, or to delete it. Variable references are given a context to\ndistinguish these cases.\n\n"}, {"name": "ast.Delete", "path": "library/ast#ast.Delete", "type": "Language", "text": "\nRepresents a `del` statement. `targets` is a list of nodes, such as `Name`,\n`Attribute` or `Subscript` nodes.\n\n"}, {"name": "ast.Dict", "path": "library/ast#ast.Dict", "type": "Language", "text": "\nA dictionary. `keys` and `values` hold lists of nodes representing the keys\nand the values respectively, in matching order (what would be returned when\ncalling `dictionary.keys()` and `dictionary.values()`).\n\n"}, {"name": "ast.DictComp", "path": "library/ast#ast.DictComp", "type": "Language", "text": "\nList and set comprehensions, generator expressions, and dictionary\ncomprehensions. `elt` (or `key` and `value`) is a single node representing the\npart that will be evaluated for each item.\n\n"}, {"name": "ast.Div", "path": "library/ast#ast.Div", "type": "Language", "text": "\nBinary operator tokens.\n\n"}, {"name": "ast.dump()", "path": "library/ast#ast.dump", "type": "Language", "text": "\nReturn a formatted dump of the tree in node. This is mainly useful for\ndebugging purposes. If annotate_fields is true (by default), the returned\nstring will show the names and the values for fields. If annotate_fields is\nfalse, the result string will be more compact by omitting unambiguous field\nnames. Attributes such as line numbers and column offsets are not dumped by\ndefault. If this is wanted, include_attributes can be set to true.\n\n"}, {"name": "ast.Eq", "path": "library/ast#ast.Eq", "type": "Language", "text": "\nComparison operator tokens.\n\n"}, {"name": "ast.ExceptHandler", "path": "library/ast#ast.ExceptHandler", "type": "Language", "text": "\nA single `except` clause. `type` is the exception type it will match,\ntypically a `Name` node (or `None` for a catch-all `except:` clause). `name`\nis a raw string for the name to hold the exception, or `None` if the clause\ndoesn\u2019t have `as foo`. `body` is a list of nodes.\n\n"}, {"name": "ast.Expr", "path": "library/ast#ast.Expr", "type": "Language", "text": "\nWhen an expression, such as a function call, appears as a statement by itself\nwith its return value not used or stored, it is wrapped in this container.\n`value` holds one of the other nodes in this section, a `Constant`, a `Name`,\na `Lambda`, a `Yield` or `YieldFrom` node.\n\n"}, {"name": "ast.fix_missing_locations()", "path": "library/ast#ast.fix_missing_locations", "type": "Language", "text": "\nWhen you compile a node tree with `compile()`, the compiler expects `lineno`\nand `col_offset` attributes for every node that supports them. This is rather\ntedious to fill in for generated nodes, so this helper adds these attributes\nrecursively where not already set, by setting them to the values of the parent\nnode. It works recursively starting at node.\n\n"}, {"name": "ast.FloorDiv", "path": "library/ast#ast.FloorDiv", "type": "Language", "text": "\nBinary operator tokens.\n\n"}, {"name": "ast.For", "path": "library/ast#ast.For", "type": "Language", "text": "\nA `for` loop. `target` holds the variable(s) the loop assigns to, as a single\n`Name`, `Tuple` or `List` node. `iter` holds the item to be looped over, again\nas a single node. `body` and `orelse` contain lists of nodes to execute. Those\nin `orelse` are executed if the loop finishes normally, rather than via a\n`break` statement.\n\n"}, {"name": "ast.For.type_comment", "path": "library/ast#ast.For.type_comment", "type": "Language", "text": "\n`type_comment` is an optional string with the type annotation as a comment.\n\n"}, {"name": "ast.FormattedValue", "path": "library/ast#ast.FormattedValue", "type": "Language", "text": "\nNode representing a single formatting field in an f-string. If the string\ncontains a single formatting field and nothing else the node can be isolated\notherwise it appears in `JoinedStr`.\n\n"}, {"name": "ast.FunctionDef", "path": "library/ast#ast.FunctionDef", "type": "Language", "text": "\nA function definition.\n\n"}, {"name": "ast.FunctionDef.type_comment", "path": "library/ast#ast.FunctionDef.type_comment", "type": "Language", "text": "\n`type_comment` is an optional string with the type annotation as a comment.\n\n"}, {"name": "ast.GeneratorExp", "path": "library/ast#ast.GeneratorExp", "type": "Language", "text": "\nList and set comprehensions, generator expressions, and dictionary\ncomprehensions. `elt` (or `key` and `value`) is a single node representing the\npart that will be evaluated for each item.\n\n"}, {"name": "ast.get_docstring()", "path": "library/ast#ast.get_docstring", "type": "Language", "text": "\nReturn the docstring of the given node (which must be a `FunctionDef`,\n`AsyncFunctionDef`, `ClassDef`, or `Module` node), or `None` if it has no\ndocstring. If clean is true, clean up the docstring\u2019s indentation with\n`inspect.cleandoc()`.\n\n"}, {"name": "ast.get_source_segment()", "path": "library/ast#ast.get_source_segment", "type": "Language", "text": "\nGet source code segment of the source that generated node. If some location\ninformation (`lineno`, `end_lineno`, `col_offset`, or `end_col_offset`) is\nmissing, return `None`.\n\n"}, {"name": "ast.Global", "path": "library/ast#ast.Global", "type": "Language", "text": "\n`global` and `nonlocal` statements. `names` is a list of raw strings.\n\n"}, {"name": "ast.Gt", "path": "library/ast#ast.Gt", "type": "Language", "text": "\nComparison operator tokens.\n\n"}, {"name": "ast.GtE", "path": "library/ast#ast.GtE", "type": "Language", "text": "\nComparison operator tokens.\n\n"}, {"name": "ast.If", "path": "library/ast#ast.If", "type": "Language", "text": "\nAn `if` statement. `test` holds a single node, such as a `Compare` node.\n`body` and `orelse` each hold a list of nodes.\n\n"}, {"name": "ast.IfExp", "path": "library/ast#ast.IfExp", "type": "Language", "text": "\nAn expression such as `a if b else c`. Each field holds a single node, so in\nthe following example, all three are `Name` nodes.\n\n"}, {"name": "ast.Import", "path": "library/ast#ast.Import", "type": "Language", "text": "\nAn import statement. `names` is a list of `alias` nodes.\n\n"}, {"name": "ast.ImportFrom", "path": "library/ast#ast.ImportFrom", "type": "Language", "text": "\nRepresents `from x import y`. `module` is a raw string of the \u2018from\u2019 name,\nwithout any leading dots, or `None` for statements such as `from . import\nfoo`. `level` is an integer holding the level of the relative import (0 means\nabsolute import).\n\n"}, {"name": "ast.In", "path": "library/ast#ast.In", "type": "Language", "text": "\nComparison operator tokens.\n\n"}, {"name": "ast.increment_lineno()", "path": "library/ast#ast.increment_lineno", "type": "Language", "text": "\nIncrement the line number and end line number of each node in the tree\nstarting at node by n. This is useful to \u201cmove code\u201d to a different location\nin a file.\n\n"}, {"name": "ast.Invert", "path": "library/ast#ast.Invert", "type": "Language", "text": "\nUnary operator tokens. `Not` is the `not` keyword, `Invert` is the `~`\noperator.\n\n"}, {"name": "ast.Is", "path": "library/ast#ast.Is", "type": "Language", "text": "\nComparison operator tokens.\n\n"}, {"name": "ast.IsNot", "path": "library/ast#ast.IsNot", "type": "Language", "text": "\nComparison operator tokens.\n\n"}, {"name": "ast.iter_child_nodes()", "path": "library/ast#ast.iter_child_nodes", "type": "Language", "text": "\nYield all direct child nodes of node, that is, all fields that are nodes and\nall items of fields that are lists of nodes.\n\n"}, {"name": "ast.iter_fields()", "path": "library/ast#ast.iter_fields", "type": "Language", "text": "\nYield a tuple of `(fieldname, value)` for each field in `node._fields` that is\npresent on node.\n\n"}, {"name": "ast.JoinedStr", "path": "library/ast#ast.JoinedStr", "type": "Language", "text": "\nAn f-string, comprising a series of `FormattedValue` and `Constant` nodes.\n\n"}, {"name": "ast.keyword", "path": "library/ast#ast.keyword", "type": "Language", "text": "\nA keyword argument to a function call or class definition. `arg` is a raw\nstring of the parameter name, `value` is a node to pass in.\n\n"}, {"name": "ast.Lambda", "path": "library/ast#ast.Lambda", "type": "Language", "text": "\n`lambda` is a minimal function definition that can be used inside an\nexpression. Unlike `FunctionDef`, `body` holds a single node.\n\n"}, {"name": "ast.List", "path": "library/ast#ast.List", "type": "Language", "text": "\nA list or tuple. `elts` holds a list of nodes representing the elements. `ctx`\nis `Store` if the container is an assignment target (i.e. `(x,y)=something`),\nand `Load` otherwise.\n\n"}, {"name": "ast.ListComp", "path": "library/ast#ast.ListComp", "type": "Language", "text": "\nList and set comprehensions, generator expressions, and dictionary\ncomprehensions. `elt` (or `key` and `value`) is a single node representing the\npart that will be evaluated for each item.\n\n"}, {"name": "ast.literal_eval()", "path": "library/ast#ast.literal_eval", "type": "Language", "text": "\nSafely evaluate an expression node or a string containing a Python literal or\ncontainer display. The string or node provided may only consist of the\nfollowing Python literal structures: strings, bytes, numbers, tuples, lists,\ndicts, sets, booleans, and `None`.\n\n"}, {"name": "ast.Load", "path": "library/ast#ast.Load", "type": "Language", "text": "\nVariable references can be used to load the value of a variable, to assign a\nnew value to it, or to delete it. Variable references are given a context to\ndistinguish these cases.\n\n"}, {"name": "ast.LShift", "path": "library/ast#ast.LShift", "type": "Language", "text": "\nBinary operator tokens.\n\n"}, {"name": "ast.Lt", "path": "library/ast#ast.Lt", "type": "Language", "text": "\nComparison operator tokens.\n\n"}, {"name": "ast.LtE", "path": "library/ast#ast.LtE", "type": "Language", "text": "\nComparison operator tokens.\n\n"}, {"name": "ast.MatMult", "path": "library/ast#ast.MatMult", "type": "Language", "text": "\nBinary operator tokens.\n\n"}, {"name": "ast.Mod", "path": "library/ast#ast.Mod", "type": "Language", "text": "\nBinary operator tokens.\n\n"}, {"name": "ast.Mult", "path": "library/ast#ast.Mult", "type": "Language", "text": "\nBinary operator tokens.\n\n"}, {"name": "ast.Name", "path": "library/ast#ast.Name", "type": "Language", "text": "\nA variable name. `id` holds the name as a string, and `ctx` is one of the\nfollowing types.\n\n"}, {"name": "ast.NamedExpr", "path": "library/ast#ast.NamedExpr", "type": "Language", "text": "\nA named expression. This AST node is produced by the assignment expressions\noperator (also known as the walrus operator). As opposed to the `Assign` node\nin which the first argument can be multiple nodes, in this case both `target`\nand `value` must be single nodes.\n\n"}, {"name": "ast.NodeTransformer", "path": "library/ast#ast.NodeTransformer", "type": "Language", "text": "\nA `NodeVisitor` subclass that walks the abstract syntax tree and allows\nmodification of nodes.\n\n"}, {"name": "ast.NodeVisitor", "path": "library/ast#ast.NodeVisitor", "type": "Language", "text": "\nA node visitor base class that walks the abstract syntax tree and calls a\nvisitor function for every node found. This function may return a value which\nis forwarded by the `visit()` method.\n\n"}, {"name": "ast.NodeVisitor.generic_visit()", "path": "library/ast#ast.NodeVisitor.generic_visit", "type": "Language", "text": "\nThis visitor calls `visit()` on all children of the node.\n\n"}, {"name": "ast.NodeVisitor.visit()", "path": "library/ast#ast.NodeVisitor.visit", "type": "Language", "text": "\nVisit a node. The default implementation calls the method called\n`self.visit_classname` where classname is the name of the node class, or\n`generic_visit()` if that method doesn\u2019t exist.\n\n"}, {"name": "ast.Nonlocal", "path": "library/ast#ast.Nonlocal", "type": "Language", "text": "\n`global` and `nonlocal` statements. `names` is a list of raw strings.\n\n"}, {"name": "ast.Not", "path": "library/ast#ast.Not", "type": "Language", "text": "\nUnary operator tokens. `Not` is the `not` keyword, `Invert` is the `~`\noperator.\n\n"}, {"name": "ast.NotEq", "path": "library/ast#ast.NotEq", "type": "Language", "text": "\nComparison operator tokens.\n\n"}, {"name": "ast.NotIn", "path": "library/ast#ast.NotIn", "type": "Language", "text": "\nComparison operator tokens.\n\n"}, {"name": "ast.Or", "path": "library/ast#ast.Or", "type": "Language", "text": "\nBoolean operator tokens.\n\n"}, {"name": "ast.parse()", "path": "library/ast#ast.parse", "type": "Language", "text": "\nParse the source into an AST node. Equivalent to `compile(source, filename,\nmode, ast.PyCF_ONLY_AST)`.\n\n"}, {"name": "ast.Pass", "path": "library/ast#ast.Pass", "type": "Language", "text": "\nA `pass` statement.\n\n"}, {"name": "ast.Pow", "path": "library/ast#ast.Pow", "type": "Language", "text": "\nBinary operator tokens.\n\n"}, {"name": "ast.PyCF_ALLOW_TOP_LEVEL_AWAIT", "path": "library/ast#ast.PyCF_ALLOW_TOP_LEVEL_AWAIT", "type": "Language", "text": "\nEnables support for top-level `await`, `async for`, `async with` and async\ncomprehensions.\n\n"}, {"name": "ast.PyCF_ONLY_AST", "path": "library/ast#ast.PyCF_ONLY_AST", "type": "Language", "text": "\nGenerates and returns an abstract syntax tree instead of returning a compiled\ncode object.\n\n"}, {"name": "ast.PyCF_TYPE_COMMENTS", "path": "library/ast#ast.PyCF_TYPE_COMMENTS", "type": "Language", "text": "\nEnables support for PEP 484 and PEP 526 style type comments (`# type: <type>`,\n`# type: ignore <stuff>`).\n\n"}, {"name": "ast.Raise", "path": "library/ast#ast.Raise", "type": "Language", "text": "\nA `raise` statement. `exc` is the exception object to be raised, normally a\n`Call` or `Name`, or `None` for a standalone `raise`. `cause` is the optional\npart for `y` in `raise x from y`.\n\n"}, {"name": "ast.Return", "path": "library/ast#ast.Return", "type": "Language", "text": "\nA `return` statement.\n\n"}, {"name": "ast.RShift", "path": "library/ast#ast.RShift", "type": "Language", "text": "\nBinary operator tokens.\n\n"}, {"name": "ast.Set", "path": "library/ast#ast.Set", "type": "Language", "text": "\nA set. `elts` holds a list of nodes representing the set\u2019s elements.\n\n"}, {"name": "ast.SetComp", "path": "library/ast#ast.SetComp", "type": "Language", "text": "\nList and set comprehensions, generator expressions, and dictionary\ncomprehensions. `elt` (or `key` and `value`) is a single node representing the\npart that will be evaluated for each item.\n\n"}, {"name": "ast.Slice", "path": "library/ast#ast.Slice", "type": "Language", "text": "\nRegular slicing (on the form `lower:upper` or `lower:upper:step`). Can occur\nonly inside the slice field of `Subscript`, either directly or as an element\nof `Tuple`.\n\n"}, {"name": "ast.Starred", "path": "library/ast#ast.Starred", "type": "Language", "text": "\nA `*var` variable reference. `value` holds the variable, typically a `Name`\nnode. This type must be used when building a `Call` node with `*args`.\n\n"}, {"name": "ast.Store", "path": "library/ast#ast.Store", "type": "Language", "text": "\nVariable references can be used to load the value of a variable, to assign a\nnew value to it, or to delete it. Variable references are given a context to\ndistinguish these cases.\n\n"}, {"name": "ast.Sub", "path": "library/ast#ast.Sub", "type": "Language", "text": "\nBinary operator tokens.\n\n"}, {"name": "ast.Subscript", "path": "library/ast#ast.Subscript", "type": "Language", "text": "\nA subscript, such as `l[1]`. `value` is the subscripted object (usually\nsequence or mapping). `slice` is an index, slice or key. It can be a `Tuple`\nand contain a `Slice`. `ctx` is `Load`, `Store` or `Del` according to the\naction performed with the subscript.\n\n"}, {"name": "ast.Try", "path": "library/ast#ast.Try", "type": "Language", "text": "\n`try` blocks. All attributes are list of nodes to execute, except for\n`handlers`, which is a list of `ExceptHandler` nodes.\n\n"}, {"name": "ast.Tuple", "path": "library/ast#ast.Tuple", "type": "Language", "text": "\nA list or tuple. `elts` holds a list of nodes representing the elements. `ctx`\nis `Store` if the container is an assignment target (i.e. `(x,y)=something`),\nand `Load` otherwise.\n\n"}, {"name": "ast.UAdd", "path": "library/ast#ast.UAdd", "type": "Language", "text": "\nUnary operator tokens. `Not` is the `not` keyword, `Invert` is the `~`\noperator.\n\n"}, {"name": "ast.UnaryOp", "path": "library/ast#ast.UnaryOp", "type": "Language", "text": "\nA unary operation. `op` is the operator, and `operand` any expression node.\n\n"}, {"name": "ast.unparse()", "path": "library/ast#ast.unparse", "type": "Language", "text": "\nUnparse an `ast.AST` object and generate a string with code that would produce\nan equivalent `ast.AST` object if parsed back with `ast.parse()`.\n\n"}, {"name": "ast.USub", "path": "library/ast#ast.USub", "type": "Language", "text": "\nUnary operator tokens. `Not` is the `not` keyword, `Invert` is the `~`\noperator.\n\n"}, {"name": "ast.walk()", "path": "library/ast#ast.walk", "type": "Language", "text": "\nRecursively yield all descendant nodes in the tree starting at node (including\nnode itself), in no specified order. This is useful if you only want to modify\nnodes in place and don\u2019t care about the context.\n\n"}, {"name": "ast.While", "path": "library/ast#ast.While", "type": "Language", "text": "\nA `while` loop. `test` holds the condition, such as a `Compare` node.\n\n"}, {"name": "ast.With", "path": "library/ast#ast.With", "type": "Language", "text": "\nA `with` block. `items` is a list of `withitem` nodes representing the context\nmanagers, and `body` is the indented block inside the context.\n\n"}, {"name": "ast.With.type_comment", "path": "library/ast#ast.With.type_comment", "type": "Language", "text": "\n`type_comment` is an optional string with the type annotation as a comment.\n\n"}, {"name": "ast.withitem", "path": "library/ast#ast.withitem", "type": "Language", "text": "\nA single context manager in a `with` block. `context_expr` is the context\nmanager, often a `Call` node. `optional_vars` is a `Name`, `Tuple` or `List`\nfor the `as foo` part, or `None` if that isn\u2019t used.\n\n"}, {"name": "ast.Yield", "path": "library/ast#ast.Yield", "type": "Language", "text": "\nA `yield` or `yield from` expression. Because these are expressions, they must\nbe wrapped in a `Expr` node if the value sent back is not used.\n\n"}, {"name": "ast.YieldFrom", "path": "library/ast#ast.YieldFrom", "type": "Language", "text": "\nA `yield` or `yield from` expression. Because these are expressions, they must\nbe wrapped in a `Expr` node if the value sent back is not used.\n\n"}, {"name": "asynchat", "path": "library/asynchat", "type": "Networking & Interprocess Communication", "text": "\nSource code: Lib/asynchat.py\n\n"}, {"name": "asynchat.async_chat", "path": "library/asynchat#asynchat.async_chat", "type": "Networking & Interprocess Communication", "text": "\nThis class is an abstract subclass of `asyncore.dispatcher`. To make practical\nuse of the code you must subclass `async_chat`, providing meaningful\n`collect_incoming_data()` and `found_terminator()` methods. The\n`asyncore.dispatcher` methods can be used, although not all make sense in a\nmessage/response context.\n\n"}, {"name": "asynchat.async_chat.ac_in_buffer_size", "path": "library/asynchat#asynchat.async_chat.ac_in_buffer_size", "type": "Networking & Interprocess Communication", "text": "\nThe asynchronous input buffer size (default `4096`).\n\n"}, {"name": "asynchat.async_chat.ac_out_buffer_size", "path": "library/asynchat#asynchat.async_chat.ac_out_buffer_size", "type": "Networking & Interprocess Communication", "text": "\nThe asynchronous output buffer size (default `4096`).\n\n"}, {"name": "asynchat.async_chat.close_when_done()", "path": "library/asynchat#asynchat.async_chat.close_when_done", "type": "Networking & Interprocess Communication", "text": "\nPushes a `None` on to the producer queue. When this producer is popped off the\nqueue it causes the channel to be closed.\n\n"}, {"name": "asynchat.async_chat.collect_incoming_data()", "path": "library/asynchat#asynchat.async_chat.collect_incoming_data", "type": "Networking & Interprocess Communication", "text": "\nCalled with data holding an arbitrary amount of received data. The default\nmethod, which must be overridden, raises a `NotImplementedError` exception.\n\n"}, {"name": "asynchat.async_chat.discard_buffers()", "path": "library/asynchat#asynchat.async_chat.discard_buffers", "type": "Networking & Interprocess Communication", "text": "\nIn emergencies this method will discard any data held in the input and/or\noutput buffers and the producer queue.\n\n"}, {"name": "asynchat.async_chat.found_terminator()", "path": "library/asynchat#asynchat.async_chat.found_terminator", "type": "Networking & Interprocess Communication", "text": "\nCalled when the incoming data stream matches the termination condition set by\n`set_terminator()`. The default method, which must be overridden, raises a\n`NotImplementedError` exception. The buffered input data should be available\nvia an instance attribute.\n\n"}, {"name": "asynchat.async_chat.get_terminator()", "path": "library/asynchat#asynchat.async_chat.get_terminator", "type": "Networking & Interprocess Communication", "text": "\nReturns the current terminator for the channel.\n\n"}, {"name": "asynchat.async_chat.push()", "path": "library/asynchat#asynchat.async_chat.push", "type": "Networking & Interprocess Communication", "text": "\nPushes data on to the channel\u2019s queue to ensure its transmission. This is all\nyou need to do to have the channel write the data out to the network, although\nit is possible to use your own producers in more complex schemes to implement\nencryption and chunking, for example.\n\n"}, {"name": "asynchat.async_chat.push_with_producer()", "path": "library/asynchat#asynchat.async_chat.push_with_producer", "type": "Networking & Interprocess Communication", "text": "\nTakes a producer object and adds it to the producer queue associated with the\nchannel. When all currently-pushed producers have been exhausted the channel\nwill consume this producer\u2019s data by calling its `more()` method and send the\ndata to the remote endpoint.\n\n"}, {"name": "asynchat.async_chat.set_terminator()", "path": "library/asynchat#asynchat.async_chat.set_terminator", "type": "Networking & Interprocess Communication", "text": "\nSets the terminating condition to be recognized on the channel. `term` may be\nany of three types of value, corresponding to three different ways to handle\nincoming protocol data.\n\n"}, {"name": "asyncio", "path": "library/asyncio", "type": "Asynchronous I/O", "text": "\nHello World!\n\n"}, {"name": "asyncio.AbstractChildWatcher", "path": "library/asyncio-policy#asyncio.AbstractChildWatcher", "type": "Asynchronous I/O", "text": "\nRegister a new child handler.\n\n"}, {"name": "asyncio.AbstractChildWatcher.add_child_handler()", "path": "library/asyncio-policy#asyncio.AbstractChildWatcher.add_child_handler", "type": "Asynchronous I/O", "text": "\nRegister a new child handler.\n\n"}, {"name": "asyncio.AbstractChildWatcher.attach_loop()", "path": "library/asyncio-policy#asyncio.AbstractChildWatcher.attach_loop", "type": "Asynchronous I/O", "text": "\nAttach the watcher to an event loop.\n\n"}, {"name": "asyncio.AbstractChildWatcher.close()", "path": "library/asyncio-policy#asyncio.AbstractChildWatcher.close", "type": "Asynchronous I/O", "text": "\nClose the watcher.\n\n"}, {"name": "asyncio.AbstractChildWatcher.is_active()", "path": "library/asyncio-policy#asyncio.AbstractChildWatcher.is_active", "type": "Asynchronous I/O", "text": "\nReturn `True` if the watcher is ready to use.\n\n"}, {"name": "asyncio.AbstractChildWatcher.remove_child_handler()", "path": "library/asyncio-policy#asyncio.AbstractChildWatcher.remove_child_handler", "type": "Asynchronous I/O", "text": "\nRemoves the handler for process with PID equal to pid.\n\n"}, {"name": "asyncio.AbstractEventLoop", "path": "library/asyncio-eventloop#asyncio.AbstractEventLoop", "type": "Asynchronous I/O", "text": "\nAbstract base class for asyncio-compliant event loops.\n\n"}, {"name": "asyncio.AbstractEventLoopPolicy", "path": "library/asyncio-policy#asyncio.AbstractEventLoopPolicy", "type": "Asynchronous I/O", "text": "\nAn abstract base class for asyncio policies.\n\n"}, {"name": "asyncio.AbstractEventLoopPolicy.get_child_watcher()", "path": "library/asyncio-policy#asyncio.AbstractEventLoopPolicy.get_child_watcher", "type": "Asynchronous I/O", "text": "\nGet a child process watcher object.\n\n"}, {"name": "asyncio.AbstractEventLoopPolicy.get_event_loop()", "path": "library/asyncio-policy#asyncio.AbstractEventLoopPolicy.get_event_loop", "type": "Asynchronous I/O", "text": "\nGet the event loop for the current context.\n\n"}, {"name": "asyncio.AbstractEventLoopPolicy.new_event_loop()", "path": "library/asyncio-policy#asyncio.AbstractEventLoopPolicy.new_event_loop", "type": "Asynchronous I/O", "text": "\nCreate and return a new event loop object.\n\n"}, {"name": "asyncio.AbstractEventLoopPolicy.set_child_watcher()", "path": "library/asyncio-policy#asyncio.AbstractEventLoopPolicy.set_child_watcher", "type": "Asynchronous I/O", "text": "\nSet the current child process watcher to watcher.\n\n"}, {"name": "asyncio.AbstractEventLoopPolicy.set_event_loop()", "path": "library/asyncio-policy#asyncio.AbstractEventLoopPolicy.set_event_loop", "type": "Asynchronous I/O", "text": "\nSet the event loop for the current context to loop.\n\n"}, {"name": "asyncio.all_tasks()", "path": "library/asyncio-task#asyncio.all_tasks", "type": "Asynchronous I/O", "text": "\nReturn a set of not yet finished `Task` objects run by the loop.\n\n"}, {"name": "asyncio.asyncio.subprocess.DEVNULL", "path": "library/asyncio-subprocess#asyncio.asyncio.subprocess.DEVNULL", "type": "Asynchronous I/O", "text": "\nSpecial value that can be used as the stdin, stdout or stderr argument to\nprocess creation functions. It indicates that the special file `os.devnull`\nwill be used for the corresponding subprocess stream.\n\n"}, {"name": "asyncio.asyncio.subprocess.PIPE", "path": "library/asyncio-subprocess#asyncio.asyncio.subprocess.PIPE", "type": "Asynchronous I/O", "text": "\nCan be passed to the stdin, stdout or stderr parameters.\n\n"}, {"name": "asyncio.asyncio.subprocess.Process", "path": "library/asyncio-subprocess#asyncio.asyncio.subprocess.Process", "type": "Asynchronous I/O", "text": "\nAn object that wraps OS processes created by the `create_subprocess_exec()`\nand `create_subprocess_shell()` functions.\n\n"}, {"name": "asyncio.asyncio.subprocess.Process.communicate()", "path": "library/asyncio-subprocess#asyncio.asyncio.subprocess.Process.communicate", "type": "Asynchronous I/O", "text": "\nInteract with process:\n\n"}, {"name": "asyncio.asyncio.subprocess.Process.kill()", "path": "library/asyncio-subprocess#asyncio.asyncio.subprocess.Process.kill", "type": "Asynchronous I/O", "text": "\nKill the child process.\n\n"}, {"name": "asyncio.asyncio.subprocess.Process.pid", "path": "library/asyncio-subprocess#asyncio.asyncio.subprocess.Process.pid", "type": "Asynchronous I/O", "text": "\nProcess identification number (PID).\n\n"}, {"name": "asyncio.asyncio.subprocess.Process.returncode", "path": "library/asyncio-subprocess#asyncio.asyncio.subprocess.Process.returncode", "type": "Asynchronous I/O", "text": "\nReturn code of the process when it exits.\n\n"}, {"name": "asyncio.asyncio.subprocess.Process.send_signal()", "path": "library/asyncio-subprocess#asyncio.asyncio.subprocess.Process.send_signal", "type": "Asynchronous I/O", "text": "\nSends the signal signal to the child process.\n\n"}, {"name": "asyncio.asyncio.subprocess.Process.stderr", "path": "library/asyncio-subprocess#asyncio.asyncio.subprocess.Process.stderr", "type": "Asynchronous I/O", "text": "\nStandard error stream (`StreamReader`) or `None` if the process was created\nwith `stderr=None`.\n\n"}, {"name": "asyncio.asyncio.subprocess.Process.stdin", "path": "library/asyncio-subprocess#asyncio.asyncio.subprocess.Process.stdin", "type": "Asynchronous I/O", "text": "\nStandard input stream (`StreamWriter`) or `None` if the process was created\nwith `stdin=None`.\n\n"}, {"name": "asyncio.asyncio.subprocess.Process.stdout", "path": "library/asyncio-subprocess#asyncio.asyncio.subprocess.Process.stdout", "type": "Asynchronous I/O", "text": "\nStandard output stream (`StreamReader`) or `None` if the process was created\nwith `stdout=None`.\n\n"}, {"name": "asyncio.asyncio.subprocess.Process.terminate()", "path": "library/asyncio-subprocess#asyncio.asyncio.subprocess.Process.terminate", "type": "Asynchronous I/O", "text": "\nStop the child process.\n\n"}, {"name": "asyncio.asyncio.subprocess.Process.wait()", "path": "library/asyncio-subprocess#asyncio.asyncio.subprocess.Process.wait", "type": "Asynchronous I/O", "text": "\nWait for the child process to terminate.\n\n"}, {"name": "asyncio.asyncio.subprocess.STDOUT", "path": "library/asyncio-subprocess#asyncio.asyncio.subprocess.STDOUT", "type": "Asynchronous I/O", "text": "\nSpecial value that can be used as the stderr argument and indicates that\nstandard error should be redirected into standard output.\n\n"}, {"name": "asyncio.as_completed()", "path": "library/asyncio-task#asyncio.as_completed", "type": "Asynchronous I/O", "text": "\nRun awaitable objects in the aws iterable concurrently. Return an iterator of\ncoroutines. Each coroutine returned can be awaited to get the earliest next\nresult from the iterable of the remaining awaitables.\n\n"}, {"name": "asyncio.BaseProtocol", "path": "library/asyncio-protocol#asyncio.BaseProtocol", "type": "Asynchronous I/O", "text": "\nBase protocol with methods that all protocols share.\n\n"}, {"name": "asyncio.BaseProtocol.connection_lost()", "path": "library/asyncio-protocol#asyncio.BaseProtocol.connection_lost", "type": "Asynchronous I/O", "text": "\nCalled when the connection is lost or closed.\n\n"}, {"name": "asyncio.BaseProtocol.connection_made()", "path": "library/asyncio-protocol#asyncio.BaseProtocol.connection_made", "type": "Asynchronous I/O", "text": "\nCalled when a connection is made.\n\n"}, {"name": "asyncio.BaseProtocol.pause_writing()", "path": "library/asyncio-protocol#asyncio.BaseProtocol.pause_writing", "type": "Asynchronous I/O", "text": "\nCalled when the transport\u2019s buffer goes over the high watermark.\n\n"}, {"name": "asyncio.BaseProtocol.resume_writing()", "path": "library/asyncio-protocol#asyncio.BaseProtocol.resume_writing", "type": "Asynchronous I/O", "text": "\nCalled when the transport\u2019s buffer drains below the low watermark.\n\n"}, {"name": "asyncio.BaseTransport", "path": "library/asyncio-protocol#asyncio.BaseTransport", "type": "Asynchronous I/O", "text": "\nBase class for all transports. Contains methods that all asyncio transports\nshare.\n\n"}, {"name": "asyncio.BaseTransport.close()", "path": "library/asyncio-protocol#asyncio.BaseTransport.close", "type": "Asynchronous I/O", "text": "\nClose the transport.\n\n"}, {"name": "asyncio.BaseTransport.get_extra_info()", "path": "library/asyncio-protocol#asyncio.BaseTransport.get_extra_info", "type": "Asynchronous I/O", "text": "\nReturn information about the transport or underlying resources it uses.\n\n"}, {"name": "asyncio.BaseTransport.get_protocol()", "path": "library/asyncio-protocol#asyncio.BaseTransport.get_protocol", "type": "Asynchronous I/O", "text": "\nReturn the current protocol.\n\n"}, {"name": "asyncio.BaseTransport.is_closing()", "path": "library/asyncio-protocol#asyncio.BaseTransport.is_closing", "type": "Asynchronous I/O", "text": "\nReturn `True` if the transport is closing or is closed.\n\n"}, {"name": "asyncio.BaseTransport.set_protocol()", "path": "library/asyncio-protocol#asyncio.BaseTransport.set_protocol", "type": "Asynchronous I/O", "text": "\nSet a new protocol.\n\n"}, {"name": "asyncio.BoundedSemaphore", "path": "library/asyncio-sync#asyncio.BoundedSemaphore", "type": "Asynchronous I/O", "text": "\nA bounded semaphore object. Not thread-safe.\n\n"}, {"name": "asyncio.BufferedProtocol", "path": "library/asyncio-protocol#asyncio.BufferedProtocol", "type": "Asynchronous I/O", "text": "\nA base class for implementing streaming protocols with manual control of the\nreceive buffer.\n\n"}, {"name": "asyncio.BufferedProtocol.buffer_updated()", "path": "library/asyncio-protocol#asyncio.BufferedProtocol.buffer_updated", "type": "Asynchronous I/O", "text": "\nCalled when the buffer was updated with the received data.\n\n"}, {"name": "asyncio.BufferedProtocol.eof_received()", "path": "library/asyncio-protocol#asyncio.BufferedProtocol.eof_received", "type": "Asynchronous I/O", "text": "\nSee the documentation of the `protocol.eof_received()` method.\n\n"}, {"name": "asyncio.BufferedProtocol.get_buffer()", "path": "library/asyncio-protocol#asyncio.BufferedProtocol.get_buffer", "type": "Asynchronous I/O", "text": "\nCalled to allocate a new receive buffer.\n\n"}, {"name": "asyncio.CancelledError", "path": "library/asyncio-exceptions#asyncio.CancelledError", "type": "Asynchronous I/O", "text": "\nThe operation has been cancelled.\n\n"}, {"name": "asyncio.Condition", "path": "library/asyncio-sync#asyncio.Condition", "type": "Asynchronous I/O", "text": "\nA Condition object. Not thread-safe.\n\n"}, {"name": "asyncio.Condition.acquire()", "path": "library/asyncio-sync#asyncio.Condition.acquire", "type": "Asynchronous I/O", "text": "\nAcquire the underlying lock.\n\n"}, {"name": "asyncio.Condition.locked()", "path": "library/asyncio-sync#asyncio.Condition.locked", "type": "Asynchronous I/O", "text": "\nReturn `True` if the underlying lock is acquired.\n\n"}, {"name": "asyncio.Condition.notify()", "path": "library/asyncio-sync#asyncio.Condition.notify", "type": "Asynchronous I/O", "text": "\nWake up at most n tasks (1 by default) waiting on this condition. The method\nis no-op if no tasks are waiting.\n\n"}, {"name": "asyncio.Condition.notify_all()", "path": "library/asyncio-sync#asyncio.Condition.notify_all", "type": "Asynchronous I/O", "text": "\nWake up all tasks waiting on this condition.\n\n"}, {"name": "asyncio.Condition.release()", "path": "library/asyncio-sync#asyncio.Condition.release", "type": "Asynchronous I/O", "text": "\nRelease the underlying lock.\n\n"}, {"name": "asyncio.Condition.wait()", "path": "library/asyncio-sync#asyncio.Condition.wait", "type": "Asynchronous I/O", "text": "\nWait until notified.\n\n"}, {"name": "asyncio.Condition.wait_for()", "path": "library/asyncio-sync#asyncio.Condition.wait_for", "type": "Asynchronous I/O", "text": "\nWait until a predicate becomes true.\n\n"}, {"name": "asyncio.coroutine()", "path": "library/asyncio-task#asyncio.coroutine", "type": "Asynchronous I/O", "text": "\nDecorator to mark generator-based coroutines.\n\n"}, {"name": "asyncio.create_subprocess_exec()", "path": "library/asyncio-subprocess#asyncio.create_subprocess_exec", "type": "Asynchronous I/O", "text": "\nCreate a subprocess.\n\n"}, {"name": "asyncio.create_subprocess_shell()", "path": "library/asyncio-subprocess#asyncio.create_subprocess_shell", "type": "Asynchronous I/O", "text": "\nRun the cmd shell command.\n\n"}, {"name": "asyncio.create_task()", "path": "library/asyncio-task#asyncio.create_task", "type": "Asynchronous I/O", "text": "\nWrap the coro coroutine into a `Task` and schedule its execution. Return the\nTask object.\n\n"}, {"name": "asyncio.current_task()", "path": "library/asyncio-task#asyncio.current_task", "type": "Asynchronous I/O", "text": "\nReturn the currently running `Task` instance, or `None` if no task is running.\n\n"}, {"name": "asyncio.DatagramProtocol", "path": "library/asyncio-protocol#asyncio.DatagramProtocol", "type": "Asynchronous I/O", "text": "\nThe base class for implementing datagram (UDP) protocols.\n\n"}, {"name": "asyncio.DatagramProtocol.datagram_received()", "path": "library/asyncio-protocol#asyncio.DatagramProtocol.datagram_received", "type": "Asynchronous I/O", "text": "\nCalled when a datagram is received. data is a bytes object containing the\nincoming data. addr is the address of the peer sending the data; the exact\nformat depends on the transport.\n\n"}, {"name": "asyncio.DatagramProtocol.error_received()", "path": "library/asyncio-protocol#asyncio.DatagramProtocol.error_received", "type": "Asynchronous I/O", "text": "\nCalled when a previous send or receive operation raises an `OSError`. exc is\nthe `OSError` instance.\n\n"}, {"name": "asyncio.DatagramTransport", "path": "library/asyncio-protocol#asyncio.DatagramTransport", "type": "Asynchronous I/O", "text": "\nA transport for datagram (UDP) connections.\n\n"}, {"name": "asyncio.DatagramTransport.abort()", "path": "library/asyncio-protocol#asyncio.DatagramTransport.abort", "type": "Asynchronous I/O", "text": "\nClose the transport immediately, without waiting for pending operations to\ncomplete. Buffered data will be lost. No more data will be received. The\nprotocol\u2019s `protocol.connection_lost()` method will eventually be called with\n`None` as its argument.\n\n"}, {"name": "asyncio.DatagramTransport.sendto()", "path": "library/asyncio-protocol#asyncio.DatagramTransport.sendto", "type": "Asynchronous I/O", "text": "\nSend the data bytes to the remote peer given by addr (a transport-dependent\ntarget address). If addr is `None`, the data is sent to the target address\ngiven on transport creation.\n\n"}, {"name": "asyncio.DefaultEventLoopPolicy", "path": "library/asyncio-policy#asyncio.DefaultEventLoopPolicy", "type": "Asynchronous I/O", "text": "\nThe default asyncio policy. Uses `SelectorEventLoop` on Unix and\n`ProactorEventLoop` on Windows.\n\n"}, {"name": "asyncio.ensure_future()", "path": "library/asyncio-future#asyncio.ensure_future", "type": "Asynchronous I/O", "text": "\nReturn:\n\n"}, {"name": "asyncio.Event", "path": "library/asyncio-sync#asyncio.Event", "type": "Asynchronous I/O", "text": "\nAn event object. Not thread-safe.\n\n"}, {"name": "asyncio.Event.clear()", "path": "library/asyncio-sync#asyncio.Event.clear", "type": "Asynchronous I/O", "text": "\nClear (unset) the event.\n\n"}, {"name": "asyncio.Event.is_set()", "path": "library/asyncio-sync#asyncio.Event.is_set", "type": "Asynchronous I/O", "text": "\nReturn `True` if the event is set.\n\n"}, {"name": "asyncio.Event.set()", "path": "library/asyncio-sync#asyncio.Event.set", "type": "Asynchronous I/O", "text": "\nSet the event.\n\n"}, {"name": "asyncio.Event.wait()", "path": "library/asyncio-sync#asyncio.Event.wait", "type": "Asynchronous I/O", "text": "\nWait until the event is set.\n\n"}, {"name": "asyncio.FastChildWatcher", "path": "library/asyncio-policy#asyncio.FastChildWatcher", "type": "Asynchronous I/O", "text": "\nThis implementation reaps every terminated processes by calling\n`os.waitpid(-1)` directly, possibly breaking other code spawning processes and\nwaiting for their termination.\n\n"}, {"name": "asyncio.Future", "path": "library/asyncio-future#asyncio.Future", "type": "Asynchronous I/O", "text": "\nA Future represents an eventual result of an asynchronous operation. Not\nthread-safe.\n\n"}, {"name": "asyncio.Future.add_done_callback()", "path": "library/asyncio-future#asyncio.Future.add_done_callback", "type": "Asynchronous I/O", "text": "\nAdd a callback to be run when the Future is done.\n\n"}, {"name": "asyncio.Future.cancel()", "path": "library/asyncio-future#asyncio.Future.cancel", "type": "Asynchronous I/O", "text": "\nCancel the Future and schedule callbacks.\n\n"}, {"name": "asyncio.Future.cancelled()", "path": "library/asyncio-future#asyncio.Future.cancelled", "type": "Asynchronous I/O", "text": "\nReturn `True` if the Future was cancelled.\n\n"}, {"name": "asyncio.Future.done()", "path": "library/asyncio-future#asyncio.Future.done", "type": "Asynchronous I/O", "text": "\nReturn `True` if the Future is done.\n\n"}, {"name": "asyncio.Future.exception()", "path": "library/asyncio-future#asyncio.Future.exception", "type": "Asynchronous I/O", "text": "\nReturn the exception that was set on this Future.\n\n"}, {"name": "asyncio.Future.get_loop()", "path": "library/asyncio-future#asyncio.Future.get_loop", "type": "Asynchronous I/O", "text": "\nReturn the event loop the Future object is bound to.\n\n"}, {"name": "asyncio.Future.remove_done_callback()", "path": "library/asyncio-future#asyncio.Future.remove_done_callback", "type": "Asynchronous I/O", "text": "\nRemove callback from the callbacks list.\n\n"}, {"name": "asyncio.Future.result()", "path": "library/asyncio-future#asyncio.Future.result", "type": "Asynchronous I/O", "text": "\nReturn the result of the Future.\n\n"}, {"name": "asyncio.Future.set_exception()", "path": "library/asyncio-future#asyncio.Future.set_exception", "type": "Asynchronous I/O", "text": "\nMark the Future as done and set an exception.\n\n"}, {"name": "asyncio.Future.set_result()", "path": "library/asyncio-future#asyncio.Future.set_result", "type": "Asynchronous I/O", "text": "\nMark the Future as done and set its result.\n\n"}, {"name": "asyncio.gather()", "path": "library/asyncio-task#asyncio.gather", "type": "Asynchronous I/O", "text": "\nRun awaitable objects in the aws sequence concurrently.\n\n"}, {"name": "asyncio.get_child_watcher()", "path": "library/asyncio-policy#asyncio.get_child_watcher", "type": "Asynchronous I/O", "text": "\nReturn the current child watcher for the current policy.\n\n"}, {"name": "asyncio.get_event_loop()", "path": "library/asyncio-eventloop#asyncio.get_event_loop", "type": "Asynchronous I/O", "text": "\nGet the current event loop.\n\n"}, {"name": "asyncio.get_event_loop_policy()", "path": "library/asyncio-policy#asyncio.get_event_loop_policy", "type": "Asynchronous I/O", "text": "\nReturn the current process-wide policy.\n\n"}, {"name": "asyncio.get_running_loop()", "path": "library/asyncio-eventloop#asyncio.get_running_loop", "type": "Asynchronous I/O", "text": "\nReturn the running event loop in the current OS thread.\n\n"}, {"name": "asyncio.Handle", "path": "library/asyncio-eventloop#asyncio.Handle", "type": "Asynchronous I/O", "text": "\nA callback wrapper object returned by `loop.call_soon()`,\n`loop.call_soon_threadsafe()`.\n\n"}, {"name": "asyncio.Handle.cancel()", "path": "library/asyncio-eventloop#asyncio.Handle.cancel", "type": "Asynchronous I/O", "text": "\nCancel the callback. If the callback has already been canceled or executed,\nthis method has no effect.\n\n"}, {"name": "asyncio.Handle.cancelled()", "path": "library/asyncio-eventloop#asyncio.Handle.cancelled", "type": "Asynchronous I/O", "text": "\nReturn `True` if the callback was cancelled.\n\n"}, {"name": "asyncio.IncompleteReadError", "path": "library/asyncio-exceptions#asyncio.IncompleteReadError", "type": "Asynchronous I/O", "text": "\nThe requested read operation did not complete fully.\n\n"}, {"name": "asyncio.IncompleteReadError.expected", "path": "library/asyncio-exceptions#asyncio.IncompleteReadError.expected", "type": "Asynchronous I/O", "text": "\nThe total number (`int`) of expected bytes.\n\n"}, {"name": "asyncio.IncompleteReadError.partial", "path": "library/asyncio-exceptions#asyncio.IncompleteReadError.partial", "type": "Asynchronous I/O", "text": "\nA string of `bytes` read before the end of stream was reached.\n\n"}, {"name": "asyncio.InvalidStateError", "path": "library/asyncio-exceptions#asyncio.InvalidStateError", "type": "Asynchronous I/O", "text": "\nInvalid internal state of `Task` or `Future`.\n\n"}, {"name": "asyncio.iscoroutine()", "path": "library/asyncio-task#asyncio.iscoroutine", "type": "Asynchronous I/O", "text": "\nReturn `True` if obj is a coroutine object.\n\n"}, {"name": "asyncio.iscoroutinefunction()", "path": "library/asyncio-task#asyncio.iscoroutinefunction", "type": "Asynchronous I/O", "text": "\nReturn `True` if func is a coroutine function.\n\n"}, {"name": "asyncio.isfuture()", "path": "library/asyncio-future#asyncio.isfuture", "type": "Asynchronous I/O", "text": "\nReturn `True` if obj is either of:\n\n"}, {"name": "asyncio.LifoQueue", "path": "library/asyncio-queue#asyncio.LifoQueue", "type": "Asynchronous I/O", "text": "\nA variant of `Queue` that retrieves most recently added entries first (last\nin, first out).\n\n"}, {"name": "asyncio.LimitOverrunError", "path": "library/asyncio-exceptions#asyncio.LimitOverrunError", "type": "Asynchronous I/O", "text": "\nReached the buffer size limit while looking for a separator.\n\n"}, {"name": "asyncio.LimitOverrunError.consumed", "path": "library/asyncio-exceptions#asyncio.LimitOverrunError.consumed", "type": "Asynchronous I/O", "text": "\nThe total number of to be consumed bytes.\n\n"}, {"name": "asyncio.Lock", "path": "library/asyncio-sync#asyncio.Lock", "type": "Asynchronous I/O", "text": "\nImplements a mutex lock for asyncio tasks. Not thread-safe.\n\n"}, {"name": "asyncio.Lock.acquire()", "path": "library/asyncio-sync#asyncio.Lock.acquire", "type": "Asynchronous I/O", "text": "\nAcquire the lock.\n\n"}, {"name": "asyncio.Lock.locked()", "path": "library/asyncio-sync#asyncio.Lock.locked", "type": "Asynchronous I/O", "text": "\nReturn `True` if the lock is locked.\n\n"}, {"name": "asyncio.Lock.release()", "path": "library/asyncio-sync#asyncio.Lock.release", "type": "Asynchronous I/O", "text": "\nRelease the lock.\n\n"}, {"name": "asyncio.loop.add_reader()", "path": "library/asyncio-eventloop#asyncio.loop.add_reader", "type": "Asynchronous I/O", "text": "\nStart monitoring the fd file descriptor for read availability and invoke\ncallback with the specified arguments once fd is available for reading.\n\n"}, {"name": "asyncio.loop.add_signal_handler()", "path": "library/asyncio-eventloop#asyncio.loop.add_signal_handler", "type": "Asynchronous I/O", "text": "\nSet callback as the handler for the signum signal.\n\n"}, {"name": "asyncio.loop.add_writer()", "path": "library/asyncio-eventloop#asyncio.loop.add_writer", "type": "Asynchronous I/O", "text": "\nStart monitoring the fd file descriptor for write availability and invoke\ncallback with the specified arguments once fd is available for writing.\n\n"}, {"name": "asyncio.loop.call_at()", "path": "library/asyncio-eventloop#asyncio.loop.call_at", "type": "Asynchronous I/O", "text": "\nSchedule callback to be called at the given absolute timestamp when (an int or\na float), using the same time reference as `loop.time()`.\n\n"}, {"name": "asyncio.loop.call_exception_handler()", "path": "library/asyncio-eventloop#asyncio.loop.call_exception_handler", "type": "Asynchronous I/O", "text": "\nCall the current event loop exception handler.\n\n"}, {"name": "asyncio.loop.call_later()", "path": "library/asyncio-eventloop#asyncio.loop.call_later", "type": "Asynchronous I/O", "text": "\nSchedule callback to be called after the given delay number of seconds (can be\neither an int or a float).\n\n"}, {"name": "asyncio.loop.call_soon()", "path": "library/asyncio-eventloop#asyncio.loop.call_soon", "type": "Asynchronous I/O", "text": "\nSchedule the callback callback to be called with args arguments at the next\niteration of the event loop.\n\n"}, {"name": "asyncio.loop.call_soon_threadsafe()", "path": "library/asyncio-eventloop#asyncio.loop.call_soon_threadsafe", "type": "Asynchronous I/O", "text": "\nA thread-safe variant of `call_soon()`. Must be used to schedule callbacks\nfrom another thread.\n\n"}, {"name": "asyncio.loop.close()", "path": "library/asyncio-eventloop#asyncio.loop.close", "type": "Asynchronous I/O", "text": "\nClose the event loop.\n\n"}, {"name": "asyncio.loop.connect_accepted_socket()", "path": "library/asyncio-eventloop#asyncio.loop.connect_accepted_socket", "type": "Asynchronous I/O", "text": "\nWrap an already accepted connection into a transport/protocol pair.\n\n"}, {"name": "asyncio.loop.connect_read_pipe()", "path": "library/asyncio-eventloop#asyncio.loop.connect_read_pipe", "type": "Asynchronous I/O", "text": "\nRegister the read end of pipe in the event loop.\n\n"}, {"name": "asyncio.loop.connect_write_pipe()", "path": "library/asyncio-eventloop#asyncio.loop.connect_write_pipe", "type": "Asynchronous I/O", "text": "\nRegister the write end of pipe in the event loop.\n\n"}, {"name": "asyncio.loop.create_connection()", "path": "library/asyncio-eventloop#asyncio.loop.create_connection", "type": "Asynchronous I/O", "text": "\nOpen a streaming transport connection to a given address specified by host and\nport.\n\n"}, {"name": "asyncio.loop.create_datagram_endpoint()", "path": "library/asyncio-eventloop#asyncio.loop.create_datagram_endpoint", "type": "Asynchronous I/O", "text": "\nNote\n\n"}, {"name": "asyncio.loop.create_future()", "path": "library/asyncio-eventloop#asyncio.loop.create_future", "type": "Asynchronous I/O", "text": "\nCreate an `asyncio.Future` object attached to the event loop.\n\n"}, {"name": "asyncio.loop.create_server()", "path": "library/asyncio-eventloop#asyncio.loop.create_server", "type": "Asynchronous I/O", "text": "\nCreate a TCP server (socket type `SOCK_STREAM`) listening on port of the host\naddress.\n\n"}, {"name": "asyncio.loop.create_task()", "path": "library/asyncio-eventloop#asyncio.loop.create_task", "type": "Asynchronous I/O", "text": "\nSchedule the execution of a Coroutines. Return a `Task` object.\n\n"}, {"name": "asyncio.loop.create_unix_connection()", "path": "library/asyncio-eventloop#asyncio.loop.create_unix_connection", "type": "Asynchronous I/O", "text": "\nCreate a Unix connection.\n\n"}, {"name": "asyncio.loop.create_unix_server()", "path": "library/asyncio-eventloop#asyncio.loop.create_unix_server", "type": "Asynchronous I/O", "text": "\nSimilar to `loop.create_server()` but works with the `AF_UNIX` socket family.\n\n"}, {"name": "asyncio.loop.default_exception_handler()", "path": "library/asyncio-eventloop#asyncio.loop.default_exception_handler", "type": "Asynchronous I/O", "text": "\nDefault exception handler.\n\n"}, {"name": "asyncio.loop.getaddrinfo()", "path": "library/asyncio-eventloop#asyncio.loop.getaddrinfo", "type": "Asynchronous I/O", "text": "\nAsynchronous version of `socket.getaddrinfo()`.\n\n"}, {"name": "asyncio.loop.getnameinfo()", "path": "library/asyncio-eventloop#asyncio.loop.getnameinfo", "type": "Asynchronous I/O", "text": "\nAsynchronous version of `socket.getnameinfo()`.\n\n"}, {"name": "asyncio.loop.get_debug()", "path": "library/asyncio-eventloop#asyncio.loop.get_debug", "type": "Asynchronous I/O", "text": "\nGet the debug mode (`bool`) of the event loop.\n\n"}, {"name": "asyncio.loop.get_exception_handler()", "path": "library/asyncio-eventloop#asyncio.loop.get_exception_handler", "type": "Asynchronous I/O", "text": "\nReturn the current exception handler, or `None` if no custom exception handler\nwas set.\n\n"}, {"name": "asyncio.loop.get_task_factory()", "path": "library/asyncio-eventloop#asyncio.loop.get_task_factory", "type": "Asynchronous I/O", "text": "\nReturn a task factory or `None` if the default one is in use.\n\n"}, {"name": "asyncio.loop.is_closed()", "path": "library/asyncio-eventloop#asyncio.loop.is_closed", "type": "Asynchronous I/O", "text": "\nReturn `True` if the event loop was closed.\n\n"}, {"name": "asyncio.loop.is_running()", "path": "library/asyncio-eventloop#asyncio.loop.is_running", "type": "Asynchronous I/O", "text": "\nReturn `True` if the event loop is currently running.\n\n"}, {"name": "asyncio.loop.remove_reader()", "path": "library/asyncio-eventloop#asyncio.loop.remove_reader", "type": "Asynchronous I/O", "text": "\nStop monitoring the fd file descriptor for read availability.\n\n"}, {"name": "asyncio.loop.remove_signal_handler()", "path": "library/asyncio-eventloop#asyncio.loop.remove_signal_handler", "type": "Asynchronous I/O", "text": "\nRemove the handler for the sig signal.\n\n"}, {"name": "asyncio.loop.remove_writer()", "path": "library/asyncio-eventloop#asyncio.loop.remove_writer", "type": "Asynchronous I/O", "text": "\nStop monitoring the fd file descriptor for write availability.\n\n"}, {"name": "asyncio.loop.run_forever()", "path": "library/asyncio-eventloop#asyncio.loop.run_forever", "type": "Asynchronous I/O", "text": "\nRun the event loop until `stop()` is called.\n\n"}, {"name": "asyncio.loop.run_in_executor()", "path": "library/asyncio-eventloop#asyncio.loop.run_in_executor", "type": "Asynchronous I/O", "text": "\nArrange for func to be called in the specified executor.\n\n"}, {"name": "asyncio.loop.run_until_complete()", "path": "library/asyncio-eventloop#asyncio.loop.run_until_complete", "type": "Asynchronous I/O", "text": "\nRun until the future (an instance of `Future`) has completed.\n\n"}, {"name": "asyncio.loop.sendfile()", "path": "library/asyncio-eventloop#asyncio.loop.sendfile", "type": "Asynchronous I/O", "text": "\nSend a file over a transport. Return the total number of bytes sent.\n\n"}, {"name": "asyncio.loop.set_debug()", "path": "library/asyncio-eventloop#asyncio.loop.set_debug", "type": "Asynchronous I/O", "text": "\nSet the debug mode of the event loop.\n\n"}, {"name": "asyncio.loop.set_default_executor()", "path": "library/asyncio-eventloop#asyncio.loop.set_default_executor", "type": "Asynchronous I/O", "text": "\nSet executor as the default executor used by `run_in_executor()`. executor\nshould be an instance of `ThreadPoolExecutor`.\n\n"}, {"name": "asyncio.loop.set_exception_handler()", "path": "library/asyncio-eventloop#asyncio.loop.set_exception_handler", "type": "Asynchronous I/O", "text": "\nSet handler as the new event loop exception handler.\n\n"}, {"name": "asyncio.loop.set_task_factory()", "path": "library/asyncio-eventloop#asyncio.loop.set_task_factory", "type": "Asynchronous I/O", "text": "\nSet a task factory that will be used by `loop.create_task()`.\n\n"}, {"name": "asyncio.loop.shutdown_asyncgens()", "path": "library/asyncio-eventloop#asyncio.loop.shutdown_asyncgens", "type": "Asynchronous I/O", "text": "\nSchedule all currently open asynchronous generator objects to close with an\n`aclose()` call. After calling this method, the event loop will issue a\nwarning if a new asynchronous generator is iterated. This should be used to\nreliably finalize all scheduled asynchronous generators.\n\n"}, {"name": "asyncio.loop.shutdown_default_executor()", "path": "library/asyncio-eventloop#asyncio.loop.shutdown_default_executor", "type": "Asynchronous I/O", "text": "\nSchedule the closure of the default executor and wait for it to join all of\nthe threads in the `ThreadPoolExecutor`. After calling this method, a\n`RuntimeError` will be raised if `loop.run_in_executor()` is called while\nusing the default executor.\n\n"}, {"name": "asyncio.loop.sock_accept()", "path": "library/asyncio-eventloop#asyncio.loop.sock_accept", "type": "Asynchronous I/O", "text": "\nAccept a connection. Modeled after the blocking `socket.accept()` method.\n\n"}, {"name": "asyncio.loop.sock_connect()", "path": "library/asyncio-eventloop#asyncio.loop.sock_connect", "type": "Asynchronous I/O", "text": "\nConnect sock to a remote socket at address.\n\n"}, {"name": "asyncio.loop.sock_recv()", "path": "library/asyncio-eventloop#asyncio.loop.sock_recv", "type": "Asynchronous I/O", "text": "\nReceive up to nbytes from sock. Asynchronous version of `socket.recv()`.\n\n"}, {"name": "asyncio.loop.sock_recv_into()", "path": "library/asyncio-eventloop#asyncio.loop.sock_recv_into", "type": "Asynchronous I/O", "text": "\nReceive data from sock into the buf buffer. Modeled after the blocking\n`socket.recv_into()` method.\n\n"}, {"name": "asyncio.loop.sock_sendall()", "path": "library/asyncio-eventloop#asyncio.loop.sock_sendall", "type": "Asynchronous I/O", "text": "\nSend data to the sock socket. Asynchronous version of `socket.sendall()`.\n\n"}, {"name": "asyncio.loop.sock_sendfile()", "path": "library/asyncio-eventloop#asyncio.loop.sock_sendfile", "type": "Asynchronous I/O", "text": "\nSend a file using high-performance `os.sendfile` if possible. Return the total\nnumber of bytes sent.\n\n"}, {"name": "asyncio.loop.start_tls()", "path": "library/asyncio-eventloop#asyncio.loop.start_tls", "type": "Asynchronous I/O", "text": "\nUpgrade an existing transport-based connection to TLS.\n\n"}, {"name": "asyncio.loop.stop()", "path": "library/asyncio-eventloop#asyncio.loop.stop", "type": "Asynchronous I/O", "text": "\nStop the event loop.\n\n"}, {"name": "asyncio.loop.subprocess_exec()", "path": "library/asyncio-eventloop#asyncio.loop.subprocess_exec", "type": "Asynchronous I/O", "text": "\nCreate a subprocess from one or more string arguments specified by args.\n\n"}, {"name": "asyncio.loop.subprocess_shell()", "path": "library/asyncio-eventloop#asyncio.loop.subprocess_shell", "type": "Asynchronous I/O", "text": "\nCreate a subprocess from cmd, which can be a `str` or a `bytes` string encoded\nto the filesystem encoding, using the platform\u2019s \u201cshell\u201d syntax.\n\n"}, {"name": "asyncio.loop.time()", "path": "library/asyncio-eventloop#asyncio.loop.time", "type": "Asynchronous I/O", "text": "\nReturn the current time, as a `float` value, according to the event loop\u2019s\ninternal monotonic clock.\n\n"}, {"name": "asyncio.MultiLoopChildWatcher", "path": "library/asyncio-policy#asyncio.MultiLoopChildWatcher", "type": "Asynchronous I/O", "text": "\nThis implementation registers a `SIGCHLD` signal handler on instantiation.\nThat can break third-party code that installs a custom handler for `SIGCHLD`\nsignal.\n\n"}, {"name": "asyncio.new_event_loop()", "path": "library/asyncio-eventloop#asyncio.new_event_loop", "type": "Asynchronous I/O", "text": "\nCreate a new event loop object.\n\n"}, {"name": "asyncio.open_connection()", "path": "library/asyncio-stream#asyncio.open_connection", "type": "Asynchronous I/O", "text": "\nEstablish a network connection and return a pair of `(reader, writer)`\nobjects.\n\n"}, {"name": "asyncio.open_unix_connection()", "path": "library/asyncio-stream#asyncio.open_unix_connection", "type": "Asynchronous I/O", "text": "\nEstablish a Unix socket connection and return a pair of `(reader, writer)`.\n\n"}, {"name": "asyncio.PidfdChildWatcher", "path": "library/asyncio-policy#asyncio.PidfdChildWatcher", "type": "Asynchronous I/O", "text": "\nThis implementation polls process file descriptors (pidfds) to await child\nprocess termination. In some respects, `PidfdChildWatcher` is a \u201cGoldilocks\u201d\nchild watcher implementation. It doesn\u2019t require signals or threads, doesn\u2019t\ninterfere with any processes launched outside the event loop, and scales\nlinearly with the number of subprocesses launched by the event loop. The main\ndisadvantage is that pidfds are specific to Linux, and only work on recent\n(5.3+) kernels.\n\n"}, {"name": "asyncio.PriorityQueue", "path": "library/asyncio-queue#asyncio.PriorityQueue", "type": "Asynchronous I/O", "text": "\nA variant of `Queue`; retrieves entries in priority order (lowest first).\n\n"}, {"name": "asyncio.ProactorEventLoop", "path": "library/asyncio-eventloop#asyncio.ProactorEventLoop", "type": "Asynchronous I/O", "text": "\nAn event loop for Windows that uses \u201cI/O Completion Ports\u201d (IOCP).\n\n"}, {"name": "asyncio.Protocol", "path": "library/asyncio-protocol#asyncio.Protocol", "type": "Asynchronous I/O", "text": "\nThe base class for implementing streaming protocols (TCP, Unix sockets, etc).\n\n"}, {"name": "asyncio.Protocol.data_received()", "path": "library/asyncio-protocol#asyncio.Protocol.data_received", "type": "Asynchronous I/O", "text": "\nCalled when some data is received. data is a non-empty bytes object containing\nthe incoming data.\n\n"}, {"name": "asyncio.Protocol.eof_received()", "path": "library/asyncio-protocol#asyncio.Protocol.eof_received", "type": "Asynchronous I/O", "text": "\nCalled when the other end signals it won\u2019t send any more data (for example by\ncalling `transport.write_eof()`, if the other end also uses asyncio).\n\n"}, {"name": "asyncio.Queue", "path": "library/asyncio-queue#asyncio.Queue", "type": "Asynchronous I/O", "text": "\nA first in, first out (FIFO) queue.\n\n"}, {"name": "asyncio.Queue.empty()", "path": "library/asyncio-queue#asyncio.Queue.empty", "type": "Asynchronous I/O", "text": "\nReturn `True` if the queue is empty, `False` otherwise.\n\n"}, {"name": "asyncio.Queue.full()", "path": "library/asyncio-queue#asyncio.Queue.full", "type": "Asynchronous I/O", "text": "\nReturn `True` if there are `maxsize` items in the queue.\n\n"}, {"name": "asyncio.Queue.get()", "path": "library/asyncio-queue#asyncio.Queue.get", "type": "Asynchronous I/O", "text": "\nRemove and return an item from the queue. If queue is empty, wait until an\nitem is available.\n\n"}, {"name": "asyncio.Queue.get_nowait()", "path": "library/asyncio-queue#asyncio.Queue.get_nowait", "type": "Asynchronous I/O", "text": "\nReturn an item if one is immediately available, else raise `QueueEmpty`.\n\n"}, {"name": "asyncio.Queue.join()", "path": "library/asyncio-queue#asyncio.Queue.join", "type": "Asynchronous I/O", "text": "\nBlock until all items in the queue have been received and processed.\n\n"}, {"name": "asyncio.Queue.maxsize", "path": "library/asyncio-queue#asyncio.Queue.maxsize", "type": "Asynchronous I/O", "text": "\nNumber of items allowed in the queue.\n\n"}, {"name": "asyncio.Queue.put()", "path": "library/asyncio-queue#asyncio.Queue.put", "type": "Asynchronous I/O", "text": "\nPut an item into the queue. If the queue is full, wait until a free slot is\navailable before adding the item.\n\n"}, {"name": "asyncio.Queue.put_nowait()", "path": "library/asyncio-queue#asyncio.Queue.put_nowait", "type": "Asynchronous I/O", "text": "\nPut an item into the queue without blocking.\n\n"}, {"name": "asyncio.Queue.qsize()", "path": "library/asyncio-queue#asyncio.Queue.qsize", "type": "Asynchronous I/O", "text": "\nReturn the number of items in the queue.\n\n"}, {"name": "asyncio.Queue.task_done()", "path": "library/asyncio-queue#asyncio.Queue.task_done", "type": "Asynchronous I/O", "text": "\nIndicate that a formerly enqueued task is complete.\n\n"}, {"name": "asyncio.QueueEmpty", "path": "library/asyncio-queue#asyncio.QueueEmpty", "type": "Asynchronous I/O", "text": "\nThis exception is raised when the `get_nowait()` method is called on an empty\nqueue.\n\n"}, {"name": "asyncio.QueueFull", "path": "library/asyncio-queue#asyncio.QueueFull", "type": "Asynchronous I/O", "text": "\nException raised when the `put_nowait()` method is called on a queue that has\nreached its maxsize.\n\n"}, {"name": "asyncio.ReadTransport", "path": "library/asyncio-protocol#asyncio.ReadTransport", "type": "Asynchronous I/O", "text": "\nA base transport for read-only connections.\n\n"}, {"name": "asyncio.ReadTransport.is_reading()", "path": "library/asyncio-protocol#asyncio.ReadTransport.is_reading", "type": "Asynchronous I/O", "text": "\nReturn `True` if the transport is receiving new data.\n\n"}, {"name": "asyncio.ReadTransport.pause_reading()", "path": "library/asyncio-protocol#asyncio.ReadTransport.pause_reading", "type": "Asynchronous I/O", "text": "\nPause the receiving end of the transport. No data will be passed to the\nprotocol\u2019s `protocol.data_received()` method until `resume_reading()` is\ncalled.\n\n"}, {"name": "asyncio.ReadTransport.resume_reading()", "path": "library/asyncio-protocol#asyncio.ReadTransport.resume_reading", "type": "Asynchronous I/O", "text": "\nResume the receiving end. The protocol\u2019s `protocol.data_received()` method\nwill be called once again if some data is available for reading.\n\n"}, {"name": "asyncio.run()", "path": "library/asyncio-task#asyncio.run", "type": "Asynchronous I/O", "text": "\nExecute the coroutine coro and return the result.\n\n"}, {"name": "asyncio.run_coroutine_threadsafe()", "path": "library/asyncio-task#asyncio.run_coroutine_threadsafe", "type": "Asynchronous I/O", "text": "\nSubmit a coroutine to the given event loop. Thread-safe.\n\n"}, {"name": "asyncio.SafeChildWatcher", "path": "library/asyncio-policy#asyncio.SafeChildWatcher", "type": "Asynchronous I/O", "text": "\nThis implementation uses active event loop from the main thread to handle\n`SIGCHLD` signal. If the main thread has no running event loop another thread\ncannot spawn a subprocess (`RuntimeError` is raised).\n\n"}, {"name": "asyncio.SelectorEventLoop", "path": "library/asyncio-eventloop#asyncio.SelectorEventLoop", "type": "Asynchronous I/O", "text": "\nAn event loop based on the `selectors` module.\n\n"}, {"name": "asyncio.Semaphore", "path": "library/asyncio-sync#asyncio.Semaphore", "type": "Asynchronous I/O", "text": "\nA Semaphore object. Not thread-safe.\n\n"}, {"name": "asyncio.Semaphore.acquire()", "path": "library/asyncio-sync#asyncio.Semaphore.acquire", "type": "Asynchronous I/O", "text": "\nAcquire a semaphore.\n\n"}, {"name": "asyncio.Semaphore.locked()", "path": "library/asyncio-sync#asyncio.Semaphore.locked", "type": "Asynchronous I/O", "text": "\nReturns `True` if semaphore can not be acquired immediately.\n\n"}, {"name": "asyncio.Semaphore.release()", "path": "library/asyncio-sync#asyncio.Semaphore.release", "type": "Asynchronous I/O", "text": "\nRelease a semaphore, incrementing the internal counter by one. Can wake up a\ntask waiting to acquire the semaphore.\n\n"}, {"name": "asyncio.SendfileNotAvailableError", "path": "library/asyncio-exceptions#asyncio.SendfileNotAvailableError", "type": "Asynchronous I/O", "text": "\nThe \u201csendfile\u201d syscall is not available for the given socket or file type.\n\n"}, {"name": "asyncio.Server", "path": "library/asyncio-eventloop#asyncio.Server", "type": "Asynchronous I/O", "text": "\nServer objects are asynchronous context managers. When used in an `async with`\nstatement, it\u2019s guaranteed that the Server object is closed and not accepting\nnew connections when the `async with` statement is completed:\n\n"}, {"name": "asyncio.Server.close()", "path": "library/asyncio-eventloop#asyncio.Server.close", "type": "Asynchronous I/O", "text": "\nStop serving: close listening sockets and set the `sockets` attribute to\n`None`.\n\n"}, {"name": "asyncio.Server.get_loop()", "path": "library/asyncio-eventloop#asyncio.Server.get_loop", "type": "Asynchronous I/O", "text": "\nReturn the event loop associated with the server object.\n\n"}, {"name": "asyncio.Server.is_serving()", "path": "library/asyncio-eventloop#asyncio.Server.is_serving", "type": "Asynchronous I/O", "text": "\nReturn `True` if the server is accepting new connections.\n\n"}, {"name": "asyncio.Server.serve_forever()", "path": "library/asyncio-eventloop#asyncio.Server.serve_forever", "type": "Asynchronous I/O", "text": "\nStart accepting connections until the coroutine is cancelled. Cancellation of\n`serve_forever` task causes the server to be closed.\n\n"}, {"name": "asyncio.Server.sockets", "path": "library/asyncio-eventloop#asyncio.Server.sockets", "type": "Asynchronous I/O", "text": "\nList of `socket.socket` objects the server is listening on.\n\n"}, {"name": "asyncio.Server.start_serving()", "path": "library/asyncio-eventloop#asyncio.Server.start_serving", "type": "Asynchronous I/O", "text": "\nStart accepting connections.\n\n"}, {"name": "asyncio.Server.wait_closed()", "path": "library/asyncio-eventloop#asyncio.Server.wait_closed", "type": "Asynchronous I/O", "text": "\nWait until the `close()` method completes.\n\n"}, {"name": "asyncio.set_child_watcher()", "path": "library/asyncio-policy#asyncio.set_child_watcher", "type": "Asynchronous I/O", "text": "\nSet the current child watcher to watcher for the current policy. watcher must\nimplement methods defined in the `AbstractChildWatcher` base class.\n\n"}, {"name": "asyncio.set_event_loop()", "path": "library/asyncio-eventloop#asyncio.set_event_loop", "type": "Asynchronous I/O", "text": "\nSet loop as a current event loop for the current OS thread.\n\n"}, {"name": "asyncio.set_event_loop_policy()", "path": "library/asyncio-policy#asyncio.set_event_loop_policy", "type": "Asynchronous I/O", "text": "\nSet the current process-wide policy to policy.\n\n"}, {"name": "asyncio.shield()", "path": "library/asyncio-task#asyncio.shield", "type": "Asynchronous I/O", "text": "\nProtect an awaitable object from being `cancelled`.\n\n"}, {"name": "asyncio.sleep()", "path": "library/asyncio-task#asyncio.sleep", "type": "Asynchronous I/O", "text": "\nBlock for delay seconds.\n\n"}, {"name": "asyncio.start_server()", "path": "library/asyncio-stream#asyncio.start_server", "type": "Asynchronous I/O", "text": "\nStart a socket server.\n\n"}, {"name": "asyncio.start_unix_server()", "path": "library/asyncio-stream#asyncio.start_unix_server", "type": "Asynchronous I/O", "text": "\nStart a Unix socket server.\n\n"}, {"name": "asyncio.StreamReader", "path": "library/asyncio-stream#asyncio.StreamReader", "type": "Asynchronous I/O", "text": "\nRepresents a reader object that provides APIs to read data from the IO stream.\n\n"}, {"name": "asyncio.StreamReader.at_eof()", "path": "library/asyncio-stream#asyncio.StreamReader.at_eof", "type": "Asynchronous I/O", "text": "\nReturn `True` if the buffer is empty and `feed_eof()` was called.\n\n"}, {"name": "asyncio.StreamReader.read()", "path": "library/asyncio-stream#asyncio.StreamReader.read", "type": "Asynchronous I/O", "text": "\nRead up to n bytes. If n is not provided, or set to `-1`, read until EOF and\nreturn all read bytes.\n\n"}, {"name": "asyncio.StreamReader.readexactly()", "path": "library/asyncio-stream#asyncio.StreamReader.readexactly", "type": "Asynchronous I/O", "text": "\nRead exactly n bytes.\n\n"}, {"name": "asyncio.StreamReader.readline()", "path": "library/asyncio-stream#asyncio.StreamReader.readline", "type": "Asynchronous I/O", "text": "\nRead one line, where \u201cline\u201d is a sequence of bytes ending with `\\n`.\n\n"}, {"name": "asyncio.StreamReader.readuntil()", "path": "library/asyncio-stream#asyncio.StreamReader.readuntil", "type": "Asynchronous I/O", "text": "\nRead data from the stream until separator is found.\n\n"}, {"name": "asyncio.StreamWriter", "path": "library/asyncio-stream#asyncio.StreamWriter", "type": "Asynchronous I/O", "text": "\nRepresents a writer object that provides APIs to write data to the IO stream.\n\n"}, {"name": "asyncio.StreamWriter.can_write_eof()", "path": "library/asyncio-stream#asyncio.StreamWriter.can_write_eof", "type": "Asynchronous I/O", "text": "\nReturn `True` if the underlying transport supports the `write_eof()` method,\n`False` otherwise.\n\n"}, {"name": "asyncio.StreamWriter.close()", "path": "library/asyncio-stream#asyncio.StreamWriter.close", "type": "Asynchronous I/O", "text": "\nThe method closes the stream and the underlying socket.\n\n"}, {"name": "asyncio.StreamWriter.drain()", "path": "library/asyncio-stream#asyncio.StreamWriter.drain", "type": "Asynchronous I/O", "text": "\nWait until it is appropriate to resume writing to the stream. Example:\n\n"}, {"name": "asyncio.StreamWriter.get_extra_info()", "path": "library/asyncio-stream#asyncio.StreamWriter.get_extra_info", "type": "Asynchronous I/O", "text": "\nAccess optional transport information; see `BaseTransport.get_extra_info()`\nfor details.\n\n"}, {"name": "asyncio.StreamWriter.is_closing()", "path": "library/asyncio-stream#asyncio.StreamWriter.is_closing", "type": "Asynchronous I/O", "text": "\nReturn `True` if the stream is closed or in the process of being closed.\n\n"}, {"name": "asyncio.StreamWriter.transport", "path": "library/asyncio-stream#asyncio.StreamWriter.transport", "type": "Asynchronous I/O", "text": "\nReturn the underlying asyncio transport.\n\n"}, {"name": "asyncio.StreamWriter.wait_closed()", "path": "library/asyncio-stream#asyncio.StreamWriter.wait_closed", "type": "Asynchronous I/O", "text": "\nWait until the stream is closed.\n\n"}, {"name": "asyncio.StreamWriter.write()", "path": "library/asyncio-stream#asyncio.StreamWriter.write", "type": "Asynchronous I/O", "text": "\nThe method attempts to write the data to the underlying socket immediately. If\nthat fails, the data is queued in an internal write buffer until it can be\nsent.\n\n"}, {"name": "asyncio.StreamWriter.writelines()", "path": "library/asyncio-stream#asyncio.StreamWriter.writelines", "type": "Asynchronous I/O", "text": "\nThe method writes a list (or any iterable) of bytes to the underlying socket\nimmediately. If that fails, the data is queued in an internal write buffer\nuntil it can be sent.\n\n"}, {"name": "asyncio.StreamWriter.write_eof()", "path": "library/asyncio-stream#asyncio.StreamWriter.write_eof", "type": "Asynchronous I/O", "text": "\nClose the write end of the stream after the buffered write data is flushed.\n\n"}, {"name": "asyncio.SubprocessProtocol", "path": "library/asyncio-protocol#asyncio.SubprocessProtocol", "type": "Asynchronous I/O", "text": "\nThe base class for implementing protocols communicating with child processes\n(unidirectional pipes).\n\n"}, {"name": "asyncio.SubprocessProtocol.pipe_connection_lost()", "path": "library/asyncio-protocol#asyncio.SubprocessProtocol.pipe_connection_lost", "type": "Asynchronous I/O", "text": "\nCalled when one of the pipes communicating with the child process is closed.\n\n"}, {"name": "asyncio.SubprocessProtocol.pipe_data_received()", "path": "library/asyncio-protocol#asyncio.SubprocessProtocol.pipe_data_received", "type": "Asynchronous I/O", "text": "\nCalled when the child process writes data into its stdout or stderr pipe.\n\n"}, {"name": "asyncio.SubprocessProtocol.process_exited()", "path": "library/asyncio-protocol#asyncio.SubprocessProtocol.process_exited", "type": "Asynchronous I/O", "text": "\nCalled when the child process has exited.\n\n"}, {"name": "asyncio.SubprocessTransport", "path": "library/asyncio-protocol#asyncio.SubprocessTransport", "type": "Asynchronous I/O", "text": "\nAn abstraction to represent a connection between a parent and its child OS\nprocess.\n\n"}, {"name": "asyncio.SubprocessTransport.close()", "path": "library/asyncio-protocol#asyncio.SubprocessTransport.close", "type": "Asynchronous I/O", "text": "\nKill the subprocess by calling the `kill()` method.\n\n"}, {"name": "asyncio.SubprocessTransport.get_pid()", "path": "library/asyncio-protocol#asyncio.SubprocessTransport.get_pid", "type": "Asynchronous I/O", "text": "\nReturn the subprocess process id as an integer.\n\n"}, {"name": "asyncio.SubprocessTransport.get_pipe_transport()", "path": "library/asyncio-protocol#asyncio.SubprocessTransport.get_pipe_transport", "type": "Asynchronous I/O", "text": "\nReturn the transport for the communication pipe corresponding to the integer\nfile descriptor fd:\n\n"}, {"name": "asyncio.SubprocessTransport.get_returncode()", "path": "library/asyncio-protocol#asyncio.SubprocessTransport.get_returncode", "type": "Asynchronous I/O", "text": "\nReturn the subprocess return code as an integer or `None` if it hasn\u2019t\nreturned, which is similar to the `subprocess.Popen.returncode` attribute.\n\n"}, {"name": "asyncio.SubprocessTransport.kill()", "path": "library/asyncio-protocol#asyncio.SubprocessTransport.kill", "type": "Asynchronous I/O", "text": "\nKill the subprocess.\n\n"}, {"name": "asyncio.SubprocessTransport.send_signal()", "path": "library/asyncio-protocol#asyncio.SubprocessTransport.send_signal", "type": "Asynchronous I/O", "text": "\nSend the signal number to the subprocess, as in\n`subprocess.Popen.send_signal()`.\n\n"}, {"name": "asyncio.SubprocessTransport.terminate()", "path": "library/asyncio-protocol#asyncio.SubprocessTransport.terminate", "type": "Asynchronous I/O", "text": "\nStop the subprocess.\n\n"}, {"name": "asyncio.Task", "path": "library/asyncio-task#asyncio.Task", "type": "Asynchronous I/O", "text": "\nA `Future-like` object that runs a Python coroutine. Not thread-safe.\n\n"}, {"name": "asyncio.Task.add_done_callback()", "path": "library/asyncio-task#asyncio.Task.add_done_callback", "type": "Asynchronous I/O", "text": "\nAdd a callback to be run when the Task is done.\n\n"}, {"name": "asyncio.Task.cancel()", "path": "library/asyncio-task#asyncio.Task.cancel", "type": "Asynchronous I/O", "text": "\nRequest the Task to be cancelled.\n\n"}, {"name": "asyncio.Task.cancelled()", "path": "library/asyncio-task#asyncio.Task.cancelled", "type": "Asynchronous I/O", "text": "\nReturn `True` if the Task is cancelled.\n\n"}, {"name": "asyncio.Task.done()", "path": "library/asyncio-task#asyncio.Task.done", "type": "Asynchronous I/O", "text": "\nReturn `True` if the Task is done.\n\n"}, {"name": "asyncio.Task.exception()", "path": "library/asyncio-task#asyncio.Task.exception", "type": "Asynchronous I/O", "text": "\nReturn the exception of the Task.\n\n"}, {"name": "asyncio.Task.get_coro()", "path": "library/asyncio-task#asyncio.Task.get_coro", "type": "Asynchronous I/O", "text": "\nReturn the coroutine object wrapped by the `Task`.\n\n"}, {"name": "asyncio.Task.get_name()", "path": "library/asyncio-task#asyncio.Task.get_name", "type": "Asynchronous I/O", "text": "\nReturn the name of the Task.\n\n"}, {"name": "asyncio.Task.get_stack()", "path": "library/asyncio-task#asyncio.Task.get_stack", "type": "Asynchronous I/O", "text": "\nReturn the list of stack frames for this Task.\n\n"}, {"name": "asyncio.Task.print_stack()", "path": "library/asyncio-task#asyncio.Task.print_stack", "type": "Asynchronous I/O", "text": "\nPrint the stack or traceback for this Task.\n\n"}, {"name": "asyncio.Task.remove_done_callback()", "path": "library/asyncio-task#asyncio.Task.remove_done_callback", "type": "Asynchronous I/O", "text": "\nRemove callback from the callbacks list.\n\n"}, {"name": "asyncio.Task.result()", "path": "library/asyncio-task#asyncio.Task.result", "type": "Asynchronous I/O", "text": "\nReturn the result of the Task.\n\n"}, {"name": "asyncio.Task.set_name()", "path": "library/asyncio-task#asyncio.Task.set_name", "type": "Asynchronous I/O", "text": "\nSet the name of the Task.\n\n"}, {"name": "asyncio.ThreadedChildWatcher", "path": "library/asyncio-policy#asyncio.ThreadedChildWatcher", "type": "Asynchronous I/O", "text": "\nThis implementation starts a new waiting thread for every subprocess spawn.\n\n"}, {"name": "asyncio.TimeoutError", "path": "library/asyncio-exceptions#asyncio.TimeoutError", "type": "Asynchronous I/O", "text": "\nThe operation has exceeded the given deadline.\n\n"}, {"name": "asyncio.TimerHandle", "path": "library/asyncio-eventloop#asyncio.TimerHandle", "type": "Asynchronous I/O", "text": "\nA callback wrapper object returned by `loop.call_later()`, and\n`loop.call_at()`.\n\n"}, {"name": "asyncio.TimerHandle.when()", "path": "library/asyncio-eventloop#asyncio.TimerHandle.when", "type": "Asynchronous I/O", "text": "\nReturn a scheduled callback time as `float` seconds.\n\n"}, {"name": "asyncio.to_thread()", "path": "library/asyncio-task#asyncio.to_thread", "type": "Asynchronous I/O", "text": "\nAsynchronously run function func in a separate thread.\n\n"}, {"name": "asyncio.Transport", "path": "library/asyncio-protocol#asyncio.Transport", "type": "Asynchronous I/O", "text": "\nInterface representing a bidirectional transport, such as a TCP connection.\n\n"}, {"name": "asyncio.wait()", "path": "library/asyncio-task#asyncio.wait", "type": "Asynchronous I/O", "text": "\nRun awaitable objects in the aws iterable concurrently and block until the\ncondition specified by return_when.\n\n"}, {"name": "asyncio.wait_for()", "path": "library/asyncio-task#asyncio.wait_for", "type": "Asynchronous I/O", "text": "\nWait for the aw awaitable to complete with a timeout.\n\n"}, {"name": "asyncio.WindowsProactorEventLoopPolicy", "path": "library/asyncio-policy#asyncio.WindowsProactorEventLoopPolicy", "type": "Asynchronous I/O", "text": "\nAn alternative event loop policy that uses the `ProactorEventLoop` event loop\nimplementation.\n\n"}, {"name": "asyncio.WindowsSelectorEventLoopPolicy", "path": "library/asyncio-policy#asyncio.WindowsSelectorEventLoopPolicy", "type": "Asynchronous I/O", "text": "\nAn alternative event loop policy that uses the `SelectorEventLoop` event loop\nimplementation.\n\n"}, {"name": "asyncio.wrap_future()", "path": "library/asyncio-future#asyncio.wrap_future", "type": "Asynchronous I/O", "text": "\nWrap a `concurrent.futures.Future` object in a `asyncio.Future` object.\n\n"}, {"name": "asyncio.WriteTransport", "path": "library/asyncio-protocol#asyncio.WriteTransport", "type": "Asynchronous I/O", "text": "\nA base transport for write-only connections.\n\n"}, {"name": "asyncio.WriteTransport.abort()", "path": "library/asyncio-protocol#asyncio.WriteTransport.abort", "type": "Asynchronous I/O", "text": "\nClose the transport immediately, without waiting for pending operations to\ncomplete. Buffered data will be lost. No more data will be received. The\nprotocol\u2019s `protocol.connection_lost()` method will eventually be called with\n`None` as its argument.\n\n"}, {"name": "asyncio.WriteTransport.can_write_eof()", "path": "library/asyncio-protocol#asyncio.WriteTransport.can_write_eof", "type": "Asynchronous I/O", "text": "\nReturn `True` if the transport supports `write_eof()`, `False` if not.\n\n"}, {"name": "asyncio.WriteTransport.get_write_buffer_limits()", "path": "library/asyncio-protocol#asyncio.WriteTransport.get_write_buffer_limits", "type": "Asynchronous I/O", "text": "\nGet the high and low watermarks for write flow control. Return a tuple `(low,\nhigh)` where low and high are positive number of bytes.\n\n"}, {"name": "asyncio.WriteTransport.get_write_buffer_size()", "path": "library/asyncio-protocol#asyncio.WriteTransport.get_write_buffer_size", "type": "Asynchronous I/O", "text": "\nReturn the current size of the output buffer used by the transport.\n\n"}, {"name": "asyncio.WriteTransport.set_write_buffer_limits()", "path": "library/asyncio-protocol#asyncio.WriteTransport.set_write_buffer_limits", "type": "Asynchronous I/O", "text": "\nSet the high and low watermarks for write flow control.\n\n"}, {"name": "asyncio.WriteTransport.write()", "path": "library/asyncio-protocol#asyncio.WriteTransport.write", "type": "Asynchronous I/O", "text": "\nWrite some data bytes to the transport.\n\n"}, {"name": "asyncio.WriteTransport.writelines()", "path": "library/asyncio-protocol#asyncio.WriteTransport.writelines", "type": "Asynchronous I/O", "text": "\nWrite a list (or any iterable) of data bytes to the transport. This is\nfunctionally equivalent to calling `write()` on each element yielded by the\niterable, but may be implemented more efficiently.\n\n"}, {"name": "asyncio.WriteTransport.write_eof()", "path": "library/asyncio-protocol#asyncio.WriteTransport.write_eof", "type": "Asynchronous I/O", "text": "\nClose the write end of the transport after flushing all buffered data. Data\nmay still be received.\n\n"}, {"name": "asyncore", "path": "library/asyncore", "type": "Networking & Interprocess Communication", "text": "\nSource code: Lib/asyncore.py\n\n"}, {"name": "asyncore.dispatcher", "path": "library/asyncore#asyncore.dispatcher", "type": "Networking & Interprocess Communication", "text": "\nThe `dispatcher` class is a thin wrapper around a low-level socket object. To\nmake it more useful, it has a few methods for event-handling which are called\nfrom the asynchronous loop. Otherwise, it can be treated as a normal non-\nblocking socket object.\n\n"}, {"name": "asyncore.dispatcher.accept()", "path": "library/asyncore#asyncore.dispatcher.accept", "type": "Networking & Interprocess Communication", "text": "\nAccept a connection. The socket must be bound to an address and listening for\nconnections. The return value can be either `None` or a pair `(conn, address)`\nwhere conn is a new socket object usable to send and receive data on the\nconnection, and address is the address bound to the socket on the other end of\nthe connection. When `None` is returned it means the connection didn\u2019t take\nplace, in which case the server should just ignore this event and keep\nlistening for further incoming connections.\n\n"}, {"name": "asyncore.dispatcher.bind()", "path": "library/asyncore#asyncore.dispatcher.bind", "type": "Networking & Interprocess Communication", "text": "\nBind the socket to address. The socket must not already be bound. (The format\nof address depends on the address family \u2014 refer to the `socket` documentation\nfor more information.) To mark the socket as re-usable (setting the\n`SO_REUSEADDR` option), call the `dispatcher` object\u2019s `set_reuse_addr()`\nmethod.\n\n"}, {"name": "asyncore.dispatcher.close()", "path": "library/asyncore#asyncore.dispatcher.close", "type": "Networking & Interprocess Communication", "text": "\nClose the socket. All future operations on the socket object will fail. The\nremote end-point will receive no more data (after queued data is flushed).\nSockets are automatically closed when they are garbage-collected.\n\n"}, {"name": "asyncore.dispatcher.connect()", "path": "library/asyncore#asyncore.dispatcher.connect", "type": "Networking & Interprocess Communication", "text": "\nAs with the normal socket object, address is a tuple with the first element\nthe host to connect to, and the second the port number.\n\n"}, {"name": "asyncore.dispatcher.create_socket()", "path": "library/asyncore#asyncore.dispatcher.create_socket", "type": "Networking & Interprocess Communication", "text": "\nThis is identical to the creation of a normal socket, and will use the same\noptions for creation. Refer to the `socket` documentation for information on\ncreating sockets.\n\n"}, {"name": "asyncore.dispatcher.handle_accept()", "path": "library/asyncore#asyncore.dispatcher.handle_accept", "type": "Networking & Interprocess Communication", "text": "\nCalled on listening channels (passive openers) when a connection can be\nestablished with a new remote endpoint that has issued a `connect()` call for\nthe local endpoint. Deprecated in version 3.2; use `handle_accepted()`\ninstead.\n\n"}, {"name": "asyncore.dispatcher.handle_accepted()", "path": "library/asyncore#asyncore.dispatcher.handle_accepted", "type": "Networking & Interprocess Communication", "text": "\nCalled on listening channels (passive openers) when a connection has been\nestablished with a new remote endpoint that has issued a `connect()` call for\nthe local endpoint. sock is a new socket object usable to send and receive\ndata on the connection, and addr is the address bound to the socket on the\nother end of the connection.\n\n"}, {"name": "asyncore.dispatcher.handle_close()", "path": "library/asyncore#asyncore.dispatcher.handle_close", "type": "Networking & Interprocess Communication", "text": "\nCalled when the socket is closed.\n\n"}, {"name": "asyncore.dispatcher.handle_connect()", "path": "library/asyncore#asyncore.dispatcher.handle_connect", "type": "Networking & Interprocess Communication", "text": "\nCalled when the active opener\u2019s socket actually makes a connection. Might send\na \u201cwelcome\u201d banner, or initiate a protocol negotiation with the remote\nendpoint, for example.\n\n"}, {"name": "asyncore.dispatcher.handle_error()", "path": "library/asyncore#asyncore.dispatcher.handle_error", "type": "Networking & Interprocess Communication", "text": "\nCalled when an exception is raised and not otherwise handled. The default\nversion prints a condensed traceback.\n\n"}, {"name": "asyncore.dispatcher.handle_expt()", "path": "library/asyncore#asyncore.dispatcher.handle_expt", "type": "Networking & Interprocess Communication", "text": "\nCalled when there is out of band (OOB) data for a socket connection. This will\nalmost never happen, as OOB is tenuously supported and rarely used.\n\n"}, {"name": "asyncore.dispatcher.handle_read()", "path": "library/asyncore#asyncore.dispatcher.handle_read", "type": "Networking & Interprocess Communication", "text": "\nCalled when the asynchronous loop detects that a `read()` call on the\nchannel\u2019s socket will succeed.\n\n"}, {"name": "asyncore.dispatcher.handle_write()", "path": "library/asyncore#asyncore.dispatcher.handle_write", "type": "Networking & Interprocess Communication", "text": "\nCalled when the asynchronous loop detects that a writable socket can be\nwritten. Often this method will implement the necessary buffering for\nperformance. For example:\n\n"}, {"name": "asyncore.dispatcher.listen()", "path": "library/asyncore#asyncore.dispatcher.listen", "type": "Networking & Interprocess Communication", "text": "\nListen for connections made to the socket. The backlog argument specifies the\nmaximum number of queued connections and should be at least 1; the maximum\nvalue is system-dependent (usually 5).\n\n"}, {"name": "asyncore.dispatcher.readable()", "path": "library/asyncore#asyncore.dispatcher.readable", "type": "Networking & Interprocess Communication", "text": "\nCalled each time around the asynchronous loop to determine whether a channel\u2019s\nsocket should be added to the list on which read events can occur. The default\nmethod simply returns `True`, indicating that by default, all channels will be\ninterested in read events.\n\n"}, {"name": "asyncore.dispatcher.recv()", "path": "library/asyncore#asyncore.dispatcher.recv", "type": "Networking & Interprocess Communication", "text": "\nRead at most buffer_size bytes from the socket\u2019s remote end-point. An empty\nbytes object implies that the channel has been closed from the other end.\n\n"}, {"name": "asyncore.dispatcher.send()", "path": "library/asyncore#asyncore.dispatcher.send", "type": "Networking & Interprocess Communication", "text": "\nSend data to the remote end-point of the socket.\n\n"}, {"name": "asyncore.dispatcher.writable()", "path": "library/asyncore#asyncore.dispatcher.writable", "type": "Networking & Interprocess Communication", "text": "\nCalled each time around the asynchronous loop to determine whether a channel\u2019s\nsocket should be added to the list on which write events can occur. The\ndefault method simply returns `True`, indicating that by default, all channels\nwill be interested in write events.\n\n"}, {"name": "asyncore.dispatcher_with_send", "path": "library/asyncore#asyncore.dispatcher_with_send", "type": "Networking & Interprocess Communication", "text": "\nA `dispatcher` subclass which adds simple buffered output capability, useful\nfor simple clients. For more sophisticated usage use `asynchat.async_chat`.\n\n"}, {"name": "asyncore.file_dispatcher", "path": "library/asyncore#asyncore.file_dispatcher", "type": "Networking & Interprocess Communication", "text": "\nA file_dispatcher takes a file descriptor or file object along with an\noptional map argument and wraps it for use with the `poll()` or `loop()`\nfunctions. If provided a file object or anything with a `fileno()` method,\nthat method will be called and passed to the `file_wrapper` constructor.\n\n"}, {"name": "asyncore.file_wrapper", "path": "library/asyncore#asyncore.file_wrapper", "type": "Networking & Interprocess Communication", "text": "\nA file_wrapper takes an integer file descriptor and calls `os.dup()` to\nduplicate the handle so that the original handle may be closed independently\nof the file_wrapper. This class implements sufficient methods to emulate a\nsocket for use by the `file_dispatcher` class.\n\n"}, {"name": "asyncore.loop()", "path": "library/asyncore#asyncore.loop", "type": "Networking & Interprocess Communication", "text": "\nEnter a polling loop that terminates after count passes or all open channels\nhave been closed. All arguments are optional. The count parameter defaults to\n`None`, resulting in the loop terminating only when all channels have been\nclosed. The timeout argument sets the timeout parameter for the appropriate\n`select()` or `poll()` call, measured in seconds; the default is 30 seconds.\nThe use_poll parameter, if true, indicates that `poll()` should be used in\npreference to `select()` (the default is `False`).\n\n"}, {"name": "atexit", "path": "library/atexit", "type": "Runtime", "text": "\nThe `atexit` module defines functions to register and unregister cleanup\nfunctions. Functions thus registered are automatically executed upon normal\ninterpreter termination. `atexit` runs these functions in the reverse order in\nwhich they were registered; if you register `A`, `B`, and `C`, at interpreter\ntermination time they will be run in the order `C`, `B`, `A`.\n\n"}, {"name": "atexit.register()", "path": "library/atexit#atexit.register", "type": "Runtime", "text": "\nRegister func as a function to be executed at termination. Any optional\narguments that are to be passed to func must be passed as arguments to\n`register()`. It is possible to register the same function and arguments more\nthan once.\n\n"}, {"name": "atexit.unregister()", "path": "library/atexit#atexit.unregister", "type": "Runtime", "text": "\nRemove func from the list of functions to be run at interpreter shutdown.\nAfter calling `unregister()`, func is guaranteed not to be called when the\ninterpreter shuts down, even if it was registered more than once.\n`unregister()` silently does nothing if func was not previously registered.\n\n"}, {"name": "AttributeError", "path": "library/exceptions#AttributeError", "type": "Built-in Exceptions", "text": "\nRaised when an attribute reference (see Attribute references) or assignment\nfails. (When an object does not support attribute references or attribute\nassignments at all, `TypeError` is raised.)\n\n"}, {"name": "audioop", "path": "library/audioop", "type": "Multimedia", "text": "\nThe `audioop` module contains some useful operations on sound fragments. It\noperates on sound fragments consisting of signed integer samples 8, 16, 24 or\n32 bits wide, stored in bytes-like objects. All scalar items are integers,\nunless specified otherwise.\n\n"}, {"name": "audioop.add()", "path": "library/audioop#audioop.add", "type": "Multimedia", "text": "\nReturn a fragment which is the addition of the two samples passed as\nparameters. width is the sample width in bytes, either `1`, `2`, `3` or `4`.\nBoth fragments should have the same length. Samples are truncated in case of\noverflow.\n\n"}, {"name": "audioop.adpcm2lin()", "path": "library/audioop#audioop.adpcm2lin", "type": "Multimedia", "text": "\nDecode an Intel/DVI ADPCM coded fragment to a linear fragment. See the\ndescription of `lin2adpcm()` for details on ADPCM coding. Return a tuple\n`(sample, newstate)` where the sample has the width specified in width.\n\n"}, {"name": "audioop.alaw2lin()", "path": "library/audioop#audioop.alaw2lin", "type": "Multimedia", "text": "\nConvert sound fragments in a-LAW encoding to linearly encoded sound fragments.\na-LAW encoding always uses 8 bits samples, so width refers only to the sample\nwidth of the output fragment here.\n\n"}, {"name": "audioop.avg()", "path": "library/audioop#audioop.avg", "type": "Multimedia", "text": "\nReturn the average over all samples in the fragment.\n\n"}, {"name": "audioop.avgpp()", "path": "library/audioop#audioop.avgpp", "type": "Multimedia", "text": "\nReturn the average peak-peak value over all samples in the fragment. No\nfiltering is done, so the usefulness of this routine is questionable.\n\n"}, {"name": "audioop.bias()", "path": "library/audioop#audioop.bias", "type": "Multimedia", "text": "\nReturn a fragment that is the original fragment with a bias added to each\nsample. Samples wrap around in case of overflow.\n\n"}, {"name": "audioop.byteswap()", "path": "library/audioop#audioop.byteswap", "type": "Multimedia", "text": "\n\u201cByteswap\u201d all samples in a fragment and returns the modified fragment.\nConverts big-endian samples to little-endian and vice versa.\n\n"}, {"name": "audioop.cross()", "path": "library/audioop#audioop.cross", "type": "Multimedia", "text": "\nReturn the number of zero crossings in the fragment passed as an argument.\n\n"}, {"name": "audioop.error", "path": "library/audioop#audioop.error", "type": "Multimedia", "text": "\nThis exception is raised on all errors, such as unknown number of bytes per\nsample, etc.\n\n"}, {"name": "audioop.findfactor()", "path": "library/audioop#audioop.findfactor", "type": "Multimedia", "text": "\nReturn a factor F such that `rms(add(fragment, mul(reference, -F)))` is\nminimal, i.e., return the factor with which you should multiply reference to\nmake it match as well as possible to fragment. The fragments should both\ncontain 2-byte samples.\n\n"}, {"name": "audioop.findfit()", "path": "library/audioop#audioop.findfit", "type": "Multimedia", "text": "\nTry to match reference as well as possible to a portion of fragment (which\nshould be the longer fragment). This is (conceptually) done by taking slices\nout of fragment, using `findfactor()` to compute the best match, and\nminimizing the result. The fragments should both contain 2-byte samples.\nReturn a tuple `(offset, factor)` where offset is the (integer) offset into\nfragment where the optimal match started and factor is the (floating-point)\nfactor as per `findfactor()`.\n\n"}, {"name": "audioop.findmax()", "path": "library/audioop#audioop.findmax", "type": "Multimedia", "text": "\nSearch fragment for a slice of length length samples (not bytes!) with maximum\nenergy, i.e., return i for which `rms(fragment[i*2:(i+length)*2])` is maximal.\nThe fragments should both contain 2-byte samples.\n\n"}, {"name": "audioop.getsample()", "path": "library/audioop#audioop.getsample", "type": "Multimedia", "text": "\nReturn the value of sample index from the fragment.\n\n"}, {"name": "audioop.lin2adpcm()", "path": "library/audioop#audioop.lin2adpcm", "type": "Multimedia", "text": "\nConvert samples to 4 bit Intel/DVI ADPCM encoding. ADPCM coding is an adaptive\ncoding scheme, whereby each 4 bit number is the difference between one sample\nand the next, divided by a (varying) step. The Intel/DVI ADPCM algorithm has\nbeen selected for use by the IMA, so it may well become a standard.\n\n"}, {"name": "audioop.lin2alaw()", "path": "library/audioop#audioop.lin2alaw", "type": "Multimedia", "text": "\nConvert samples in the audio fragment to a-LAW encoding and return this as a\nbytes object. a-LAW is an audio encoding format whereby you get a dynamic\nrange of about 13 bits using only 8 bit samples. It is used by the Sun audio\nhardware, among others.\n\n"}, {"name": "audioop.lin2lin()", "path": "library/audioop#audioop.lin2lin", "type": "Multimedia", "text": "\nConvert samples between 1-, 2-, 3- and 4-byte formats.\n\n"}, {"name": "audioop.lin2ulaw()", "path": "library/audioop#audioop.lin2ulaw", "type": "Multimedia", "text": "\nConvert samples in the audio fragment to u-LAW encoding and return this as a\nbytes object. u-LAW is an audio encoding format whereby you get a dynamic\nrange of about 14 bits using only 8 bit samples. It is used by the Sun audio\nhardware, among others.\n\n"}, {"name": "audioop.max()", "path": "library/audioop#audioop.max", "type": "Multimedia", "text": "\nReturn the maximum of the absolute value of all samples in a fragment.\n\n"}, {"name": "audioop.maxpp()", "path": "library/audioop#audioop.maxpp", "type": "Multimedia", "text": "\nReturn the maximum peak-peak value in the sound fragment.\n\n"}, {"name": "audioop.minmax()", "path": "library/audioop#audioop.minmax", "type": "Multimedia", "text": "\nReturn a tuple consisting of the minimum and maximum values of all samples in\nthe sound fragment.\n\n"}, {"name": "audioop.mul()", "path": "library/audioop#audioop.mul", "type": "Multimedia", "text": "\nReturn a fragment that has all samples in the original fragment multiplied by\nthe floating-point value factor. Samples are truncated in case of overflow.\n\n"}, {"name": "audioop.ratecv()", "path": "library/audioop#audioop.ratecv", "type": "Multimedia", "text": "\nConvert the frame rate of the input fragment.\n\n"}, {"name": "audioop.reverse()", "path": "library/audioop#audioop.reverse", "type": "Multimedia", "text": "\nReverse the samples in a fragment and returns the modified fragment.\n\n"}, {"name": "audioop.rms()", "path": "library/audioop#audioop.rms", "type": "Multimedia", "text": "\nReturn the root-mean-square of the fragment, i.e. `sqrt(sum(S_i^2)/n)`.\n\n"}, {"name": "audioop.tomono()", "path": "library/audioop#audioop.tomono", "type": "Multimedia", "text": "\nConvert a stereo fragment to a mono fragment. The left channel is multiplied\nby lfactor and the right channel by rfactor before adding the two channels to\ngive a mono signal.\n\n"}, {"name": "audioop.tostereo()", "path": "library/audioop#audioop.tostereo", "type": "Multimedia", "text": "\nGenerate a stereo fragment from a mono fragment. Each pair of samples in the\nstereo fragment are computed from the mono sample, whereby left channel\nsamples are multiplied by lfactor and right channel samples by rfactor.\n\n"}, {"name": "audioop.ulaw2lin()", "path": "library/audioop#audioop.ulaw2lin", "type": "Multimedia", "text": "\nConvert sound fragments in u-LAW encoding to linearly encoded sound fragments.\nu-LAW encoding always uses 8 bits samples, so width refers only to the sample\nwidth of the output fragment here.\n\n"}, {"name": "Audit events table", "path": "library/audit_events", "type": "Debugging & Profiling", "text": "\nThis table contains all events raised by `sys.audit()` or `PySys_Audit()`\ncalls throughout the CPython runtime and the standard library. These calls\nwere added in 3.8.0 or later.\n\n"}, {"name": "base64", "path": "library/base64", "type": "Internet Data", "text": "\nSource code: Lib/base64.py\n\n"}, {"name": "base64.a85decode()", "path": "library/base64#base64.a85decode", "type": "Internet Data", "text": "\nDecode the Ascii85 encoded bytes-like object or ASCII string b and return the\ndecoded `bytes`.\n\n"}, {"name": "base64.a85encode()", "path": "library/base64#base64.a85encode", "type": "Internet Data", "text": "\nEncode the bytes-like object b using Ascii85 and return the encoded `bytes`.\n\n"}, {"name": "base64.b16decode()", "path": "library/base64#base64.b16decode", "type": "Internet Data", "text": "\nDecode the Base16 encoded bytes-like object or ASCII string s and return the\ndecoded `bytes`.\n\n"}, {"name": "base64.b16encode()", "path": "library/base64#base64.b16encode", "type": "Internet Data", "text": "\nEncode the bytes-like object s using Base16 and return the encoded `bytes`.\n\n"}, {"name": "base64.b32decode()", "path": "library/base64#base64.b32decode", "type": "Internet Data", "text": "\nDecode the Base32 encoded bytes-like object or ASCII string s and return the\ndecoded `bytes`.\n\n"}, {"name": "base64.b32encode()", "path": "library/base64#base64.b32encode", "type": "Internet Data", "text": "\nEncode the bytes-like object s using Base32 and return the encoded `bytes`.\n\n"}, {"name": "base64.b64decode()", "path": "library/base64#base64.b64decode", "type": "Internet Data", "text": "\nDecode the Base64 encoded bytes-like object or ASCII string s and return the\ndecoded `bytes`.\n\n"}, {"name": "base64.b64encode()", "path": "library/base64#base64.b64encode", "type": "Internet Data", "text": "\nEncode the bytes-like object s using Base64 and return the encoded `bytes`.\n\n"}, {"name": "base64.b85decode()", "path": "library/base64#base64.b85decode", "type": "Internet Data", "text": "\nDecode the base85-encoded bytes-like object or ASCII string b and return the\ndecoded `bytes`. Padding is implicitly removed, if necessary.\n\n"}, {"name": "base64.b85encode()", "path": "library/base64#base64.b85encode", "type": "Internet Data", "text": "\nEncode the bytes-like object b using base85 (as used in e.g. git-style binary\ndiffs) and return the encoded `bytes`.\n\n"}, {"name": "base64.decode()", "path": "library/base64#base64.decode", "type": "Internet Data", "text": "\nDecode the contents of the binary input file and write the resulting binary\ndata to the output file. input and output must be file objects. input will be\nread until `input.readline()` returns an empty bytes object.\n\n"}, {"name": "base64.decodebytes()", "path": "library/base64#base64.decodebytes", "type": "Internet Data", "text": "\nDecode the bytes-like object s, which must contain one or more lines of base64\nencoded data, and return the decoded `bytes`.\n\n"}, {"name": "base64.encode()", "path": "library/base64#base64.encode", "type": "Internet Data", "text": "\nEncode the contents of the binary input file and write the resulting base64\nencoded data to the output file. input and output must be file objects. input\nwill be read until `input.read()` returns an empty bytes object. `encode()`\ninserts a newline character (`b'\\n'`) after every 76 bytes of the output, as\nwell as ensuring that the output always ends with a newline, as per RFC 2045\n(MIME).\n\n"}, {"name": "base64.encodebytes()", "path": "library/base64#base64.encodebytes", "type": "Internet Data", "text": "\nEncode the bytes-like object s, which can contain arbitrary binary data, and\nreturn `bytes` containing the base64-encoded data, with newlines (`b'\\n'`)\ninserted after every 76 bytes of output, and ensuring that there is a trailing\nnewline, as per RFC 2045 (MIME).\n\n"}, {"name": "base64.standard_b64decode()", "path": "library/base64#base64.standard_b64decode", "type": "Internet Data", "text": "\nDecode bytes-like object or ASCII string s using the standard Base64 alphabet\nand return the decoded `bytes`.\n\n"}, {"name": "base64.standard_b64encode()", "path": "library/base64#base64.standard_b64encode", "type": "Internet Data", "text": "\nEncode bytes-like object s using the standard Base64 alphabet and return the\nencoded `bytes`.\n\n"}, {"name": "base64.urlsafe_b64decode()", "path": "library/base64#base64.urlsafe_b64decode", "type": "Internet Data", "text": "\nDecode bytes-like object or ASCII string s using the URL- and filesystem-safe\nalphabet, which substitutes `-` instead of `+` and `_` instead of `/` in the\nstandard Base64 alphabet, and return the decoded `bytes`.\n\n"}, {"name": "base64.urlsafe_b64encode()", "path": "library/base64#base64.urlsafe_b64encode", "type": "Internet Data", "text": "\nEncode bytes-like object s using the URL- and filesystem-safe alphabet, which\nsubstitutes `-` instead of `+` and `_` instead of `/` in the standard Base64\nalphabet, and return the encoded `bytes`. The result can still contain `=`.\n\n"}, {"name": "BaseException", "path": "library/exceptions#BaseException", "type": "Built-in Exceptions", "text": "\nThe base class for all built-in exceptions. It is not meant to be directly\ninherited by user-defined classes (for that, use `Exception`). If `str()` is\ncalled on an instance of this class, the representation of the argument(s) to\nthe instance are returned, or the empty string when there were no arguments.\n\n"}, {"name": "BaseException.args", "path": "library/exceptions#BaseException.args", "type": "Built-in Exceptions", "text": "\nThe tuple of arguments given to the exception constructor. Some built-in\nexceptions (like `OSError`) expect a certain number of arguments and assign a\nspecial meaning to the elements of this tuple, while others are usually called\nonly with a single string giving an error message.\n\n"}, {"name": "BaseException.with_traceback()", "path": "library/exceptions#BaseException.with_traceback", "type": "Built-in Exceptions", "text": "\nThis method sets tb as the new traceback for the exception and returns the\nexception object. It is usually used in exception handling code like this:\n\n"}, {"name": "bdb", "path": "library/bdb", "type": "Debugging & Profiling", "text": "\nSource code: Lib/bdb.py\n\n"}, {"name": "bdb.Bdb", "path": "library/bdb#bdb.Bdb", "type": "Debugging & Profiling", "text": "\nThe `Bdb` class acts as a generic Python debugger base class.\n\n"}, {"name": "bdb.Bdb.break_anywhere()", "path": "library/bdb#bdb.Bdb.break_anywhere", "type": "Debugging & Profiling", "text": "\nThis method checks if there is a breakpoint in the filename of the current\nframe.\n\n"}, {"name": "bdb.Bdb.break_here()", "path": "library/bdb#bdb.Bdb.break_here", "type": "Debugging & Profiling", "text": "\nThis method checks if there is a breakpoint in the filename and line belonging\nto frame or, at least, in the current function. If the breakpoint is a\ntemporary one, this method deletes it.\n\n"}, {"name": "bdb.Bdb.canonic()", "path": "library/bdb#bdb.Bdb.canonic", "type": "Debugging & Profiling", "text": "\nAuxiliary method for getting a filename in a canonical form, that is, as a\ncase-normalized (on case-insensitive filesystems) absolute path, stripped of\nsurrounding angle brackets.\n\n"}, {"name": "bdb.Bdb.clear_all_breaks()", "path": "library/bdb#bdb.Bdb.clear_all_breaks", "type": "Debugging & Profiling", "text": "\nDelete all existing breakpoints.\n\n"}, {"name": "bdb.Bdb.clear_all_file_breaks()", "path": "library/bdb#bdb.Bdb.clear_all_file_breaks", "type": "Debugging & Profiling", "text": "\nDelete all breakpoints in filename. If none were set, an error message is\nreturned.\n\n"}, {"name": "bdb.Bdb.clear_bpbynumber()", "path": "library/bdb#bdb.Bdb.clear_bpbynumber", "type": "Debugging & Profiling", "text": "\nDelete the breakpoint which has the index arg in the `Breakpoint.bpbynumber`.\nIf arg is not numeric or out of range, return an error message.\n\n"}, {"name": "bdb.Bdb.clear_break()", "path": "library/bdb#bdb.Bdb.clear_break", "type": "Debugging & Profiling", "text": "\nDelete the breakpoints in filename and lineno. If none were set, an error\nmessage is returned.\n\n"}, {"name": "bdb.Bdb.dispatch_call()", "path": "library/bdb#bdb.Bdb.dispatch_call", "type": "Debugging & Profiling", "text": "\nIf the debugger should stop on this function call, invoke the `user_call()`\nmethod (which should be overridden in subclasses). Raise a `BdbQuit` exception\nif the `Bdb.quitting` flag is set (which can be set from `user_call()`).\nReturn a reference to the `trace_dispatch()` method for further tracing in\nthat scope.\n\n"}, {"name": "bdb.Bdb.dispatch_exception()", "path": "library/bdb#bdb.Bdb.dispatch_exception", "type": "Debugging & Profiling", "text": "\nIf the debugger should stop at this exception, invokes the `user_exception()`\nmethod (which should be overridden in subclasses). Raise a `BdbQuit` exception\nif the `Bdb.quitting` flag is set (which can be set from `user_exception()`).\nReturn a reference to the `trace_dispatch()` method for further tracing in\nthat scope.\n\n"}, {"name": "bdb.Bdb.dispatch_line()", "path": "library/bdb#bdb.Bdb.dispatch_line", "type": "Debugging & Profiling", "text": "\nIf the debugger should stop on the current line, invoke the `user_line()`\nmethod (which should be overridden in subclasses). Raise a `BdbQuit` exception\nif the `Bdb.quitting` flag is set (which can be set from `user_line()`).\nReturn a reference to the `trace_dispatch()` method for further tracing in\nthat scope.\n\n"}, {"name": "bdb.Bdb.dispatch_return()", "path": "library/bdb#bdb.Bdb.dispatch_return", "type": "Debugging & Profiling", "text": "\nIf the debugger should stop on this function return, invoke the\n`user_return()` method (which should be overridden in subclasses). Raise a\n`BdbQuit` exception if the `Bdb.quitting` flag is set (which can be set from\n`user_return()`). Return a reference to the `trace_dispatch()` method for\nfurther tracing in that scope.\n\n"}, {"name": "bdb.Bdb.do_clear()", "path": "library/bdb#bdb.Bdb.do_clear", "type": "Debugging & Profiling", "text": "\nHandle how a breakpoint must be removed when it is a temporary one.\n\n"}, {"name": "bdb.Bdb.format_stack_entry()", "path": "library/bdb#bdb.Bdb.format_stack_entry", "type": "Debugging & Profiling", "text": "\nReturn a string with information about a stack entry, identified by a `(frame,\nlineno)` tuple:\n\n"}, {"name": "bdb.Bdb.get_all_breaks()", "path": "library/bdb#bdb.Bdb.get_all_breaks", "type": "Debugging & Profiling", "text": "\nReturn all breakpoints that are set.\n\n"}, {"name": "bdb.Bdb.get_bpbynumber()", "path": "library/bdb#bdb.Bdb.get_bpbynumber", "type": "Debugging & Profiling", "text": "\nReturn a breakpoint specified by the given number. If arg is a string, it will\nbe converted to a number. If arg is a non-numeric string, if the given\nbreakpoint never existed or has been deleted, a `ValueError` is raised.\n\n"}, {"name": "bdb.Bdb.get_break()", "path": "library/bdb#bdb.Bdb.get_break", "type": "Debugging & Profiling", "text": "\nCheck if there is a breakpoint for lineno of filename.\n\n"}, {"name": "bdb.Bdb.get_breaks()", "path": "library/bdb#bdb.Bdb.get_breaks", "type": "Debugging & Profiling", "text": "\nReturn all breakpoints for lineno in filename, or an empty list if none are\nset.\n\n"}, {"name": "bdb.Bdb.get_file_breaks()", "path": "library/bdb#bdb.Bdb.get_file_breaks", "type": "Debugging & Profiling", "text": "\nReturn all breakpoints in filename, or an empty list if none are set.\n\n"}, {"name": "bdb.Bdb.get_stack()", "path": "library/bdb#bdb.Bdb.get_stack", "type": "Debugging & Profiling", "text": "\nGet a list of records for a frame and all higher (calling) and lower frames,\nand the size of the higher part.\n\n"}, {"name": "bdb.Bdb.reset()", "path": "library/bdb#bdb.Bdb.reset", "type": "Debugging & Profiling", "text": "\nSet the `botframe`, `stopframe`, `returnframe` and `quitting` attributes with\nvalues ready to start debugging.\n\n"}, {"name": "bdb.Bdb.run()", "path": "library/bdb#bdb.Bdb.run", "type": "Debugging & Profiling", "text": "\nDebug a statement executed via the `exec()` function. globals defaults to\n`__main__.__dict__`, locals defaults to globals.\n\n"}, {"name": "bdb.Bdb.runcall()", "path": "library/bdb#bdb.Bdb.runcall", "type": "Debugging & Profiling", "text": "\nDebug a single function call, and return its result.\n\n"}, {"name": "bdb.Bdb.runctx()", "path": "library/bdb#bdb.Bdb.runctx", "type": "Debugging & Profiling", "text": "\nFor backwards compatibility. Calls the `run()` method.\n\n"}, {"name": "bdb.Bdb.runeval()", "path": "library/bdb#bdb.Bdb.runeval", "type": "Debugging & Profiling", "text": "\nDebug an expression executed via the `eval()` function. globals and locals\nhave the same meaning as in `run()`.\n\n"}, {"name": "bdb.Bdb.set_break()", "path": "library/bdb#bdb.Bdb.set_break", "type": "Debugging & Profiling", "text": "\nSet a new breakpoint. If the lineno line doesn\u2019t exist for the filename passed\nas argument, return an error message. The filename should be in canonical\nform, as described in the `canonic()` method.\n\n"}, {"name": "bdb.Bdb.set_continue()", "path": "library/bdb#bdb.Bdb.set_continue", "type": "Debugging & Profiling", "text": "\nStop only at breakpoints or when finished. If there are no breakpoints, set\nthe system trace function to `None`.\n\n"}, {"name": "bdb.Bdb.set_next()", "path": "library/bdb#bdb.Bdb.set_next", "type": "Debugging & Profiling", "text": "\nStop on the next line in or below the given frame.\n\n"}, {"name": "bdb.Bdb.set_quit()", "path": "library/bdb#bdb.Bdb.set_quit", "type": "Debugging & Profiling", "text": "\nSet the `quitting` attribute to `True`. This raises `BdbQuit` in the next call\nto one of the `dispatch_*()` methods.\n\n"}, {"name": "bdb.Bdb.set_return()", "path": "library/bdb#bdb.Bdb.set_return", "type": "Debugging & Profiling", "text": "\nStop when returning from the given frame.\n\n"}, {"name": "bdb.Bdb.set_step()", "path": "library/bdb#bdb.Bdb.set_step", "type": "Debugging & Profiling", "text": "\nStop after one line of code.\n\n"}, {"name": "bdb.Bdb.set_trace()", "path": "library/bdb#bdb.Bdb.set_trace", "type": "Debugging & Profiling", "text": "\nStart debugging from frame. If frame is not specified, debugging starts from\ncaller\u2019s frame.\n\n"}, {"name": "bdb.Bdb.set_until()", "path": "library/bdb#bdb.Bdb.set_until", "type": "Debugging & Profiling", "text": "\nStop when the line with the line no greater than the current one is reached or\nwhen returning from current frame.\n\n"}, {"name": "bdb.Bdb.stop_here()", "path": "library/bdb#bdb.Bdb.stop_here", "type": "Debugging & Profiling", "text": "\nThis method checks if the frame is somewhere below `botframe` in the call\nstack. `botframe` is the frame in which debugging started.\n\n"}, {"name": "bdb.Bdb.trace_dispatch()", "path": "library/bdb#bdb.Bdb.trace_dispatch", "type": "Debugging & Profiling", "text": "\nThis function is installed as the trace function of debugged frames. Its\nreturn value is the new trace function (in most cases, that is, itself).\n\n"}, {"name": "bdb.Bdb.user_call()", "path": "library/bdb#bdb.Bdb.user_call", "type": "Debugging & Profiling", "text": "\nThis method is called from `dispatch_call()` when there is the possibility\nthat a break might be necessary anywhere inside the called function.\n\n"}, {"name": "bdb.Bdb.user_exception()", "path": "library/bdb#bdb.Bdb.user_exception", "type": "Debugging & Profiling", "text": "\nThis method is called from `dispatch_exception()` when `stop_here()` yields\n`True`.\n\n"}, {"name": "bdb.Bdb.user_line()", "path": "library/bdb#bdb.Bdb.user_line", "type": "Debugging & Profiling", "text": "\nThis method is called from `dispatch_line()` when either `stop_here()` or\n`break_here()` yields `True`.\n\n"}, {"name": "bdb.Bdb.user_return()", "path": "library/bdb#bdb.Bdb.user_return", "type": "Debugging & Profiling", "text": "\nThis method is called from `dispatch_return()` when `stop_here()` yields\n`True`.\n\n"}, {"name": "bdb.BdbQuit", "path": "library/bdb#bdb.BdbQuit", "type": "Debugging & Profiling", "text": "\nException raised by the `Bdb` class for quitting the debugger.\n\n"}, {"name": "bdb.Breakpoint", "path": "library/bdb#bdb.Breakpoint", "type": "Debugging & Profiling", "text": "\nThis class implements temporary breakpoints, ignore counts, disabling and\n(re-)enabling, and conditionals.\n\n"}, {"name": "bdb.Breakpoint.bpformat()", "path": "library/bdb#bdb.Breakpoint.bpformat", "type": "Debugging & Profiling", "text": "\nReturn a string with all the information about the breakpoint, nicely\nformatted:\n\n"}, {"name": "bdb.Breakpoint.bpprint()", "path": "library/bdb#bdb.Breakpoint.bpprint", "type": "Debugging & Profiling", "text": "\nPrint the output of `bpformat()` to the file out, or if it is `None`, to\nstandard output.\n\n"}, {"name": "bdb.Breakpoint.deleteMe()", "path": "library/bdb#bdb.Breakpoint.deleteMe", "type": "Debugging & Profiling", "text": "\nDelete the breakpoint from the list associated to a file/line. If it is the\nlast breakpoint in that position, it also deletes the entry for the file/line.\n\n"}, {"name": "bdb.Breakpoint.disable()", "path": "library/bdb#bdb.Breakpoint.disable", "type": "Debugging & Profiling", "text": "\nMark the breakpoint as disabled.\n\n"}, {"name": "bdb.Breakpoint.enable()", "path": "library/bdb#bdb.Breakpoint.enable", "type": "Debugging & Profiling", "text": "\nMark the breakpoint as enabled.\n\n"}, {"name": "bdb.checkfuncname()", "path": "library/bdb#bdb.checkfuncname", "type": "Debugging & Profiling", "text": "\nCheck whether we should break here, depending on the way the breakpoint b was\nset.\n\n"}, {"name": "bdb.effective()", "path": "library/bdb#bdb.effective", "type": "Debugging & Profiling", "text": "\nDetermine if there is an effective (active) breakpoint at this line of code.\nReturn a tuple of the breakpoint and a boolean that indicates if it is ok to\ndelete a temporary breakpoint. Return `(None, None)` if there is no matching\nbreakpoint.\n\n"}, {"name": "bdb.set_trace()", "path": "library/bdb#bdb.set_trace", "type": "Debugging & Profiling", "text": "\nStart debugging with a `Bdb` instance from caller\u2019s frame.\n\n"}, {"name": "bin()", "path": "library/functions#bin", "type": "Built-in Functions", "text": "\nConvert an integer number to a binary string prefixed with \u201c0b\u201d. The result is\na valid Python expression. If x is not a Python `int` object, it has to define\nan `__index__()` method that returns an integer. Some examples:\n\n"}, {"name": "binascii", "path": "library/binascii", "type": "Internet Data", "text": "\nThe `binascii` module contains a number of methods to convert between binary\nand various ASCII-encoded binary representations. Normally, you will not use\nthese functions directly but use wrapper modules like `uu`, `base64`, or\n`binhex` instead. The `binascii` module contains low-level functions written\nin C for greater speed that are used by the higher-level modules.\n\n"}, {"name": "binascii.a2b_base64()", "path": "library/binascii#binascii.a2b_base64", "type": "Internet Data", "text": "\nConvert a block of base64 data back to binary and return the binary data. More\nthan one line may be passed at a time.\n\n"}, {"name": "binascii.a2b_hex()", "path": "library/binascii#binascii.a2b_hex", "type": "Internet Data", "text": "\nReturn the binary data represented by the hexadecimal string hexstr. This\nfunction is the inverse of `b2a_hex()`. hexstr must contain an even number of\nhexadecimal digits (which can be upper or lower case), otherwise an `Error`\nexception is raised.\n\n"}, {"name": "binascii.a2b_hqx()", "path": "library/binascii#binascii.a2b_hqx", "type": "Internet Data", "text": "\nConvert binhex4 formatted ASCII data to binary, without doing RLE-\ndecompression. The string should contain a complete number of binary bytes, or\n(in case of the last portion of the binhex4 data) have the remaining bits\nzero.\n\n"}, {"name": "binascii.a2b_qp()", "path": "library/binascii#binascii.a2b_qp", "type": "Internet Data", "text": "\nConvert a block of quoted-printable data back to binary and return the binary\ndata. More than one line may be passed at a time. If the optional argument\nheader is present and true, underscores will be decoded as spaces.\n\n"}, {"name": "binascii.a2b_uu()", "path": "library/binascii#binascii.a2b_uu", "type": "Internet Data", "text": "\nConvert a single line of uuencoded data back to binary and return the binary\ndata. Lines normally contain 45 (binary) bytes, except for the last line. Line\ndata may be followed by whitespace.\n\n"}, {"name": "binascii.b2a_base64()", "path": "library/binascii#binascii.b2a_base64", "type": "Internet Data", "text": "\nConvert binary data to a line of ASCII characters in base64 coding. The return\nvalue is the converted line, including a newline char if newline is true. The\noutput of this function conforms to RFC 3548.\n\n"}, {"name": "binascii.b2a_hex()", "path": "library/binascii#binascii.b2a_hex", "type": "Internet Data", "text": "\nReturn the hexadecimal representation of the binary data. Every byte of data\nis converted into the corresponding 2-digit hex representation. The returned\nbytes object is therefore twice as long as the length of data.\n\n"}, {"name": "binascii.b2a_hqx()", "path": "library/binascii#binascii.b2a_hqx", "type": "Internet Data", "text": "\nPerform hexbin4 binary-to-ASCII translation and return the resulting string.\nThe argument should already be RLE-coded, and have a length divisible by 3\n(except possibly the last fragment).\n\n"}, {"name": "binascii.b2a_qp()", "path": "library/binascii#binascii.b2a_qp", "type": "Internet Data", "text": "\nConvert binary data to a line(s) of ASCII characters in quoted-printable\nencoding. The return value is the converted line(s). If the optional argument\nquotetabs is present and true, all tabs and spaces will be encoded. If the\noptional argument istext is present and true, newlines are not encoded but\ntrailing whitespace will be encoded. If the optional argument header is\npresent and true, spaces will be encoded as underscores per RFC 1522. If the\noptional argument header is present and false, newline characters will be\nencoded as well; otherwise linefeed conversion might corrupt the binary data\nstream.\n\n"}, {"name": "binascii.b2a_uu()", "path": "library/binascii#binascii.b2a_uu", "type": "Internet Data", "text": "\nConvert binary data to a line of ASCII characters, the return value is the\nconverted line, including a newline char. The length of data should be at most\n45. If backtick is true, zeros are represented by `'`'` instead of spaces.\n\n"}, {"name": "binascii.crc32()", "path": "library/binascii#binascii.crc32", "type": "Internet Data", "text": "\nCompute CRC-32, the 32-bit checksum of data, starting with an initial CRC of\nvalue. The default initial CRC is zero. The algorithm is consistent with the\nZIP file checksum. Since the algorithm is designed for use as a checksum\nalgorithm, it is not suitable for use as a general hash algorithm. Use as\nfollows:\n\n"}, {"name": "binascii.crc_hqx()", "path": "library/binascii#binascii.crc_hqx", "type": "Internet Data", "text": "\nCompute a 16-bit CRC value of data, starting with value as the initial CRC,\nand return the result. This uses the CRC-CCITT polynomial x16 \\+ x12 \\+ x5 \\+\n1, often represented as 0x1021. This CRC is used in the binhex4 format.\n\n"}, {"name": "binascii.Error", "path": "library/binascii#binascii.Error", "type": "Internet Data", "text": "\nException raised on errors. These are usually programming errors.\n\n"}, {"name": "binascii.hexlify()", "path": "library/binascii#binascii.hexlify", "type": "Internet Data", "text": "\nReturn the hexadecimal representation of the binary data. Every byte of data\nis converted into the corresponding 2-digit hex representation. The returned\nbytes object is therefore twice as long as the length of data.\n\n"}, {"name": "binascii.Incomplete", "path": "library/binascii#binascii.Incomplete", "type": "Internet Data", "text": "\nException raised on incomplete data. These are usually not programming errors,\nbut may be handled by reading a little more data and trying again.\n\n"}, {"name": "binascii.rlecode_hqx()", "path": "library/binascii#binascii.rlecode_hqx", "type": "Internet Data", "text": "\nPerform binhex4 style RLE-compression on data and return the result.\n\n"}, {"name": "binascii.rledecode_hqx()", "path": "library/binascii#binascii.rledecode_hqx", "type": "Internet Data", "text": "\nPerform RLE-decompression on the data, as per the binhex4 standard. The\nalgorithm uses `0x90` after a byte as a repeat indicator, followed by a count.\nA count of `0` specifies a byte value of `0x90`. The routine returns the\ndecompressed data, unless data input data ends in an orphaned repeat\nindicator, in which case the `Incomplete` exception is raised.\n\n"}, {"name": "binascii.unhexlify()", "path": "library/binascii#binascii.unhexlify", "type": "Internet Data", "text": "\nReturn the binary data represented by the hexadecimal string hexstr. This\nfunction is the inverse of `b2a_hex()`. hexstr must contain an even number of\nhexadecimal digits (which can be upper or lower case), otherwise an `Error`\nexception is raised.\n\n"}, {"name": "binhex", "path": "library/binhex", "type": "Internet Data", "text": "\nSource code: Lib/binhex.py\n\n"}, {"name": "binhex.binhex()", "path": "library/binhex#binhex.binhex", "type": "Internet Data", "text": "\nConvert a binary file with filename input to binhex file output. The output\nparameter can either be a filename or a file-like object (any object\nsupporting a `write()` and `close()` method).\n\n"}, {"name": "binhex.Error", "path": "library/binhex#binhex.Error", "type": "Internet Data", "text": "\nException raised when something can\u2019t be encoded using the binhex format (for\nexample, a filename is too long to fit in the filename field), or when input\nis not properly encoded binhex data.\n\n"}, {"name": "binhex.hexbin()", "path": "library/binhex#binhex.hexbin", "type": "Internet Data", "text": "\nDecode a binhex file input. input may be a filename or a file-like object\nsupporting `read()` and `close()` methods. The resulting file is written to a\nfile named output, unless the argument is `None` in which case the output\nfilename is read from the binhex file.\n\n"}, {"name": "bisect", "path": "library/bisect", "type": "Data Types", "text": "\nSource code: Lib/bisect.py\n\n"}, {"name": "bisect.bisect()", "path": "library/bisect#bisect.bisect", "type": "Data Types", "text": "\nSimilar to `bisect_left()`, but returns an insertion point which comes after\n(to the right of) any existing entries of x in a.\n\n"}, {"name": "bisect.bisect_left()", "path": "library/bisect#bisect.bisect_left", "type": "Data Types", "text": "\nLocate the insertion point for x in a to maintain sorted order. The parameters\nlo and hi may be used to specify a subset of the list which should be\nconsidered; by default the entire list is used. If x is already present in a,\nthe insertion point will be before (to the left of) any existing entries. The\nreturn value is suitable for use as the first parameter to `list.insert()`\nassuming that a is already sorted.\n\n"}, {"name": "bisect.bisect_right()", "path": "library/bisect#bisect.bisect_right", "type": "Data Types", "text": "\nSimilar to `bisect_left()`, but returns an insertion point which comes after\n(to the right of) any existing entries of x in a.\n\n"}, {"name": "bisect.insort()", "path": "library/bisect#bisect.insort", "type": "Data Types", "text": "\nSimilar to `insort_left()`, but inserting x in a after any existing entries of\nx.\n\n"}, {"name": "bisect.insort_left()", "path": "library/bisect#bisect.insort_left", "type": "Data Types", "text": "\nInsert x in a in sorted order. This is equivalent to\n`a.insert(bisect.bisect_left(a, x, lo, hi), x)` assuming that a is already\nsorted. Keep in mind that the O(log n) search is dominated by the slow O(n)\ninsertion step.\n\n"}, {"name": "bisect.insort_right()", "path": "library/bisect#bisect.insort_right", "type": "Data Types", "text": "\nSimilar to `insort_left()`, but inserting x in a after any existing entries of\nx.\n\n"}, {"name": "BlockingIOError", "path": "library/exceptions#BlockingIOError", "type": "Built-in Exceptions", "text": "\nRaised when an operation would block on an object (e.g. socket) set for non-\nblocking operation. Corresponds to `errno` `EAGAIN`, `EALREADY`, `EWOULDBLOCK`\nand `EINPROGRESS`.\n\n"}, {"name": "BlockingIOError.characters_written", "path": "library/exceptions#BlockingIOError.characters_written", "type": "Built-in Exceptions", "text": "\nAn integer containing the number of characters written to the stream before it\nblocked. This attribute is available when using the buffered I/O classes from\nthe `io` module.\n\n"}, {"name": "bool", "path": "library/functions#bool", "type": "Built-in Functions", "text": "\nReturn a Boolean value, i.e. one of `True` or `False`. x is converted using\nthe standard truth testing procedure. If x is false or omitted, this returns\n`False`; otherwise it returns `True`. The `bool` class is a subclass of `int`\n(see Numeric Types \u2014 int, float, complex). It cannot be subclassed further.\nIts only instances are `False` and `True` (see Boolean Values).\n\n"}, {"name": "breakpoint()", "path": "library/functions#breakpoint", "type": "Built-in Functions", "text": "\nThis function drops you into the debugger at the call site. Specifically, it\ncalls `sys.breakpointhook()`, passing `args` and `kws` straight through. By\ndefault, `sys.breakpointhook()` calls `pdb.set_trace()` expecting no\narguments. In this case, it is purely a convenience function so you don\u2019t have\nto explicitly import `pdb` or type as much code to enter the debugger.\nHowever, `sys.breakpointhook()` can be set to some other function and\n`breakpoint()` will automatically call that, allowing you to drop into the\ndebugger of choice.\n\n"}, {"name": "BrokenPipeError", "path": "library/exceptions#BrokenPipeError", "type": "Built-in Exceptions", "text": "\nA subclass of `ConnectionError`, raised when trying to write on a pipe while\nthe other end has been closed, or trying to write on a socket which has been\nshutdown for writing. Corresponds to `errno` `EPIPE` and `ESHUTDOWN`.\n\n"}, {"name": "BufferError", "path": "library/exceptions#BufferError", "type": "Built-in Exceptions", "text": "\nRaised when a buffer related operation cannot be performed.\n\n"}, {"name": "builtins", "path": "library/builtins", "type": "Runtime", "text": "\nThis module provides direct access to all \u2018built-in\u2019 identifiers of Python;\nfor example, `builtins.open` is the full name for the built-in function\n`open()`. See Built-in Functions and Built-in Constants for documentation.\n\n"}, {"name": "bytearray", "path": "library/functions#bytearray", "type": "Built-in Functions", "text": "\nReturn a new array of bytes. The `bytearray` class is a mutable sequence of\nintegers in the range 0 <= x < 256\\. It has most of the usual methods of\nmutable sequences, described in Mutable Sequence Types, as well as most\nmethods that the `bytes` type has, see Bytes and Bytearray Operations.\n\n"}, {"name": "bytearray", "path": "library/stdtypes#bytearray", "type": "Built-in Types", "text": "\nThere is no dedicated literal syntax for bytearray objects, instead they are\nalways created by calling the constructor:\n\n"}, {"name": "bytearray.capitalize()", "path": "library/stdtypes#bytearray.capitalize", "type": "Built-in Types", "text": "\nReturn a copy of the sequence with each byte interpreted as an ASCII\ncharacter, and the first byte capitalized and the rest lowercased. Non-ASCII\nbyte values are passed through unchanged.\n\n"}, {"name": "bytearray.center()", "path": "library/stdtypes#bytearray.center", "type": "Built-in Types", "text": "\nReturn a copy of the object centered in a sequence of length width. Padding is\ndone using the specified fillbyte (default is an ASCII space). For `bytes`\nobjects, the original sequence is returned if width is less than or equal to\n`len(s)`.\n\n"}, {"name": "bytearray.count()", "path": "library/stdtypes#bytearray.count", "type": "Built-in Types", "text": "\nReturn the number of non-overlapping occurrences of subsequence sub in the\nrange [start, end]. Optional arguments start and end are interpreted as in\nslice notation.\n\n"}, {"name": "bytearray.decode()", "path": "library/stdtypes#bytearray.decode", "type": "Built-in Types", "text": "\nReturn a string decoded from the given bytes. Default encoding is `'utf-8'`.\nerrors may be given to set a different error handling scheme. The default for\nerrors is `'strict'`, meaning that encoding errors raise a `UnicodeError`.\nOther possible values are `'ignore'`, `'replace'` and any other name\nregistered via `codecs.register_error()`, see section Error Handlers. For a\nlist of possible encodings, see section Standard Encodings.\n\n"}, {"name": "bytearray.endswith()", "path": "library/stdtypes#bytearray.endswith", "type": "Built-in Types", "text": "\nReturn `True` if the binary data ends with the specified suffix, otherwise\nreturn `False`. suffix can also be a tuple of suffixes to look for. With\noptional start, test beginning at that position. With optional end, stop\ncomparing at that position.\n\n"}, {"name": "bytearray.expandtabs()", "path": "library/stdtypes#bytearray.expandtabs", "type": "Built-in Types", "text": "\nReturn a copy of the sequence where all ASCII tab characters are replaced by\none or more ASCII spaces, depending on the current column and the given tab\nsize. Tab positions occur every tabsize bytes (default is 8, giving tab\npositions at columns 0, 8, 16 and so on). To expand the sequence, the current\ncolumn is set to zero and the sequence is examined byte by byte. If the byte\nis an ASCII tab character (`b'\\t'`), one or more space characters are inserted\nin the result until the current column is equal to the next tab position. (The\ntab character itself is not copied.) If the current byte is an ASCII newline\n(`b'\\n'`) or carriage return (`b'\\r'`), it is copied and the current column is\nreset to zero. Any other byte value is copied unchanged and the current column\nis incremented by one regardless of how the byte value is represented when\nprinted:\n\n"}, {"name": "bytearray.find()", "path": "library/stdtypes#bytearray.find", "type": "Built-in Types", "text": "\nReturn the lowest index in the data where the subsequence sub is found, such\nthat sub is contained in the slice `s[start:end]`. Optional arguments start\nand end are interpreted as in slice notation. Return `-1` if sub is not found.\n\n"}, {"name": "bytearray.fromhex()", "path": "library/stdtypes#bytearray.fromhex", "type": "Built-in Types", "text": "\nThis `bytearray` class method returns bytearray object, decoding the given\nstring object. The string must contain two hexadecimal digits per byte, with\nASCII whitespace being ignored.\n\n"}, {"name": "bytearray.hex()", "path": "library/stdtypes#bytearray.hex", "type": "Built-in Types", "text": "\nReturn a string object containing two hexadecimal digits for each byte in the\ninstance.\n\n"}, {"name": "bytearray.index()", "path": "library/stdtypes#bytearray.index", "type": "Built-in Types", "text": "\nLike `find()`, but raise `ValueError` when the subsequence is not found.\n\n"}, {"name": "bytearray.isalnum()", "path": "library/stdtypes#bytearray.isalnum", "type": "Built-in Types", "text": "\nReturn `True` if all bytes in the sequence are alphabetical ASCII characters\nor ASCII decimal digits and the sequence is not empty, `False` otherwise.\nAlphabetic ASCII characters are those byte values in the sequence\n`b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'`. ASCII decimal\ndigits are those byte values in the sequence `b'0123456789'`.\n\n"}, {"name": "bytearray.isalpha()", "path": "library/stdtypes#bytearray.isalpha", "type": "Built-in Types", "text": "\nReturn `True` if all bytes in the sequence are alphabetic ASCII characters and\nthe sequence is not empty, `False` otherwise. Alphabetic ASCII characters are\nthose byte values in the sequence\n`b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'`.\n\n"}, {"name": "bytearray.isascii()", "path": "library/stdtypes#bytearray.isascii", "type": "Built-in Types", "text": "\nReturn `True` if the sequence is empty or all bytes in the sequence are ASCII,\n`False` otherwise. ASCII bytes are in the range 0-0x7F.\n\n"}, {"name": "bytearray.isdigit()", "path": "library/stdtypes#bytearray.isdigit", "type": "Built-in Types", "text": "\nReturn `True` if all bytes in the sequence are ASCII decimal digits and the\nsequence is not empty, `False` otherwise. ASCII decimal digits are those byte\nvalues in the sequence `b'0123456789'`.\n\n"}, {"name": "bytearray.islower()", "path": "library/stdtypes#bytearray.islower", "type": "Built-in Types", "text": "\nReturn `True` if there is at least one lowercase ASCII character in the\nsequence and no uppercase ASCII characters, `False` otherwise.\n\n"}, {"name": "bytearray.isspace()", "path": "library/stdtypes#bytearray.isspace", "type": "Built-in Types", "text": "\nReturn `True` if all bytes in the sequence are ASCII whitespace and the\nsequence is not empty, `False` otherwise. ASCII whitespace characters are\nthose byte values in the sequence `b' \\t\\n\\r\\x0b\\f'` (space, tab, newline,\ncarriage return, vertical tab, form feed).\n\n"}, {"name": "bytearray.istitle()", "path": "library/stdtypes#bytearray.istitle", "type": "Built-in Types", "text": "\nReturn `True` if the sequence is ASCII titlecase and the sequence is not\nempty, `False` otherwise. See `bytes.title()` for more details on the\ndefinition of \u201ctitlecase\u201d.\n\n"}, {"name": "bytearray.isupper()", "path": "library/stdtypes#bytearray.isupper", "type": "Built-in Types", "text": "\nReturn `True` if there is at least one uppercase alphabetic ASCII character in\nthe sequence and no lowercase ASCII characters, `False` otherwise.\n\n"}, {"name": "bytearray.join()", "path": "library/stdtypes#bytearray.join", "type": "Built-in Types", "text": "\nReturn a bytes or bytearray object which is the concatenation of the binary\ndata sequences in iterable. A `TypeError` will be raised if there are any\nvalues in iterable that are not bytes-like objects, including `str` objects.\nThe separator between elements is the contents of the bytes or bytearray\nobject providing this method.\n\n"}, {"name": "bytearray.ljust()", "path": "library/stdtypes#bytearray.ljust", "type": "Built-in Types", "text": "\nReturn a copy of the object left justified in a sequence of length width.\nPadding is done using the specified fillbyte (default is an ASCII space). For\n`bytes` objects, the original sequence is returned if width is less than or\nequal to `len(s)`.\n\n"}, {"name": "bytearray.lower()", "path": "library/stdtypes#bytearray.lower", "type": "Built-in Types", "text": "\nReturn a copy of the sequence with all the uppercase ASCII characters\nconverted to their corresponding lowercase counterpart.\n\n"}, {"name": "bytearray.lstrip()", "path": "library/stdtypes#bytearray.lstrip", "type": "Built-in Types", "text": "\nReturn a copy of the sequence with specified leading bytes removed. The chars\nargument is a binary sequence specifying the set of byte values to be removed\n- the name refers to the fact this method is usually used with ASCII\ncharacters. If omitted or `None`, the chars argument defaults to removing\nASCII whitespace. The chars argument is not a prefix; rather, all combinations\nof its values are stripped:\n\n"}, {"name": "bytearray.maketrans()", "path": "library/stdtypes#bytearray.maketrans", "type": "Built-in Types", "text": "\nThis static method returns a translation table usable for `bytes.translate()`\nthat will map each character in from into the character at the same position\nin to; from and to must both be bytes-like objects and have the same length.\n\n"}, {"name": "bytearray.partition()", "path": "library/stdtypes#bytearray.partition", "type": "Built-in Types", "text": "\nSplit the sequence at the first occurrence of sep, and return a 3-tuple\ncontaining the part before the separator, the separator itself or its\nbytearray copy, and the part after the separator. If the separator is not\nfound, return a 3-tuple containing a copy of the original sequence, followed\nby two empty bytes or bytearray objects.\n\n"}, {"name": "bytearray.removeprefix()", "path": "library/stdtypes#bytearray.removeprefix", "type": "Built-in Types", "text": "\nIf the binary data starts with the prefix string, return\n`bytes[len(prefix):]`. Otherwise, return a copy of the original binary data:\n\n"}, {"name": "bytearray.removesuffix()", "path": "library/stdtypes#bytearray.removesuffix", "type": "Built-in Types", "text": "\nIf the binary data ends with the suffix string and that suffix is not empty,\nreturn `bytes[:-len(suffix)]`. Otherwise, return a copy of the original binary\ndata:\n\n"}, {"name": "bytearray.replace()", "path": "library/stdtypes#bytearray.replace", "type": "Built-in Types", "text": "\nReturn a copy of the sequence with all occurrences of subsequence old replaced\nby new. If the optional argument count is given, only the first count\noccurrences are replaced.\n\n"}, {"name": "bytearray.rfind()", "path": "library/stdtypes#bytearray.rfind", "type": "Built-in Types", "text": "\nReturn the highest index in the sequence where the subsequence sub is found,\nsuch that sub is contained within `s[start:end]`. Optional arguments start and\nend are interpreted as in slice notation. Return `-1` on failure.\n\n"}, {"name": "bytearray.rindex()", "path": "library/stdtypes#bytearray.rindex", "type": "Built-in Types", "text": "\nLike `rfind()` but raises `ValueError` when the subsequence sub is not found.\n\n"}, {"name": "bytearray.rjust()", "path": "library/stdtypes#bytearray.rjust", "type": "Built-in Types", "text": "\nReturn a copy of the object right justified in a sequence of length width.\nPadding is done using the specified fillbyte (default is an ASCII space). For\n`bytes` objects, the original sequence is returned if width is less than or\nequal to `len(s)`.\n\n"}, {"name": "bytearray.rpartition()", "path": "library/stdtypes#bytearray.rpartition", "type": "Built-in Types", "text": "\nSplit the sequence at the last occurrence of sep, and return a 3-tuple\ncontaining the part before the separator, the separator itself or its\nbytearray copy, and the part after the separator. If the separator is not\nfound, return a 3-tuple containing two empty bytes or bytearray objects,\nfollowed by a copy of the original sequence.\n\n"}, {"name": "bytearray.rsplit()", "path": "library/stdtypes#bytearray.rsplit", "type": "Built-in Types", "text": "\nSplit the binary sequence into subsequences of the same type, using sep as the\ndelimiter string. If maxsplit is given, at most maxsplit splits are done, the\nrightmost ones. If sep is not specified or `None`, any subsequence consisting\nsolely of ASCII whitespace is a separator. Except for splitting from the\nright, `rsplit()` behaves like `split()` which is described in detail below.\n\n"}, {"name": "bytearray.rstrip()", "path": "library/stdtypes#bytearray.rstrip", "type": "Built-in Types", "text": "\nReturn a copy of the sequence with specified trailing bytes removed. The chars\nargument is a binary sequence specifying the set of byte values to be removed\n- the name refers to the fact this method is usually used with ASCII\ncharacters. If omitted or `None`, the chars argument defaults to removing\nASCII whitespace. The chars argument is not a suffix; rather, all combinations\nof its values are stripped:\n\n"}, {"name": "bytearray.split()", "path": "library/stdtypes#bytearray.split", "type": "Built-in Types", "text": "\nSplit the binary sequence into subsequences of the same type, using sep as the\ndelimiter string. If maxsplit is given and non-negative, at most maxsplit\nsplits are done (thus, the list will have at most `maxsplit+1` elements). If\nmaxsplit is not specified or is `-1`, then there is no limit on the number of\nsplits (all possible splits are made).\n\n"}, {"name": "bytearray.splitlines()", "path": "library/stdtypes#bytearray.splitlines", "type": "Built-in Types", "text": "\nReturn a list of the lines in the binary sequence, breaking at ASCII line\nboundaries. This method uses the universal newlines approach to splitting\nlines. Line breaks are not included in the resulting list unless keepends is\ngiven and true.\n\n"}, {"name": "bytearray.startswith()", "path": "library/stdtypes#bytearray.startswith", "type": "Built-in Types", "text": "\nReturn `True` if the binary data starts with the specified prefix, otherwise\nreturn `False`. prefix can also be a tuple of prefixes to look for. With\noptional start, test beginning at that position. With optional end, stop\ncomparing at that position.\n\n"}, {"name": "bytearray.strip()", "path": "library/stdtypes#bytearray.strip", "type": "Built-in Types", "text": "\nReturn a copy of the sequence with specified leading and trailing bytes\nremoved. The chars argument is a binary sequence specifying the set of byte\nvalues to be removed - the name refers to the fact this method is usually used\nwith ASCII characters. If omitted or `None`, the chars argument defaults to\nremoving ASCII whitespace. The chars argument is not a prefix or suffix;\nrather, all combinations of its values are stripped:\n\n"}, {"name": "bytearray.swapcase()", "path": "library/stdtypes#bytearray.swapcase", "type": "Built-in Types", "text": "\nReturn a copy of the sequence with all the lowercase ASCII characters\nconverted to their corresponding uppercase counterpart and vice-versa.\n\n"}, {"name": "bytearray.title()", "path": "library/stdtypes#bytearray.title", "type": "Built-in Types", "text": "\nReturn a titlecased version of the binary sequence where words start with an\nuppercase ASCII character and the remaining characters are lowercase. Uncased\nbyte values are left unmodified.\n\n"}, {"name": "bytearray.translate()", "path": "library/stdtypes#bytearray.translate", "type": "Built-in Types", "text": "\nReturn a copy of the bytes or bytearray object where all bytes occurring in\nthe optional argument delete are removed, and the remaining bytes have been\nmapped through the given translation table, which must be a bytes object of\nlength 256.\n\n"}, {"name": "bytearray.upper()", "path": "library/stdtypes#bytearray.upper", "type": "Built-in Types", "text": "\nReturn a copy of the sequence with all the lowercase ASCII characters\nconverted to their corresponding uppercase counterpart.\n\n"}, {"name": "bytearray.zfill()", "path": "library/stdtypes#bytearray.zfill", "type": "Built-in Types", "text": "\nReturn a copy of the sequence left filled with ASCII `b'0'` digits to make a\nsequence of length width. A leading sign prefix (`b'+'`/ `b'-'`) is handled by\ninserting the padding after the sign character rather than before. For `bytes`\nobjects, the original sequence is returned if width is less than or equal to\n`len(seq)`.\n\n"}, {"name": "bytes", "path": "library/stdtypes#bytes", "type": "Built-in Types", "text": "\nFirstly, the syntax for bytes literals is largely the same as that for string\nliterals, except that a `b` prefix is added:\n\n"}, {"name": "bytes", "path": "library/functions#bytes", "type": "Built-in Functions", "text": "\nReturn a new \u201cbytes\u201d object, which is an immutable sequence of integers in the\nrange `0 <= x < 256`. `bytes` is an immutable version of `bytearray` \u2013 it has\nthe same non-mutating methods and the same indexing and slicing behavior.\n\n"}, {"name": "bytes.capitalize()", "path": "library/stdtypes#bytes.capitalize", "type": "Built-in Types", "text": "\nReturn a copy of the sequence with each byte interpreted as an ASCII\ncharacter, and the first byte capitalized and the rest lowercased. Non-ASCII\nbyte values are passed through unchanged.\n\n"}, {"name": "bytes.center()", "path": "library/stdtypes#bytes.center", "type": "Built-in Types", "text": "\nReturn a copy of the object centered in a sequence of length width. Padding is\ndone using the specified fillbyte (default is an ASCII space). For `bytes`\nobjects, the original sequence is returned if width is less than or equal to\n`len(s)`.\n\n"}, {"name": "bytes.count()", "path": "library/stdtypes#bytes.count", "type": "Built-in Types", "text": "\nReturn the number of non-overlapping occurrences of subsequence sub in the\nrange [start, end]. Optional arguments start and end are interpreted as in\nslice notation.\n\n"}, {"name": "bytes.decode()", "path": "library/stdtypes#bytes.decode", "type": "Built-in Types", "text": "\nReturn a string decoded from the given bytes. Default encoding is `'utf-8'`.\nerrors may be given to set a different error handling scheme. The default for\nerrors is `'strict'`, meaning that encoding errors raise a `UnicodeError`.\nOther possible values are `'ignore'`, `'replace'` and any other name\nregistered via `codecs.register_error()`, see section Error Handlers. For a\nlist of possible encodings, see section Standard Encodings.\n\n"}, {"name": "bytes.endswith()", "path": "library/stdtypes#bytes.endswith", "type": "Built-in Types", "text": "\nReturn `True` if the binary data ends with the specified suffix, otherwise\nreturn `False`. suffix can also be a tuple of suffixes to look for. With\noptional start, test beginning at that position. With optional end, stop\ncomparing at that position.\n\n"}, {"name": "bytes.expandtabs()", "path": "library/stdtypes#bytes.expandtabs", "type": "Built-in Types", "text": "\nReturn a copy of the sequence where all ASCII tab characters are replaced by\none or more ASCII spaces, depending on the current column and the given tab\nsize. Tab positions occur every tabsize bytes (default is 8, giving tab\npositions at columns 0, 8, 16 and so on). To expand the sequence, the current\ncolumn is set to zero and the sequence is examined byte by byte. If the byte\nis an ASCII tab character (`b'\\t'`), one or more space characters are inserted\nin the result until the current column is equal to the next tab position. (The\ntab character itself is not copied.) If the current byte is an ASCII newline\n(`b'\\n'`) or carriage return (`b'\\r'`), it is copied and the current column is\nreset to zero. Any other byte value is copied unchanged and the current column\nis incremented by one regardless of how the byte value is represented when\nprinted:\n\n"}, {"name": "bytes.find()", "path": "library/stdtypes#bytes.find", "type": "Built-in Types", "text": "\nReturn the lowest index in the data where the subsequence sub is found, such\nthat sub is contained in the slice `s[start:end]`. Optional arguments start\nand end are interpreted as in slice notation. Return `-1` if sub is not found.\n\n"}, {"name": "bytes.fromhex()", "path": "library/stdtypes#bytes.fromhex", "type": "Built-in Types", "text": "\nThis `bytes` class method returns a bytes object, decoding the given string\nobject. The string must contain two hexadecimal digits per byte, with ASCII\nwhitespace being ignored.\n\n"}, {"name": "bytes.hex()", "path": "library/stdtypes#bytes.hex", "type": "Built-in Types", "text": "\nReturn a string object containing two hexadecimal digits for each byte in the\ninstance.\n\n"}, {"name": "bytes.index()", "path": "library/stdtypes#bytes.index", "type": "Built-in Types", "text": "\nLike `find()`, but raise `ValueError` when the subsequence is not found.\n\n"}, {"name": "bytes.isalnum()", "path": "library/stdtypes#bytes.isalnum", "type": "Built-in Types", "text": "\nReturn `True` if all bytes in the sequence are alphabetical ASCII characters\nor ASCII decimal digits and the sequence is not empty, `False` otherwise.\nAlphabetic ASCII characters are those byte values in the sequence\n`b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'`. ASCII decimal\ndigits are those byte values in the sequence `b'0123456789'`.\n\n"}, {"name": "bytes.isalpha()", "path": "library/stdtypes#bytes.isalpha", "type": "Built-in Types", "text": "\nReturn `True` if all bytes in the sequence are alphabetic ASCII characters and\nthe sequence is not empty, `False` otherwise. Alphabetic ASCII characters are\nthose byte values in the sequence\n`b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'`.\n\n"}, {"name": "bytes.isascii()", "path": "library/stdtypes#bytes.isascii", "type": "Built-in Types", "text": "\nReturn `True` if the sequence is empty or all bytes in the sequence are ASCII,\n`False` otherwise. ASCII bytes are in the range 0-0x7F.\n\n"}, {"name": "bytes.isdigit()", "path": "library/stdtypes#bytes.isdigit", "type": "Built-in Types", "text": "\nReturn `True` if all bytes in the sequence are ASCII decimal digits and the\nsequence is not empty, `False` otherwise. ASCII decimal digits are those byte\nvalues in the sequence `b'0123456789'`.\n\n"}, {"name": "bytes.islower()", "path": "library/stdtypes#bytes.islower", "type": "Built-in Types", "text": "\nReturn `True` if there is at least one lowercase ASCII character in the\nsequence and no uppercase ASCII characters, `False` otherwise.\n\n"}, {"name": "bytes.isspace()", "path": "library/stdtypes#bytes.isspace", "type": "Built-in Types", "text": "\nReturn `True` if all bytes in the sequence are ASCII whitespace and the\nsequence is not empty, `False` otherwise. ASCII whitespace characters are\nthose byte values in the sequence `b' \\t\\n\\r\\x0b\\f'` (space, tab, newline,\ncarriage return, vertical tab, form feed).\n\n"}, {"name": "bytes.istitle()", "path": "library/stdtypes#bytes.istitle", "type": "Built-in Types", "text": "\nReturn `True` if the sequence is ASCII titlecase and the sequence is not\nempty, `False` otherwise. See `bytes.title()` for more details on the\ndefinition of \u201ctitlecase\u201d.\n\n"}, {"name": "bytes.isupper()", "path": "library/stdtypes#bytes.isupper", "type": "Built-in Types", "text": "\nReturn `True` if there is at least one uppercase alphabetic ASCII character in\nthe sequence and no lowercase ASCII characters, `False` otherwise.\n\n"}, {"name": "bytes.join()", "path": "library/stdtypes#bytes.join", "type": "Built-in Types", "text": "\nReturn a bytes or bytearray object which is the concatenation of the binary\ndata sequences in iterable. A `TypeError` will be raised if there are any\nvalues in iterable that are not bytes-like objects, including `str` objects.\nThe separator between elements is the contents of the bytes or bytearray\nobject providing this method.\n\n"}, {"name": "bytes.ljust()", "path": "library/stdtypes#bytes.ljust", "type": "Built-in Types", "text": "\nReturn a copy of the object left justified in a sequence of length width.\nPadding is done using the specified fillbyte (default is an ASCII space). For\n`bytes` objects, the original sequence is returned if width is less than or\nequal to `len(s)`.\n\n"}, {"name": "bytes.lower()", "path": "library/stdtypes#bytes.lower", "type": "Built-in Types", "text": "\nReturn a copy of the sequence with all the uppercase ASCII characters\nconverted to their corresponding lowercase counterpart.\n\n"}, {"name": "bytes.lstrip()", "path": "library/stdtypes#bytes.lstrip", "type": "Built-in Types", "text": "\nReturn a copy of the sequence with specified leading bytes removed. The chars\nargument is a binary sequence specifying the set of byte values to be removed\n- the name refers to the fact this method is usually used with ASCII\ncharacters. If omitted or `None`, the chars argument defaults to removing\nASCII whitespace. The chars argument is not a prefix; rather, all combinations\nof its values are stripped:\n\n"}, {"name": "bytes.maketrans()", "path": "library/stdtypes#bytes.maketrans", "type": "Built-in Types", "text": "\nThis static method returns a translation table usable for `bytes.translate()`\nthat will map each character in from into the character at the same position\nin to; from and to must both be bytes-like objects and have the same length.\n\n"}, {"name": "bytes.partition()", "path": "library/stdtypes#bytes.partition", "type": "Built-in Types", "text": "\nSplit the sequence at the first occurrence of sep, and return a 3-tuple\ncontaining the part before the separator, the separator itself or its\nbytearray copy, and the part after the separator. If the separator is not\nfound, return a 3-tuple containing a copy of the original sequence, followed\nby two empty bytes or bytearray objects.\n\n"}, {"name": "bytes.removeprefix()", "path": "library/stdtypes#bytes.removeprefix", "type": "Built-in Types", "text": "\nIf the binary data starts with the prefix string, return\n`bytes[len(prefix):]`. Otherwise, return a copy of the original binary data:\n\n"}, {"name": "bytes.removesuffix()", "path": "library/stdtypes#bytes.removesuffix", "type": "Built-in Types", "text": "\nIf the binary data ends with the suffix string and that suffix is not empty,\nreturn `bytes[:-len(suffix)]`. Otherwise, return a copy of the original binary\ndata:\n\n"}, {"name": "bytes.replace()", "path": "library/stdtypes#bytes.replace", "type": "Built-in Types", "text": "\nReturn a copy of the sequence with all occurrences of subsequence old replaced\nby new. If the optional argument count is given, only the first count\noccurrences are replaced.\n\n"}, {"name": "bytes.rfind()", "path": "library/stdtypes#bytes.rfind", "type": "Built-in Types", "text": "\nReturn the highest index in the sequence where the subsequence sub is found,\nsuch that sub is contained within `s[start:end]`. Optional arguments start and\nend are interpreted as in slice notation. Return `-1` on failure.\n\n"}, {"name": "bytes.rindex()", "path": "library/stdtypes#bytes.rindex", "type": "Built-in Types", "text": "\nLike `rfind()` but raises `ValueError` when the subsequence sub is not found.\n\n"}, {"name": "bytes.rjust()", "path": "library/stdtypes#bytes.rjust", "type": "Built-in Types", "text": "\nReturn a copy of the object right justified in a sequence of length width.\nPadding is done using the specified fillbyte (default is an ASCII space). For\n`bytes` objects, the original sequence is returned if width is less than or\nequal to `len(s)`.\n\n"}, {"name": "bytes.rpartition()", "path": "library/stdtypes#bytes.rpartition", "type": "Built-in Types", "text": "\nSplit the sequence at the last occurrence of sep, and return a 3-tuple\ncontaining the part before the separator, the separator itself or its\nbytearray copy, and the part after the separator. If the separator is not\nfound, return a 3-tuple containing two empty bytes or bytearray objects,\nfollowed by a copy of the original sequence.\n\n"}, {"name": "bytes.rsplit()", "path": "library/stdtypes#bytes.rsplit", "type": "Built-in Types", "text": "\nSplit the binary sequence into subsequences of the same type, using sep as the\ndelimiter string. If maxsplit is given, at most maxsplit splits are done, the\nrightmost ones. If sep is not specified or `None`, any subsequence consisting\nsolely of ASCII whitespace is a separator. Except for splitting from the\nright, `rsplit()` behaves like `split()` which is described in detail below.\n\n"}, {"name": "bytes.rstrip()", "path": "library/stdtypes#bytes.rstrip", "type": "Built-in Types", "text": "\nReturn a copy of the sequence with specified trailing bytes removed. The chars\nargument is a binary sequence specifying the set of byte values to be removed\n- the name refers to the fact this method is usually used with ASCII\ncharacters. If omitted or `None`, the chars argument defaults to removing\nASCII whitespace. The chars argument is not a suffix; rather, all combinations\nof its values are stripped:\n\n"}, {"name": "bytes.split()", "path": "library/stdtypes#bytes.split", "type": "Built-in Types", "text": "\nSplit the binary sequence into subsequences of the same type, using sep as the\ndelimiter string. If maxsplit is given and non-negative, at most maxsplit\nsplits are done (thus, the list will have at most `maxsplit+1` elements). If\nmaxsplit is not specified or is `-1`, then there is no limit on the number of\nsplits (all possible splits are made).\n\n"}, {"name": "bytes.splitlines()", "path": "library/stdtypes#bytes.splitlines", "type": "Built-in Types", "text": "\nReturn a list of the lines in the binary sequence, breaking at ASCII line\nboundaries. This method uses the universal newlines approach to splitting\nlines. Line breaks are not included in the resulting list unless keepends is\ngiven and true.\n\n"}, {"name": "bytes.startswith()", "path": "library/stdtypes#bytes.startswith", "type": "Built-in Types", "text": "\nReturn `True` if the binary data starts with the specified prefix, otherwise\nreturn `False`. prefix can also be a tuple of prefixes to look for. With\noptional start, test beginning at that position. With optional end, stop\ncomparing at that position.\n\n"}, {"name": "bytes.strip()", "path": "library/stdtypes#bytes.strip", "type": "Built-in Types", "text": "\nReturn a copy of the sequence with specified leading and trailing bytes\nremoved. The chars argument is a binary sequence specifying the set of byte\nvalues to be removed - the name refers to the fact this method is usually used\nwith ASCII characters. If omitted or `None`, the chars argument defaults to\nremoving ASCII whitespace. The chars argument is not a prefix or suffix;\nrather, all combinations of its values are stripped:\n\n"}, {"name": "bytes.swapcase()", "path": "library/stdtypes#bytes.swapcase", "type": "Built-in Types", "text": "\nReturn a copy of the sequence with all the lowercase ASCII characters\nconverted to their corresponding uppercase counterpart and vice-versa.\n\n"}, {"name": "bytes.title()", "path": "library/stdtypes#bytes.title", "type": "Built-in Types", "text": "\nReturn a titlecased version of the binary sequence where words start with an\nuppercase ASCII character and the remaining characters are lowercase. Uncased\nbyte values are left unmodified.\n\n"}, {"name": "bytes.translate()", "path": "library/stdtypes#bytes.translate", "type": "Built-in Types", "text": "\nReturn a copy of the bytes or bytearray object where all bytes occurring in\nthe optional argument delete are removed, and the remaining bytes have been\nmapped through the given translation table, which must be a bytes object of\nlength 256.\n\n"}, {"name": "bytes.upper()", "path": "library/stdtypes#bytes.upper", "type": "Built-in Types", "text": "\nReturn a copy of the sequence with all the lowercase ASCII characters\nconverted to their corresponding uppercase counterpart.\n\n"}, {"name": "bytes.zfill()", "path": "library/stdtypes#bytes.zfill", "type": "Built-in Types", "text": "\nReturn a copy of the sequence left filled with ASCII `b'0'` digits to make a\nsequence of length width. A leading sign prefix (`b'+'`/ `b'-'`) is handled by\ninserting the padding after the sign character rather than before. For `bytes`\nobjects, the original sequence is returned if width is less than or equal to\n`len(seq)`.\n\n"}, {"name": "BytesWarning", "path": "library/exceptions#BytesWarning", "type": "Built-in Exceptions", "text": "\nBase class for warnings related to `bytes` and `bytearray`.\n\n"}, {"name": "bz2", "path": "library/bz2", "type": "Data Compression", "text": "\nSource code: Lib/bz2.py\n\n"}, {"name": "bz2.BZ2Compressor", "path": "library/bz2#bz2.BZ2Compressor", "type": "Data Compression", "text": "\nCreate a new compressor object. This object may be used to compress data\nincrementally. For one-shot compression, use the `compress()` function\ninstead.\n\n"}, {"name": "bz2.BZ2Compressor.compress()", "path": "library/bz2#bz2.BZ2Compressor.compress", "type": "Data Compression", "text": "\nProvide data to the compressor object. Returns a chunk of compressed data if\npossible, or an empty byte string otherwise.\n\n"}, {"name": "bz2.BZ2Compressor.flush()", "path": "library/bz2#bz2.BZ2Compressor.flush", "type": "Data Compression", "text": "\nFinish the compression process. Returns the compressed data left in internal\nbuffers.\n\n"}, {"name": "bz2.BZ2Decompressor", "path": "library/bz2#bz2.BZ2Decompressor", "type": "Data Compression", "text": "\nCreate a new decompressor object. This object may be used to decompress data\nincrementally. For one-shot compression, use the `decompress()` function\ninstead.\n\n"}, {"name": "bz2.BZ2Decompressor.decompress()", "path": "library/bz2#bz2.BZ2Decompressor.decompress", "type": "Data Compression", "text": "\nDecompress data (a bytes-like object), returning uncompressed data as bytes.\nSome of data may be buffered internally, for use in later calls to\n`decompress()`. The returned data should be concatenated with the output of\nany previous calls to `decompress()`.\n\n"}, {"name": "bz2.BZ2Decompressor.eof", "path": "library/bz2#bz2.BZ2Decompressor.eof", "type": "Data Compression", "text": "\n`True` if the end-of-stream marker has been reached.\n\n"}, {"name": "bz2.BZ2Decompressor.needs_input", "path": "library/bz2#bz2.BZ2Decompressor.needs_input", "type": "Data Compression", "text": "\n`False` if the `decompress()` method can provide more decompressed data before\nrequiring new uncompressed input.\n\n"}, {"name": "bz2.BZ2Decompressor.unused_data", "path": "library/bz2#bz2.BZ2Decompressor.unused_data", "type": "Data Compression", "text": "\nData found after the end of the compressed stream.\n\n"}, {"name": "bz2.BZ2File", "path": "library/bz2#bz2.BZ2File", "type": "Data Compression", "text": "\nOpen a bzip2-compressed file in binary mode.\n\n"}, {"name": "bz2.BZ2File.peek()", "path": "library/bz2#bz2.BZ2File.peek", "type": "Data Compression", "text": "\nReturn buffered data without advancing the file position. At least one byte of\ndata will be returned (unless at EOF). The exact number of bytes returned is\nunspecified.\n\n"}, {"name": "bz2.compress()", "path": "library/bz2#bz2.compress", "type": "Data Compression", "text": "\nCompress data, a bytes-like object.\n\n"}, {"name": "bz2.decompress()", "path": "library/bz2#bz2.decompress", "type": "Data Compression", "text": "\nDecompress data, a bytes-like object.\n\n"}, {"name": "bz2.open()", "path": "library/bz2#bz2.open", "type": "Data Compression", "text": "\nOpen a bzip2-compressed file in binary or text mode, returning a file object.\n\n"}, {"name": "calendar", "path": "library/calendar", "type": "Data Types", "text": "\nSource code: Lib/calendar.py\n\n"}, {"name": "calendar.Calendar", "path": "library/calendar#calendar.Calendar", "type": "Data Types", "text": "\nCreates a `Calendar` object. firstweekday is an integer specifying the first\nday of the week. `0` is Monday (the default), `6` is Sunday.\n\n"}, {"name": "calendar.calendar()", "path": "library/calendar#calendar.calendar", "type": "Data Types", "text": "\nReturns a 3-column calendar for an entire year as a multi-line string using\nthe `formatyear()` of the `TextCalendar` class.\n\n"}, {"name": "calendar.Calendar.itermonthdates()", "path": "library/calendar#calendar.Calendar.itermonthdates", "type": "Data Types", "text": "\nReturn an iterator for the month month (1\u201312) in the year year. This iterator\nwill return all days (as `datetime.date` objects) for the month and all days\nbefore the start of the month or after the end of the month that are required\nto get a complete week.\n\n"}, {"name": "calendar.Calendar.itermonthdays()", "path": "library/calendar#calendar.Calendar.itermonthdays", "type": "Data Types", "text": "\nReturn an iterator for the month month in the year year similar to\n`itermonthdates()`, but not restricted by the `datetime.date` range. Days\nreturned will simply be day of the month numbers. For the days outside of the\nspecified month, the day number is `0`.\n\n"}, {"name": "calendar.Calendar.itermonthdays2()", "path": "library/calendar#calendar.Calendar.itermonthdays2", "type": "Data Types", "text": "\nReturn an iterator for the month month in the year year similar to\n`itermonthdates()`, but not restricted by the `datetime.date` range. Days\nreturned will be tuples consisting of a day of the month number and a week day\nnumber.\n\n"}, {"name": "calendar.Calendar.itermonthdays3()", "path": "library/calendar#calendar.Calendar.itermonthdays3", "type": "Data Types", "text": "\nReturn an iterator for the month month in the year year similar to\n`itermonthdates()`, but not restricted by the `datetime.date` range. Days\nreturned will be tuples consisting of a year, a month and a day of the month\nnumbers.\n\n"}, {"name": "calendar.Calendar.itermonthdays4()", "path": "library/calendar#calendar.Calendar.itermonthdays4", "type": "Data Types", "text": "\nReturn an iterator for the month month in the year year similar to\n`itermonthdates()`, but not restricted by the `datetime.date` range. Days\nreturned will be tuples consisting of a year, a month, a day of the month, and\na day of the week numbers.\n\n"}, {"name": "calendar.Calendar.iterweekdays()", "path": "library/calendar#calendar.Calendar.iterweekdays", "type": "Data Types", "text": "\nReturn an iterator for the week day numbers that will be used for one week.\nThe first value from the iterator will be the same as the value of the\n`firstweekday` property.\n\n"}, {"name": "calendar.Calendar.monthdatescalendar()", "path": "library/calendar#calendar.Calendar.monthdatescalendar", "type": "Data Types", "text": "\nReturn a list of the weeks in the month month of the year as full weeks. Weeks\nare lists of seven `datetime.date` objects.\n\n"}, {"name": "calendar.Calendar.monthdays2calendar()", "path": "library/calendar#calendar.Calendar.monthdays2calendar", "type": "Data Types", "text": "\nReturn a list of the weeks in the month month of the year as full weeks. Weeks\nare lists of seven tuples of day numbers and weekday numbers.\n\n"}, {"name": "calendar.Calendar.monthdayscalendar()", "path": "library/calendar#calendar.Calendar.monthdayscalendar", "type": "Data Types", "text": "\nReturn a list of the weeks in the month month of the year as full weeks. Weeks\nare lists of seven day numbers.\n\n"}, {"name": "calendar.Calendar.yeardatescalendar()", "path": "library/calendar#calendar.Calendar.yeardatescalendar", "type": "Data Types", "text": "\nReturn the data for the specified year ready for formatting. The return value\nis a list of month rows. Each month row contains up to width months\n(defaulting to 3). Each month contains between 4 and 6 weeks and each week\ncontains 1\u20137 days. Days are `datetime.date` objects.\n\n"}, {"name": "calendar.Calendar.yeardays2calendar()", "path": "library/calendar#calendar.Calendar.yeardays2calendar", "type": "Data Types", "text": "\nReturn the data for the specified year ready for formatting (similar to\n`yeardatescalendar()`). Entries in the week lists are tuples of day numbers\nand weekday numbers. Day numbers outside this month are zero.\n\n"}, {"name": "calendar.Calendar.yeardayscalendar()", "path": "library/calendar#calendar.Calendar.yeardayscalendar", "type": "Data Types", "text": "\nReturn the data for the specified year ready for formatting (similar to\n`yeardatescalendar()`). Entries in the week lists are day numbers. Day numbers\noutside this month are zero.\n\n"}, {"name": "calendar.day_abbr", "path": "library/calendar#calendar.day_abbr", "type": "Data Types", "text": "\nAn array that represents the abbreviated days of the week in the current\nlocale.\n\n"}, {"name": "calendar.day_name", "path": "library/calendar#calendar.day_name", "type": "Data Types", "text": "\nAn array that represents the days of the week in the current locale.\n\n"}, {"name": "calendar.firstweekday()", "path": "library/calendar#calendar.firstweekday", "type": "Data Types", "text": "\nReturns the current setting for the weekday to start each week.\n\n"}, {"name": "calendar.HTMLCalendar", "path": "library/calendar#calendar.HTMLCalendar", "type": "Data Types", "text": "\nThis class can be used to generate HTML calendars.\n\n"}, {"name": "calendar.HTMLCalendar.cssclasses", "path": "library/calendar#calendar.HTMLCalendar.cssclasses", "type": "Data Types", "text": "\nA list of CSS classes used for each weekday. The default class list is:\n\n"}, {"name": "calendar.HTMLCalendar.cssclasses_weekday_head", "path": "library/calendar#calendar.HTMLCalendar.cssclasses_weekday_head", "type": "Data Types", "text": "\nA list of CSS classes used for weekday names in the header row. The default is\nthe same as `cssclasses`.\n\n"}, {"name": "calendar.HTMLCalendar.cssclass_month", "path": "library/calendar#calendar.HTMLCalendar.cssclass_month", "type": "Data Types", "text": "\nThe CSS class for the whole month\u2019s table (used by `formatmonth()`). The\ndefault value is `\"month\"`.\n\n"}, {"name": "calendar.HTMLCalendar.cssclass_month_head", "path": "library/calendar#calendar.HTMLCalendar.cssclass_month_head", "type": "Data Types", "text": "\nThe month\u2019s head CSS class (used by `formatmonthname()`). The default value is\n`\"month\"`.\n\n"}, {"name": "calendar.HTMLCalendar.cssclass_noday", "path": "library/calendar#calendar.HTMLCalendar.cssclass_noday", "type": "Data Types", "text": "\nThe CSS class for a weekday occurring in the previous or coming month.\n\n"}, {"name": "calendar.HTMLCalendar.cssclass_year", "path": "library/calendar#calendar.HTMLCalendar.cssclass_year", "type": "Data Types", "text": "\nThe CSS class for the whole year\u2019s table of tables (used by `formatyear()`).\nThe default value is `\"year\"`.\n\n"}, {"name": "calendar.HTMLCalendar.cssclass_year_head", "path": "library/calendar#calendar.HTMLCalendar.cssclass_year_head", "type": "Data Types", "text": "\nThe CSS class for the table head for the whole year (used by `formatyear()`).\nThe default value is `\"year\"`.\n\n"}, {"name": "calendar.HTMLCalendar.formatmonth()", "path": "library/calendar#calendar.HTMLCalendar.formatmonth", "type": "Data Types", "text": "\nReturn a month\u2019s calendar as an HTML table. If withyear is true the year will\nbe included in the header, otherwise just the month name will be used.\n\n"}, {"name": "calendar.HTMLCalendar.formatyear()", "path": "library/calendar#calendar.HTMLCalendar.formatyear", "type": "Data Types", "text": "\nReturn a year\u2019s calendar as an HTML table. width (defaulting to 3) specifies\nthe number of months per row.\n\n"}, {"name": "calendar.HTMLCalendar.formatyearpage()", "path": "library/calendar#calendar.HTMLCalendar.formatyearpage", "type": "Data Types", "text": "\nReturn a year\u2019s calendar as a complete HTML page. width (defaulting to 3)\nspecifies the number of months per row. css is the name for the cascading\nstyle sheet to be used. `None` can be passed if no style sheet should be used.\nencoding specifies the encoding to be used for the output (defaulting to the\nsystem default encoding).\n\n"}, {"name": "calendar.isleap()", "path": "library/calendar#calendar.isleap", "type": "Data Types", "text": "\nReturns `True` if year is a leap year, otherwise `False`.\n\n"}, {"name": "calendar.leapdays()", "path": "library/calendar#calendar.leapdays", "type": "Data Types", "text": "\nReturns the number of leap years in the range from y1 to y2 (exclusive), where\ny1 and y2 are years.\n\n"}, {"name": "calendar.LocaleHTMLCalendar", "path": "library/calendar#calendar.LocaleHTMLCalendar", "type": "Data Types", "text": "\nThis subclass of `HTMLCalendar` can be passed a locale name in the constructor\nand will return month and weekday names in the specified locale. If this\nlocale includes an encoding all strings containing month and weekday names\nwill be returned as unicode.\n\n"}, {"name": "calendar.LocaleTextCalendar", "path": "library/calendar#calendar.LocaleTextCalendar", "type": "Data Types", "text": "\nThis subclass of `TextCalendar` can be passed a locale name in the constructor\nand will return month and weekday names in the specified locale. If this\nlocale includes an encoding all strings containing month and weekday names\nwill be returned as unicode.\n\n"}, {"name": "calendar.month()", "path": "library/calendar#calendar.month", "type": "Data Types", "text": "\nReturns a month\u2019s calendar in a multi-line string using the `formatmonth()` of\nthe `TextCalendar` class.\n\n"}, {"name": "calendar.monthcalendar()", "path": "library/calendar#calendar.monthcalendar", "type": "Data Types", "text": "\nReturns a matrix representing a month\u2019s calendar. Each row represents a week;\ndays outside of the month are represented by zeros. Each week begins with\nMonday unless set by `setfirstweekday()`.\n\n"}, {"name": "calendar.monthrange()", "path": "library/calendar#calendar.monthrange", "type": "Data Types", "text": "\nReturns weekday of first day of the month and number of days in month, for the\nspecified year and month.\n\n"}, {"name": "calendar.month_abbr", "path": "library/calendar#calendar.month_abbr", "type": "Data Types", "text": "\nAn array that represents the abbreviated months of the year in the current\nlocale. This follows normal convention of January being month number 1, so it\nhas a length of 13 and `month_abbr[0]` is the empty string.\n\n"}, {"name": "calendar.month_name", "path": "library/calendar#calendar.month_name", "type": "Data Types", "text": "\nAn array that represents the months of the year in the current locale. This\nfollows normal convention of January being month number 1, so it has a length\nof 13 and `month_name[0]` is the empty string.\n\n"}, {"name": "calendar.prcal()", "path": "library/calendar#calendar.prcal", "type": "Data Types", "text": "\nPrints the calendar for an entire year as returned by `calendar()`.\n\n"}, {"name": "calendar.prmonth()", "path": "library/calendar#calendar.prmonth", "type": "Data Types", "text": "\nPrints a month\u2019s calendar as returned by `month()`.\n\n"}, {"name": "calendar.setfirstweekday()", "path": "library/calendar#calendar.setfirstweekday", "type": "Data Types", "text": "\nSets the weekday (`0` is Monday, `6` is Sunday) to start each week. The values\n`MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, and\n`SUNDAY` are provided for convenience. For example, to set the first weekday\nto Sunday:\n\n"}, {"name": "calendar.TextCalendar", "path": "library/calendar#calendar.TextCalendar", "type": "Data Types", "text": "\nThis class can be used to generate plain text calendars.\n\n"}, {"name": "calendar.TextCalendar.formatmonth()", "path": "library/calendar#calendar.TextCalendar.formatmonth", "type": "Data Types", "text": "\nReturn a month\u2019s calendar in a multi-line string. If w is provided, it\nspecifies the width of the date columns, which are centered. If l is given, it\nspecifies the number of lines that each week will use. Depends on the first\nweekday as specified in the constructor or set by the `setfirstweekday()`\nmethod.\n\n"}, {"name": "calendar.TextCalendar.formatyear()", "path": "library/calendar#calendar.TextCalendar.formatyear", "type": "Data Types", "text": "\nReturn a m-column calendar for an entire year as a multi-line string. Optional\nparameters w, l, and c are for date column width, lines per week, and number\nof spaces between month columns, respectively. Depends on the first weekday as\nspecified in the constructor or set by the `setfirstweekday()` method. The\nearliest year for which a calendar can be generated is platform-dependent.\n\n"}, {"name": "calendar.TextCalendar.prmonth()", "path": "library/calendar#calendar.TextCalendar.prmonth", "type": "Data Types", "text": "\nPrint a month\u2019s calendar as returned by `formatmonth()`.\n\n"}, {"name": "calendar.TextCalendar.pryear()", "path": "library/calendar#calendar.TextCalendar.pryear", "type": "Data Types", "text": "\nPrint the calendar for an entire year as returned by `formatyear()`.\n\n"}, {"name": "calendar.timegm()", "path": "library/calendar#calendar.timegm", "type": "Data Types", "text": "\nAn unrelated but handy function that takes a time tuple such as returned by\nthe `gmtime()` function in the `time` module, and returns the corresponding\nUnix timestamp value, assuming an epoch of 1970, and the POSIX encoding. In\nfact, `time.gmtime()` and `timegm()` are each others\u2019 inverse.\n\n"}, {"name": "calendar.weekday()", "path": "library/calendar#calendar.weekday", "type": "Data Types", "text": "\nReturns the day of the week (`0` is Monday) for year (`1970`\u2013\u2026), month\n(`1`\u2013`12`), day (`1`\u2013`31`).\n\n"}, {"name": "calendar.weekheader()", "path": "library/calendar#calendar.weekheader", "type": "Data Types", "text": "\nReturn a header containing abbreviated weekday names. n specifies the width in\ncharacters for one weekday.\n\n"}, {"name": "callable()", "path": "library/functions#callable", "type": "Built-in Functions", "text": "\nReturn `True` if the object argument appears callable, `False` if not. If this\nreturns `True`, it is still possible that a call fails, but if it is `False`,\ncalling object will never succeed. Note that classes are callable (calling a\nclass returns a new instance); instances are callable if their class has a\n`__call__()` method.\n\n"}, {"name": "cgi", "path": "library/cgi", "type": "Internet", "text": "\nSource code: Lib/cgi.py\n\n"}, {"name": "cgi.FieldStorage.getfirst()", "path": "library/cgi#cgi.FieldStorage.getfirst", "type": "Internet", "text": "\nThis method always returns only one value associated with form field name. The\nmethod returns only the first value in case that more values were posted under\nsuch name. Please note that the order in which the values are received may\nvary from browser to browser and should not be counted on. 1 If no such form\nfield or value exists then the method returns the value specified by the\noptional parameter default. This parameter defaults to `None` if not\nspecified.\n\n"}, {"name": "cgi.FieldStorage.getlist()", "path": "library/cgi#cgi.FieldStorage.getlist", "type": "Internet", "text": "\nThis method always returns a list of values associated with form field name.\nThe method returns an empty list if no such form field or value exists for\nname. It returns a list consisting of one item if only one such value exists.\n\n"}, {"name": "cgi.parse()", "path": "library/cgi#cgi.parse", "type": "Internet", "text": "\nParse a query in the environment or from a file (the file defaults to\n`sys.stdin`). The keep_blank_values, strict_parsing and separator parameters\nare passed to `urllib.parse.parse_qs()` unchanged.\n\n"}, {"name": "cgi.parse_header()", "path": "library/cgi#cgi.parse_header", "type": "Internet", "text": "\nParse a MIME header (such as Content-Type) into a main value and a dictionary\nof parameters.\n\n"}, {"name": "cgi.parse_multipart()", "path": "library/cgi#cgi.parse_multipart", "type": "Internet", "text": "\nParse input of type multipart/form-data (for file uploads). Arguments are fp\nfor the input file, pdict for a dictionary containing other parameters in the\nContent-Type header, and encoding, the request encoding.\n\n"}, {"name": "cgi.print_directory()", "path": "library/cgi#cgi.print_directory", "type": "Internet", "text": "\nFormat the current directory in HTML.\n\n"}, {"name": "cgi.print_environ()", "path": "library/cgi#cgi.print_environ", "type": "Internet", "text": "\nFormat the shell environment in HTML.\n\n"}, {"name": "cgi.print_environ_usage()", "path": "library/cgi#cgi.print_environ_usage", "type": "Internet", "text": "\nPrint a list of useful (used by CGI) environment variables in HTML.\n\n"}, {"name": "cgi.print_form()", "path": "library/cgi#cgi.print_form", "type": "Internet", "text": "\nFormat a form in HTML.\n\n"}, {"name": "cgi.test()", "path": "library/cgi#cgi.test", "type": "Internet", "text": "\nRobust test CGI script, usable as main program. Writes minimal HTTP headers\nand formats all information provided to the script in HTML form.\n\n"}, {"name": "cgitb", "path": "library/cgitb", "type": "Internet", "text": "\nSource code: Lib/cgitb.py\n\n"}, {"name": "cgitb.enable()", "path": "library/cgitb#cgitb.enable", "type": "Internet", "text": "\nThis function causes the `cgitb` module to take over the interpreter\u2019s default\nhandling for exceptions by setting the value of `sys.excepthook`.\n\n"}, {"name": "cgitb.handler()", "path": "library/cgitb#cgitb.handler", "type": "Internet", "text": "\nThis function handles an exception using the default settings (that is, show a\nreport in the browser, but don\u2019t log to a file). This can be used when you\u2019ve\ncaught an exception and want to report it using `cgitb`. The optional info\nargument should be a 3-tuple containing an exception type, exception value,\nand traceback object, exactly like the tuple returned by `sys.exc_info()`. If\nthe info argument is not supplied, the current exception is obtained from\n`sys.exc_info()`.\n\n"}, {"name": "cgitb.html()", "path": "library/cgitb#cgitb.html", "type": "Internet", "text": "\nThis function handles the exception described by info (a 3-tuple containing\nthe result of `sys.exc_info()`), formatting its traceback as HTML and\nreturning the result as a string. The optional argument context is the number\nof lines of context to display around the current line of source code in the\ntraceback; this defaults to `5`.\n\n"}, {"name": "cgitb.text()", "path": "library/cgitb#cgitb.text", "type": "Internet", "text": "\nThis function handles the exception described by info (a 3-tuple containing\nthe result of `sys.exc_info()`), formatting its traceback as text and\nreturning the result as a string. The optional argument context is the number\nof lines of context to display around the current line of source code in the\ntraceback; this defaults to `5`.\n\n"}, {"name": "ChildProcessError", "path": "library/exceptions#ChildProcessError", "type": "Built-in Exceptions", "text": "\nRaised when an operation on a child process failed. Corresponds to `errno`\n`ECHILD`.\n\n"}, {"name": "chr()", "path": "library/functions#chr", "type": "Built-in Functions", "text": "\nReturn the string representing a character whose Unicode code point is the\ninteger i. For example, `chr(97)` returns the string `'a'`, while `chr(8364)`\nreturns the string `'\u20ac'`. This is the inverse of `ord()`.\n\n"}, {"name": "chunk", "path": "library/chunk", "type": "Multimedia", "text": "\nSource code: Lib/chunk.py\n\n"}, {"name": "chunk.Chunk", "path": "library/chunk#chunk.Chunk", "type": "Multimedia", "text": "\nClass which represents a chunk. The file argument is expected to be a file-\nlike object. An instance of this class is specifically allowed. The only\nmethod that is needed is `read()`. If the methods `seek()` and `tell()` are\npresent and don\u2019t raise an exception, they are also used. If these methods are\npresent and raise an exception, they are expected to not have altered the\nobject. If the optional argument align is true, chunks are assumed to be\naligned on 2-byte boundaries. If align is false, no alignment is assumed. The\ndefault value is true. If the optional argument bigendian is false, the chunk\nsize is assumed to be in little-endian order. This is needed for WAVE audio\nfiles. The default value is true. If the optional argument inclheader is true,\nthe size given in the chunk header includes the size of the header. The\ndefault value is false.\n\n"}, {"name": "chunk.Chunk.close()", "path": "library/chunk#chunk.Chunk.close", "type": "Multimedia", "text": "\nClose and skip to the end of the chunk. This does not close the underlying\nfile.\n\n"}, {"name": "chunk.Chunk.getname()", "path": "library/chunk#chunk.Chunk.getname", "type": "Multimedia", "text": "\nReturns the name (ID) of the chunk. This is the first 4 bytes of the chunk.\n\n"}, {"name": "chunk.Chunk.getsize()", "path": "library/chunk#chunk.Chunk.getsize", "type": "Multimedia", "text": "\nReturns the size of the chunk.\n\n"}, {"name": "chunk.Chunk.isatty()", "path": "library/chunk#chunk.Chunk.isatty", "type": "Multimedia", "text": "\nReturns `False`.\n\n"}, {"name": "chunk.Chunk.read()", "path": "library/chunk#chunk.Chunk.read", "type": "Multimedia", "text": "\nRead at most size bytes from the chunk (less if the read hits the end of the\nchunk before obtaining size bytes). If the size argument is negative or\nomitted, read all data until the end of the chunk. An empty bytes object is\nreturned when the end of the chunk is encountered immediately.\n\n"}, {"name": "chunk.Chunk.seek()", "path": "library/chunk#chunk.Chunk.seek", "type": "Multimedia", "text": "\nSet the chunk\u2019s current position. The whence argument is optional and defaults\nto `0` (absolute file positioning); other values are `1` (seek relative to the\ncurrent position) and `2` (seek relative to the file\u2019s end). There is no\nreturn value. If the underlying file does not allow seek, only forward seeks\nare allowed.\n\n"}, {"name": "chunk.Chunk.skip()", "path": "library/chunk#chunk.Chunk.skip", "type": "Multimedia", "text": "\nSkip to the end of the chunk. All further calls to `read()` for the chunk will\nreturn `b''`. If you are not interested in the contents of the chunk, this\nmethod should be called so that the file points to the start of the next\nchunk.\n\n"}, {"name": "chunk.Chunk.tell()", "path": "library/chunk#chunk.Chunk.tell", "type": "Multimedia", "text": "\nReturn the current position into the chunk.\n\n"}, {"name": "class.mro()", "path": "library/stdtypes#class.mro", "type": "Built-in Types", "text": "\nThis method can be overridden by a metaclass to customize the method\nresolution order for its instances. It is called at class instantiation, and\nits result is stored in `__mro__`.\n\n"}, {"name": "class.__bases__", "path": "library/stdtypes#class.__bases__", "type": "Built-in Types", "text": "\nThe tuple of base classes of a class object.\n\n"}, {"name": "class.__mro__", "path": "library/stdtypes#class.__mro__", "type": "Built-in Types", "text": "\nThis attribute is a tuple of classes that are considered when looking for base\nclasses during method resolution.\n\n"}, {"name": "class.__subclasses__()", "path": "library/stdtypes#class.__subclasses__", "type": "Built-in Types", "text": "\nEach class keeps a list of weak references to its immediate subclasses. This\nmethod returns a list of all those references still alive. The list is in\ndefinition order. Example:\n\n"}, {"name": "classmethod()", "path": "library/functions#classmethod", "type": "Built-in Functions", "text": "\nTransform a method into a class method.\n\n"}, {"name": "cmath", "path": "library/cmath", "type": "Numeric & Mathematical", "text": "\nThis module provides access to mathematical functions for complex numbers. The\nfunctions in this module accept integers, floating-point numbers or complex\nnumbers as arguments. They will also accept any Python object that has either\na `__complex__()` or a `__float__()` method: these methods are used to convert\nthe object to a complex or floating-point number, respectively, and the\nfunction is then applied to the result of the conversion.\n\n"}, {"name": "cmath.acos()", "path": "library/cmath#cmath.acos", "type": "Numeric & Mathematical", "text": "\nReturn the arc cosine of x. There are two branch cuts: One extends right from\n1 along the real axis to \u221e, continuous from below. The other extends left from\n-1 along the real axis to -\u221e, continuous from above.\n\n"}, {"name": "cmath.acosh()", "path": "library/cmath#cmath.acosh", "type": "Numeric & Mathematical", "text": "\nReturn the inverse hyperbolic cosine of x. There is one branch cut, extending\nleft from 1 along the real axis to -\u221e, continuous from above.\n\n"}, {"name": "cmath.asin()", "path": "library/cmath#cmath.asin", "type": "Numeric & Mathematical", "text": "\nReturn the arc sine of x. This has the same branch cuts as `acos()`.\n\n"}, {"name": "cmath.asinh()", "path": "library/cmath#cmath.asinh", "type": "Numeric & Mathematical", "text": "\nReturn the inverse hyperbolic sine of x. There are two branch cuts: One\nextends from `1j` along the imaginary axis to `\u221ej`, continuous from the right.\nThe other extends from `-1j` along the imaginary axis to `-\u221ej`, continuous\nfrom the left.\n\n"}, {"name": "cmath.atan()", "path": "library/cmath#cmath.atan", "type": "Numeric & Mathematical", "text": "\nReturn the arc tangent of x. There are two branch cuts: One extends from `1j`\nalong the imaginary axis to `\u221ej`, continuous from the right. The other extends\nfrom `-1j` along the imaginary axis to `-\u221ej`, continuous from the left.\n\n"}, {"name": "cmath.atanh()", "path": "library/cmath#cmath.atanh", "type": "Numeric & Mathematical", "text": "\nReturn the inverse hyperbolic tangent of x. There are two branch cuts: One\nextends from `1` along the real axis to `\u221e`, continuous from below. The other\nextends from `-1` along the real axis to `-\u221e`, continuous from above.\n\n"}, {"name": "cmath.cos()", "path": "library/cmath#cmath.cos", "type": "Numeric & Mathematical", "text": "\nReturn the cosine of x.\n\n"}, {"name": "cmath.cosh()", "path": "library/cmath#cmath.cosh", "type": "Numeric & Mathematical", "text": "\nReturn the hyperbolic cosine of x.\n\n"}, {"name": "cmath.e", "path": "library/cmath#cmath.e", "type": "Numeric & Mathematical", "text": "\nThe mathematical constant e, as a float.\n\n"}, {"name": "cmath.exp()", "path": "library/cmath#cmath.exp", "type": "Numeric & Mathematical", "text": "\nReturn e raised to the power x, where e is the base of natural logarithms.\n\n"}, {"name": "cmath.inf", "path": "library/cmath#cmath.inf", "type": "Numeric & Mathematical", "text": "\nFloating-point positive infinity. Equivalent to `float('inf')`.\n\n"}, {"name": "cmath.infj", "path": "library/cmath#cmath.infj", "type": "Numeric & Mathematical", "text": "\nComplex number with zero real part and positive infinity imaginary part.\nEquivalent to `complex(0.0, float('inf'))`.\n\n"}, {"name": "cmath.isclose()", "path": "library/cmath#cmath.isclose", "type": "Numeric & Mathematical", "text": "\nReturn `True` if the values a and b are close to each other and `False`\notherwise.\n\n"}, {"name": "cmath.isfinite()", "path": "library/cmath#cmath.isfinite", "type": "Numeric & Mathematical", "text": "\nReturn `True` if both the real and imaginary parts of x are finite, and\n`False` otherwise.\n\n"}, {"name": "cmath.isinf()", "path": "library/cmath#cmath.isinf", "type": "Numeric & Mathematical", "text": "\nReturn `True` if either the real or the imaginary part of x is an infinity,\nand `False` otherwise.\n\n"}, {"name": "cmath.isnan()", "path": "library/cmath#cmath.isnan", "type": "Numeric & Mathematical", "text": "\nReturn `True` if either the real or the imaginary part of x is a NaN, and\n`False` otherwise.\n\n"}, {"name": "cmath.log()", "path": "library/cmath#cmath.log", "type": "Numeric & Mathematical", "text": "\nReturns the logarithm of x to the given base. If the base is not specified,\nreturns the natural logarithm of x. There is one branch cut, from 0 along the\nnegative real axis to -\u221e, continuous from above.\n\n"}, {"name": "cmath.log10()", "path": "library/cmath#cmath.log10", "type": "Numeric & Mathematical", "text": "\nReturn the base-10 logarithm of x. This has the same branch cut as `log()`.\n\n"}, {"name": "cmath.nan", "path": "library/cmath#cmath.nan", "type": "Numeric & Mathematical", "text": "\nA floating-point \u201cnot a number\u201d (NaN) value. Equivalent to `float('nan')`.\n\n"}, {"name": "cmath.nanj", "path": "library/cmath#cmath.nanj", "type": "Numeric & Mathematical", "text": "\nComplex number with zero real part and NaN imaginary part. Equivalent to\n`complex(0.0, float('nan'))`.\n\n"}, {"name": "cmath.phase()", "path": "library/cmath#cmath.phase", "type": "Numeric & Mathematical", "text": "\nReturn the phase of x (also known as the argument of x), as a float.\n`phase(x)` is equivalent to `math.atan2(x.imag, x.real)`. The result lies in\nthe range [-\u03c0, \u03c0], and the branch cut for this operation lies along the\nnegative real axis, continuous from above. On systems with support for signed\nzeros (which includes most systems in current use), this means that the sign\nof the result is the same as the sign of `x.imag`, even when `x.imag` is zero:\n\n"}, {"name": "cmath.pi", "path": "library/cmath#cmath.pi", "type": "Numeric & Mathematical", "text": "\nThe mathematical constant \u03c0, as a float.\n\n"}, {"name": "cmath.polar()", "path": "library/cmath#cmath.polar", "type": "Numeric & Mathematical", "text": "\nReturn the representation of x in polar coordinates. Returns a pair `(r, phi)`\nwhere r is the modulus of x and phi is the phase of x. `polar(x)` is\nequivalent to `(abs(x), phase(x))`.\n\n"}, {"name": "cmath.rect()", "path": "library/cmath#cmath.rect", "type": "Numeric & Mathematical", "text": "\nReturn the complex number x with polar coordinates r and phi. Equivalent to `r\n* (math.cos(phi) + math.sin(phi)*1j)`.\n\n"}, {"name": "cmath.sin()", "path": "library/cmath#cmath.sin", "type": "Numeric & Mathematical", "text": "\nReturn the sine of x.\n\n"}, {"name": "cmath.sinh()", "path": "library/cmath#cmath.sinh", "type": "Numeric & Mathematical", "text": "\nReturn the hyperbolic sine of x.\n\n"}, {"name": "cmath.sqrt()", "path": "library/cmath#cmath.sqrt", "type": "Numeric & Mathematical", "text": "\nReturn the square root of x. This has the same branch cut as `log()`.\n\n"}, {"name": "cmath.tan()", "path": "library/cmath#cmath.tan", "type": "Numeric & Mathematical", "text": "\nReturn the tangent of x.\n\n"}, {"name": "cmath.tanh()", "path": "library/cmath#cmath.tanh", "type": "Numeric & Mathematical", "text": "\nReturn the hyperbolic tangent of x.\n\n"}, {"name": "cmath.tau", "path": "library/cmath#cmath.tau", "type": "Numeric & Mathematical", "text": "\nThe mathematical constant \u03c4, as a float.\n\n"}, {"name": "cmd", "path": "library/cmd", "type": "Frameworks", "text": "\nSource code: Lib/cmd.py\n\n"}, {"name": "cmd.Cmd", "path": "library/cmd#cmd.Cmd", "type": "Frameworks", "text": "\nA `Cmd` instance or subclass instance is a line-oriented interpreter\nframework. There is no good reason to instantiate `Cmd` itself; rather, it\u2019s\nuseful as a superclass of an interpreter class you define yourself in order to\ninherit `Cmd`\u2019s methods and encapsulate action methods.\n\n"}, {"name": "cmd.Cmd.cmdloop()", "path": "library/cmd#cmd.Cmd.cmdloop", "type": "Frameworks", "text": "\nRepeatedly issue a prompt, accept input, parse an initial prefix off the\nreceived input, and dispatch to action methods, passing them the remainder of\nthe line as argument.\n\n"}, {"name": "cmd.Cmd.cmdqueue", "path": "library/cmd#cmd.Cmd.cmdqueue", "type": "Frameworks", "text": "\nA list of queued input lines. The cmdqueue list is checked in `cmdloop()` when\nnew input is needed; if it is nonempty, its elements will be processed in\norder, as if entered at the prompt.\n\n"}, {"name": "cmd.Cmd.completedefault()", "path": "library/cmd#cmd.Cmd.completedefault", "type": "Frameworks", "text": "\nMethod called to complete an input line when no command-specific\n`complete_*()` method is available. By default, it returns an empty list.\n\n"}, {"name": "cmd.Cmd.default()", "path": "library/cmd#cmd.Cmd.default", "type": "Frameworks", "text": "\nMethod called on an input line when the command prefix is not recognized. If\nthis method is not overridden, it prints an error message and returns.\n\n"}, {"name": "cmd.Cmd.doc_header", "path": "library/cmd#cmd.Cmd.doc_header", "type": "Frameworks", "text": "\nThe header to issue if the help output has a section for documented commands.\n\n"}, {"name": "cmd.Cmd.emptyline()", "path": "library/cmd#cmd.Cmd.emptyline", "type": "Frameworks", "text": "\nMethod called when an empty line is entered in response to the prompt. If this\nmethod is not overridden, it repeats the last nonempty command entered.\n\n"}, {"name": "cmd.Cmd.identchars", "path": "library/cmd#cmd.Cmd.identchars", "type": "Frameworks", "text": "\nThe string of characters accepted for the command prefix.\n\n"}, {"name": "cmd.Cmd.intro", "path": "library/cmd#cmd.Cmd.intro", "type": "Frameworks", "text": "\nA string to issue as an intro or banner. May be overridden by giving the\n`cmdloop()` method an argument.\n\n"}, {"name": "cmd.Cmd.lastcmd", "path": "library/cmd#cmd.Cmd.lastcmd", "type": "Frameworks", "text": "\nThe last nonempty command prefix seen.\n\n"}, {"name": "cmd.Cmd.misc_header", "path": "library/cmd#cmd.Cmd.misc_header", "type": "Frameworks", "text": "\nThe header to issue if the help output has a section for miscellaneous help\ntopics (that is, there are `help_*()` methods without corresponding `do_*()`\nmethods).\n\n"}, {"name": "cmd.Cmd.onecmd()", "path": "library/cmd#cmd.Cmd.onecmd", "type": "Frameworks", "text": "\nInterpret the argument as though it had been typed in response to the prompt.\nThis may be overridden, but should not normally need to be; see the `precmd()`\nand `postcmd()` methods for useful execution hooks. The return value is a flag\nindicating whether interpretation of commands by the interpreter should stop.\nIf there is a `do_*()` method for the command str, the return value of that\nmethod is returned, otherwise the return value from the `default()` method is\nreturned.\n\n"}, {"name": "cmd.Cmd.postcmd()", "path": "library/cmd#cmd.Cmd.postcmd", "type": "Frameworks", "text": "\nHook method executed just after a command dispatch is finished. This method is\na stub in `Cmd`; it exists to be overridden by subclasses. line is the command\nline which was executed, and stop is a flag which indicates whether execution\nwill be terminated after the call to `postcmd()`; this will be the return\nvalue of the `onecmd()` method. The return value of this method will be used\nas the new value for the internal flag which corresponds to stop; returning\nfalse will cause interpretation to continue.\n\n"}, {"name": "cmd.Cmd.postloop()", "path": "library/cmd#cmd.Cmd.postloop", "type": "Frameworks", "text": "\nHook method executed once when `cmdloop()` is about to return. This method is\na stub in `Cmd`; it exists to be overridden by subclasses.\n\n"}, {"name": "cmd.Cmd.precmd()", "path": "library/cmd#cmd.Cmd.precmd", "type": "Frameworks", "text": "\nHook method executed just before the command line line is interpreted, but\nafter the input prompt is generated and issued. This method is a stub in\n`Cmd`; it exists to be overridden by subclasses. The return value is used as\nthe command which will be executed by the `onecmd()` method; the `precmd()`\nimplementation may re-write the command or simply return line unchanged.\n\n"}, {"name": "cmd.Cmd.preloop()", "path": "library/cmd#cmd.Cmd.preloop", "type": "Frameworks", "text": "\nHook method executed once when `cmdloop()` is called. This method is a stub in\n`Cmd`; it exists to be overridden by subclasses.\n\n"}, {"name": "cmd.Cmd.prompt", "path": "library/cmd#cmd.Cmd.prompt", "type": "Frameworks", "text": "\nThe prompt issued to solicit input.\n\n"}, {"name": "cmd.Cmd.ruler", "path": "library/cmd#cmd.Cmd.ruler", "type": "Frameworks", "text": "\nThe character used to draw separator lines under the help-message headers. If\nempty, no ruler line is drawn. It defaults to `'='`.\n\n"}, {"name": "cmd.Cmd.undoc_header", "path": "library/cmd#cmd.Cmd.undoc_header", "type": "Frameworks", "text": "\nThe header to issue if the help output has a section for undocumented commands\n(that is, there are `do_*()` methods without corresponding `help_*()`\nmethods).\n\n"}, {"name": "cmd.Cmd.use_rawinput", "path": "library/cmd#cmd.Cmd.use_rawinput", "type": "Frameworks", "text": "\nA flag, defaulting to true. If true, `cmdloop()` uses `input()` to display a\nprompt and read the next command; if false, `sys.stdout.write()` and\n`sys.stdin.readline()` are used. (This means that by importing `readline`, on\nsystems that support it, the interpreter will automatically support Emacs-like\nline editing and command-history keystrokes.)\n\n"}, {"name": "code", "path": "library/code", "type": "Interpreters", "text": "\nSource code: Lib/code.py\n\n"}, {"name": "code.compile_command()", "path": "library/code#code.compile_command", "type": "Interpreters", "text": "\nThis function is useful for programs that want to emulate Python\u2019s interpreter\nmain loop (a.k.a. the read-eval-print loop). The tricky part is to determine\nwhen the user has entered an incomplete command that can be completed by\nentering more text (as opposed to a complete command or a syntax error). This\nfunction almost always makes the same decision as the real interpreter main\nloop.\n\n"}, {"name": "code.interact()", "path": "library/code#code.interact", "type": "Interpreters", "text": "\nConvenience function to run a read-eval-print loop. This creates a new\ninstance of `InteractiveConsole` and sets readfunc to be used as the\n`InteractiveConsole.raw_input()` method, if provided. If local is provided, it\nis passed to the `InteractiveConsole` constructor for use as the default\nnamespace for the interpreter loop. The `interact()` method of the instance is\nthen run with banner and exitmsg passed as the banner and exit message to use,\nif provided. The console object is discarded after use.\n\n"}, {"name": "code.InteractiveConsole", "path": "library/code#code.InteractiveConsole", "type": "Interpreters", "text": "\nClosely emulate the behavior of the interactive Python interpreter. This class\nbuilds on `InteractiveInterpreter` and adds prompting using the familiar\n`sys.ps1` and `sys.ps2`, and input buffering.\n\n"}, {"name": "code.InteractiveConsole.interact()", "path": "library/code#code.InteractiveConsole.interact", "type": "Interpreters", "text": "\nClosely emulate the interactive Python console. The optional banner argument\nspecify the banner to print before the first interaction; by default it prints\na banner similar to the one printed by the standard Python interpreter,\nfollowed by the class name of the console object in parentheses (so as not to\nconfuse this with the real interpreter \u2013 since it\u2019s so close!).\n\n"}, {"name": "code.InteractiveConsole.push()", "path": "library/code#code.InteractiveConsole.push", "type": "Interpreters", "text": "\nPush a line of source text to the interpreter. The line should not have a\ntrailing newline; it may have internal newlines. The line is appended to a\nbuffer and the interpreter\u2019s `runsource()` method is called with the\nconcatenated contents of the buffer as source. If this indicates that the\ncommand was executed or invalid, the buffer is reset; otherwise, the command\nis incomplete, and the buffer is left as it was after the line was appended.\nThe return value is `True` if more input is required, `False` if the line was\ndealt with in some way (this is the same as `runsource()`).\n\n"}, {"name": "code.InteractiveConsole.raw_input()", "path": "library/code#code.InteractiveConsole.raw_input", "type": "Interpreters", "text": "\nWrite a prompt and read a line. The returned line does not include the\ntrailing newline. When the user enters the EOF key sequence, `EOFError` is\nraised. The base implementation reads from `sys.stdin`; a subclass may replace\nthis with a different implementation.\n\n"}, {"name": "code.InteractiveConsole.resetbuffer()", "path": "library/code#code.InteractiveConsole.resetbuffer", "type": "Interpreters", "text": "\nRemove any unhandled source text from the input buffer.\n\n"}, {"name": "code.InteractiveInterpreter", "path": "library/code#code.InteractiveInterpreter", "type": "Interpreters", "text": "\nThis class deals with parsing and interpreter state (the user\u2019s namespace); it\ndoes not deal with input buffering or prompting or input file naming (the\nfilename is always passed in explicitly). The optional locals argument\nspecifies the dictionary in which code will be executed; it defaults to a\nnewly created dictionary with key `'__name__'` set to `'__console__'` and key\n`'__doc__'` set to `None`.\n\n"}, {"name": "code.InteractiveInterpreter.runcode()", "path": "library/code#code.InteractiveInterpreter.runcode", "type": "Interpreters", "text": "\nExecute a code object. When an exception occurs, `showtraceback()` is called\nto display a traceback. All exceptions are caught except `SystemExit`, which\nis allowed to propagate.\n\n"}, {"name": "code.InteractiveInterpreter.runsource()", "path": "library/code#code.InteractiveInterpreter.runsource", "type": "Interpreters", "text": "\nCompile and run some source in the interpreter. Arguments are the same as for\n`compile_command()`; the default for filename is `'<input>'`, and for symbol\nis `'single'`. One of several things can happen:\n\n"}, {"name": "code.InteractiveInterpreter.showsyntaxerror()", "path": "library/code#code.InteractiveInterpreter.showsyntaxerror", "type": "Interpreters", "text": "\nDisplay the syntax error that just occurred. This does not display a stack\ntrace because there isn\u2019t one for syntax errors. If filename is given, it is\nstuffed into the exception instead of the default filename provided by\nPython\u2019s parser, because it always uses `'<string>'` when reading from a\nstring. The output is written by the `write()` method.\n\n"}, {"name": "code.InteractiveInterpreter.showtraceback()", "path": "library/code#code.InteractiveInterpreter.showtraceback", "type": "Interpreters", "text": "\nDisplay the exception that just occurred. We remove the first stack item\nbecause it is within the interpreter object implementation. The output is\nwritten by the `write()` method.\n\n"}, {"name": "code.InteractiveInterpreter.write()", "path": "library/code#code.InteractiveInterpreter.write", "type": "Interpreters", "text": "\nWrite a string to the standard error stream (`sys.stderr`). Derived classes\nshould override this to provide the appropriate output handling as needed.\n\n"}, {"name": "codecs", "path": "library/codecs", "type": "Binary Data", "text": "\nSource code: Lib/codecs.py\n\n"}, {"name": "codecs.backslashreplace_errors()", "path": "library/codecs#codecs.backslashreplace_errors", "type": "Binary Data", "text": "\nImplements the `'backslashreplace'` error handling (for text encodings only):\nmalformed data is replaced by a backslashed escape sequence.\n\n"}, {"name": "codecs.BOM", "path": "library/codecs#codecs.BOM", "type": "Binary Data", "text": "\nThese constants define various byte sequences, being Unicode byte order marks\n(BOMs) for several encodings. They are used in UTF-16 and UTF-32 data streams\nto indicate the byte order used, and in UTF-8 as a Unicode signature.\n`BOM_UTF16` is either `BOM_UTF16_BE` or `BOM_UTF16_LE` depending on the\nplatform\u2019s native byte order, `BOM` is an alias for `BOM_UTF16`, `BOM_LE` for\n`BOM_UTF16_LE` and `BOM_BE` for `BOM_UTF16_BE`. The others represent the BOM\nin UTF-8 and UTF-32 encodings.\n\n"}, {"name": "codecs.BOM_BE", "path": "library/codecs#codecs.BOM_BE", "type": "Binary Data", "text": "\nThese constants define various byte sequences, being Unicode byte order marks\n(BOMs) for several encodings. They are used in UTF-16 and UTF-32 data streams\nto indicate the byte order used, and in UTF-8 as a Unicode signature.\n`BOM_UTF16` is either `BOM_UTF16_BE` or `BOM_UTF16_LE` depending on the\nplatform\u2019s native byte order, `BOM` is an alias for `BOM_UTF16`, `BOM_LE` for\n`BOM_UTF16_LE` and `BOM_BE` for `BOM_UTF16_BE`. The others represent the BOM\nin UTF-8 and UTF-32 encodings.\n\n"}, {"name": "codecs.BOM_LE", "path": "library/codecs#codecs.BOM_LE", "type": "Binary Data", "text": "\nThese constants define various byte sequences, being Unicode byte order marks\n(BOMs) for several encodings. They are used in UTF-16 and UTF-32 data streams\nto indicate the byte order used, and in UTF-8 as a Unicode signature.\n`BOM_UTF16` is either `BOM_UTF16_BE` or `BOM_UTF16_LE` depending on the\nplatform\u2019s native byte order, `BOM` is an alias for `BOM_UTF16`, `BOM_LE` for\n`BOM_UTF16_LE` and `BOM_BE` for `BOM_UTF16_BE`. The others represent the BOM\nin UTF-8 and UTF-32 encodings.\n\n"}, {"name": "codecs.BOM_UTF16", "path": "library/codecs#codecs.BOM_UTF16", "type": "Binary Data", "text": "\nThese constants define various byte sequences, being Unicode byte order marks\n(BOMs) for several encodings. They are used in UTF-16 and UTF-32 data streams\nto indicate the byte order used, and in UTF-8 as a Unicode signature.\n`BOM_UTF16` is either `BOM_UTF16_BE` or `BOM_UTF16_LE` depending on the\nplatform\u2019s native byte order, `BOM` is an alias for `BOM_UTF16`, `BOM_LE` for\n`BOM_UTF16_LE` and `BOM_BE` for `BOM_UTF16_BE`. The others represent the BOM\nin UTF-8 and UTF-32 encodings.\n\n"}, {"name": "codecs.BOM_UTF16_BE", "path": "library/codecs#codecs.BOM_UTF16_BE", "type": "Binary Data", "text": "\nThese constants define various byte sequences, being Unicode byte order marks\n(BOMs) for several encodings. They are used in UTF-16 and UTF-32 data streams\nto indicate the byte order used, and in UTF-8 as a Unicode signature.\n`BOM_UTF16` is either `BOM_UTF16_BE` or `BOM_UTF16_LE` depending on the\nplatform\u2019s native byte order, `BOM` is an alias for `BOM_UTF16`, `BOM_LE` for\n`BOM_UTF16_LE` and `BOM_BE` for `BOM_UTF16_BE`. The others represent the BOM\nin UTF-8 and UTF-32 encodings.\n\n"}, {"name": "codecs.BOM_UTF16_LE", "path": "library/codecs#codecs.BOM_UTF16_LE", "type": "Binary Data", "text": "\nThese constants define various byte sequences, being Unicode byte order marks\n(BOMs) for several encodings. They are used in UTF-16 and UTF-32 data streams\nto indicate the byte order used, and in UTF-8 as a Unicode signature.\n`BOM_UTF16` is either `BOM_UTF16_BE` or `BOM_UTF16_LE` depending on the\nplatform\u2019s native byte order, `BOM` is an alias for `BOM_UTF16`, `BOM_LE` for\n`BOM_UTF16_LE` and `BOM_BE` for `BOM_UTF16_BE`. The others represent the BOM\nin UTF-8 and UTF-32 encodings.\n\n"}, {"name": "codecs.BOM_UTF32", "path": "library/codecs#codecs.BOM_UTF32", "type": "Binary Data", "text": "\nThese constants define various byte sequences, being Unicode byte order marks\n(BOMs) for several encodings. They are used in UTF-16 and UTF-32 data streams\nto indicate the byte order used, and in UTF-8 as a Unicode signature.\n`BOM_UTF16` is either `BOM_UTF16_BE` or `BOM_UTF16_LE` depending on the\nplatform\u2019s native byte order, `BOM` is an alias for `BOM_UTF16`, `BOM_LE` for\n`BOM_UTF16_LE` and `BOM_BE` for `BOM_UTF16_BE`. The others represent the BOM\nin UTF-8 and UTF-32 encodings.\n\n"}, {"name": "codecs.BOM_UTF32_BE", "path": "library/codecs#codecs.BOM_UTF32_BE", "type": "Binary Data", "text": "\nThese constants define various byte sequences, being Unicode byte order marks\n(BOMs) for several encodings. They are used in UTF-16 and UTF-32 data streams\nto indicate the byte order used, and in UTF-8 as a Unicode signature.\n`BOM_UTF16` is either `BOM_UTF16_BE` or `BOM_UTF16_LE` depending on the\nplatform\u2019s native byte order, `BOM` is an alias for `BOM_UTF16`, `BOM_LE` for\n`BOM_UTF16_LE` and `BOM_BE` for `BOM_UTF16_BE`. The others represent the BOM\nin UTF-8 and UTF-32 encodings.\n\n"}, {"name": "codecs.BOM_UTF32_LE", "path": "library/codecs#codecs.BOM_UTF32_LE", "type": "Binary Data", "text": "\nThese constants define various byte sequences, being Unicode byte order marks\n(BOMs) for several encodings. They are used in UTF-16 and UTF-32 data streams\nto indicate the byte order used, and in UTF-8 as a Unicode signature.\n`BOM_UTF16` is either `BOM_UTF16_BE` or `BOM_UTF16_LE` depending on the\nplatform\u2019s native byte order, `BOM` is an alias for `BOM_UTF16`, `BOM_LE` for\n`BOM_UTF16_LE` and `BOM_BE` for `BOM_UTF16_BE`. The others represent the BOM\nin UTF-8 and UTF-32 encodings.\n\n"}, {"name": "codecs.BOM_UTF8", "path": "library/codecs#codecs.BOM_UTF8", "type": "Binary Data", "text": "\nThese constants define various byte sequences, being Unicode byte order marks\n(BOMs) for several encodings. They are used in UTF-16 and UTF-32 data streams\nto indicate the byte order used, and in UTF-8 as a Unicode signature.\n`BOM_UTF16` is either `BOM_UTF16_BE` or `BOM_UTF16_LE` depending on the\nplatform\u2019s native byte order, `BOM` is an alias for `BOM_UTF16`, `BOM_LE` for\n`BOM_UTF16_LE` and `BOM_BE` for `BOM_UTF16_BE`. The others represent the BOM\nin UTF-8 and UTF-32 encodings.\n\n"}, {"name": "codecs.Codec.decode()", "path": "library/codecs#codecs.Codec.decode", "type": "Binary Data", "text": "\nDecodes the object input and returns a tuple (output object, length consumed).\nFor instance, for a text encoding, decoding converts a bytes object encoded\nusing a particular character set encoding to a string object.\n\n"}, {"name": "codecs.Codec.encode()", "path": "library/codecs#codecs.Codec.encode", "type": "Binary Data", "text": "\nEncodes the object input and returns a tuple (output object, length consumed).\nFor instance, text encoding converts a string object to a bytes object using a\nparticular character set encoding (e.g., `cp1252` or `iso-8859-1`).\n\n"}, {"name": "codecs.CodecInfo", "path": "library/codecs#codecs.CodecInfo", "type": "Binary Data", "text": "\nCodec details when looking up the codec registry. The constructor arguments\nare stored in attributes of the same name:\n\n"}, {"name": "codecs.CodecInfo.decode", "path": "library/codecs#codecs.CodecInfo.decode", "type": "Binary Data", "text": "\nThe stateless encoding and decoding functions. These must be functions or\nmethods which have the same interface as the `encode()` and `decode()` methods\nof Codec instances (see Codec Interface). The functions or methods are\nexpected to work in a stateless mode.\n\n"}, {"name": "codecs.CodecInfo.encode", "path": "library/codecs#codecs.CodecInfo.encode", "type": "Binary Data", "text": "\nThe stateless encoding and decoding functions. These must be functions or\nmethods which have the same interface as the `encode()` and `decode()` methods\nof Codec instances (see Codec Interface). The functions or methods are\nexpected to work in a stateless mode.\n\n"}, {"name": "codecs.CodecInfo.incrementaldecoder", "path": "library/codecs#codecs.CodecInfo.incrementaldecoder", "type": "Binary Data", "text": "\nIncremental encoder and decoder classes or factory functions. These have to\nprovide the interface defined by the base classes `IncrementalEncoder` and\n`IncrementalDecoder`, respectively. Incremental codecs can maintain state.\n\n"}, {"name": "codecs.CodecInfo.incrementalencoder", "path": "library/codecs#codecs.CodecInfo.incrementalencoder", "type": "Binary Data", "text": "\nIncremental encoder and decoder classes or factory functions. These have to\nprovide the interface defined by the base classes `IncrementalEncoder` and\n`IncrementalDecoder`, respectively. Incremental codecs can maintain state.\n\n"}, {"name": "codecs.CodecInfo.name", "path": "library/codecs#codecs.CodecInfo.name", "type": "Binary Data", "text": "\nThe name of the encoding.\n\n"}, {"name": "codecs.CodecInfo.streamreader", "path": "library/codecs#codecs.CodecInfo.streamreader", "type": "Binary Data", "text": "\nStream writer and reader classes or factory functions. These have to provide\nthe interface defined by the base classes `StreamWriter` and `StreamReader`,\nrespectively. Stream codecs can maintain state.\n\n"}, {"name": "codecs.CodecInfo.streamwriter", "path": "library/codecs#codecs.CodecInfo.streamwriter", "type": "Binary Data", "text": "\nStream writer and reader classes or factory functions. These have to provide\nthe interface defined by the base classes `StreamWriter` and `StreamReader`,\nrespectively. Stream codecs can maintain state.\n\n"}, {"name": "codecs.decode()", "path": "library/codecs#codecs.decode", "type": "Binary Data", "text": "\nDecodes obj using the codec registered for encoding.\n\n"}, {"name": "codecs.encode()", "path": "library/codecs#codecs.encode", "type": "Binary Data", "text": "\nEncodes obj using the codec registered for encoding.\n\n"}, {"name": "codecs.EncodedFile()", "path": "library/codecs#codecs.EncodedFile", "type": "Binary Data", "text": "\nReturn a `StreamRecoder` instance, a wrapped version of file which provides\ntransparent transcoding. The original file is closed when the wrapped version\nis closed.\n\n"}, {"name": "codecs.getdecoder()", "path": "library/codecs#codecs.getdecoder", "type": "Binary Data", "text": "\nLook up the codec for the given encoding and return its decoder function.\n\n"}, {"name": "codecs.getencoder()", "path": "library/codecs#codecs.getencoder", "type": "Binary Data", "text": "\nLook up the codec for the given encoding and return its encoder function.\n\n"}, {"name": "codecs.getincrementaldecoder()", "path": "library/codecs#codecs.getincrementaldecoder", "type": "Binary Data", "text": "\nLook up the codec for the given encoding and return its incremental decoder\nclass or factory function.\n\n"}, {"name": "codecs.getincrementalencoder()", "path": "library/codecs#codecs.getincrementalencoder", "type": "Binary Data", "text": "\nLook up the codec for the given encoding and return its incremental encoder\nclass or factory function.\n\n"}, {"name": "codecs.getreader()", "path": "library/codecs#codecs.getreader", "type": "Binary Data", "text": "\nLook up the codec for the given encoding and return its `StreamReader` class\nor factory function.\n\n"}, {"name": "codecs.getwriter()", "path": "library/codecs#codecs.getwriter", "type": "Binary Data", "text": "\nLook up the codec for the given encoding and return its `StreamWriter` class\nor factory function.\n\n"}, {"name": "codecs.ignore_errors()", "path": "library/codecs#codecs.ignore_errors", "type": "Binary Data", "text": "\nImplements the `'ignore'` error handling: malformed data is ignored and\nencoding or decoding is continued without further notice.\n\n"}, {"name": "codecs.IncrementalDecoder", "path": "library/codecs#codecs.IncrementalDecoder", "type": "Binary Data", "text": "\nConstructor for an `IncrementalDecoder` instance.\n\n"}, {"name": "codecs.IncrementalDecoder.decode()", "path": "library/codecs#codecs.IncrementalDecoder.decode", "type": "Binary Data", "text": "\nDecodes object (taking the current state of the decoder into account) and\nreturns the resulting decoded object. If this is the last call to `decode()`\nfinal must be true (the default is false). If final is true the decoder must\ndecode the input completely and must flush all buffers. If this isn\u2019t possible\n(e.g. because of incomplete byte sequences at the end of the input) it must\ninitiate error handling just like in the stateless case (which might raise an\nexception).\n\n"}, {"name": "codecs.IncrementalDecoder.getstate()", "path": "library/codecs#codecs.IncrementalDecoder.getstate", "type": "Binary Data", "text": "\nReturn the current state of the decoder. This must be a tuple with two items,\nthe first must be the buffer containing the still undecoded input. The second\nmust be an integer and can be additional state info. (The implementation\nshould make sure that `0` is the most common additional state info.) If this\nadditional state info is `0` it must be possible to set the decoder to the\nstate which has no input buffered and `0` as the additional state info, so\nthat feeding the previously buffered input to the decoder returns it to the\nprevious state without producing any output. (Additional state info that is\nmore complicated than integers can be converted into an integer by\nmarshaling/pickling the info and encoding the bytes of the resulting string\ninto an integer.)\n\n"}, {"name": "codecs.IncrementalDecoder.reset()", "path": "library/codecs#codecs.IncrementalDecoder.reset", "type": "Binary Data", "text": "\nReset the decoder to the initial state.\n\n"}, {"name": "codecs.IncrementalDecoder.setstate()", "path": "library/codecs#codecs.IncrementalDecoder.setstate", "type": "Binary Data", "text": "\nSet the state of the decoder to state. state must be a decoder state returned\nby `getstate()`.\n\n"}, {"name": "codecs.IncrementalEncoder", "path": "library/codecs#codecs.IncrementalEncoder", "type": "Binary Data", "text": "\nConstructor for an `IncrementalEncoder` instance.\n\n"}, {"name": "codecs.IncrementalEncoder.encode()", "path": "library/codecs#codecs.IncrementalEncoder.encode", "type": "Binary Data", "text": "\nEncodes object (taking the current state of the encoder into account) and\nreturns the resulting encoded object. If this is the last call to `encode()`\nfinal must be true (the default is false).\n\n"}, {"name": "codecs.IncrementalEncoder.getstate()", "path": "library/codecs#codecs.IncrementalEncoder.getstate", "type": "Binary Data", "text": "\nReturn the current state of the encoder which must be an integer. The\nimplementation should make sure that `0` is the most common state. (States\nthat are more complicated than integers can be converted into an integer by\nmarshaling/pickling the state and encoding the bytes of the resulting string\ninto an integer.)\n\n"}, {"name": "codecs.IncrementalEncoder.reset()", "path": "library/codecs#codecs.IncrementalEncoder.reset", "type": "Binary Data", "text": "\nReset the encoder to the initial state. The output is discarded: call\n`.encode(object, final=True)`, passing an empty byte or text string if\nnecessary, to reset the encoder and to get the output.\n\n"}, {"name": "codecs.IncrementalEncoder.setstate()", "path": "library/codecs#codecs.IncrementalEncoder.setstate", "type": "Binary Data", "text": "\nSet the state of the encoder to state. state must be an encoder state returned\nby `getstate()`.\n\n"}, {"name": "codecs.iterdecode()", "path": "library/codecs#codecs.iterdecode", "type": "Binary Data", "text": "\nUses an incremental decoder to iteratively decode the input provided by\niterator. This function is a generator. The errors argument (as well as any\nother keyword argument) is passed through to the incremental decoder.\n\n"}, {"name": "codecs.iterencode()", "path": "library/codecs#codecs.iterencode", "type": "Binary Data", "text": "\nUses an incremental encoder to iteratively encode the input provided by\niterator. This function is a generator. The errors argument (as well as any\nother keyword argument) is passed through to the incremental encoder.\n\n"}, {"name": "codecs.lookup()", "path": "library/codecs#codecs.lookup", "type": "Binary Data", "text": "\nLooks up the codec info in the Python codec registry and returns a `CodecInfo`\nobject as defined below.\n\n"}, {"name": "codecs.lookup_error()", "path": "library/codecs#codecs.lookup_error", "type": "Binary Data", "text": "\nReturn the error handler previously registered under the name name.\n\n"}, {"name": "codecs.namereplace_errors()", "path": "library/codecs#codecs.namereplace_errors", "type": "Binary Data", "text": "\nImplements the `'namereplace'` error handling (for encoding with text\nencodings only): the unencodable character is replaced by a `\\N{...}` escape\nsequence.\n\n"}, {"name": "codecs.open()", "path": "library/codecs#codecs.open", "type": "Binary Data", "text": "\nOpen an encoded file using the given mode and return an instance of\n`StreamReaderWriter`, providing transparent encoding/decoding. The default\nfile mode is `'r'`, meaning to open the file in read mode.\n\n"}, {"name": "codecs.register()", "path": "library/codecs#codecs.register", "type": "Binary Data", "text": "\nRegister a codec search function. Search functions are expected to take one\nargument, being the encoding name in all lower case letters with hyphens and\nspaces converted to underscores, and return a `CodecInfo` object. In case a\nsearch function cannot find a given encoding, it should return `None`.\n\n"}, {"name": "codecs.register_error()", "path": "library/codecs#codecs.register_error", "type": "Binary Data", "text": "\nRegister the error handling function error_handler under the name name. The\nerror_handler argument will be called during encoding and decoding in case of\nan error, when name is specified as the errors parameter.\n\n"}, {"name": "codecs.replace_errors()", "path": "library/codecs#codecs.replace_errors", "type": "Binary Data", "text": "\nImplements the `'replace'` error handling (for text encodings only):\nsubstitutes `'?'` for encoding errors (to be encoded by the codec), and\n`'\\ufffd'` (the Unicode replacement character) for decoding errors.\n\n"}, {"name": "codecs.StreamReader", "path": "library/codecs#codecs.StreamReader", "type": "Binary Data", "text": "\nConstructor for a `StreamReader` instance.\n\n"}, {"name": "codecs.StreamReader.read()", "path": "library/codecs#codecs.StreamReader.read", "type": "Binary Data", "text": "\nDecodes data from the stream and returns the resulting object.\n\n"}, {"name": "codecs.StreamReader.readline()", "path": "library/codecs#codecs.StreamReader.readline", "type": "Binary Data", "text": "\nRead one line from the input stream and return the decoded data.\n\n"}, {"name": "codecs.StreamReader.readlines()", "path": "library/codecs#codecs.StreamReader.readlines", "type": "Binary Data", "text": "\nRead all lines available on the input stream and return them as a list of\nlines.\n\n"}, {"name": "codecs.StreamReader.reset()", "path": "library/codecs#codecs.StreamReader.reset", "type": "Binary Data", "text": "\nResets the codec buffers used for keeping internal state.\n\n"}, {"name": "codecs.StreamReaderWriter", "path": "library/codecs#codecs.StreamReaderWriter", "type": "Binary Data", "text": "\nCreates a `StreamReaderWriter` instance. stream must be a file-like object.\nReader and Writer must be factory functions or classes providing the\n`StreamReader` and `StreamWriter` interface resp. Error handling is done in\nthe same way as defined for the stream readers and writers.\n\n"}, {"name": "codecs.StreamRecoder", "path": "library/codecs#codecs.StreamRecoder", "type": "Binary Data", "text": "\nCreates a `StreamRecoder` instance which implements a two-way conversion:\nencode and decode work on the frontend \u2014 the data visible to code calling\n`read()` and `write()`, while Reader and Writer work on the backend \u2014 the data\nin stream.\n\n"}, {"name": "codecs.StreamWriter", "path": "library/codecs#codecs.StreamWriter", "type": "Binary Data", "text": "\nConstructor for a `StreamWriter` instance.\n\n"}, {"name": "codecs.StreamWriter.reset()", "path": "library/codecs#codecs.StreamWriter.reset", "type": "Binary Data", "text": "\nResets the codec buffers used for keeping internal state.\n\n"}, {"name": "codecs.StreamWriter.write()", "path": "library/codecs#codecs.StreamWriter.write", "type": "Binary Data", "text": "\nWrites the object\u2019s contents encoded to the stream.\n\n"}, {"name": "codecs.StreamWriter.writelines()", "path": "library/codecs#codecs.StreamWriter.writelines", "type": "Binary Data", "text": "\nWrites the concatenated list of strings to the stream (possibly by reusing the\n`write()` method). The standard bytes-to-bytes codecs do not support this\nmethod.\n\n"}, {"name": "codecs.strict_errors()", "path": "library/codecs#codecs.strict_errors", "type": "Binary Data", "text": "\nImplements the `'strict'` error handling: each encoding or decoding error\nraises a `UnicodeError`.\n\n"}, {"name": "codecs.xmlcharrefreplace_errors()", "path": "library/codecs#codecs.xmlcharrefreplace_errors", "type": "Binary Data", "text": "\nImplements the `'xmlcharrefreplace'` error handling (for encoding with text\nencodings only): the unencodable character is replaced by an appropriate XML\ncharacter reference.\n\n"}, {"name": "codeop", "path": "library/codeop", "type": "Interpreters", "text": "\nSource code: Lib/codeop.py\n\n"}, {"name": "codeop.CommandCompiler", "path": "library/codeop#codeop.CommandCompiler", "type": "Interpreters", "text": "\nInstances of this class have `__call__()` methods identical in signature to\n`compile_command()`; the difference is that if the instance compiles program\ntext containing a `__future__` statement, the instance \u2018remembers\u2019 and\ncompiles all subsequent program texts with the statement in force.\n\n"}, {"name": "codeop.Compile", "path": "library/codeop#codeop.Compile", "type": "Interpreters", "text": "\nInstances of this class have `__call__()` methods identical in signature to\nthe built-in function `compile()`, but with the difference that if the\ninstance compiles program text containing a `__future__` statement, the\ninstance \u2018remembers\u2019 and compiles all subsequent program texts with the\nstatement in force.\n\n"}, {"name": "codeop.compile_command()", "path": "library/codeop#codeop.compile_command", "type": "Interpreters", "text": "\nTries to compile source, which should be a string of Python code and return a\ncode object if source is valid Python code. In that case, the filename\nattribute of the code object will be filename, which defaults to `'<input>'`.\nReturns `None` if source is not valid Python code, but is a prefix of valid\nPython code.\n\n"}, {"name": "collections", "path": "library/collections", "type": "Data Types", "text": "\nSource code: Lib/collections/__init__.py\n\n"}, {"name": "collections.abc", "path": "library/collections.abc", "type": "Data Types", "text": "\nNew in version 3.3: Formerly, this module was part of the `collections`\nmodule.\n\n"}, {"name": "collections.abc.AsyncGenerator", "path": "library/collections.abc#collections.abc.AsyncGenerator", "type": "Data Types", "text": "\nABC for asynchronous generator classes that implement the protocol defined in\nPEP 525 and PEP 492.\n\n"}, {"name": "collections.abc.AsyncIterable", "path": "library/collections.abc#collections.abc.AsyncIterable", "type": "Data Types", "text": "\nABC for classes that provide `__aiter__` method. See also the definition of\nasynchronous iterable.\n\n"}, {"name": "collections.abc.AsyncIterator", "path": "library/collections.abc#collections.abc.AsyncIterator", "type": "Data Types", "text": "\nABC for classes that provide `__aiter__` and `__anext__` methods. See also the\ndefinition of asynchronous iterator.\n\n"}, {"name": "collections.abc.Awaitable", "path": "library/collections.abc#collections.abc.Awaitable", "type": "Data Types", "text": "\nABC for awaitable objects, which can be used in `await` expressions. Custom\nimplementations must provide the `__await__()` method.\n\n"}, {"name": "collections.abc.ByteString", "path": "library/collections.abc#collections.abc.ByteString", "type": "Data Types", "text": "\nABCs for read-only and mutable sequences.\n\n"}, {"name": "collections.abc.Callable", "path": "library/collections.abc#collections.abc.Callable", "type": "Data Types", "text": "\nABC for classes that provide the `__call__()` method.\n\n"}, {"name": "collections.abc.Collection", "path": "library/collections.abc#collections.abc.Collection", "type": "Data Types", "text": "\nABC for sized iterable container classes.\n\n"}, {"name": "collections.abc.Container", "path": "library/collections.abc#collections.abc.Container", "type": "Data Types", "text": "\nABC for classes that provide the `__contains__()` method.\n\n"}, {"name": "collections.abc.Coroutine", "path": "library/collections.abc#collections.abc.Coroutine", "type": "Data Types", "text": "\nABC for coroutine compatible classes. These implement the following methods,\ndefined in Coroutine Objects: `send()`, `throw()`, and `close()`. Custom\nimplementations must also implement `__await__()`. All `Coroutine` instances\nare also instances of `Awaitable`. See also the definition of coroutine.\n\n"}, {"name": "collections.abc.Generator", "path": "library/collections.abc#collections.abc.Generator", "type": "Data Types", "text": "\nABC for generator classes that implement the protocol defined in PEP 342 that\nextends iterators with the `send()`, `throw()` and `close()` methods. See also\nthe definition of generator.\n\n"}, {"name": "collections.abc.Hashable", "path": "library/collections.abc#collections.abc.Hashable", "type": "Data Types", "text": "\nABC for classes that provide the `__hash__()` method.\n\n"}, {"name": "collections.abc.ItemsView", "path": "library/collections.abc#collections.abc.ItemsView", "type": "Data Types", "text": "\nABCs for mapping, items, keys, and values views.\n\n"}, {"name": "collections.abc.Iterable", "path": "library/collections.abc#collections.abc.Iterable", "type": "Data Types", "text": "\nABC for classes that provide the `__iter__()` method.\n\n"}, {"name": "collections.abc.Iterator", "path": "library/collections.abc#collections.abc.Iterator", "type": "Data Types", "text": "\nABC for classes that provide the `__iter__()` and `__next__()` methods. See\nalso the definition of iterator.\n\n"}, {"name": "collections.abc.KeysView", "path": "library/collections.abc#collections.abc.KeysView", "type": "Data Types", "text": "\nABCs for mapping, items, keys, and values views.\n\n"}, {"name": "collections.abc.Mapping", "path": "library/collections.abc#collections.abc.Mapping", "type": "Data Types", "text": "\nABCs for read-only and mutable mappings.\n\n"}, {"name": "collections.abc.MappingView", "path": "library/collections.abc#collections.abc.MappingView", "type": "Data Types", "text": "\nABCs for mapping, items, keys, and values views.\n\n"}, {"name": "collections.abc.MutableMapping", "path": "library/collections.abc#collections.abc.MutableMapping", "type": "Data Types", "text": "\nABCs for read-only and mutable mappings.\n\n"}, {"name": "collections.abc.MutableSequence", "path": "library/collections.abc#collections.abc.MutableSequence", "type": "Data Types", "text": "\nABCs for read-only and mutable sequences.\n\n"}, {"name": "collections.abc.MutableSet", "path": "library/collections.abc#collections.abc.MutableSet", "type": "Data Types", "text": "\nABCs for read-only and mutable sets.\n\n"}, {"name": "collections.abc.Reversible", "path": "library/collections.abc#collections.abc.Reversible", "type": "Data Types", "text": "\nABC for iterable classes that also provide the `__reversed__()` method.\n\n"}, {"name": "collections.abc.Sequence", "path": "library/collections.abc#collections.abc.Sequence", "type": "Data Types", "text": "\nABCs for read-only and mutable sequences.\n\n"}, {"name": "collections.abc.Set", "path": "library/collections.abc#collections.abc.Set", "type": "Data Types", "text": "\nABCs for read-only and mutable sets.\n\n"}, {"name": "collections.abc.Sized", "path": "library/collections.abc#collections.abc.Sized", "type": "Data Types", "text": "\nABC for classes that provide the `__len__()` method.\n\n"}, {"name": "collections.abc.ValuesView", "path": "library/collections.abc#collections.abc.ValuesView", "type": "Data Types", "text": "\nABCs for mapping, items, keys, and values views.\n\n"}, {"name": "collections.ChainMap", "path": "library/collections#collections.ChainMap", "type": "Data Types", "text": "\nA `ChainMap` groups multiple dicts or other mappings together to create a\nsingle, updateable view. If no maps are specified, a single empty dictionary\nis provided so that a new chain always has at least one mapping.\n\n"}, {"name": "collections.ChainMap.maps", "path": "library/collections#collections.ChainMap.maps", "type": "Data Types", "text": "\nA user updateable list of mappings. The list is ordered from first-searched to\nlast-searched. It is the only stored state and can be modified to change which\nmappings are searched. The list should always contain at least one mapping.\n\n"}, {"name": "collections.ChainMap.new_child()", "path": "library/collections#collections.ChainMap.new_child", "type": "Data Types", "text": "\nReturns a new `ChainMap` containing a new map followed by all of the maps in\nthe current instance. If `m` is specified, it becomes the new map at the front\nof the list of mappings; if not specified, an empty dict is used, so that a\ncall to `d.new_child()` is equivalent to: `ChainMap({}, *d.maps)`. This method\nis used for creating subcontexts that can be updated without altering values\nin any of the parent mappings.\n\n"}, {"name": "collections.ChainMap.parents", "path": "library/collections#collections.ChainMap.parents", "type": "Data Types", "text": "\nProperty returning a new `ChainMap` containing all of the maps in the current\ninstance except the first one. This is useful for skipping the first map in\nthe search. Use cases are similar to those for the `nonlocal` keyword used in\nnested scopes. The use cases also parallel those for the built-in `super()`\nfunction. A reference to `d.parents` is equivalent to:\n`ChainMap(*d.maps[1:])`.\n\n"}, {"name": "collections.Counter", "path": "library/collections#collections.Counter", "type": "Data Types", "text": "\nA `Counter` is a `dict` subclass for counting hashable objects. It is a\ncollection where elements are stored as dictionary keys and their counts are\nstored as dictionary values. Counts are allowed to be any integer value\nincluding zero or negative counts. The `Counter` class is similar to bags or\nmultisets in other languages.\n\n"}, {"name": "collections.Counter.elements()", "path": "library/collections#collections.Counter.elements", "type": "Data Types", "text": "\nReturn an iterator over elements repeating each as many times as its count.\nElements are returned in the order first encountered. If an element\u2019s count is\nless than one, `elements()` will ignore it.\n\n"}, {"name": "collections.Counter.fromkeys()", "path": "library/collections#collections.Counter.fromkeys", "type": "Data Types", "text": "\nThis class method is not implemented for `Counter` objects.\n\n"}, {"name": "collections.Counter.most_common()", "path": "library/collections#collections.Counter.most_common", "type": "Data Types", "text": "\nReturn a list of the n most common elements and their counts from the most\ncommon to the least. If n is omitted or `None`, `most_common()` returns all\nelements in the counter. Elements with equal counts are ordered in the order\nfirst encountered:\n\n"}, {"name": "collections.Counter.subtract()", "path": "library/collections#collections.Counter.subtract", "type": "Data Types", "text": "\nElements are subtracted from an iterable or from another mapping (or counter).\nLike `dict.update()` but subtracts counts instead of replacing them. Both\ninputs and outputs may be zero or negative.\n\n"}, {"name": "collections.Counter.update()", "path": "library/collections#collections.Counter.update", "type": "Data Types", "text": "\nElements are counted from an iterable or added-in from another mapping (or\ncounter). Like `dict.update()` but adds counts instead of replacing them.\nAlso, the iterable is expected to be a sequence of elements, not a sequence of\n`(key, value)` pairs.\n\n"}, {"name": "collections.defaultdict", "path": "library/collections#collections.defaultdict", "type": "Data Types", "text": "\nReturns a new dictionary-like object. `defaultdict` is a subclass of the\nbuilt-in `dict` class. It overrides one method and adds one writable instance\nvariable. The remaining functionality is the same as for the `dict` class and\nis not documented here.\n\n"}, {"name": "collections.defaultdict.default_factory", "path": "library/collections#collections.defaultdict.default_factory", "type": "Data Types", "text": "\nThis attribute is used by the `__missing__()` method; it is initialized from\nthe first argument to the constructor, if present, or to `None`, if absent.\n\n"}, {"name": "collections.defaultdict.__missing__()", "path": "library/collections#collections.defaultdict.__missing__", "type": "Data Types", "text": "\nIf the `default_factory` attribute is `None`, this raises a `KeyError`\nexception with the key as argument.\n\n"}, {"name": "collections.deque", "path": "library/collections#collections.deque", "type": "Data Types", "text": "\nReturns a new deque object initialized left-to-right (using `append()`) with\ndata from iterable. If iterable is not specified, the new deque is empty.\n\n"}, {"name": "collections.deque.append()", "path": "library/collections#collections.deque.append", "type": "Data Types", "text": "\nAdd x to the right side of the deque.\n\n"}, {"name": "collections.deque.appendleft()", "path": "library/collections#collections.deque.appendleft", "type": "Data Types", "text": "\nAdd x to the left side of the deque.\n\n"}, {"name": "collections.deque.clear()", "path": "library/collections#collections.deque.clear", "type": "Data Types", "text": "\nRemove all elements from the deque leaving it with length 0.\n\n"}, {"name": "collections.deque.copy()", "path": "library/collections#collections.deque.copy", "type": "Data Types", "text": "\nCreate a shallow copy of the deque.\n\n"}, {"name": "collections.deque.count()", "path": "library/collections#collections.deque.count", "type": "Data Types", "text": "\nCount the number of deque elements equal to x.\n\n"}, {"name": "collections.deque.extend()", "path": "library/collections#collections.deque.extend", "type": "Data Types", "text": "\nExtend the right side of the deque by appending elements from the iterable\nargument.\n\n"}, {"name": "collections.deque.extendleft()", "path": "library/collections#collections.deque.extendleft", "type": "Data Types", "text": "\nExtend the left side of the deque by appending elements from iterable. Note,\nthe series of left appends results in reversing the order of elements in the\niterable argument.\n\n"}, {"name": "collections.deque.index()", "path": "library/collections#collections.deque.index", "type": "Data Types", "text": "\nReturn the position of x in the deque (at or after index start and before\nindex stop). Returns the first match or raises `ValueError` if not found.\n\n"}, {"name": "collections.deque.insert()", "path": "library/collections#collections.deque.insert", "type": "Data Types", "text": "\nInsert x into the deque at position i.\n\n"}, {"name": "collections.deque.maxlen", "path": "library/collections#collections.deque.maxlen", "type": "Data Types", "text": "\nMaximum size of a deque or `None` if unbounded.\n\n"}, {"name": "collections.deque.pop()", "path": "library/collections#collections.deque.pop", "type": "Data Types", "text": "\nRemove and return an element from the right side of the deque. If no elements\nare present, raises an `IndexError`.\n\n"}, {"name": "collections.deque.popleft()", "path": "library/collections#collections.deque.popleft", "type": "Data Types", "text": "\nRemove and return an element from the left side of the deque. If no elements\nare present, raises an `IndexError`.\n\n"}, {"name": "collections.deque.remove()", "path": "library/collections#collections.deque.remove", "type": "Data Types", "text": "\nRemove the first occurrence of value. If not found, raises a `ValueError`.\n\n"}, {"name": "collections.deque.reverse()", "path": "library/collections#collections.deque.reverse", "type": "Data Types", "text": "\nReverse the elements of the deque in-place and then return `None`.\n\n"}, {"name": "collections.deque.rotate()", "path": "library/collections#collections.deque.rotate", "type": "Data Types", "text": "\nRotate the deque n steps to the right. If n is negative, rotate to the left.\n\n"}, {"name": "collections.namedtuple()", "path": "library/collections#collections.namedtuple", "type": "Data Types", "text": "\nReturns a new tuple subclass named typename. The new subclass is used to\ncreate tuple-like objects that have fields accessible by attribute lookup as\nwell as being indexable and iterable. Instances of the subclass also have a\nhelpful docstring (with typename and field_names) and a helpful `__repr__()`\nmethod which lists the tuple contents in a `name=value` format.\n\n"}, {"name": "collections.OrderedDict", "path": "library/collections#collections.OrderedDict", "type": "Data Types", "text": "\nReturn an instance of a `dict` subclass that has methods specialized for\nrearranging dictionary order.\n\n"}, {"name": "collections.OrderedDict.move_to_end()", "path": "library/collections#collections.OrderedDict.move_to_end", "type": "Data Types", "text": "\nMove an existing key to either end of an ordered dictionary. The item is moved\nto the right end if last is true (the default) or to the beginning if last is\nfalse. Raises `KeyError` if the key does not exist:\n\n"}, {"name": "collections.OrderedDict.popitem()", "path": "library/collections#collections.OrderedDict.popitem", "type": "Data Types", "text": "\nThe `popitem()` method for ordered dictionaries returns and removes a (key,\nvalue) pair. The pairs are returned in LIFO order if last is true or FIFO\norder if false.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "collections.somenamedtuple._asdict()", "path": "library/collections#collections.somenamedtuple._asdict", "type": "Data Types", "text": "\nReturn a new `dict` which maps field names to their corresponding values:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "collections.somenamedtuple._fields", "path": "library/collections#collections.somenamedtuple._fields", "type": "Data Types", "text": "\nTuple of strings listing the field names. Useful for introspection and for\ncreating new named tuple types from existing named tuples.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "collections.somenamedtuple._field_defaults", "path": "library/collections#collections.somenamedtuple._field_defaults", "type": "Data Types", "text": "\nDictionary mapping field names to default values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "collections.somenamedtuple._make()", "path": "library/collections#collections.somenamedtuple._make", "type": "Data Types", "text": "\nClass method that makes a new instance from an existing sequence or iterable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "collections.somenamedtuple._replace()", "path": "library/collections#collections.somenamedtuple._replace", "type": "Data Types", "text": "\nReturn a new instance of the named tuple replacing specified fields with new\nvalues:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "collections.UserDict", "path": "library/collections#collections.UserDict", "type": "Data Types", "text": "\nClass that simulates a dictionary. The instance\u2019s contents are kept in a\nregular dictionary, which is accessible via the `data` attribute of `UserDict`\ninstances. If initialdata is provided, `data` is initialized with its\ncontents; note that a reference to initialdata will not be kept, allowing it\nbe used for other purposes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "collections.UserDict.data", "path": "library/collections#collections.UserDict.data", "type": "Data Types", "text": "\nA real dictionary used to store the contents of the `UserDict` class.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "collections.UserList", "path": "library/collections#collections.UserList", "type": "Data Types", "text": "\nClass that simulates a list. The instance\u2019s contents are kept in a regular\nlist, which is accessible via the `data` attribute of `UserList` instances.\nThe instance\u2019s contents are initially set to a copy of list, defaulting to the\nempty list `[]`. list can be any iterable, for example a real Python list or a\n`UserList` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "collections.UserList.data", "path": "library/collections#collections.UserList.data", "type": "Data Types", "text": "\nA real `list` object used to store the contents of the `UserList` class.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "collections.UserString", "path": "library/collections#collections.UserString", "type": "Data Types", "text": "\nClass that simulates a string object. The instance\u2019s content is kept in a\nregular string object, which is accessible via the `data` attribute of\n`UserString` instances. The instance\u2019s contents are initially set to a copy of\nseq. The seq argument can be any object which can be converted into a string\nusing the built-in `str()` function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "collections.UserString.data", "path": "library/collections#collections.UserString.data", "type": "Data Types", "text": "\nA real `str` object used to store the contents of the `UserString` class.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "colorsys", "path": "library/colorsys", "type": "Multimedia", "text": "\nSource code: Lib/colorsys.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "colorsys.hls_to_rgb()", "path": "library/colorsys#colorsys.hls_to_rgb", "type": "Multimedia", "text": "\nConvert the color from HLS coordinates to RGB coordinates.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "colorsys.hsv_to_rgb()", "path": "library/colorsys#colorsys.hsv_to_rgb", "type": "Multimedia", "text": "\nConvert the color from HSV coordinates to RGB coordinates.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "colorsys.rgb_to_hls()", "path": "library/colorsys#colorsys.rgb_to_hls", "type": "Multimedia", "text": "\nConvert the color from RGB coordinates to HLS coordinates.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "colorsys.rgb_to_hsv()", "path": "library/colorsys#colorsys.rgb_to_hsv", "type": "Multimedia", "text": "\nConvert the color from RGB coordinates to HSV coordinates.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "colorsys.rgb_to_yiq()", "path": "library/colorsys#colorsys.rgb_to_yiq", "type": "Multimedia", "text": "\nConvert the color from RGB coordinates to YIQ coordinates.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "colorsys.yiq_to_rgb()", "path": "library/colorsys#colorsys.yiq_to_rgb", "type": "Multimedia", "text": "\nConvert the color from YIQ coordinates to RGB coordinates.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "compile()", "path": "library/functions#compile", "type": "Built-in Functions", "text": "\nCompile the source into a code or AST object. Code objects can be executed by\n`exec()` or `eval()`. source can either be a normal string, a byte string, or\nan AST object. Refer to the `ast` module documentation for information on how\nto work with AST objects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "compileall", "path": "library/compileall", "type": "Language", "text": "\nSource code: Lib/compileall.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "compileall.compile_dir()", "path": "library/compileall#compileall.compile_dir", "type": "Language", "text": "\nRecursively descend the directory tree named by dir, compiling all `.py` files\nalong the way. Return a true value if all the files compiled successfully, and\na false value otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "compileall.compile_file()", "path": "library/compileall#compileall.compile_file", "type": "Language", "text": "\nCompile the file with path fullname. Return a true value if the file compiled\nsuccessfully, and a false value otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "compileall.compile_path()", "path": "library/compileall#compileall.compile_path", "type": "Language", "text": "\nByte-compile all the `.py` files found along `sys.path`. Return a true value\nif all the files compiled successfully, and a false value otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "complex", "path": "library/functions#complex", "type": "Built-in Functions", "text": "\nReturn a complex number with the value real \\+ imag*1j or convert a string or\nnumber to a complex number. If the first parameter is a string, it will be\ninterpreted as a complex number and the function must be called without a\nsecond parameter. The second parameter can never be a string. Each argument\nmay be any numeric type (including complex). If imag is omitted, it defaults\nto zero and the constructor serves as a numeric conversion like `int` and\n`float`. If both arguments are omitted, returns `0j`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures", "path": "library/concurrent.futures", "type": "Concurrent Execution", "text": "\nNew in version 3.2.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.as_completed()", "path": "library/concurrent.futures#concurrent.futures.as_completed", "type": "Concurrent Execution", "text": "\nReturns an iterator over the `Future` instances (possibly created by different\n`Executor` instances) given by fs that yields futures as they complete\n(finished or cancelled futures). Any futures given by fs that are duplicated\nwill be returned once. Any futures that completed before `as_completed()` is\ncalled will be yielded first. The returned iterator raises a\n`concurrent.futures.TimeoutError` if `__next__()` is called and the result\nisn\u2019t available after timeout seconds from the original call to\n`as_completed()`. timeout can be an int or float. If timeout is not specified\nor `None`, there is no limit to the wait time.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.BrokenExecutor", "path": "library/concurrent.futures#concurrent.futures.BrokenExecutor", "type": "Concurrent Execution", "text": "\nDerived from `RuntimeError`, this exception class is raised when an executor\nis broken for some reason, and cannot be used to submit or execute new tasks.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.CancelledError", "path": "library/concurrent.futures#concurrent.futures.CancelledError", "type": "Concurrent Execution", "text": "\nRaised when a future is cancelled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.Executor", "path": "library/concurrent.futures#concurrent.futures.Executor", "type": "Concurrent Execution", "text": "\nAn abstract class that provides methods to execute calls asynchronously. It\nshould not be used directly, but through its concrete subclasses.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.Executor.map()", "path": "library/concurrent.futures#concurrent.futures.Executor.map", "type": "Concurrent Execution", "text": "\nSimilar to `map(func, *iterables)` except:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.Executor.shutdown()", "path": "library/concurrent.futures#concurrent.futures.Executor.shutdown", "type": "Concurrent Execution", "text": "\nSignal the executor that it should free any resources that it is using when\nthe currently pending futures are done executing. Calls to `Executor.submit()`\nand `Executor.map()` made after shutdown will raise `RuntimeError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.Executor.submit()", "path": "library/concurrent.futures#concurrent.futures.Executor.submit", "type": "Concurrent Execution", "text": "\nSchedules the callable, fn, to be executed as `fn(*args **kwargs)` and returns\na `Future` object representing the execution of the callable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.Future", "path": "library/concurrent.futures#concurrent.futures.Future", "type": "Concurrent Execution", "text": "\nEncapsulates the asynchronous execution of a callable. `Future` instances are\ncreated by `Executor.submit()` and should not be created directly except for\ntesting.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.Future.add_done_callback()", "path": "library/concurrent.futures#concurrent.futures.Future.add_done_callback", "type": "Concurrent Execution", "text": "\nAttaches the callable fn to the future. fn will be called, with the future as\nits only argument, when the future is cancelled or finishes running.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.Future.cancel()", "path": "library/concurrent.futures#concurrent.futures.Future.cancel", "type": "Concurrent Execution", "text": "\nAttempt to cancel the call. If the call is currently being executed or\nfinished running and cannot be cancelled then the method will return `False`,\notherwise the call will be cancelled and the method will return `True`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.Future.cancelled()", "path": "library/concurrent.futures#concurrent.futures.Future.cancelled", "type": "Concurrent Execution", "text": "\nReturn `True` if the call was successfully cancelled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.Future.done()", "path": "library/concurrent.futures#concurrent.futures.Future.done", "type": "Concurrent Execution", "text": "\nReturn `True` if the call was successfully cancelled or finished running.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.Future.exception()", "path": "library/concurrent.futures#concurrent.futures.Future.exception", "type": "Concurrent Execution", "text": "\nReturn the exception raised by the call. If the call hasn\u2019t yet completed then\nthis method will wait up to timeout seconds. If the call hasn\u2019t completed in\ntimeout seconds, then a `concurrent.futures.TimeoutError` will be raised.\ntimeout can be an int or float. If timeout is not specified or `None`, there\nis no limit to the wait time.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.Future.result()", "path": "library/concurrent.futures#concurrent.futures.Future.result", "type": "Concurrent Execution", "text": "\nReturn the value returned by the call. If the call hasn\u2019t yet completed then\nthis method will wait up to timeout seconds. If the call hasn\u2019t completed in\ntimeout seconds, then a `concurrent.futures.TimeoutError` will be raised.\ntimeout can be an int or float. If timeout is not specified or `None`, there\nis no limit to the wait time.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.Future.running()", "path": "library/concurrent.futures#concurrent.futures.Future.running", "type": "Concurrent Execution", "text": "\nReturn `True` if the call is currently being executed and cannot be cancelled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.Future.set_exception()", "path": "library/concurrent.futures#concurrent.futures.Future.set_exception", "type": "Concurrent Execution", "text": "\nSets the result of the work associated with the `Future` to the `Exception`\nexception.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.Future.set_result()", "path": "library/concurrent.futures#concurrent.futures.Future.set_result", "type": "Concurrent Execution", "text": "\nSets the result of the work associated with the `Future` to result.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.Future.set_running_or_notify_cancel()", "path": "library/concurrent.futures#concurrent.futures.Future.set_running_or_notify_cancel", "type": "Concurrent Execution", "text": "\nThis method should only be called by `Executor` implementations before\nexecuting the work associated with the `Future` and by unit tests.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.InvalidStateError", "path": "library/concurrent.futures#concurrent.futures.InvalidStateError", "type": "Concurrent Execution", "text": "\nRaised when an operation is performed on a future that is not allowed in the\ncurrent state.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.process.BrokenProcessPool", "path": "library/concurrent.futures#concurrent.futures.process.BrokenProcessPool", "type": "Concurrent Execution", "text": "\nDerived from `BrokenExecutor` (formerly `RuntimeError`), this exception class\nis raised when one of the workers of a `ProcessPoolExecutor` has terminated in\na non-clean fashion (for example, if it was killed from the outside).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.ProcessPoolExecutor", "path": "library/concurrent.futures#concurrent.futures.ProcessPoolExecutor", "type": "Concurrent Execution", "text": "\nAn `Executor` subclass that executes calls asynchronously using a pool of at\nmost max_workers processes. If max_workers is `None` or not given, it will\ndefault to the number of processors on the machine. If max_workers is less\nthan or equal to `0`, then a `ValueError` will be raised. On Windows,\nmax_workers must be less than or equal to `61`. If it is not then `ValueError`\nwill be raised. If max_workers is `None`, then the default chosen will be at\nmost `61`, even if more processors are available. mp_context can be a\nmultiprocessing context or None. It will be used to launch the workers. If\nmp_context is `None` or not given, the default multiprocessing context is\nused.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.thread.BrokenThreadPool", "path": "library/concurrent.futures#concurrent.futures.thread.BrokenThreadPool", "type": "Concurrent Execution", "text": "\nDerived from `BrokenExecutor`, this exception class is raised when one of the\nworkers of a `ThreadPoolExecutor` has failed initializing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.ThreadPoolExecutor", "path": "library/concurrent.futures#concurrent.futures.ThreadPoolExecutor", "type": "Concurrent Execution", "text": "\nAn `Executor` subclass that uses a pool of at most max_workers threads to\nexecute calls asynchronously.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.TimeoutError", "path": "library/concurrent.futures#concurrent.futures.TimeoutError", "type": "Concurrent Execution", "text": "\nRaised when a future operation exceeds the given timeout.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "concurrent.futures.wait()", "path": "library/concurrent.futures#concurrent.futures.wait", "type": "Concurrent Execution", "text": "\nWait for the `Future` instances (possibly created by different `Executor`\ninstances) given by fs to complete. Returns a named 2-tuple of sets. The first\nset, named `done`, contains the futures that completed (finished or cancelled\nfutures) before the wait completed. The second set, named `not_done`, contains\nthe futures that did not complete (pending or running futures).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser", "path": "library/configparser", "type": "File Formats", "text": "\nSource code: Lib/configparser.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.BasicInterpolation", "path": "library/configparser#configparser.BasicInterpolation", "type": "File Formats", "text": "\nThe default implementation used by `ConfigParser`. It enables values to\ncontain format strings which refer to other values in the same section, or\nvalues in the special default section 1. Additional default values can be\nprovided on initialization.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser", "path": "library/configparser#configparser.ConfigParser", "type": "File Formats", "text": "\nThe main configuration parser. When defaults is given, it is initialized into\nthe dictionary of intrinsic defaults. When dict_type is given, it will be used\nto create the dictionary objects for the list of sections, for the options\nwithin a section, and for the default values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.add_section()", "path": "library/configparser#configparser.ConfigParser.add_section", "type": "File Formats", "text": "\nAdd a section named section to the instance. If a section by the given name\nalready exists, `DuplicateSectionError` is raised. If the default section name\nis passed, `ValueError` is raised. The name of the section must be a string;\nif not, `TypeError` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.BOOLEAN_STATES", "path": "library/configparser#configparser.ConfigParser.BOOLEAN_STATES", "type": "File Formats", "text": "\nBy default when using `getboolean()`, config parsers consider the following\nvalues `True`: `'1'`, `'yes'`, `'true'`, `'on'` and the following values\n`False`: `'0'`, `'no'`, `'false'`, `'off'`. You can override this by\nspecifying a custom dictionary of strings and their Boolean outcomes. For\nexample:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.defaults()", "path": "library/configparser#configparser.ConfigParser.defaults", "type": "File Formats", "text": "\nReturn a dictionary containing the instance-wide defaults.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.get()", "path": "library/configparser#configparser.ConfigParser.get", "type": "File Formats", "text": "\nGet an option value for the named section. If vars is provided, it must be a\ndictionary. The option is looked up in vars (if provided), section, and in\nDEFAULTSECT in that order. If the key is not found and fallback is provided,\nit is used as a fallback value. `None` can be provided as a fallback value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.getboolean()", "path": "library/configparser#configparser.ConfigParser.getboolean", "type": "File Formats", "text": "\nA convenience method which coerces the option in the specified section to a\nBoolean value. Note that the accepted values for the option are `'1'`,\n`'yes'`, `'true'`, and `'on'`, which cause this method to return `True`, and\n`'0'`, `'no'`, `'false'`, and `'off'`, which cause it to return `False`. These\nstring values are checked in a case-insensitive manner. Any other value will\ncause it to raise `ValueError`. See `get()` for explanation of raw, vars and\nfallback.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.getfloat()", "path": "library/configparser#configparser.ConfigParser.getfloat", "type": "File Formats", "text": "\nA convenience method which coerces the option in the specified section to a\nfloating point number. See `get()` for explanation of raw, vars and fallback.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.getint()", "path": "library/configparser#configparser.ConfigParser.getint", "type": "File Formats", "text": "\nA convenience method which coerces the option in the specified section to an\ninteger. See `get()` for explanation of raw, vars and fallback.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.has_option()", "path": "library/configparser#configparser.ConfigParser.has_option", "type": "File Formats", "text": "\nIf the given section exists, and contains the given option, return `True`;\notherwise return `False`. If the specified section is `None` or an empty\nstring, DEFAULT is assumed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.has_section()", "path": "library/configparser#configparser.ConfigParser.has_section", "type": "File Formats", "text": "\nIndicates whether the named section is present in the configuration. The\ndefault section is not acknowledged.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.items()", "path": "library/configparser#configparser.ConfigParser.items", "type": "File Formats", "text": "\nWhen section is not given, return a list of section_name, section_proxy pairs,\nincluding DEFAULTSECT.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.options()", "path": "library/configparser#configparser.ConfigParser.options", "type": "File Formats", "text": "\nReturn a list of options available in the specified section.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.optionxform()", "path": "library/configparser#configparser.ConfigParser.optionxform", "type": "File Formats", "text": "\nTransforms the option name option as found in an input file or as passed in by\nclient code to the form that should be used in the internal structures. The\ndefault implementation returns a lower-case version of option; subclasses may\noverride this or client code can set an attribute of this name on instances to\naffect this behavior.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.read()", "path": "library/configparser#configparser.ConfigParser.read", "type": "File Formats", "text": "\nAttempt to read and parse an iterable of filenames, returning a list of\nfilenames which were successfully parsed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.readfp()", "path": "library/configparser#configparser.ConfigParser.readfp", "type": "File Formats", "text": "\nDeprecated since version 3.2: Use `read_file()` instead.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.read_dict()", "path": "library/configparser#configparser.ConfigParser.read_dict", "type": "File Formats", "text": "\nLoad configuration from any object that provides a dict-like `items()` method.\nKeys are section names, values are dictionaries with keys and values that\nshould be present in the section. If the used dictionary type preserves order,\nsections and their keys will be added in order. Values are automatically\nconverted to strings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.read_file()", "path": "library/configparser#configparser.ConfigParser.read_file", "type": "File Formats", "text": "\nRead and parse configuration data from f which must be an iterable yielding\nUnicode strings (for example files opened in text mode).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.read_string()", "path": "library/configparser#configparser.ConfigParser.read_string", "type": "File Formats", "text": "\nParse configuration data from a string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.remove_option()", "path": "library/configparser#configparser.ConfigParser.remove_option", "type": "File Formats", "text": "\nRemove the specified option from the specified section. If the section does\nnot exist, raise `NoSectionError`. If the option existed to be removed, return\n`True`; otherwise return `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.remove_section()", "path": "library/configparser#configparser.ConfigParser.remove_section", "type": "File Formats", "text": "\nRemove the specified section from the configuration. If the section in fact\nexisted, return `True`. Otherwise return `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.SECTCRE", "path": "library/configparser#configparser.ConfigParser.SECTCRE", "type": "File Formats", "text": "\nA compiled regular expression used to parse section headers. The default\nmatches `[section]` to the name `\"section\"`. Whitespace is considered part of\nthe section name, thus `[ larch ]` will be read as a section of name `\" larch\n\"`. Override this attribute if that\u2019s unsuitable. For example:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.sections()", "path": "library/configparser#configparser.ConfigParser.sections", "type": "File Formats", "text": "\nReturn a list of the sections available; the default section is not included\nin the list.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.set()", "path": "library/configparser#configparser.ConfigParser.set", "type": "File Formats", "text": "\nIf the given section exists, set the given option to the specified value;\notherwise raise `NoSectionError`. option and value must be strings; if not,\n`TypeError` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ConfigParser.write()", "path": "library/configparser#configparser.ConfigParser.write", "type": "File Formats", "text": "\nWrite a representation of the configuration to the specified file object,\nwhich must be opened in text mode (accepting strings). This representation can\nbe parsed by a future `read()` call. If space_around_delimiters is true,\ndelimiters between keys and values are surrounded by spaces.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.DuplicateOptionError", "path": "library/configparser#configparser.DuplicateOptionError", "type": "File Formats", "text": "\nException raised by strict parsers if a single option appears twice during\nreading from a single file, string or dictionary. This catches misspellings\nand case sensitivity-related errors, e.g. a dictionary may have two keys\nrepresenting the same case-insensitive configuration key.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.DuplicateSectionError", "path": "library/configparser#configparser.DuplicateSectionError", "type": "File Formats", "text": "\nException raised if `add_section()` is called with the name of a section that\nis already present or in strict parsers when a section if found more than once\nin a single input file, string or dictionary.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.Error", "path": "library/configparser#configparser.Error", "type": "File Formats", "text": "\nBase class for all other `configparser` exceptions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ExtendedInterpolation", "path": "library/configparser#configparser.ExtendedInterpolation", "type": "File Formats", "text": "\nAn alternative handler for interpolation which implements a more advanced\nsyntax, used for instance in `zc.buildout`. Extended interpolation is using\n`${section:option}` to denote a value from a foreign section. Interpolation\ncan span multiple levels. For convenience, if the `section:` part is omitted,\ninterpolation defaults to the current section (and possibly the default values\nfrom the special section).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.InterpolationDepthError", "path": "library/configparser#configparser.InterpolationDepthError", "type": "File Formats", "text": "\nException raised when string interpolation cannot be completed because the\nnumber of iterations exceeds `MAX_INTERPOLATION_DEPTH`. Subclass of\n`InterpolationError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.InterpolationError", "path": "library/configparser#configparser.InterpolationError", "type": "File Formats", "text": "\nBase class for exceptions raised when problems occur performing string\ninterpolation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.InterpolationMissingOptionError", "path": "library/configparser#configparser.InterpolationMissingOptionError", "type": "File Formats", "text": "\nException raised when an option referenced from a value does not exist.\nSubclass of `InterpolationError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.InterpolationSyntaxError", "path": "library/configparser#configparser.InterpolationSyntaxError", "type": "File Formats", "text": "\nException raised when the source text into which substitutions are made does\nnot conform to the required syntax. Subclass of `InterpolationError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.MAX_INTERPOLATION_DEPTH", "path": "library/configparser#configparser.MAX_INTERPOLATION_DEPTH", "type": "File Formats", "text": "\nThe maximum depth for recursive interpolation for `get()` when the raw\nparameter is false. This is relevant only when the default interpolation is\nused.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.MissingSectionHeaderError", "path": "library/configparser#configparser.MissingSectionHeaderError", "type": "File Formats", "text": "\nException raised when attempting to parse a file which has no section headers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.NoOptionError", "path": "library/configparser#configparser.NoOptionError", "type": "File Formats", "text": "\nException raised when a specified option is not found in the specified\nsection.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.NoSectionError", "path": "library/configparser#configparser.NoSectionError", "type": "File Formats", "text": "\nException raised when a specified section is not found.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.ParsingError", "path": "library/configparser#configparser.ParsingError", "type": "File Formats", "text": "\nException raised when errors occur attempting to parse a file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.RawConfigParser", "path": "library/configparser#configparser.RawConfigParser", "type": "File Formats", "text": "\nLegacy variant of the `ConfigParser`. It has interpolation disabled by default\nand allows for non-string section names, option names, and values via its\nunsafe `add_section` and `set` methods, as well as the legacy `defaults=`\nkeyword argument handling.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.RawConfigParser.add_section()", "path": "library/configparser#configparser.RawConfigParser.add_section", "type": "File Formats", "text": "\nAdd a section named section to the instance. If a section by the given name\nalready exists, `DuplicateSectionError` is raised. If the default section name\nis passed, `ValueError` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "configparser.RawConfigParser.set()", "path": "library/configparser#configparser.RawConfigParser.set", "type": "File Formats", "text": "\nIf the given section exists, set the given option to the specified value;\notherwise raise `NoSectionError`. While it is possible to use\n`RawConfigParser` (or `ConfigParser` with raw parameters set to true) for\ninternal storage of non-string values, full functionality (including\ninterpolation and output to files) can only be achieved using string values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ConnectionAbortedError", "path": "library/exceptions#ConnectionAbortedError", "type": "Built-in Exceptions", "text": "\nA subclass of `ConnectionError`, raised when a connection attempt is aborted\nby the peer. Corresponds to `errno` `ECONNABORTED`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ConnectionError", "path": "library/exceptions#ConnectionError", "type": "Built-in Exceptions", "text": "\nA base class for connection-related issues.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ConnectionRefusedError", "path": "library/exceptions#ConnectionRefusedError", "type": "Built-in Exceptions", "text": "\nA subclass of `ConnectionError`, raised when a connection attempt is refused\nby the peer. Corresponds to `errno` `ECONNREFUSED`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ConnectionResetError", "path": "library/exceptions#ConnectionResetError", "type": "Built-in Exceptions", "text": "\nA subclass of `ConnectionError`, raised when a connection is reset by the\npeer. Corresponds to `errno` `ECONNRESET`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Constants", "path": "library/constants", "type": "Built-in Constants", "text": "\nA small number of constants live in the built-in namespace. They are:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "container.__iter__()", "path": "library/stdtypes#container.__iter__", "type": "Built-in Types", "text": "\nReturn an iterator object. The object is required to support the iterator\nprotocol described below. If a container supports different types of\niteration, additional methods can be provided to specifically request\niterators for those iteration types. (An example of an object supporting\nmultiple forms of iteration would be a tree structure which supports both\nbreadth-first and depth-first traversal.) This method corresponds to the\n`tp_iter` slot of the type structure for Python objects in the Python/C API.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib", "path": "library/contextlib", "type": "Runtime", "text": "\nSource code: Lib/contextlib.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib.AbstractAsyncContextManager", "path": "library/contextlib#contextlib.AbstractAsyncContextManager", "type": "Runtime", "text": "\nAn abstract base class for classes that implement `object.__aenter__()` and\n`object.__aexit__()`. A default implementation for `object.__aenter__()` is\nprovided which returns `self` while `object.__aexit__()` is an abstract method\nwhich by default returns `None`. See also the definition of Asynchronous\nContext Managers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib.AbstractContextManager", "path": "library/contextlib#contextlib.AbstractContextManager", "type": "Runtime", "text": "\nAn abstract base class for classes that implement `object.__enter__()` and\n`object.__exit__()`. A default implementation for `object.__enter__()` is\nprovided which returns `self` while `object.__exit__()` is an abstract method\nwhich by default returns `None`. See also the definition of Context Manager\nTypes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib.asynccontextmanager()", "path": "library/contextlib#contextlib.asynccontextmanager", "type": "Runtime", "text": "\nSimilar to `contextmanager()`, but creates an asynchronous context manager.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib.AsyncExitStack", "path": "library/contextlib#contextlib.AsyncExitStack", "type": "Runtime", "text": "\nAn asynchronous context manager, similar to `ExitStack`, that supports\ncombining both synchronous and asynchronous context managers, as well as\nhaving coroutines for cleanup logic.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib.AsyncExitStack.aclose()", "path": "library/contextlib#contextlib.AsyncExitStack.aclose", "type": "Runtime", "text": "\nSimilar to `close()` but properly handles awaitables.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib.AsyncExitStack.enter_async_context()", "path": "library/contextlib#contextlib.AsyncExitStack.enter_async_context", "type": "Runtime", "text": "\nSimilar to `enter_context()` but expects an asynchronous context manager.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib.AsyncExitStack.push_async_callback()", "path": "library/contextlib#contextlib.AsyncExitStack.push_async_callback", "type": "Runtime", "text": "\nSimilar to `callback()` but expects a coroutine function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib.AsyncExitStack.push_async_exit()", "path": "library/contextlib#contextlib.AsyncExitStack.push_async_exit", "type": "Runtime", "text": "\nSimilar to `push()` but expects either an asynchronous context manager or a\ncoroutine function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib.closing()", "path": "library/contextlib#contextlib.closing", "type": "Runtime", "text": "\nReturn a context manager that closes thing upon completion of the block. This\nis basically equivalent to:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib.ContextDecorator", "path": "library/contextlib#contextlib.ContextDecorator", "type": "Runtime", "text": "\nA base class that enables a context manager to also be used as a decorator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib.contextmanager()", "path": "library/contextlib#contextlib.contextmanager", "type": "Runtime", "text": "\nThis function is a decorator that can be used to define a factory function for\n`with` statement context managers, without needing to create a class or\nseparate `__enter__()` and `__exit__()` methods.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib.ExitStack", "path": "library/contextlib#contextlib.ExitStack", "type": "Runtime", "text": "\nA context manager that is designed to make it easy to programmatically combine\nother context managers and cleanup functions, especially those that are\noptional or otherwise driven by input data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib.ExitStack.callback()", "path": "library/contextlib#contextlib.ExitStack.callback", "type": "Runtime", "text": "\nAccepts an arbitrary callback function and arguments and adds it to the\ncallback stack.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib.ExitStack.close()", "path": "library/contextlib#contextlib.ExitStack.close", "type": "Runtime", "text": "\nImmediately unwinds the callback stack, invoking callbacks in the reverse\norder of registration. For any context managers and exit callbacks registered,\nthe arguments passed in will indicate that no exception occurred.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib.ExitStack.enter_context()", "path": "library/contextlib#contextlib.ExitStack.enter_context", "type": "Runtime", "text": "\nEnters a new context manager and adds its `__exit__()` method to the callback\nstack. The return value is the result of the context manager\u2019s own\n`__enter__()` method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib.ExitStack.pop_all()", "path": "library/contextlib#contextlib.ExitStack.pop_all", "type": "Runtime", "text": "\nTransfers the callback stack to a fresh `ExitStack` instance and returns it.\nNo callbacks are invoked by this operation - instead, they will now be invoked\nwhen the new stack is closed (either explicitly or implicitly at the end of a\n`with` statement).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib.ExitStack.push()", "path": "library/contextlib#contextlib.ExitStack.push", "type": "Runtime", "text": "\nAdds a context manager\u2019s `__exit__()` method to the callback stack.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib.nullcontext()", "path": "library/contextlib#contextlib.nullcontext", "type": "Runtime", "text": "\nReturn a context manager that returns enter_result from `__enter__`, but\notherwise does nothing. It is intended to be used as a stand-in for an\noptional context manager, for example:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib.redirect_stderr()", "path": "library/contextlib#contextlib.redirect_stderr", "type": "Runtime", "text": "\nSimilar to `redirect_stdout()` but redirecting `sys.stderr` to another file or\nfile-like object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib.redirect_stdout()", "path": "library/contextlib#contextlib.redirect_stdout", "type": "Runtime", "text": "\nContext manager for temporarily redirecting `sys.stdout` to another file or\nfile-like object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextlib.suppress()", "path": "library/contextlib#contextlib.suppress", "type": "Runtime", "text": "\nReturn a context manager that suppresses any of the specified exceptions if\nthey occur in the body of a with statement and then resumes execution with the\nfirst statement following the end of the with statement.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextmanager.__enter__()", "path": "library/stdtypes#contextmanager.__enter__", "type": "Built-in Types", "text": "\nEnter the runtime context and return either this object or another object\nrelated to the runtime context. The value returned by this method is bound to\nthe identifier in the `as` clause of `with` statements using this context\nmanager.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextmanager.__exit__()", "path": "library/stdtypes#contextmanager.__exit__", "type": "Built-in Types", "text": "\nExit the runtime context and return a Boolean flag indicating if any exception\nthat occurred should be suppressed. If an exception occurred while executing\nthe body of the `with` statement, the arguments contain the exception type,\nvalue and traceback information. Otherwise, all three arguments are `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextvars", "path": "library/contextvars", "type": "Concurrent Execution", "text": "\nThis module provides APIs to manage, store, and access context-local state.\nThe `ContextVar` class is used to declare and work with Context Variables. The\n`copy_context()` function and the `Context` class should be used to manage the\ncurrent context in asynchronous frameworks.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextvars.Context", "path": "library/contextvars#contextvars.Context", "type": "Concurrent Execution", "text": "\nA mapping of `ContextVars` to their values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextvars.Context.copy()", "path": "library/contextvars#contextvars.Context.copy", "type": "Concurrent Execution", "text": "\nReturn a shallow copy of the context object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextvars.Context.get()", "path": "library/contextvars#contextvars.Context.get", "type": "Concurrent Execution", "text": "\nReturn the value for var if var has the value in the context object. Return\ndefault otherwise. If default is not given, return `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextvars.Context.items()", "path": "library/contextvars#contextvars.Context.items", "type": "Concurrent Execution", "text": "\nReturn a list of 2-tuples containing all variables and their values in the\ncontext object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextvars.Context.keys()", "path": "library/contextvars#contextvars.Context.keys", "type": "Concurrent Execution", "text": "\nReturn a list of all variables in the context object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextvars.Context.run()", "path": "library/contextvars#contextvars.Context.run", "type": "Concurrent Execution", "text": "\nExecute `callable(*args, **kwargs)` code in the context object the run method\nis called on. Return the result of the execution or propagate an exception if\none occurred.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextvars.Context.values()", "path": "library/contextvars#contextvars.Context.values", "type": "Concurrent Execution", "text": "\nReturn a list of all variables\u2019 values in the context object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextvars.ContextVar", "path": "library/contextvars#contextvars.ContextVar", "type": "Concurrent Execution", "text": "\nThis class is used to declare a new Context Variable, e.g.:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextvars.ContextVar.get()", "path": "library/contextvars#contextvars.ContextVar.get", "type": "Concurrent Execution", "text": "\nReturn a value for the context variable for the current context.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextvars.ContextVar.name", "path": "library/contextvars#contextvars.ContextVar.name", "type": "Concurrent Execution", "text": "\nThe name of the variable. This is a read-only property.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextvars.ContextVar.reset()", "path": "library/contextvars#contextvars.ContextVar.reset", "type": "Concurrent Execution", "text": "\nReset the context variable to the value it had before the `ContextVar.set()`\nthat created the token was used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextvars.ContextVar.set()", "path": "library/contextvars#contextvars.ContextVar.set", "type": "Concurrent Execution", "text": "\nCall to set a new value for the context variable in the current context.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextvars.contextvars.Token", "path": "library/contextvars#contextvars.contextvars.Token", "type": "Concurrent Execution", "text": "\nToken objects are returned by the `ContextVar.set()` method. They can be\npassed to the `ContextVar.reset()` method to revert the value of the variable\nto what it was before the corresponding set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextvars.contextvars.Token.Token.MISSING", "path": "library/contextvars#contextvars.contextvars.Token.Token.MISSING", "type": "Concurrent Execution", "text": "\nA marker object used by `Token.old_value`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextvars.contextvars.Token.Token.old_value", "path": "library/contextvars#contextvars.contextvars.Token.Token.old_value", "type": "Concurrent Execution", "text": "\nA read-only property. Set to the value the variable had before the\n`ContextVar.set()` method call that created the token. It points to\n`Token.MISSING` is the variable was not set before the call.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextvars.contextvars.Token.Token.var", "path": "library/contextvars#contextvars.contextvars.Token.Token.var", "type": "Concurrent Execution", "text": "\nA read-only property. Points to the `ContextVar` object that created the\ntoken.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "contextvars.copy_context()", "path": "library/contextvars#contextvars.copy_context", "type": "Concurrent Execution", "text": "\nReturns a copy of the current `Context` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "copy", "path": "library/copy", "type": "Data Types", "text": "\nSource code: Lib/copy.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "copy.copy()", "path": "library/copy#copy.copy", "type": "Data Types", "text": "\nReturn a shallow copy of x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "copy.deepcopy()", "path": "library/copy#copy.deepcopy", "type": "Data Types", "text": "\nReturn a deep copy of x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "copy.Error", "path": "library/copy#copy.Error", "type": "Data Types", "text": "\nRaised for module specific errors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "copyreg", "path": "library/copyreg", "type": "Data Persistence", "text": "\nSource code: Lib/copyreg.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "copyreg.constructor()", "path": "library/copyreg#copyreg.constructor", "type": "Data Persistence", "text": "\nDeclares object to be a valid constructor. If object is not callable (and\nhence not valid as a constructor), raises `TypeError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "copyreg.pickle()", "path": "library/copyreg#copyreg.pickle", "type": "Data Persistence", "text": "\nDeclares that function should be used as a \u201creduction\u201d function for objects of\ntype type. function should return either a string or a tuple containing two or\nthree elements.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "copyright", "path": "library/constants#copyright", "type": "Built-in Constants", "text": "\nObjects that when printed or called, print the text of copyright or credits,\nrespectively.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Coroutines and Tasks", "path": "library/asyncio-task", "type": "Asynchronous I/O", "text": "\nThis section outlines high-level asyncio APIs to work with coroutines and\nTasks.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "credits", "path": "library/constants#credits", "type": "Built-in Constants", "text": "\nObjects that when printed or called, print the text of copyright or credits,\nrespectively.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "crypt", "path": "library/crypt", "type": "Unix", "text": "\nSource code: Lib/crypt.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "crypt.crypt()", "path": "library/crypt#crypt.crypt", "type": "Unix", "text": "\nword will usually be a user\u2019s password as typed at a prompt or in a graphical\ninterface. The optional salt is either a string as returned from `mksalt()`,\none of the `crypt.METHOD_*` values (though not all may be available on all\nplatforms), or a full encrypted password including salt, as returned by this\nfunction. If salt is not provided, the strongest method will be used (as\nreturned by `methods()`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "crypt.methods", "path": "library/crypt#crypt.methods", "type": "Unix", "text": "\nA list of available password hashing algorithms, as `crypt.METHOD_*` objects.\nThis list is sorted from strongest to weakest.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "crypt.METHOD_BLOWFISH", "path": "library/crypt#crypt.METHOD_BLOWFISH", "type": "Unix", "text": "\nAnother Modular Crypt Format method with 22 character salt and 31 character\nhash based on the Blowfish cipher.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "crypt.METHOD_CRYPT", "path": "library/crypt#crypt.METHOD_CRYPT", "type": "Unix", "text": "\nThe traditional method with a 2 character salt and 13 characters of hash. This\nis the weakest method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "crypt.METHOD_MD5", "path": "library/crypt#crypt.METHOD_MD5", "type": "Unix", "text": "\nAnother Modular Crypt Format method with 8 character salt and 22 character\nhash based on the MD5 hash function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "crypt.METHOD_SHA256", "path": "library/crypt#crypt.METHOD_SHA256", "type": "Unix", "text": "\nAnother Modular Crypt Format method with 16 character salt and 43 character\nhash based on the SHA-256 hash function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "crypt.METHOD_SHA512", "path": "library/crypt#crypt.METHOD_SHA512", "type": "Unix", "text": "\nA Modular Crypt Format method with 16 character salt and 86 character hash\nbased on the SHA-512 hash function. This is the strongest method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "crypt.mksalt()", "path": "library/crypt#crypt.mksalt", "type": "Unix", "text": "\nReturn a randomly generated salt of the specified method. If no method is\ngiven, the strongest method available as returned by `methods()` is used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv", "path": "library/csv", "type": "File Formats", "text": "\nSource code: Lib/csv.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.csvreader.dialect", "path": "library/csv#csv.csvreader.dialect", "type": "File Formats", "text": "\nA read-only description of the dialect in use by the parser.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.csvreader.fieldnames", "path": "library/csv#csv.csvreader.fieldnames", "type": "File Formats", "text": "\nIf not passed as a parameter when creating the object, this attribute is\ninitialized upon first access or when the first record is read from the file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.csvreader.line_num", "path": "library/csv#csv.csvreader.line_num", "type": "File Formats", "text": "\nThe number of lines read from the source iterator. This is not the same as the\nnumber of records returned, as records can span multiple lines.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.csvreader.__next__()", "path": "library/csv#csv.csvreader.__next__", "type": "File Formats", "text": "\nReturn the next row of the reader\u2019s iterable object as a list (if the object\nwas returned from `reader()`) or a dict (if it is a `DictReader` instance),\nparsed according to the current dialect. Usually you should call this as\n`next(reader)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.csvwriter.dialect", "path": "library/csv#csv.csvwriter.dialect", "type": "File Formats", "text": "\nA read-only description of the dialect in use by the writer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.csvwriter.writerow()", "path": "library/csv#csv.csvwriter.writerow", "type": "File Formats", "text": "\nWrite the row parameter to the writer\u2019s file object, formatted according to\nthe current dialect. Return the return value of the call to the write method\nof the underlying file object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.csvwriter.writerows()", "path": "library/csv#csv.csvwriter.writerows", "type": "File Formats", "text": "\nWrite all elements in rows (an iterable of row objects as described above) to\nthe writer\u2019s file object, formatted according to the current dialect.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.Dialect", "path": "library/csv#csv.Dialect", "type": "File Formats", "text": "\nThe `Dialect` class is a container class relied on primarily for its\nattributes, which are used to define the parameters for a specific `reader` or\n`writer` instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.Dialect.delimiter", "path": "library/csv#csv.Dialect.delimiter", "type": "File Formats", "text": "\nA one-character string used to separate fields. It defaults to `','`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.Dialect.doublequote", "path": "library/csv#csv.Dialect.doublequote", "type": "File Formats", "text": "\nControls how instances of quotechar appearing inside a field should themselves\nbe quoted. When `True`, the character is doubled. When `False`, the escapechar\nis used as a prefix to the quotechar. It defaults to `True`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.Dialect.escapechar", "path": "library/csv#csv.Dialect.escapechar", "type": "File Formats", "text": "\nA one-character string used by the writer to escape the delimiter if quoting\nis set to `QUOTE_NONE` and the quotechar if doublequote is `False`. On\nreading, the escapechar removes any special meaning from the following\ncharacter. It defaults to `None`, which disables escaping.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.Dialect.lineterminator", "path": "library/csv#csv.Dialect.lineterminator", "type": "File Formats", "text": "\nThe string used to terminate lines produced by the `writer`. It defaults to\n`'\\r\\n'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.Dialect.quotechar", "path": "library/csv#csv.Dialect.quotechar", "type": "File Formats", "text": "\nA one-character string used to quote fields containing special characters,\nsuch as the delimiter or quotechar, or which contain new-line characters. It\ndefaults to `'\"'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.Dialect.quoting", "path": "library/csv#csv.Dialect.quoting", "type": "File Formats", "text": "\nControls when quotes should be generated by the writer and recognised by the\nreader. It can take on any of the `QUOTE_*` constants (see section Module\nContents) and defaults to `QUOTE_MINIMAL`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.Dialect.skipinitialspace", "path": "library/csv#csv.Dialect.skipinitialspace", "type": "File Formats", "text": "\nWhen `True`, whitespace immediately following the delimiter is ignored. The\ndefault is `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.Dialect.strict", "path": "library/csv#csv.Dialect.strict", "type": "File Formats", "text": "\nWhen `True`, raise exception `Error` on bad CSV input. The default is `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.DictReader", "path": "library/csv#csv.DictReader", "type": "File Formats", "text": "\nCreate an object that operates like a regular reader but maps the information\nin each row to a `dict` whose keys are given by the optional fieldnames\nparameter.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.DictWriter", "path": "library/csv#csv.DictWriter", "type": "File Formats", "text": "\nCreate an object which operates like a regular writer but maps dictionaries\nonto output rows. The fieldnames parameter is a `sequence` of keys that\nidentify the order in which values in the dictionary passed to the\n`writerow()` method are written to file f. The optional restval parameter\nspecifies the value to be written if the dictionary is missing a key in\nfieldnames. If the dictionary passed to the `writerow()` method contains a key\nnot found in fieldnames, the optional extrasaction parameter indicates what\naction to take. If it is set to `'raise'`, the default value, a `ValueError`\nis raised. If it is set to `'ignore'`, extra values in the dictionary are\nignored. Any other optional or keyword arguments are passed to the underlying\n`writer` instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.DictWriter.writeheader()", "path": "library/csv#csv.DictWriter.writeheader", "type": "File Formats", "text": "\nWrite a row with the field names (as specified in the constructor) to the\nwriter\u2019s file object, formatted according to the current dialect. Return the\nreturn value of the `csvwriter.writerow()` call used internally.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.Error", "path": "library/csv#csv.Error", "type": "File Formats", "text": "\nRaised by any of the functions when an error is detected.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.excel", "path": "library/csv#csv.excel", "type": "File Formats", "text": "\nThe `excel` class defines the usual properties of an Excel-generated CSV file.\nIt is registered with the dialect name `'excel'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.excel_tab", "path": "library/csv#csv.excel_tab", "type": "File Formats", "text": "\nThe `excel_tab` class defines the usual properties of an Excel-generated TAB-\ndelimited file. It is registered with the dialect name `'excel-tab'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.field_size_limit()", "path": "library/csv#csv.field_size_limit", "type": "File Formats", "text": "\nReturns the current maximum field size allowed by the parser. If new_limit is\ngiven, this becomes the new limit.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.get_dialect()", "path": "library/csv#csv.get_dialect", "type": "File Formats", "text": "\nReturn the dialect associated with name. An `Error` is raised if name is not a\nregistered dialect name. This function returns an immutable `Dialect`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.list_dialects()", "path": "library/csv#csv.list_dialects", "type": "File Formats", "text": "\nReturn the names of all registered dialects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.QUOTE_ALL", "path": "library/csv#csv.QUOTE_ALL", "type": "File Formats", "text": "\nInstructs `writer` objects to quote all fields.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.QUOTE_MINIMAL", "path": "library/csv#csv.QUOTE_MINIMAL", "type": "File Formats", "text": "\nInstructs `writer` objects to only quote those fields which contain special\ncharacters such as delimiter, quotechar or any of the characters in\nlineterminator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.QUOTE_NONE", "path": "library/csv#csv.QUOTE_NONE", "type": "File Formats", "text": "\nInstructs `writer` objects to never quote fields. When the current delimiter\noccurs in output data it is preceded by the current escapechar character. If\nescapechar is not set, the writer will raise `Error` if any characters that\nrequire escaping are encountered.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.QUOTE_NONNUMERIC", "path": "library/csv#csv.QUOTE_NONNUMERIC", "type": "File Formats", "text": "\nInstructs `writer` objects to quote all non-numeric fields.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.reader()", "path": "library/csv#csv.reader", "type": "File Formats", "text": "\nReturn a reader object which will iterate over lines in the given csvfile.\ncsvfile can be any object which supports the iterator protocol and returns a\nstring each time its `__next__()` method is called \u2014 file objects and list\nobjects are both suitable. If csvfile is a file object, it should be opened\nwith `newline=''`. 1 An optional dialect parameter can be given which is used\nto define a set of parameters specific to a particular CSV dialect. It may be\nan instance of a subclass of the `Dialect` class or one of the strings\nreturned by the `list_dialects()` function. The other optional fmtparams\nkeyword arguments can be given to override individual formatting parameters in\nthe current dialect. For full details about the dialect and formatting\nparameters, see section Dialects and Formatting Parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.register_dialect()", "path": "library/csv#csv.register_dialect", "type": "File Formats", "text": "\nAssociate dialect with name. name must be a string. The dialect can be\nspecified either by passing a sub-class of `Dialect`, or by fmtparams keyword\narguments, or both, with keyword arguments overriding parameters of the\ndialect. For full details about the dialect and formatting parameters, see\nsection Dialects and Formatting Parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.Sniffer", "path": "library/csv#csv.Sniffer", "type": "File Formats", "text": "\nThe `Sniffer` class is used to deduce the format of a CSV file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.Sniffer.has_header()", "path": "library/csv#csv.Sniffer.has_header", "type": "File Formats", "text": "\nAnalyze the sample text (presumed to be in CSV format) and return `True` if\nthe first row appears to be a series of column headers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.Sniffer.sniff()", "path": "library/csv#csv.Sniffer.sniff", "type": "File Formats", "text": "\nAnalyze the given sample and return a `Dialect` subclass reflecting the\nparameters found. If the optional delimiters parameter is given, it is\ninterpreted as a string containing possible valid delimiter characters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.unix_dialect", "path": "library/csv#csv.unix_dialect", "type": "File Formats", "text": "\nThe `unix_dialect` class defines the usual properties of a CSV file generated\non UNIX systems, i.e. using `'\\n'` as line terminator and quoting all fields.\nIt is registered with the dialect name `'unix'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.unregister_dialect()", "path": "library/csv#csv.unregister_dialect", "type": "File Formats", "text": "\nDelete the dialect associated with name from the dialect registry. An `Error`\nis raised if name is not a registered dialect name.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "csv.writer()", "path": "library/csv#csv.writer", "type": "File Formats", "text": "\nReturn a writer object responsible for converting the user\u2019s data into\ndelimited strings on the given file-like object. csvfile can be any object\nwith a `write()` method. If csvfile is a file object, it should be opened with\n`newline=''` 1. An optional dialect parameter can be given which is used to\ndefine a set of parameters specific to a particular CSV dialect. It may be an\ninstance of a subclass of the `Dialect` class or one of the strings returned\nby the `list_dialects()` function. The other optional fmtparams keyword\narguments can be given to override individual formatting parameters in the\ncurrent dialect. For full details about the dialect and formatting parameters,\nsee section Dialects and Formatting Parameters. To make it as easy as possible\nto interface with modules which implement the DB API, the value `None` is\nwritten as the empty string. While this isn\u2019t a reversible transformation, it\nmakes it easier to dump SQL NULL data values to CSV files without\npreprocessing the data returned from a `cursor.fetch*` call. All other non-\nstring data are stringified with `str()` before being written.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes", "path": "library/ctypes", "type": "Operating System", "text": "\n`ctypes` is a foreign function library for Python. It provides C compatible\ndata types, and allows calling functions in DLLs or shared libraries. It can\nbe used to wrap these libraries in pure Python.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.addressof()", "path": "library/ctypes#ctypes.addressof", "type": "Operating System", "text": "\nReturns the address of the memory buffer as integer. obj must be an instance\nof a ctypes type.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.alignment()", "path": "library/ctypes#ctypes.alignment", "type": "Operating System", "text": "\nReturns the alignment requirements of a ctypes type. obj_or_type must be a\nctypes type or instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.ArgumentError", "path": "library/ctypes#ctypes.ArgumentError", "type": "Operating System", "text": "\nThis exception is raised when a foreign function call cannot convert one of\nthe passed arguments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.Array", "path": "library/ctypes#ctypes.Array", "type": "Operating System", "text": "\nAbstract base class for arrays.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.Array._length_", "path": "library/ctypes#ctypes.Array._length_", "type": "Operating System", "text": "\nA positive integer specifying the number of elements in the array. Out-of-\nrange subscripts result in an `IndexError`. Will be returned by `len()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.Array._type_", "path": "library/ctypes#ctypes.Array._type_", "type": "Operating System", "text": "\nSpecifies the type of each element in the array.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.BigEndianStructure", "path": "library/ctypes#ctypes.BigEndianStructure", "type": "Operating System", "text": "\nAbstract base class for structures in big endian byte order.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.byref()", "path": "library/ctypes#ctypes.byref", "type": "Operating System", "text": "\nReturns a light-weight pointer to obj, which must be an instance of a ctypes\ntype. offset defaults to zero, and must be an integer that will be added to\nthe internal pointer value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.cast()", "path": "library/ctypes#ctypes.cast", "type": "Operating System", "text": "\nThis function is similar to the cast operator in C. It returns a new instance\nof type which points to the same memory block as obj. type must be a pointer\ntype, and obj must be an object that can be interpreted as a pointer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.CDLL", "path": "library/ctypes#ctypes.CDLL", "type": "Operating System", "text": "\nInstances of this class represent loaded shared libraries. Functions in these\nlibraries use the standard C calling convention, and are assumed to return\n`int`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.CFUNCTYPE()", "path": "library/ctypes#ctypes.CFUNCTYPE", "type": "Operating System", "text": "\nThe returned function prototype creates functions that use the standard C\ncalling convention. The function will release the GIL during the call. If\nuse_errno is set to true, the ctypes private copy of the system `errno`\nvariable is exchanged with the real `errno` value before and after the call;\nuse_last_error does the same for the Windows error code.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.create_string_buffer()", "path": "library/ctypes#ctypes.create_string_buffer", "type": "Operating System", "text": "\nThis function creates a mutable character buffer. The returned object is a\nctypes array of `c_char`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.create_unicode_buffer()", "path": "library/ctypes#ctypes.create_unicode_buffer", "type": "Operating System", "text": "\nThis function creates a mutable unicode character buffer. The returned object\nis a ctypes array of `c_wchar`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_bool", "path": "library/ctypes#ctypes.c_bool", "type": "Operating System", "text": "\nRepresent the C `bool` datatype (more accurately, `_Bool` from C99). Its value\ncan be `True` or `False`, and the constructor accepts any object that has a\ntruth value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_byte", "path": "library/ctypes#ctypes.c_byte", "type": "Operating System", "text": "\nRepresents the C `signed char` datatype, and interprets the value as small\ninteger. The constructor accepts an optional integer initializer; no overflow\nchecking is done.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_char", "path": "library/ctypes#ctypes.c_char", "type": "Operating System", "text": "\nRepresents the C `char` datatype, and interprets the value as a single\ncharacter. The constructor accepts an optional string initializer, the length\nof the string must be exactly one character.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_char_p", "path": "library/ctypes#ctypes.c_char_p", "type": "Operating System", "text": "\nRepresents the C `char *` datatype when it points to a zero-terminated string.\nFor a general character pointer that may also point to binary data,\n`POINTER(c_char)` must be used. The constructor accepts an integer address, or\na bytes object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_double", "path": "library/ctypes#ctypes.c_double", "type": "Operating System", "text": "\nRepresents the C `double` datatype. The constructor accepts an optional float\ninitializer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_float", "path": "library/ctypes#ctypes.c_float", "type": "Operating System", "text": "\nRepresents the C `float` datatype. The constructor accepts an optional float\ninitializer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_int", "path": "library/ctypes#ctypes.c_int", "type": "Operating System", "text": "\nRepresents the C `signed int` datatype. The constructor accepts an optional\ninteger initializer; no overflow checking is done. On platforms where\n`sizeof(int) == sizeof(long)` it is an alias to `c_long`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_int16", "path": "library/ctypes#ctypes.c_int16", "type": "Operating System", "text": "\nRepresents the C 16-bit `signed int` datatype. Usually an alias for `c_short`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_int32", "path": "library/ctypes#ctypes.c_int32", "type": "Operating System", "text": "\nRepresents the C 32-bit `signed int` datatype. Usually an alias for `c_int`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_int64", "path": "library/ctypes#ctypes.c_int64", "type": "Operating System", "text": "\nRepresents the C 64-bit `signed int` datatype. Usually an alias for\n`c_longlong`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_int8", "path": "library/ctypes#ctypes.c_int8", "type": "Operating System", "text": "\nRepresents the C 8-bit `signed int` datatype. Usually an alias for `c_byte`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_long", "path": "library/ctypes#ctypes.c_long", "type": "Operating System", "text": "\nRepresents the C `signed long` datatype. The constructor accepts an optional\ninteger initializer; no overflow checking is done.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_longdouble", "path": "library/ctypes#ctypes.c_longdouble", "type": "Operating System", "text": "\nRepresents the C `long double` datatype. The constructor accepts an optional\nfloat initializer. On platforms where `sizeof(long double) == sizeof(double)`\nit is an alias to `c_double`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_longlong", "path": "library/ctypes#ctypes.c_longlong", "type": "Operating System", "text": "\nRepresents the C `signed long long` datatype. The constructor accepts an\noptional integer initializer; no overflow checking is done.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_short", "path": "library/ctypes#ctypes.c_short", "type": "Operating System", "text": "\nRepresents the C `signed short` datatype. The constructor accepts an optional\ninteger initializer; no overflow checking is done.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_size_t", "path": "library/ctypes#ctypes.c_size_t", "type": "Operating System", "text": "\nRepresents the C `size_t` datatype.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_ssize_t", "path": "library/ctypes#ctypes.c_ssize_t", "type": "Operating System", "text": "\nRepresents the C `ssize_t` datatype.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_ubyte", "path": "library/ctypes#ctypes.c_ubyte", "type": "Operating System", "text": "\nRepresents the C `unsigned char` datatype, it interprets the value as small\ninteger. The constructor accepts an optional integer initializer; no overflow\nchecking is done.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_uint", "path": "library/ctypes#ctypes.c_uint", "type": "Operating System", "text": "\nRepresents the C `unsigned int` datatype. The constructor accepts an optional\ninteger initializer; no overflow checking is done. On platforms where\n`sizeof(int) == sizeof(long)` it is an alias for `c_ulong`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_uint16", "path": "library/ctypes#ctypes.c_uint16", "type": "Operating System", "text": "\nRepresents the C 16-bit `unsigned int` datatype. Usually an alias for\n`c_ushort`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_uint32", "path": "library/ctypes#ctypes.c_uint32", "type": "Operating System", "text": "\nRepresents the C 32-bit `unsigned int` datatype. Usually an alias for\n`c_uint`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_uint64", "path": "library/ctypes#ctypes.c_uint64", "type": "Operating System", "text": "\nRepresents the C 64-bit `unsigned int` datatype. Usually an alias for\n`c_ulonglong`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_uint8", "path": "library/ctypes#ctypes.c_uint8", "type": "Operating System", "text": "\nRepresents the C 8-bit `unsigned int` datatype. Usually an alias for\n`c_ubyte`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_ulong", "path": "library/ctypes#ctypes.c_ulong", "type": "Operating System", "text": "\nRepresents the C `unsigned long` datatype. The constructor accepts an optional\ninteger initializer; no overflow checking is done.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_ulonglong", "path": "library/ctypes#ctypes.c_ulonglong", "type": "Operating System", "text": "\nRepresents the C `unsigned long long` datatype. The constructor accepts an\noptional integer initializer; no overflow checking is done.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_ushort", "path": "library/ctypes#ctypes.c_ushort", "type": "Operating System", "text": "\nRepresents the C `unsigned short` datatype. The constructor accepts an\noptional integer initializer; no overflow checking is done.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_void_p", "path": "library/ctypes#ctypes.c_void_p", "type": "Operating System", "text": "\nRepresents the C `void *` type. The value is represented as integer. The\nconstructor accepts an optional integer initializer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_wchar", "path": "library/ctypes#ctypes.c_wchar", "type": "Operating System", "text": "\nRepresents the C `wchar_t` datatype, and interprets the value as a single\ncharacter unicode string. The constructor accepts an optional string\ninitializer, the length of the string must be exactly one character.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.c_wchar_p", "path": "library/ctypes#ctypes.c_wchar_p", "type": "Operating System", "text": "\nRepresents the C `wchar_t *` datatype, which must be a pointer to a zero-\nterminated wide character string. The constructor accepts an integer address,\nor a string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.DllCanUnloadNow()", "path": "library/ctypes#ctypes.DllCanUnloadNow", "type": "Operating System", "text": "\nWindows only: This function is a hook which allows implementing in-process COM\nservers with ctypes. It is called from the DllCanUnloadNow function that the\n_ctypes extension dll exports.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.DllGetClassObject()", "path": "library/ctypes#ctypes.DllGetClassObject", "type": "Operating System", "text": "\nWindows only: This function is a hook which allows implementing in-process COM\nservers with ctypes. It is called from the DllGetClassObject function that the\n`_ctypes` extension dll exports.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.FormatError()", "path": "library/ctypes#ctypes.FormatError", "type": "Operating System", "text": "\nWindows only: Returns a textual description of the error code code. If no\nerror code is specified, the last error code is used by calling the Windows\napi function GetLastError.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.GetLastError()", "path": "library/ctypes#ctypes.GetLastError", "type": "Operating System", "text": "\nWindows only: Returns the last error code set by Windows in the calling\nthread. This function calls the Windows `GetLastError()` function directly, it\ndoes not return the ctypes-private copy of the error code.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.get_errno()", "path": "library/ctypes#ctypes.get_errno", "type": "Operating System", "text": "\nReturns the current value of the ctypes-private copy of the system `errno`\nvariable in the calling thread.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.get_last_error()", "path": "library/ctypes#ctypes.get_last_error", "type": "Operating System", "text": "\nWindows only: returns the current value of the ctypes-private copy of the\nsystem `LastError` variable in the calling thread.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.HRESULT", "path": "library/ctypes#ctypes.HRESULT", "type": "Operating System", "text": "\nWindows only: Represents a `HRESULT` value, which contains success or error\ninformation for a function or method call.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.LibraryLoader", "path": "library/ctypes#ctypes.LibraryLoader", "type": "Operating System", "text": "\nClass which loads shared libraries. dlltype should be one of the `CDLL`,\n`PyDLL`, `WinDLL`, or `OleDLL` types.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.LibraryLoader.LoadLibrary()", "path": "library/ctypes#ctypes.LibraryLoader.LoadLibrary", "type": "Operating System", "text": "\nLoad a shared library into the process and return it. This method always\nreturns a new instance of the library.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.LittleEndianStructure", "path": "library/ctypes#ctypes.LittleEndianStructure", "type": "Operating System", "text": "\nAbstract base class for structures in little endian byte order.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.memmove()", "path": "library/ctypes#ctypes.memmove", "type": "Operating System", "text": "\nSame as the standard C memmove library function: copies count bytes from src\nto dst. dst and src must be integers or ctypes instances that can be converted\nto pointers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.memset()", "path": "library/ctypes#ctypes.memset", "type": "Operating System", "text": "\nSame as the standard C memset library function: fills the memory block at\naddress dst with count bytes of value c. dst must be an integer specifying an\naddress, or a ctypes instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.OleDLL", "path": "library/ctypes#ctypes.OleDLL", "type": "Operating System", "text": "\nWindows only: Instances of this class represent loaded shared libraries,\nfunctions in these libraries use the `stdcall` calling convention, and are\nassumed to return the windows specific `HRESULT` code. `HRESULT` values\ncontain information specifying whether the function call failed or succeeded,\ntogether with additional error code. If the return value signals a failure, an\n`OSError` is automatically raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.POINTER()", "path": "library/ctypes#ctypes.POINTER", "type": "Operating System", "text": "\nThis factory function creates and returns a new ctypes pointer type. Pointer\ntypes are cached and reused internally, so calling this function repeatedly is\ncheap. type must be a ctypes type.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.pointer()", "path": "library/ctypes#ctypes.pointer", "type": "Operating System", "text": "\nThis function creates a new pointer instance, pointing to obj. The returned\nobject is of the type `POINTER(type(obj))`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.PyDLL", "path": "library/ctypes#ctypes.PyDLL", "type": "Operating System", "text": "\nInstances of this class behave like `CDLL` instances, except that the Python\nGIL is not released during the function call, and after the function execution\nthe Python error flag is checked. If the error flag is set, a Python exception\nis raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.PyDLL._handle", "path": "library/ctypes#ctypes.PyDLL._handle", "type": "Operating System", "text": "\nThe system handle used to access the library.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.PyDLL._name", "path": "library/ctypes#ctypes.PyDLL._name", "type": "Operating System", "text": "\nThe name of the library passed in the constructor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.PYFUNCTYPE()", "path": "library/ctypes#ctypes.PYFUNCTYPE", "type": "Operating System", "text": "\nThe returned function prototype creates functions that use the Python calling\nconvention. The function will not release the GIL during the call.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.py_object", "path": "library/ctypes#ctypes.py_object", "type": "Operating System", "text": "\nRepresents the C `PyObject *` datatype. Calling this without an argument\ncreates a `NULL` `PyObject *` pointer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.resize()", "path": "library/ctypes#ctypes.resize", "type": "Operating System", "text": "\nThis function resizes the internal memory buffer of obj, which must be an\ninstance of a ctypes type. It is not possible to make the buffer smaller than\nthe native size of the objects type, as given by `sizeof(type(obj))`, but it\nis possible to enlarge the buffer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.set_errno()", "path": "library/ctypes#ctypes.set_errno", "type": "Operating System", "text": "\nSet the current value of the ctypes-private copy of the system `errno`\nvariable in the calling thread to value and return the previous value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.set_last_error()", "path": "library/ctypes#ctypes.set_last_error", "type": "Operating System", "text": "\nWindows only: set the current value of the ctypes-private copy of the system\n`LastError` variable in the calling thread to value and return the previous\nvalue.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.sizeof()", "path": "library/ctypes#ctypes.sizeof", "type": "Operating System", "text": "\nReturns the size in bytes of a ctypes type or instance memory buffer. Does the\nsame as the C `sizeof` operator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.string_at()", "path": "library/ctypes#ctypes.string_at", "type": "Operating System", "text": "\nThis function returns the C string starting at memory address address as a\nbytes object. If size is specified, it is used as size, otherwise the string\nis assumed to be zero-terminated.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.Structure", "path": "library/ctypes#ctypes.Structure", "type": "Operating System", "text": "\nAbstract base class for structures in native byte order.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.Structure._anonymous_", "path": "library/ctypes#ctypes.Structure._anonymous_", "type": "Operating System", "text": "\nAn optional sequence that lists the names of unnamed (anonymous) fields.\n`_anonymous_` must be already defined when `_fields_` is assigned, otherwise\nit will have no effect.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.Structure._fields_", "path": "library/ctypes#ctypes.Structure._fields_", "type": "Operating System", "text": "\nA sequence defining the structure fields. The items must be 2-tuples or\n3-tuples. The first item is the name of the field, the second item specifies\nthe type of the field; it can be any ctypes data type.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.Structure._pack_", "path": "library/ctypes#ctypes.Structure._pack_", "type": "Operating System", "text": "\nAn optional small integer that allows overriding the alignment of structure\nfields in the instance. `_pack_` must already be defined when `_fields_` is\nassigned, otherwise it will have no effect.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.Union", "path": "library/ctypes#ctypes.Union", "type": "Operating System", "text": "\nAbstract base class for unions in native byte order.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.util.find_library()", "path": "library/ctypes#ctypes.util.find_library", "type": "Operating System", "text": "\nTry to find a library and return a pathname. name is the library name without\nany prefix like `lib`, suffix like `.so`, `.dylib` or version number (this is\nthe form used for the posix linker option `-l`). If no library can be found,\nreturns `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.util.find_msvcrt()", "path": "library/ctypes#ctypes.util.find_msvcrt", "type": "Operating System", "text": "\nWindows only: return the filename of the VC runtime library used by Python,\nand by the extension modules. If the name of the library cannot be determined,\n`None` is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.WinDLL", "path": "library/ctypes#ctypes.WinDLL", "type": "Operating System", "text": "\nWindows only: Instances of this class represent loaded shared libraries,\nfunctions in these libraries use the `stdcall` calling convention, and are\nassumed to return `int` by default.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.WinError()", "path": "library/ctypes#ctypes.WinError", "type": "Operating System", "text": "\nWindows only: this function is probably the worst-named thing in ctypes. It\ncreates an instance of OSError. If code is not specified, `GetLastError` is\ncalled to determine the error code. If descr is not specified, `FormatError()`\nis called to get a textual description of the error.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.WINFUNCTYPE()", "path": "library/ctypes#ctypes.WINFUNCTYPE", "type": "Operating System", "text": "\nWindows only: The returned function prototype creates functions that use the\n`stdcall` calling convention, except on Windows CE where `WINFUNCTYPE()` is\nthe same as `CFUNCTYPE()`. The function will release the GIL during the call.\nuse_errno and use_last_error have the same meaning as above.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes.wstring_at()", "path": "library/ctypes#ctypes.wstring_at", "type": "Operating System", "text": "\nThis function returns the wide character string starting at memory address\naddress as a string. If size is specified, it is used as the number of\ncharacters of the string, otherwise the string is assumed to be zero-\nterminated.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes._CData", "path": "library/ctypes#ctypes._CData", "type": "Operating System", "text": "\nThis non-public class is the common base class of all ctypes data types. Among\nother things, all ctypes type instances contain a memory block that hold C\ncompatible data; the address of the memory block is returned by the\n`addressof()` helper function. Another instance variable is exposed as\n`_objects`; this contains other Python objects that need to be kept alive in\ncase the memory block contains pointers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes._CData.from_address()", "path": "library/ctypes#ctypes._CData.from_address", "type": "Operating System", "text": "\nThis method returns a ctypes type instance using the memory specified by\naddress which must be an integer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes._CData.from_buffer()", "path": "library/ctypes#ctypes._CData.from_buffer", "type": "Operating System", "text": "\nThis method returns a ctypes instance that shares the buffer of the source\nobject. The source object must support the writeable buffer interface. The\noptional offset parameter specifies an offset into the source buffer in bytes;\nthe default is zero. If the source buffer is not large enough a `ValueError`\nis raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes._CData.from_buffer_copy()", "path": "library/ctypes#ctypes._CData.from_buffer_copy", "type": "Operating System", "text": "\nThis method creates a ctypes instance, copying the buffer from the source\nobject buffer which must be readable. The optional offset parameter specifies\nan offset into the source buffer in bytes; the default is zero. If the source\nbuffer is not large enough a `ValueError` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes._CData.from_param()", "path": "library/ctypes#ctypes._CData.from_param", "type": "Operating System", "text": "\nThis method adapts obj to a ctypes type. It is called with the actual object\nused in a foreign function call when the type is present in the foreign\nfunction\u2019s `argtypes` tuple; it must return an object that can be used as a\nfunction call parameter.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes._CData.in_dll()", "path": "library/ctypes#ctypes._CData.in_dll", "type": "Operating System", "text": "\nThis method returns a ctypes type instance exported by a shared library. name\nis the name of the symbol that exports the data, library is the loaded shared\nlibrary.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes._CData._b_base_", "path": "library/ctypes#ctypes._CData._b_base_", "type": "Operating System", "text": "\nSometimes ctypes data instances do not own the memory block they contain,\ninstead they share part of the memory block of a base object. The `_b_base_`\nread-only member is the root ctypes object that owns the memory block.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes._CData._b_needsfree_", "path": "library/ctypes#ctypes._CData._b_needsfree_", "type": "Operating System", "text": "\nThis read-only variable is true when the ctypes data instance has allocated\nthe memory block itself, false otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes._CData._objects", "path": "library/ctypes#ctypes._CData._objects", "type": "Operating System", "text": "\nThis member is either `None` or a dictionary containing Python objects that\nneed to be kept alive so that the memory block contents is kept valid. This\nobject is only exposed for debugging; never modify the contents of this\ndictionary.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes._FuncPtr", "path": "library/ctypes#ctypes._FuncPtr", "type": "Operating System", "text": "\nBase class for C callable foreign functions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes._FuncPtr.argtypes", "path": "library/ctypes#ctypes._FuncPtr.argtypes", "type": "Operating System", "text": "\nAssign a tuple of ctypes types to specify the argument types that the function\naccepts. Functions using the `stdcall` calling convention can only be called\nwith the same number of arguments as the length of this tuple; functions using\nthe C calling convention accept additional, unspecified arguments as well.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes._FuncPtr.errcheck", "path": "library/ctypes#ctypes._FuncPtr.errcheck", "type": "Operating System", "text": "\nAssign a Python function or another callable to this attribute. The callable\nwill be called with three or more arguments:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes._FuncPtr.restype", "path": "library/ctypes#ctypes._FuncPtr.restype", "type": "Operating System", "text": "\nAssign a ctypes type to specify the result type of the foreign function. Use\n`None` for `void`, a function not returning anything.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes._Pointer", "path": "library/ctypes#ctypes._Pointer", "type": "Operating System", "text": "\nPrivate, abstract base class for pointers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes._Pointer.contents", "path": "library/ctypes#ctypes._Pointer.contents", "type": "Operating System", "text": "\nReturns the object to which to pointer points. Assigning to this attribute\nchanges the pointer to point to the assigned object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes._Pointer._type_", "path": "library/ctypes#ctypes._Pointer._type_", "type": "Operating System", "text": "\nSpecifies the type pointed to.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes._SimpleCData", "path": "library/ctypes#ctypes._SimpleCData", "type": "Operating System", "text": "\nThis non-public class is the base class of all fundamental ctypes data types.\nIt is mentioned here because it contains the common attributes of the\nfundamental ctypes data types. `_SimpleCData` is a subclass of `_CData`, so it\ninherits their methods and attributes. ctypes data types that are not and do\nnot contain pointers can now be pickled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ctypes._SimpleCData.value", "path": "library/ctypes#ctypes._SimpleCData.value", "type": "Operating System", "text": "\nThis attribute contains the actual value of the instance. For integer and\npointer types, it is an integer, for character types, it is a single character\nbytes object or string, for character pointer types it is a Python bytes\nobject or string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses", "path": "library/curses", "type": "Operating System", "text": "\nThe `curses` module provides an interface to the curses library, the de-facto\nstandard for portable advanced terminal handling.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ascii", "path": "library/curses.ascii", "type": "Operating System", "text": "\nThe `curses.ascii` module supplies name constants for ASCII characters and\nfunctions to test membership in various ASCII character classes. The constants\nsupplied are names for control characters as follows:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ascii.alt()", "path": "library/curses.ascii#curses.ascii.alt", "type": "Operating System", "text": "\nReturn the 8-bit character corresponding to the given ASCII character (the\ncharacter bit value is bitwise-ored with 0x80).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ascii.ascii()", "path": "library/curses.ascii#curses.ascii.ascii", "type": "Operating System", "text": "\nReturn the ASCII value corresponding to the low 7 bits of c.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ascii.controlnames", "path": "library/curses.ascii#curses.ascii.controlnames", "type": "Operating System", "text": "\nA 33-element string array that contains the ASCII mnemonics for the thirty-two\nASCII control characters from 0 (NUL) to 0x1f (US), in order, plus the\nmnemonic `SP` for the space character.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ascii.ctrl()", "path": "library/curses.ascii#curses.ascii.ctrl", "type": "Operating System", "text": "\nReturn the control character corresponding to the given character (the\ncharacter bit value is bitwise-anded with 0x1f).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ascii.isalnum()", "path": "library/curses.ascii#curses.ascii.isalnum", "type": "Operating System", "text": "\nChecks for an ASCII alphanumeric character; it is equivalent to `isalpha(c) or\nisdigit(c)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ascii.isalpha()", "path": "library/curses.ascii#curses.ascii.isalpha", "type": "Operating System", "text": "\nChecks for an ASCII alphabetic character; it is equivalent to `isupper(c) or\nislower(c)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ascii.isascii()", "path": "library/curses.ascii#curses.ascii.isascii", "type": "Operating System", "text": "\nChecks for a character value that fits in the 7-bit ASCII set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ascii.isblank()", "path": "library/curses.ascii#curses.ascii.isblank", "type": "Operating System", "text": "\nChecks for an ASCII whitespace character; space or horizontal tab.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ascii.iscntrl()", "path": "library/curses.ascii#curses.ascii.iscntrl", "type": "Operating System", "text": "\nChecks for an ASCII control character (in the range 0x00 to 0x1f or 0x7f).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ascii.isctrl()", "path": "library/curses.ascii#curses.ascii.isctrl", "type": "Operating System", "text": "\nChecks for an ASCII control character (ordinal values 0 to 31).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ascii.isdigit()", "path": "library/curses.ascii#curses.ascii.isdigit", "type": "Operating System", "text": "\nChecks for an ASCII decimal digit, `'0'` through `'9'`. This is equivalent to\n`c in string.digits`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ascii.isgraph()", "path": "library/curses.ascii#curses.ascii.isgraph", "type": "Operating System", "text": "\nChecks for ASCII any printable character except space.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ascii.islower()", "path": "library/curses.ascii#curses.ascii.islower", "type": "Operating System", "text": "\nChecks for an ASCII lower-case character.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ascii.ismeta()", "path": "library/curses.ascii#curses.ascii.ismeta", "type": "Operating System", "text": "\nChecks for a non-ASCII character (ordinal values 0x80 and above).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ascii.isprint()", "path": "library/curses.ascii#curses.ascii.isprint", "type": "Operating System", "text": "\nChecks for any ASCII printable character including space.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ascii.ispunct()", "path": "library/curses.ascii#curses.ascii.ispunct", "type": "Operating System", "text": "\nChecks for any printable ASCII character which is not a space or an\nalphanumeric character.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ascii.isspace()", "path": "library/curses.ascii#curses.ascii.isspace", "type": "Operating System", "text": "\nChecks for ASCII white-space characters; space, line feed, carriage return,\nform feed, horizontal tab, vertical tab.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ascii.isupper()", "path": "library/curses.ascii#curses.ascii.isupper", "type": "Operating System", "text": "\nChecks for an ASCII uppercase letter.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ascii.isxdigit()", "path": "library/curses.ascii#curses.ascii.isxdigit", "type": "Operating System", "text": "\nChecks for an ASCII hexadecimal digit. This is equivalent to `c in\nstring.hexdigits`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ascii.unctrl()", "path": "library/curses.ascii#curses.ascii.unctrl", "type": "Operating System", "text": "\nReturn a string representation of the ASCII character c. If c is printable,\nthis string is the character itself. If the character is a control character\n(0x00\u20130x1f) the string consists of a caret (`'^'`) followed by the\ncorresponding uppercase letter. If the character is an ASCII delete (0x7f) the\nstring is `'^?'`. If the character has its meta bit (0x80) set, the meta bit\nis stripped, the preceding rules applied, and `'!'` prepended to the result.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.baudrate()", "path": "library/curses#curses.baudrate", "type": "Operating System", "text": "\nReturn the output speed of the terminal in bits per second. On software\nterminal emulators it will have a fixed high value. Included for historical\nreasons; in former times, it was used to write output loops for time delays\nand occasionally to change interfaces depending on the line speed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.beep()", "path": "library/curses#curses.beep", "type": "Operating System", "text": "\nEmit a short attention sound.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.can_change_color()", "path": "library/curses#curses.can_change_color", "type": "Operating System", "text": "\nReturn `True` or `False`, depending on whether the programmer can change the\ncolors displayed by the terminal.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.cbreak()", "path": "library/curses#curses.cbreak", "type": "Operating System", "text": "\nEnter cbreak mode. In cbreak mode (sometimes called \u201crare\u201d mode) normal tty\nline buffering is turned off and characters are available to be read one by\none. However, unlike raw mode, special characters (interrupt, quit, suspend,\nand flow control) retain their effects on the tty driver and calling program.\nCalling first `raw()` then `cbreak()` leaves the terminal in cbreak mode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.color_content()", "path": "library/curses#curses.color_content", "type": "Operating System", "text": "\nReturn the intensity of the red, green, and blue (RGB) components in the color\ncolor_number, which must be between `0` and `COLORS - 1`. Return a 3-tuple,\ncontaining the R,G,B values for the given color, which will be between `0` (no\ncomponent) and `1000` (maximum amount of component).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.color_pair()", "path": "library/curses#curses.color_pair", "type": "Operating System", "text": "\nReturn the attribute value for displaying text in the specified color pair.\nOnly the first 256 color pairs are supported. This attribute value can be\ncombined with `A_STANDOUT`, `A_REVERSE`, and the other `A_*` attributes.\n`pair_number()` is the counterpart to this function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.curs_set()", "path": "library/curses#curses.curs_set", "type": "Operating System", "text": "\nSet the cursor state. visibility can be set to `0`, `1`, or `2`, for\ninvisible, normal, or very visible. If the terminal supports the visibility\nrequested, return the previous cursor state; otherwise raise an exception. On\nmany terminals, the \u201cvisible\u201d mode is an underline cursor and the \u201cvery\nvisible\u201d mode is a block cursor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.def_prog_mode()", "path": "library/curses#curses.def_prog_mode", "type": "Operating System", "text": "\nSave the current terminal mode as the \u201cprogram\u201d mode, the mode when the\nrunning program is using curses. (Its counterpart is the \u201cshell\u201d mode, for\nwhen the program is not in curses.) Subsequent calls to `reset_prog_mode()`\nwill restore this mode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.def_shell_mode()", "path": "library/curses#curses.def_shell_mode", "type": "Operating System", "text": "\nSave the current terminal mode as the \u201cshell\u201d mode, the mode when the running\nprogram is not using curses. (Its counterpart is the \u201cprogram\u201d mode, when the\nprogram is using curses capabilities.) Subsequent calls to\n`reset_shell_mode()` will restore this mode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.delay_output()", "path": "library/curses#curses.delay_output", "type": "Operating System", "text": "\nInsert an ms millisecond pause in output.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.doupdate()", "path": "library/curses#curses.doupdate", "type": "Operating System", "text": "\nUpdate the physical screen. The curses library keeps two data structures, one\nrepresenting the current physical screen contents and a virtual screen\nrepresenting the desired next state. The `doupdate()` ground updates the\nphysical screen to match the virtual screen.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.echo()", "path": "library/curses#curses.echo", "type": "Operating System", "text": "\nEnter echo mode. In echo mode, each character input is echoed to the screen as\nit is entered.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.endwin()", "path": "library/curses#curses.endwin", "type": "Operating System", "text": "\nDe-initialize the library, and return terminal to normal status.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.erasechar()", "path": "library/curses#curses.erasechar", "type": "Operating System", "text": "\nReturn the user\u2019s current erase character as a one-byte bytes object. Under\nUnix operating systems this is a property of the controlling tty of the curses\nprogram, and is not set by the curses library itself.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ERR", "path": "library/curses#curses.ERR", "type": "Operating System", "text": "\nSome curses routines that return an integer, such as `getch()`, return `ERR`\nupon failure.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.error", "path": "library/curses#curses.error", "type": "Operating System", "text": "\nException raised when a curses library function returns an error.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.filter()", "path": "library/curses#curses.filter", "type": "Operating System", "text": "\nThe `filter()` routine, if used, must be called before `initscr()` is called.\nThe effect is that, during those calls, `LINES` is set to `1`; the\ncapabilities `clear`, `cup`, `cud`, `cud1`, `cuu1`, `cuu`, `vpa` are disabled;\nand the `home` string is set to the value of `cr`. The effect is that the\ncursor is confined to the current line, and so are screen updates. This may be\nused for enabling character-at-a-time line editing without touching the rest\nof the screen.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.flash()", "path": "library/curses#curses.flash", "type": "Operating System", "text": "\nFlash the screen. That is, change it to reverse-video and then change it back\nin a short interval. Some people prefer such as \u2018visible bell\u2019 to the audible\nattention signal produced by `beep()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.flushinp()", "path": "library/curses#curses.flushinp", "type": "Operating System", "text": "\nFlush all input buffers. This throws away any typeahead that has been typed by\nthe user and has not yet been processed by the program.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.getmouse()", "path": "library/curses#curses.getmouse", "type": "Operating System", "text": "\nAfter `getch()` returns `KEY_MOUSE` to signal a mouse event, this method\nshould be called to retrieve the queued mouse event, represented as a 5-tuple\n`(id, x, y, z, bstate)`. id is an ID value used to distinguish multiple\ndevices, and x, y, z are the event\u2019s coordinates. (z is currently unused.)\nbstate is an integer value whose bits will be set to indicate the type of\nevent, and will be the bitwise OR of one or more of the following constants,\nwhere n is the button number from 1 to 4: `BUTTONn_PRESSED`,\n`BUTTONn_RELEASED`, `BUTTONn_CLICKED`, `BUTTONn_DOUBLE_CLICKED`,\n`BUTTONn_TRIPLE_CLICKED`, `BUTTON_SHIFT`, `BUTTON_CTRL`, `BUTTON_ALT`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.getsyx()", "path": "library/curses#curses.getsyx", "type": "Operating System", "text": "\nReturn the current coordinates of the virtual screen cursor as a tuple `(y,\nx)`. If `leaveok` is currently `True`, then return `(-1, -1)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.getwin()", "path": "library/curses#curses.getwin", "type": "Operating System", "text": "\nRead window related data stored in the file by an earlier `putwin()` call. The\nroutine then creates and initializes a new window using that data, returning\nthe new window object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.get_escdelay()", "path": "library/curses#curses.get_escdelay", "type": "Operating System", "text": "\nRetrieves the value set by `set_escdelay()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.get_tabsize()", "path": "library/curses#curses.get_tabsize", "type": "Operating System", "text": "\nRetrieves the value set by `set_tabsize()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.halfdelay()", "path": "library/curses#curses.halfdelay", "type": "Operating System", "text": "\nUsed for half-delay mode, which is similar to cbreak mode in that characters\ntyped by the user are immediately available to the program. However, after\nblocking for tenths tenths of seconds, raise an exception if nothing has been\ntyped. The value of tenths must be a number between `1` and `255`. Use\n`nocbreak()` to leave half-delay mode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.has_colors()", "path": "library/curses#curses.has_colors", "type": "Operating System", "text": "\nReturn `True` if the terminal can display colors; otherwise, return `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.has_ic()", "path": "library/curses#curses.has_ic", "type": "Operating System", "text": "\nReturn `True` if the terminal has insert- and delete-character capabilities.\nThis function is included for historical reasons only, as all modern software\nterminal emulators have such capabilities.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.has_il()", "path": "library/curses#curses.has_il", "type": "Operating System", "text": "\nReturn `True` if the terminal has insert- and delete-line capabilities, or can\nsimulate them using scrolling regions. This function is included for\nhistorical reasons only, as all modern software terminal emulators have such\ncapabilities.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.has_key()", "path": "library/curses#curses.has_key", "type": "Operating System", "text": "\nTake a key value ch, and return `True` if the current terminal type recognizes\na key with that value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.initscr()", "path": "library/curses#curses.initscr", "type": "Operating System", "text": "\nInitialize the library. Return a window object which represents the whole\nscreen.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.init_color()", "path": "library/curses#curses.init_color", "type": "Operating System", "text": "\nChange the definition of a color, taking the number of the color to be changed\nfollowed by three RGB values (for the amounts of red, green, and blue\ncomponents). The value of color_number must be between `0` and `COLORS - 1`.\nEach of r, g, b, must be a value between `0` and `1000`. When `init_color()`\nis used, all occurrences of that color on the screen immediately change to the\nnew definition. This function is a no-op on most terminals; it is active only\nif `can_change_color()` returns `True`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.init_pair()", "path": "library/curses#curses.init_pair", "type": "Operating System", "text": "\nChange the definition of a color-pair. It takes three arguments: the number of\nthe color-pair to be changed, the foreground color number, and the background\ncolor number. The value of pair_number must be between `1` and `COLOR_PAIRS -\n1` (the `0` color pair is wired to white on black and cannot be changed). The\nvalue of fg and bg arguments must be between `0` and `COLORS - 1`, or, after\ncalling `use_default_colors()`, `-1`. If the color-pair was previously\ninitialized, the screen is refreshed and all occurrences of that color-pair\nare changed to the new definition.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.isendwin()", "path": "library/curses#curses.isendwin", "type": "Operating System", "text": "\nReturn `True` if `endwin()` has been called (that is, the curses library has\nbeen deinitialized).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.is_term_resized()", "path": "library/curses#curses.is_term_resized", "type": "Operating System", "text": "\nReturn `True` if `resize_term()` would modify the window structure, `False`\notherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.keyname()", "path": "library/curses#curses.keyname", "type": "Operating System", "text": "\nReturn the name of the key numbered k as a bytes object. The name of a key\ngenerating printable ASCII character is the key\u2019s character. The name of a\ncontrol-key combination is a two-byte bytes object consisting of a caret\n(`b'^'`) followed by the corresponding printable ASCII character. The name of\nan alt-key combination (128\u2013255) is a bytes object consisting of the prefix\n`b'M-'` followed by the name of the corresponding ASCII character.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.killchar()", "path": "library/curses#curses.killchar", "type": "Operating System", "text": "\nReturn the user\u2019s current line kill character as a one-byte bytes object.\nUnder Unix operating systems this is a property of the controlling tty of the\ncurses program, and is not set by the curses library itself.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.longname()", "path": "library/curses#curses.longname", "type": "Operating System", "text": "\nReturn a bytes object containing the terminfo long name field describing the\ncurrent terminal. The maximum length of a verbose description is 128\ncharacters. It is defined only after the call to `initscr()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.meta()", "path": "library/curses#curses.meta", "type": "Operating System", "text": "\nIf flag is `True`, allow 8-bit characters to be input. If flag is `False`,\nallow only 7-bit chars.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.mouseinterval()", "path": "library/curses#curses.mouseinterval", "type": "Operating System", "text": "\nSet the maximum time in milliseconds that can elapse between press and release\nevents in order for them to be recognized as a click, and return the previous\ninterval value. The default value is 200 msec, or one fifth of a second.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.mousemask()", "path": "library/curses#curses.mousemask", "type": "Operating System", "text": "\nSet the mouse events to be reported, and return a tuple `(availmask,\noldmask)`. availmask indicates which of the specified mouse events can be\nreported; on complete failure it returns `0`. oldmask is the previous value of\nthe given window\u2019s mouse event mask. If this function is never called, no\nmouse events are ever reported.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.napms()", "path": "library/curses#curses.napms", "type": "Operating System", "text": "\nSleep for ms milliseconds.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ncurses_version", "path": "library/curses#curses.ncurses_version", "type": "Operating System", "text": "\nA named tuple containing the three components of the ncurses library version:\nmajor, minor, and patch. All values are integers. The components can also be\naccessed by name, so `curses.ncurses_version[0]` is equivalent to\n`curses.ncurses_version.major` and so on.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.newpad()", "path": "library/curses#curses.newpad", "type": "Operating System", "text": "\nCreate and return a pointer to a new pad data structure with the given number\nof lines and columns. Return a pad as a window object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.newwin()", "path": "library/curses#curses.newwin", "type": "Operating System", "text": "\nReturn a new window, whose left-upper corner is at `(begin_y, begin_x)`, and\nwhose height/width is nlines/ncols.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.nl()", "path": "library/curses#curses.nl", "type": "Operating System", "text": "\nEnter newline mode. This mode translates the return key into newline on input,\nand translates newline into return and line-feed on output. Newline mode is\ninitially on.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.nocbreak()", "path": "library/curses#curses.nocbreak", "type": "Operating System", "text": "\nLeave cbreak mode. Return to normal \u201ccooked\u201d mode with line buffering.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.noecho()", "path": "library/curses#curses.noecho", "type": "Operating System", "text": "\nLeave echo mode. Echoing of input characters is turned off.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.nonl()", "path": "library/curses#curses.nonl", "type": "Operating System", "text": "\nLeave newline mode. Disable translation of return into newline on input, and\ndisable low-level translation of newline into newline/return on output (but\nthis does not change the behavior of `addch('\\n')`, which always does the\nequivalent of return and line feed on the virtual screen). With translation\noff, curses can sometimes speed up vertical motion a little; also, it will be\nable to detect the return key on input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.noqiflush()", "path": "library/curses#curses.noqiflush", "type": "Operating System", "text": "\nWhen the `noqiflush()` routine is used, normal flush of input and output\nqueues associated with the `INTR`, `QUIT` and `SUSP` characters will not be\ndone. You may want to call `noqiflush()` in a signal handler if you want\noutput to continue as though the interrupt had not occurred, after the handler\nexits.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.noraw()", "path": "library/curses#curses.noraw", "type": "Operating System", "text": "\nLeave raw mode. Return to normal \u201ccooked\u201d mode with line buffering.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.OK", "path": "library/curses#curses.OK", "type": "Operating System", "text": "\nSome curses routines that return an integer, such as `napms()`, return `OK`\nupon success.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.pair_content()", "path": "library/curses#curses.pair_content", "type": "Operating System", "text": "\nReturn a tuple `(fg, bg)` containing the colors for the requested color pair.\nThe value of pair_number must be between `0` and `COLOR_PAIRS - 1`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.pair_number()", "path": "library/curses#curses.pair_number", "type": "Operating System", "text": "\nReturn the number of the color-pair set by the attribute value attr.\n`color_pair()` is the counterpart to this function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.panel", "path": "library/curses.panel", "type": "Operating System", "text": "\nPanels are windows with the added feature of depth, so they can be stacked on\ntop of each other, and only the visible portions of each window will be\ndisplayed. Panels can be added, moved up or down in the stack, and removed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.panel.bottom_panel()", "path": "library/curses.panel#curses.panel.bottom_panel", "type": "Operating System", "text": "\nReturns the bottom panel in the panel stack.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.panel.new_panel()", "path": "library/curses.panel#curses.panel.new_panel", "type": "Operating System", "text": "\nReturns a panel object, associating it with the given window win. Be aware\nthat you need to keep the returned panel object referenced explicitly. If you\ndon\u2019t, the panel object is garbage collected and removed from the panel stack.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.panel.Panel.above()", "path": "library/curses.panel#curses.panel.Panel.above", "type": "Operating System", "text": "\nReturns the panel above the current panel.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.panel.Panel.below()", "path": "library/curses.panel#curses.panel.Panel.below", "type": "Operating System", "text": "\nReturns the panel below the current panel.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.panel.Panel.bottom()", "path": "library/curses.panel#curses.panel.Panel.bottom", "type": "Operating System", "text": "\nPush the panel to the bottom of the stack.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.panel.Panel.hidden()", "path": "library/curses.panel#curses.panel.Panel.hidden", "type": "Operating System", "text": "\nReturns `True` if the panel is hidden (not visible), `False` otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.panel.Panel.hide()", "path": "library/curses.panel#curses.panel.Panel.hide", "type": "Operating System", "text": "\nHide the panel. This does not delete the object, it just makes the window on\nscreen invisible.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.panel.Panel.move()", "path": "library/curses.panel#curses.panel.Panel.move", "type": "Operating System", "text": "\nMove the panel to the screen coordinates `(y, x)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.panel.Panel.replace()", "path": "library/curses.panel#curses.panel.Panel.replace", "type": "Operating System", "text": "\nChange the window associated with the panel to the window win.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.panel.Panel.set_userptr()", "path": "library/curses.panel#curses.panel.Panel.set_userptr", "type": "Operating System", "text": "\nSet the panel\u2019s user pointer to obj. This is used to associate an arbitrary\npiece of data with the panel, and can be any Python object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.panel.Panel.show()", "path": "library/curses.panel#curses.panel.Panel.show", "type": "Operating System", "text": "\nDisplay the panel (which might have been hidden).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.panel.Panel.top()", "path": "library/curses.panel#curses.panel.Panel.top", "type": "Operating System", "text": "\nPush panel to the top of the stack.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.panel.Panel.userptr()", "path": "library/curses.panel#curses.panel.Panel.userptr", "type": "Operating System", "text": "\nReturns the user pointer for the panel. This might be any Python object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.panel.Panel.window()", "path": "library/curses.panel#curses.panel.Panel.window", "type": "Operating System", "text": "\nReturns the window object associated with the panel.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.panel.top_panel()", "path": "library/curses.panel#curses.panel.top_panel", "type": "Operating System", "text": "\nReturns the top panel in the panel stack.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.panel.update_panels()", "path": "library/curses.panel#curses.panel.update_panels", "type": "Operating System", "text": "\nUpdates the virtual screen after changes in the panel stack. This does not\ncall `curses.doupdate()`, so you\u2019ll have to do this yourself.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.putp()", "path": "library/curses#curses.putp", "type": "Operating System", "text": "\nEquivalent to `tputs(str, 1, putchar)`; emit the value of a specified terminfo\ncapability for the current terminal. Note that the output of `putp()` always\ngoes to standard output.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.qiflush()", "path": "library/curses#curses.qiflush", "type": "Operating System", "text": "\nIf flag is `False`, the effect is the same as calling `noqiflush()`. If flag\nis `True`, or no argument is provided, the queues will be flushed when these\ncontrol characters are read.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.raw()", "path": "library/curses#curses.raw", "type": "Operating System", "text": "\nEnter raw mode. In raw mode, normal line buffering and processing of\ninterrupt, quit, suspend, and flow control keys are turned off; characters are\npresented to curses input functions one by one.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.resetty()", "path": "library/curses#curses.resetty", "type": "Operating System", "text": "\nRestore the state of the terminal modes to what it was at the last call to\n`savetty()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.reset_prog_mode()", "path": "library/curses#curses.reset_prog_mode", "type": "Operating System", "text": "\nRestore the terminal to \u201cprogram\u201d mode, as previously saved by\n`def_prog_mode()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.reset_shell_mode()", "path": "library/curses#curses.reset_shell_mode", "type": "Operating System", "text": "\nRestore the terminal to \u201cshell\u201d mode, as previously saved by\n`def_shell_mode()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.resizeterm()", "path": "library/curses#curses.resizeterm", "type": "Operating System", "text": "\nResize the standard and current windows to the specified dimensions, and\nadjusts other bookkeeping data used by the curses library that record the\nwindow dimensions (in particular the SIGWINCH handler).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.resize_term()", "path": "library/curses#curses.resize_term", "type": "Operating System", "text": "\nBackend function used by `resizeterm()`, performing most of the work; when\nresizing the windows, `resize_term()` blank-fills the areas that are extended.\nThe calling application should fill in these areas with appropriate data. The\n`resize_term()` function attempts to resize all windows. However, due to the\ncalling convention of pads, it is not possible to resize these without\nadditional interaction with the application.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.savetty()", "path": "library/curses#curses.savetty", "type": "Operating System", "text": "\nSave the current state of the terminal modes in a buffer, usable by\n`resetty()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.setsyx()", "path": "library/curses#curses.setsyx", "type": "Operating System", "text": "\nSet the virtual screen cursor to y, x. If y and x are both `-1`, then\n`leaveok` is set `True`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.setupterm()", "path": "library/curses#curses.setupterm", "type": "Operating System", "text": "\nInitialize the terminal. term is a string giving the terminal name, or `None`;\nif omitted or `None`, the value of the `TERM` environment variable will be\nused. fd is the file descriptor to which any initialization sequences will be\nsent; if not supplied or `-1`, the file descriptor for `sys.stdout` will be\nused.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.set_escdelay()", "path": "library/curses#curses.set_escdelay", "type": "Operating System", "text": "\nSets the number of milliseconds to wait after reading an escape character, to\ndistinguish between an individual escape character entered on the keyboard\nfrom escape sequences sent by cursor and function keys.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.set_tabsize()", "path": "library/curses#curses.set_tabsize", "type": "Operating System", "text": "\nSets the number of columns used by the curses library when converting a tab\ncharacter to spaces as it adds the tab to a window.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.start_color()", "path": "library/curses#curses.start_color", "type": "Operating System", "text": "\nMust be called if the programmer wants to use colors, and before any other\ncolor manipulation routine is called. It is good practice to call this routine\nright after `initscr()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.termattrs()", "path": "library/curses#curses.termattrs", "type": "Operating System", "text": "\nReturn a logical OR of all video attributes supported by the terminal. This\ninformation is useful when a curses program needs complete control over the\nappearance of the screen.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.termname()", "path": "library/curses#curses.termname", "type": "Operating System", "text": "\nReturn the value of the environment variable `TERM`, as a bytes object,\ntruncated to 14 characters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.textpad.rectangle()", "path": "library/curses#curses.textpad.rectangle", "type": "Operating System", "text": "\nDraw a rectangle. The first argument must be a window object; the remaining\narguments are coordinates relative to that window. The second and third\narguments are the y and x coordinates of the upper left hand corner of the\nrectangle to be drawn; the fourth and fifth arguments are the y and x\ncoordinates of the lower right hand corner. The rectangle will be drawn using\nVT100/IBM PC forms characters on terminals that make this possible (including\nxterm and most other software terminal emulators). Otherwise it will be drawn\nwith ASCII dashes, vertical bars, and plus signs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.textpad.Textbox", "path": "library/curses#curses.textpad.Textbox", "type": "Operating System", "text": "\nReturn a textbox widget object. The win argument should be a curses window\nobject in which the textbox is to be contained. The edit cursor of the textbox\nis initially located at the upper left hand corner of the containing window,\nwith coordinates `(0, 0)`. The instance\u2019s `stripspaces` flag is initially on.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.textpad.Textbox.do_command()", "path": "library/curses#curses.textpad.Textbox.do_command", "type": "Operating System", "text": "\nProcess a single command keystroke. Here are the supported special keystrokes:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.textpad.Textbox.edit()", "path": "library/curses#curses.textpad.Textbox.edit", "type": "Operating System", "text": "\nThis is the entry point you will normally use. It accepts editing keystrokes\nuntil one of the termination keystrokes is entered. If validator is supplied,\nit must be a function. It will be called for each keystroke entered with the\nkeystroke as a parameter; command dispatch is done on the result. This method\nreturns the window contents as a string; whether blanks in the window are\nincluded is affected by the `stripspaces` attribute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.textpad.Textbox.gather()", "path": "library/curses#curses.textpad.Textbox.gather", "type": "Operating System", "text": "\nReturn the window contents as a string; whether blanks in the window are\nincluded is affected by the `stripspaces` member.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.textpad.Textbox.stripspaces", "path": "library/curses#curses.textpad.Textbox.stripspaces", "type": "Operating System", "text": "\nThis attribute is a flag which controls the interpretation of blanks in the\nwindow. When it is on, trailing blanks on each line are ignored; any cursor\nmotion that would land the cursor on a trailing blank goes to the end of that\nline instead, and trailing blanks are stripped when the window contents are\ngathered.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.tigetflag()", "path": "library/curses#curses.tigetflag", "type": "Operating System", "text": "\nReturn the value of the Boolean capability corresponding to the terminfo\ncapability name capname as an integer. Return the value `-1` if capname is not\na Boolean capability, or `0` if it is canceled or absent from the terminal\ndescription.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.tigetnum()", "path": "library/curses#curses.tigetnum", "type": "Operating System", "text": "\nReturn the value of the numeric capability corresponding to the terminfo\ncapability name capname as an integer. Return the value `-2` if capname is not\na numeric capability, or `-1` if it is canceled or absent from the terminal\ndescription.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.tigetstr()", "path": "library/curses#curses.tigetstr", "type": "Operating System", "text": "\nReturn the value of the string capability corresponding to the terminfo\ncapability name capname as a bytes object. Return `None` if capname is not a\nterminfo \u201cstring capability\u201d, or is canceled or absent from the terminal\ndescription.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.tparm()", "path": "library/curses#curses.tparm", "type": "Operating System", "text": "\nInstantiate the bytes object str with the supplied parameters, where str\nshould be a parameterized string obtained from the terminfo database. E.g.\n`tparm(tigetstr(\"cup\"), 5, 3)` could result in `b'\\033[6;4H'`, the exact\nresult depending on terminal type.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.typeahead()", "path": "library/curses#curses.typeahead", "type": "Operating System", "text": "\nSpecify that the file descriptor fd be used for typeahead checking. If fd is\n`-1`, then no typeahead checking is done.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.unctrl()", "path": "library/curses#curses.unctrl", "type": "Operating System", "text": "\nReturn a bytes object which is a printable representation of the character ch.\nControl characters are represented as a caret followed by the character, for\nexample as `b'^C'`. Printing characters are left as they are.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ungetch()", "path": "library/curses#curses.ungetch", "type": "Operating System", "text": "\nPush ch so the next `getch()` will return it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.ungetmouse()", "path": "library/curses#curses.ungetmouse", "type": "Operating System", "text": "\nPush a `KEY_MOUSE` event onto the input queue, associating the given state\ndata with it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.unget_wch()", "path": "library/curses#curses.unget_wch", "type": "Operating System", "text": "\nPush ch so the next `get_wch()` will return it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.update_lines_cols()", "path": "library/curses#curses.update_lines_cols", "type": "Operating System", "text": "\nUpdate `LINES` and `COLS`. Useful for detecting manual screen resize.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.use_default_colors()", "path": "library/curses#curses.use_default_colors", "type": "Operating System", "text": "\nAllow use of default values for colors on terminals supporting this feature.\nUse this to support transparency in your application. The default color is\nassigned to the color number `-1`. After calling this function, `init_pair(x,\ncurses.COLOR_RED, -1)` initializes, for instance, color pair x to a red\nforeground color on the default background.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.use_env()", "path": "library/curses#curses.use_env", "type": "Operating System", "text": "\nIf used, this function should be called before `initscr()` or newterm are\ncalled. When flag is `False`, the values of lines and columns specified in the\nterminfo database will be used, even if environment variables `LINES` and\n`COLUMNS` (used by default) are set, or if curses is running in a window (in\nwhich case default behavior would be to use the window size if `LINES` and\n`COLUMNS` are not set).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.version", "path": "library/curses#curses.version", "type": "Operating System", "text": "\nA bytes object representing the current version of the module. Also available\nas `__version__`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.addch()", "path": "library/curses#curses.window.addch", "type": "Operating System", "text": "\nPaint character ch at `(y, x)` with attributes attr, overwriting any character\npreviously painted at that location. By default, the character position and\nattributes are the current settings for the window object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.addnstr()", "path": "library/curses#curses.window.addnstr", "type": "Operating System", "text": "\nPaint at most n characters of the character string str at `(y, x)` with\nattributes attr, overwriting anything previously on the display.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.addstr()", "path": "library/curses#curses.window.addstr", "type": "Operating System", "text": "\nPaint the character string str at `(y, x)` with attributes attr, overwriting\nanything previously on the display.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.attroff()", "path": "library/curses#curses.window.attroff", "type": "Operating System", "text": "\nRemove attribute attr from the \u201cbackground\u201d set applied to all writes to the\ncurrent window.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.attron()", "path": "library/curses#curses.window.attron", "type": "Operating System", "text": "\nAdd attribute attr from the \u201cbackground\u201d set applied to all writes to the\ncurrent window.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.attrset()", "path": "library/curses#curses.window.attrset", "type": "Operating System", "text": "\nSet the \u201cbackground\u201d set of attributes to attr. This set is initially `0` (no\nattributes).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.bkgd()", "path": "library/curses#curses.window.bkgd", "type": "Operating System", "text": "\nSet the background property of the window to the character ch, with attributes\nattr. The change is then applied to every character position in that window:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.bkgdset()", "path": "library/curses#curses.window.bkgdset", "type": "Operating System", "text": "\nSet the window\u2019s background. A window\u2019s background consists of a character and\nany combination of attributes. The attribute part of the background is\ncombined (OR\u2019ed) with all non-blank characters that are written into the\nwindow. Both the character and attribute parts of the background are combined\nwith the blank characters. The background becomes a property of the character\nand moves with the character through any scrolling and insert/delete\nline/character operations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.border()", "path": "library/curses#curses.window.border", "type": "Operating System", "text": "\nDraw a border around the edges of the window. Each parameter specifies the\ncharacter to use for a specific part of the border; see the table below for\nmore details.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.box()", "path": "library/curses#curses.window.box", "type": "Operating System", "text": "\nSimilar to `border()`, but both ls and rs are vertch and both ts and bs are\nhorch. The default corner characters are always used by this function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.chgat()", "path": "library/curses#curses.window.chgat", "type": "Operating System", "text": "\nSet the attributes of num characters at the current cursor position, or at\nposition `(y, x)` if supplied. If num is not given or is `-1`, the attribute\nwill be set on all the characters to the end of the line. This function moves\ncursor to position `(y, x)` if supplied. The changed line will be touched\nusing the `touchline()` method so that the contents will be redisplayed by the\nnext window refresh.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.clear()", "path": "library/curses#curses.window.clear", "type": "Operating System", "text": "\nLike `erase()`, but also cause the whole window to be repainted upon next call\nto `refresh()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.clearok()", "path": "library/curses#curses.window.clearok", "type": "Operating System", "text": "\nIf flag is `True`, the next call to `refresh()` will clear the window\ncompletely.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.clrtobot()", "path": "library/curses#curses.window.clrtobot", "type": "Operating System", "text": "\nErase from cursor to the end of the window: all lines below the cursor are\ndeleted, and then the equivalent of `clrtoeol()` is performed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.clrtoeol()", "path": "library/curses#curses.window.clrtoeol", "type": "Operating System", "text": "\nErase from cursor to the end of the line.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.cursyncup()", "path": "library/curses#curses.window.cursyncup", "type": "Operating System", "text": "\nUpdate the current cursor position of all the ancestors of the window to\nreflect the current cursor position of the window.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.delch()", "path": "library/curses#curses.window.delch", "type": "Operating System", "text": "\nDelete any character at `(y, x)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.deleteln()", "path": "library/curses#curses.window.deleteln", "type": "Operating System", "text": "\nDelete the line under the cursor. All following lines are moved up by one\nline.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.derwin()", "path": "library/curses#curses.window.derwin", "type": "Operating System", "text": "\nAn abbreviation for \u201cderive window\u201d, `derwin()` is the same as calling\n`subwin()`, except that begin_y and begin_x are relative to the origin of the\nwindow, rather than relative to the entire screen. Return a window object for\nthe derived window.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.echochar()", "path": "library/curses#curses.window.echochar", "type": "Operating System", "text": "\nAdd character ch with attribute attr, and immediately call `refresh()` on the\nwindow.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.enclose()", "path": "library/curses#curses.window.enclose", "type": "Operating System", "text": "\nTest whether the given pair of screen-relative character-cell coordinates are\nenclosed by the given window, returning `True` or `False`. It is useful for\ndetermining what subset of the screen windows enclose the location of a mouse\nevent.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.encoding", "path": "library/curses#curses.window.encoding", "type": "Operating System", "text": "\nEncoding used to encode method arguments (Unicode strings and characters). The\nencoding attribute is inherited from the parent window when a subwindow is\ncreated, for example with `window.subwin()`. By default, the locale encoding\nis used (see `locale.getpreferredencoding()`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.erase()", "path": "library/curses#curses.window.erase", "type": "Operating System", "text": "\nClear the window.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.getbegyx()", "path": "library/curses#curses.window.getbegyx", "type": "Operating System", "text": "\nReturn a tuple `(y, x)` of co-ordinates of upper-left corner.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.getbkgd()", "path": "library/curses#curses.window.getbkgd", "type": "Operating System", "text": "\nReturn the given window\u2019s current background character/attribute pair.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.getch()", "path": "library/curses#curses.window.getch", "type": "Operating System", "text": "\nGet a character. Note that the integer returned does not have to be in ASCII\nrange: function keys, keypad keys and so on are represented by numbers higher\nthan 255. In no-delay mode, return `-1` if there is no input, otherwise wait\nuntil a key is pressed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.getkey()", "path": "library/curses#curses.window.getkey", "type": "Operating System", "text": "\nGet a character, returning a string instead of an integer, as `getch()` does.\nFunction keys, keypad keys and other special keys return a multibyte string\ncontaining the key name. In no-delay mode, raise an exception if there is no\ninput.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.getmaxyx()", "path": "library/curses#curses.window.getmaxyx", "type": "Operating System", "text": "\nReturn a tuple `(y, x)` of the height and width of the window.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.getparyx()", "path": "library/curses#curses.window.getparyx", "type": "Operating System", "text": "\nReturn the beginning coordinates of this window relative to its parent window\nas a tuple `(y, x)`. Return `(-1, -1)` if this window has no parent.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.getstr()", "path": "library/curses#curses.window.getstr", "type": "Operating System", "text": "\nRead a bytes object from the user, with primitive line editing capacity.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.getyx()", "path": "library/curses#curses.window.getyx", "type": "Operating System", "text": "\nReturn a tuple `(y, x)` of current cursor position relative to the window\u2019s\nupper-left corner.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.get_wch()", "path": "library/curses#curses.window.get_wch", "type": "Operating System", "text": "\nGet a wide character. Return a character for most keys, or an integer for\nfunction keys, keypad keys, and other special keys. In no-delay mode, raise an\nexception if there is no input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.hline()", "path": "library/curses#curses.window.hline", "type": "Operating System", "text": "\nDisplay a horizontal line starting at `(y, x)` with length n consisting of the\ncharacter ch.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.idcok()", "path": "library/curses#curses.window.idcok", "type": "Operating System", "text": "\nIf flag is `False`, curses no longer considers using the hardware\ninsert/delete character feature of the terminal; if flag is `True`, use of\ncharacter insertion and deletion is enabled. When curses is first initialized,\nuse of character insert/delete is enabled by default.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.idlok()", "path": "library/curses#curses.window.idlok", "type": "Operating System", "text": "\nIf flag is `True`, `curses` will try and use hardware line editing facilities.\nOtherwise, line insertion/deletion are disabled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.immedok()", "path": "library/curses#curses.window.immedok", "type": "Operating System", "text": "\nIf flag is `True`, any change in the window image automatically causes the\nwindow to be refreshed; you no longer have to call `refresh()` yourself.\nHowever, it may degrade performance considerably, due to repeated calls to\nwrefresh. This option is disabled by default.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.inch()", "path": "library/curses#curses.window.inch", "type": "Operating System", "text": "\nReturn the character at the given position in the window. The bottom 8 bits\nare the character proper, and upper bits are the attributes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.insch()", "path": "library/curses#curses.window.insch", "type": "Operating System", "text": "\nPaint character ch at `(y, x)` with attributes attr, moving the line from\nposition x right by one character.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.insdelln()", "path": "library/curses#curses.window.insdelln", "type": "Operating System", "text": "\nInsert nlines lines into the specified window above the current line. The\nnlines bottom lines are lost. For negative nlines, delete nlines lines\nstarting with the one under the cursor, and move the remaining lines up. The\nbottom nlines lines are cleared. The current cursor position remains the same.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.insertln()", "path": "library/curses#curses.window.insertln", "type": "Operating System", "text": "\nInsert a blank line under the cursor. All following lines are moved down by\none line.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.insnstr()", "path": "library/curses#curses.window.insnstr", "type": "Operating System", "text": "\nInsert a character string (as many characters as will fit on the line) before\nthe character under the cursor, up to n characters. If n is zero or negative,\nthe entire string is inserted. All characters to the right of the cursor are\nshifted right, with the rightmost characters on the line being lost. The\ncursor position does not change (after moving to y, x, if specified).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.insstr()", "path": "library/curses#curses.window.insstr", "type": "Operating System", "text": "\nInsert a character string (as many characters as will fit on the line) before\nthe character under the cursor. All characters to the right of the cursor are\nshifted right, with the rightmost characters on the line being lost. The\ncursor position does not change (after moving to y, x, if specified).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.instr()", "path": "library/curses#curses.window.instr", "type": "Operating System", "text": "\nReturn a bytes object of characters, extracted from the window starting at the\ncurrent cursor position, or at y, x if specified. Attributes are stripped from\nthe characters. If n is specified, `instr()` returns a string at most n\ncharacters long (exclusive of the trailing NUL).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.is_linetouched()", "path": "library/curses#curses.window.is_linetouched", "type": "Operating System", "text": "\nReturn `True` if the specified line was modified since the last call to\n`refresh()`; otherwise return `False`. Raise a `curses.error` exception if\nline is not valid for the given window.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.is_wintouched()", "path": "library/curses#curses.window.is_wintouched", "type": "Operating System", "text": "\nReturn `True` if the specified window was modified since the last call to\n`refresh()`; otherwise return `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.keypad()", "path": "library/curses#curses.window.keypad", "type": "Operating System", "text": "\nIf flag is `True`, escape sequences generated by some keys (keypad, function\nkeys) will be interpreted by `curses`. If flag is `False`, escape sequences\nwill be left as is in the input stream.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.leaveok()", "path": "library/curses#curses.window.leaveok", "type": "Operating System", "text": "\nIf flag is `True`, cursor is left where it is on update, instead of being at\n\u201ccursor position.\u201d This reduces cursor movement where possible. If possible\nthe cursor will be made invisible.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.move()", "path": "library/curses#curses.window.move", "type": "Operating System", "text": "\nMove cursor to `(new_y, new_x)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.mvderwin()", "path": "library/curses#curses.window.mvderwin", "type": "Operating System", "text": "\nMove the window inside its parent window. The screen-relative parameters of\nthe window are not changed. This routine is used to display different parts of\nthe parent window at the same physical position on the screen.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.mvwin()", "path": "library/curses#curses.window.mvwin", "type": "Operating System", "text": "\nMove the window so its upper-left corner is at `(new_y, new_x)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.nodelay()", "path": "library/curses#curses.window.nodelay", "type": "Operating System", "text": "\nIf flag is `True`, `getch()` will be non-blocking.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.notimeout()", "path": "library/curses#curses.window.notimeout", "type": "Operating System", "text": "\nIf flag is `True`, escape sequences will not be timed out.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.noutrefresh()", "path": "library/curses#curses.window.noutrefresh", "type": "Operating System", "text": "\nMark for refresh but wait. This function updates the data structure\nrepresenting the desired state of the window, but does not force an update of\nthe physical screen. To accomplish that, call `doupdate()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.overlay()", "path": "library/curses#curses.window.overlay", "type": "Operating System", "text": "\nOverlay the window on top of destwin. The windows need not be the same size,\nonly the overlapping region is copied. This copy is non-destructive, which\nmeans that the current background character does not overwrite the old\ncontents of destwin.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.overwrite()", "path": "library/curses#curses.window.overwrite", "type": "Operating System", "text": "\nOverwrite the window on top of destwin. The windows need not be the same size,\nin which case only the overlapping region is copied. This copy is destructive,\nwhich means that the current background character overwrites the old contents\nof destwin.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.putwin()", "path": "library/curses#curses.window.putwin", "type": "Operating System", "text": "\nWrite all data associated with the window into the provided file object. This\ninformation can be later retrieved using the `getwin()` function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.redrawln()", "path": "library/curses#curses.window.redrawln", "type": "Operating System", "text": "\nIndicate that the num screen lines, starting at line beg, are corrupted and\nshould be completely redrawn on the next `refresh()` call.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.redrawwin()", "path": "library/curses#curses.window.redrawwin", "type": "Operating System", "text": "\nTouch the entire window, causing it to be completely redrawn on the next\n`refresh()` call.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.refresh()", "path": "library/curses#curses.window.refresh", "type": "Operating System", "text": "\nUpdate the display immediately (sync actual screen with previous\ndrawing/deleting methods).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.resize()", "path": "library/curses#curses.window.resize", "type": "Operating System", "text": "\nReallocate storage for a curses window to adjust its dimensions to the\nspecified values. If either dimension is larger than the current values, the\nwindow\u2019s data is filled with blanks that have the current background rendition\n(as set by `bkgdset()`) merged into them.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.scroll()", "path": "library/curses#curses.window.scroll", "type": "Operating System", "text": "\nScroll the screen or scrolling region upward by lines lines.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.scrollok()", "path": "library/curses#curses.window.scrollok", "type": "Operating System", "text": "\nControl what happens when the cursor of a window is moved off the edge of the\nwindow or scrolling region, either as a result of a newline action on the\nbottom line, or typing the last character of the last line. If flag is\n`False`, the cursor is left on the bottom line. If flag is `True`, the window\nis scrolled up one line. Note that in order to get the physical scrolling\neffect on the terminal, it is also necessary to call `idlok()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.setscrreg()", "path": "library/curses#curses.window.setscrreg", "type": "Operating System", "text": "\nSet the scrolling region from line top to line bottom. All scrolling actions\nwill take place in this region.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.standend()", "path": "library/curses#curses.window.standend", "type": "Operating System", "text": "\nTurn off the standout attribute. On some terminals this has the side effect of\nturning off all attributes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.standout()", "path": "library/curses#curses.window.standout", "type": "Operating System", "text": "\nTurn on attribute A_STANDOUT.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.subpad()", "path": "library/curses#curses.window.subpad", "type": "Operating System", "text": "\nReturn a sub-window, whose upper-left corner is at `(begin_y, begin_x)`, and\nwhose width/height is ncols/nlines.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.subwin()", "path": "library/curses#curses.window.subwin", "type": "Operating System", "text": "\nReturn a sub-window, whose upper-left corner is at `(begin_y, begin_x)`, and\nwhose width/height is ncols/nlines.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.syncdown()", "path": "library/curses#curses.window.syncdown", "type": "Operating System", "text": "\nTouch each location in the window that has been touched in any of its ancestor\nwindows. This routine is called by `refresh()`, so it should almost never be\nnecessary to call it manually.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.syncok()", "path": "library/curses#curses.window.syncok", "type": "Operating System", "text": "\nIf flag is `True`, then `syncup()` is called automatically whenever there is a\nchange in the window.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.syncup()", "path": "library/curses#curses.window.syncup", "type": "Operating System", "text": "\nTouch all locations in ancestors of the window that have been changed in the\nwindow.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.timeout()", "path": "library/curses#curses.window.timeout", "type": "Operating System", "text": "\nSet blocking or non-blocking read behavior for the window. If delay is\nnegative, blocking read is used (which will wait indefinitely for input). If\ndelay is zero, then non-blocking read is used, and `getch()` will return `-1`\nif no input is waiting. If delay is positive, then `getch()` will block for\ndelay milliseconds, and return `-1` if there is still no input at the end of\nthat time.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.touchline()", "path": "library/curses#curses.window.touchline", "type": "Operating System", "text": "\nPretend count lines have been changed, starting with line start. If changed is\nsupplied, it specifies whether the affected lines are marked as having been\nchanged (changed`=True`) or unchanged (changed`=False`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.touchwin()", "path": "library/curses#curses.window.touchwin", "type": "Operating System", "text": "\nPretend the whole window has been changed, for purposes of drawing\noptimizations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.untouchwin()", "path": "library/curses#curses.window.untouchwin", "type": "Operating System", "text": "\nMark all lines in the window as unchanged since the last call to `refresh()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.window.vline()", "path": "library/curses#curses.window.vline", "type": "Operating System", "text": "\nDisplay a vertical line starting at `(y, x)` with length n consisting of the\ncharacter ch.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "curses.wrapper()", "path": "library/curses#curses.wrapper", "type": "Operating System", "text": "\nInitialize curses and call another callable object, func, which should be the\nrest of your curses-using application. If the application raises an exception,\nthis function will restore the terminal to a sane state before re-raising the\nexception and generating a traceback. The callable object func is then passed\nthe main window \u2018stdscr\u2019 as its first argument, followed by any other\narguments passed to `wrapper()`. Before calling func, `wrapper()` turns on\ncbreak mode, turns off echo, enables the terminal keypad, and initializes\ncolors if the terminal has color support. On exit (whether normally or by\nexception) it restores cooked mode, turns on echo, and disables the terminal\nkeypad.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dataclasses", "path": "library/dataclasses", "type": "Runtime", "text": "\nSource code: Lib/dataclasses.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dataclasses.asdict()", "path": "library/dataclasses#dataclasses.asdict", "type": "Runtime", "text": "\nConverts the dataclass `instance` to a dict (by using the factory function\n`dict_factory`). Each dataclass is converted to a dict of its fields, as\n`name: value` pairs. dataclasses, dicts, lists, and tuples are recursed into.\nFor example:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dataclasses.astuple()", "path": "library/dataclasses#dataclasses.astuple", "type": "Runtime", "text": "\nConverts the dataclass `instance` to a tuple (by using the factory function\n`tuple_factory`). Each dataclass is converted to a tuple of its field values.\ndataclasses, dicts, lists, and tuples are recursed into.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dataclasses.dataclass()", "path": "library/dataclasses#dataclasses.dataclass", "type": "Runtime", "text": "\nThis function is a decorator that is used to add generated special methods to\nclasses, as described below.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dataclasses.Field", "path": "library/dataclasses#dataclasses.Field", "type": "Runtime", "text": "\n`Field` objects describe each defined field. These objects are created\ninternally, and are returned by the `fields()` module-level method (see\nbelow). Users should never instantiate a `Field` object directly. Its\ndocumented attributes are:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dataclasses.field()", "path": "library/dataclasses#dataclasses.field", "type": "Runtime", "text": "\nFor common and simple use cases, no other functionality is required. There\nare, however, some dataclass features that require additional per-field\ninformation. To satisfy this need for additional information, you can replace\nthe default field value with a call to the provided `field()` function. For\nexample:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dataclasses.fields()", "path": "library/dataclasses#dataclasses.fields", "type": "Runtime", "text": "\nReturns a tuple of `Field` objects that define the fields for this dataclass.\nAccepts either a dataclass, or an instance of a dataclass. Raises `TypeError`\nif not passed a dataclass or instance of one. Does not return pseudo-fields\nwhich are `ClassVar` or `InitVar`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dataclasses.FrozenInstanceError", "path": "library/dataclasses#dataclasses.FrozenInstanceError", "type": "Runtime", "text": "\nRaised when an implicitly defined `__setattr__()` or `__delattr__()` is called\non a dataclass which was defined with `frozen=True`. It is a subclass of\n`AttributeError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dataclasses.is_dataclass()", "path": "library/dataclasses#dataclasses.is_dataclass", "type": "Runtime", "text": "\nReturn `True` if its parameter is a dataclass or an instance of one, otherwise\nreturn `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dataclasses.make_dataclass()", "path": "library/dataclasses#dataclasses.make_dataclass", "type": "Runtime", "text": "\nCreates a new dataclass with name `cls_name`, fields as defined in `fields`,\nbase classes as given in `bases`, and initialized with a namespace as given in\n`namespace`. `fields` is an iterable whose elements are each either `name`,\n`(name, type)`, or `(name, type, Field)`. If just `name` is supplied,\n`typing.Any` is used for `type`. The values of `init`, `repr`, `eq`, `order`,\n`unsafe_hash`, and `frozen` have the same meaning as they do in `dataclass()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dataclasses.replace()", "path": "library/dataclasses#dataclasses.replace", "type": "Runtime", "text": "\nCreates a new object of the same type of `instance`, replacing fields with\nvalues from `changes`. If `instance` is not a Data Class, raises `TypeError`.\nIf values in `changes` do not specify fields, raises `TypeError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime", "path": "library/datetime", "type": "Data Types", "text": "\nSource code: Lib/datetime.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date", "path": "library/datetime#datetime.date", "type": "Data Types", "text": "\nAll arguments are required. Arguments must be integers, in the following\nranges:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.ctime()", "path": "library/datetime#datetime.date.ctime", "type": "Data Types", "text": "\nReturn a string representing the date:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.day", "path": "library/datetime#datetime.date.day", "type": "Data Types", "text": "\nBetween 1 and the number of days in the given month of the given year.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.fromisocalendar()", "path": "library/datetime#datetime.date.fromisocalendar", "type": "Data Types", "text": "\nReturn a `date` corresponding to the ISO calendar date specified by year, week\nand day. This is the inverse of the function `date.isocalendar()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.fromisoformat()", "path": "library/datetime#datetime.date.fromisoformat", "type": "Data Types", "text": "\nReturn a `date` corresponding to a date_string given in the format `YYYY-MM-\nDD`:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.fromordinal()", "path": "library/datetime#datetime.date.fromordinal", "type": "Data Types", "text": "\nReturn the date corresponding to the proleptic Gregorian ordinal, where\nJanuary 1 of year 1 has ordinal 1.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.fromtimestamp()", "path": "library/datetime#datetime.date.fromtimestamp", "type": "Data Types", "text": "\nReturn the local date corresponding to the POSIX timestamp, such as is\nreturned by `time.time()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.isocalendar()", "path": "library/datetime#datetime.date.isocalendar", "type": "Data Types", "text": "\nReturn a named tuple object with three components: `year`, `week` and\n`weekday`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.isoformat()", "path": "library/datetime#datetime.date.isoformat", "type": "Data Types", "text": "\nReturn a string representing the date in ISO 8601 format, `YYYY-MM-DD`:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.isoweekday()", "path": "library/datetime#datetime.date.isoweekday", "type": "Data Types", "text": "\nReturn the day of the week as an integer, where Monday is 1 and Sunday is 7.\nFor example, `date(2002, 12, 4).isoweekday() == 3`, a Wednesday. See also\n`weekday()`, `isocalendar()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.max", "path": "library/datetime#datetime.date.max", "type": "Data Types", "text": "\nThe latest representable date, `date(MAXYEAR, 12, 31)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.min", "path": "library/datetime#datetime.date.min", "type": "Data Types", "text": "\nThe earliest representable date, `date(MINYEAR, 1, 1)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.month", "path": "library/datetime#datetime.date.month", "type": "Data Types", "text": "\nBetween 1 and 12 inclusive.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.replace()", "path": "library/datetime#datetime.date.replace", "type": "Data Types", "text": "\nReturn a date with the same value, except for those parameters given new\nvalues by whichever keyword arguments are specified.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.resolution", "path": "library/datetime#datetime.date.resolution", "type": "Data Types", "text": "\nThe smallest possible difference between non-equal date objects,\n`timedelta(days=1)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.strftime()", "path": "library/datetime#datetime.date.strftime", "type": "Data Types", "text": "\nReturn a string representing the date, controlled by an explicit format\nstring. Format codes referring to hours, minutes or seconds will see 0 values.\nFor a complete list of formatting directives, see strftime() and strptime()\nBehavior.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.timetuple()", "path": "library/datetime#datetime.date.timetuple", "type": "Data Types", "text": "\nReturn a `time.struct_time` such as returned by `time.localtime()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.today()", "path": "library/datetime#datetime.date.today", "type": "Data Types", "text": "\nReturn the current local date.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.toordinal()", "path": "library/datetime#datetime.date.toordinal", "type": "Data Types", "text": "\nReturn the proleptic Gregorian ordinal of the date, where January 1 of year 1\nhas ordinal 1. For any `date` object d, `date.fromordinal(d.toordinal()) ==\nd`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.weekday()", "path": "library/datetime#datetime.date.weekday", "type": "Data Types", "text": "\nReturn the day of the week as an integer, where Monday is 0 and Sunday is 6.\nFor example, `date(2002, 12, 4).weekday() == 2`, a Wednesday. See also\n`isoweekday()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.year", "path": "library/datetime#datetime.date.year", "type": "Data Types", "text": "\nBetween `MINYEAR` and `MAXYEAR` inclusive.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.__format__()", "path": "library/datetime#datetime.date.__format__", "type": "Data Types", "text": "\nSame as `date.strftime()`. This makes it possible to specify a format string\nfor a `date` object in formatted string literals and when using\n`str.format()`. For a complete list of formatting directives, see strftime()\nand strptime() Behavior.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.date.__str__()", "path": "library/datetime#datetime.date.__str__", "type": "Data Types", "text": "\nFor a date d, `str(d)` is equivalent to `d.isoformat()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime", "path": "library/datetime#datetime.datetime", "type": "Data Types", "text": "\nThe year, month and day arguments are required. tzinfo may be `None`, or an\ninstance of a `tzinfo` subclass. The remaining arguments must be integers in\nthe following ranges:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.astimezone()", "path": "library/datetime#datetime.datetime.astimezone", "type": "Data Types", "text": "\nReturn a `datetime` object with new `tzinfo` attribute tz, adjusting the date\nand time data so the result is the same UTC time as self, but in tz\u2019s local\ntime.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.combine()", "path": "library/datetime#datetime.datetime.combine", "type": "Data Types", "text": "\nReturn a new `datetime` object whose date components are equal to the given\n`date` object\u2019s, and whose time components are equal to the given `time`\nobject\u2019s. If the tzinfo argument is provided, its value is used to set the\n`tzinfo` attribute of the result, otherwise the `tzinfo` attribute of the time\nargument is used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.ctime()", "path": "library/datetime#datetime.datetime.ctime", "type": "Data Types", "text": "\nReturn a string representing the date and time:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.date()", "path": "library/datetime#datetime.datetime.date", "type": "Data Types", "text": "\nReturn `date` object with same year, month and day.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.day", "path": "library/datetime#datetime.datetime.day", "type": "Data Types", "text": "\nBetween 1 and the number of days in the given month of the given year.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.dst()", "path": "library/datetime#datetime.datetime.dst", "type": "Data Types", "text": "\nIf `tzinfo` is `None`, returns `None`, else returns `self.tzinfo.dst(self)`,\nand raises an exception if the latter doesn\u2019t return `None` or a `timedelta`\nobject with magnitude less than one day.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.fold", "path": "library/datetime#datetime.datetime.fold", "type": "Data Types", "text": "\nIn `[0, 1]`. Used to disambiguate wall times during a repeated interval. (A\nrepeated interval occurs when clocks are rolled back at the end of daylight\nsaving time or when the UTC offset for the current zone is decreased for\npolitical reasons.) The value 0 (1) represents the earlier (later) of the two\nmoments with the same wall time representation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.fromisocalendar()", "path": "library/datetime#datetime.datetime.fromisocalendar", "type": "Data Types", "text": "\nReturn a `datetime` corresponding to the ISO calendar date specified by year,\nweek and day. The non-date components of the datetime are populated with their\nnormal default values. This is the inverse of the function\n`datetime.isocalendar()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.fromisoformat()", "path": "library/datetime#datetime.datetime.fromisoformat", "type": "Data Types", "text": "\nReturn a `datetime` corresponding to a date_string in one of the formats\nemitted by `date.isoformat()` and `datetime.isoformat()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.fromordinal()", "path": "library/datetime#datetime.datetime.fromordinal", "type": "Data Types", "text": "\nReturn the `datetime` corresponding to the proleptic Gregorian ordinal, where\nJanuary 1 of year 1 has ordinal 1. `ValueError` is raised unless `1 <= ordinal\n<= datetime.max.toordinal()`. The hour, minute, second and microsecond of the\nresult are all 0, and `tzinfo` is `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.fromtimestamp()", "path": "library/datetime#datetime.datetime.fromtimestamp", "type": "Data Types", "text": "\nReturn the local date and time corresponding to the POSIX timestamp, such as\nis returned by `time.time()`. If optional argument tz is `None` or not\nspecified, the timestamp is converted to the platform\u2019s local date and time,\nand the returned `datetime` object is naive.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.hour", "path": "library/datetime#datetime.datetime.hour", "type": "Data Types", "text": "\nIn `range(24)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.isocalendar()", "path": "library/datetime#datetime.datetime.isocalendar", "type": "Data Types", "text": "\nReturn a named tuple with three components: `year`, `week` and `weekday`. The\nsame as `self.date().isocalendar()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.isoformat()", "path": "library/datetime#datetime.datetime.isoformat", "type": "Data Types", "text": "\nReturn a string representing the date and time in ISO 8601 format:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.isoweekday()", "path": "library/datetime#datetime.datetime.isoweekday", "type": "Data Types", "text": "\nReturn the day of the week as an integer, where Monday is 1 and Sunday is 7.\nThe same as `self.date().isoweekday()`. See also `weekday()`, `isocalendar()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.max", "path": "library/datetime#datetime.datetime.max", "type": "Data Types", "text": "\nThe latest representable `datetime`, `datetime(MAXYEAR, 12, 31, 23, 59, 59,\n999999, tzinfo=None)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.microsecond", "path": "library/datetime#datetime.datetime.microsecond", "type": "Data Types", "text": "\nIn `range(1000000)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.min", "path": "library/datetime#datetime.datetime.min", "type": "Data Types", "text": "\nThe earliest representable `datetime`, `datetime(MINYEAR, 1, 1, tzinfo=None)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.minute", "path": "library/datetime#datetime.datetime.minute", "type": "Data Types", "text": "\nIn `range(60)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.month", "path": "library/datetime#datetime.datetime.month", "type": "Data Types", "text": "\nBetween 1 and 12 inclusive.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.now()", "path": "library/datetime#datetime.datetime.now", "type": "Data Types", "text": "\nReturn the current local date and time.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.replace()", "path": "library/datetime#datetime.datetime.replace", "type": "Data Types", "text": "\nReturn a datetime with the same attributes, except for those attributes given\nnew values by whichever keyword arguments are specified. Note that\n`tzinfo=None` can be specified to create a naive datetime from an aware\ndatetime with no conversion of date and time data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.resolution", "path": "library/datetime#datetime.datetime.resolution", "type": "Data Types", "text": "\nThe smallest possible difference between non-equal `datetime` objects,\n`timedelta(microseconds=1)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.second", "path": "library/datetime#datetime.datetime.second", "type": "Data Types", "text": "\nIn `range(60)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.strftime()", "path": "library/datetime#datetime.datetime.strftime", "type": "Data Types", "text": "\nReturn a string representing the date and time, controlled by an explicit\nformat string. For a complete list of formatting directives, see strftime()\nand strptime() Behavior.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.strptime()", "path": "library/datetime#datetime.datetime.strptime", "type": "Data Types", "text": "\nReturn a `datetime` corresponding to date_string, parsed according to format.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.time()", "path": "library/datetime#datetime.datetime.time", "type": "Data Types", "text": "\nReturn `time` object with same hour, minute, second, microsecond and fold.\n`tzinfo` is `None`. See also method `timetz()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.timestamp()", "path": "library/datetime#datetime.datetime.timestamp", "type": "Data Types", "text": "\nReturn POSIX timestamp corresponding to the `datetime` instance. The return\nvalue is a `float` similar to that returned by `time.time()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.timetuple()", "path": "library/datetime#datetime.datetime.timetuple", "type": "Data Types", "text": "\nReturn a `time.struct_time` such as returned by `time.localtime()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.timetz()", "path": "library/datetime#datetime.datetime.timetz", "type": "Data Types", "text": "\nReturn `time` object with same hour, minute, second, microsecond, fold, and\ntzinfo attributes. See also method `time()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.today()", "path": "library/datetime#datetime.datetime.today", "type": "Data Types", "text": "\nReturn the current local datetime, with `tzinfo` `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.toordinal()", "path": "library/datetime#datetime.datetime.toordinal", "type": "Data Types", "text": "\nReturn the proleptic Gregorian ordinal of the date. The same as\n`self.date().toordinal()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.tzinfo", "path": "library/datetime#datetime.datetime.tzinfo", "type": "Data Types", "text": "\nThe object passed as the tzinfo argument to the `datetime` constructor, or\n`None` if none was passed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.tzname()", "path": "library/datetime#datetime.datetime.tzname", "type": "Data Types", "text": "\nIf `tzinfo` is `None`, returns `None`, else returns\n`self.tzinfo.tzname(self)`, raises an exception if the latter doesn\u2019t return\n`None` or a string object,\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.utcfromtimestamp()", "path": "library/datetime#datetime.datetime.utcfromtimestamp", "type": "Data Types", "text": "\nReturn the UTC `datetime` corresponding to the POSIX timestamp, with `tzinfo`\n`None`. (The resulting object is naive.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.utcnow()", "path": "library/datetime#datetime.datetime.utcnow", "type": "Data Types", "text": "\nReturn the current UTC date and time, with `tzinfo` `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.utcoffset()", "path": "library/datetime#datetime.datetime.utcoffset", "type": "Data Types", "text": "\nIf `tzinfo` is `None`, returns `None`, else returns\n`self.tzinfo.utcoffset(self)`, and raises an exception if the latter doesn\u2019t\nreturn `None` or a `timedelta` object with magnitude less than one day.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.utctimetuple()", "path": "library/datetime#datetime.datetime.utctimetuple", "type": "Data Types", "text": "\nIf `datetime` instance d is naive, this is the same as `d.timetuple()` except\nthat `tm_isdst` is forced to 0 regardless of what `d.dst()` returns. DST is\nnever in effect for a UTC time.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.weekday()", "path": "library/datetime#datetime.datetime.weekday", "type": "Data Types", "text": "\nReturn the day of the week as an integer, where Monday is 0 and Sunday is 6.\nThe same as `self.date().weekday()`. See also `isoweekday()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.year", "path": "library/datetime#datetime.datetime.year", "type": "Data Types", "text": "\nBetween `MINYEAR` and `MAXYEAR` inclusive.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.__format__()", "path": "library/datetime#datetime.datetime.__format__", "type": "Data Types", "text": "\nSame as `datetime.strftime()`. This makes it possible to specify a format\nstring for a `datetime` object in formatted string literals and when using\n`str.format()`. For a complete list of formatting directives, see strftime()\nand strptime() Behavior.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.datetime.__str__()", "path": "library/datetime#datetime.datetime.__str__", "type": "Data Types", "text": "\nFor a `datetime` instance d, `str(d)` is equivalent to `d.isoformat(' ')`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.MAXYEAR", "path": "library/datetime#datetime.MAXYEAR", "type": "Data Types", "text": "\nThe largest year number allowed in a `date` or `datetime` object. `MAXYEAR` is\n`9999`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.MINYEAR", "path": "library/datetime#datetime.MINYEAR", "type": "Data Types", "text": "\nThe smallest year number allowed in a `date` or `datetime` object. `MINYEAR`\nis `1`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.time", "path": "library/datetime#datetime.time", "type": "Data Types", "text": "\nAll arguments are optional. tzinfo may be `None`, or an instance of a `tzinfo`\nsubclass. The remaining arguments must be integers in the following ranges:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.time.dst()", "path": "library/datetime#datetime.time.dst", "type": "Data Types", "text": "\nIf `tzinfo` is `None`, returns `None`, else returns `self.tzinfo.dst(None)`,\nand raises an exception if the latter doesn\u2019t return `None`, or a `timedelta`\nobject with magnitude less than one day.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.time.fold", "path": "library/datetime#datetime.time.fold", "type": "Data Types", "text": "\nIn `[0, 1]`. Used to disambiguate wall times during a repeated interval. (A\nrepeated interval occurs when clocks are rolled back at the end of daylight\nsaving time or when the UTC offset for the current zone is decreased for\npolitical reasons.) The value 0 (1) represents the earlier (later) of the two\nmoments with the same wall time representation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.time.fromisoformat()", "path": "library/datetime#datetime.time.fromisoformat", "type": "Data Types", "text": "\nReturn a `time` corresponding to a time_string in one of the formats emitted\nby `time.isoformat()`. Specifically, this function supports strings in the\nformat:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.time.hour", "path": "library/datetime#datetime.time.hour", "type": "Data Types", "text": "\nIn `range(24)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.time.isoformat()", "path": "library/datetime#datetime.time.isoformat", "type": "Data Types", "text": "\nReturn a string representing the time in ISO 8601 format, one of:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.time.max", "path": "library/datetime#datetime.time.max", "type": "Data Types", "text": "\nThe latest representable `time`, `time(23, 59, 59, 999999)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.time.microsecond", "path": "library/datetime#datetime.time.microsecond", "type": "Data Types", "text": "\nIn `range(1000000)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.time.min", "path": "library/datetime#datetime.time.min", "type": "Data Types", "text": "\nThe earliest representable `time`, `time(0, 0, 0, 0)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.time.minute", "path": "library/datetime#datetime.time.minute", "type": "Data Types", "text": "\nIn `range(60)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.time.replace()", "path": "library/datetime#datetime.time.replace", "type": "Data Types", "text": "\nReturn a `time` with the same value, except for those attributes given new\nvalues by whichever keyword arguments are specified. Note that `tzinfo=None`\ncan be specified to create a naive `time` from an aware `time`, without\nconversion of the time data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.time.resolution", "path": "library/datetime#datetime.time.resolution", "type": "Data Types", "text": "\nThe smallest possible difference between non-equal `time` objects,\n`timedelta(microseconds=1)`, although note that arithmetic on `time` objects\nis not supported.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.time.second", "path": "library/datetime#datetime.time.second", "type": "Data Types", "text": "\nIn `range(60)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.time.strftime()", "path": "library/datetime#datetime.time.strftime", "type": "Data Types", "text": "\nReturn a string representing the time, controlled by an explicit format\nstring. For a complete list of formatting directives, see strftime() and\nstrptime() Behavior.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.time.tzinfo", "path": "library/datetime#datetime.time.tzinfo", "type": "Data Types", "text": "\nThe object passed as the tzinfo argument to the `time` constructor, or `None`\nif none was passed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.time.tzname()", "path": "library/datetime#datetime.time.tzname", "type": "Data Types", "text": "\nIf `tzinfo` is `None`, returns `None`, else returns\n`self.tzinfo.tzname(None)`, or raises an exception if the latter doesn\u2019t\nreturn `None` or a string object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.time.utcoffset()", "path": "library/datetime#datetime.time.utcoffset", "type": "Data Types", "text": "\nIf `tzinfo` is `None`, returns `None`, else returns\n`self.tzinfo.utcoffset(None)`, and raises an exception if the latter doesn\u2019t\nreturn `None` or a `timedelta` object with magnitude less than one day.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.time.__format__()", "path": "library/datetime#datetime.time.__format__", "type": "Data Types", "text": "\nSame as `time.strftime()`. This makes it possible to specify a format string\nfor a `time` object in formatted string literals and when using\n`str.format()`. For a complete list of formatting directives, see strftime()\nand strptime() Behavior.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.time.__str__()", "path": "library/datetime#datetime.time.__str__", "type": "Data Types", "text": "\nFor a time t, `str(t)` is equivalent to `t.isoformat()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.timedelta", "path": "library/datetime#datetime.timedelta", "type": "Data Types", "text": "\nAll arguments are optional and default to `0`. Arguments may be integers or\nfloats, and may be positive or negative.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.timedelta.max", "path": "library/datetime#datetime.timedelta.max", "type": "Data Types", "text": "\nThe most positive `timedelta` object, `timedelta(days=999999999, hours=23,\nminutes=59, seconds=59, microseconds=999999)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.timedelta.min", "path": "library/datetime#datetime.timedelta.min", "type": "Data Types", "text": "\nThe most negative `timedelta` object, `timedelta(-999999999)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.timedelta.resolution", "path": "library/datetime#datetime.timedelta.resolution", "type": "Data Types", "text": "\nThe smallest possible difference between non-equal `timedelta` objects,\n`timedelta(microseconds=1)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.timedelta.total_seconds()", "path": "library/datetime#datetime.timedelta.total_seconds", "type": "Data Types", "text": "\nReturn the total number of seconds contained in the duration. Equivalent to\n`td / timedelta(seconds=1)`. For interval units other than seconds, use the\ndivision form directly (e.g. `td / timedelta(microseconds=1)`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.timezone", "path": "library/datetime#datetime.timezone", "type": "Data Types", "text": "\nThe offset argument must be specified as a `timedelta` object representing the\ndifference between the local time and UTC. It must be strictly between\n`-timedelta(hours=24)` and `timedelta(hours=24)`, otherwise `ValueError` is\nraised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.timezone.dst()", "path": "library/datetime#datetime.timezone.dst", "type": "Data Types", "text": "\nAlways returns `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.timezone.fromutc()", "path": "library/datetime#datetime.timezone.fromutc", "type": "Data Types", "text": "\nReturn `dt + offset`. The dt argument must be an aware `datetime` instance,\nwith `tzinfo` set to `self`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.timezone.tzname()", "path": "library/datetime#datetime.timezone.tzname", "type": "Data Types", "text": "\nReturn the fixed value specified when the `timezone` instance is constructed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.timezone.utc", "path": "library/datetime#datetime.timezone.utc", "type": "Data Types", "text": "\nThe UTC timezone, `timezone(timedelta(0))`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.timezone.utcoffset()", "path": "library/datetime#datetime.timezone.utcoffset", "type": "Data Types", "text": "\nReturn the fixed value specified when the `timezone` instance is constructed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.tzinfo", "path": "library/datetime#datetime.tzinfo", "type": "Data Types", "text": "\nThis is an abstract base class, meaning that this class should not be\ninstantiated directly. Define a subclass of `tzinfo` to capture information\nabout a particular time zone.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.tzinfo.dst()", "path": "library/datetime#datetime.tzinfo.dst", "type": "Data Types", "text": "\nReturn the daylight saving time (DST) adjustment, as a `timedelta` object or\n`None` if DST information isn\u2019t known.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.tzinfo.fromutc()", "path": "library/datetime#datetime.tzinfo.fromutc", "type": "Data Types", "text": "\nThis is called from the default `datetime.astimezone()` implementation. When\ncalled from that, `dt.tzinfo` is self, and dt\u2019s date and time data are to be\nviewed as expressing a UTC time. The purpose of `fromutc()` is to adjust the\ndate and time data, returning an equivalent datetime in self\u2019s local time.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.tzinfo.tzname()", "path": "library/datetime#datetime.tzinfo.tzname", "type": "Data Types", "text": "\nReturn the time zone name corresponding to the `datetime` object dt, as a\nstring. Nothing about string names is defined by the `datetime` module, and\nthere\u2019s no requirement that it mean anything in particular. For example,\n\u201cGMT\u201d, \u201cUTC\u201d, \u201c-500\u201d, \u201c-5:00\u201d, \u201cEDT\u201d, \u201cUS/Eastern\u201d, \u201cAmerica/New York\u201d are all\nvalid replies. Return `None` if a string name isn\u2019t known. Note that this is a\nmethod rather than a fixed string primarily because some `tzinfo` subclasses\nwill wish to return different names depending on the specific value of dt\npassed, especially if the `tzinfo` class is accounting for daylight time.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "datetime.tzinfo.utcoffset()", "path": "library/datetime#datetime.tzinfo.utcoffset", "type": "Data Types", "text": "\nReturn offset of local time from UTC, as a `timedelta` object that is positive\neast of UTC. If local time is west of UTC, this should be negative.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dbm", "path": "library/dbm", "type": "Data Persistence", "text": "\nSource code: Lib/dbm/__init__.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dbm.dumb.dumbdbm.close()", "path": "library/dbm#dbm.dumb.dumbdbm.close", "type": "Data Persistence", "text": "\nClose the `dumbdbm` database.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dbm.dumb.dumbdbm.sync()", "path": "library/dbm#dbm.dumb.dumbdbm.sync", "type": "Data Persistence", "text": "\nSynchronize the on-disk directory and data files. This method is called by the\n`Shelve.sync()` method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dbm.dumb.error", "path": "library/dbm#dbm.dumb.error", "type": "Data Persistence", "text": "\nRaised on `dbm.dumb`-specific errors, such as I/O errors. `KeyError` is raised\nfor general mapping errors like specifying an incorrect key.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dbm.dumb.open()", "path": "library/dbm#dbm.dumb.open", "type": "Data Persistence", "text": "\nOpen a `dumbdbm` database and return a dumbdbm object. The filename argument\nis the basename of the database file (without any specific extensions). When a\ndumbdbm database is created, files with `.dat` and `.dir` extensions are\ncreated.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dbm.error", "path": "library/dbm#dbm.error", "type": "Data Persistence", "text": "\nA tuple containing the exceptions that can be raised by each of the supported\nmodules, with a unique exception also named `dbm.error` as the first item \u2014\nthe latter is used when `dbm.error` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dbm.gnu.error", "path": "library/dbm#dbm.gnu.error", "type": "Data Persistence", "text": "\nRaised on `dbm.gnu`-specific errors, such as I/O errors. `KeyError` is raised\nfor general mapping errors like specifying an incorrect key.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dbm.gnu.gdbm.close()", "path": "library/dbm#dbm.gnu.gdbm.close", "type": "Data Persistence", "text": "\nClose the `gdbm` database.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dbm.gnu.gdbm.firstkey()", "path": "library/dbm#dbm.gnu.gdbm.firstkey", "type": "Data Persistence", "text": "\nIt\u2019s possible to loop over every key in the database using this method and the\n`nextkey()` method. The traversal is ordered by `gdbm`\u2019s internal hash values,\nand won\u2019t be sorted by the key values. This method returns the starting key.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dbm.gnu.gdbm.nextkey()", "path": "library/dbm#dbm.gnu.gdbm.nextkey", "type": "Data Persistence", "text": "\nReturns the key that follows key in the traversal. The following code prints\nevery key in the database `db`, without having to create a list in memory that\ncontains them all:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dbm.gnu.gdbm.reorganize()", "path": "library/dbm#dbm.gnu.gdbm.reorganize", "type": "Data Persistence", "text": "\nIf you have carried out a lot of deletions and would like to shrink the space\nused by the `gdbm` file, this routine will reorganize the database. `gdbm`\nobjects will not shorten the length of a database file except by using this\nreorganization; otherwise, deleted file space will be kept and reused as new\n(key, value) pairs are added.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dbm.gnu.gdbm.sync()", "path": "library/dbm#dbm.gnu.gdbm.sync", "type": "Data Persistence", "text": "\nWhen the database has been opened in fast mode, this method forces any\nunwritten data to be written to the disk.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dbm.gnu.open()", "path": "library/dbm#dbm.gnu.open", "type": "Data Persistence", "text": "\nOpen a `gdbm` database and return a `gdbm` object. The filename argument is\nthe name of the database file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dbm.ndbm.error", "path": "library/dbm#dbm.ndbm.error", "type": "Data Persistence", "text": "\nRaised on `dbm.ndbm`-specific errors, such as I/O errors. `KeyError` is raised\nfor general mapping errors like specifying an incorrect key.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dbm.ndbm.library", "path": "library/dbm#dbm.ndbm.library", "type": "Data Persistence", "text": "\nName of the `ndbm` implementation library used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dbm.ndbm.ndbm.close()", "path": "library/dbm#dbm.ndbm.ndbm.close", "type": "Data Persistence", "text": "\nClose the `ndbm` database.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dbm.ndbm.open()", "path": "library/dbm#dbm.ndbm.open", "type": "Data Persistence", "text": "\nOpen a dbm database and return a `ndbm` object. The filename argument is the\nname of the database file (without the `.dir` or `.pag` extensions).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dbm.open()", "path": "library/dbm#dbm.open", "type": "Data Persistence", "text": "\nOpen the database file file and return a corresponding object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dbm.whichdb()", "path": "library/dbm#dbm.whichdb", "type": "Data Persistence", "text": "\nThis function attempts to guess which of the several simple database modules\navailable \u2014 `dbm.gnu`, `dbm.ndbm` or `dbm.dumb` \u2014 should be used to open a\ngiven file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal", "path": "library/decimal", "type": "Numeric & Mathematical", "text": "\nSource code: Lib/decimal.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.BasicContext", "path": "library/decimal#decimal.BasicContext", "type": "Numeric & Mathematical", "text": "\nThis is a standard context defined by the General Decimal Arithmetic\nSpecification. Precision is set to nine. Rounding is set to `ROUND_HALF_UP`.\nAll flags are cleared. All traps are enabled (treated as exceptions) except\n`Inexact`, `Rounded`, and `Subnormal`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Clamped", "path": "library/decimal#decimal.Clamped", "type": "Numeric & Mathematical", "text": "\nAltered an exponent to fit representation constraints.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context", "path": "library/decimal#decimal.Context", "type": "Numeric & Mathematical", "text": "\nCreates a new context. If a field is not specified or is `None`, the default\nvalues are copied from the `DefaultContext`. If the flags field is not\nspecified or is `None`, all flags are cleared.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.abs()", "path": "library/decimal#decimal.Context.abs", "type": "Numeric & Mathematical", "text": "\nReturns the absolute value of x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.add()", "path": "library/decimal#decimal.Context.add", "type": "Numeric & Mathematical", "text": "\nReturn the sum of x and y.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.canonical()", "path": "library/decimal#decimal.Context.canonical", "type": "Numeric & Mathematical", "text": "\nReturns the same Decimal object x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.clear_flags()", "path": "library/decimal#decimal.Context.clear_flags", "type": "Numeric & Mathematical", "text": "\nResets all of the flags to `0`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.clear_traps()", "path": "library/decimal#decimal.Context.clear_traps", "type": "Numeric & Mathematical", "text": "\nResets all of the traps to `0`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.compare()", "path": "library/decimal#decimal.Context.compare", "type": "Numeric & Mathematical", "text": "\nCompares x and y numerically.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.compare_signal()", "path": "library/decimal#decimal.Context.compare_signal", "type": "Numeric & Mathematical", "text": "\nCompares the values of the two operands numerically.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.compare_total()", "path": "library/decimal#decimal.Context.compare_total", "type": "Numeric & Mathematical", "text": "\nCompares two operands using their abstract representation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.compare_total_mag()", "path": "library/decimal#decimal.Context.compare_total_mag", "type": "Numeric & Mathematical", "text": "\nCompares two operands using their abstract representation, ignoring sign.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.copy()", "path": "library/decimal#decimal.Context.copy", "type": "Numeric & Mathematical", "text": "\nReturn a duplicate of the context.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.copy_abs()", "path": "library/decimal#decimal.Context.copy_abs", "type": "Numeric & Mathematical", "text": "\nReturns a copy of x with the sign set to 0.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.copy_decimal()", "path": "library/decimal#decimal.Context.copy_decimal", "type": "Numeric & Mathematical", "text": "\nReturn a copy of the Decimal instance num.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.copy_negate()", "path": "library/decimal#decimal.Context.copy_negate", "type": "Numeric & Mathematical", "text": "\nReturns a copy of x with the sign inverted.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.copy_sign()", "path": "library/decimal#decimal.Context.copy_sign", "type": "Numeric & Mathematical", "text": "\nCopies the sign from y to x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.create_decimal()", "path": "library/decimal#decimal.Context.create_decimal", "type": "Numeric & Mathematical", "text": "\nCreates a new Decimal instance from num but using self as context. Unlike the\n`Decimal` constructor, the context precision, rounding method, flags, and\ntraps are applied to the conversion.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.create_decimal_from_float()", "path": "library/decimal#decimal.Context.create_decimal_from_float", "type": "Numeric & Mathematical", "text": "\nCreates a new Decimal instance from a float f but rounding using self as the\ncontext. Unlike the `Decimal.from_float()` class method, the context\nprecision, rounding method, flags, and traps are applied to the conversion.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.divide()", "path": "library/decimal#decimal.Context.divide", "type": "Numeric & Mathematical", "text": "\nReturn x divided by y.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.divide_int()", "path": "library/decimal#decimal.Context.divide_int", "type": "Numeric & Mathematical", "text": "\nReturn x divided by y, truncated to an integer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.divmod()", "path": "library/decimal#decimal.Context.divmod", "type": "Numeric & Mathematical", "text": "\nDivides two numbers and returns the integer part of the result.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.Etiny()", "path": "library/decimal#decimal.Context.Etiny", "type": "Numeric & Mathematical", "text": "\nReturns a value equal to `Emin - prec + 1` which is the minimum exponent value\nfor subnormal results. When underflow occurs, the exponent is set to `Etiny`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.Etop()", "path": "library/decimal#decimal.Context.Etop", "type": "Numeric & Mathematical", "text": "\nReturns a value equal to `Emax - prec + 1`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.exp()", "path": "library/decimal#decimal.Context.exp", "type": "Numeric & Mathematical", "text": "\nReturns `e ** x`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.fma()", "path": "library/decimal#decimal.Context.fma", "type": "Numeric & Mathematical", "text": "\nReturns x multiplied by y, plus z.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.is_canonical()", "path": "library/decimal#decimal.Context.is_canonical", "type": "Numeric & Mathematical", "text": "\nReturns `True` if x is canonical; otherwise returns `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.is_finite()", "path": "library/decimal#decimal.Context.is_finite", "type": "Numeric & Mathematical", "text": "\nReturns `True` if x is finite; otherwise returns `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.is_infinite()", "path": "library/decimal#decimal.Context.is_infinite", "type": "Numeric & Mathematical", "text": "\nReturns `True` if x is infinite; otherwise returns `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.is_nan()", "path": "library/decimal#decimal.Context.is_nan", "type": "Numeric & Mathematical", "text": "\nReturns `True` if x is a qNaN or sNaN; otherwise returns `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.is_normal()", "path": "library/decimal#decimal.Context.is_normal", "type": "Numeric & Mathematical", "text": "\nReturns `True` if x is a normal number; otherwise returns `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.is_qnan()", "path": "library/decimal#decimal.Context.is_qnan", "type": "Numeric & Mathematical", "text": "\nReturns `True` if x is a quiet NaN; otherwise returns `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.is_signed()", "path": "library/decimal#decimal.Context.is_signed", "type": "Numeric & Mathematical", "text": "\nReturns `True` if x is negative; otherwise returns `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.is_snan()", "path": "library/decimal#decimal.Context.is_snan", "type": "Numeric & Mathematical", "text": "\nReturns `True` if x is a signaling NaN; otherwise returns `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.is_subnormal()", "path": "library/decimal#decimal.Context.is_subnormal", "type": "Numeric & Mathematical", "text": "\nReturns `True` if x is subnormal; otherwise returns `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.is_zero()", "path": "library/decimal#decimal.Context.is_zero", "type": "Numeric & Mathematical", "text": "\nReturns `True` if x is a zero; otherwise returns `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.ln()", "path": "library/decimal#decimal.Context.ln", "type": "Numeric & Mathematical", "text": "\nReturns the natural (base e) logarithm of x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.log10()", "path": "library/decimal#decimal.Context.log10", "type": "Numeric & Mathematical", "text": "\nReturns the base 10 logarithm of x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.logb()", "path": "library/decimal#decimal.Context.logb", "type": "Numeric & Mathematical", "text": "\nReturns the exponent of the magnitude of the operand\u2019s MSD.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.logical_and()", "path": "library/decimal#decimal.Context.logical_and", "type": "Numeric & Mathematical", "text": "\nApplies the logical operation and between each operand\u2019s digits.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.logical_invert()", "path": "library/decimal#decimal.Context.logical_invert", "type": "Numeric & Mathematical", "text": "\nInvert all the digits in x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.logical_or()", "path": "library/decimal#decimal.Context.logical_or", "type": "Numeric & Mathematical", "text": "\nApplies the logical operation or between each operand\u2019s digits.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.logical_xor()", "path": "library/decimal#decimal.Context.logical_xor", "type": "Numeric & Mathematical", "text": "\nApplies the logical operation xor between each operand\u2019s digits.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.max()", "path": "library/decimal#decimal.Context.max", "type": "Numeric & Mathematical", "text": "\nCompares two values numerically and returns the maximum.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.max_mag()", "path": "library/decimal#decimal.Context.max_mag", "type": "Numeric & Mathematical", "text": "\nCompares the values numerically with their sign ignored.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.min()", "path": "library/decimal#decimal.Context.min", "type": "Numeric & Mathematical", "text": "\nCompares two values numerically and returns the minimum.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.minus()", "path": "library/decimal#decimal.Context.minus", "type": "Numeric & Mathematical", "text": "\nMinus corresponds to the unary prefix minus operator in Python.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.min_mag()", "path": "library/decimal#decimal.Context.min_mag", "type": "Numeric & Mathematical", "text": "\nCompares the values numerically with their sign ignored.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.multiply()", "path": "library/decimal#decimal.Context.multiply", "type": "Numeric & Mathematical", "text": "\nReturn the product of x and y.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.next_minus()", "path": "library/decimal#decimal.Context.next_minus", "type": "Numeric & Mathematical", "text": "\nReturns the largest representable number smaller than x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.next_plus()", "path": "library/decimal#decimal.Context.next_plus", "type": "Numeric & Mathematical", "text": "\nReturns the smallest representable number larger than x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.next_toward()", "path": "library/decimal#decimal.Context.next_toward", "type": "Numeric & Mathematical", "text": "\nReturns the number closest to x, in direction towards y.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.normalize()", "path": "library/decimal#decimal.Context.normalize", "type": "Numeric & Mathematical", "text": "\nReduces x to its simplest form.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.number_class()", "path": "library/decimal#decimal.Context.number_class", "type": "Numeric & Mathematical", "text": "\nReturns an indication of the class of x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.plus()", "path": "library/decimal#decimal.Context.plus", "type": "Numeric & Mathematical", "text": "\nPlus corresponds to the unary prefix plus operator in Python. This operation\napplies the context precision and rounding, so it is not an identity\noperation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.power()", "path": "library/decimal#decimal.Context.power", "type": "Numeric & Mathematical", "text": "\nReturn `x` to the power of `y`, reduced modulo `modulo` if given.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.quantize()", "path": "library/decimal#decimal.Context.quantize", "type": "Numeric & Mathematical", "text": "\nReturns a value equal to x (rounded), having the exponent of y.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.radix()", "path": "library/decimal#decimal.Context.radix", "type": "Numeric & Mathematical", "text": "\nJust returns 10, as this is Decimal, :)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.remainder()", "path": "library/decimal#decimal.Context.remainder", "type": "Numeric & Mathematical", "text": "\nReturns the remainder from integer division.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.remainder_near()", "path": "library/decimal#decimal.Context.remainder_near", "type": "Numeric & Mathematical", "text": "\nReturns `x - y * n`, where n is the integer nearest the exact value of `x / y`\n(if the result is 0 then its sign will be the sign of x).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.rotate()", "path": "library/decimal#decimal.Context.rotate", "type": "Numeric & Mathematical", "text": "\nReturns a rotated copy of x, y times.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.same_quantum()", "path": "library/decimal#decimal.Context.same_quantum", "type": "Numeric & Mathematical", "text": "\nReturns `True` if the two operands have the same exponent.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.scaleb()", "path": "library/decimal#decimal.Context.scaleb", "type": "Numeric & Mathematical", "text": "\nReturns the first operand after adding the second value its exp.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.shift()", "path": "library/decimal#decimal.Context.shift", "type": "Numeric & Mathematical", "text": "\nReturns a shifted copy of x, y times.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.sqrt()", "path": "library/decimal#decimal.Context.sqrt", "type": "Numeric & Mathematical", "text": "\nSquare root of a non-negative number to context precision.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.subtract()", "path": "library/decimal#decimal.Context.subtract", "type": "Numeric & Mathematical", "text": "\nReturn the difference between x and y.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.to_eng_string()", "path": "library/decimal#decimal.Context.to_eng_string", "type": "Numeric & Mathematical", "text": "\nConvert to a string, using engineering notation if an exponent is needed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.to_integral_exact()", "path": "library/decimal#decimal.Context.to_integral_exact", "type": "Numeric & Mathematical", "text": "\nRounds to an integer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Context.to_sci_string()", "path": "library/decimal#decimal.Context.to_sci_string", "type": "Numeric & Mathematical", "text": "\nConverts a number to a string using scientific notation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal", "path": "library/decimal#decimal.Decimal", "type": "Numeric & Mathematical", "text": "\nConstruct a new `Decimal` object based from value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.adjusted()", "path": "library/decimal#decimal.Decimal.adjusted", "type": "Numeric & Mathematical", "text": "\nReturn the adjusted exponent after shifting out the coefficient\u2019s rightmost\ndigits until only the lead digit remains: `Decimal('321e+5').adjusted()`\nreturns seven. Used for determining the position of the most significant digit\nwith respect to the decimal point.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.as_integer_ratio()", "path": "library/decimal#decimal.Decimal.as_integer_ratio", "type": "Numeric & Mathematical", "text": "\nReturn a pair `(n, d)` of integers that represent the given `Decimal` instance\nas a fraction, in lowest terms and with a positive denominator:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.as_tuple()", "path": "library/decimal#decimal.Decimal.as_tuple", "type": "Numeric & Mathematical", "text": "\nReturn a named tuple representation of the number: `DecimalTuple(sign, digits,\nexponent)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.canonical()", "path": "library/decimal#decimal.Decimal.canonical", "type": "Numeric & Mathematical", "text": "\nReturn the canonical encoding of the argument. Currently, the encoding of a\n`Decimal` instance is always canonical, so this operation returns its argument\nunchanged.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.compare()", "path": "library/decimal#decimal.Decimal.compare", "type": "Numeric & Mathematical", "text": "\nCompare the values of two Decimal instances. `compare()` returns a Decimal\ninstance, and if either operand is a NaN then the result is a NaN:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.compare_signal()", "path": "library/decimal#decimal.Decimal.compare_signal", "type": "Numeric & Mathematical", "text": "\nThis operation is identical to the `compare()` method, except that all NaNs\nsignal. That is, if neither operand is a signaling NaN then any quiet NaN\noperand is treated as though it were a signaling NaN.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.compare_total()", "path": "library/decimal#decimal.Decimal.compare_total", "type": "Numeric & Mathematical", "text": "\nCompare two operands using their abstract representation rather than their\nnumerical value. Similar to the `compare()` method, but the result gives a\ntotal ordering on `Decimal` instances. Two `Decimal` instances with the same\nnumeric value but different representations compare unequal in this ordering:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.compare_total_mag()", "path": "library/decimal#decimal.Decimal.compare_total_mag", "type": "Numeric & Mathematical", "text": "\nCompare two operands using their abstract representation rather than their\nvalue as in `compare_total()`, but ignoring the sign of each operand.\n`x.compare_total_mag(y)` is equivalent to\n`x.copy_abs().compare_total(y.copy_abs())`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.conjugate()", "path": "library/decimal#decimal.Decimal.conjugate", "type": "Numeric & Mathematical", "text": "\nJust returns self, this method is only to comply with the Decimal\nSpecification.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.copy_abs()", "path": "library/decimal#decimal.Decimal.copy_abs", "type": "Numeric & Mathematical", "text": "\nReturn the absolute value of the argument. This operation is unaffected by the\ncontext and is quiet: no flags are changed and no rounding is performed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.copy_negate()", "path": "library/decimal#decimal.Decimal.copy_negate", "type": "Numeric & Mathematical", "text": "\nReturn the negation of the argument. This operation is unaffected by the\ncontext and is quiet: no flags are changed and no rounding is performed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.copy_sign()", "path": "library/decimal#decimal.Decimal.copy_sign", "type": "Numeric & Mathematical", "text": "\nReturn a copy of the first operand with the sign set to be the same as the\nsign of the second operand. For example:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.exp()", "path": "library/decimal#decimal.Decimal.exp", "type": "Numeric & Mathematical", "text": "\nReturn the value of the (natural) exponential function `e**x` at the given\nnumber. The result is correctly rounded using the `ROUND_HALF_EVEN` rounding\nmode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.fma()", "path": "library/decimal#decimal.Decimal.fma", "type": "Numeric & Mathematical", "text": "\nFused multiply-add. Return self*other+third with no rounding of the\nintermediate product self*other.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.from_float()", "path": "library/decimal#decimal.Decimal.from_float", "type": "Numeric & Mathematical", "text": "\nClassmethod that converts a float to a decimal number, exactly.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.is_canonical()", "path": "library/decimal#decimal.Decimal.is_canonical", "type": "Numeric & Mathematical", "text": "\nReturn `True` if the argument is canonical and `False` otherwise. Currently, a\n`Decimal` instance is always canonical, so this operation always returns\n`True`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.is_finite()", "path": "library/decimal#decimal.Decimal.is_finite", "type": "Numeric & Mathematical", "text": "\nReturn `True` if the argument is a finite number, and `False` if the argument\nis an infinity or a NaN.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.is_infinite()", "path": "library/decimal#decimal.Decimal.is_infinite", "type": "Numeric & Mathematical", "text": "\nReturn `True` if the argument is either positive or negative infinity and\n`False` otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.is_nan()", "path": "library/decimal#decimal.Decimal.is_nan", "type": "Numeric & Mathematical", "text": "\nReturn `True` if the argument is a (quiet or signaling) NaN and `False`\notherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.is_normal()", "path": "library/decimal#decimal.Decimal.is_normal", "type": "Numeric & Mathematical", "text": "\nReturn `True` if the argument is a normal finite number. Return `False` if the\nargument is zero, subnormal, infinite or a NaN.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.is_qnan()", "path": "library/decimal#decimal.Decimal.is_qnan", "type": "Numeric & Mathematical", "text": "\nReturn `True` if the argument is a quiet NaN, and `False` otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.is_signed()", "path": "library/decimal#decimal.Decimal.is_signed", "type": "Numeric & Mathematical", "text": "\nReturn `True` if the argument has a negative sign and `False` otherwise. Note\nthat zeros and NaNs can both carry signs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.is_snan()", "path": "library/decimal#decimal.Decimal.is_snan", "type": "Numeric & Mathematical", "text": "\nReturn `True` if the argument is a signaling NaN and `False` otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.is_subnormal()", "path": "library/decimal#decimal.Decimal.is_subnormal", "type": "Numeric & Mathematical", "text": "\nReturn `True` if the argument is subnormal, and `False` otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.is_zero()", "path": "library/decimal#decimal.Decimal.is_zero", "type": "Numeric & Mathematical", "text": "\nReturn `True` if the argument is a (positive or negative) zero and `False`\notherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.ln()", "path": "library/decimal#decimal.Decimal.ln", "type": "Numeric & Mathematical", "text": "\nReturn the natural (base e) logarithm of the operand. The result is correctly\nrounded using the `ROUND_HALF_EVEN` rounding mode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.log10()", "path": "library/decimal#decimal.Decimal.log10", "type": "Numeric & Mathematical", "text": "\nReturn the base ten logarithm of the operand. The result is correctly rounded\nusing the `ROUND_HALF_EVEN` rounding mode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.logb()", "path": "library/decimal#decimal.Decimal.logb", "type": "Numeric & Mathematical", "text": "\nFor a nonzero number, return the adjusted exponent of its operand as a\n`Decimal` instance. If the operand is a zero then `Decimal('-Infinity')` is\nreturned and the `DivisionByZero` flag is raised. If the operand is an\ninfinity then `Decimal('Infinity')` is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.logical_and()", "path": "library/decimal#decimal.Decimal.logical_and", "type": "Numeric & Mathematical", "text": "\n`logical_and()` is a logical operation which takes two logical operands (see\nLogical operands). The result is the digit-wise `and` of the two operands.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.logical_invert()", "path": "library/decimal#decimal.Decimal.logical_invert", "type": "Numeric & Mathematical", "text": "\n`logical_invert()` is a logical operation. The result is the digit-wise\ninversion of the operand.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.logical_or()", "path": "library/decimal#decimal.Decimal.logical_or", "type": "Numeric & Mathematical", "text": "\n`logical_or()` is a logical operation which takes two logical operands (see\nLogical operands). The result is the digit-wise `or` of the two operands.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.logical_xor()", "path": "library/decimal#decimal.Decimal.logical_xor", "type": "Numeric & Mathematical", "text": "\n`logical_xor()` is a logical operation which takes two logical operands (see\nLogical operands). The result is the digit-wise exclusive or of the two\noperands.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.max()", "path": "library/decimal#decimal.Decimal.max", "type": "Numeric & Mathematical", "text": "\nLike `max(self, other)` except that the context rounding rule is applied\nbefore returning and that `NaN` values are either signaled or ignored\n(depending on the context and whether they are signaling or quiet).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.max_mag()", "path": "library/decimal#decimal.Decimal.max_mag", "type": "Numeric & Mathematical", "text": "\nSimilar to the `max()` method, but the comparison is done using the absolute\nvalues of the operands.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.min()", "path": "library/decimal#decimal.Decimal.min", "type": "Numeric & Mathematical", "text": "\nLike `min(self, other)` except that the context rounding rule is applied\nbefore returning and that `NaN` values are either signaled or ignored\n(depending on the context and whether they are signaling or quiet).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.min_mag()", "path": "library/decimal#decimal.Decimal.min_mag", "type": "Numeric & Mathematical", "text": "\nSimilar to the `min()` method, but the comparison is done using the absolute\nvalues of the operands.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.next_minus()", "path": "library/decimal#decimal.Decimal.next_minus", "type": "Numeric & Mathematical", "text": "\nReturn the largest number representable in the given context (or in the\ncurrent thread\u2019s context if no context is given) that is smaller than the\ngiven operand.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.next_plus()", "path": "library/decimal#decimal.Decimal.next_plus", "type": "Numeric & Mathematical", "text": "\nReturn the smallest number representable in the given context (or in the\ncurrent thread\u2019s context if no context is given) that is larger than the given\noperand.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.next_toward()", "path": "library/decimal#decimal.Decimal.next_toward", "type": "Numeric & Mathematical", "text": "\nIf the two operands are unequal, return the number closest to the first\noperand in the direction of the second operand. If both operands are\nnumerically equal, return a copy of the first operand with the sign set to be\nthe same as the sign of the second operand.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.normalize()", "path": "library/decimal#decimal.Decimal.normalize", "type": "Numeric & Mathematical", "text": "\nNormalize the number by stripping the rightmost trailing zeros and converting\nany result equal to `Decimal('0')` to `Decimal('0e0')`. Used for producing\ncanonical values for attributes of an equivalence class. For example,\n`Decimal('32.100')` and `Decimal('0.321000e+2')` both normalize to the\nequivalent value `Decimal('32.1')`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.number_class()", "path": "library/decimal#decimal.Decimal.number_class", "type": "Numeric & Mathematical", "text": "\nReturn a string describing the class of the operand. The returned value is one\nof the following ten strings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.quantize()", "path": "library/decimal#decimal.Decimal.quantize", "type": "Numeric & Mathematical", "text": "\nReturn a value equal to the first operand after rounding and having the\nexponent of the second operand.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.radix()", "path": "library/decimal#decimal.Decimal.radix", "type": "Numeric & Mathematical", "text": "\nReturn `Decimal(10)`, the radix (base) in which the `Decimal` class does all\nits arithmetic. Included for compatibility with the specification.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.remainder_near()", "path": "library/decimal#decimal.Decimal.remainder_near", "type": "Numeric & Mathematical", "text": "\nReturn the remainder from dividing self by other. This differs from `self %\nother` in that the sign of the remainder is chosen so as to minimize its\nabsolute value. More precisely, the return value is `self - n * other` where\n`n` is the integer nearest to the exact value of `self / other`, and if two\nintegers are equally near then the even one is chosen.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.rotate()", "path": "library/decimal#decimal.Decimal.rotate", "type": "Numeric & Mathematical", "text": "\nReturn the result of rotating the digits of the first operand by an amount\nspecified by the second operand. The second operand must be an integer in the\nrange -precision through precision. The absolute value of the second operand\ngives the number of places to rotate. If the second operand is positive then\nrotation is to the left; otherwise rotation is to the right. The coefficient\nof the first operand is padded on the left with zeros to length precision if\nnecessary. The sign and exponent of the first operand are unchanged.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.same_quantum()", "path": "library/decimal#decimal.Decimal.same_quantum", "type": "Numeric & Mathematical", "text": "\nTest whether self and other have the same exponent or whether both are `NaN`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.scaleb()", "path": "library/decimal#decimal.Decimal.scaleb", "type": "Numeric & Mathematical", "text": "\nReturn the first operand with exponent adjusted by the second. Equivalently,\nreturn the first operand multiplied by `10**other`. The second operand must be\nan integer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.shift()", "path": "library/decimal#decimal.Decimal.shift", "type": "Numeric & Mathematical", "text": "\nReturn the result of shifting the digits of the first operand by an amount\nspecified by the second operand. The second operand must be an integer in the\nrange -precision through precision. The absolute value of the second operand\ngives the number of places to shift. If the second operand is positive then\nthe shift is to the left; otherwise the shift is to the right. Digits shifted\ninto the coefficient are zeros. The sign and exponent of the first operand are\nunchanged.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.sqrt()", "path": "library/decimal#decimal.Decimal.sqrt", "type": "Numeric & Mathematical", "text": "\nReturn the square root of the argument to full precision.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.to_eng_string()", "path": "library/decimal#decimal.Decimal.to_eng_string", "type": "Numeric & Mathematical", "text": "\nConvert to a string, using engineering notation if an exponent is needed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.to_integral()", "path": "library/decimal#decimal.Decimal.to_integral", "type": "Numeric & Mathematical", "text": "\nIdentical to the `to_integral_value()` method. The `to_integral` name has been\nkept for compatibility with older versions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.to_integral_exact()", "path": "library/decimal#decimal.Decimal.to_integral_exact", "type": "Numeric & Mathematical", "text": "\nRound to the nearest integer, signaling `Inexact` or `Rounded` as appropriate\nif rounding occurs. The rounding mode is determined by the `rounding`\nparameter if given, else by the given `context`. If neither parameter is given\nthen the rounding mode of the current context is used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Decimal.to_integral_value()", "path": "library/decimal#decimal.Decimal.to_integral_value", "type": "Numeric & Mathematical", "text": "\nRound to the nearest integer without signaling `Inexact` or `Rounded`. If\ngiven, applies rounding; otherwise, uses the rounding method in either the\nsupplied context or the current context.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.DecimalException", "path": "library/decimal#decimal.DecimalException", "type": "Numeric & Mathematical", "text": "\nBase class for other signals and a subclass of `ArithmeticError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.DefaultContext", "path": "library/decimal#decimal.DefaultContext", "type": "Numeric & Mathematical", "text": "\nThis context is used by the `Context` constructor as a prototype for new\ncontexts. Changing a field (such a precision) has the effect of changing the\ndefault for new contexts created by the `Context` constructor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.DivisionByZero", "path": "library/decimal#decimal.DivisionByZero", "type": "Numeric & Mathematical", "text": "\nSignals the division of a non-infinite number by zero.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.ExtendedContext", "path": "library/decimal#decimal.ExtendedContext", "type": "Numeric & Mathematical", "text": "\nThis is a standard context defined by the General Decimal Arithmetic\nSpecification. Precision is set to nine. Rounding is set to `ROUND_HALF_EVEN`.\nAll flags are cleared. No traps are enabled (so that exceptions are not raised\nduring computations).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.FloatOperation", "path": "library/decimal#decimal.FloatOperation", "type": "Numeric & Mathematical", "text": "\nEnable stricter semantics for mixing floats and Decimals.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.getcontext()", "path": "library/decimal#decimal.getcontext", "type": "Numeric & Mathematical", "text": "\nReturn the current context for the active thread.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.HAVE_CONTEXTVAR", "path": "library/decimal#decimal.HAVE_CONTEXTVAR", "type": "Numeric & Mathematical", "text": "\nThe default value is `True`. If Python is compiled `--without-decimal-\ncontextvar`, the C version uses a thread-local rather than a coroutine-local\ncontext and the value is `False`. This is slightly faster in some nested\ncontext scenarios.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.HAVE_THREADS", "path": "library/decimal#decimal.HAVE_THREADS", "type": "Numeric & Mathematical", "text": "\nThe value is `True`. Deprecated, because Python now always has threads.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Inexact", "path": "library/decimal#decimal.Inexact", "type": "Numeric & Mathematical", "text": "\nIndicates that rounding occurred and the result is not exact.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.InvalidOperation", "path": "library/decimal#decimal.InvalidOperation", "type": "Numeric & Mathematical", "text": "\nAn invalid operation was performed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.localcontext()", "path": "library/decimal#decimal.localcontext", "type": "Numeric & Mathematical", "text": "\nReturn a context manager that will set the current context for the active\nthread to a copy of ctx on entry to the with-statement and restore the\nprevious context when exiting the with-statement. If no context is specified,\na copy of the current context is used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.MAX_EMAX", "path": "library/decimal#decimal.MAX_EMAX", "type": "Numeric & Mathematical", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.MAX_PREC", "path": "library/decimal#decimal.MAX_PREC", "type": "Numeric & Mathematical", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.MIN_EMIN", "path": "library/decimal#decimal.MIN_EMIN", "type": "Numeric & Mathematical", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.MIN_ETINY", "path": "library/decimal#decimal.MIN_ETINY", "type": "Numeric & Mathematical", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Overflow", "path": "library/decimal#decimal.Overflow", "type": "Numeric & Mathematical", "text": "\nNumerical overflow.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Rounded", "path": "library/decimal#decimal.Rounded", "type": "Numeric & Mathematical", "text": "\nRounding occurred though possibly no information was lost.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.ROUND_05UP", "path": "library/decimal#decimal.ROUND_05UP", "type": "Numeric & Mathematical", "text": "\nRound away from zero if last digit after rounding towards zero would have been\n0 or 5; otherwise round towards zero.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.ROUND_CEILING", "path": "library/decimal#decimal.ROUND_CEILING", "type": "Numeric & Mathematical", "text": "\nRound towards `Infinity`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.ROUND_DOWN", "path": "library/decimal#decimal.ROUND_DOWN", "type": "Numeric & Mathematical", "text": "\nRound towards zero.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.ROUND_FLOOR", "path": "library/decimal#decimal.ROUND_FLOOR", "type": "Numeric & Mathematical", "text": "\nRound towards `-Infinity`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.ROUND_HALF_DOWN", "path": "library/decimal#decimal.ROUND_HALF_DOWN", "type": "Numeric & Mathematical", "text": "\nRound to nearest with ties going towards zero.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.ROUND_HALF_EVEN", "path": "library/decimal#decimal.ROUND_HALF_EVEN", "type": "Numeric & Mathematical", "text": "\nRound to nearest with ties going to nearest even integer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.ROUND_HALF_UP", "path": "library/decimal#decimal.ROUND_HALF_UP", "type": "Numeric & Mathematical", "text": "\nRound to nearest with ties going away from zero.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.ROUND_UP", "path": "library/decimal#decimal.ROUND_UP", "type": "Numeric & Mathematical", "text": "\nRound away from zero.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.setcontext()", "path": "library/decimal#decimal.setcontext", "type": "Numeric & Mathematical", "text": "\nSet the current context for the active thread to c.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Subnormal", "path": "library/decimal#decimal.Subnormal", "type": "Numeric & Mathematical", "text": "\nExponent was lower than `Emin` prior to rounding.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "decimal.Underflow", "path": "library/decimal#decimal.Underflow", "type": "Numeric & Mathematical", "text": "\nNumerical underflow with result rounded to zero.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "definition.__name__", "path": "library/stdtypes#definition.__name__", "type": "Built-in Types", "text": "\nThe name of the class, function, method, descriptor, or generator instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "definition.__qualname__", "path": "library/stdtypes#definition.__qualname__", "type": "Built-in Types", "text": "\nThe qualified name of the class, function, method, descriptor, or generator\ninstance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "delattr()", "path": "library/functions#delattr", "type": "Built-in Functions", "text": "\nThis is a relative of `setattr()`. The arguments are an object and a string.\nThe string must be the name of one of the object\u2019s attributes. The function\ndeletes the named attribute, provided the object allows it. For example,\n`delattr(x, 'foobar')` is equivalent to `del x.foobar`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "DeprecationWarning", "path": "library/exceptions#DeprecationWarning", "type": "Built-in Exceptions", "text": "\nBase class for warnings about deprecated features when those warnings are\nintended for other Python developers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Developing with asyncio", "path": "library/asyncio-dev", "type": "Asynchronous I/O", "text": "\nAsynchronous programming is different from classic \u201csequential\u201d programming.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dict", "path": "library/functions#dict", "type": "Built-in Functions", "text": "\nCreate a new dictionary. The `dict` object is the dictionary class. See `dict`\nand Mapping Types \u2014 dict for documentation about this class.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dict", "path": "library/stdtypes#dict", "type": "Built-in Types", "text": "\nReturn a new dictionary initialized from an optional positional argument and a\npossibly empty set of keyword arguments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dict.clear()", "path": "library/stdtypes#dict.clear", "type": "Built-in Types", "text": "\nRemove all items from the dictionary.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dict.copy()", "path": "library/stdtypes#dict.copy", "type": "Built-in Types", "text": "\nReturn a shallow copy of the dictionary.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dict.fromkeys()", "path": "library/stdtypes#dict.fromkeys", "type": "Built-in Types", "text": "\nCreate a new dictionary with keys from iterable and values set to value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dict.get()", "path": "library/stdtypes#dict.get", "type": "Built-in Types", "text": "\nReturn the value for key if key is in the dictionary, else default. If default\nis not given, it defaults to `None`, so that this method never raises a\n`KeyError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dict.items()", "path": "library/stdtypes#dict.items", "type": "Built-in Types", "text": "\nReturn a new view of the dictionary\u2019s items (`(key, value)` pairs). See the\ndocumentation of view objects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dict.keys()", "path": "library/stdtypes#dict.keys", "type": "Built-in Types", "text": "\nReturn a new view of the dictionary\u2019s keys. See the documentation of view\nobjects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dict.pop()", "path": "library/stdtypes#dict.pop", "type": "Built-in Types", "text": "\nIf key is in the dictionary, remove it and return its value, else return\ndefault. If default is not given and key is not in the dictionary, a\n`KeyError` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dict.popitem()", "path": "library/stdtypes#dict.popitem", "type": "Built-in Types", "text": "\nRemove and return a `(key, value)` pair from the dictionary. Pairs are\nreturned in LIFO order.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dict.setdefault()", "path": "library/stdtypes#dict.setdefault", "type": "Built-in Types", "text": "\nIf key is in the dictionary, return its value. If not, insert key with a value\nof default and return default. default defaults to `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dict.update()", "path": "library/stdtypes#dict.update", "type": "Built-in Types", "text": "\nUpdate the dictionary with the key/value pairs from other, overwriting\nexisting keys. Return `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dict.values()", "path": "library/stdtypes#dict.values", "type": "Built-in Types", "text": "\nReturn a new view of the dictionary\u2019s values. See the documentation of view\nobjects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib", "path": "library/difflib", "type": "Text Processing", "text": "\nSource code: Lib/difflib.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.context_diff()", "path": "library/difflib#difflib.context_diff", "type": "Text Processing", "text": "\nCompare a and b (lists of strings); return a delta (a generator generating the\ndelta lines) in context diff format.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.Differ", "path": "library/difflib#difflib.Differ", "type": "Text Processing", "text": "\nThis is a class for comparing sequences of lines of text, and producing human-\nreadable differences or deltas. Differ uses `SequenceMatcher` both to compare\nsequences of lines, and to compare sequences of characters within similar\n(near-matching) lines.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.Differ.compare()", "path": "library/difflib#difflib.Differ.compare", "type": "Text Processing", "text": "\nCompare two sequences of lines, and generate the delta (a sequence of lines).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.diff_bytes()", "path": "library/difflib#difflib.diff_bytes", "type": "Text Processing", "text": "\nCompare a and b (lists of bytes objects) using dfunc; yield a sequence of\ndelta lines (also bytes) in the format returned by dfunc. dfunc must be a\ncallable, typically either `unified_diff()` or `context_diff()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.get_close_matches()", "path": "library/difflib#difflib.get_close_matches", "type": "Text Processing", "text": "\nReturn a list of the best \u201cgood enough\u201d matches. word is a sequence for which\nclose matches are desired (typically a string), and possibilities is a list of\nsequences against which to match word (typically a list of strings).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.HtmlDiff", "path": "library/difflib#difflib.HtmlDiff", "type": "Text Processing", "text": "\nThis class can be used to create an HTML table (or a complete HTML file\ncontaining the table) showing a side by side, line by line comparison of text\nwith inter-line and intra-line change highlights. The table can be generated\nin either full or contextual difference mode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.HtmlDiff.make_file()", "path": "library/difflib#difflib.HtmlDiff.make_file", "type": "Text Processing", "text": "\nCompares fromlines and tolines (lists of strings) and returns a string which\nis a complete HTML file containing a table showing line by line differences\nwith inter-line and intra-line changes highlighted.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.HtmlDiff.make_table()", "path": "library/difflib#difflib.HtmlDiff.make_table", "type": "Text Processing", "text": "\nCompares fromlines and tolines (lists of strings) and returns a string which\nis a complete HTML table showing line by line differences with inter-line and\nintra-line changes highlighted.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.HtmlDiff.__init__()", "path": "library/difflib#difflib.HtmlDiff.__init__", "type": "Text Processing", "text": "\nInitializes instance of `HtmlDiff`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.IS_CHARACTER_JUNK()", "path": "library/difflib#difflib.IS_CHARACTER_JUNK", "type": "Text Processing", "text": "\nReturn `True` for ignorable characters. The character ch is ignorable if ch is\na space or tab, otherwise it is not ignorable. Used as a default for parameter\ncharjunk in `ndiff()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.IS_LINE_JUNK()", "path": "library/difflib#difflib.IS_LINE_JUNK", "type": "Text Processing", "text": "\nReturn `True` for ignorable lines. The line line is ignorable if line is blank\nor contains a single `'#'`, otherwise it is not ignorable. Used as a default\nfor parameter linejunk in `ndiff()` in older versions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.ndiff()", "path": "library/difflib#difflib.ndiff", "type": "Text Processing", "text": "\nCompare a and b (lists of strings); return a `Differ`-style delta (a generator\ngenerating the delta lines).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.restore()", "path": "library/difflib#difflib.restore", "type": "Text Processing", "text": "\nReturn one of the two sequences that generated a delta.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.SequenceMatcher", "path": "library/difflib#difflib.SequenceMatcher", "type": "Text Processing", "text": "\nOptional argument isjunk must be `None` (the default) or a one-argument\nfunction that takes a sequence element and returns true if and only if the\nelement is \u201cjunk\u201d and should be ignored. Passing `None` for isjunk is\nequivalent to passing `lambda x: False`; in other words, no elements are\nignored. For example, pass:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.SequenceMatcher.find_longest_match()", "path": "library/difflib#difflib.SequenceMatcher.find_longest_match", "type": "Text Processing", "text": "\nFind longest matching block in `a[alo:ahi]` and `b[blo:bhi]`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.SequenceMatcher.get_grouped_opcodes()", "path": "library/difflib#difflib.SequenceMatcher.get_grouped_opcodes", "type": "Text Processing", "text": "\nReturn a generator of groups with up to n lines of context.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.SequenceMatcher.get_matching_blocks()", "path": "library/difflib#difflib.SequenceMatcher.get_matching_blocks", "type": "Text Processing", "text": "\nReturn list of triples describing non-overlapping matching subsequences. Each\ntriple is of the form `(i, j, n)`, and means that `a[i:i+n] == b[j:j+n]`. The\ntriples are monotonically increasing in i and j.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.SequenceMatcher.get_opcodes()", "path": "library/difflib#difflib.SequenceMatcher.get_opcodes", "type": "Text Processing", "text": "\nReturn list of 5-tuples describing how to turn a into b. Each tuple is of the\nform `(tag, i1, i2, j1, j2)`. The first tuple has `i1 == j1 == 0`, and\nremaining tuples have i1 equal to the i2 from the preceding tuple, and,\nlikewise, j1 equal to the previous j2.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.SequenceMatcher.quick_ratio()", "path": "library/difflib#difflib.SequenceMatcher.quick_ratio", "type": "Text Processing", "text": "\nReturn an upper bound on `ratio()` relatively quickly.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.SequenceMatcher.ratio()", "path": "library/difflib#difflib.SequenceMatcher.ratio", "type": "Text Processing", "text": "\nReturn a measure of the sequences\u2019 similarity as a float in the range [0, 1].\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.SequenceMatcher.real_quick_ratio()", "path": "library/difflib#difflib.SequenceMatcher.real_quick_ratio", "type": "Text Processing", "text": "\nReturn an upper bound on `ratio()` very quickly.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.SequenceMatcher.set_seq1()", "path": "library/difflib#difflib.SequenceMatcher.set_seq1", "type": "Text Processing", "text": "\nSet the first sequence to be compared. The second sequence to be compared is\nnot changed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.SequenceMatcher.set_seq2()", "path": "library/difflib#difflib.SequenceMatcher.set_seq2", "type": "Text Processing", "text": "\nSet the second sequence to be compared. The first sequence to be compared is\nnot changed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.SequenceMatcher.set_seqs()", "path": "library/difflib#difflib.SequenceMatcher.set_seqs", "type": "Text Processing", "text": "\nSet the two sequences to be compared.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "difflib.unified_diff()", "path": "library/difflib#difflib.unified_diff", "type": "Text Processing", "text": "\nCompare a and b (lists of strings); return a delta (a generator generating the\ndelta lines) in unified diff format.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dir()", "path": "library/functions#dir", "type": "Built-in Functions", "text": "\nWithout arguments, return the list of names in the current local scope. With\nan argument, attempt to return a list of valid attributes for that object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis", "path": "library/dis", "type": "Language", "text": "\nSource code: Lib/dis.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.Bytecode", "path": "library/dis#dis.Bytecode", "type": "Language", "text": "\nAnalyse the bytecode corresponding to a function, generator, asynchronous\ngenerator, coroutine, method, string of source code, or a code object (as\nreturned by `compile()`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.Bytecode.codeobj", "path": "library/dis#dis.Bytecode.codeobj", "type": "Language", "text": "\nThe compiled code object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.Bytecode.dis()", "path": "library/dis#dis.Bytecode.dis", "type": "Language", "text": "\nReturn a formatted view of the bytecode operations (the same as printed by\n`dis.dis()`, but returned as a multi-line string).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.Bytecode.first_line", "path": "library/dis#dis.Bytecode.first_line", "type": "Language", "text": "\nThe first source line of the code object (if available)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.Bytecode.from_traceback()", "path": "library/dis#dis.Bytecode.from_traceback", "type": "Language", "text": "\nConstruct a `Bytecode` instance from the given traceback, setting\ncurrent_offset to the instruction responsible for the exception.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.Bytecode.info()", "path": "library/dis#dis.Bytecode.info", "type": "Language", "text": "\nReturn a formatted multi-line string with detailed information about the code\nobject, like `code_info()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.cmp_op", "path": "library/dis#dis.cmp_op", "type": "Language", "text": "\nSequence of all compare operation names.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.code_info()", "path": "library/dis#dis.code_info", "type": "Language", "text": "\nReturn a formatted multi-line string with detailed code object information for\nthe supplied function, generator, asynchronous generator, coroutine, method,\nsource code string or code object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.dis()", "path": "library/dis#dis.dis", "type": "Language", "text": "\nDisassemble the x object. x can denote either a module, a class, a method, a\nfunction, a generator, an asynchronous generator, a coroutine, a code object,\na string of source code or a byte sequence of raw bytecode. For a module, it\ndisassembles all functions. For a class, it disassembles all methods\n(including class and static methods). For a code object or sequence of raw\nbytecode, it prints one line per bytecode instruction. It also recursively\ndisassembles nested code objects (the code of comprehensions, generator\nexpressions and nested functions, and the code used for building nested\nclasses). Strings are first compiled to code objects with the `compile()`\nbuilt-in function before being disassembled. If no object is provided, this\nfunction disassembles the last traceback.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.disassemble()", "path": "library/dis#dis.disassemble", "type": "Language", "text": "\nDisassemble a code object, indicating the last instruction if lasti was\nprovided. The output is divided in the following columns:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.disco()", "path": "library/dis#dis.disco", "type": "Language", "text": "\nDisassemble a code object, indicating the last instruction if lasti was\nprovided. The output is divided in the following columns:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.distb()", "path": "library/dis#dis.distb", "type": "Language", "text": "\nDisassemble the top-of-stack function of a traceback, using the last traceback\nif none was passed. The instruction causing the exception is indicated.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.findlabels()", "path": "library/dis#dis.findlabels", "type": "Language", "text": "\nDetect all offsets in the raw compiled bytecode string code which are jump\ntargets, and return a list of these offsets.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.findlinestarts()", "path": "library/dis#dis.findlinestarts", "type": "Language", "text": "\nThis generator function uses the `co_firstlineno` and `co_lnotab` attributes\nof the code object code to find the offsets which are starts of lines in the\nsource code. They are generated as `(offset, lineno)` pairs. See\nObjects/lnotab_notes.txt for the `co_lnotab` format and how to decode it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.get_instructions()", "path": "library/dis#dis.get_instructions", "type": "Language", "text": "\nReturn an iterator over the instructions in the supplied function, method,\nsource code string or code object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.hascompare", "path": "library/dis#dis.hascompare", "type": "Language", "text": "\nSequence of bytecodes of Boolean operations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.hasconst", "path": "library/dis#dis.hasconst", "type": "Language", "text": "\nSequence of bytecodes that access a constant.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.hasfree", "path": "library/dis#dis.hasfree", "type": "Language", "text": "\nSequence of bytecodes that access a free variable (note that \u2018free\u2019 in this\ncontext refers to names in the current scope that are referenced by inner\nscopes or names in outer scopes that are referenced from this scope. It does\nnot include references to global or builtin scopes).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.hasjabs", "path": "library/dis#dis.hasjabs", "type": "Language", "text": "\nSequence of bytecodes that have an absolute jump target.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.hasjrel", "path": "library/dis#dis.hasjrel", "type": "Language", "text": "\nSequence of bytecodes that have a relative jump target.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.haslocal", "path": "library/dis#dis.haslocal", "type": "Language", "text": "\nSequence of bytecodes that access a local variable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.hasname", "path": "library/dis#dis.hasname", "type": "Language", "text": "\nSequence of bytecodes that access an attribute by name.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.Instruction", "path": "library/dis#dis.Instruction", "type": "Language", "text": "\nDetails for a bytecode operation\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.Instruction.arg", "path": "library/dis#dis.Instruction.arg", "type": "Language", "text": "\nnumeric argument to operation (if any), otherwise `None`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.Instruction.argrepr", "path": "library/dis#dis.Instruction.argrepr", "type": "Language", "text": "\nhuman readable description of operation argument\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.Instruction.argval", "path": "library/dis#dis.Instruction.argval", "type": "Language", "text": "\nresolved arg value (if known), otherwise same as arg\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.Instruction.is_jump_target", "path": "library/dis#dis.Instruction.is_jump_target", "type": "Language", "text": "\n`True` if other code jumps to here, otherwise `False`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.Instruction.offset", "path": "library/dis#dis.Instruction.offset", "type": "Language", "text": "\nstart index of operation within bytecode sequence\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.Instruction.opcode", "path": "library/dis#dis.Instruction.opcode", "type": "Language", "text": "\nnumeric code for operation, corresponding to the opcode values listed below\nand the bytecode values in the Opcode collections.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.Instruction.opname", "path": "library/dis#dis.Instruction.opname", "type": "Language", "text": "\nhuman readable name for operation\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.Instruction.starts_line", "path": "library/dis#dis.Instruction.starts_line", "type": "Language", "text": "\nline started by this opcode (if any), otherwise `None`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.opmap", "path": "library/dis#dis.opmap", "type": "Language", "text": "\nDictionary mapping operation names to bytecodes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.opname", "path": "library/dis#dis.opname", "type": "Language", "text": "\nSequence of operation names, indexable using the bytecode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.show_code()", "path": "library/dis#dis.show_code", "type": "Language", "text": "\nPrint detailed code object information for the supplied function, method,\nsource code string or code object to file (or `sys.stdout` if file is not\nspecified).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dis.stack_effect()", "path": "library/dis#dis.stack_effect", "type": "Language", "text": "\nCompute the stack effect of opcode with argument oparg.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "distutils", "path": "library/distutils", "type": "Software Packaging & Distribution", "text": "\nThe `distutils` package provides support for building and installing\nadditional modules into a Python installation. The new modules may be either\n100%-pure Python, or may be extension modules written in C, or may be\ncollections of Python packages which include modules coded in both Python and\nC.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "divmod()", "path": "library/functions#divmod", "type": "Built-in Functions", "text": "\nTake two (non complex) numbers as arguments and return a pair of numbers\nconsisting of their quotient and remainder when using integer division. With\nmixed operand types, the rules for binary arithmetic operators apply. For\nintegers, the result is the same as `(a // b, a % b)`. For floating point\nnumbers the result is `(q, a % b)`, where q is usually `math.floor(a / b)` but\nmay be 1 less than that. In any case `q * b + a % b` is very close to a, if `a\n% b` is non-zero it has the same sign as b, and `0 <= abs(a % b) < abs(b)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest", "path": "library/doctest", "type": "Development Tools", "text": "\nSource code: Lib/doctest.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.COMPARISON_FLAGS", "path": "library/doctest#doctest.COMPARISON_FLAGS", "type": "Development Tools", "text": "\nA bitmask or\u2019ing together all the comparison flags above.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.debug()", "path": "library/doctest#doctest.debug", "type": "Development Tools", "text": "\nDebug the doctests for an object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DebugRunner", "path": "library/doctest#doctest.DebugRunner", "type": "Development Tools", "text": "\nA subclass of `DocTestRunner` that raises an exception as soon as a failure is\nencountered. If an unexpected exception occurs, an `UnexpectedException`\nexception is raised, containing the test, the example, and the original\nexception. If the output doesn\u2019t match, then a `DocTestFailure` exception is\nraised, containing the test, the example, and the actual output.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.debug_src()", "path": "library/doctest#doctest.debug_src", "type": "Development Tools", "text": "\nDebug the doctests in a string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocFileSuite()", "path": "library/doctest#doctest.DocFileSuite", "type": "Development Tools", "text": "\nConvert doctest tests from one or more text files to a `unittest.TestSuite`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTest", "path": "library/doctest#doctest.DocTest", "type": "Development Tools", "text": "\nA collection of doctest examples that should be run in a single namespace. The\nconstructor arguments are used to initialize the attributes of the same names.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTest.docstring", "path": "library/doctest#doctest.DocTest.docstring", "type": "Development Tools", "text": "\nThe string that the test was extracted from, or `None` if the string is\nunavailable, or if the test was not extracted from a string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTest.examples", "path": "library/doctest#doctest.DocTest.examples", "type": "Development Tools", "text": "\nA list of `Example` objects encoding the individual interactive Python\nexamples that should be run by this test.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTest.filename", "path": "library/doctest#doctest.DocTest.filename", "type": "Development Tools", "text": "\nThe name of the file that this `DocTest` was extracted from; or `None` if the\nfilename is unknown, or if the `DocTest` was not extracted from a file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTest.globs", "path": "library/doctest#doctest.DocTest.globs", "type": "Development Tools", "text": "\nThe namespace (aka globals) that the examples should be run in. This is a\ndictionary mapping names to values. Any changes to the namespace made by the\nexamples (such as binding new variables) will be reflected in `globs` after\nthe test is run.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTest.lineno", "path": "library/doctest#doctest.DocTest.lineno", "type": "Development Tools", "text": "\nThe line number within `filename` where this `DocTest` begins, or `None` if\nthe line number is unavailable. This line number is zero-based with respect to\nthe beginning of the file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTest.name", "path": "library/doctest#doctest.DocTest.name", "type": "Development Tools", "text": "\nA string name identifying the `DocTest`. Typically, this is the name of the\nobject or file that the test was extracted from.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTestFailure", "path": "library/doctest#doctest.DocTestFailure", "type": "Development Tools", "text": "\nAn exception raised by `DocTestRunner` to signal that a doctest example\u2019s\nactual output did not match its expected output. The constructor arguments are\nused to initialize the attributes of the same names.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTestFailure.example", "path": "library/doctest#doctest.DocTestFailure.example", "type": "Development Tools", "text": "\nThe `Example` that failed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTestFailure.got", "path": "library/doctest#doctest.DocTestFailure.got", "type": "Development Tools", "text": "\nThe example\u2019s actual output.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTestFailure.test", "path": "library/doctest#doctest.DocTestFailure.test", "type": "Development Tools", "text": "\nThe `DocTest` object that was being run when the example failed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTestFinder", "path": "library/doctest#doctest.DocTestFinder", "type": "Development Tools", "text": "\nA processing class used to extract the `DocTest`s that are relevant to a given\nobject, from its docstring and the docstrings of its contained objects.\n`DocTest`s can be extracted from modules, classes, functions, methods,\nstaticmethods, classmethods, and properties.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTestFinder.find()", "path": "library/doctest#doctest.DocTestFinder.find", "type": "Development Tools", "text": "\nReturn a list of the `DocTest`s that are defined by obj\u2019s docstring, or by any\nof its contained objects\u2019 docstrings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTestParser", "path": "library/doctest#doctest.DocTestParser", "type": "Development Tools", "text": "\nA processing class used to extract interactive examples from a string, and use\nthem to create a `DocTest` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTestParser.get_doctest()", "path": "library/doctest#doctest.DocTestParser.get_doctest", "type": "Development Tools", "text": "\nExtract all doctest examples from the given string, and collect them into a\n`DocTest` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTestParser.get_examples()", "path": "library/doctest#doctest.DocTestParser.get_examples", "type": "Development Tools", "text": "\nExtract all doctest examples from the given string, and return them as a list\nof `Example` objects. Line numbers are 0-based. The optional argument name is\na name identifying this string, and is only used for error messages.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTestParser.parse()", "path": "library/doctest#doctest.DocTestParser.parse", "type": "Development Tools", "text": "\nDivide the given string into examples and intervening text, and return them as\na list of alternating `Example`s and strings. Line numbers for the `Example`s\nare 0-based. The optional argument name is a name identifying this string, and\nis only used for error messages.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTestRunner", "path": "library/doctest#doctest.DocTestRunner", "type": "Development Tools", "text": "\nA processing class used to execute and verify the interactive examples in a\n`DocTest`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTestRunner.report_failure()", "path": "library/doctest#doctest.DocTestRunner.report_failure", "type": "Development Tools", "text": "\nReport that the given example failed. This method is provided to allow\nsubclasses of `DocTestRunner` to customize their output; it should not be\ncalled directly.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTestRunner.report_start()", "path": "library/doctest#doctest.DocTestRunner.report_start", "type": "Development Tools", "text": "\nReport that the test runner is about to process the given example. This method\nis provided to allow subclasses of `DocTestRunner` to customize their output;\nit should not be called directly.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTestRunner.report_success()", "path": "library/doctest#doctest.DocTestRunner.report_success", "type": "Development Tools", "text": "\nReport that the given example ran successfully. This method is provided to\nallow subclasses of `DocTestRunner` to customize their output; it should not\nbe called directly.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTestRunner.report_unexpected_exception()", "path": "library/doctest#doctest.DocTestRunner.report_unexpected_exception", "type": "Development Tools", "text": "\nReport that the given example raised an unexpected exception. This method is\nprovided to allow subclasses of `DocTestRunner` to customize their output; it\nshould not be called directly.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTestRunner.run()", "path": "library/doctest#doctest.DocTestRunner.run", "type": "Development Tools", "text": "\nRun the examples in test (a `DocTest` object), and display the results using\nthe writer function out.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTestRunner.summarize()", "path": "library/doctest#doctest.DocTestRunner.summarize", "type": "Development Tools", "text": "\nPrint a summary of all the test cases that have been run by this\nDocTestRunner, and return a named tuple `TestResults(failed, attempted)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DocTestSuite()", "path": "library/doctest#doctest.DocTestSuite", "type": "Development Tools", "text": "\nConvert doctest tests for a module to a `unittest.TestSuite`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DONT_ACCEPT_BLANKLINE", "path": "library/doctest#doctest.DONT_ACCEPT_BLANKLINE", "type": "Development Tools", "text": "\nBy default, if an expected output block contains a line containing only the\nstring `<BLANKLINE>`, then that line will match a blank line in the actual\noutput. Because a genuinely blank line delimits the expected output, this is\nthe only way to communicate that a blank line is expected. When\n`DONT_ACCEPT_BLANKLINE` is specified, this substitution is not allowed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.DONT_ACCEPT_TRUE_FOR_1", "path": "library/doctest#doctest.DONT_ACCEPT_TRUE_FOR_1", "type": "Development Tools", "text": "\nBy default, if an expected output block contains just `1`, an actual output\nblock containing just `1` or just `True` is considered to be a match, and\nsimilarly for `0` versus `False`. When `DONT_ACCEPT_TRUE_FOR_1` is specified,\nneither substitution is allowed. The default behavior caters to that Python\nchanged the return type of many functions from integer to boolean; doctests\nexpecting \u201clittle integer\u201d output still work in these cases. This option will\nprobably go away, but not for several years.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.ELLIPSIS", "path": "library/doctest#doctest.ELLIPSIS", "type": "Development Tools", "text": "\nWhen specified, an ellipsis marker (`...`) in the expected output can match\nany substring in the actual output. This includes substrings that span line\nboundaries, and empty substrings, so it\u2019s best to keep usage of this simple.\nComplicated uses can lead to the same kinds of \u201coops, it matched too much!\u201d\nsurprises that `.*` is prone to in regular expressions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.Example", "path": "library/doctest#doctest.Example", "type": "Development Tools", "text": "\nA single interactive example, consisting of a Python statement and its\nexpected output. The constructor arguments are used to initialize the\nattributes of the same names.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.Example.exc_msg", "path": "library/doctest#doctest.Example.exc_msg", "type": "Development Tools", "text": "\nThe exception message generated by the example, if the example is expected to\ngenerate an exception; or `None` if it is not expected to generate an\nexception. This exception message is compared against the return value of\n`traceback.format_exception_only()`. `exc_msg` ends with a newline unless it\u2019s\n`None`. The constructor adds a newline if needed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.Example.indent", "path": "library/doctest#doctest.Example.indent", "type": "Development Tools", "text": "\nThe example\u2019s indentation in the containing string, i.e., the number of space\ncharacters that precede the example\u2019s first prompt.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.Example.lineno", "path": "library/doctest#doctest.Example.lineno", "type": "Development Tools", "text": "\nThe line number within the string containing this example where the example\nbegins. This line number is zero-based with respect to the beginning of the\ncontaining string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.Example.options", "path": "library/doctest#doctest.Example.options", "type": "Development Tools", "text": "\nA dictionary mapping from option flags to `True` or `False`, which is used to\noverride default options for this example. Any option flags not contained in\nthis dictionary are left at their default value (as specified by the\n`DocTestRunner`\u2019s `optionflags`). By default, no options are set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.Example.source", "path": "library/doctest#doctest.Example.source", "type": "Development Tools", "text": "\nA string containing the example\u2019s source code. This source code consists of a\nsingle Python statement, and always ends with a newline; the constructor adds\na newline when necessary.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.Example.want", "path": "library/doctest#doctest.Example.want", "type": "Development Tools", "text": "\nThe expected output from running the example\u2019s source code (either from\nstdout, or a traceback in case of exception). `want` ends with a newline\nunless no output is expected, in which case it\u2019s an empty string. The\nconstructor adds a newline when necessary.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.FAIL_FAST", "path": "library/doctest#doctest.FAIL_FAST", "type": "Development Tools", "text": "\nWhen specified, exit after the first failing example and don\u2019t attempt to run\nthe remaining examples. Thus, the number of failures reported will be at most\n1. This flag may be useful during debugging, since examples after the first\nfailure won\u2019t even produce debugging output.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.IGNORE_EXCEPTION_DETAIL", "path": "library/doctest#doctest.IGNORE_EXCEPTION_DETAIL", "type": "Development Tools", "text": "\nWhen specified, an example that expects an exception passes if an exception of\nthe expected type is raised, even if the exception detail does not match. For\nexample, an example expecting `ValueError: 42` will pass if the actual\nexception raised is `ValueError: 3*14`, but will fail, e.g., if `TypeError` is\nraised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.NORMALIZE_WHITESPACE", "path": "library/doctest#doctest.NORMALIZE_WHITESPACE", "type": "Development Tools", "text": "\nWhen specified, all sequences of whitespace (blanks and newlines) are treated\nas equal. Any sequence of whitespace within the expected output will match any\nsequence of whitespace within the actual output. By default, whitespace must\nmatch exactly. `NORMALIZE_WHITESPACE` is especially useful when a line of\nexpected output is very long, and you want to wrap it across multiple lines in\nyour source.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.OutputChecker", "path": "library/doctest#doctest.OutputChecker", "type": "Development Tools", "text": "\nA class used to check the whether the actual output from a doctest example\nmatches the expected output. `OutputChecker` defines two methods:\n`check_output()`, which compares a given pair of outputs, and returns `True`\nif they match; and `output_difference()`, which returns a string describing\nthe differences between two outputs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.OutputChecker.check_output()", "path": "library/doctest#doctest.OutputChecker.check_output", "type": "Development Tools", "text": "\nReturn `True` iff the actual output from an example (got) matches the expected\noutput (want). These strings are always considered to match if they are\nidentical; but depending on what option flags the test runner is using,\nseveral non-exact match types are also possible. See section Option Flags for\nmore information about option flags.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.OutputChecker.output_difference()", "path": "library/doctest#doctest.OutputChecker.output_difference", "type": "Development Tools", "text": "\nReturn a string describing the differences between the expected output for a\ngiven example (example) and the actual output (got). optionflags is the set of\noption flags used to compare want and got.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.register_optionflag()", "path": "library/doctest#doctest.register_optionflag", "type": "Development Tools", "text": "\nCreate a new option flag with a given name, and return the new flag\u2019s integer\nvalue. `register_optionflag()` can be used when subclassing `OutputChecker` or\n`DocTestRunner` to create new options that are supported by your subclasses.\n`register_optionflag()` should always be called using the following idiom:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.REPORTING_FLAGS", "path": "library/doctest#doctest.REPORTING_FLAGS", "type": "Development Tools", "text": "\nA bitmask or\u2019ing together all the reporting flags above.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.REPORT_CDIFF", "path": "library/doctest#doctest.REPORT_CDIFF", "type": "Development Tools", "text": "\nWhen specified, failures that involve multi-line expected and actual outputs\nwill be displayed using a context diff.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.REPORT_NDIFF", "path": "library/doctest#doctest.REPORT_NDIFF", "type": "Development Tools", "text": "\nWhen specified, differences are computed by `difflib.Differ`, using the same\nalgorithm as the popular `ndiff.py` utility. This is the only method that\nmarks differences within lines as well as across lines. For example, if a line\nof expected output contains digit `1` where actual output contains letter `l`,\na line is inserted with a caret marking the mismatching column positions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.REPORT_ONLY_FIRST_FAILURE", "path": "library/doctest#doctest.REPORT_ONLY_FIRST_FAILURE", "type": "Development Tools", "text": "\nWhen specified, display the first failing example in each doctest, but\nsuppress output for all remaining examples. This will prevent doctest from\nreporting correct examples that break because of earlier failures; but it\nmight also hide incorrect examples that fail independently of the first\nfailure. When `REPORT_ONLY_FIRST_FAILURE` is specified, the remaining examples\nare still run, and still count towards the total number of failures reported;\nonly the output is suppressed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.REPORT_UDIFF", "path": "library/doctest#doctest.REPORT_UDIFF", "type": "Development Tools", "text": "\nWhen specified, failures that involve multi-line expected and actual outputs\nare displayed using a unified diff.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.run_docstring_examples()", "path": "library/doctest#doctest.run_docstring_examples", "type": "Development Tools", "text": "\nTest examples associated with object f; for example, f may be a string, a\nmodule, a function, or a class object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.script_from_examples()", "path": "library/doctest#doctest.script_from_examples", "type": "Development Tools", "text": "\nConvert text with examples to a script.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.set_unittest_reportflags()", "path": "library/doctest#doctest.set_unittest_reportflags", "type": "Development Tools", "text": "\nSet the `doctest` reporting flags to use.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.SKIP", "path": "library/doctest#doctest.SKIP", "type": "Development Tools", "text": "\nWhen specified, do not run the example at all. This can be useful in contexts\nwhere doctest examples serve as both documentation and test cases, and an\nexample should be included for documentation purposes, but should not be\nchecked. E.g., the example\u2019s output might be random; or the example might\ndepend on resources which would be unavailable to the test driver.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.testfile()", "path": "library/doctest#doctest.testfile", "type": "Development Tools", "text": "\nAll arguments except filename are optional, and should be specified in keyword\nform.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.testmod()", "path": "library/doctest#doctest.testmod", "type": "Development Tools", "text": "\nAll arguments are optional, and all except for m should be specified in\nkeyword form.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.testsource()", "path": "library/doctest#doctest.testsource", "type": "Development Tools", "text": "\nConvert the doctest for an object to a script.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.UnexpectedException", "path": "library/doctest#doctest.UnexpectedException", "type": "Development Tools", "text": "\nAn exception raised by `DocTestRunner` to signal that a doctest example raised\nan unexpected exception. The constructor arguments are used to initialize the\nattributes of the same names.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.UnexpectedException.example", "path": "library/doctest#doctest.UnexpectedException.example", "type": "Development Tools", "text": "\nThe `Example` that failed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.UnexpectedException.exc_info", "path": "library/doctest#doctest.UnexpectedException.exc_info", "type": "Development Tools", "text": "\nA tuple containing information about the unexpected exception, as returned by\n`sys.exc_info()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "doctest.UnexpectedException.test", "path": "library/doctest#doctest.UnexpectedException.test", "type": "Development Tools", "text": "\nThe `DocTest` object that was being run when the example failed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Ellipsis", "path": "library/constants#Ellipsis", "type": "Built-in Constants", "text": "\nThe same as the ellipsis literal \u201c`...`\u201d. Special value used mostly in\nconjunction with extended slicing syntax for user-defined container data\ntypes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email", "path": "library/email", "type": "Internet Data", "text": "\nSource code: Lib/email/__init__.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.charset.add_alias()", "path": "library/email.charset#email.charset.add_alias", "type": "Email", "text": "\nAdd a character set alias. alias is the alias name, e.g. `latin-1`. canonical\nis the character set\u2019s canonical name, e.g. `iso-8859-1`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.charset.add_charset()", "path": "library/email.charset#email.charset.add_charset", "type": "Email", "text": "\nAdd character properties to the global registry.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.charset.add_codec()", "path": "library/email.charset#email.charset.add_codec", "type": "Email", "text": "\nAdd a codec that map characters in the given character set to and from\nUnicode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.charset.Charset", "path": "library/email.charset#email.charset.Charset", "type": "Email", "text": "\nMap character sets to their email properties.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.charset.Charset.body_encode()", "path": "library/email.charset#email.charset.Charset.body_encode", "type": "Email", "text": "\nBody-encode the string string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.charset.Charset.body_encoding", "path": "library/email.charset#email.charset.Charset.body_encoding", "type": "Email", "text": "\nSame as header_encoding, but describes the encoding for the mail message\u2019s\nbody, which indeed may be different than the header encoding.\n`Charset.SHORTEST` is not allowed for body_encoding.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.charset.Charset.get_body_encoding()", "path": "library/email.charset#email.charset.Charset.get_body_encoding", "type": "Email", "text": "\nReturn the content transfer encoding used for body encoding.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.charset.Charset.get_output_charset()", "path": "library/email.charset#email.charset.Charset.get_output_charset", "type": "Email", "text": "\nReturn the output character set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.charset.Charset.header_encode()", "path": "library/email.charset#email.charset.Charset.header_encode", "type": "Email", "text": "\nHeader-encode the string string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.charset.Charset.header_encode_lines()", "path": "library/email.charset#email.charset.Charset.header_encode_lines", "type": "Email", "text": "\nHeader-encode a string by converting it first to bytes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.charset.Charset.header_encoding", "path": "library/email.charset#email.charset.Charset.header_encoding", "type": "Email", "text": "\nIf the character set must be encoded before it can be used in an email header,\nthis attribute will be set to `Charset.QP` (for quoted-printable),\n`Charset.BASE64` (for base64 encoding), or `Charset.SHORTEST` for the shortest\nof QP or BASE64 encoding. Otherwise, it will be `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.charset.Charset.input_charset", "path": "library/email.charset#email.charset.Charset.input_charset", "type": "Email", "text": "\nThe initial character set specified. Common aliases are converted to their\nofficial email names (e.g. `latin_1` is converted to `iso-8859-1`). Defaults\nto 7-bit `us-ascii`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.charset.Charset.input_codec", "path": "library/email.charset#email.charset.Charset.input_codec", "type": "Email", "text": "\nThe name of the Python codec used to convert the input_charset to Unicode. If\nno conversion codec is necessary, this attribute will be `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.charset.Charset.output_charset", "path": "library/email.charset#email.charset.Charset.output_charset", "type": "Email", "text": "\nSome character sets must be converted before they can be used in email headers\nor bodies. If the input_charset is one of them, this attribute will contain\nthe name of the character set output will be converted to. Otherwise, it will\nbe `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.charset.Charset.output_codec", "path": "library/email.charset#email.charset.Charset.output_codec", "type": "Email", "text": "\nThe name of the Python codec used to convert Unicode to the output_charset. If\nno conversion codec is necessary, this attribute will have the same value as\nthe input_codec.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.charset.Charset.__eq__()", "path": "library/email.charset#email.charset.Charset.__eq__", "type": "Email", "text": "\nThis method allows you to compare two `Charset` instances for equality.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.charset.Charset.__ne__()", "path": "library/email.charset#email.charset.Charset.__ne__", "type": "Email", "text": "\nThis method allows you to compare two `Charset` instances for inequality.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.charset.Charset.__str__()", "path": "library/email.charset#email.charset.Charset.__str__", "type": "Email", "text": "\nReturns input_charset as a string coerced to lower case. `__repr__()` is an\nalias for `__str__()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.charset: Representing character sets", "path": "library/email.charset", "type": "Email", "text": "\nSource code: Lib/email/charset.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.contentmanager.ContentManager", "path": "library/email.contentmanager#email.contentmanager.ContentManager", "type": "Email", "text": "\nBase class for content managers. Provides the standard registry mechanisms to\nregister converters between MIME content and other representations, as well as\nthe `get_content` and `set_content` dispatch methods.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.contentmanager.ContentManager.add_get_handler()", "path": "library/email.contentmanager#email.contentmanager.ContentManager.add_get_handler", "type": "Email", "text": "\nRecord the function handler as the handler for key. For the possible values of\nkey, see `get_content()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.contentmanager.ContentManager.add_set_handler()", "path": "library/email.contentmanager#email.contentmanager.ContentManager.add_set_handler", "type": "Email", "text": "\nRecord handler as the function to call when an object of a type matching\ntypekey is passed to `set_content()`. For the possible values of typekey, see\n`set_content()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.contentmanager.ContentManager.get_content()", "path": "library/email.contentmanager#email.contentmanager.ContentManager.get_content", "type": "Email", "text": "\nLook up a handler function based on the `mimetype` of msg (see next\nparagraph), call it, passing through all arguments, and return the result of\nthe call. The expectation is that the handler will extract the payload from\nmsg and return an object that encodes information about the extracted data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.contentmanager.ContentManager.set_content()", "path": "library/email.contentmanager#email.contentmanager.ContentManager.set_content", "type": "Email", "text": "\nIf the `maintype` is `multipart`, raise a `TypeError`; otherwise look up a\nhandler function based on the type of obj (see next paragraph), call\n`clear_content()` on the msg, and call the handler function, passing through\nall arguments. The expectation is that the handler will transform and store\nobj into msg, possibly making other changes to msg as well, such as adding\nvarious MIME headers to encode information needed to interpret the stored\ndata.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.contentmanager.get_content()", "path": "library/email.contentmanager#email.contentmanager.get_content", "type": "Email", "text": "\nReturn the payload of the part as either a string (for `text` parts), an\n`EmailMessage` object (for `message/rfc822` parts), or a `bytes` object (for\nall other non-multipart types). Raise a `KeyError` if called on a `multipart`.\nIf the part is a `text` part and errors is specified, use it as the error\nhandler when decoding the payload to unicode. The default error handler is\n`replace`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.contentmanager.raw_data_manager", "path": "library/email.contentmanager#email.contentmanager.raw_data_manager", "type": "Email", "text": "\nThis content manager provides only a minimum interface beyond that provided by\n`Message` itself: it deals only with text, raw byte strings, and `Message`\nobjects. Nevertheless, it provides significant advantages compared to the base\nAPI: `get_content` on a text part will return a unicode string without the\napplication needing to manually decode it, `set_content` provides a rich set\nof options for controlling the headers added to a part and controlling the\ncontent transfer encoding, and it enables the use of the various `add_`\nmethods, thereby simplifying the creation of multipart messages.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.contentmanager.set_content()", "path": "library/email.contentmanager#email.contentmanager.set_content", "type": "Email", "text": "\nAdd headers and payload to msg:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.contentmanager: Managing MIME Content", "path": "library/email.contentmanager", "type": "Email", "text": "\nSource code: Lib/email/contentmanager.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.encoders.encode_7or8bit()", "path": "library/email.encoders#email.encoders.encode_7or8bit", "type": "Email", "text": "\nThis doesn\u2019t actually modify the message\u2019s payload, but it does set the\nContent-Transfer-Encoding header to either `7bit` or `8bit` as appropriate,\nbased on the payload data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.encoders.encode_base64()", "path": "library/email.encoders#email.encoders.encode_base64", "type": "Email", "text": "\nEncodes the payload into base64 form and sets the Content-Transfer-Encoding\nheader to `base64`. This is a good encoding to use when most of your payload\nis unprintable data since it is a more compact form than quoted-printable. The\ndrawback of base64 encoding is that it renders the text non-human readable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.encoders.encode_noop()", "path": "library/email.encoders#email.encoders.encode_noop", "type": "Email", "text": "\nThis does nothing; it doesn\u2019t even set the Content-Transfer-Encoding header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.encoders.encode_quopri()", "path": "library/email.encoders#email.encoders.encode_quopri", "type": "Email", "text": "\nEncodes the payload into quoted-printable form and sets the Content-Transfer-\nEncoding header to `quoted-printable` 1. This is a good encoding to use when\nmost of your payload is normal printable data, but contains a few unprintable\ncharacters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.encoders: Encoders", "path": "library/email.encoders", "type": "Email", "text": "\nSource code: Lib/email/encoders.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.errors.BoundaryError", "path": "library/email.errors#email.errors.BoundaryError", "type": "Email", "text": "\nDeprecated and no longer used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.errors.HeaderParseError", "path": "library/email.errors#email.errors.HeaderParseError", "type": "Email", "text": "\nRaised under some error conditions when parsing the RFC 5322 headers of a\nmessage, this class is derived from `MessageParseError`. The `set_boundary()`\nmethod will raise this error if the content type is unknown when the method is\ncalled. `Header` may raise this error for certain base64 decoding errors, and\nwhen an attempt is made to create a header that appears to contain an embedded\nheader (that is, there is what is supposed to be a continuation line that has\nno leading whitespace and looks like a header).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.errors.MessageError", "path": "library/email.errors#email.errors.MessageError", "type": "Email", "text": "\nThis is the base class for all exceptions that the `email` package can raise.\nIt is derived from the standard `Exception` class and defines no additional\nmethods.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.errors.MessageParseError", "path": "library/email.errors#email.errors.MessageParseError", "type": "Email", "text": "\nThis is the base class for exceptions raised by the `Parser` class. It is\nderived from `MessageError`. This class is also used internally by the parser\nused by `headerregistry`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.errors.MultipartConversionError", "path": "library/email.errors#email.errors.MultipartConversionError", "type": "Email", "text": "\nRaised when a payload is added to a `Message` object using `add_payload()`,\nbut the payload is already a scalar and the message\u2019s Content-Type main type\nis not either multipart or missing. `MultipartConversionError` multiply\ninherits from `MessageError` and the built-in `TypeError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.errors: Exception and Defect classes", "path": "library/email.errors", "type": "Email", "text": "\nSource code: Lib/email/errors.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.generator.BytesGenerator", "path": "library/email.generator#email.generator.BytesGenerator", "type": "Email", "text": "\nReturn a `BytesGenerator` object that will write any message provided to the\n`flatten()` method, or any surrogateescape encoded text provided to the\n`write()` method, to the file-like object outfp. outfp must support a `write`\nmethod that accepts binary data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.generator.BytesGenerator.clone()", "path": "library/email.generator#email.generator.BytesGenerator.clone", "type": "Email", "text": "\nReturn an independent clone of this `BytesGenerator` instance with the exact\nsame option settings, and fp as the new outfp.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.generator.BytesGenerator.flatten()", "path": "library/email.generator#email.generator.BytesGenerator.flatten", "type": "Email", "text": "\nPrint the textual representation of the message object structure rooted at msg\nto the output file specified when the `BytesGenerator` instance was created.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.generator.BytesGenerator.write()", "path": "library/email.generator#email.generator.BytesGenerator.write", "type": "Email", "text": "\nEncode s using the `ASCII` codec and the `surrogateescape` error handler, and\npass it to the write method of the outfp passed to the `BytesGenerator`\u2019s\nconstructor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.generator.DecodedGenerator", "path": "library/email.generator#email.generator.DecodedGenerator", "type": "Email", "text": "\nAct like `Generator`, except that for any subpart of the message passed to\n`Generator.flatten()`, if the subpart is of main type text, print the decoded\npayload of the subpart, and if the main type is not text, instead of printing\nit fill in the string fmt using information from the part and print the\nresulting filled-in string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.generator.Generator", "path": "library/email.generator#email.generator.Generator", "type": "Email", "text": "\nReturn a `Generator` object that will write any message provided to the\n`flatten()` method, or any text provided to the `write()` method, to the file-\nlike object outfp. outfp must support a `write` method that accepts string\ndata.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.generator.Generator.clone()", "path": "library/email.generator#email.generator.Generator.clone", "type": "Email", "text": "\nReturn an independent clone of this `Generator` instance with the exact same\noptions, and fp as the new outfp.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.generator.Generator.flatten()", "path": "library/email.generator#email.generator.Generator.flatten", "type": "Email", "text": "\nPrint the textual representation of the message object structure rooted at msg\nto the output file specified when the `Generator` instance was created.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.generator.Generator.write()", "path": "library/email.generator#email.generator.Generator.write", "type": "Email", "text": "\nWrite s to the write method of the outfp passed to the `Generator`\u2019s\nconstructor. This provides just enough file-like API for `Generator` instances\nto be used in the `print()` function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.generator: Generating MIME documents", "path": "library/email.generator", "type": "Email", "text": "\nSource code: Lib/email/generator.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.header.decode_header()", "path": "library/email.header#email.header.decode_header", "type": "Email", "text": "\nDecode a message header value without converting the character set. The header\nvalue is in header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.header.Header", "path": "library/email.header#email.header.Header", "type": "Email", "text": "\nCreate a MIME-compliant header that can contain strings in different character\nsets.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.header.Header.append()", "path": "library/email.header#email.header.Header.append", "type": "Email", "text": "\nAppend the string s to the MIME header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.header.Header.encode()", "path": "library/email.header#email.header.Header.encode", "type": "Email", "text": "\nEncode a message header into an RFC-compliant format, possibly wrapping long\nlines and encapsulating non-ASCII parts in base64 or quoted-printable\nencodings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.header.Header.__eq__()", "path": "library/email.header#email.header.Header.__eq__", "type": "Email", "text": "\nThis method allows you to compare two `Header` instances for equality.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.header.Header.__ne__()", "path": "library/email.header#email.header.Header.__ne__", "type": "Email", "text": "\nThis method allows you to compare two `Header` instances for inequality.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.header.Header.__str__()", "path": "library/email.header#email.header.Header.__str__", "type": "Email", "text": "\nReturns an approximation of the `Header` as a string, using an unlimited line\nlength. All pieces are converted to unicode using the specified encoding and\njoined together appropriately. Any pieces with a charset of `'unknown-8bit'`\nare decoded as ASCII using the `'replace'` error handler.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.header.make_header()", "path": "library/email.header#email.header.make_header", "type": "Email", "text": "\nCreate a `Header` instance from a sequence of pairs as returned by\n`decode_header()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.header: Internationalized headers", "path": "library/email.header", "type": "Email", "text": "\nSource code: Lib/email/header.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.Address", "path": "library/email.headerregistry#email.headerregistry.Address", "type": "Email", "text": "\nThe class used to represent an email address. The general form of an address\nis:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.Address.addr_spec", "path": "library/email.headerregistry#email.headerregistry.Address.addr_spec", "type": "Email", "text": "\nThe `username@domain` portion of the address, correctly quoted for use as a\nbare address (the second form shown above). This attribute is not mutable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.Address.display_name", "path": "library/email.headerregistry#email.headerregistry.Address.display_name", "type": "Email", "text": "\nThe display name portion of the address, if any, with all quoting removed. If\nthe address does not have a display name, this attribute will be an empty\nstring.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.Address.domain", "path": "library/email.headerregistry#email.headerregistry.Address.domain", "type": "Email", "text": "\nThe `domain` portion of the address.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.Address.username", "path": "library/email.headerregistry#email.headerregistry.Address.username", "type": "Email", "text": "\nThe `username` portion of the address, with all quoting removed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.Address.__str__()", "path": "library/email.headerregistry#email.headerregistry.Address.__str__", "type": "Email", "text": "\nThe `str` value of the object is the address quoted according to RFC 5322\nrules, but with no Content Transfer Encoding of any non-ASCII characters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.AddressHeader", "path": "library/email.headerregistry#email.headerregistry.AddressHeader", "type": "Email", "text": "\nAddress headers are one of the most complex structured header types. The\n`AddressHeader` class provides a generic interface to any address header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.AddressHeader.addresses", "path": "library/email.headerregistry#email.headerregistry.AddressHeader.addresses", "type": "Email", "text": "\nA tuple of `Address` objects encoding all of the individual addresses from the\nheader value. If the header value contains any groups, the individual\naddresses from the group are included in the list at the point where the group\noccurs in the value (that is, the list of addresses is \u201cflattened\u201d into a one\ndimensional list).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.AddressHeader.groups", "path": "library/email.headerregistry#email.headerregistry.AddressHeader.groups", "type": "Email", "text": "\nA tuple of `Group` objects encoding the addresses and groups found in the\nheader value. Addresses that are not part of a group are represented in this\nlist as single-address `Groups` whose `display_name` is `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.BaseHeader", "path": "library/email.headerregistry#email.headerregistry.BaseHeader", "type": "Email", "text": "\nname and value are passed to `BaseHeader` from the `header_factory` call. The\nstring value of any header object is the value fully decoded to unicode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.BaseHeader.defects", "path": "library/email.headerregistry#email.headerregistry.BaseHeader.defects", "type": "Email", "text": "\nA tuple of `HeaderDefect` instances reporting any RFC compliance problems\nfound during parsing. The email package tries to be complete about detecting\ncompliance issues. See the `errors` module for a discussion of the types of\ndefects that may be reported.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.BaseHeader.fold()", "path": "library/email.headerregistry#email.headerregistry.BaseHeader.fold", "type": "Email", "text": "\nReturn a string containing `linesep` characters as required to correctly fold\nthe header according to policy. A `cte_type` of `8bit` will be treated as if\nit were `7bit`, since headers may not contain arbitrary binary data. If `utf8`\nis `False`, non-ASCII data will be RFC 2047 encoded.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.BaseHeader.max_count", "path": "library/email.headerregistry#email.headerregistry.BaseHeader.max_count", "type": "Email", "text": "\nThe maximum number of headers of this type that can have the same `name`. A\nvalue of `None` means unlimited. The `BaseHeader` value for this attribute is\n`None`; it is expected that specialized header classes will override this\nvalue as needed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.BaseHeader.name", "path": "library/email.headerregistry#email.headerregistry.BaseHeader.name", "type": "Email", "text": "\nThe name of the header (the portion of the field before the \u2018:\u2019). This is\nexactly the value passed in the `header_factory` call for name; that is, case\nis preserved.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.ContentDispositionHeader", "path": "library/email.headerregistry#email.headerregistry.ContentDispositionHeader", "type": "Email", "text": "\nA `ParameterizedMIMEHeader` class that handles the Content-Disposition header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.ContentDispositionHeader.content_disposition", "path": "library/email.headerregistry#email.headerregistry.ContentDispositionHeader.content_disposition", "type": "Email", "text": "\n`inline` and `attachment` are the only valid values in common use.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.ContentTransferEncoding", "path": "library/email.headerregistry#email.headerregistry.ContentTransferEncoding", "type": "Email", "text": "\nHandles the Content-Transfer-Encoding header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.ContentTransferEncoding.cte", "path": "library/email.headerregistry#email.headerregistry.ContentTransferEncoding.cte", "type": "Email", "text": "\nValid values are `7bit`, `8bit`, `base64`, and `quoted-printable`. See RFC\n2045 for more information.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.ContentTypeHeader", "path": "library/email.headerregistry#email.headerregistry.ContentTypeHeader", "type": "Email", "text": "\nA `ParameterizedMIMEHeader` class that handles the Content-Type header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.ContentTypeHeader.content_type", "path": "library/email.headerregistry#email.headerregistry.ContentTypeHeader.content_type", "type": "Email", "text": "\nThe content type string, in the form `maintype/subtype`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.ContentTypeHeader.maintype", "path": "library/email.headerregistry#email.headerregistry.ContentTypeHeader.maintype", "type": "Email", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.ContentTypeHeader.subtype", "path": "library/email.headerregistry#email.headerregistry.ContentTypeHeader.subtype", "type": "Email", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.DateHeader", "path": "library/email.headerregistry#email.headerregistry.DateHeader", "type": "Email", "text": "\nRFC 5322 specifies a very specific format for dates within email headers. The\n`DateHeader` parser recognizes that date format, as well as recognizing a\nnumber of variant forms that are sometimes found \u201cin the wild\u201d.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.DateHeader.datetime", "path": "library/email.headerregistry#email.headerregistry.DateHeader.datetime", "type": "Email", "text": "\nIf the header value can be recognized as a valid date of one form or another,\nthis attribute will contain a `datetime` instance representing that date. If\nthe timezone of the input date is specified as `-0000` (indicating it is in\nUTC but contains no information about the source timezone), then `datetime`\nwill be a naive `datetime`. If a specific timezone offset is found (including\n`+0000`), then `datetime` will contain an aware `datetime` that uses\n`datetime.timezone` to record the timezone offset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.Group", "path": "library/email.headerregistry#email.headerregistry.Group", "type": "Email", "text": "\nThe class used to represent an address group. The general form of an address\ngroup is:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.Group.addresses", "path": "library/email.headerregistry#email.headerregistry.Group.addresses", "type": "Email", "text": "\nA possibly empty tuple of `Address` objects representing the addresses in the\ngroup.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.Group.display_name", "path": "library/email.headerregistry#email.headerregistry.Group.display_name", "type": "Email", "text": "\nThe `display_name` of the group. If it is `None` and there is exactly one\n`Address` in `addresses`, then the `Group` represents a single address that is\nnot in a group.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.Group.__str__()", "path": "library/email.headerregistry#email.headerregistry.Group.__str__", "type": "Email", "text": "\nThe `str` value of a `Group` is formatted according to RFC 5322, but with no\nContent Transfer Encoding of any non-ASCII characters. If `display_name` is\nnone and there is a single `Address` in the `addresses` list, the `str` value\nwill be the same as the `str` of that single `Address`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.HeaderRegistry", "path": "library/email.headerregistry#email.headerregistry.HeaderRegistry", "type": "Email", "text": "\nThis is the factory used by `EmailPolicy` by default. `HeaderRegistry` builds\nthe class used to create a header instance dynamically, using base_class and a\nspecialized class retrieved from a registry that it holds. When a given header\nname does not appear in the registry, the class specified by default_class is\nused as the specialized class. When use_default_map is `True` (the default),\nthe standard mapping of header names to classes is copied in to the registry\nduring initialization. base_class is always the last class in the generated\nclass\u2019s `__bases__` list.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.HeaderRegistry.map_to_type()", "path": "library/email.headerregistry#email.headerregistry.HeaderRegistry.map_to_type", "type": "Email", "text": "\nname is the name of the header to be mapped. It will be converted to lower\ncase in the registry. cls is the specialized class to be used, along with\nbase_class, to create the class used to instantiate headers that match name.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.HeaderRegistry.__call__()", "path": "library/email.headerregistry#email.headerregistry.HeaderRegistry.__call__", "type": "Email", "text": "\nRetrieves the specialized header associated with name from the registry (using\ndefault_class if name does not appear in the registry) and composes it with\nbase_class to produce a class, calls the constructed class\u2019s constructor,\npassing it the same argument list, and finally returns the class instance\ncreated thereby.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.HeaderRegistry.__getitem__()", "path": "library/email.headerregistry#email.headerregistry.HeaderRegistry.__getitem__", "type": "Email", "text": "\nConstruct and return a class to handle creating a name header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.MIMEVersionHeader", "path": "library/email.headerregistry#email.headerregistry.MIMEVersionHeader", "type": "Email", "text": "\nThere is really only one valid value for the MIME-Version header, and that is\n`1.0`. For future proofing, this header class supports other valid version\nnumbers. If a version number has a valid value per RFC 2045, then the header\nobject will have non-`None` values for the following attributes:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.MIMEVersionHeader.major", "path": "library/email.headerregistry#email.headerregistry.MIMEVersionHeader.major", "type": "Email", "text": "\nThe major version number as an integer\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.MIMEVersionHeader.minor", "path": "library/email.headerregistry#email.headerregistry.MIMEVersionHeader.minor", "type": "Email", "text": "\nThe minor version number as an integer\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.MIMEVersionHeader.version", "path": "library/email.headerregistry#email.headerregistry.MIMEVersionHeader.version", "type": "Email", "text": "\nThe version number as a string, with any whitespace and/or comments removed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.ParameterizedMIMEHeader", "path": "library/email.headerregistry#email.headerregistry.ParameterizedMIMEHeader", "type": "Email", "text": "\nMIME headers all start with the prefix \u2018Content-\u2018. Each specific header has a\ncertain value, described under the class for that header. Some can also take a\nlist of supplemental parameters, which have a common format. This class serves\nas a base for all the MIME headers that take parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.ParameterizedMIMEHeader.params", "path": "library/email.headerregistry#email.headerregistry.ParameterizedMIMEHeader.params", "type": "Email", "text": "\nA dictionary mapping parameter names to parameter values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.SingleAddressHeader", "path": "library/email.headerregistry#email.headerregistry.SingleAddressHeader", "type": "Email", "text": "\nA subclass of `AddressHeader` that adds one additional attribute:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.SingleAddressHeader.address", "path": "library/email.headerregistry#email.headerregistry.SingleAddressHeader.address", "type": "Email", "text": "\nThe single address encoded by the header value. If the header value actually\ncontains more than one address (which would be a violation of the RFC under\nthe default `policy`), accessing this attribute will result in a `ValueError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry.UnstructuredHeader", "path": "library/email.headerregistry#email.headerregistry.UnstructuredHeader", "type": "Email", "text": "\nAn \u201cunstructured\u201d header is the default type of header in RFC 5322. Any header\nthat does not have a specified syntax is treated as unstructured. The classic\nexample of an unstructured header is the Subject header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.headerregistry: Custom Header Objects", "path": "library/email.headerregistry", "type": "Email", "text": "\nSource code: Lib/email/headerregistry.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.iterators.body_line_iterator()", "path": "library/email.iterators#email.iterators.body_line_iterator", "type": "Email", "text": "\nThis iterates over all the payloads in all the subparts of msg, returning the\nstring payloads line-by-line. It skips over all the subpart headers, and it\nskips over any subpart with a payload that isn\u2019t a Python string. This is\nsomewhat equivalent to reading the flat text representation of the message\nfrom a file using `readline()`, skipping over all the intervening headers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.iterators.typed_subpart_iterator()", "path": "library/email.iterators#email.iterators.typed_subpart_iterator", "type": "Email", "text": "\nThis iterates over all the subparts of msg, returning only those subparts that\nmatch the MIME type specified by maintype and subtype.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.iterators._structure()", "path": "library/email.iterators#email.iterators._structure", "type": "Email", "text": "\nPrints an indented representation of the content types of the message object\nstructure. For example:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.iterators: Iterators", "path": "library/email.iterators", "type": "Email", "text": "\nSource code: Lib/email/iterators.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage", "path": "library/email.message#email.message.EmailMessage", "type": "Email", "text": "\nIf policy is specified use the rules it specifies to update and serialize the\nrepresentation of the message. If policy is not set, use the `default` policy,\nwhich follows the rules of the email RFCs except for line endings (instead of\nthe RFC mandated `\\r\\n`, it uses the Python standard `\\n` line endings). For\nmore information see the `policy` documentation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.add_alternative()", "path": "library/email.message#email.message.EmailMessage.add_alternative", "type": "Email", "text": "\nIf the message is a `multipart/alternative`, create a new message object, pass\nall of the arguments to its `set_content()` method, and `attach()` it to the\n`multipart`. If the message is a non-`multipart` or `multipart/related`, call\n`make_alternative()` and then proceed as above. If the message is any other\ntype of `multipart`, raise a `TypeError`. If content_manager is not specified,\nuse the `content_manager` specified by the current `policy`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.add_attachment()", "path": "library/email.message#email.message.EmailMessage.add_attachment", "type": "Email", "text": "\nIf the message is a `multipart/mixed`, create a new message object, pass all\nof the arguments to its `set_content()` method, and `attach()` it to the\n`multipart`. If the message is a non-`multipart`, `multipart/related`, or\n`multipart/alternative`, call `make_mixed()` and then proceed as above. If\ncontent_manager is not specified, use the `content_manager` specified by the\ncurrent `policy`. If the added part has no Content-Disposition header, add one\nwith the value `attachment`. This method can be used both for explicit\nattachments (Content-Disposition: attachment) and `inline` attachments\n(Content-Disposition: inline), by passing appropriate options to the\n`content_manager`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.add_header()", "path": "library/email.message#email.message.EmailMessage.add_header", "type": "Email", "text": "\nExtended header setting. This method is similar to `__setitem__()` except that\nadditional header parameters can be provided as keyword arguments. _name is\nthe header field to add and _value is the primary value for the header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.add_related()", "path": "library/email.message#email.message.EmailMessage.add_related", "type": "Email", "text": "\nIf the message is a `multipart/related`, create a new message object, pass all\nof the arguments to its `set_content()` method, and `attach()` it to the\n`multipart`. If the message is a non-`multipart`, call `make_related()` and\nthen proceed as above. If the message is any other type of `multipart`, raise\na `TypeError`. If content_manager is not specified, use the `content_manager`\nspecified by the current `policy`. If the added part has no Content-\nDisposition header, add one with the value `inline`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.as_bytes()", "path": "library/email.message#email.message.EmailMessage.as_bytes", "type": "Email", "text": "\nReturn the entire message flattened as a bytes object. When optional unixfrom\nis true, the envelope header is included in the returned string. unixfrom\ndefaults to `False`. The policy argument may be used to override the default\npolicy obtained from the message instance. This can be used to control some of\nthe formatting produced by the method, since the specified policy will be\npassed to the `BytesGenerator`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.as_string()", "path": "library/email.message#email.message.EmailMessage.as_string", "type": "Email", "text": "\nReturn the entire message flattened as a string. When optional unixfrom is\ntrue, the envelope header is included in the returned string. unixfrom\ndefaults to `False`. For backward compatibility with the base `Message` class\nmaxheaderlen is accepted, but defaults to `None`, which means that by default\nthe line length is controlled by the `max_line_length` of the policy. The\npolicy argument may be used to override the default policy obtained from the\nmessage instance. This can be used to control some of the formatting produced\nby the method, since the specified policy will be passed to the `Generator`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.clear()", "path": "library/email.message#email.message.EmailMessage.clear", "type": "Email", "text": "\nRemove the payload and all of the headers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.clear_content()", "path": "library/email.message#email.message.EmailMessage.clear_content", "type": "Email", "text": "\nRemove the payload and all of the `Content-` headers, leaving all other\nheaders intact and in their original order.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.defects", "path": "library/email.message#email.message.EmailMessage.defects", "type": "Email", "text": "\nThe defects attribute contains a list of all the problems found when parsing\nthis message. See `email.errors` for a detailed description of the possible\nparsing defects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.del_param()", "path": "library/email.message#email.message.EmailMessage.del_param", "type": "Email", "text": "\nRemove the given parameter completely from the Content-Type header. The header\nwill be re-written in place without the parameter or its value. Optional\nheader specifies an alternative to Content-Type.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.epilogue", "path": "library/email.message#email.message.EmailMessage.epilogue", "type": "Email", "text": "\nThe epilogue attribute acts the same way as the preamble attribute, except\nthat it contains text that appears between the last boundary and the end of\nthe message. As with the `preamble`, if there is no epilog text this attribute\nwill be `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.get()", "path": "library/email.message#email.message.EmailMessage.get", "type": "Email", "text": "\nReturn the value of the named header field. This is identical to\n`__getitem__()` except that optional failobj is returned if the named header\nis missing (failobj defaults to `None`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.get_all()", "path": "library/email.message#email.message.EmailMessage.get_all", "type": "Email", "text": "\nReturn a list of all the values for the field named name. If there are no such\nnamed headers in the message, failobj is returned (defaults to `None`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.get_body()", "path": "library/email.message#email.message.EmailMessage.get_body", "type": "Email", "text": "\nReturn the MIME part that is the best candidate to be the \u201cbody\u201d of the\nmessage.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.get_boundary()", "path": "library/email.message#email.message.EmailMessage.get_boundary", "type": "Email", "text": "\nReturn the value of the `boundary` parameter of the Content-Type header of the\nmessage, or failobj if either the header is missing, or has no `boundary`\nparameter. The returned string will always be unquoted as per\n`email.utils.unquote()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.get_charsets()", "path": "library/email.message#email.message.EmailMessage.get_charsets", "type": "Email", "text": "\nReturn a list containing the character set names in the message. If the\nmessage is a multipart, then the list will contain one element for each\nsubpart in the payload, otherwise, it will be a list of length 1.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.get_content()", "path": "library/email.message#email.message.EmailMessage.get_content", "type": "Email", "text": "\nCall the `get_content()` method of the content_manager, passing self as the\nmessage object, and passing along any other arguments or keywords as\nadditional arguments. If content_manager is not specified, use the\n`content_manager` specified by the current `policy`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.get_content_charset()", "path": "library/email.message#email.message.EmailMessage.get_content_charset", "type": "Email", "text": "\nReturn the `charset` parameter of the Content-Type header, coerced to lower\ncase. If there is no Content-Type header, or if that header has no `charset`\nparameter, failobj is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.get_content_disposition()", "path": "library/email.message#email.message.EmailMessage.get_content_disposition", "type": "Email", "text": "\nReturn the lowercased value (without parameters) of the message\u2019s Content-\nDisposition header if it has one, or `None`. The possible values for this\nmethod are inline, attachment or `None` if the message follows RFC 2183.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.get_content_maintype()", "path": "library/email.message#email.message.EmailMessage.get_content_maintype", "type": "Email", "text": "\nReturn the message\u2019s main content type. This is the maintype part of the\nstring returned by `get_content_type()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.get_content_subtype()", "path": "library/email.message#email.message.EmailMessage.get_content_subtype", "type": "Email", "text": "\nReturn the message\u2019s sub-content type. This is the subtype part of the string\nreturned by `get_content_type()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.get_content_type()", "path": "library/email.message#email.message.EmailMessage.get_content_type", "type": "Email", "text": "\nReturn the message\u2019s content type, coerced to lower case of the form\nmaintype/subtype. If there is no Content-Type header in the message return the\nvalue returned by `get_default_type()`. If the Content-Type header is invalid,\nreturn `text/plain`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.get_default_type()", "path": "library/email.message#email.message.EmailMessage.get_default_type", "type": "Email", "text": "\nReturn the default content type. Most messages have a default content type of\ntext/plain, except for messages that are subparts of multipart/digest\ncontainers. Such subparts have a default content type of message/rfc822.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.get_filename()", "path": "library/email.message#email.message.EmailMessage.get_filename", "type": "Email", "text": "\nReturn the value of the `filename` parameter of the Content-Disposition header\nof the message. If the header does not have a `filename` parameter, this\nmethod falls back to looking for the `name` parameter on the Content-Type\nheader. If neither is found, or the header is missing, then failobj is\nreturned. The returned string will always be unquoted as per\n`email.utils.unquote()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.get_unixfrom()", "path": "library/email.message#email.message.EmailMessage.get_unixfrom", "type": "Email", "text": "\nReturn the message\u2019s envelope header. Defaults to `None` if the envelope\nheader was never set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.is_attachment()", "path": "library/email.message#email.message.EmailMessage.is_attachment", "type": "Email", "text": "\nReturn `True` if there is a Content-Disposition header and its (case\ninsensitive) value is `attachment`, `False` otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.is_multipart()", "path": "library/email.message#email.message.EmailMessage.is_multipart", "type": "Email", "text": "\nReturn `True` if the message\u2019s payload is a list of sub-`EmailMessage`\nobjects, otherwise return `False`. When `is_multipart()` returns `False`, the\npayload should be a string object (which might be a CTE encoded binary\npayload). Note that `is_multipart()` returning `True` does not necessarily\nmean that \u201cmsg.get_content_maintype() == \u2018multipart\u2019\u201d will return the `True`.\nFor example, `is_multipart` will return `True` when the `EmailMessage` is of\ntype `message/rfc822`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.items()", "path": "library/email.message#email.message.EmailMessage.items", "type": "Email", "text": "\nReturn a list of 2-tuples containing all the message\u2019s field headers and\nvalues.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.iter_attachments()", "path": "library/email.message#email.message.EmailMessage.iter_attachments", "type": "Email", "text": "\nReturn an iterator over all of the immediate sub-parts of the message that are\nnot candidate \u201cbody\u201d parts. That is, skip the first occurrence of each of\n`text/plain`, `text/html`, `multipart/related`, or `multipart/alternative`\n(unless they are explicitly marked as attachments via Content-Disposition:\nattachment), and return all remaining parts. When applied directly to a\n`multipart/related`, return an iterator over the all the related parts except\nthe root part (ie: the part pointed to by the `start` parameter, or the first\npart if there is no `start` parameter or the `start` parameter doesn\u2019t match\nthe Content-ID of any of the parts). When applied directly to a\n`multipart/alternative` or a non-`multipart`, return an empty iterator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.iter_parts()", "path": "library/email.message#email.message.EmailMessage.iter_parts", "type": "Email", "text": "\nReturn an iterator over all of the immediate sub-parts of the message, which\nwill be empty for a non-`multipart`. (See also `walk()`.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.keys()", "path": "library/email.message#email.message.EmailMessage.keys", "type": "Email", "text": "\nReturn a list of all the message\u2019s header field names.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.make_alternative()", "path": "library/email.message#email.message.EmailMessage.make_alternative", "type": "Email", "text": "\nConvert a non-`multipart` or a `multipart/related` into a\n`multipart/alternative`, moving any existing Content- headers and payload into\na (new) first part of the `multipart`. If boundary is specified, use it as the\nboundary string in the multipart, otherwise leave the boundary to be\nautomatically created when it is needed (for example, when the message is\nserialized).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.make_mixed()", "path": "library/email.message#email.message.EmailMessage.make_mixed", "type": "Email", "text": "\nConvert a non-`multipart`, a `multipart/related`, or a `multipart-alternative`\ninto a `multipart/mixed`, moving any existing Content- headers and payload\ninto a (new) first part of the `multipart`. If boundary is specified, use it\nas the boundary string in the multipart, otherwise leave the boundary to be\nautomatically created when it is needed (for example, when the message is\nserialized).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.make_related()", "path": "library/email.message#email.message.EmailMessage.make_related", "type": "Email", "text": "\nConvert a non-`multipart` message into a `multipart/related` message, moving\nany existing Content- headers and payload into a (new) first part of the\n`multipart`. If boundary is specified, use it as the boundary string in the\nmultipart, otherwise leave the boundary to be automatically created when it is\nneeded (for example, when the message is serialized).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.preamble", "path": "library/email.message#email.message.EmailMessage.preamble", "type": "Email", "text": "\nThe format of a MIME document allows for some text between the blank line\nfollowing the headers, and the first multipart boundary string. Normally, this\ntext is never visible in a MIME-aware mail reader because it falls outside the\nstandard MIME armor. However, when viewing the raw text of the message, or\nwhen viewing the message in a non-MIME aware reader, this text can become\nvisible.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.replace_header()", "path": "library/email.message#email.message.EmailMessage.replace_header", "type": "Email", "text": "\nReplace a header. Replace the first header found in the message that matches\n_name, retaining header order and field name case of the original header. If\nno matching header is found, raise a `KeyError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.set_boundary()", "path": "library/email.message#email.message.EmailMessage.set_boundary", "type": "Email", "text": "\nSet the `boundary` parameter of the Content-Type header to boundary.\n`set_boundary()` will always quote boundary if necessary. A `HeaderParseError`\nis raised if the message object has no Content-Type header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.set_content()", "path": "library/email.message#email.message.EmailMessage.set_content", "type": "Email", "text": "\nCall the `set_content()` method of the content_manager, passing self as the\nmessage object, and passing along any other arguments or keywords as\nadditional arguments. If content_manager is not specified, use the\n`content_manager` specified by the current `policy`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.set_default_type()", "path": "library/email.message#email.message.EmailMessage.set_default_type", "type": "Email", "text": "\nSet the default content type. ctype should either be text/plain or\nmessage/rfc822, although this is not enforced. The default content type is not\nstored in the Content-Type header, so it only affects the return value of the\n`get_content_type` methods when no Content-Type header is present in the\nmessage.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.set_param()", "path": "library/email.message#email.message.EmailMessage.set_param", "type": "Email", "text": "\nSet a parameter in the Content-Type header. If the parameter already exists in\nthe header, replace its value with value. When header is `Content-Type` (the\ndefault) and the header does not yet exist in the message, add it, set its\nvalue to text/plain, and append the new parameter value. Optional header\nspecifies an alternative header to Content-Type.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.set_unixfrom()", "path": "library/email.message#email.message.EmailMessage.set_unixfrom", "type": "Email", "text": "\nSet the message\u2019s envelope header to unixfrom, which should be a string. (See\n`mboxMessage` for a brief description of this header.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.values()", "path": "library/email.message#email.message.EmailMessage.values", "type": "Email", "text": "\nReturn a list of all the message\u2019s field values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.walk()", "path": "library/email.message#email.message.EmailMessage.walk", "type": "Email", "text": "\nThe `walk()` method is an all-purpose generator which can be used to iterate\nover all the parts and subparts of a message object tree, in depth-first\ntraversal order. You will typically use `walk()` as the iterator in a `for`\nloop; each iteration returns the next subpart.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.__bytes__()", "path": "library/email.message#email.message.EmailMessage.__bytes__", "type": "Email", "text": "\nEquivalent to `as_bytes()`. Allows `bytes(msg)` to produce a bytes object\ncontaining the serialized message.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.__contains__()", "path": "library/email.message#email.message.EmailMessage.__contains__", "type": "Email", "text": "\nReturn `True` if the message object has a field named name. Matching is done\nwithout regard to case and name does not include the trailing colon. Used for\nthe `in` operator. For example:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.__delitem__()", "path": "library/email.message#email.message.EmailMessage.__delitem__", "type": "Email", "text": "\nDelete all occurrences of the field with name name from the message\u2019s headers.\nNo exception is raised if the named field isn\u2019t present in the headers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.__getitem__()", "path": "library/email.message#email.message.EmailMessage.__getitem__", "type": "Email", "text": "\nReturn the value of the named header field. name does not include the colon\nfield separator. If the header is missing, `None` is returned; a `KeyError` is\nnever raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.__len__()", "path": "library/email.message#email.message.EmailMessage.__len__", "type": "Email", "text": "\nReturn the total number of headers, including duplicates.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.__setitem__()", "path": "library/email.message#email.message.EmailMessage.__setitem__", "type": "Email", "text": "\nAdd a header to the message with field name name and value val. The field is\nappended to the end of the message\u2019s existing headers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.EmailMessage.__str__()", "path": "library/email.message#email.message.EmailMessage.__str__", "type": "Email", "text": "\nEquivalent to `as_string(policy=self.policy.clone(utf8=True))`. Allows\n`str(msg)` to produce a string containing the serialized message in a readable\nformat.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message", "path": "library/email.compat32-message#email.message.Message", "type": "Email", "text": "\nIf policy is specified (it must be an instance of a `policy` class) use the\nrules it specifies to update and serialize the representation of the message.\nIf policy is not set, use the `compat32` policy, which maintains backward\ncompatibility with the Python 3.2 version of the email package. For more\ninformation see the `policy` documentation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.add_header()", "path": "library/email.compat32-message#email.message.Message.add_header", "type": "Email", "text": "\nExtended header setting. This method is similar to `__setitem__()` except that\nadditional header parameters can be provided as keyword arguments. _name is\nthe header field to add and _value is the primary value for the header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.as_bytes()", "path": "library/email.compat32-message#email.message.Message.as_bytes", "type": "Email", "text": "\nReturn the entire message flattened as a bytes object. When optional unixfrom\nis true, the envelope header is included in the returned string. unixfrom\ndefaults to `False`. The policy argument may be used to override the default\npolicy obtained from the message instance. This can be used to control some of\nthe formatting produced by the method, since the specified policy will be\npassed to the `BytesGenerator`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.as_string()", "path": "library/email.compat32-message#email.message.Message.as_string", "type": "Email", "text": "\nReturn the entire message flattened as a string. When optional unixfrom is\ntrue, the envelope header is included in the returned string. unixfrom\ndefaults to `False`. For backward compatibility reasons, maxheaderlen defaults\nto `0`, so if you want a different value you must override it explicitly (the\nvalue specified for max_line_length in the policy will be ignored by this\nmethod). The policy argument may be used to override the default policy\nobtained from the message instance. This can be used to control some of the\nformatting produced by the method, since the specified policy will be passed\nto the `Generator`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.attach()", "path": "library/email.compat32-message#email.message.Message.attach", "type": "Email", "text": "\nAdd the given payload to the current payload, which must be `None` or a list\nof `Message` objects before the call. After the call, the payload will always\nbe a list of `Message` objects. If you want to set the payload to a scalar\nobject (e.g. a string), use `set_payload()` instead.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.defects", "path": "library/email.compat32-message#email.message.Message.defects", "type": "Email", "text": "\nThe defects attribute contains a list of all the problems found when parsing\nthis message. See `email.errors` for a detailed description of the possible\nparsing defects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.del_param()", "path": "library/email.compat32-message#email.message.Message.del_param", "type": "Email", "text": "\nRemove the given parameter completely from the Content-Type header. The header\nwill be re-written in place without the parameter or its value. All values\nwill be quoted as necessary unless requote is `False` (the default is `True`).\nOptional header specifies an alternative to Content-Type.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.epilogue", "path": "library/email.compat32-message#email.message.Message.epilogue", "type": "Email", "text": "\nThe epilogue attribute acts the same way as the preamble attribute, except\nthat it contains text that appears between the last boundary and the end of\nthe message.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.get()", "path": "library/email.compat32-message#email.message.Message.get", "type": "Email", "text": "\nReturn the value of the named header field. This is identical to\n`__getitem__()` except that optional failobj is returned if the named header\nis missing (defaults to `None`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.get_all()", "path": "library/email.compat32-message#email.message.Message.get_all", "type": "Email", "text": "\nReturn a list of all the values for the field named name. If there are no such\nnamed headers in the message, failobj is returned (defaults to `None`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.get_boundary()", "path": "library/email.compat32-message#email.message.Message.get_boundary", "type": "Email", "text": "\nReturn the value of the `boundary` parameter of the Content-Type header of the\nmessage, or failobj if either the header is missing, or has no `boundary`\nparameter. The returned string will always be unquoted as per\n`email.utils.unquote()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.get_charset()", "path": "library/email.compat32-message#email.message.Message.get_charset", "type": "Email", "text": "\nReturn the `Charset` instance associated with the message\u2019s payload.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.get_charsets()", "path": "library/email.compat32-message#email.message.Message.get_charsets", "type": "Email", "text": "\nReturn a list containing the character set names in the message. If the\nmessage is a multipart, then the list will contain one element for each\nsubpart in the payload, otherwise, it will be a list of length 1.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.get_content_charset()", "path": "library/email.compat32-message#email.message.Message.get_content_charset", "type": "Email", "text": "\nReturn the `charset` parameter of the Content-Type header, coerced to lower\ncase. If there is no Content-Type header, or if that header has no `charset`\nparameter, failobj is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.get_content_disposition()", "path": "library/email.compat32-message#email.message.Message.get_content_disposition", "type": "Email", "text": "\nReturn the lowercased value (without parameters) of the message\u2019s Content-\nDisposition header if it has one, or `None`. The possible values for this\nmethod are inline, attachment or `None` if the message follows RFC 2183.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.get_content_maintype()", "path": "library/email.compat32-message#email.message.Message.get_content_maintype", "type": "Email", "text": "\nReturn the message\u2019s main content type. This is the maintype part of the\nstring returned by `get_content_type()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.get_content_subtype()", "path": "library/email.compat32-message#email.message.Message.get_content_subtype", "type": "Email", "text": "\nReturn the message\u2019s sub-content type. This is the subtype part of the string\nreturned by `get_content_type()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.get_content_type()", "path": "library/email.compat32-message#email.message.Message.get_content_type", "type": "Email", "text": "\nReturn the message\u2019s content type. The returned string is coerced to lower\ncase of the form maintype/subtype. If there was no Content-Type header in the\nmessage the default type as given by `get_default_type()` will be returned.\nSince according to RFC 2045, messages always have a default type,\n`get_content_type()` will always return a value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.get_default_type()", "path": "library/email.compat32-message#email.message.Message.get_default_type", "type": "Email", "text": "\nReturn the default content type. Most messages have a default content type of\ntext/plain, except for messages that are subparts of multipart/digest\ncontainers. Such subparts have a default content type of message/rfc822.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.get_filename()", "path": "library/email.compat32-message#email.message.Message.get_filename", "type": "Email", "text": "\nReturn the value of the `filename` parameter of the Content-Disposition header\nof the message. If the header does not have a `filename` parameter, this\nmethod falls back to looking for the `name` parameter on the Content-Type\nheader. If neither is found, or the header is missing, then failobj is\nreturned. The returned string will always be unquoted as per\n`email.utils.unquote()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.get_param()", "path": "library/email.compat32-message#email.message.Message.get_param", "type": "Email", "text": "\nReturn the value of the Content-Type header\u2019s parameter param as a string. If\nthe message has no Content-Type header or if there is no such parameter, then\nfailobj is returned (defaults to `None`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.get_params()", "path": "library/email.compat32-message#email.message.Message.get_params", "type": "Email", "text": "\nReturn the message\u2019s Content-Type parameters, as a list. The elements of the\nreturned list are 2-tuples of key/value pairs, as split on the `'='` sign. The\nleft hand side of the `'='` is the key, while the right hand side is the\nvalue. If there is no `'='` sign in the parameter the value is the empty\nstring, otherwise the value is as described in `get_param()` and is unquoted\nif optional unquote is `True` (the default).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.get_payload()", "path": "library/email.compat32-message#email.message.Message.get_payload", "type": "Email", "text": "\nReturn the current payload, which will be a list of `Message` objects when\n`is_multipart()` is `True`, or a string when `is_multipart()` is `False`. If\nthe payload is a list and you mutate the list object, you modify the message\u2019s\npayload in place.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.get_unixfrom()", "path": "library/email.compat32-message#email.message.Message.get_unixfrom", "type": "Email", "text": "\nReturn the message\u2019s envelope header. Defaults to `None` if the envelope\nheader was never set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.is_multipart()", "path": "library/email.compat32-message#email.message.Message.is_multipart", "type": "Email", "text": "\nReturn `True` if the message\u2019s payload is a list of sub-`Message` objects,\notherwise return `False`. When `is_multipart()` returns `False`, the payload\nshould be a string object (which might be a CTE encoded binary payload). (Note\nthat `is_multipart()` returning `True` does not necessarily mean that\n\u201cmsg.get_content_maintype() == \u2018multipart\u2019\u201d will return the `True`. For\nexample, `is_multipart` will return `True` when the `Message` is of type\n`message/rfc822`.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.items()", "path": "library/email.compat32-message#email.message.Message.items", "type": "Email", "text": "\nReturn a list of 2-tuples containing all the message\u2019s field headers and\nvalues.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.keys()", "path": "library/email.compat32-message#email.message.Message.keys", "type": "Email", "text": "\nReturn a list of all the message\u2019s header field names.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.preamble", "path": "library/email.compat32-message#email.message.Message.preamble", "type": "Email", "text": "\nThe format of a MIME document allows for some text between the blank line\nfollowing the headers, and the first multipart boundary string. Normally, this\ntext is never visible in a MIME-aware mail reader because it falls outside the\nstandard MIME armor. However, when viewing the raw text of the message, or\nwhen viewing the message in a non-MIME aware reader, this text can become\nvisible.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.replace_header()", "path": "library/email.compat32-message#email.message.Message.replace_header", "type": "Email", "text": "\nReplace a header. Replace the first header found in the message that matches\n_name, retaining header order and field name case. If no matching header was\nfound, a `KeyError` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.set_boundary()", "path": "library/email.compat32-message#email.message.Message.set_boundary", "type": "Email", "text": "\nSet the `boundary` parameter of the Content-Type header to boundary.\n`set_boundary()` will always quote boundary if necessary. A `HeaderParseError`\nis raised if the message object has no Content-Type header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.set_charset()", "path": "library/email.compat32-message#email.message.Message.set_charset", "type": "Email", "text": "\nSet the character set of the payload to charset, which can either be a\n`Charset` instance (see `email.charset`), a string naming a character set, or\n`None`. If it is a string, it will be converted to a `Charset` instance. If\ncharset is `None`, the `charset` parameter will be removed from the Content-\nType header (the message will not be otherwise modified). Anything else will\ngenerate a `TypeError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.set_default_type()", "path": "library/email.compat32-message#email.message.Message.set_default_type", "type": "Email", "text": "\nSet the default content type. ctype should either be text/plain or\nmessage/rfc822, although this is not enforced. The default content type is not\nstored in the Content-Type header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.set_param()", "path": "library/email.compat32-message#email.message.Message.set_param", "type": "Email", "text": "\nSet a parameter in the Content-Type header. If the parameter already exists in\nthe header, its value will be replaced with value. If the Content-Type header\nas not yet been defined for this message, it will be set to text/plain and the\nnew parameter value will be appended as per RFC 2045.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.set_payload()", "path": "library/email.compat32-message#email.message.Message.set_payload", "type": "Email", "text": "\nSet the entire message object\u2019s payload to payload. It is the client\u2019s\nresponsibility to ensure the payload invariants. Optional charset sets the\nmessage\u2019s default character set; see `set_charset()` for details.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.set_type()", "path": "library/email.compat32-message#email.message.Message.set_type", "type": "Email", "text": "\nSet the main type and subtype for the Content-Type header. type must be a\nstring in the form maintype/subtype, otherwise a `ValueError` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.set_unixfrom()", "path": "library/email.compat32-message#email.message.Message.set_unixfrom", "type": "Email", "text": "\nSet the message\u2019s envelope header to unixfrom, which should be a string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.values()", "path": "library/email.compat32-message#email.message.Message.values", "type": "Email", "text": "\nReturn a list of all the message\u2019s field values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.walk()", "path": "library/email.compat32-message#email.message.Message.walk", "type": "Email", "text": "\nThe `walk()` method is an all-purpose generator which can be used to iterate\nover all the parts and subparts of a message object tree, in depth-first\ntraversal order. You will typically use `walk()` as the iterator in a `for`\nloop; each iteration returns the next subpart.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.__bytes__()", "path": "library/email.compat32-message#email.message.Message.__bytes__", "type": "Email", "text": "\nEquivalent to `as_bytes()`. Allows `bytes(msg)` to produce a bytes object\ncontaining the formatted message.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.__contains__()", "path": "library/email.compat32-message#email.message.Message.__contains__", "type": "Email", "text": "\nReturn `True` if the message object has a field named name. Matching is done\ncase-insensitively and name should not include the trailing colon. Used for\nthe `in` operator, e.g.:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.__delitem__()", "path": "library/email.compat32-message#email.message.Message.__delitem__", "type": "Email", "text": "\nDelete all occurrences of the field with name name from the message\u2019s headers.\nNo exception is raised if the named field isn\u2019t present in the headers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.__getitem__()", "path": "library/email.compat32-message#email.message.Message.__getitem__", "type": "Email", "text": "\nReturn the value of the named header field. name should not include the colon\nfield separator. If the header is missing, `None` is returned; a `KeyError` is\nnever raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.__len__()", "path": "library/email.compat32-message#email.message.Message.__len__", "type": "Email", "text": "\nReturn the total number of headers, including duplicates.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.__setitem__()", "path": "library/email.compat32-message#email.message.Message.__setitem__", "type": "Email", "text": "\nAdd a header to the message with field name name and value val. The field is\nappended to the end of the message\u2019s existing fields.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message.__str__()", "path": "library/email.compat32-message#email.message.Message.__str__", "type": "Email", "text": "\nEquivalent to `as_string()`. Allows `str(msg)` to produce a string containing\nthe formatted message.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.Message: Representing an email message using the compat32 API", "path": "library/email.compat32-message", "type": "Email", "text": "\nThe `Message` class is very similar to the `EmailMessage` class, without the\nmethods added by that class, and with the default behavior of certain other\nmethods being slightly different. We also document here some methods that,\nwhile supported by the `EmailMessage` class, are not recommended unless you\nare dealing with legacy code.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message.MIMEPart", "path": "library/email.message#email.message.MIMEPart", "type": "Email", "text": "\nThis class represents a subpart of a MIME message. It is identical to\n`EmailMessage`, except that no MIME-Version headers are added when\n`set_content()` is called, since sub-parts do not need their own MIME-Version\nheaders.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message: Representing an email message", "path": "library/email.message", "type": "Email", "text": "\nSource code: Lib/email/message.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message_from_binary_file()", "path": "library/email.parser#email.message_from_binary_file", "type": "Email", "text": "\nReturn a message object structure tree from an open binary file object. This\nis equivalent to `BytesParser().parse(fp)`. _class and policy are interpreted\nas with the `BytesParser` class constructor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message_from_bytes()", "path": "library/email.parser#email.message_from_bytes", "type": "Email", "text": "\nReturn a message object structure from a bytes-like object. This is equivalent\nto `BytesParser().parsebytes(s)`. Optional _class and policy are interpreted\nas with the `BytesParser` class constructor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message_from_file()", "path": "library/email.parser#email.message_from_file", "type": "Email", "text": "\nReturn a message object structure tree from an open file object. This is\nequivalent to `Parser().parse(fp)`. _class and policy are interpreted as with\nthe `Parser` class constructor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.message_from_string()", "path": "library/email.parser#email.message_from_string", "type": "Email", "text": "\nReturn a message object structure from a string. This is equivalent to\n`Parser().parsestr(s)`. _class and policy are interpreted as with the `Parser`\nclass constructor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.mime.application.MIMEApplication", "path": "library/email.mime#email.mime.application.MIMEApplication", "type": "Email", "text": "\nModule: `email.mime.application`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.mime.audio.MIMEAudio", "path": "library/email.mime#email.mime.audio.MIMEAudio", "type": "Email", "text": "\nModule: `email.mime.audio`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.mime.base.MIMEBase", "path": "library/email.mime#email.mime.base.MIMEBase", "type": "Email", "text": "\nModule: `email.mime.base`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.mime.image.MIMEImage", "path": "library/email.mime#email.mime.image.MIMEImage", "type": "Email", "text": "\nModule: `email.mime.image`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.mime.message.MIMEMessage", "path": "library/email.mime#email.mime.message.MIMEMessage", "type": "Email", "text": "\nModule: `email.mime.message`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.mime.multipart.MIMEMultipart", "path": "library/email.mime#email.mime.multipart.MIMEMultipart", "type": "Email", "text": "\nModule: `email.mime.multipart`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.mime.nonmultipart.MIMENonMultipart", "path": "library/email.mime#email.mime.nonmultipart.MIMENonMultipart", "type": "Email", "text": "\nModule: `email.mime.nonmultipart`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.mime.text.MIMEText", "path": "library/email.mime#email.mime.text.MIMEText", "type": "Email", "text": "\nModule: `email.mime.text`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.mime: Creating email and MIME objects from scratch", "path": "library/email.mime", "type": "Email", "text": "\nSource code: Lib/email/mime/\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.parser.BytesFeedParser", "path": "library/email.parser#email.parser.BytesFeedParser", "type": "Email", "text": "\nCreate a `BytesFeedParser` instance. Optional _factory is a no-argument\ncallable; if not specified use the `message_factory` from the policy. Call\n_factory whenever a new message object is needed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.parser.BytesFeedParser.close()", "path": "library/email.parser#email.parser.BytesFeedParser.close", "type": "Email", "text": "\nComplete the parsing of all previously fed data and return the root message\nobject. It is undefined what happens if `feed()` is called after this method\nhas been called.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.parser.BytesFeedParser.feed()", "path": "library/email.parser#email.parser.BytesFeedParser.feed", "type": "Email", "text": "\nFeed the parser some more data. data should be a bytes-like object containing\none or more lines. The lines can be partial and the parser will stitch such\npartial lines together properly. The lines can have any of the three common\nline endings: carriage return, newline, or carriage return and newline (they\ncan even be mixed).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.parser.BytesHeaderParser", "path": "library/email.parser#email.parser.BytesHeaderParser", "type": "Email", "text": "\nExactly like `BytesParser`, except that headersonly defaults to `True`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.parser.BytesParser", "path": "library/email.parser#email.parser.BytesParser", "type": "Email", "text": "\nCreate a `BytesParser` instance. The _class and policy arguments have the same\nmeaning and semantics as the _factory and policy arguments of\n`BytesFeedParser`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.parser.BytesParser.parse()", "path": "library/email.parser#email.parser.BytesParser.parse", "type": "Email", "text": "\nRead all the data from the binary file-like object fp, parse the resulting\nbytes, and return the message object. fp must support both the `readline()`\nand the `read()` methods.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.parser.BytesParser.parsebytes()", "path": "library/email.parser#email.parser.BytesParser.parsebytes", "type": "Email", "text": "\nSimilar to the `parse()` method, except it takes a bytes-like object instead\nof a file-like object. Calling this method on a bytes-like object is\nequivalent to wrapping bytes in a `BytesIO` instance first and calling\n`parse()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.parser.FeedParser", "path": "library/email.parser#email.parser.FeedParser", "type": "Email", "text": "\nWorks like `BytesFeedParser` except that the input to the `feed()` method must\nbe a string. This is of limited utility, since the only way for such a message\nto be valid is for it to contain only ASCII text or, if `utf8` is `True`, no\nbinary attachments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.parser.HeaderParser", "path": "library/email.parser#email.parser.HeaderParser", "type": "Email", "text": "\nExactly like `Parser`, except that headersonly defaults to `True`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.parser.Parser", "path": "library/email.parser#email.parser.Parser", "type": "Email", "text": "\nThis class is parallel to `BytesParser`, but handles string input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.parser.Parser.parse()", "path": "library/email.parser#email.parser.Parser.parse", "type": "Email", "text": "\nRead all the data from the text-mode file-like object fp, parse the resulting\ntext, and return the root message object. fp must support both the\n`readline()` and the `read()` methods on file-like objects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.parser.Parser.parsestr()", "path": "library/email.parser#email.parser.Parser.parsestr", "type": "Email", "text": "\nSimilar to the `parse()` method, except it takes a string object instead of a\nfile-like object. Calling this method on a string is equivalent to wrapping\ntext in a `StringIO` instance first and calling `parse()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.parser: Parsing email messages", "path": "library/email.parser", "type": "Email", "text": "\nSource code: Lib/email/parser.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.compat32", "path": "library/email.policy#email.policy.compat32", "type": "Email", "text": "\nAn instance of `Compat32`, providing backward compatibility with the behavior\nof the email package in Python 3.2.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Compat32", "path": "library/email.policy#email.policy.Compat32", "type": "Email", "text": "\nThis concrete `Policy` is the backward compatibility policy. It replicates the\nbehavior of the email package in Python 3.2. The `policy` module also defines\nan instance of this class, `compat32`, that is used as the default policy.\nThus the default behavior of the email package is to maintain compatibility\nwith Python 3.2.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Compat32.fold()", "path": "library/email.policy#email.policy.Compat32.fold", "type": "Email", "text": "\nHeaders are folded using the `Header` folding algorithm, which preserves\nexisting line breaks in the value, and wraps each resulting line to the\n`max_line_length`. Non-ASCII binary data are CTE encoded using the\n`unknown-8bit` charset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Compat32.fold_binary()", "path": "library/email.policy#email.policy.Compat32.fold_binary", "type": "Email", "text": "\nHeaders are folded using the `Header` folding algorithm, which preserves\nexisting line breaks in the value, and wraps each resulting line to the\n`max_line_length`. If `cte_type` is `7bit`, non-ascii binary data is CTE\nencoded using the `unknown-8bit` charset. Otherwise the original source header\nis used, with its existing line breaks and any (RFC invalid) binary data it\nmay contain.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Compat32.header_fetch_parse()", "path": "library/email.policy#email.policy.Compat32.header_fetch_parse", "type": "Email", "text": "\nIf the value contains binary data, it is converted into a `Header` object\nusing the `unknown-8bit` charset. Otherwise it is returned unmodified.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Compat32.header_source_parse()", "path": "library/email.policy#email.policy.Compat32.header_source_parse", "type": "Email", "text": "\nThe name is parsed as everything up to the \u2018`:`\u2019 and returned unmodified. The\nvalue is determined by stripping leading whitespace off the remainder of the\nfirst line, joining all subsequent lines together, and stripping any trailing\ncarriage return or linefeed characters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Compat32.header_store_parse()", "path": "library/email.policy#email.policy.Compat32.header_store_parse", "type": "Email", "text": "\nThe name and value are returned unmodified.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Compat32.mangle_from_", "path": "library/email.policy#email.policy.Compat32.mangle_from_", "type": "Email", "text": "\nThe default is `True`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.default", "path": "library/email.policy#email.policy.default", "type": "Email", "text": "\nAn instance of `EmailPolicy` with all defaults unchanged. This policy uses the\nstandard Python `\\n` line endings rather than the RFC-correct `\\r\\n`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.EmailPolicy", "path": "library/email.policy#email.policy.EmailPolicy", "type": "Email", "text": "\nThis concrete `Policy` provides behavior that is intended to be fully\ncompliant with the current email RFCs. These include (but are not limited to)\nRFC 5322, RFC 2047, and the current MIME RFCs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.EmailPolicy.content_manager", "path": "library/email.policy#email.policy.EmailPolicy.content_manager", "type": "Email", "text": "\nAn object with at least two methods: get_content and set_content. When the\n`get_content()` or `set_content()` method of an `EmailMessage` object is\ncalled, it calls the corresponding method of this object, passing it the\nmessage object as its first argument, and any arguments or keywords that were\npassed to it as additional arguments. By default `content_manager` is set to\n`raw_data_manager`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.EmailPolicy.fold()", "path": "library/email.policy#email.policy.EmailPolicy.fold", "type": "Email", "text": "\nHeader folding is controlled by the `refold_source` policy setting. A value is\nconsidered to be a \u2018source value\u2019 if and only if it does not have a `name`\nattribute (having a `name` attribute means it is a header object of some\nsort). If a source value needs to be refolded according to the policy, it is\nconverted into a header object by passing the name and the value with any CR\nand LF characters removed to the `header_factory`. Folding of a header object\nis done by calling its `fold` method with the current policy.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.EmailPolicy.fold_binary()", "path": "library/email.policy#email.policy.EmailPolicy.fold_binary", "type": "Email", "text": "\nThe same as `fold()` if `cte_type` is `7bit`, except that the returned value\nis bytes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.EmailPolicy.header_factory", "path": "library/email.policy#email.policy.EmailPolicy.header_factory", "type": "Email", "text": "\nA callable that takes two arguments, `name` and `value`, where `name` is a\nheader field name and `value` is an unfolded header field value, and returns a\nstring subclass that represents that header. A default `header_factory` (see\n`headerregistry`) is provided that supports custom parsing for the various\naddress and date RFC 5322 header field types, and the major MIME header field\nstypes. Support for additional custom parsing will be added in the future.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.EmailPolicy.header_fetch_parse()", "path": "library/email.policy#email.policy.EmailPolicy.header_fetch_parse", "type": "Email", "text": "\nIf the value has a `name` attribute, it is returned to unmodified. Otherwise\nthe name, and the value with any CR or LF characters removed, are passed to\nthe `header_factory`, and the resulting header object is returned. Any\nsurrogateescaped bytes get turned into the unicode unknown-character glyph.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.EmailPolicy.header_max_count()", "path": "library/email.policy#email.policy.EmailPolicy.header_max_count", "type": "Email", "text": "\nReturns the value of the `max_count` attribute of the specialized class used\nto represent the header with the given name.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.EmailPolicy.header_source_parse()", "path": "library/email.policy#email.policy.EmailPolicy.header_source_parse", "type": "Email", "text": "\nThe name is parsed as everything up to the \u2018`:`\u2019 and returned unmodified. The\nvalue is determined by stripping leading whitespace off the remainder of the\nfirst line, joining all subsequent lines together, and stripping any trailing\ncarriage return or linefeed characters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.EmailPolicy.header_store_parse()", "path": "library/email.policy#email.policy.EmailPolicy.header_store_parse", "type": "Email", "text": "\nThe name is returned unchanged. If the input value has a `name` attribute and\nit matches name ignoring case, the value is returned unchanged. Otherwise the\nname and value are passed to `header_factory`, and the resulting header object\nis returned as the value. In this case a `ValueError` is raised if the input\nvalue contains CR or LF characters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.EmailPolicy.refold_source", "path": "library/email.policy#email.policy.EmailPolicy.refold_source", "type": "Email", "text": "\nIf the value for a header in the `Message` object originated from a `parser`\n(as opposed to being set by a program), this attribute indicates whether or\nnot a generator should refold that value when transforming the message back\ninto serialized form. The possible values are:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.EmailPolicy.utf8", "path": "library/email.policy#email.policy.EmailPolicy.utf8", "type": "Email", "text": "\nIf `False`, follow RFC 5322, supporting non-ASCII characters in headers by\nencoding them as \u201cencoded words\u201d. If `True`, follow RFC 6532 and use `utf-8`\nencoding for headers. Messages formatted in this way may be passed to SMTP\nservers that support the `SMTPUTF8` extension (RFC 6531).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.HTTP", "path": "library/email.policy#email.policy.HTTP", "type": "Email", "text": "\nSuitable for serializing headers with for use in HTTP traffic. Like `SMTP`\nexcept that `max_line_length` is set to `None` (unlimited).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Policy", "path": "library/email.policy#email.policy.Policy", "type": "Email", "text": "\nThis is the abstract base class for all policy classes. It provides default\nimplementations for a couple of trivial methods, as well as the implementation\nof the immutability property, the `clone()` method, and the constructor\nsemantics.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Policy.clone()", "path": "library/email.policy#email.policy.Policy.clone", "type": "Email", "text": "\nReturn a new `Policy` instance whose attributes have the same values as the\ncurrent instance, except where those attributes are given new values by the\nkeyword arguments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Policy.cte_type", "path": "library/email.policy#email.policy.Policy.cte_type", "type": "Email", "text": "\nControls the type of Content Transfer Encodings that may be or are required to\nbe used. The possible values are:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Policy.fold()", "path": "library/email.policy#email.policy.Policy.fold", "type": "Email", "text": "\nThe email package calls this method with the name and value currently stored\nin the `Message` for a given header. The method should return a string that\nrepresents that header \u201cfolded\u201d correctly (according to the policy settings)\nby composing the name with the value and inserting `linesep` characters at the\nappropriate places. See RFC 5322 for a discussion of the rules for folding\nemail headers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Policy.fold_binary()", "path": "library/email.policy#email.policy.Policy.fold_binary", "type": "Email", "text": "\nThe same as `fold()`, except that the returned value should be a bytes object\nrather than a string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Policy.handle_defect()", "path": "library/email.policy#email.policy.Policy.handle_defect", "type": "Email", "text": "\nHandle a defect found on obj. When the email package calls this method, defect\nwill always be a subclass of `Defect`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Policy.header_fetch_parse()", "path": "library/email.policy#email.policy.Policy.header_fetch_parse", "type": "Email", "text": "\nThe email package calls this method with the name and value currently stored\nin the `Message` when that header is requested by the application program, and\nwhatever the method returns is what is passed back to the application as the\nvalue of the header being retrieved. Note that there may be more than one\nheader with the same name stored in the `Message`; the method is passed the\nspecific name and value of the header destined to be returned to the\napplication.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Policy.header_max_count()", "path": "library/email.policy#email.policy.Policy.header_max_count", "type": "Email", "text": "\nReturn the maximum allowed number of headers named name.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Policy.header_source_parse()", "path": "library/email.policy#email.policy.Policy.header_source_parse", "type": "Email", "text": "\nThe email package calls this method with a list of strings, each string ending\nwith the line separation characters found in the source being parsed. The\nfirst line includes the field header name and separator. All whitespace in the\nsource is preserved. The method should return the `(name, value)` tuple that\nis to be stored in the `Message` to represent the parsed header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Policy.header_store_parse()", "path": "library/email.policy#email.policy.Policy.header_store_parse", "type": "Email", "text": "\nThe email package calls this method with the name and value provided by the\napplication program when the application program is modifying a `Message`\nprogrammatically (as opposed to a `Message` created by a parser). The method\nshould return the `(name, value)` tuple that is to be stored in the `Message`\nto represent the header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Policy.linesep", "path": "library/email.policy#email.policy.Policy.linesep", "type": "Email", "text": "\nThe string to be used to terminate lines in serialized output. The default is\n`\\n` because that\u2019s the internal end-of-line discipline used by Python, though\n`\\r\\n` is required by the RFCs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Policy.mangle_from_", "path": "library/email.policy#email.policy.Policy.mangle_from_", "type": "Email", "text": "\nIf `True`, lines starting with \u201cFrom \u201c in the body are escaped by putting a\n`>` in front of them. This parameter is used when the message is being\nserialized by a generator. Default: `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Policy.max_line_length", "path": "library/email.policy#email.policy.Policy.max_line_length", "type": "Email", "text": "\nThe maximum length of any line in the serialized output, not counting the end\nof line character(s). Default is 78, per RFC 5322. A value of `0` or `None`\nindicates that no line wrapping should be done at all.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Policy.message_factory", "path": "library/email.policy#email.policy.Policy.message_factory", "type": "Email", "text": "\nA factory function for constructing a new empty message object. Used by the\nparser when building messages. Defaults to `None`, in which case `Message` is\nused.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Policy.raise_on_defect", "path": "library/email.policy#email.policy.Policy.raise_on_defect", "type": "Email", "text": "\nIf `True`, any defects encountered will be raised as errors. If `False` (the\ndefault), defects will be passed to the `register_defect()` method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.Policy.register_defect()", "path": "library/email.policy#email.policy.Policy.register_defect", "type": "Email", "text": "\nRegister a defect on obj. In the email package, defect will always be a\nsubclass of `Defect`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.SMTP", "path": "library/email.policy#email.policy.SMTP", "type": "Email", "text": "\nSuitable for serializing messages in conformance with the email RFCs. Like\n`default`, but with `linesep` set to `\\r\\n`, which is RFC compliant.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.SMTPUTF8", "path": "library/email.policy#email.policy.SMTPUTF8", "type": "Email", "text": "\nThe same as `SMTP` except that `utf8` is `True`. Useful for serializing\nmessages to a message store without using encoded words in the headers. Should\nonly be used for SMTP transmission if the sender or recipient addresses have\nnon-ASCII characters (the `smtplib.SMTP.send_message()` method handles this\nautomatically).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy.strict", "path": "library/email.policy#email.policy.strict", "type": "Email", "text": "\nConvenience instance. The same as `default` except that `raise_on_defect` is\nset to `True`. This allows any policy to be made strict by writing:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.policy: Policy Objects", "path": "library/email.policy", "type": "Email", "text": "\nNew in version 3.3.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.utils.collapse_rfc2231_value()", "path": "library/email.utils#email.utils.collapse_rfc2231_value", "type": "Email", "text": "\nWhen a header parameter is encoded in RFC 2231 format, `Message.get_param` may\nreturn a 3-tuple containing the character set, language, and value.\n`collapse_rfc2231_value()` turns this into a unicode string. Optional errors\nis passed to the errors argument of `str`\u2019s `encode()` method; it defaults to\n`'replace'`. Optional fallback_charset specifies the character set to use if\nthe one in the RFC 2231 header is not known by Python; it defaults to `'us-\nascii'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.utils.decode_params()", "path": "library/email.utils#email.utils.decode_params", "type": "Email", "text": "\nDecode parameters list according to RFC 2231. params is a sequence of 2-tuples\ncontaining elements of the form `(content-type, string-value)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.utils.decode_rfc2231()", "path": "library/email.utils#email.utils.decode_rfc2231", "type": "Email", "text": "\nDecode the string s according to RFC 2231.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.utils.encode_rfc2231()", "path": "library/email.utils#email.utils.encode_rfc2231", "type": "Email", "text": "\nEncode the string s according to RFC 2231. Optional charset and language, if\ngiven is the character set name and language name to use. If neither is given,\ns is returned as-is. If charset is given but language is not, the string is\nencoded using the empty string for language.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.utils.formataddr()", "path": "library/email.utils#email.utils.formataddr", "type": "Email", "text": "\nThe inverse of `parseaddr()`, this takes a 2-tuple of the form `(realname,\nemail_address)` and returns the string value suitable for a To or Cc header.\nIf the first element of pair is false, then the second element is returned\nunmodified.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.utils.formatdate()", "path": "library/email.utils#email.utils.formatdate", "type": "Email", "text": "\nReturns a date string as per RFC 2822, e.g.:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.utils.format_datetime()", "path": "library/email.utils#email.utils.format_datetime", "type": "Email", "text": "\nLike `formatdate`, but the input is a `datetime` instance. If it is a naive\ndatetime, it is assumed to be \u201cUTC with no information about the source\ntimezone\u201d, and the conventional `-0000` is used for the timezone. If it is an\naware `datetime`, then the numeric timezone offset is used. If it is an aware\ntimezone with offset zero, then usegmt may be set to `True`, in which case the\nstring `GMT` is used instead of the numeric timezone offset. This provides a\nway to generate standards conformant HTTP date headers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.utils.getaddresses()", "path": "library/email.utils#email.utils.getaddresses", "type": "Email", "text": "\nThis method returns a list of 2-tuples of the form returned by `parseaddr()`.\nfieldvalues is a sequence of header field values as might be returned by\n`Message.get_all`. Here\u2019s a simple example that gets all the recipients of a\nmessage:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.utils.localtime()", "path": "library/email.utils#email.utils.localtime", "type": "Email", "text": "\nReturn local time as an aware datetime object. If called without arguments,\nreturn current time. Otherwise dt argument should be a `datetime` instance,\nand it is converted to the local time zone according to the system time zone\ndatabase. If dt is naive (that is, `dt.tzinfo` is `None`), it is assumed to be\nin local time. In this case, a positive or zero value for isdst causes\n`localtime` to presume initially that summer time (for example, Daylight\nSaving Time) is or is not (respectively) in effect for the specified time. A\nnegative value for isdst causes the `localtime` to attempt to divine whether\nsummer time is in effect for the specified time.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.utils.make_msgid()", "path": "library/email.utils#email.utils.make_msgid", "type": "Email", "text": "\nReturns a string suitable for an RFC 2822-compliant Message-ID header.\nOptional idstring if given, is a string used to strengthen the uniqueness of\nthe message id. Optional domain if given provides the portion of the msgid\nafter the \u2018@\u2019. The default is the local hostname. It is not normally necessary\nto override this default, but may be useful certain cases, such as a\nconstructing distributed system that uses a consistent domain name across\nmultiple hosts.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.utils.mktime_tz()", "path": "library/email.utils#email.utils.mktime_tz", "type": "Email", "text": "\nTurn a 10-tuple as returned by `parsedate_tz()` into a UTC timestamp (seconds\nsince the Epoch). If the timezone item in the tuple is `None`, assume local\ntime.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.utils.parseaddr()", "path": "library/email.utils#email.utils.parseaddr", "type": "Email", "text": "\nParse address \u2013 which should be the value of some address-containing field\nsuch as To or Cc \u2013 into its constituent realname and email address parts.\nReturns a tuple of that information, unless the parse fails, in which case a\n2-tuple of `('', '')` is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.utils.parsedate()", "path": "library/email.utils#email.utils.parsedate", "type": "Email", "text": "\nAttempts to parse a date according to the rules in RFC 2822. however, some\nmailers don\u2019t follow that format as specified, so `parsedate()` tries to guess\ncorrectly in such cases. date is a string containing an RFC 2822 date, such as\n`\"Mon, 20 Nov 1995 19:12:08 -0500\"`. If it succeeds in parsing the date,\n`parsedate()` returns a 9-tuple that can be passed directly to\n`time.mktime()`; otherwise `None` will be returned. Note that indexes 6, 7,\nand 8 of the result tuple are not usable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.utils.parsedate_to_datetime()", "path": "library/email.utils#email.utils.parsedate_to_datetime", "type": "Email", "text": "\nThe inverse of `format_datetime()`. Performs the same function as\n`parsedate()`, but on success returns a `datetime`. If the input date has a\ntimezone of `-0000`, the `datetime` will be a naive `datetime`, and if the\ndate is conforming to the RFCs it will represent a time in UTC but with no\nindication of the actual source timezone of the message the date comes from.\nIf the input date has any other valid timezone offset, the `datetime` will be\nan aware `datetime` with the corresponding a `timezone` `tzinfo`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.utils.parsedate_tz()", "path": "library/email.utils#email.utils.parsedate_tz", "type": "Email", "text": "\nPerforms the same function as `parsedate()`, but returns either `None` or a\n10-tuple; the first 9 elements make up a tuple that can be passed directly to\n`time.mktime()`, and the tenth is the offset of the date\u2019s timezone from UTC\n(which is the official term for Greenwich Mean Time) 1. If the input string\nhas no timezone, the last element of the tuple returned is `0`, which\nrepresents UTC. Note that indexes 6, 7, and 8 of the result tuple are not\nusable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.utils.quote()", "path": "library/email.utils#email.utils.quote", "type": "Email", "text": "\nReturn a new string with backslashes in str replaced by two backslashes, and\ndouble quotes replaced by backslash-double quote.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.utils.unquote()", "path": "library/email.utils#email.utils.unquote", "type": "Email", "text": "\nReturn a new string which is an unquoted version of str. If str ends and\nbegins with double quotes, they are stripped off. Likewise if str ends and\nbegins with angle brackets, they are stripped off.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email.utils: Miscellaneous utilities", "path": "library/email.utils", "type": "Email", "text": "\nSource code: Lib/email/utils.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "email: Examples", "path": "library/email.examples", "type": "Email", "text": "\nHere are a few examples of how to use the `email` package to read, write, and\nsend simple email messages, as well as more complex MIME messages.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "encodings.idna.nameprep()", "path": "library/codecs#encodings.idna.nameprep", "type": "Binary Data", "text": "\nReturn the nameprepped version of label. The implementation currently assumes\nquery strings, so `AllowUnassigned` is true.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "encodings.idna.ToASCII()", "path": "library/codecs#encodings.idna.ToASCII", "type": "Binary Data", "text": "\nConvert a label to ASCII, as specified in RFC 3490. `UseSTD3ASCIIRules` is\nassumed to be false.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "encodings.idna.ToUnicode()", "path": "library/codecs#encodings.idna.ToUnicode", "type": "Binary Data", "text": "\nConvert a label to Unicode, as specified in RFC 3490.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ensurepip", "path": "library/ensurepip", "type": "Software Packaging & Distribution", "text": "\nNew in version 3.4.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ensurepip.bootstrap()", "path": "library/ensurepip#ensurepip.bootstrap", "type": "Software Packaging & Distribution", "text": "\nBootstraps `pip` into the current or designated environment.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ensurepip.version()", "path": "library/ensurepip#ensurepip.version", "type": "Software Packaging & Distribution", "text": "\nReturns a string specifying the bundled version of pip that will be installed\nwhen bootstrapping an environment.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "enum", "path": "library/enum", "type": "Data Types", "text": "\nNew in version 3.4.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "enum.auto", "path": "library/enum#enum.auto", "type": "Data Types", "text": "\nInstances are replaced with an appropriate value for Enum members. By default,\nthe initial value starts at 1.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "enum.Enum", "path": "library/enum#enum.Enum", "type": "Data Types", "text": "\nBase class for creating enumerated constants. See section Functional API for\nan alternate construction syntax.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "enum.Flag", "path": "library/enum#enum.Flag", "type": "Data Types", "text": "\nBase class for creating enumerated constants that can be combined using the\nbitwise operations without losing their `Flag` membership.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "enum.IntEnum", "path": "library/enum#enum.IntEnum", "type": "Data Types", "text": "\nBase class for creating enumerated constants that are also subclasses of\n`int`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "enum.IntFlag", "path": "library/enum#enum.IntFlag", "type": "Data Types", "text": "\nBase class for creating enumerated constants that can be combined using the\nbitwise operators without losing their `IntFlag` membership. `IntFlag` members\nare also subclasses of `int`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "enum.unique()", "path": "library/enum#enum.unique", "type": "Data Types", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "enumerate()", "path": "library/functions#enumerate", "type": "Built-in Functions", "text": "\nReturn an enumerate object. iterable must be a sequence, an iterator, or some\nother object which supports iteration. The `__next__()` method of the iterator\nreturned by `enumerate()` returns a tuple containing a count (from start which\ndefaults to 0) and the values obtained from iterating over iterable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "EnvironmentError", "path": "library/exceptions#EnvironmentError", "type": "Built-in Exceptions", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "EOFError", "path": "library/exceptions#EOFError", "type": "Built-in Exceptions", "text": "\nRaised when the `input()` function hits an end-of-file condition (EOF) without\nreading any data. (N.B.: the `io.IOBase.read()` and `io.IOBase.readline()`\nmethods return an empty string when they hit EOF.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "errno", "path": "library/errno", "type": "Operating System", "text": "\nThis module makes available standard `errno` system symbols. The value of each\nsymbol is the corresponding integer value. The names and descriptions are\nborrowed from `linux/include/errno.h`, which should be pretty all-inclusive.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "eval()", "path": "library/functions#eval", "type": "Built-in Functions", "text": "\nThe arguments are a string and optional globals and locals. If provided,\nglobals must be a dictionary. If provided, locals can be any mapping object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Event Loop", "path": "library/asyncio-eventloop", "type": "Asynchronous I/O", "text": "\nSource code: Lib/asyncio/events.py, Lib/asyncio/base_events.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Exception", "path": "library/exceptions#Exception", "type": "Built-in Exceptions", "text": "\nAll built-in, non-system-exiting exceptions are derived from this class. All\nuser-defined exceptions should also be derived from this class.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Exceptions", "path": "library/asyncio-exceptions", "type": "Asynchronous I/O", "text": "\nSource code: Lib/asyncio/exceptions.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Exceptions", "path": "library/exceptions", "type": "Built-in Exceptions", "text": "\nIn Python, all exceptions must be instances of a class that derives from\n`BaseException`. In a `try` statement with an `except` clause that mentions a\nparticular class, that clause also handles any exception classes derived from\nthat class (but not exception classes from which it is derived). Two exception\nclasses that are not related via subclassing are never equivalent, even if\nthey have the same name.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "exec()", "path": "library/functions#exec", "type": "Built-in Functions", "text": "\nThis function supports dynamic execution of Python code. object must be either\na string or a code object. If it is a string, the string is parsed as a suite\nof Python statements which is then executed (unless a syntax error occurs). 1\nIf it is a code object, it is simply executed. In all cases, the code that\u2019s\nexecuted is expected to be valid as file input (see the section \u201cFile input\u201d\nin the Reference Manual). Be aware that the `nonlocal`, `yield`, and `return`\nstatements may not be used outside of function definitions even within the\ncontext of code passed to the `exec()` function. The return value is `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "exit", "path": "library/constants#exit", "type": "Built-in Constants", "text": "\nObjects that when printed, print a message like \u201cUse quit() or Ctrl-D (i.e.\nEOF) to exit\u201d, and when called, raise `SystemExit` with the specified exit\ncode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "False", "path": "library/constants#False", "type": "Built-in Constants", "text": "\nThe false value of the `bool` type. Assignments to `False` are illegal and\nraise a `SyntaxError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "faulthandler", "path": "library/faulthandler", "type": "Debugging & Profiling", "text": "\nNew in version 3.3.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "faulthandler.cancel_dump_traceback_later()", "path": "library/faulthandler#faulthandler.cancel_dump_traceback_later", "type": "Debugging & Profiling", "text": "\nCancel the last call to `dump_traceback_later()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "faulthandler.disable()", "path": "library/faulthandler#faulthandler.disable", "type": "Debugging & Profiling", "text": "\nDisable the fault handler: uninstall the signal handlers installed by\n`enable()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "faulthandler.dump_traceback()", "path": "library/faulthandler#faulthandler.dump_traceback", "type": "Debugging & Profiling", "text": "\nDump the tracebacks of all threads into file. If all_threads is `False`, dump\nonly the current thread.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "faulthandler.dump_traceback_later()", "path": "library/faulthandler#faulthandler.dump_traceback_later", "type": "Debugging & Profiling", "text": "\nDump the tracebacks of all threads, after a timeout of timeout seconds, or\nevery timeout seconds if repeat is `True`. If exit is `True`, call `_exit()`\nwith status=1 after dumping the tracebacks. (Note `_exit()` exits the process\nimmediately, which means it doesn\u2019t do any cleanup like flushing file\nbuffers.) If the function is called twice, the new call replaces previous\nparameters and resets the timeout. The timer has a sub-second resolution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "faulthandler.enable()", "path": "library/faulthandler#faulthandler.enable", "type": "Debugging & Profiling", "text": "\nEnable the fault handler: install handlers for the `SIGSEGV`, `SIGFPE`,\n`SIGABRT`, `SIGBUS` and `SIGILL` signals to dump the Python traceback. If\nall_threads is `True`, produce tracebacks for every running thread. Otherwise,\ndump only the current thread.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "faulthandler.is_enabled()", "path": "library/faulthandler#faulthandler.is_enabled", "type": "Debugging & Profiling", "text": "\nCheck if the fault handler is enabled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "faulthandler.register()", "path": "library/faulthandler#faulthandler.register", "type": "Debugging & Profiling", "text": "\nRegister a user signal: install a handler for the signum signal to dump the\ntraceback of all threads, or of the current thread if all_threads is `False`,\ninto file. Call the previous handler if chain is `True`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "faulthandler.unregister()", "path": "library/faulthandler#faulthandler.unregister", "type": "Debugging & Profiling", "text": "\nUnregister a user signal: uninstall the handler of the signum signal installed\nby `register()`. Return `True` if the signal was registered, `False`\notherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fcntl", "path": "library/fcntl", "type": "Unix", "text": "\nThis module performs file control and I/O control on file descriptors. It is\nan interface to the `fcntl()` and `ioctl()` Unix routines. For a complete\ndescription of these calls, see fcntl(2) and ioctl(2) Unix manual pages.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fcntl.fcntl()", "path": "library/fcntl#fcntl.fcntl", "type": "Unix", "text": "\nPerform the operation cmd on file descriptor fd (file objects providing a\n`fileno()` method are accepted as well). The values used for cmd are operating\nsystem dependent, and are available as constants in the `fcntl` module, using\nthe same names as used in the relevant C header files. The argument arg can\neither be an integer value, or a `bytes` object. With an integer value, the\nreturn value of this function is the integer return value of the C `fcntl()`\ncall. When the argument is bytes it represents a binary structure, e.g.\ncreated by `struct.pack()`. The binary data is copied to a buffer whose\naddress is passed to the C `fcntl()` call. The return value after a successful\ncall is the contents of the buffer, converted to a `bytes` object. The length\nof the returned object will be the same as the length of the arg argument.\nThis is limited to 1024 bytes. If the information returned in the buffer by\nthe operating system is larger than 1024 bytes, this is most likely to result\nin a segmentation violation or a more subtle data corruption.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fcntl.flock()", "path": "library/fcntl#fcntl.flock", "type": "Unix", "text": "\nPerform the lock operation operation on file descriptor fd (file objects\nproviding a `fileno()` method are accepted as well). See the Unix manual\nflock(2) for details. (On some systems, this function is emulated using\n`fcntl()`.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fcntl.ioctl()", "path": "library/fcntl#fcntl.ioctl", "type": "Unix", "text": "\nThis function is identical to the `fcntl()` function, except that the argument\nhandling is even more complicated.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fcntl.lockf()", "path": "library/fcntl#fcntl.lockf", "type": "Unix", "text": "\nThis is essentially a wrapper around the `fcntl()` locking calls. fd is the\nfile descriptor (file objects providing a `fileno()` method are accepted as\nwell) of the file to lock or unlock, and cmd is one of the following values:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "File and Directory Access", "path": "library/filesys", "type": "File & Directory Access", "text": "\nThe modules described in this chapter deal with disk files and directories.\nFor example, there are modules for reading the properties of files,\nmanipulating paths in a portable way, and creating temporary files. The full\nlist of modules in this chapter is:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp", "path": "library/filecmp", "type": "File & Directory Access", "text": "\nSource code: Lib/filecmp.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.clear_cache()", "path": "library/filecmp#filecmp.clear_cache", "type": "File & Directory Access", "text": "\nClear the filecmp cache. This may be useful if a file is compared so quickly\nafter it is modified that it is within the mtime resolution of the underlying\nfilesystem.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.cmp()", "path": "library/filecmp#filecmp.cmp", "type": "File & Directory Access", "text": "\nCompare the files named f1 and f2, returning `True` if they seem equal,\n`False` otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.cmpfiles()", "path": "library/filecmp#filecmp.cmpfiles", "type": "File & Directory Access", "text": "\nCompare the files in the two directories dir1 and dir2 whose names are given\nby common.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.DEFAULT_IGNORES", "path": "library/filecmp#filecmp.DEFAULT_IGNORES", "type": "File & Directory Access", "text": "\nNew in version 3.4.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.dircmp", "path": "library/filecmp#filecmp.dircmp", "type": "File & Directory Access", "text": "\nConstruct a new directory comparison object, to compare the directories a and\nb. ignore is a list of names to ignore, and defaults to\n`filecmp.DEFAULT_IGNORES`. hide is a list of names to hide, and defaults to\n`[os.curdir, os.pardir]`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.dircmp.common", "path": "library/filecmp#filecmp.dircmp.common", "type": "File & Directory Access", "text": "\nFiles and subdirectories in both a and b.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.dircmp.common_dirs", "path": "library/filecmp#filecmp.dircmp.common_dirs", "type": "File & Directory Access", "text": "\nSubdirectories in both a and b.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.dircmp.common_files", "path": "library/filecmp#filecmp.dircmp.common_files", "type": "File & Directory Access", "text": "\nFiles in both a and b.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.dircmp.common_funny", "path": "library/filecmp#filecmp.dircmp.common_funny", "type": "File & Directory Access", "text": "\nNames in both a and b, such that the type differs between the directories, or\nnames for which `os.stat()` reports an error.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.dircmp.diff_files", "path": "library/filecmp#filecmp.dircmp.diff_files", "type": "File & Directory Access", "text": "\nFiles which are in both a and b, whose contents differ according to the\nclass\u2019s file comparison operator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.dircmp.funny_files", "path": "library/filecmp#filecmp.dircmp.funny_files", "type": "File & Directory Access", "text": "\nFiles which are in both a and b, but could not be compared.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.dircmp.left", "path": "library/filecmp#filecmp.dircmp.left", "type": "File & Directory Access", "text": "\nThe directory a.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.dircmp.left_list", "path": "library/filecmp#filecmp.dircmp.left_list", "type": "File & Directory Access", "text": "\nFiles and subdirectories in a, filtered by hide and ignore.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.dircmp.left_only", "path": "library/filecmp#filecmp.dircmp.left_only", "type": "File & Directory Access", "text": "\nFiles and subdirectories only in a.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.dircmp.report()", "path": "library/filecmp#filecmp.dircmp.report", "type": "File & Directory Access", "text": "\nPrint (to `sys.stdout`) a comparison between a and b.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.dircmp.report_full_closure()", "path": "library/filecmp#filecmp.dircmp.report_full_closure", "type": "File & Directory Access", "text": "\nPrint a comparison between a and b and common subdirectories (recursively).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.dircmp.report_partial_closure()", "path": "library/filecmp#filecmp.dircmp.report_partial_closure", "type": "File & Directory Access", "text": "\nPrint a comparison between a and b and common immediate subdirectories.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.dircmp.right", "path": "library/filecmp#filecmp.dircmp.right", "type": "File & Directory Access", "text": "\nThe directory b.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.dircmp.right_list", "path": "library/filecmp#filecmp.dircmp.right_list", "type": "File & Directory Access", "text": "\nFiles and subdirectories in b, filtered by hide and ignore.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.dircmp.right_only", "path": "library/filecmp#filecmp.dircmp.right_only", "type": "File & Directory Access", "text": "\nFiles and subdirectories only in b.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.dircmp.same_files", "path": "library/filecmp#filecmp.dircmp.same_files", "type": "File & Directory Access", "text": "\nFiles which are identical in both a and b, using the class\u2019s file comparison\noperator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filecmp.dircmp.subdirs", "path": "library/filecmp#filecmp.dircmp.subdirs", "type": "File & Directory Access", "text": "\nA dictionary mapping names in `common_dirs` to `dircmp` objects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "FileExistsError", "path": "library/exceptions#FileExistsError", "type": "Built-in Exceptions", "text": "\nRaised when trying to create a file or directory which already exists.\nCorresponds to `errno` `EEXIST`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fileinput", "path": "library/fileinput", "type": "File & Directory Access", "text": "\nSource code: Lib/fileinput.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fileinput.close()", "path": "library/fileinput#fileinput.close", "type": "File & Directory Access", "text": "\nClose the sequence.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fileinput.FileInput", "path": "library/fileinput#fileinput.FileInput", "type": "File & Directory Access", "text": "\nClass `FileInput` is the implementation; its methods `filename()`, `fileno()`,\n`lineno()`, `filelineno()`, `isfirstline()`, `isstdin()`, `nextfile()` and\n`close()` correspond to the functions of the same name in the module. In\naddition it has a `readline()` method which returns the next input line, and a\n`__getitem__()` method which implements the sequence behavior. The sequence\nmust be accessed in strictly sequential order; random access and `readline()`\ncannot be mixed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fileinput.filelineno()", "path": "library/fileinput#fileinput.filelineno", "type": "File & Directory Access", "text": "\nReturn the line number in the current file. Before the first line has been\nread, returns `0`. After the last line of the last file has been read, returns\nthe line number of that line within the file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fileinput.filename()", "path": "library/fileinput#fileinput.filename", "type": "File & Directory Access", "text": "\nReturn the name of the file currently being read. Before the first line has\nbeen read, returns `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fileinput.fileno()", "path": "library/fileinput#fileinput.fileno", "type": "File & Directory Access", "text": "\nReturn the integer \u201cfile descriptor\u201d for the current file. When no file is\nopened (before the first line and between files), returns `-1`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fileinput.hook_compressed()", "path": "library/fileinput#fileinput.hook_compressed", "type": "File & Directory Access", "text": "\nTransparently opens files compressed with gzip and bzip2 (recognized by the\nextensions `'.gz'` and `'.bz2'`) using the `gzip` and `bz2` modules. If the\nfilename extension is not `'.gz'` or `'.bz2'`, the file is opened normally\n(ie, using `open()` without any decompression).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fileinput.hook_encoded()", "path": "library/fileinput#fileinput.hook_encoded", "type": "File & Directory Access", "text": "\nReturns a hook which opens each file with `open()`, using the given encoding\nand errors to read the file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fileinput.input()", "path": "library/fileinput#fileinput.input", "type": "File & Directory Access", "text": "\nCreate an instance of the `FileInput` class. The instance will be used as\nglobal state for the functions of this module, and is also returned to use\nduring iteration. The parameters to this function will be passed along to the\nconstructor of the `FileInput` class.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fileinput.isfirstline()", "path": "library/fileinput#fileinput.isfirstline", "type": "File & Directory Access", "text": "\nReturn `True` if the line just read is the first line of its file, otherwise\nreturn `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fileinput.isstdin()", "path": "library/fileinput#fileinput.isstdin", "type": "File & Directory Access", "text": "\nReturn `True` if the last line was read from `sys.stdin`, otherwise return\n`False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fileinput.lineno()", "path": "library/fileinput#fileinput.lineno", "type": "File & Directory Access", "text": "\nReturn the cumulative line number of the line that has just been read. Before\nthe first line has been read, returns `0`. After the last line of the last\nfile has been read, returns the line number of that line.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fileinput.nextfile()", "path": "library/fileinput#fileinput.nextfile", "type": "File & Directory Access", "text": "\nClose the current file so that the next iteration will read the first line\nfrom the next file (if any); lines not read from the file will not count\ntowards the cumulative line count. The filename is not changed until after the\nfirst line of the next file has been read. Before the first line has been\nread, this function has no effect; it cannot be used to skip the first file.\nAfter the last line of the last file has been read, this function has no\neffect.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "FileNotFoundError", "path": "library/exceptions#FileNotFoundError", "type": "Built-in Exceptions", "text": "\nRaised when a file or directory is requested but doesn\u2019t exist. Corresponds to\n`errno` `ENOENT`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "filter()", "path": "library/functions#filter", "type": "Built-in Functions", "text": "\nConstruct an iterator from those elements of iterable for which function\nreturns true. iterable may be either a sequence, a container which supports\niteration, or an iterator. If function is `None`, the identity function is\nassumed, that is, all elements of iterable that are false are removed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "float", "path": "library/functions#float", "type": "Built-in Functions", "text": "\nReturn a floating point number constructed from a number or string x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "float.as_integer_ratio()", "path": "library/stdtypes#float.as_integer_ratio", "type": "Built-in Types", "text": "\nReturn a pair of integers whose ratio is exactly equal to the original float\nand with a positive denominator. Raises `OverflowError` on infinities and a\n`ValueError` on NaNs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "float.fromhex()", "path": "library/stdtypes#float.fromhex", "type": "Built-in Types", "text": "\nClass method to return the float represented by a hexadecimal string s. The\nstring s may have leading and trailing whitespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "float.hex()", "path": "library/stdtypes#float.hex", "type": "Built-in Types", "text": "\nReturn a representation of a floating-point number as a hexadecimal string.\nFor finite floating-point numbers, this representation will always include a\nleading `0x` and a trailing `p` and exponent.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "float.is_integer()", "path": "library/stdtypes#float.is_integer", "type": "Built-in Types", "text": "\nReturn `True` if the float instance is finite with integral value, and `False`\notherwise:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "FloatingPointError", "path": "library/exceptions#FloatingPointError", "type": "Built-in Exceptions", "text": "\nNot currently used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fnmatch", "path": "library/fnmatch", "type": "File & Directory Access", "text": "\nSource code: Lib/fnmatch.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fnmatch.filter()", "path": "library/fnmatch#fnmatch.filter", "type": "File & Directory Access", "text": "\nConstruct a list from those elements of the iterable names that match pattern.\nIt is the same as `[n for n in names if fnmatch(n, pattern)]`, but implemented\nmore efficiently.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fnmatch.fnmatch()", "path": "library/fnmatch#fnmatch.fnmatch", "type": "File & Directory Access", "text": "\nTest whether the filename string matches the pattern string, returning `True`\nor `False`. Both parameters are case-normalized using `os.path.normcase()`.\n`fnmatchcase()` can be used to perform a case-sensitive comparison, regardless\nof whether that\u2019s standard for the operating system.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fnmatch.fnmatchcase()", "path": "library/fnmatch#fnmatch.fnmatchcase", "type": "File & Directory Access", "text": "\nTest whether filename matches pattern, returning `True` or `False`; the\ncomparison is case-sensitive and does not apply `os.path.normcase()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fnmatch.translate()", "path": "library/fnmatch#fnmatch.translate", "type": "File & Directory Access", "text": "\nReturn the shell-style pattern converted to a regular expression for using\nwith `re.match()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "format()", "path": "library/functions#format", "type": "Built-in Functions", "text": "\nConvert a value to a \u201cformatted\u201d representation, as controlled by format_spec.\nThe interpretation of format_spec will depend on the type of the value\nargument, however there is a standard formatting syntax that is used by most\nbuilt-in types: Format Specification Mini-Language.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fractions", "path": "library/fractions", "type": "Numeric & Mathematical", "text": "\nSource code: Lib/fractions.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fractions.Fraction", "path": "library/fractions#fractions.Fraction", "type": "Numeric & Mathematical", "text": "\nThe first version requires that numerator and denominator are instances of\n`numbers.Rational` and returns a new `Fraction` instance with value\n`numerator/denominator`. If denominator is `0`, it raises a\n`ZeroDivisionError`. The second version requires that other_fraction is an\ninstance of `numbers.Rational` and returns a `Fraction` instance with the same\nvalue. The next two versions accept either a `float` or a `decimal.Decimal`\ninstance, and return a `Fraction` instance with exactly the same value. Note\nthat due to the usual issues with binary floating-point (see Floating Point\nArithmetic: Issues and Limitations), the argument to `Fraction(1.1)` is not\nexactly equal to 11/10, and so `Fraction(1.1)` does not return `Fraction(11,\n10)` as one might expect. (But see the documentation for the\n`limit_denominator()` method below.) The last version of the constructor\nexpects a string or unicode instance. The usual form for this instance is:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fractions.Fraction.as_integer_ratio()", "path": "library/fractions#fractions.Fraction.as_integer_ratio", "type": "Numeric & Mathematical", "text": "\nReturn a tuple of two integers, whose ratio is equal to the Fraction and with\na positive denominator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fractions.Fraction.denominator", "path": "library/fractions#fractions.Fraction.denominator", "type": "Numeric & Mathematical", "text": "\nDenominator of the Fraction in lowest term.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fractions.Fraction.from_decimal()", "path": "library/fractions#fractions.Fraction.from_decimal", "type": "Numeric & Mathematical", "text": "\nThis class method constructs a `Fraction` representing the exact value of dec,\nwhich must be a `decimal.Decimal` instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fractions.Fraction.from_float()", "path": "library/fractions#fractions.Fraction.from_float", "type": "Numeric & Mathematical", "text": "\nThis class method constructs a `Fraction` representing the exact value of flt,\nwhich must be a `float`. Beware that `Fraction.from_float(0.3)` is not the\nsame value as `Fraction(3, 10)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fractions.Fraction.limit_denominator()", "path": "library/fractions#fractions.Fraction.limit_denominator", "type": "Numeric & Mathematical", "text": "\nFinds and returns the closest `Fraction` to `self` that has denominator at\nmost max_denominator. This method is useful for finding rational\napproximations to a given floating-point number:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fractions.Fraction.numerator", "path": "library/fractions#fractions.Fraction.numerator", "type": "Numeric & Mathematical", "text": "\nNumerator of the Fraction in lowest term.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fractions.Fraction.__ceil__()", "path": "library/fractions#fractions.Fraction.__ceil__", "type": "Numeric & Mathematical", "text": "\nReturns the least `int` `>= self`. This method can also be accessed through\nthe `math.ceil()` function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fractions.Fraction.__floor__()", "path": "library/fractions#fractions.Fraction.__floor__", "type": "Numeric & Mathematical", "text": "\nReturns the greatest `int` `<= self`. This method can also be accessed through\nthe `math.floor()` function:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "fractions.Fraction.__round__()", "path": "library/fractions#fractions.Fraction.__round__", "type": "Numeric & Mathematical", "text": "\nThe first version returns the nearest `int` to `self`, rounding half to even.\nThe second version rounds `self` to the nearest multiple of `Fraction(1,\n10**ndigits)` (logically, if `ndigits` is negative), again rounding half\ntoward even. This method can also be accessed through the `round()` function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "frozenset", "path": "library/functions#frozenset", "type": "Built-in Functions", "text": "\nReturn a new `frozenset` object, optionally with elements taken from iterable.\n`frozenset` is a built-in class. See `frozenset` and Set Types \u2014 set,\nfrozenset for documentation about this class.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "frozenset", "path": "library/stdtypes#frozenset", "type": "Built-in Types", "text": "\nReturn a new set or frozenset object whose elements are taken from iterable.\nThe elements of a set must be hashable. To represent sets of sets, the inner\nsets must be `frozenset` objects. If iterable is not specified, a new empty\nset is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "frozenset.add()", "path": "library/stdtypes#frozenset.add", "type": "Built-in Types", "text": "\nAdd element elem to the set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "frozenset.clear()", "path": "library/stdtypes#frozenset.clear", "type": "Built-in Types", "text": "\nRemove all elements from the set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "frozenset.copy()", "path": "library/stdtypes#frozenset.copy", "type": "Built-in Types", "text": "\nReturn a shallow copy of the set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "frozenset.difference()", "path": "library/stdtypes#frozenset.difference", "type": "Built-in Types", "text": "\nReturn a new set with elements in the set that are not in the others.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "frozenset.difference_update()", "path": "library/stdtypes#frozenset.difference_update", "type": "Built-in Types", "text": "\nUpdate the set, removing elements found in others.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "frozenset.discard()", "path": "library/stdtypes#frozenset.discard", "type": "Built-in Types", "text": "\nRemove element elem from the set if it is present.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "frozenset.intersection()", "path": "library/stdtypes#frozenset.intersection", "type": "Built-in Types", "text": "\nReturn a new set with elements common to the set and all others.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "frozenset.intersection_update()", "path": "library/stdtypes#frozenset.intersection_update", "type": "Built-in Types", "text": "\nUpdate the set, keeping only elements found in it and all others.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "frozenset.isdisjoint()", "path": "library/stdtypes#frozenset.isdisjoint", "type": "Built-in Types", "text": "\nReturn `True` if the set has no elements in common with other. Sets are\ndisjoint if and only if their intersection is the empty set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "frozenset.issubset()", "path": "library/stdtypes#frozenset.issubset", "type": "Built-in Types", "text": "\nTest whether every element in the set is in other.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "frozenset.issuperset()", "path": "library/stdtypes#frozenset.issuperset", "type": "Built-in Types", "text": "\nTest whether every element in other is in the set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "frozenset.pop()", "path": "library/stdtypes#frozenset.pop", "type": "Built-in Types", "text": "\nRemove and return an arbitrary element from the set. Raises `KeyError` if the\nset is empty.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "frozenset.remove()", "path": "library/stdtypes#frozenset.remove", "type": "Built-in Types", "text": "\nRemove element elem from the set. Raises `KeyError` if elem is not contained\nin the set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "frozenset.symmetric_difference()", "path": "library/stdtypes#frozenset.symmetric_difference", "type": "Built-in Types", "text": "\nReturn a new set with elements in either the set or other but not both.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "frozenset.symmetric_difference_update()", "path": "library/stdtypes#frozenset.symmetric_difference_update", "type": "Built-in Types", "text": "\nUpdate the set, keeping only elements found in either set, but not in both.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "frozenset.union()", "path": "library/stdtypes#frozenset.union", "type": "Built-in Types", "text": "\nReturn a new set with elements from the set and all others.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "frozenset.update()", "path": "library/stdtypes#frozenset.update", "type": "Built-in Types", "text": "\nUpdate the set, adding elements from all others.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib", "path": "library/ftplib", "type": "Internet", "text": "\nSource code: Lib/ftplib.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.all_errors", "path": "library/ftplib#ftplib.all_errors", "type": "Internet", "text": "\nThe set of all exceptions (as a tuple) that methods of `FTP` instances may\nraise as a result of problems with the FTP connection (as opposed to\nprogramming errors made by the caller). This set includes the four exceptions\nlisted above as well as `OSError` and `EOFError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.error_perm", "path": "library/ftplib#ftplib.error_perm", "type": "Internet", "text": "\nException raised when an error code signifying a permanent error (response\ncodes in the range 500\u2013599) is received.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.error_proto", "path": "library/ftplib#ftplib.error_proto", "type": "Internet", "text": "\nException raised when a reply is received from the server that does not fit\nthe response specifications of the File Transfer Protocol, i.e. begin with a\ndigit in the range 1\u20135.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.error_reply", "path": "library/ftplib#ftplib.error_reply", "type": "Internet", "text": "\nException raised when an unexpected reply is received from the server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.error_temp", "path": "library/ftplib#ftplib.error_temp", "type": "Internet", "text": "\nException raised when an error code signifying a temporary error (response\ncodes in the range 400\u2013499) is received.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP", "path": "library/ftplib#ftplib.FTP", "type": "Internet", "text": "\nReturn a new instance of the `FTP` class. When host is given, the method call\n`connect(host)` is made. When user is given, additionally the method call\n`login(user, passwd, acct)` is made (where passwd and acct default to the\nempty string when not given). The optional timeout parameter specifies a\ntimeout in seconds for blocking operations like the connection attempt (if is\nnot specified, the global default timeout setting will be used).\nsource_address is a 2-tuple `(host, port)` for the socket to bind to as its\nsource address before connecting. The encoding parameter specifies the\nencoding for directories and filenames.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.abort()", "path": "library/ftplib#ftplib.FTP.abort", "type": "Internet", "text": "\nAbort a file transfer that is in progress. Using this does not always work,\nbut it\u2019s worth a try.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.close()", "path": "library/ftplib#ftplib.FTP.close", "type": "Internet", "text": "\nClose the connection unilaterally. This should not be applied to an already\nclosed connection such as after a successful call to `quit()`. After this call\nthe `FTP` instance should not be used any more (after a call to `close()` or\n`quit()` you cannot reopen the connection by issuing another `login()`\nmethod).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.connect()", "path": "library/ftplib#ftplib.FTP.connect", "type": "Internet", "text": "\nConnect to the given host and port. The default port number is `21`, as\nspecified by the FTP protocol specification. It is rarely needed to specify a\ndifferent port number. This function should be called only once for each\ninstance; it should not be called at all if a host was given when the instance\nwas created. All other methods can only be used after a connection has been\nmade. The optional timeout parameter specifies a timeout in seconds for the\nconnection attempt. If no timeout is passed, the global default timeout\nsetting will be used. source_address is a 2-tuple `(host, port)` for the\nsocket to bind to as its source address before connecting.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.cwd()", "path": "library/ftplib#ftplib.FTP.cwd", "type": "Internet", "text": "\nSet the current directory on the server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.delete()", "path": "library/ftplib#ftplib.FTP.delete", "type": "Internet", "text": "\nRemove the file named filename from the server. If successful, returns the\ntext of the response, otherwise raises `error_perm` on permission errors or\n`error_reply` on other errors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.dir()", "path": "library/ftplib#ftplib.FTP.dir", "type": "Internet", "text": "\nProduce a directory listing as returned by the `LIST` command, printing it to\nstandard output. The optional argument is a directory to list (default is the\ncurrent server directory). Multiple arguments can be used to pass non-standard\noptions to the `LIST` command. If the last argument is a function, it is used\nas a callback function as for `retrlines()`; the default prints to\n`sys.stdout`. This method returns `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.getwelcome()", "path": "library/ftplib#ftplib.FTP.getwelcome", "type": "Internet", "text": "\nReturn the welcome message sent by the server in reply to the initial\nconnection. (This message sometimes contains disclaimers or help information\nthat may be relevant to the user.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.login()", "path": "library/ftplib#ftplib.FTP.login", "type": "Internet", "text": "\nLog in as the given user. The passwd and acct parameters are optional and\ndefault to the empty string. If no user is specified, it defaults to\n`'anonymous'`. If user is `'anonymous'`, the default passwd is `'anonymous@'`.\nThis function should be called only once for each instance, after a connection\nhas been established; it should not be called at all if a host and user were\ngiven when the instance was created. Most FTP commands are only allowed after\nthe client has logged in. The acct parameter supplies \u201caccounting\ninformation\u201d; few systems implement this.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.mkd()", "path": "library/ftplib#ftplib.FTP.mkd", "type": "Internet", "text": "\nCreate a new directory on the server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.mlsd()", "path": "library/ftplib#ftplib.FTP.mlsd", "type": "Internet", "text": "\nList a directory in a standardized format by using `MLSD` command (RFC 3659).\nIf path is omitted the current directory is assumed. facts is a list of\nstrings representing the type of information desired (e.g. `[\"type\", \"size\",\n\"perm\"]`). Return a generator object yielding a tuple of two elements for\nevery file found in path. First element is the file name, the second one is a\ndictionary containing facts about the file name. Content of this dictionary\nmight be limited by the facts argument but server is not guaranteed to return\nall requested facts.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.nlst()", "path": "library/ftplib#ftplib.FTP.nlst", "type": "Internet", "text": "\nReturn a list of file names as returned by the `NLST` command. The optional\nargument is a directory to list (default is the current server directory).\nMultiple arguments can be used to pass non-standard options to the `NLST`\ncommand.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.ntransfercmd()", "path": "library/ftplib#ftplib.FTP.ntransfercmd", "type": "Internet", "text": "\nLike `transfercmd()`, but returns a tuple of the data connection and the\nexpected size of the data. If the expected size could not be computed, `None`\nwill be returned as the expected size. cmd and rest means the same thing as in\n`transfercmd()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.pwd()", "path": "library/ftplib#ftplib.FTP.pwd", "type": "Internet", "text": "\nReturn the pathname of the current directory on the server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.quit()", "path": "library/ftplib#ftplib.FTP.quit", "type": "Internet", "text": "\nSend a `QUIT` command to the server and close the connection. This is the\n\u201cpolite\u201d way to close a connection, but it may raise an exception if the\nserver responds with an error to the `QUIT` command. This implies a call to\nthe `close()` method which renders the `FTP` instance useless for subsequent\ncalls (see below).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.rename()", "path": "library/ftplib#ftplib.FTP.rename", "type": "Internet", "text": "\nRename file fromname on the server to toname.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.retrbinary()", "path": "library/ftplib#ftplib.FTP.retrbinary", "type": "Internet", "text": "\nRetrieve a file in binary transfer mode. cmd should be an appropriate `RETR`\ncommand: `'RETR filename'`. The callback function is called for each block of\ndata received, with a single bytes argument giving the data block. The\noptional blocksize argument specifies the maximum chunk size to read on the\nlow-level socket object created to do the actual transfer (which will also be\nthe largest size of the data blocks passed to callback). A reasonable default\nis chosen. rest means the same thing as in the `transfercmd()` method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.retrlines()", "path": "library/ftplib#ftplib.FTP.retrlines", "type": "Internet", "text": "\nRetrieve a file or directory listing in the encoding specified by the encoding\nparameter at initialization. cmd should be an appropriate `RETR` command (see\n`retrbinary()`) or a command such as `LIST` or `NLST` (usually just the string\n`'LIST'`). `LIST` retrieves a list of files and information about those files.\n`NLST` retrieves a list of file names. The callback function is called for\neach line with a string argument containing the line with the trailing CRLF\nstripped. The default callback prints the line to `sys.stdout`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.rmd()", "path": "library/ftplib#ftplib.FTP.rmd", "type": "Internet", "text": "\nRemove the directory named dirname on the server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.sendcmd()", "path": "library/ftplib#ftplib.FTP.sendcmd", "type": "Internet", "text": "\nSend a simple command string to the server and return the response string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.set_debuglevel()", "path": "library/ftplib#ftplib.FTP.set_debuglevel", "type": "Internet", "text": "\nSet the instance\u2019s debugging level. This controls the amount of debugging\noutput printed. The default, `0`, produces no debugging output. A value of `1`\nproduces a moderate amount of debugging output, generally a single line per\nrequest. A value of `2` or higher produces the maximum amount of debugging\noutput, logging each line sent and received on the control connection.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.set_pasv()", "path": "library/ftplib#ftplib.FTP.set_pasv", "type": "Internet", "text": "\nEnable \u201cpassive\u201d mode if val is true, otherwise disable passive mode. Passive\nmode is on by default.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.size()", "path": "library/ftplib#ftplib.FTP.size", "type": "Internet", "text": "\nRequest the size of the file named filename on the server. On success, the\nsize of the file is returned as an integer, otherwise `None` is returned. Note\nthat the `SIZE` command is not standardized, but is supported by many common\nserver implementations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.storbinary()", "path": "library/ftplib#ftplib.FTP.storbinary", "type": "Internet", "text": "\nStore a file in binary transfer mode. cmd should be an appropriate `STOR`\ncommand: `\"STOR filename\"`. fp is a file object (opened in binary mode) which\nis read until EOF using its `read()` method in blocks of size blocksize to\nprovide the data to be stored. The blocksize argument defaults to 8192.\ncallback is an optional single parameter callable that is called on each block\nof data after it is sent. rest means the same thing as in the `transfercmd()`\nmethod.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.storlines()", "path": "library/ftplib#ftplib.FTP.storlines", "type": "Internet", "text": "\nStore a file in line mode. cmd should be an appropriate `STOR` command (see\n`storbinary()`). Lines are read until EOF from the file object fp (opened in\nbinary mode) using its `readline()` method to provide the data to be stored.\ncallback is an optional single parameter callable that is called on each line\nafter it is sent.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.transfercmd()", "path": "library/ftplib#ftplib.FTP.transfercmd", "type": "Internet", "text": "\nInitiate a transfer over the data connection. If the transfer is active, send\nan `EPRT` or `PORT` command and the transfer command specified by cmd, and\naccept the connection. If the server is passive, send an `EPSV` or `PASV`\ncommand, connect to it, and start the transfer command. Either way, return the\nsocket for the connection.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP.voidcmd()", "path": "library/ftplib#ftplib.FTP.voidcmd", "type": "Internet", "text": "\nSend a simple command string to the server and handle the response. Return\nnothing if a response code corresponding to success (codes in the range\n200\u2013299) is received. Raise `error_reply` otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP_TLS", "path": "library/ftplib#ftplib.FTP_TLS", "type": "Internet", "text": "\nA `FTP` subclass which adds TLS support to FTP as described in RFC 4217.\nConnect as usual to port 21 implicitly securing the FTP control connection\nbefore authenticating. Securing the data connection requires the user to\nexplicitly ask for it by calling the `prot_p()` method. context is a\n`ssl.SSLContext` object which allows bundling SSL configuration options,\ncertificates and private keys into a single (potentially long-lived)\nstructure. Please read Security considerations for best practices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP_TLS.auth()", "path": "library/ftplib#ftplib.FTP_TLS.auth", "type": "Internet", "text": "\nSet up a secure control connection by using TLS or SSL, depending on what is\nspecified in the `ssl_version` attribute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP_TLS.ccc()", "path": "library/ftplib#ftplib.FTP_TLS.ccc", "type": "Internet", "text": "\nRevert control channel back to plaintext. This can be useful to take advantage\nof firewalls that know how to handle NAT with non-secure FTP without opening\nfixed ports.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP_TLS.prot_c()", "path": "library/ftplib#ftplib.FTP_TLS.prot_c", "type": "Internet", "text": "\nSet up clear text data connection.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP_TLS.prot_p()", "path": "library/ftplib#ftplib.FTP_TLS.prot_p", "type": "Internet", "text": "\nSet up secure data connection.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ftplib.FTP_TLS.ssl_version", "path": "library/ftplib#ftplib.FTP_TLS.ssl_version", "type": "Internet", "text": "\nThe SSL version to use (defaults to `ssl.PROTOCOL_SSLv23`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Functions", "path": "library/functions", "type": "Built-in Functions", "text": "\nThe Python interpreter has a number of functions and types built into it that\nare always available. They are listed here in alphabetical order.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "functools", "path": "library/functools", "type": "Functional Programming", "text": "\nSource code: Lib/functools.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "functools.cache()", "path": "library/functools#functools.cache", "type": "Functional Programming", "text": "\nSimple lightweight unbounded function cache. Sometimes called \u201cmemoize\u201d.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "functools.cached_property()", "path": "library/functools#functools.cached_property", "type": "Functional Programming", "text": "\nTransform a method of a class into a property whose value is computed once and\nthen cached as a normal attribute for the life of the instance. Similar to\n`property()`, with the addition of caching. Useful for expensive computed\nproperties of instances that are otherwise effectively immutable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "functools.cmp_to_key()", "path": "library/functools#functools.cmp_to_key", "type": "Functional Programming", "text": "\nTransform an old-style comparison function to a key function. Used with tools\nthat accept key functions (such as `sorted()`, `min()`, `max()`,\n`heapq.nlargest()`, `heapq.nsmallest()`, `itertools.groupby()`). This function\nis primarily used as a transition tool for programs being converted from\nPython 2 which supported the use of comparison functions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "functools.lru_cache()", "path": "library/functools#functools.lru_cache", "type": "Functional Programming", "text": "\nDecorator to wrap a function with a memoizing callable that saves up to the\nmaxsize most recent calls. It can save time when an expensive or I/O bound\nfunction is periodically called with the same arguments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "functools.partial()", "path": "library/functools#functools.partial", "type": "Functional Programming", "text": "\nReturn a new partial object which when called will behave like func called\nwith the positional arguments args and keyword arguments keywords. If more\narguments are supplied to the call, they are appended to args. If additional\nkeyword arguments are supplied, they extend and override keywords. Roughly\nequivalent to:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "functools.partial.args", "path": "library/functools#functools.partial.args", "type": "Functional Programming", "text": "\nThe leftmost positional arguments that will be prepended to the positional\narguments provided to a `partial` object call.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "functools.partial.func", "path": "library/functools#functools.partial.func", "type": "Functional Programming", "text": "\nA callable object or function. Calls to the `partial` object will be forwarded\nto `func` with new arguments and keywords.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "functools.partial.keywords", "path": "library/functools#functools.partial.keywords", "type": "Functional Programming", "text": "\nThe keyword arguments that will be supplied when the `partial` object is\ncalled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "functools.partialmethod", "path": "library/functools#functools.partialmethod", "type": "Functional Programming", "text": "\nReturn a new `partialmethod` descriptor which behaves like `partial` except\nthat it is designed to be used as a method definition rather than being\ndirectly callable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "functools.reduce()", "path": "library/functools#functools.reduce", "type": "Functional Programming", "text": "\nApply function of two arguments cumulatively to the items of iterable, from\nleft to right, so as to reduce the iterable to a single value. For example,\n`reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])` calculates `((((1+2)+3)+4)+5)`.\nThe left argument, x, is the accumulated value and the right argument, y, is\nthe update value from the iterable. If the optional initializer is present, it\nis placed before the items of the iterable in the calculation, and serves as a\ndefault when the iterable is empty. If initializer is not given and iterable\ncontains only one item, the first item is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "functools.singledispatch()", "path": "library/functools#functools.singledispatch", "type": "Functional Programming", "text": "\nTransform a function into a single-dispatch generic function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "functools.singledispatchmethod", "path": "library/functools#functools.singledispatchmethod", "type": "Functional Programming", "text": "\nTransform a method into a single-dispatch generic function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "functools.total_ordering()", "path": "library/functools#functools.total_ordering", "type": "Functional Programming", "text": "\nGiven a class defining one or more rich comparison ordering methods, this\nclass decorator supplies the rest. This simplifies the effort involved in\nspecifying all of the possible rich comparison operations:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "functools.update_wrapper()", "path": "library/functools#functools.update_wrapper", "type": "Functional Programming", "text": "\nUpdate a wrapper function to look like the wrapped function. The optional\narguments are tuples to specify which attributes of the original function are\nassigned directly to the matching attributes on the wrapper function and which\nattributes of the wrapper function are updated with the corresponding\nattributes from the original function. The default values for these arguments\nare the module level constants `WRAPPER_ASSIGNMENTS` (which assigns to the\nwrapper function\u2019s `__module__`, `__name__`, `__qualname__`, `__annotations__`\nand `__doc__`, the documentation string) and `WRAPPER_UPDATES` (which updates\nthe wrapper function\u2019s `__dict__`, i.e. the instance dictionary).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "functools.wraps()", "path": "library/functools#functools.wraps", "type": "Functional Programming", "text": "\nThis is a convenience function for invoking `update_wrapper()` as a function\ndecorator when defining a wrapper function. It is equivalent to\n`partial(update_wrapper, wrapped=wrapped, assigned=assigned,\nupdated=updated)`. For example:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Futures", "path": "library/asyncio-future", "type": "Asynchronous I/O", "text": "\nSource code: Lib/asyncio/futures.py, Lib/asyncio/base_futures.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "FutureWarning", "path": "library/exceptions#FutureWarning", "type": "Built-in Exceptions", "text": "\nBase class for warnings about deprecated features when those warnings are\nintended for end users of applications that are written in Python.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc", "path": "library/gc", "type": "Runtime", "text": "\nThis module provides an interface to the optional garbage collector. It\nprovides the ability to disable the collector, tune the collection frequency,\nand set debugging options. It also provides access to unreachable objects that\nthe collector found but cannot free. Since the collector supplements the\nreference counting already used in Python, you can disable the collector if\nyou are sure your program does not create reference cycles. Automatic\ncollection can be disabled by calling `gc.disable()`. To debug a leaking\nprogram call `gc.set_debug(gc.DEBUG_LEAK)`. Notice that this includes\n`gc.DEBUG_SAVEALL`, causing garbage-collected objects to be saved in\ngc.garbage for inspection.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.callbacks", "path": "library/gc#gc.callbacks", "type": "Runtime", "text": "\nA list of callbacks that will be invoked by the garbage collector before and\nafter collection. The callbacks will be called with two arguments, phase and\ninfo.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.collect()", "path": "library/gc#gc.collect", "type": "Runtime", "text": "\nWith no arguments, run a full collection. The optional argument generation may\nbe an integer specifying which generation to collect (from 0 to 2). A\n`ValueError` is raised if the generation number is invalid. The number of\nunreachable objects found is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.DEBUG_COLLECTABLE", "path": "library/gc#gc.DEBUG_COLLECTABLE", "type": "Runtime", "text": "\nPrint information on collectable objects found.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.DEBUG_LEAK", "path": "library/gc#gc.DEBUG_LEAK", "type": "Runtime", "text": "\nThe debugging flags necessary for the collector to print information about a\nleaking program (equal to `DEBUG_COLLECTABLE | DEBUG_UNCOLLECTABLE |\nDEBUG_SAVEALL`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.DEBUG_SAVEALL", "path": "library/gc#gc.DEBUG_SAVEALL", "type": "Runtime", "text": "\nWhen set, all unreachable objects found will be appended to garbage rather\nthan being freed. This can be useful for debugging a leaking program.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.DEBUG_STATS", "path": "library/gc#gc.DEBUG_STATS", "type": "Runtime", "text": "\nPrint statistics during collection. This information can be useful when tuning\nthe collection frequency.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.DEBUG_UNCOLLECTABLE", "path": "library/gc#gc.DEBUG_UNCOLLECTABLE", "type": "Runtime", "text": "\nPrint information of uncollectable objects found (objects which are not\nreachable but cannot be freed by the collector). These objects will be added\nto the `garbage` list.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.disable()", "path": "library/gc#gc.disable", "type": "Runtime", "text": "\nDisable automatic garbage collection.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.enable()", "path": "library/gc#gc.enable", "type": "Runtime", "text": "\nEnable automatic garbage collection.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.freeze()", "path": "library/gc#gc.freeze", "type": "Runtime", "text": "\nFreeze all the objects tracked by gc - move them to a permanent generation and\nignore all the future collections. This can be used before a POSIX fork() call\nto make the gc copy-on-write friendly or to speed up collection. Also\ncollection before a POSIX fork() call may free pages for future allocation\nwhich can cause copy-on-write too so it\u2019s advised to disable gc in parent\nprocess and freeze before fork and enable gc in child process.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.garbage", "path": "library/gc#gc.garbage", "type": "Runtime", "text": "\nA list of objects which the collector found to be unreachable but could not be\nfreed (uncollectable objects). Starting with Python 3.4, this list should be\nempty most of the time, except when using instances of C extension types with\na non-`NULL` `tp_del` slot.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.get_count()", "path": "library/gc#gc.get_count", "type": "Runtime", "text": "\nReturn the current collection counts as a tuple of `(count0, count1, count2)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.get_debug()", "path": "library/gc#gc.get_debug", "type": "Runtime", "text": "\nReturn the debugging flags currently set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.get_freeze_count()", "path": "library/gc#gc.get_freeze_count", "type": "Runtime", "text": "\nReturn the number of objects in the permanent generation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.get_objects()", "path": "library/gc#gc.get_objects", "type": "Runtime", "text": "\nReturns a list of all objects tracked by the collector, excluding the list\nreturned. If generation is not None, return only the objects tracked by the\ncollector that are in that generation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.get_referents()", "path": "library/gc#gc.get_referents", "type": "Runtime", "text": "\nReturn a list of objects directly referred to by any of the arguments. The\nreferents returned are those objects visited by the arguments\u2019 C-level\n`tp_traverse` methods (if any), and may not be all objects actually directly\nreachable. `tp_traverse` methods are supported only by objects that support\ngarbage collection, and are only required to visit objects that may be\ninvolved in a cycle. So, for example, if an integer is directly reachable from\nan argument, that integer object may or may not appear in the result list.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.get_referrers()", "path": "library/gc#gc.get_referrers", "type": "Runtime", "text": "\nReturn the list of objects that directly refer to any of objs. This function\nwill only locate those containers which support garbage collection; extension\ntypes which do refer to other objects but do not support garbage collection\nwill not be found.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.get_stats()", "path": "library/gc#gc.get_stats", "type": "Runtime", "text": "\nReturn a list of three per-generation dictionaries containing collection\nstatistics since interpreter start. The number of keys may change in the\nfuture, but currently each dictionary will contain the following items:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.get_threshold()", "path": "library/gc#gc.get_threshold", "type": "Runtime", "text": "\nReturn the current collection thresholds as a tuple of `(threshold0,\nthreshold1, threshold2)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.isenabled()", "path": "library/gc#gc.isenabled", "type": "Runtime", "text": "\nReturn `True` if automatic collection is enabled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.is_finalized()", "path": "library/gc#gc.is_finalized", "type": "Runtime", "text": "\nReturns `True` if the given object has been finalized by the garbage\ncollector, `False` otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.is_tracked()", "path": "library/gc#gc.is_tracked", "type": "Runtime", "text": "\nReturns `True` if the object is currently tracked by the garbage collector,\n`False` otherwise. As a general rule, instances of atomic types aren\u2019t tracked\nand instances of non-atomic types (containers, user-defined objects\u2026) are.\nHowever, some type-specific optimizations can be present in order to suppress\nthe garbage collector footprint of simple instances (e.g. dicts containing\nonly atomic keys and values):\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.set_debug()", "path": "library/gc#gc.set_debug", "type": "Runtime", "text": "\nSet the garbage collection debugging flags. Debugging information will be\nwritten to `sys.stderr`. See below for a list of debugging flags which can be\ncombined using bit operations to control debugging.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.set_threshold()", "path": "library/gc#gc.set_threshold", "type": "Runtime", "text": "\nSet the garbage collection thresholds (the collection frequency). Setting\nthreshold0 to zero disables collection.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gc.unfreeze()", "path": "library/gc#gc.unfreeze", "type": "Runtime", "text": "\nUnfreeze the objects in the permanent generation, put them back into the\noldest generation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "GeneratorExit", "path": "library/exceptions#GeneratorExit", "type": "Built-in Exceptions", "text": "\nRaised when a generator or coroutine is closed; see `generator.close()` and\n`coroutine.close()`. It directly inherits from `BaseException` instead of\n`Exception` since it is technically not an error.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "genericalias.__args__", "path": "library/stdtypes#genericalias.__args__", "type": "Built-in Types", "text": "\nThis attribute is a `tuple` (possibly of length 1) of generic types passed to\nthe original `__class_getitem__()` of the generic container:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "genericalias.__origin__", "path": "library/stdtypes#genericalias.__origin__", "type": "Built-in Types", "text": "\nThis attribute points at the non-parameterized generic class:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "genericalias.__parameters__", "path": "library/stdtypes#genericalias.__parameters__", "type": "Built-in Types", "text": "\nThis attribute is a lazily computed tuple (possibly empty) of unique type\nvariables found in `__args__`:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "getattr()", "path": "library/functions#getattr", "type": "Built-in Functions", "text": "\nReturn the value of the named attribute of object. name must be a string. If\nthe string is the name of one of the object\u2019s attributes, the result is the\nvalue of that attribute. For example, `getattr(x, 'foobar')` is equivalent to\n`x.foobar`. If the named attribute does not exist, default is returned if\nprovided, otherwise `AttributeError` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "getopt", "path": "library/getopt", "type": "Operating System", "text": "\nSource code: Lib/getopt.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "getopt.error", "path": "library/getopt#getopt.error", "type": "Operating System", "text": "\nAlias for `GetoptError`; for backward compatibility.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "getopt.getopt()", "path": "library/getopt#getopt.getopt", "type": "Operating System", "text": "\nParses command line options and parameter list. args is the argument list to\nbe parsed, without the leading reference to the running program. Typically,\nthis means `sys.argv[1:]`. shortopts is the string of option letters that the\nscript wants to recognize, with options that require an argument followed by a\ncolon (`':'`; i.e., the same format that Unix `getopt()` uses).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "getopt.GetoptError", "path": "library/getopt#getopt.GetoptError", "type": "Operating System", "text": "\nThis is raised when an unrecognized option is found in the argument list or\nwhen an option requiring an argument is given none. The argument to the\nexception is a string indicating the cause of the error. For long options, an\nargument given to an option which does not require one will also cause this\nexception to be raised. The attributes `msg` and `opt` give the error message\nand related option; if there is no specific option to which the exception\nrelates, `opt` is an empty string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "getopt.gnu_getopt()", "path": "library/getopt#getopt.gnu_getopt", "type": "Operating System", "text": "\nThis function works like `getopt()`, except that GNU style scanning mode is\nused by default. This means that option and non-option arguments may be\nintermixed. The `getopt()` function stops processing options as soon as a non-\noption argument is encountered.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "getpass", "path": "library/getpass", "type": "Operating System", "text": "\nSource code: Lib/getpass.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "getpass.getpass()", "path": "library/getpass#getpass.getpass", "type": "Operating System", "text": "\nPrompt the user for a password without echoing. The user is prompted using the\nstring prompt, which defaults to `'Password: '`. On Unix, the prompt is\nwritten to the file-like object stream using the replace error handler if\nneeded. stream defaults to the controlling terminal (`/dev/tty`) or if that is\nunavailable to `sys.stderr` (this argument is ignored on Windows).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "getpass.GetPassWarning", "path": "library/getpass#getpass.GetPassWarning", "type": "Operating System", "text": "\nA `UserWarning` subclass issued when password input may be echoed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "getpass.getuser()", "path": "library/getpass#getpass.getuser", "type": "Operating System", "text": "\nReturn the \u201clogin name\u201d of the user.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext", "path": "library/gettext", "type": "Internationalization", "text": "\nSource code: Lib/gettext.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.bindtextdomain()", "path": "library/gettext#gettext.bindtextdomain", "type": "Internationalization", "text": "\nBind the domain to the locale directory localedir. More concretely, `gettext`\nwill look for binary `.mo` files for the given domain using the path (on\nUnix): `localedir/language/LC_MESSAGES/domain.mo`, where language is searched\nfor in the environment variables `LANGUAGE`, `LC_ALL`, `LC_MESSAGES`, and\n`LANG` respectively.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.bind_textdomain_codeset()", "path": "library/gettext#gettext.bind_textdomain_codeset", "type": "Internationalization", "text": "\nBind the domain to codeset, changing the encoding of byte strings returned by\nthe `lgettext()`, `ldgettext()`, `lngettext()` and `ldngettext()` functions.\nIf codeset is omitted, then the current binding is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.dgettext()", "path": "library/gettext#gettext.dgettext", "type": "Internationalization", "text": "\nLike `gettext()`, but look the message up in the specified domain.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.dngettext()", "path": "library/gettext#gettext.dngettext", "type": "Internationalization", "text": "\nLike `ngettext()`, but look the message up in the specified domain.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.dnpgettext()", "path": "library/gettext#gettext.dnpgettext", "type": "Internationalization", "text": "\nSimilar to the corresponding functions without the `p` in the prefix (that is,\n`gettext()`, `dgettext()`, `ngettext()`, `dngettext()`), but the translation\nis restricted to the given message context.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.dpgettext()", "path": "library/gettext#gettext.dpgettext", "type": "Internationalization", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.find()", "path": "library/gettext#gettext.find", "type": "Internationalization", "text": "\nThis function implements the standard `.mo` file search algorithm. It takes a\ndomain, identical to what `textdomain()` takes. Optional localedir is as in\n`bindtextdomain()`. Optional languages is a list of strings, where each string\nis a language code.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.gettext()", "path": "library/gettext#gettext.gettext", "type": "Internationalization", "text": "\nReturn the localized translation of message, based on the current global\ndomain, language, and locale directory. This function is usually aliased as\n`_()` in the local namespace (see examples below).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.GNUTranslations", "path": "library/gettext#gettext.GNUTranslations", "type": "Internationalization", "text": "\nThe following methods are overridden from the base class implementation:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.GNUTranslations.gettext()", "path": "library/gettext#gettext.GNUTranslations.gettext", "type": "Internationalization", "text": "\nLook up the message id in the catalog and return the corresponding message\nstring, as a Unicode string. If there is no entry in the catalog for the\nmessage id, and a fallback has been set, the look up is forwarded to the\nfallback\u2019s `gettext()` method. Otherwise, the message id is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.GNUTranslations.lgettext()", "path": "library/gettext#gettext.GNUTranslations.lgettext", "type": "Internationalization", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.GNUTranslations.lngettext()", "path": "library/gettext#gettext.GNUTranslations.lngettext", "type": "Internationalization", "text": "\nEquivalent to `gettext()` and `ngettext()`, but the translation is returned as\na byte string encoded in the preferred system encoding if no encoding was\nexplicitly set with `set_output_charset()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.GNUTranslations.ngettext()", "path": "library/gettext#gettext.GNUTranslations.ngettext", "type": "Internationalization", "text": "\nDo a plural-forms lookup of a message id. singular is used as the message id\nfor purposes of lookup in the catalog, while n is used to determine which\nplural form to use. The returned message string is a Unicode string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.GNUTranslations.npgettext()", "path": "library/gettext#gettext.GNUTranslations.npgettext", "type": "Internationalization", "text": "\nDo a plural-forms lookup of a message id. singular is used as the message id\nfor purposes of lookup in the catalog, while n is used to determine which\nplural form to use.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.GNUTranslations.pgettext()", "path": "library/gettext#gettext.GNUTranslations.pgettext", "type": "Internationalization", "text": "\nLook up the context and message id in the catalog and return the corresponding\nmessage string, as a Unicode string. If there is no entry in the catalog for\nthe message id and context, and a fallback has been set, the look up is\nforwarded to the fallback\u2019s `pgettext()` method. Otherwise, the message id is\nreturned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.install()", "path": "library/gettext#gettext.install", "type": "Internationalization", "text": "\nThis installs the function `_()` in Python\u2019s builtins namespace, based on\ndomain, localedir, and codeset which are passed to the function\n`translation()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.ldgettext()", "path": "library/gettext#gettext.ldgettext", "type": "Internationalization", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.ldngettext()", "path": "library/gettext#gettext.ldngettext", "type": "Internationalization", "text": "\nEquivalent to the corresponding functions without the `l` prefix (`gettext()`,\n`dgettext()`, `ngettext()` and `dngettext()`), but the translation is returned\nas a byte string encoded in the preferred system encoding if no other encoding\nwas explicitly set with `bind_textdomain_codeset()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.lgettext()", "path": "library/gettext#gettext.lgettext", "type": "Internationalization", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.lngettext()", "path": "library/gettext#gettext.lngettext", "type": "Internationalization", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.ngettext()", "path": "library/gettext#gettext.ngettext", "type": "Internationalization", "text": "\nLike `gettext()`, but consider plural forms. If a translation is found, apply\nthe plural formula to n, and return the resulting message (some languages have\nmore than two plural forms). If no translation is found, return singular if n\nis 1; return plural otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.npgettext()", "path": "library/gettext#gettext.npgettext", "type": "Internationalization", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.NullTranslations", "path": "library/gettext#gettext.NullTranslations", "type": "Internationalization", "text": "\nTakes an optional file object fp, which is ignored by the base class.\nInitializes \u201cprotected\u201d instance variables _info and _charset which are set by\nderived classes, as well as _fallback, which is set through `add_fallback()`.\nIt then calls `self._parse(fp)` if fp is not `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.NullTranslations.add_fallback()", "path": "library/gettext#gettext.NullTranslations.add_fallback", "type": "Internationalization", "text": "\nAdd fallback as the fallback object for the current translation object. A\ntranslation object should consult the fallback if it cannot provide a\ntranslation for a given message.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.NullTranslations.charset()", "path": "library/gettext#gettext.NullTranslations.charset", "type": "Internationalization", "text": "\nReturn the encoding of the message catalog file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.NullTranslations.gettext()", "path": "library/gettext#gettext.NullTranslations.gettext", "type": "Internationalization", "text": "\nIf a fallback has been set, forward `gettext()` to the fallback. Otherwise,\nreturn message. Overridden in derived classes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.NullTranslations.info()", "path": "library/gettext#gettext.NullTranslations.info", "type": "Internationalization", "text": "\nReturn the \u201cprotected\u201d `_info` variable, a dictionary containing the metadata\nfound in the message catalog file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.NullTranslations.install()", "path": "library/gettext#gettext.NullTranslations.install", "type": "Internationalization", "text": "\nThis method installs `gettext()` into the built-in namespace, binding it to\n`_`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.NullTranslations.lgettext()", "path": "library/gettext#gettext.NullTranslations.lgettext", "type": "Internationalization", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.NullTranslations.lngettext()", "path": "library/gettext#gettext.NullTranslations.lngettext", "type": "Internationalization", "text": "\nEquivalent to `gettext()` and `ngettext()`, but the translation is returned as\na byte string encoded in the preferred system encoding if no encoding was\nexplicitly set with `set_output_charset()`. Overridden in derived classes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.NullTranslations.ngettext()", "path": "library/gettext#gettext.NullTranslations.ngettext", "type": "Internationalization", "text": "\nIf a fallback has been set, forward `ngettext()` to the fallback. Otherwise,\nreturn singular if n is 1; return plural otherwise. Overridden in derived\nclasses.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.NullTranslations.npgettext()", "path": "library/gettext#gettext.NullTranslations.npgettext", "type": "Internationalization", "text": "\nIf a fallback has been set, forward `npgettext()` to the fallback. Otherwise,\nreturn the translated message. Overridden in derived classes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.NullTranslations.output_charset()", "path": "library/gettext#gettext.NullTranslations.output_charset", "type": "Internationalization", "text": "\nReturn the encoding used to return translated messages in `lgettext()` and\n`lngettext()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.NullTranslations.pgettext()", "path": "library/gettext#gettext.NullTranslations.pgettext", "type": "Internationalization", "text": "\nIf a fallback has been set, forward `pgettext()` to the fallback. Otherwise,\nreturn the translated message. Overridden in derived classes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.NullTranslations.set_output_charset()", "path": "library/gettext#gettext.NullTranslations.set_output_charset", "type": "Internationalization", "text": "\nChange the encoding used to return translated messages.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.NullTranslations._parse()", "path": "library/gettext#gettext.NullTranslations._parse", "type": "Internationalization", "text": "\nNo-op in the base class, this method takes file object fp, and reads the data\nfrom the file, initializing its message catalog. If you have an unsupported\nmessage catalog file format, you should override this method to parse your\nformat.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.pgettext()", "path": "library/gettext#gettext.pgettext", "type": "Internationalization", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.textdomain()", "path": "library/gettext#gettext.textdomain", "type": "Internationalization", "text": "\nChange or query the current global domain. If domain is `None`, then the\ncurrent global domain is returned, otherwise the global domain is set to\ndomain, which is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gettext.translation()", "path": "library/gettext#gettext.translation", "type": "Internationalization", "text": "\nReturn a `*Translations` instance based on the domain, localedir, and\nlanguages, which are first passed to `find()` to get a list of the associated\n`.mo` file paths. Instances with identical `.mo` file names are cached. The\nactual class instantiated is class_ if provided, otherwise `GNUTranslations`.\nThe class\u2019s constructor must take a single file object argument. If provided,\ncodeset will change the charset used to encode translated strings in the\n`lgettext()` and `lngettext()` methods.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "glob", "path": "library/glob", "type": "File & Directory Access", "text": "\nSource code: Lib/glob.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "glob.escape()", "path": "library/glob#glob.escape", "type": "File & Directory Access", "text": "\nEscape all special characters (`'?'`, `'*'` and `'['`). This is useful if you\nwant to match an arbitrary literal string that may have special characters in\nit. Special characters in drive/UNC sharepoints are not escaped, e.g. on\nWindows `escape('//?/c:/Quo vadis?.txt')` returns `'//?/c:/Quo vadis[?].txt'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "glob.glob()", "path": "library/glob#glob.glob", "type": "File & Directory Access", "text": "\nReturn a possibly-empty list of path names that match pathname, which must be\na string containing a path specification. pathname can be either absolute\n(like `/usr/src/Python-1.5/Makefile`) or relative (like\n`../../Tools/*/*.gif`), and can contain shell-style wildcards. Broken symlinks\nare included in the results (as in the shell). Whether or not the results are\nsorted depends on the file system. If a file that satisfies conditions is\nremoved or added during the call of this function, whether a path name for\nthat file be included is unspecified.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "glob.iglob()", "path": "library/glob#glob.iglob", "type": "File & Directory Access", "text": "\nReturn an iterator which yields the same values as `glob()` without actually\nstoring them all simultaneously.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "globals()", "path": "library/functions#globals", "type": "Built-in Functions", "text": "\nReturn a dictionary representing the current global symbol table. This is\nalways the dictionary of the current module (inside a function or method, this\nis the module where it is defined, not the module from which it is called).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "graphlib", "path": "library/graphlib", "type": "Data Types", "text": "\nSource code: Lib/graphlib.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "graphlib.CycleError", "path": "library/graphlib#graphlib.CycleError", "type": "Data Types", "text": "\nSubclass of `ValueError` raised by `TopologicalSorter.prepare()` if cycles\nexist in the working graph. If multiple cycles exist, only one undefined\nchoice among them will be reported and included in the exception.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "graphlib.TopologicalSorter", "path": "library/graphlib#graphlib.TopologicalSorter", "type": "Data Types", "text": "\nProvides functionality to topologically sort a graph of hashable nodes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "graphlib.TopologicalSorter.add()", "path": "library/graphlib#graphlib.TopologicalSorter.add", "type": "Data Types", "text": "\nAdd a new node and its predecessors to the graph. Both the node and all\nelements in predecessors must be hashable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "graphlib.TopologicalSorter.done()", "path": "library/graphlib#graphlib.TopologicalSorter.done", "type": "Data Types", "text": "\nMarks a set of nodes returned by `TopologicalSorter.get_ready()` as processed,\nunblocking any successor of each node in nodes for being returned in the\nfuture by a call to `TopologicalSorter.get_ready()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "graphlib.TopologicalSorter.get_ready()", "path": "library/graphlib#graphlib.TopologicalSorter.get_ready", "type": "Data Types", "text": "\nReturns a `tuple` with all the nodes that are ready. Initially it returns all\nnodes with no predecessors, and once those are marked as processed by calling\n`TopologicalSorter.done()`, further calls will return all new nodes that have\nall their predecessors already processed. Once no more progress can be made,\nempty tuples are returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "graphlib.TopologicalSorter.is_active()", "path": "library/graphlib#graphlib.TopologicalSorter.is_active", "type": "Data Types", "text": "\nReturns `True` if more progress can be made and `False` otherwise. Progress\ncan be made if cycles do not block the resolution and either there are still\nnodes ready that haven\u2019t yet been returned by `TopologicalSorter.get_ready()`\nor the number of nodes marked `TopologicalSorter.done()` is less than the\nnumber that have been returned by `TopologicalSorter.get_ready()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "graphlib.TopologicalSorter.prepare()", "path": "library/graphlib#graphlib.TopologicalSorter.prepare", "type": "Data Types", "text": "\nMark the graph as finished and check for cycles in the graph. If any cycle is\ndetected, `CycleError` will be raised, but `get_ready()` can still be used to\nobtain as many nodes as possible until cycles block more progress. After a\ncall to this function, the graph cannot be modified, and therefore no more\nnodes can be added using `add()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "graphlib.TopologicalSorter.static_order()", "path": "library/graphlib#graphlib.TopologicalSorter.static_order", "type": "Data Types", "text": "\nReturns an iterable of nodes in a topological order. Using this method does\nnot require to call `TopologicalSorter.prepare()` or\n`TopologicalSorter.done()`. This method is equivalent to:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "grp", "path": "library/grp", "type": "Unix", "text": "\nThis module provides access to the Unix group database. It is available on all\nUnix versions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "grp.getgrall()", "path": "library/grp#grp.getgrall", "type": "Unix", "text": "\nReturn a list of all available group entries, in arbitrary order.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "grp.getgrgid()", "path": "library/grp#grp.getgrgid", "type": "Unix", "text": "\nReturn the group database entry for the given numeric group ID. `KeyError` is\nraised if the entry asked for cannot be found.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "grp.getgrnam()", "path": "library/grp#grp.getgrnam", "type": "Unix", "text": "\nReturn the group database entry for the given group name. `KeyError` is raised\nif the entry asked for cannot be found.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gzip", "path": "library/gzip", "type": "Data Compression", "text": "\nSource code: Lib/gzip.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gzip.BadGzipFile", "path": "library/gzip#gzip.BadGzipFile", "type": "Data Compression", "text": "\nAn exception raised for invalid gzip files. It inherits `OSError`. `EOFError`\nand `zlib.error` can also be raised for invalid gzip files.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gzip.compress()", "path": "library/gzip#gzip.compress", "type": "Data Compression", "text": "\nCompress the data, returning a `bytes` object containing the compressed data.\ncompresslevel and mtime have the same meaning as in the `GzipFile` constructor\nabove.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gzip.decompress()", "path": "library/gzip#gzip.decompress", "type": "Data Compression", "text": "\nDecompress the data, returning a `bytes` object containing the uncompressed\ndata.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gzip.GzipFile", "path": "library/gzip#gzip.GzipFile", "type": "Data Compression", "text": "\nConstructor for the `GzipFile` class, which simulates most of the methods of a\nfile object, with the exception of the `truncate()` method. At least one of\nfileobj and filename must be given a non-trivial value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gzip.GzipFile.mtime", "path": "library/gzip#gzip.GzipFile.mtime", "type": "Data Compression", "text": "\nWhen decompressing, the value of the last modification time field in the most\nrecently read header may be read from this attribute, as an integer. The\ninitial value before reading any headers is `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gzip.GzipFile.peek()", "path": "library/gzip#gzip.GzipFile.peek", "type": "Data Compression", "text": "\nRead n uncompressed bytes without advancing the file position. At most one\nsingle read on the compressed stream is done to satisfy the call. The number\nof bytes returned may be more or less than requested.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "gzip.open()", "path": "library/gzip#gzip.open", "type": "Data Compression", "text": "\nOpen a gzip-compressed file in binary or text mode, returning a file object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hasattr()", "path": "library/functions#hasattr", "type": "Built-in Functions", "text": "\nThe arguments are an object and a string. The result is `True` if the string\nis the name of one of the object\u2019s attributes, `False` if not. (This is\nimplemented by calling `getattr(object, name)` and seeing whether it raises an\n`AttributeError` or not.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hash()", "path": "library/functions#hash", "type": "Built-in Functions", "text": "\nReturn the hash value of the object (if it has one). Hash values are integers.\nThey are used to quickly compare dictionary keys during a dictionary lookup.\nNumeric values that compare equal have the same hash value (even if they are\nof different types, as is the case for 1 and 1.0).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib", "path": "library/hashlib", "type": "Cryptography", "text": "\nSource code: Lib/hashlib.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.algorithms_available", "path": "library/hashlib#hashlib.algorithms_available", "type": "Cryptography", "text": "\nA set containing the names of the hash algorithms that are available in the\nrunning Python interpreter. These names will be recognized when passed to\n`new()`. `algorithms_guaranteed` will always be a subset. The same algorithm\nmay appear multiple times in this set under different names (thanks to\nOpenSSL).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.algorithms_guaranteed", "path": "library/hashlib#hashlib.algorithms_guaranteed", "type": "Cryptography", "text": "\nA set containing the names of the hash algorithms guaranteed to be supported\nby this module on all platforms. Note that \u2018md5\u2019 is in this list despite some\nupstream vendors offering an odd \u201cFIPS compliant\u201d Python build that excludes\nit.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.blake2b()", "path": "library/hashlib#hashlib.blake2b", "type": "Cryptography", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.blake2b.MAX_DIGEST_SIZE", "path": "library/hashlib#hashlib.blake2b.MAX_DIGEST_SIZE", "type": "Cryptography", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.blake2b.MAX_KEY_SIZE", "path": "library/hashlib#hashlib.blake2b.MAX_KEY_SIZE", "type": "Cryptography", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.blake2b.PERSON_SIZE", "path": "library/hashlib#hashlib.blake2b.PERSON_SIZE", "type": "Cryptography", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.blake2b.SALT_SIZE", "path": "library/hashlib#hashlib.blake2b.SALT_SIZE", "type": "Cryptography", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.blake2s()", "path": "library/hashlib#hashlib.blake2s", "type": "Cryptography", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.blake2s.MAX_DIGEST_SIZE", "path": "library/hashlib#hashlib.blake2s.MAX_DIGEST_SIZE", "type": "Cryptography", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.blake2s.MAX_KEY_SIZE", "path": "library/hashlib#hashlib.blake2s.MAX_KEY_SIZE", "type": "Cryptography", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.blake2s.PERSON_SIZE", "path": "library/hashlib#hashlib.blake2s.PERSON_SIZE", "type": "Cryptography", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.blake2s.SALT_SIZE", "path": "library/hashlib#hashlib.blake2s.SALT_SIZE", "type": "Cryptography", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.hash.block_size", "path": "library/hashlib#hashlib.hash.block_size", "type": "Cryptography", "text": "\nThe internal block size of the hash algorithm in bytes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.hash.copy()", "path": "library/hashlib#hashlib.hash.copy", "type": "Cryptography", "text": "\nReturn a copy (\u201cclone\u201d) of the hash object. This can be used to efficiently\ncompute the digests of data sharing a common initial substring.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.hash.digest()", "path": "library/hashlib#hashlib.hash.digest", "type": "Cryptography", "text": "\nReturn the digest of the data passed to the `update()` method so far. This is\na bytes object of size `digest_size` which may contain bytes in the whole\nrange from 0 to 255.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.hash.digest_size", "path": "library/hashlib#hashlib.hash.digest_size", "type": "Cryptography", "text": "\nThe size of the resulting hash in bytes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.hash.hexdigest()", "path": "library/hashlib#hashlib.hash.hexdigest", "type": "Cryptography", "text": "\nLike `digest()` except the digest is returned as a string object of double\nlength, containing only hexadecimal digits. This may be used to exchange the\nvalue safely in email or other non-binary environments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.hash.name", "path": "library/hashlib#hashlib.hash.name", "type": "Cryptography", "text": "\nThe canonical name of this hash, always lowercase and always suitable as a\nparameter to `new()` to create another hash of this type.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.hash.update()", "path": "library/hashlib#hashlib.hash.update", "type": "Cryptography", "text": "\nUpdate the hash object with the bytes-like object. Repeated calls are\nequivalent to a single call with the concatenation of all the arguments:\n`m.update(a); m.update(b)` is equivalent to `m.update(a+b)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.new()", "path": "library/hashlib#hashlib.new", "type": "Cryptography", "text": "\nIs a generic constructor that takes the string name of the desired algorithm\nas its first parameter. It also exists to allow access to the above listed\nhashes as well as any other algorithms that your OpenSSL library may offer.\nThe named constructors are much faster than `new()` and should be preferred.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.pbkdf2_hmac()", "path": "library/hashlib#hashlib.pbkdf2_hmac", "type": "Cryptography", "text": "\nThe function provides PKCS#5 password-based key derivation function 2. It uses\nHMAC as pseudorandom function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.scrypt()", "path": "library/hashlib#hashlib.scrypt", "type": "Cryptography", "text": "\nThe function provides scrypt password-based key derivation function as defined\nin RFC 7914.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.shake.digest()", "path": "library/hashlib#hashlib.shake.digest", "type": "Cryptography", "text": "\nReturn the digest of the data passed to the `update()` method so far. This is\na bytes object of size length which may contain bytes in the whole range from\n0 to 255.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hashlib.shake.hexdigest()", "path": "library/hashlib#hashlib.shake.hexdigest", "type": "Cryptography", "text": "\nLike `digest()` except the digest is returned as a string object of double\nlength, containing only hexadecimal digits. This may be used to exchange the\nvalue safely in email or other non-binary environments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "heapq", "path": "library/heapq", "type": "Data Types", "text": "\nSource code: Lib/heapq.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "heapq.heapify()", "path": "library/heapq#heapq.heapify", "type": "Data Types", "text": "\nTransform list x into a heap, in-place, in linear time.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "heapq.heappop()", "path": "library/heapq#heapq.heappop", "type": "Data Types", "text": "\nPop and return the smallest item from the heap, maintaining the heap\ninvariant. If the heap is empty, `IndexError` is raised. To access the\nsmallest item without popping it, use `heap[0]`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "heapq.heappush()", "path": "library/heapq#heapq.heappush", "type": "Data Types", "text": "\nPush the value item onto the heap, maintaining the heap invariant.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "heapq.heappushpop()", "path": "library/heapq#heapq.heappushpop", "type": "Data Types", "text": "\nPush item on the heap, then pop and return the smallest item from the heap.\nThe combined action runs more efficiently than `heappush()` followed by a\nseparate call to `heappop()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "heapq.heapreplace()", "path": "library/heapq#heapq.heapreplace", "type": "Data Types", "text": "\nPop and return the smallest item from the heap, and also push the new item.\nThe heap size doesn\u2019t change. If the heap is empty, `IndexError` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "heapq.merge()", "path": "library/heapq#heapq.merge", "type": "Data Types", "text": "\nMerge multiple sorted inputs into a single sorted output (for example, merge\ntimestamped entries from multiple log files). Returns an iterator over the\nsorted values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "heapq.nlargest()", "path": "library/heapq#heapq.nlargest", "type": "Data Types", "text": "\nReturn a list with the n largest elements from the dataset defined by\niterable. key, if provided, specifies a function of one argument that is used\nto extract a comparison key from each element in iterable (for example,\n`key=str.lower`). Equivalent to: `sorted(iterable, key=key,\nreverse=True)[:n]`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "heapq.nsmallest()", "path": "library/heapq#heapq.nsmallest", "type": "Data Types", "text": "\nReturn a list with the n smallest elements from the dataset defined by\niterable. key, if provided, specifies a function of one argument that is used\nto extract a comparison key from each element in iterable (for example,\n`key=str.lower`). Equivalent to: `sorted(iterable, key=key)[:n]`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "help()", "path": "library/functions#help", "type": "Built-in Functions", "text": "\nInvoke the built-in help system. (This function is intended for interactive\nuse.) If no argument is given, the interactive help system starts on the\ninterpreter console. If the argument is a string, then the string is looked up\nas the name of a module, function, class, method, keyword, or documentation\ntopic, and a help page is printed on the console. If the argument is any other\nkind of object, a help page on the object is generated.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hex()", "path": "library/functions#hex", "type": "Built-in Functions", "text": "\nConvert an integer number to a lowercase hexadecimal string prefixed with\n\u201c0x\u201d. If x is not a Python `int` object, it has to define an `__index__()`\nmethod that returns an integer. Some examples:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "High-level API Index", "path": "library/asyncio-api-index", "type": "Asynchronous I/O", "text": "\nThis page lists all high-level async/await enabled asyncio APIs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hmac", "path": "library/hmac", "type": "Cryptography", "text": "\nSource code: Lib/hmac.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hmac.compare_digest()", "path": "library/hmac#hmac.compare_digest", "type": "Cryptography", "text": "\nReturn `a == b`. This function uses an approach designed to prevent timing\nanalysis by avoiding content-based short circuiting behaviour, making it\nappropriate for cryptography. a and b must both be of the same type: either\n`str` (ASCII only, as e.g. returned by `HMAC.hexdigest()`), or a bytes-like\nobject.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hmac.digest()", "path": "library/hmac#hmac.digest", "type": "Cryptography", "text": "\nReturn digest of msg for given secret key and digest. The function is\nequivalent to `HMAC(key, msg, digest).digest()`, but uses an optimized C or\ninline implementation, which is faster for messages that fit into memory. The\nparameters key, msg, and digest have the same meaning as in `new()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hmac.HMAC.block_size", "path": "library/hmac#hmac.HMAC.block_size", "type": "Cryptography", "text": "\nThe internal block size of the hash algorithm in bytes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hmac.HMAC.copy()", "path": "library/hmac#hmac.HMAC.copy", "type": "Cryptography", "text": "\nReturn a copy (\u201cclone\u201d) of the hmac object. This can be used to efficiently\ncompute the digests of strings that share a common initial substring.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hmac.HMAC.digest()", "path": "library/hmac#hmac.HMAC.digest", "type": "Cryptography", "text": "\nReturn the digest of the bytes passed to the `update()` method so far. This\nbytes object will be the same length as the digest_size of the digest given to\nthe constructor. It may contain non-ASCII bytes, including NUL bytes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hmac.HMAC.digest_size", "path": "library/hmac#hmac.HMAC.digest_size", "type": "Cryptography", "text": "\nThe size of the resulting HMAC digest in bytes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hmac.HMAC.hexdigest()", "path": "library/hmac#hmac.HMAC.hexdigest", "type": "Cryptography", "text": "\nLike `digest()` except the digest is returned as a string twice the length\ncontaining only hexadecimal digits. This may be used to exchange the value\nsafely in email or other non-binary environments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hmac.HMAC.name", "path": "library/hmac#hmac.HMAC.name", "type": "Cryptography", "text": "\nThe canonical name of this HMAC, always lowercase, e.g. `hmac-md5`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hmac.HMAC.update()", "path": "library/hmac#hmac.HMAC.update", "type": "Cryptography", "text": "\nUpdate the hmac object with msg. Repeated calls are equivalent to a single\ncall with the concatenation of all the arguments: `m.update(a); m.update(b)`\nis equivalent to `m.update(a + b)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "hmac.new()", "path": "library/hmac#hmac.new", "type": "Cryptography", "text": "\nReturn a new hmac object. key is a bytes or bytearray object giving the secret\nkey. If msg is present, the method call `update(msg)` is made. digestmod is\nthe digest name, digest constructor or module for the HMAC object to use. It\nmay be any name suitable to `hashlib.new()`. Despite its argument position, it\nis required.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html", "path": "library/html", "type": "Structured Markup", "text": "\nSource code: Lib/html/__init__.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.entities", "path": "library/html.entities", "type": "Structured Markup", "text": "\nSource code: Lib/html/entities.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.entities.codepoint2name", "path": "library/html.entities#html.entities.codepoint2name", "type": "Structured Markup", "text": "\nA dictionary that maps Unicode code points to HTML entity names.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.entities.entitydefs", "path": "library/html.entities#html.entities.entitydefs", "type": "Structured Markup", "text": "\nA dictionary mapping XHTML 1.0 entity definitions to their replacement text in\nISO Latin-1.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.entities.html5", "path": "library/html.entities#html.entities.html5", "type": "Structured Markup", "text": "\nA dictionary that maps HTML5 named character references 1 to the equivalent\nUnicode character(s), e.g. `html5['gt;'] == '>'`. Note that the trailing\nsemicolon is included in the name (e.g. `'gt;'`), however some of the names\nare accepted by the standard even without the semicolon: in this case the name\nis present with and without the `';'`. See also `html.unescape()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.entities.name2codepoint", "path": "library/html.entities#html.entities.name2codepoint", "type": "Structured Markup", "text": "\nA dictionary that maps HTML entity names to the Unicode code points.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.escape()", "path": "library/html#html.escape", "type": "Structured Markup", "text": "\nConvert the characters `&`, `<` and `>` in string s to HTML-safe sequences.\nUse this if you need to display text that might contain such characters in\nHTML. If the optional flag quote is true, the characters (`\"`) and (`'`) are\nalso translated; this helps for inclusion in an HTML attribute value delimited\nby quotes, as in `<a href=\"...\">`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.parser", "path": "library/html.parser", "type": "Structured Markup", "text": "\nSource code: Lib/html/parser.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.parser.HTMLParser", "path": "library/html.parser#html.parser.HTMLParser", "type": "Structured Markup", "text": "\nCreate a parser instance able to parse invalid markup.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.parser.HTMLParser.close()", "path": "library/html.parser#html.parser.HTMLParser.close", "type": "Structured Markup", "text": "\nForce processing of all buffered data as if it were followed by an end-of-file\nmark. This method may be redefined by a derived class to define additional\nprocessing at the end of the input, but the redefined version should always\ncall the `HTMLParser` base class method `close()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.parser.HTMLParser.feed()", "path": "library/html.parser#html.parser.HTMLParser.feed", "type": "Structured Markup", "text": "\nFeed some text to the parser. It is processed insofar as it consists of\ncomplete elements; incomplete data is buffered until more data is fed or\n`close()` is called. data must be `str`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.parser.HTMLParser.getpos()", "path": "library/html.parser#html.parser.HTMLParser.getpos", "type": "Structured Markup", "text": "\nReturn current line number and offset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.parser.HTMLParser.get_starttag_text()", "path": "library/html.parser#html.parser.HTMLParser.get_starttag_text", "type": "Structured Markup", "text": "\nReturn the text of the most recently opened start tag. This should not\nnormally be needed for structured processing, but may be useful in dealing\nwith HTML \u201cas deployed\u201d or for re-generating input with minimal changes\n(whitespace between attributes can be preserved, etc.).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.parser.HTMLParser.handle_charref()", "path": "library/html.parser#html.parser.HTMLParser.handle_charref", "type": "Structured Markup", "text": "\nThis method is called to process decimal and hexadecimal numeric character\nreferences of the form `&#NNN;` and `&#xNNN;`. For example, the decimal\nequivalent for `&gt;` is `&#62;`, whereas the hexadecimal is `&#x3E;`; in this\ncase the method will receive `'62'` or `'x3E'`. This method is never called if\nconvert_charrefs is `True`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.parser.HTMLParser.handle_comment()", "path": "library/html.parser#html.parser.HTMLParser.handle_comment", "type": "Structured Markup", "text": "\nThis method is called when a comment is encountered (e.g. `<!--comment-->`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.parser.HTMLParser.handle_data()", "path": "library/html.parser#html.parser.HTMLParser.handle_data", "type": "Structured Markup", "text": "\nThis method is called to process arbitrary data (e.g. text nodes and the\ncontent of `<script>...</script>` and `<style>...</style>`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.parser.HTMLParser.handle_decl()", "path": "library/html.parser#html.parser.HTMLParser.handle_decl", "type": "Structured Markup", "text": "\nThis method is called to handle an HTML doctype declaration (e.g. `<!DOCTYPE\nhtml>`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.parser.HTMLParser.handle_endtag()", "path": "library/html.parser#html.parser.HTMLParser.handle_endtag", "type": "Structured Markup", "text": "\nThis method is called to handle the end tag of an element (e.g. `</div>`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.parser.HTMLParser.handle_entityref()", "path": "library/html.parser#html.parser.HTMLParser.handle_entityref", "type": "Structured Markup", "text": "\nThis method is called to process a named character reference of the form\n`&name;` (e.g. `&gt;`), where name is a general entity reference (e.g.\n`'gt'`). This method is never called if convert_charrefs is `True`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.parser.HTMLParser.handle_pi()", "path": "library/html.parser#html.parser.HTMLParser.handle_pi", "type": "Structured Markup", "text": "\nMethod called when a processing instruction is encountered. The data parameter\nwill contain the entire processing instruction. For example, for the\nprocessing instruction `<?proc color='red'>`, this method would be called as\n`handle_pi(\"proc color='red'\")`. It is intended to be overridden by a derived\nclass; the base class implementation does nothing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.parser.HTMLParser.handle_startendtag()", "path": "library/html.parser#html.parser.HTMLParser.handle_startendtag", "type": "Structured Markup", "text": "\nSimilar to `handle_starttag()`, but called when the parser encounters an\nXHTML-style empty tag (`<img ... />`). This method may be overridden by\nsubclasses which require this particular lexical information; the default\nimplementation simply calls `handle_starttag()` and `handle_endtag()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.parser.HTMLParser.handle_starttag()", "path": "library/html.parser#html.parser.HTMLParser.handle_starttag", "type": "Structured Markup", "text": "\nThis method is called to handle the start of a tag (e.g. `<div id=\"main\">`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.parser.HTMLParser.reset()", "path": "library/html.parser#html.parser.HTMLParser.reset", "type": "Structured Markup", "text": "\nReset the instance. Loses all unprocessed data. This is called implicitly at\ninstantiation time.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.parser.HTMLParser.unknown_decl()", "path": "library/html.parser#html.parser.HTMLParser.unknown_decl", "type": "Structured Markup", "text": "\nThis method is called when an unrecognized declaration is read by the parser.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "html.unescape()", "path": "library/html#html.unescape", "type": "Structured Markup", "text": "\nConvert all named and numeric character references (e.g. `&gt;`, `&#62;`,\n`&#x3e;`) in the string s to the corresponding Unicode characters. This\nfunction uses the rules defined by the HTML 5 standard for both valid and\ninvalid character references, and the `list of HTML 5 named character\nreferences`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http", "path": "library/http", "type": "Internet", "text": "\nSource code: Lib/http/__init__.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client", "path": "library/http.client", "type": "Internet", "text": "\nSource code: Lib/http/client.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.BadStatusLine", "path": "library/http.client#http.client.BadStatusLine", "type": "Internet", "text": "\nA subclass of `HTTPException`. Raised if a server responds with a HTTP status\ncode that we don\u2019t understand.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.CannotSendHeader", "path": "library/http.client#http.client.CannotSendHeader", "type": "Internet", "text": "\nA subclass of `ImproperConnectionState`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.CannotSendRequest", "path": "library/http.client#http.client.CannotSendRequest", "type": "Internet", "text": "\nA subclass of `ImproperConnectionState`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPConnection", "path": "library/http.client#http.client.HTTPConnection", "type": "Internet", "text": "\nAn `HTTPConnection` instance represents one transaction with an HTTP server.\nIt should be instantiated passing it a host and optional port number. If no\nport number is passed, the port is extracted from the host string if it has\nthe form `host:port`, else the default HTTP port (80) is used. If the optional\ntimeout parameter is given, blocking operations (like connection attempts)\nwill timeout after that many seconds (if it is not given, the global default\ntimeout setting is used). The optional source_address parameter may be a tuple\nof a (host, port) to use as the source address the HTTP connection is made\nfrom. The optional blocksize parameter sets the buffer size in bytes for\nsending a file-like message body.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPConnection.blocksize", "path": "library/http.client#http.client.HTTPConnection.blocksize", "type": "Internet", "text": "\nBuffer size in bytes for sending a file-like message body.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPConnection.close()", "path": "library/http.client#http.client.HTTPConnection.close", "type": "Internet", "text": "\nClose the connection to the server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPConnection.connect()", "path": "library/http.client#http.client.HTTPConnection.connect", "type": "Internet", "text": "\nConnect to the server specified when the object was created. By default, this\nis called automatically when making a request if the client does not already\nhave a connection.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPConnection.endheaders()", "path": "library/http.client#http.client.HTTPConnection.endheaders", "type": "Internet", "text": "\nSend a blank line to the server, signalling the end of the headers. The\noptional message_body argument can be used to pass a message body associated\nwith the request.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPConnection.getresponse()", "path": "library/http.client#http.client.HTTPConnection.getresponse", "type": "Internet", "text": "\nShould be called after a request is sent to get the response from the server.\nReturns an `HTTPResponse` instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPConnection.putheader()", "path": "library/http.client#http.client.HTTPConnection.putheader", "type": "Internet", "text": "\nSend an RFC 822-style header to the server. It sends a line to the server\nconsisting of the header, a colon and a space, and the first argument. If more\narguments are given, continuation lines are sent, each consisting of a tab and\nan argument.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPConnection.putrequest()", "path": "library/http.client#http.client.HTTPConnection.putrequest", "type": "Internet", "text": "\nThis should be the first call after the connection to the server has been\nmade. It sends a line to the server consisting of the method string, the url\nstring, and the HTTP version (`HTTP/1.1`). To disable automatic sending of\n`Host:` or `Accept-Encoding:` headers (for example to accept additional\ncontent encodings), specify skip_host or skip_accept_encoding with non-False\nvalues.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPConnection.request()", "path": "library/http.client#http.client.HTTPConnection.request", "type": "Internet", "text": "\nThis will send a request to the server using the HTTP request method method\nand the selector url.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPConnection.send()", "path": "library/http.client#http.client.HTTPConnection.send", "type": "Internet", "text": "\nSend data to the server. This should be used directly only after the\n`endheaders()` method has been called and before `getresponse()` is called.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPConnection.set_debuglevel()", "path": "library/http.client#http.client.HTTPConnection.set_debuglevel", "type": "Internet", "text": "\nSet the debugging level. The default debug level is `0`, meaning no debugging\noutput is printed. Any value greater than `0` will cause all currently defined\ndebug output to be printed to stdout. The `debuglevel` is passed to any new\n`HTTPResponse` objects that are created.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPConnection.set_tunnel()", "path": "library/http.client#http.client.HTTPConnection.set_tunnel", "type": "Internet", "text": "\nSet the host and the port for HTTP Connect Tunnelling. This allows running the\nconnection through a proxy server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPException", "path": "library/http.client#http.client.HTTPException", "type": "Internet", "text": "\nThe base class of the other exceptions in this module. It is a subclass of\n`Exception`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPResponse", "path": "library/http.client#http.client.HTTPResponse", "type": "Internet", "text": "\nClass whose instances are returned upon successful connection. Not\ninstantiated directly by user.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPResponse.closed", "path": "library/http.client#http.client.HTTPResponse.closed", "type": "Internet", "text": "\nIs `True` if the stream is closed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPResponse.debuglevel", "path": "library/http.client#http.client.HTTPResponse.debuglevel", "type": "Internet", "text": "\nA debugging hook. If `debuglevel` is greater than zero, messages will be\nprinted to stdout as the response is read and parsed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPResponse.fileno()", "path": "library/http.client#http.client.HTTPResponse.fileno", "type": "Internet", "text": "\nReturn the `fileno` of the underlying socket.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPResponse.getheader()", "path": "library/http.client#http.client.HTTPResponse.getheader", "type": "Internet", "text": "\nReturn the value of the header name, or default if there is no header matching\nname. If there is more than one header with the name name, return all of the\nvalues joined by \u2018, \u2018. If \u2018default\u2019 is any iterable other than a single\nstring, its elements are similarly returned joined by commas.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPResponse.getheaders()", "path": "library/http.client#http.client.HTTPResponse.getheaders", "type": "Internet", "text": "\nReturn a list of (header, value) tuples.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPResponse.getstatus()", "path": "library/http.client#http.client.HTTPResponse.getstatus", "type": "Internet", "text": "\nDeprecated since version 3.9: Deprecated in favor of `status`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPResponse.geturl()", "path": "library/http.client#http.client.HTTPResponse.geturl", "type": "Internet", "text": "\nDeprecated since version 3.9: Deprecated in favor of `url`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPResponse.headers", "path": "library/http.client#http.client.HTTPResponse.headers", "type": "Internet", "text": "\nHeaders of the response in the form of an `email.message.EmailMessage`\ninstance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPResponse.info()", "path": "library/http.client#http.client.HTTPResponse.info", "type": "Internet", "text": "\nDeprecated since version 3.9: Deprecated in favor of `headers`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPResponse.msg", "path": "library/http.client#http.client.HTTPResponse.msg", "type": "Internet", "text": "\nA `http.client.HTTPMessage` instance containing the response headers.\n`http.client.HTTPMessage` is a subclass of `email.message.Message`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPResponse.read()", "path": "library/http.client#http.client.HTTPResponse.read", "type": "Internet", "text": "\nReads and returns the response body, or up to the next amt bytes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPResponse.readinto()", "path": "library/http.client#http.client.HTTPResponse.readinto", "type": "Internet", "text": "\nReads up to the next len(b) bytes of the response body into the buffer b.\nReturns the number of bytes read.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPResponse.reason", "path": "library/http.client#http.client.HTTPResponse.reason", "type": "Internet", "text": "\nReason phrase returned by server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPResponse.status", "path": "library/http.client#http.client.HTTPResponse.status", "type": "Internet", "text": "\nStatus code returned by server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPResponse.url", "path": "library/http.client#http.client.HTTPResponse.url", "type": "Internet", "text": "\nURL of the resource retrieved, commonly used to determine if a redirect was\nfollowed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPResponse.version", "path": "library/http.client#http.client.HTTPResponse.version", "type": "Internet", "text": "\nHTTP protocol version used by server. 10 for HTTP/1.0, 11 for HTTP/1.1.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPSConnection", "path": "library/http.client#http.client.HTTPSConnection", "type": "Internet", "text": "\nA subclass of `HTTPConnection` that uses SSL for communication with secure\nservers. Default port is `443`. If context is specified, it must be a\n`ssl.SSLContext` instance describing the various SSL options.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTPS_PORT", "path": "library/http.client#http.client.HTTPS_PORT", "type": "Internet", "text": "\nThe default port for the HTTPS protocol (always `443`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.HTTP_PORT", "path": "library/http.client#http.client.HTTP_PORT", "type": "Internet", "text": "\nThe default port for the HTTP protocol (always `80`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.ImproperConnectionState", "path": "library/http.client#http.client.ImproperConnectionState", "type": "Internet", "text": "\nA subclass of `HTTPException`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.IncompleteRead", "path": "library/http.client#http.client.IncompleteRead", "type": "Internet", "text": "\nA subclass of `HTTPException`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.InvalidURL", "path": "library/http.client#http.client.InvalidURL", "type": "Internet", "text": "\nA subclass of `HTTPException`, raised if a port is given and is either non-\nnumeric or empty.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.LineTooLong", "path": "library/http.client#http.client.LineTooLong", "type": "Internet", "text": "\nA subclass of `HTTPException`. Raised if an excessively long line is received\nin the HTTP protocol from the server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.NotConnected", "path": "library/http.client#http.client.NotConnected", "type": "Internet", "text": "\nA subclass of `HTTPException`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.parse_headers()", "path": "library/http.client#http.client.parse_headers", "type": "Internet", "text": "\nParse the headers from a file pointer fp representing a HTTP request/response.\nThe file has to be a `BufferedIOBase` reader (i.e. not text) and must provide\na valid RFC 2822 style header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.RemoteDisconnected", "path": "library/http.client#http.client.RemoteDisconnected", "type": "Internet", "text": "\nA subclass of `ConnectionResetError` and `BadStatusLine`. Raised by\n`HTTPConnection.getresponse()` when the attempt to read the response results\nin no data read from the connection, indicating that the remote end has closed\nthe connection.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.ResponseNotReady", "path": "library/http.client#http.client.ResponseNotReady", "type": "Internet", "text": "\nA subclass of `ImproperConnectionState`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.responses", "path": "library/http.client#http.client.responses", "type": "Internet", "text": "\nThis dictionary maps the HTTP 1.1 status codes to the W3C names.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.UnimplementedFileMode", "path": "library/http.client#http.client.UnimplementedFileMode", "type": "Internet", "text": "\nA subclass of `HTTPException`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.UnknownProtocol", "path": "library/http.client#http.client.UnknownProtocol", "type": "Internet", "text": "\nA subclass of `HTTPException`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.client.UnknownTransferEncoding", "path": "library/http.client#http.client.UnknownTransferEncoding", "type": "Internet", "text": "\nA subclass of `HTTPException`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar", "path": "library/http.cookiejar", "type": "Internet", "text": "\nSource code: Lib/http/cookiejar.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.Cookie", "path": "library/http.cookiejar#http.cookiejar.Cookie", "type": "Internet", "text": "\nThis class represents Netscape, RFC 2109 and RFC 2965 cookies. It is not\nexpected that users of `http.cookiejar` construct their own `Cookie`\ninstances. Instead, if necessary, call `make_cookies()` on a `CookieJar`\ninstance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.Cookie.comment", "path": "library/http.cookiejar#http.cookiejar.Cookie.comment", "type": "Internet", "text": "\nString comment from the server explaining the function of this cookie, or\n`None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.Cookie.comment_url", "path": "library/http.cookiejar#http.cookiejar.Cookie.comment_url", "type": "Internet", "text": "\nURL linking to a comment from the server explaining the function of this\ncookie, or `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.Cookie.discard", "path": "library/http.cookiejar#http.cookiejar.Cookie.discard", "type": "Internet", "text": "\n`True` if this is a session cookie.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.Cookie.domain_initial_dot", "path": "library/http.cookiejar#http.cookiejar.Cookie.domain_initial_dot", "type": "Internet", "text": "\n`True` if the domain explicitly specified by the server began with a dot\n(`'.'`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.Cookie.domain_specified", "path": "library/http.cookiejar#http.cookiejar.Cookie.domain_specified", "type": "Internet", "text": "\n`True` if a domain was explicitly specified by the server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.Cookie.expires", "path": "library/http.cookiejar#http.cookiejar.Cookie.expires", "type": "Internet", "text": "\nInteger expiry date in seconds since epoch, or `None`. See also the\n`is_expired()` method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.Cookie.get_nonstandard_attr()", "path": "library/http.cookiejar#http.cookiejar.Cookie.get_nonstandard_attr", "type": "Internet", "text": "\nIf cookie has the named cookie-attribute, return its value. Otherwise, return\ndefault.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.Cookie.has_nonstandard_attr()", "path": "library/http.cookiejar#http.cookiejar.Cookie.has_nonstandard_attr", "type": "Internet", "text": "\nReturn `True` if cookie has the named cookie-attribute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.Cookie.is_expired()", "path": "library/http.cookiejar#http.cookiejar.Cookie.is_expired", "type": "Internet", "text": "\n`True` if cookie has passed the time at which the server requested it should\nexpire. If now is given (in seconds since the epoch), return whether the\ncookie has expired at the specified time.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.Cookie.name", "path": "library/http.cookiejar#http.cookiejar.Cookie.name", "type": "Internet", "text": "\nCookie name (a string).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.Cookie.path", "path": "library/http.cookiejar#http.cookiejar.Cookie.path", "type": "Internet", "text": "\nCookie path (a string, eg. `'/acme/rocket_launchers'`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.Cookie.port", "path": "library/http.cookiejar#http.cookiejar.Cookie.port", "type": "Internet", "text": "\nString representing a port or a set of ports (eg. \u201880\u2019, or \u201880,8080\u2019), or\n`None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.Cookie.port_specified", "path": "library/http.cookiejar#http.cookiejar.Cookie.port_specified", "type": "Internet", "text": "\n`True` if a port or set of ports was explicitly specified by the server (in\nthe Set-Cookie / Set-Cookie2 header).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.Cookie.rfc2109", "path": "library/http.cookiejar#http.cookiejar.Cookie.rfc2109", "type": "Internet", "text": "\n`True` if this cookie was received as an RFC 2109 cookie (ie. the cookie\narrived in a Set-Cookie header, and the value of the Version cookie-attribute\nin that header was 1). This attribute is provided because `http.cookiejar` may\n\u2018downgrade\u2019 RFC 2109 cookies to Netscape cookies, in which case `version` is\n0.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.Cookie.secure", "path": "library/http.cookiejar#http.cookiejar.Cookie.secure", "type": "Internet", "text": "\n`True` if cookie should only be returned over a secure connection.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.Cookie.set_nonstandard_attr()", "path": "library/http.cookiejar#http.cookiejar.Cookie.set_nonstandard_attr", "type": "Internet", "text": "\nSet the value of the named cookie-attribute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.Cookie.value", "path": "library/http.cookiejar#http.cookiejar.Cookie.value", "type": "Internet", "text": "\nCookie value (a string), or `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.Cookie.version", "path": "library/http.cookiejar#http.cookiejar.Cookie.version", "type": "Internet", "text": "\nInteger or `None`. Netscape cookies have `version` 0\\. RFC 2965 and RFC 2109\ncookies have a `version` cookie-attribute of 1. However, note that\n`http.cookiejar` may \u2018downgrade\u2019 RFC 2109 cookies to Netscape cookies, in\nwhich case `version` is 0.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.CookieJar", "path": "library/http.cookiejar#http.cookiejar.CookieJar", "type": "Internet", "text": "\npolicy is an object implementing the `CookiePolicy` interface.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.CookieJar.add_cookie_header()", "path": "library/http.cookiejar#http.cookiejar.CookieJar.add_cookie_header", "type": "Internet", "text": "\nAdd correct Cookie header to request.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.CookieJar.clear()", "path": "library/http.cookiejar#http.cookiejar.CookieJar.clear", "type": "Internet", "text": "\nClear some cookies.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.CookieJar.clear_session_cookies()", "path": "library/http.cookiejar#http.cookiejar.CookieJar.clear_session_cookies", "type": "Internet", "text": "\nDiscard all session cookies.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.CookieJar.extract_cookies()", "path": "library/http.cookiejar#http.cookiejar.CookieJar.extract_cookies", "type": "Internet", "text": "\nExtract cookies from HTTP response and store them in the `CookieJar`, where\nallowed by policy.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.CookieJar.make_cookies()", "path": "library/http.cookiejar#http.cookiejar.CookieJar.make_cookies", "type": "Internet", "text": "\nReturn sequence of `Cookie` objects extracted from response object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.CookieJar.set_cookie()", "path": "library/http.cookiejar#http.cookiejar.CookieJar.set_cookie", "type": "Internet", "text": "\nSet a `Cookie`, without checking with policy to see whether or not it should\nbe set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.CookieJar.set_cookie_if_ok()", "path": "library/http.cookiejar#http.cookiejar.CookieJar.set_cookie_if_ok", "type": "Internet", "text": "\nSet a `Cookie` if policy says it\u2019s OK to do so.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.CookieJar.set_policy()", "path": "library/http.cookiejar#http.cookiejar.CookieJar.set_policy", "type": "Internet", "text": "\nSet the `CookiePolicy` instance to be used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.CookiePolicy", "path": "library/http.cookiejar#http.cookiejar.CookiePolicy", "type": "Internet", "text": "\nThis class is responsible for deciding whether each cookie should be accepted\nfrom / returned to the server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.CookiePolicy.domain_return_ok()", "path": "library/http.cookiejar#http.cookiejar.CookiePolicy.domain_return_ok", "type": "Internet", "text": "\nReturn `False` if cookies should not be returned, given cookie domain.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.CookiePolicy.hide_cookie2", "path": "library/http.cookiejar#http.cookiejar.CookiePolicy.hide_cookie2", "type": "Internet", "text": "\nDon\u2019t add Cookie2 header to requests (the presence of this header indicates to\nthe server that we understand RFC 2965 cookies).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.CookiePolicy.netscape", "path": "library/http.cookiejar#http.cookiejar.CookiePolicy.netscape", "type": "Internet", "text": "\nImplement Netscape protocol.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.CookiePolicy.path_return_ok()", "path": "library/http.cookiejar#http.cookiejar.CookiePolicy.path_return_ok", "type": "Internet", "text": "\nReturn `False` if cookies should not be returned, given cookie path.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.CookiePolicy.return_ok()", "path": "library/http.cookiejar#http.cookiejar.CookiePolicy.return_ok", "type": "Internet", "text": "\nReturn boolean value indicating whether cookie should be returned to server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.CookiePolicy.rfc2965", "path": "library/http.cookiejar#http.cookiejar.CookiePolicy.rfc2965", "type": "Internet", "text": "\nImplement RFC 2965 protocol.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.CookiePolicy.set_ok()", "path": "library/http.cookiejar#http.cookiejar.CookiePolicy.set_ok", "type": "Internet", "text": "\nReturn boolean value indicating whether cookie should be accepted from server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.DefaultCookiePolicy", "path": "library/http.cookiejar#http.cookiejar.DefaultCookiePolicy", "type": "Internet", "text": "\nConstructor arguments should be passed as keyword arguments only.\nblocked_domains is a sequence of domain names that we never accept cookies\nfrom, nor return cookies to. allowed_domains if not `None`, this is a sequence\nof the only domains for which we accept and return cookies. secure_protocols\nis a sequence of protocols for which secure cookies can be added to. By\ndefault https and wss (secure websocket) are considered secure protocols. For\nall other arguments, see the documentation for `CookiePolicy` and\n`DefaultCookiePolicy` objects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.DefaultCookiePolicy.allowed_domains()", "path": "library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.allowed_domains", "type": "Internet", "text": "\nReturn `None`, or the sequence of allowed domains (as a tuple).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.DefaultCookiePolicy.blocked_domains()", "path": "library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.blocked_domains", "type": "Internet", "text": "\nReturn the sequence of blocked domains (as a tuple).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.DefaultCookiePolicy.DomainLiberal", "path": "library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.DomainLiberal", "type": "Internet", "text": "\nEquivalent to 0 (ie. all of the above Netscape domain strictness flags\nswitched off).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.DefaultCookiePolicy.DomainRFC2965Match", "path": "library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.DomainRFC2965Match", "type": "Internet", "text": "\nWhen setting cookies, require a full RFC 2965 domain-match.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.DefaultCookiePolicy.DomainStrict", "path": "library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.DomainStrict", "type": "Internet", "text": "\nEquivalent to `DomainStrictNoDots|DomainStrictNonDomain`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.DefaultCookiePolicy.DomainStrictNoDots", "path": "library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.DomainStrictNoDots", "type": "Internet", "text": "\nWhen setting cookies, the \u2018host prefix\u2019 must not contain a dot (eg.\n`www.foo.bar.com` can\u2019t set a cookie for `.bar.com`, because `www.foo`\ncontains a dot).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.DefaultCookiePolicy.DomainStrictNonDomain", "path": "library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.DomainStrictNonDomain", "type": "Internet", "text": "\nCookies that did not explicitly specify a `domain` cookie-attribute can only\nbe returned to a domain equal to the domain that set the cookie (eg.\n`spam.example.com` won\u2019t be returned cookies from `example.com` that had no\n`domain` cookie-attribute).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.DefaultCookiePolicy.is_blocked()", "path": "library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.is_blocked", "type": "Internet", "text": "\nReturn whether domain is on the blacklist for setting or receiving cookies.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.DefaultCookiePolicy.is_not_allowed()", "path": "library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.is_not_allowed", "type": "Internet", "text": "\nReturn whether domain is not on the whitelist for setting or receiving\ncookies.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.DefaultCookiePolicy.rfc2109_as_netscape", "path": "library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.rfc2109_as_netscape", "type": "Internet", "text": "\nIf true, request that the `CookieJar` instance downgrade RFC 2109 cookies (ie.\ncookies received in a Set-Cookie header with a version cookie-attribute of 1)\nto Netscape cookies by setting the version attribute of the `Cookie` instance\nto 0. The default value is `None`, in which case RFC 2109 cookies are\ndowngraded if and only if RFC 2965 handling is turned off. Therefore, RFC 2109\ncookies are downgraded by default.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.DefaultCookiePolicy.set_allowed_domains()", "path": "library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.set_allowed_domains", "type": "Internet", "text": "\nSet the sequence of allowed domains, or `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.DefaultCookiePolicy.set_blocked_domains()", "path": "library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.set_blocked_domains", "type": "Internet", "text": "\nSet the sequence of blocked domains.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.DefaultCookiePolicy.strict_domain", "path": "library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.strict_domain", "type": "Internet", "text": "\nDon\u2019t allow sites to set two-component domains with country-code top-level\ndomains like `.co.uk`, `.gov.uk`, `.co.nz`.etc. This is far from perfect and\nisn\u2019t guaranteed to work!\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.DefaultCookiePolicy.strict_ns_domain", "path": "library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.strict_ns_domain", "type": "Internet", "text": "\nFlags indicating how strict to be with domain-matching rules for Netscape\ncookies. See below for acceptable values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.DefaultCookiePolicy.strict_ns_set_initial_dollar", "path": "library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.strict_ns_set_initial_dollar", "type": "Internet", "text": "\nIgnore cookies in Set-Cookie: headers that have names starting with `'$'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.DefaultCookiePolicy.strict_ns_set_path", "path": "library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.strict_ns_set_path", "type": "Internet", "text": "\nDon\u2019t allow setting cookies whose path doesn\u2019t path-match request URI.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.DefaultCookiePolicy.strict_ns_unverifiable", "path": "library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.strict_ns_unverifiable", "type": "Internet", "text": "\nApply RFC 2965 rules on unverifiable transactions even to Netscape cookies.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.DefaultCookiePolicy.strict_rfc2965_unverifiable", "path": "library/http.cookiejar#http.cookiejar.DefaultCookiePolicy.strict_rfc2965_unverifiable", "type": "Internet", "text": "\nFollow RFC 2965 rules on unverifiable transactions (usually, an unverifiable\ntransaction is one resulting from a redirect or a request for an image hosted\non another site). If this is false, cookies are never blocked on the basis of\nverifiability\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.FileCookieJar", "path": "library/http.cookiejar#http.cookiejar.FileCookieJar", "type": "Internet", "text": "\npolicy is an object implementing the `CookiePolicy` interface. For the other\narguments, see the documentation for the corresponding attributes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.FileCookieJar.delayload", "path": "library/http.cookiejar#http.cookiejar.FileCookieJar.delayload", "type": "Internet", "text": "\nIf true, load cookies lazily from disk. This attribute should not be assigned\nto. This is only a hint, since this only affects performance, not behaviour\n(unless the cookies on disk are changing). A `CookieJar` object may ignore it.\nNone of the `FileCookieJar` classes included in the standard library lazily\nloads cookies.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.FileCookieJar.filename", "path": "library/http.cookiejar#http.cookiejar.FileCookieJar.filename", "type": "Internet", "text": "\nFilename of default file in which to keep cookies. This attribute may be\nassigned to.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.FileCookieJar.load()", "path": "library/http.cookiejar#http.cookiejar.FileCookieJar.load", "type": "Internet", "text": "\nLoad cookies from a file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.FileCookieJar.revert()", "path": "library/http.cookiejar#http.cookiejar.FileCookieJar.revert", "type": "Internet", "text": "\nClear all cookies and reload cookies from a saved file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.FileCookieJar.save()", "path": "library/http.cookiejar#http.cookiejar.FileCookieJar.save", "type": "Internet", "text": "\nSave cookies to a file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.LoadError", "path": "library/http.cookiejar#http.cookiejar.LoadError", "type": "Internet", "text": "\nInstances of `FileCookieJar` raise this exception on failure to load cookies\nfrom a file. `LoadError` is a subclass of `OSError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.LWPCookieJar", "path": "library/http.cookiejar#http.cookiejar.LWPCookieJar", "type": "Internet", "text": "\nA `FileCookieJar` that can load from and save cookies to disk in format\ncompatible with the libwww-perl library\u2019s `Set-Cookie3` file format. This is\nconvenient if you want to store cookies in a human-readable file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookiejar.MozillaCookieJar", "path": "library/http.cookiejar#http.cookiejar.MozillaCookieJar", "type": "Internet", "text": "\nA `FileCookieJar` that can load from and save cookies to disk in the Mozilla\n`cookies.txt` file format (which is also used by the Lynx and Netscape\nbrowsers).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookies", "path": "library/http.cookies", "type": "Internet", "text": "\nSource code: Lib/http/cookies.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookies.BaseCookie", "path": "library/http.cookies#http.cookies.BaseCookie", "type": "Internet", "text": "\nThis class is a dictionary-like object whose keys are strings and whose values\nare `Morsel` instances. Note that upon setting a key to a value, the value is\nfirst converted to a `Morsel` containing the key and the value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookies.BaseCookie.js_output()", "path": "library/http.cookies#http.cookies.BaseCookie.js_output", "type": "Internet", "text": "\nReturn an embeddable JavaScript snippet, which, if run on a browser which\nsupports JavaScript, will act the same as if the HTTP headers was sent.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookies.BaseCookie.load()", "path": "library/http.cookies#http.cookies.BaseCookie.load", "type": "Internet", "text": "\nIf rawdata is a string, parse it as an `HTTP_COOKIE` and add the values found\nthere as `Morsel`s. If it is a dictionary, it is equivalent to:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookies.BaseCookie.output()", "path": "library/http.cookies#http.cookies.BaseCookie.output", "type": "Internet", "text": "\nReturn a string representation suitable to be sent as HTTP headers. attrs and\nheader are sent to each `Morsel`\u2019s `output()` method. sep is used to join the\nheaders together, and is by default the combination `'\\r\\n'` (CRLF).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookies.BaseCookie.value_decode()", "path": "library/http.cookies#http.cookies.BaseCookie.value_decode", "type": "Internet", "text": "\nReturn a tuple `(real_value, coded_value)` from a string representation.\n`real_value` can be any type. This method does no decoding in `BaseCookie` \u2014\nit exists so it can be overridden.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookies.BaseCookie.value_encode()", "path": "library/http.cookies#http.cookies.BaseCookie.value_encode", "type": "Internet", "text": "\nReturn a tuple `(real_value, coded_value)`. val can be any type, but\n`coded_value` will always be converted to a string. This method does no\nencoding in `BaseCookie` \u2014 it exists so it can be overridden.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookies.CookieError", "path": "library/http.cookies#http.cookies.CookieError", "type": "Internet", "text": "\nException failing because of RFC 2109 invalidity: incorrect attributes,\nincorrect Set-Cookie header, etc.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookies.Morsel", "path": "library/http.cookies#http.cookies.Morsel", "type": "Internet", "text": "\nAbstract a key/value pair, which has some RFC 2109 attributes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookies.Morsel.coded_value", "path": "library/http.cookies#http.cookies.Morsel.coded_value", "type": "Internet", "text": "\nThe encoded value of the cookie \u2014 this is what should be sent.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookies.Morsel.copy()", "path": "library/http.cookies#http.cookies.Morsel.copy", "type": "Internet", "text": "\nReturn a shallow copy of the Morsel object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookies.Morsel.isReservedKey()", "path": "library/http.cookies#http.cookies.Morsel.isReservedKey", "type": "Internet", "text": "\nWhether K is a member of the set of keys of a `Morsel`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookies.Morsel.js_output()", "path": "library/http.cookies#http.cookies.Morsel.js_output", "type": "Internet", "text": "\nReturn an embeddable JavaScript snippet, which, if run on a browser which\nsupports JavaScript, will act the same as if the HTTP header was sent.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookies.Morsel.key", "path": "library/http.cookies#http.cookies.Morsel.key", "type": "Internet", "text": "\nThe name of the cookie.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookies.Morsel.output()", "path": "library/http.cookies#http.cookies.Morsel.output", "type": "Internet", "text": "\nReturn a string representation of the Morsel, suitable to be sent as an HTTP\nheader. By default, all the attributes are included, unless attrs is given, in\nwhich case it should be a list of attributes to use. header is by default\n`\"Set-Cookie:\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookies.Morsel.OutputString()", "path": "library/http.cookies#http.cookies.Morsel.OutputString", "type": "Internet", "text": "\nReturn a string representing the Morsel, without any surrounding HTTP or\nJavaScript.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookies.Morsel.set()", "path": "library/http.cookies#http.cookies.Morsel.set", "type": "Internet", "text": "\nSet the key, value and coded_value attributes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookies.Morsel.setdefault()", "path": "library/http.cookies#http.cookies.Morsel.setdefault", "type": "Internet", "text": "\nRaise an error if key is not a valid RFC 2109 attribute, otherwise behave the\nsame as `dict.setdefault()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookies.Morsel.update()", "path": "library/http.cookies#http.cookies.Morsel.update", "type": "Internet", "text": "\nUpdate the values in the Morsel dictionary with the values in the dictionary\nvalues. Raise an error if any of the keys in the values dict is not a valid\nRFC 2109 attribute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookies.Morsel.value", "path": "library/http.cookies#http.cookies.Morsel.value", "type": "Internet", "text": "\nThe value of the cookie.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.cookies.SimpleCookie", "path": "library/http.cookies#http.cookies.SimpleCookie", "type": "Internet", "text": "\nThis class derives from `BaseCookie` and overrides `value_decode()` and\n`value_encode()`. SimpleCookie supports strings as cookie values. When setting\nthe value, SimpleCookie calls the builtin `str()` to convert the value to a\nstring. Values received from HTTP are kept as strings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.HTTPStatus", "path": "library/http#http.HTTPStatus", "type": "Internet", "text": "\nNew in version 3.5.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server", "path": "library/http.server", "type": "Internet", "text": "\nSource code: Lib/http/server.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler", "path": "library/http.server#http.server.BaseHTTPRequestHandler", "type": "Internet", "text": "\nThis class is used to handle the HTTP requests that arrive at the server. By\nitself, it cannot respond to any actual HTTP requests; it must be subclassed\nto handle each request method (e.g. GET or POST). `BaseHTTPRequestHandler`\nprovides a number of class and instance variables, and methods for use by\nsubclasses.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.address_string()", "path": "library/http.server#http.server.BaseHTTPRequestHandler.address_string", "type": "Internet", "text": "\nReturns the client address.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.client_address", "path": "library/http.server#http.server.BaseHTTPRequestHandler.client_address", "type": "Internet", "text": "\nContains a tuple of the form `(host, port)` referring to the client\u2019s address.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.close_connection", "path": "library/http.server#http.server.BaseHTTPRequestHandler.close_connection", "type": "Internet", "text": "\nBoolean that should be set before `handle_one_request()` returns, indicating\nif another request may be expected, or if the connection should be shut down.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.command", "path": "library/http.server#http.server.BaseHTTPRequestHandler.command", "type": "Internet", "text": "\nContains the command (request type). For example, `'GET'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.date_time_string()", "path": "library/http.server#http.server.BaseHTTPRequestHandler.date_time_string", "type": "Internet", "text": "\nReturns the date and time given by timestamp (which must be `None` or in the\nformat returned by `time.time()`), formatted for a message header. If\ntimestamp is omitted, it uses the current date and time.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.end_headers()", "path": "library/http.server#http.server.BaseHTTPRequestHandler.end_headers", "type": "Internet", "text": "\nAdds a blank line (indicating the end of the HTTP headers in the response) to\nthe headers buffer and calls `flush_headers()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.error_content_type", "path": "library/http.server#http.server.BaseHTTPRequestHandler.error_content_type", "type": "Internet", "text": "\nSpecifies the Content-Type HTTP header of error responses sent to the client.\nThe default value is `'text/html'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.error_message_format", "path": "library/http.server#http.server.BaseHTTPRequestHandler.error_message_format", "type": "Internet", "text": "\nSpecifies a format string that should be used by `send_error()` method for\nbuilding an error response to the client. The string is filled by default with\nvariables from `responses` based on the status code that passed to\n`send_error()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.flush_headers()", "path": "library/http.server#http.server.BaseHTTPRequestHandler.flush_headers", "type": "Internet", "text": "\nFinally send the headers to the output stream and flush the internal headers\nbuffer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.handle()", "path": "library/http.server#http.server.BaseHTTPRequestHandler.handle", "type": "Internet", "text": "\nCalls `handle_one_request()` once (or, if persistent connections are enabled,\nmultiple times) to handle incoming HTTP requests. You should never need to\noverride it; instead, implement appropriate `do_*()` methods.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.handle_expect_100()", "path": "library/http.server#http.server.BaseHTTPRequestHandler.handle_expect_100", "type": "Internet", "text": "\nWhen a HTTP/1.1 compliant server receives an `Expect: 100-continue` request\nheader it responds back with a `100 Continue` followed by `200 OK` headers.\nThis method can be overridden to raise an error if the server does not want\nthe client to continue. For e.g. server can chose to send `417 Expectation\nFailed` as a response header and `return False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.handle_one_request()", "path": "library/http.server#http.server.BaseHTTPRequestHandler.handle_one_request", "type": "Internet", "text": "\nThis method will parse and dispatch the request to the appropriate `do_*()`\nmethod. You should never need to override it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.headers", "path": "library/http.server#http.server.BaseHTTPRequestHandler.headers", "type": "Internet", "text": "\nHolds an instance of the class specified by the `MessageClass` class variable.\nThis instance parses and manages the headers in the HTTP request. The\n`parse_headers()` function from `http.client` is used to parse the headers and\nit requires that the HTTP request provide a valid RFC 2822 style header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.log_date_time_string()", "path": "library/http.server#http.server.BaseHTTPRequestHandler.log_date_time_string", "type": "Internet", "text": "\nReturns the current date and time, formatted for logging.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.log_error()", "path": "library/http.server#http.server.BaseHTTPRequestHandler.log_error", "type": "Internet", "text": "\nLogs an error when a request cannot be fulfilled. By default, it passes the\nmessage to `log_message()`, so it takes the same arguments (format and\nadditional values).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.log_message()", "path": "library/http.server#http.server.BaseHTTPRequestHandler.log_message", "type": "Internet", "text": "\nLogs an arbitrary message to `sys.stderr`. This is typically overridden to\ncreate custom error logging mechanisms. The format argument is a standard\nprintf-style format string, where the additional arguments to `log_message()`\nare applied as inputs to the formatting. The client ip address and current\ndate and time are prefixed to every message logged.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.log_request()", "path": "library/http.server#http.server.BaseHTTPRequestHandler.log_request", "type": "Internet", "text": "\nLogs an accepted (successful) request. code should specify the numeric HTTP\ncode associated with the response. If a size of the response is available,\nthen it should be passed as the size parameter.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.MessageClass", "path": "library/http.server#http.server.BaseHTTPRequestHandler.MessageClass", "type": "Internet", "text": "\nSpecifies an `email.message.Message`-like class to parse HTTP headers.\nTypically, this is not overridden, and it defaults to\n`http.client.HTTPMessage`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.path", "path": "library/http.server#http.server.BaseHTTPRequestHandler.path", "type": "Internet", "text": "\nContains the request path. If query component of the URL is present, then\n`path` includes the query. Using the terminology of RFC 3986, `path` here\nincludes `hier-part` and the `query`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.protocol_version", "path": "library/http.server#http.server.BaseHTTPRequestHandler.protocol_version", "type": "Internet", "text": "\nThis specifies the HTTP protocol version used in responses. If set to\n`'HTTP/1.1'`, the server will permit HTTP persistent connections; however,\nyour server must then include an accurate `Content-Length` header (using\n`send_header()`) in all of its responses to clients. For backwards\ncompatibility, the setting defaults to `'HTTP/1.0'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.requestline", "path": "library/http.server#http.server.BaseHTTPRequestHandler.requestline", "type": "Internet", "text": "\nContains the string representation of the HTTP request line. The terminating\nCRLF is stripped. This attribute should be set by `handle_one_request()`. If\nno valid request line was processed, it should be set to the empty string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.request_version", "path": "library/http.server#http.server.BaseHTTPRequestHandler.request_version", "type": "Internet", "text": "\nContains the version string from the request. For example, `'HTTP/1.0'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.responses", "path": "library/http.server#http.server.BaseHTTPRequestHandler.responses", "type": "Internet", "text": "\nThis attribute contains a mapping of error code integers to two-element tuples\ncontaining a short and long message. For example, `{code: (shortmessage,\nlongmessage)}`. The shortmessage is usually used as the message key in an\nerror response, and longmessage as the explain key. It is used by\n`send_response_only()` and `send_error()` methods.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.rfile", "path": "library/http.server#http.server.BaseHTTPRequestHandler.rfile", "type": "Internet", "text": "\nAn `io.BufferedIOBase` input stream, ready to read from the start of the\noptional input data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.send_error()", "path": "library/http.server#http.server.BaseHTTPRequestHandler.send_error", "type": "Internet", "text": "\nSends and logs a complete error reply to the client. The numeric code\nspecifies the HTTP error code, with message as an optional, short, human\nreadable description of the error. The explain argument can be used to provide\nmore detailed information about the error; it will be formatted using the\n`error_message_format` attribute and emitted, after a complete set of headers,\nas the response body. The `responses` attribute holds the default values for\nmessage and explain that will be used if no value is provided; for unknown\ncodes the default value for both is the string `???`. The body will be empty\nif the method is HEAD or the response code is one of the following: `1xx`,\n`204 No Content`, `205 Reset Content`, `304 Not Modified`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.send_header()", "path": "library/http.server#http.server.BaseHTTPRequestHandler.send_header", "type": "Internet", "text": "\nAdds the HTTP header to an internal buffer which will be written to the output\nstream when either `end_headers()` or `flush_headers()` is invoked. keyword\nshould specify the header keyword, with value specifying its value. Note that,\nafter the send_header calls are done, `end_headers()` MUST BE called in order\nto complete the operation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.send_response()", "path": "library/http.server#http.server.BaseHTTPRequestHandler.send_response", "type": "Internet", "text": "\nAdds a response header to the headers buffer and logs the accepted request.\nThe HTTP response line is written to the internal buffer, followed by Server\nand Date headers. The values for these two headers are picked up from the\n`version_string()` and `date_time_string()` methods, respectively. If the\nserver does not intend to send any other headers using the `send_header()`\nmethod, then `send_response()` should be followed by an `end_headers()` call.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.send_response_only()", "path": "library/http.server#http.server.BaseHTTPRequestHandler.send_response_only", "type": "Internet", "text": "\nSends the response header only, used for the purposes when `100 Continue`\nresponse is sent by the server to the client. The headers not buffered and\nsent directly the output stream.If the message is not specified, the HTTP\nmessage corresponding the response code is sent.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.server", "path": "library/http.server#http.server.BaseHTTPRequestHandler.server", "type": "Internet", "text": "\nContains the server instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.server_version", "path": "library/http.server#http.server.BaseHTTPRequestHandler.server_version", "type": "Internet", "text": "\nSpecifies the server software version. You may want to override this. The\nformat is multiple whitespace-separated strings, where each string is of the\nform name[/version]. For example, `'BaseHTTP/0.2'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.sys_version", "path": "library/http.server#http.server.BaseHTTPRequestHandler.sys_version", "type": "Internet", "text": "\nContains the Python system version, in a form usable by the `version_string`\nmethod and the `server_version` class variable. For example, `'Python/1.4'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.version_string()", "path": "library/http.server#http.server.BaseHTTPRequestHandler.version_string", "type": "Internet", "text": "\nReturns the server software\u2019s version string. This is a combination of the\n`server_version` and `sys_version` attributes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.BaseHTTPRequestHandler.wfile", "path": "library/http.server#http.server.BaseHTTPRequestHandler.wfile", "type": "Internet", "text": "\nContains the output stream for writing a response back to the client. Proper\nadherence to the HTTP protocol must be used when writing to this stream in\norder to achieve successful interoperation with HTTP clients.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.CGIHTTPRequestHandler", "path": "library/http.server#http.server.CGIHTTPRequestHandler", "type": "Internet", "text": "\nThis class is used to serve either files or output of CGI scripts from the\ncurrent directory and below. Note that mapping HTTP hierarchic structure to\nlocal directory structure is exactly as in `SimpleHTTPRequestHandler`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.CGIHTTPRequestHandler.cgi_directories", "path": "library/http.server#http.server.CGIHTTPRequestHandler.cgi_directories", "type": "Internet", "text": "\nThis defaults to `['/cgi-bin', '/htbin']` and describes directories to treat\nas containing CGI scripts.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.CGIHTTPRequestHandler.do_POST()", "path": "library/http.server#http.server.CGIHTTPRequestHandler.do_POST", "type": "Internet", "text": "\nThis method serves the `'POST'` request type, only allowed for CGI scripts.\nError 501, \u201cCan only POST to CGI scripts\u201d, is output when trying to POST to a\nnon-CGI url.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.HTTPServer", "path": "library/http.server#http.server.HTTPServer", "type": "Internet", "text": "\nThis class builds on the `TCPServer` class by storing the server address as\ninstance variables named `server_name` and `server_port`. The server is\naccessible by the handler, typically through the handler\u2019s `server` instance\nvariable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.SimpleHTTPRequestHandler", "path": "library/http.server#http.server.SimpleHTTPRequestHandler", "type": "Internet", "text": "\nThis class serves files from the current directory and below, directly mapping\nthe directory structure to HTTP requests.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.SimpleHTTPRequestHandler.directory", "path": "library/http.server#http.server.SimpleHTTPRequestHandler.directory", "type": "Internet", "text": "\nIf not specified, the directory to serve is the current working directory.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.SimpleHTTPRequestHandler.do_GET()", "path": "library/http.server#http.server.SimpleHTTPRequestHandler.do_GET", "type": "Internet", "text": "\nThe request is mapped to a local file by interpreting the request as a path\nrelative to the current working directory.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.SimpleHTTPRequestHandler.do_HEAD()", "path": "library/http.server#http.server.SimpleHTTPRequestHandler.do_HEAD", "type": "Internet", "text": "\nThis method serves the `'HEAD'` request type: it sends the headers it would\nsend for the equivalent `GET` request. See the `do_GET()` method for a more\ncomplete explanation of the possible headers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.SimpleHTTPRequestHandler.extensions_map", "path": "library/http.server#http.server.SimpleHTTPRequestHandler.extensions_map", "type": "Internet", "text": "\nA dictionary mapping suffixes into MIME types, contains custom overrides for\nthe default system mappings. The mapping is used case-insensitively, and so\nshould contain only lower-cased keys.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.SimpleHTTPRequestHandler.server_version", "path": "library/http.server#http.server.SimpleHTTPRequestHandler.server_version", "type": "Internet", "text": "\nThis will be `\"SimpleHTTP/\" + __version__`, where `__version__` is defined at\nthe module level.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http.server.ThreadingHTTPServer", "path": "library/http.server#http.server.ThreadingHTTPServer", "type": "Internet", "text": "\nThis class is identical to HTTPServer but uses threads to handle requests by\nusing the `ThreadingMixIn`. This is useful to handle web browsers pre-opening\nsockets, on which `HTTPServer` would wait indefinitely.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "id()", "path": "library/functions#id", "type": "Built-in Functions", "text": "\nReturn the \u201cidentity\u201d of an object. This is an integer which is guaranteed to\nbe unique and constant for this object during its lifetime. Two objects with\nnon-overlapping lifetimes may have the same `id()` value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "IDLE", "path": "library/idle", "type": "Tk", "text": "\nSource code: Lib/idlelib/\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib", "path": "library/imaplib", "type": "Internet", "text": "\nSource code: Lib/imaplib.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4", "path": "library/imaplib#imaplib.IMAP4", "type": "Internet", "text": "\nThis class implements the actual IMAP4 protocol. The connection is created and\nprotocol version (IMAP4 or IMAP4rev1) is determined when the instance is\ninitialized. If host is not specified, `''` (the local host) is used. If port\nis omitted, the standard IMAP4 port (143) is used. The optional timeout\nparameter specifies a timeout in seconds for the connection attempt. If\ntimeout is not given or is None, the global default socket timeout is used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.abort", "path": "library/imaplib#imaplib.IMAP4.abort", "type": "Internet", "text": "\nIMAP4 server errors cause this exception to be raised. This is a sub-class of\n`IMAP4.error`. Note that closing the instance and instantiating a new one will\nusually allow recovery from this exception.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.append()", "path": "library/imaplib#imaplib.IMAP4.append", "type": "Internet", "text": "\nAppend message to named mailbox.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.authenticate()", "path": "library/imaplib#imaplib.IMAP4.authenticate", "type": "Internet", "text": "\nAuthenticate command \u2014 requires response processing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.check()", "path": "library/imaplib#imaplib.IMAP4.check", "type": "Internet", "text": "\nCheckpoint mailbox on server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.close()", "path": "library/imaplib#imaplib.IMAP4.close", "type": "Internet", "text": "\nClose currently selected mailbox. Deleted messages are removed from writable\nmailbox. This is the recommended command before `LOGOUT`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.copy()", "path": "library/imaplib#imaplib.IMAP4.copy", "type": "Internet", "text": "\nCopy message_set messages onto end of new_mailbox.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.create()", "path": "library/imaplib#imaplib.IMAP4.create", "type": "Internet", "text": "\nCreate new mailbox named mailbox.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.debug", "path": "library/imaplib#imaplib.IMAP4.debug", "type": "Internet", "text": "\nInteger value to control debugging output. The initialize value is taken from\nthe module variable `Debug`. Values greater than three trace each command.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.delete()", "path": "library/imaplib#imaplib.IMAP4.delete", "type": "Internet", "text": "\nDelete old mailbox named mailbox.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.deleteacl()", "path": "library/imaplib#imaplib.IMAP4.deleteacl", "type": "Internet", "text": "\nDelete the ACLs (remove any rights) set for who on mailbox.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.enable()", "path": "library/imaplib#imaplib.IMAP4.enable", "type": "Internet", "text": "\nEnable capability (see RFC 5161). Most capabilities do not need to be enabled.\nCurrently only the `UTF8=ACCEPT` capability is supported (see RFC 6855).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.error", "path": "library/imaplib#imaplib.IMAP4.error", "type": "Internet", "text": "\nException raised on any errors. The reason for the exception is passed to the\nconstructor as a string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.expunge()", "path": "library/imaplib#imaplib.IMAP4.expunge", "type": "Internet", "text": "\nPermanently remove deleted items from selected mailbox. Generates an `EXPUNGE`\nresponse for each deleted message. Returned data contains a list of `EXPUNGE`\nmessage numbers in order received.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.fetch()", "path": "library/imaplib#imaplib.IMAP4.fetch", "type": "Internet", "text": "\nFetch (parts of) messages. message_parts should be a string of message part\nnames enclosed within parentheses, eg: `\"(UID BODY[TEXT])\"`. Returned data are\ntuples of message part envelope and data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.getacl()", "path": "library/imaplib#imaplib.IMAP4.getacl", "type": "Internet", "text": "\nGet the `ACL`s for mailbox. The method is non-standard, but is supported by\nthe `Cyrus` server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.getannotation()", "path": "library/imaplib#imaplib.IMAP4.getannotation", "type": "Internet", "text": "\nRetrieve the specified `ANNOTATION`s for mailbox. The method is non-standard,\nbut is supported by the `Cyrus` server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.getquota()", "path": "library/imaplib#imaplib.IMAP4.getquota", "type": "Internet", "text": "\nGet the `quota` root\u2019s resource usage and limits. This method is part of the\nIMAP4 QUOTA extension defined in rfc2087.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.getquotaroot()", "path": "library/imaplib#imaplib.IMAP4.getquotaroot", "type": "Internet", "text": "\nGet the list of `quota` `roots` for the named mailbox. This method is part of\nthe IMAP4 QUOTA extension defined in rfc2087.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.list()", "path": "library/imaplib#imaplib.IMAP4.list", "type": "Internet", "text": "\nList mailbox names in directory matching pattern. directory defaults to the\ntop-level mail folder, and pattern defaults to match anything. Returned data\ncontains a list of `LIST` responses.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.login()", "path": "library/imaplib#imaplib.IMAP4.login", "type": "Internet", "text": "\nIdentify the client using a plaintext password. The password will be quoted.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.login_cram_md5()", "path": "library/imaplib#imaplib.IMAP4.login_cram_md5", "type": "Internet", "text": "\nForce use of `CRAM-MD5` authentication when identifying the client to protect\nthe password. Will only work if the server `CAPABILITY` response includes the\nphrase `AUTH=CRAM-MD5`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.logout()", "path": "library/imaplib#imaplib.IMAP4.logout", "type": "Internet", "text": "\nShutdown connection to server. Returns server `BYE` response.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.lsub()", "path": "library/imaplib#imaplib.IMAP4.lsub", "type": "Internet", "text": "\nList subscribed mailbox names in directory matching pattern. directory\ndefaults to the top level directory and pattern defaults to match any mailbox.\nReturned data are tuples of message part envelope and data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.myrights()", "path": "library/imaplib#imaplib.IMAP4.myrights", "type": "Internet", "text": "\nShow my ACLs for a mailbox (i.e. the rights that I have on mailbox).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.namespace()", "path": "library/imaplib#imaplib.IMAP4.namespace", "type": "Internet", "text": "\nReturns IMAP namespaces as defined in RFC 2342.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.noop()", "path": "library/imaplib#imaplib.IMAP4.noop", "type": "Internet", "text": "\nSend `NOOP` to server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.open()", "path": "library/imaplib#imaplib.IMAP4.open", "type": "Internet", "text": "\nOpens socket to port at host. The optional timeout parameter specifies a\ntimeout in seconds for the connection attempt. If timeout is not given or is\nNone, the global default socket timeout is used. Also note that if the timeout\nparameter is set to be zero, it will raise a `ValueError` to reject creating a\nnon-blocking socket. This method is implicitly called by the `IMAP4`\nconstructor. The connection objects established by this method will be used in\nthe `IMAP4.read()`, `IMAP4.readline()`, `IMAP4.send()`, and `IMAP4.shutdown()`\nmethods. You may override this method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.partial()", "path": "library/imaplib#imaplib.IMAP4.partial", "type": "Internet", "text": "\nFetch truncated part of a message. Returned data is a tuple of message part\nenvelope and data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.PROTOCOL_VERSION", "path": "library/imaplib#imaplib.IMAP4.PROTOCOL_VERSION", "type": "Internet", "text": "\nThe most recent supported protocol in the `CAPABILITY` response from the\nserver.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.proxyauth()", "path": "library/imaplib#imaplib.IMAP4.proxyauth", "type": "Internet", "text": "\nAssume authentication as user. Allows an authorised administrator to proxy\ninto any user\u2019s mailbox.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.read()", "path": "library/imaplib#imaplib.IMAP4.read", "type": "Internet", "text": "\nReads size bytes from the remote server. You may override this method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.readline()", "path": "library/imaplib#imaplib.IMAP4.readline", "type": "Internet", "text": "\nReads one line from the remote server. You may override this method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.readonly", "path": "library/imaplib#imaplib.IMAP4.readonly", "type": "Internet", "text": "\nThis exception is raised when a writable mailbox has its status changed by the\nserver. This is a sub-class of `IMAP4.error`. Some other client now has write\npermission, and the mailbox will need to be re-opened to re-obtain write\npermission.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.recent()", "path": "library/imaplib#imaplib.IMAP4.recent", "type": "Internet", "text": "\nPrompt server for an update. Returned data is `None` if no new messages, else\nvalue of `RECENT` response.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.rename()", "path": "library/imaplib#imaplib.IMAP4.rename", "type": "Internet", "text": "\nRename mailbox named oldmailbox to newmailbox.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.response()", "path": "library/imaplib#imaplib.IMAP4.response", "type": "Internet", "text": "\nReturn data for response code if received, or `None`. Returns the given code,\ninstead of the usual type.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.search()", "path": "library/imaplib#imaplib.IMAP4.search", "type": "Internet", "text": "\nSearch mailbox for matching messages. charset may be `None`, in which case no\n`CHARSET` will be specified in the request to the server. The IMAP protocol\nrequires that at least one criterion be specified; an exception will be raised\nwhen the server returns an error. charset must be `None` if the `UTF8=ACCEPT`\ncapability was enabled using the `enable()` command.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.select()", "path": "library/imaplib#imaplib.IMAP4.select", "type": "Internet", "text": "\nSelect a mailbox. Returned data is the count of messages in mailbox (`EXISTS`\nresponse). The default mailbox is `'INBOX'`. If the readonly flag is set,\nmodifications to the mailbox are not allowed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.send()", "path": "library/imaplib#imaplib.IMAP4.send", "type": "Internet", "text": "\nSends `data` to the remote server. You may override this method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.setacl()", "path": "library/imaplib#imaplib.IMAP4.setacl", "type": "Internet", "text": "\nSet an `ACL` for mailbox. The method is non-standard, but is supported by the\n`Cyrus` server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.setannotation()", "path": "library/imaplib#imaplib.IMAP4.setannotation", "type": "Internet", "text": "\nSet `ANNOTATION`s for mailbox. The method is non-standard, but is supported by\nthe `Cyrus` server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.setquota()", "path": "library/imaplib#imaplib.IMAP4.setquota", "type": "Internet", "text": "\nSet the `quota` root\u2019s resource limits. This method is part of the IMAP4 QUOTA\nextension defined in rfc2087.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.shutdown()", "path": "library/imaplib#imaplib.IMAP4.shutdown", "type": "Internet", "text": "\nClose connection established in `open`. This method is implicitly called by\n`IMAP4.logout()`. You may override this method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.socket()", "path": "library/imaplib#imaplib.IMAP4.socket", "type": "Internet", "text": "\nReturns socket instance used to connect to server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.sort()", "path": "library/imaplib#imaplib.IMAP4.sort", "type": "Internet", "text": "\nThe `sort` command is a variant of `search` with sorting semantics for the\nresults. Returned data contains a space separated list of matching message\nnumbers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.starttls()", "path": "library/imaplib#imaplib.IMAP4.starttls", "type": "Internet", "text": "\nSend a `STARTTLS` command. The ssl_context argument is optional and should be\na `ssl.SSLContext` object. This will enable encryption on the IMAP connection.\nPlease read Security considerations for best practices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.status()", "path": "library/imaplib#imaplib.IMAP4.status", "type": "Internet", "text": "\nRequest named status conditions for mailbox.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.store()", "path": "library/imaplib#imaplib.IMAP4.store", "type": "Internet", "text": "\nAlters flag dispositions for messages in mailbox. command is specified by\nsection 6.4.6 of RFC 2060 as being one of \u201cFLAGS\u201d, \u201c+FLAGS\u201d, or \u201c-FLAGS\u201d,\noptionally with a suffix of \u201c.SILENT\u201d.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.subscribe()", "path": "library/imaplib#imaplib.IMAP4.subscribe", "type": "Internet", "text": "\nSubscribe to new mailbox.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.thread()", "path": "library/imaplib#imaplib.IMAP4.thread", "type": "Internet", "text": "\nThe `thread` command is a variant of `search` with threading semantics for the\nresults. Returned data contains a space separated list of thread members.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.uid()", "path": "library/imaplib#imaplib.IMAP4.uid", "type": "Internet", "text": "\nExecute command args with messages identified by UID, rather than message\nnumber. Returns response appropriate to command. At least one argument must be\nsupplied; if none are provided, the server will return an error and an\nexception will be raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.unselect()", "path": "library/imaplib#imaplib.IMAP4.unselect", "type": "Internet", "text": "\n`imaplib.IMAP4.unselect()` frees server\u2019s resources associated with the\nselected mailbox and returns the server to the authenticated state. This\ncommand performs the same actions as `imaplib.IMAP4.close()`, except that no\nmessages are permanently removed from the currently selected mailbox.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.unsubscribe()", "path": "library/imaplib#imaplib.IMAP4.unsubscribe", "type": "Internet", "text": "\nUnsubscribe from old mailbox.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.utf8_enabled", "path": "library/imaplib#imaplib.IMAP4.utf8_enabled", "type": "Internet", "text": "\nBoolean value that is normally `False`, but is set to `True` if an `enable()`\ncommand is successfully issued for the `UTF8=ACCEPT` capability.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4.xatom()", "path": "library/imaplib#imaplib.IMAP4.xatom", "type": "Internet", "text": "\nAllow simple extension commands notified by server in `CAPABILITY` response.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4_SSL", "path": "library/imaplib#imaplib.IMAP4_SSL", "type": "Internet", "text": "\nThis is a subclass derived from `IMAP4` that connects over an SSL encrypted\nsocket (to use this class you need a socket module that was compiled with SSL\nsupport). If host is not specified, `''` (the local host) is used. If port is\nomitted, the standard IMAP4-over-SSL port (993) is used. ssl_context is a\n`ssl.SSLContext` object which allows bundling SSL configuration options,\ncertificates and private keys into a single (potentially long-lived)\nstructure. Please read Security considerations for best practices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.IMAP4_stream", "path": "library/imaplib#imaplib.IMAP4_stream", "type": "Internet", "text": "\nThis is a subclass derived from `IMAP4` that connects to the `stdin/stdout`\nfile descriptors created by passing command to `subprocess.Popen()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.Int2AP()", "path": "library/imaplib#imaplib.Int2AP", "type": "Internet", "text": "\nConverts an integer into a bytes representation using characters from the set\n[`A` .. `P`].\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.Internaldate2tuple()", "path": "library/imaplib#imaplib.Internaldate2tuple", "type": "Internet", "text": "\nParse an IMAP4 `INTERNALDATE` string and return corresponding local time. The\nreturn value is a `time.struct_time` tuple or `None` if the string has wrong\nformat.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.ParseFlags()", "path": "library/imaplib#imaplib.ParseFlags", "type": "Internet", "text": "\nConverts an IMAP4 `FLAGS` response to a tuple of individual flags.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imaplib.Time2Internaldate()", "path": "library/imaplib#imaplib.Time2Internaldate", "type": "Internet", "text": "\nConvert date_time to an IMAP4 `INTERNALDATE` representation. The return value\nis a string in the form: `\"DD-Mmm-YYYY HH:MM:SS +HHMM\"` (including double-\nquotes). The date_time argument can be a number (int or float) representing\nseconds since epoch (as returned by `time.time()`), a 9-tuple representing\nlocal time an instance of `time.struct_time` (as returned by\n`time.localtime()`), an aware instance of `datetime.datetime`, or a double-\nquoted string. In the last case, it is assumed to already be in the correct\nformat.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imghdr", "path": "library/imghdr", "type": "Multimedia", "text": "\nSource code: Lib/imghdr.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imghdr.tests", "path": "library/imghdr#imghdr.tests", "type": "Multimedia", "text": "\nA list of functions performing the individual tests. Each function takes two\narguments: the byte-stream and an open file-like object. When `what()` is\ncalled with a byte-stream, the file-like object will be `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "imghdr.what()", "path": "library/imghdr#imghdr.what", "type": "Multimedia", "text": "\nTests the image data contained in the file named by filename, and returns a\nstring describing the image type. If optional h is provided, the filename is\nignored and h is assumed to contain the byte stream to test.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ImportError", "path": "library/exceptions#ImportError", "type": "Built-in Exceptions", "text": "\nRaised when the `import` statement has troubles trying to load a module. Also\nraised when the \u201cfrom list\u201d in `from ... import` has a name that cannot be\nfound.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib", "path": "library/importlib", "type": "Importing", "text": "\nNew in version 3.1.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.ExecutionLoader", "path": "library/importlib#importlib.abc.ExecutionLoader", "type": "Importing", "text": "\nAn abstract base class which inherits from `InspectLoader` that, when\nimplemented, helps a module to be executed as a script. The ABC represents an\noptional PEP 302 protocol.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.ExecutionLoader.get_filename()", "path": "library/importlib#importlib.abc.ExecutionLoader.get_filename", "type": "Importing", "text": "\nAn abstract method that is to return the value of `__file__` for the specified\nmodule. If no path is available, `ImportError` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.FileLoader", "path": "library/importlib#importlib.abc.FileLoader", "type": "Importing", "text": "\nAn abstract base class which inherits from `ResourceLoader` and\n`ExecutionLoader`, providing concrete implementations of\n`ResourceLoader.get_data()` and `ExecutionLoader.get_filename()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.FileLoader.get_data()", "path": "library/importlib#importlib.abc.FileLoader.get_data", "type": "Importing", "text": "\nReads path as a binary file and returns the bytes from it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.FileLoader.get_filename()", "path": "library/importlib#importlib.abc.FileLoader.get_filename", "type": "Importing", "text": "\nReturns `path`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.FileLoader.load_module()", "path": "library/importlib#importlib.abc.FileLoader.load_module", "type": "Importing", "text": "\nCalls super\u2019s `load_module()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.FileLoader.name", "path": "library/importlib#importlib.abc.FileLoader.name", "type": "Importing", "text": "\nThe name of the module the loader can handle.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.FileLoader.path", "path": "library/importlib#importlib.abc.FileLoader.path", "type": "Importing", "text": "\nPath to the file of the module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.Finder", "path": "library/importlib#importlib.abc.Finder", "type": "Importing", "text": "\nAn abstract base class representing a finder.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.Finder.find_module()", "path": "library/importlib#importlib.abc.Finder.find_module", "type": "Importing", "text": "\nAn abstract method for finding a loader for the specified module. Originally\nspecified in PEP 302, this method was meant for use in `sys.meta_path` and in\nthe path-based import subsystem.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.InspectLoader", "path": "library/importlib#importlib.abc.InspectLoader", "type": "Importing", "text": "\nAn abstract base class for a loader which implements the optional PEP 302\nprotocol for loaders that inspect modules.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.InspectLoader.exec_module()", "path": "library/importlib#importlib.abc.InspectLoader.exec_module", "type": "Importing", "text": "\nImplementation of `Loader.exec_module()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.InspectLoader.get_code()", "path": "library/importlib#importlib.abc.InspectLoader.get_code", "type": "Importing", "text": "\nReturn the code object for a module, or `None` if the module does not have a\ncode object (as would be the case, for example, for a built-in module). Raise\nan `ImportError` if loader cannot find the requested module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.InspectLoader.get_source()", "path": "library/importlib#importlib.abc.InspectLoader.get_source", "type": "Importing", "text": "\nAn abstract method to return the source of a module. It is returned as a text\nstring using universal newlines, translating all recognized line separators\ninto `'\\n'` characters. Returns `None` if no source is available (e.g. a\nbuilt-in module). Raises `ImportError` if the loader cannot find the module\nspecified.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.InspectLoader.is_package()", "path": "library/importlib#importlib.abc.InspectLoader.is_package", "type": "Importing", "text": "\nAn abstract method to return a true value if the module is a package, a false\nvalue otherwise. `ImportError` is raised if the loader cannot find the module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.InspectLoader.load_module()", "path": "library/importlib#importlib.abc.InspectLoader.load_module", "type": "Importing", "text": "\nImplementation of `Loader.load_module()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.InspectLoader.source_to_code()", "path": "library/importlib#importlib.abc.InspectLoader.source_to_code", "type": "Importing", "text": "\nCreate a code object from Python source.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.Loader", "path": "library/importlib#importlib.abc.Loader", "type": "Importing", "text": "\nAn abstract base class for a loader. See PEP 302 for the exact definition for\na loader.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.Loader.create_module()", "path": "library/importlib#importlib.abc.Loader.create_module", "type": "Importing", "text": "\nA method that returns the module object to use when importing a module. This\nmethod may return `None`, indicating that default module creation semantics\nshould take place.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.Loader.exec_module()", "path": "library/importlib#importlib.abc.Loader.exec_module", "type": "Importing", "text": "\nAn abstract method that executes the module in its own namespace when a module\nis imported or reloaded. The module should already be initialized when\n`exec_module()` is called. When this method exists, `create_module()` must be\ndefined.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.Loader.load_module()", "path": "library/importlib#importlib.abc.Loader.load_module", "type": "Importing", "text": "\nA legacy method for loading a module. If the module cannot be loaded,\n`ImportError` is raised, otherwise the loaded module is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.Loader.module_repr()", "path": "library/importlib#importlib.abc.Loader.module_repr", "type": "Importing", "text": "\nA legacy method which when implemented calculates and returns the given\nmodule\u2019s repr, as a string. The module type\u2019s default repr() will use the\nresult of this method as appropriate.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.MetaPathFinder", "path": "library/importlib#importlib.abc.MetaPathFinder", "type": "Importing", "text": "\nAn abstract base class representing a meta path finder. For compatibility,\nthis is a subclass of `Finder`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.MetaPathFinder.find_module()", "path": "library/importlib#importlib.abc.MetaPathFinder.find_module", "type": "Importing", "text": "\nA legacy method for finding a loader for the specified module. If this is a\ntop-level import, path will be `None`. Otherwise, this is a search for a\nsubpackage or module and path will be the value of `__path__` from the parent\npackage. If a loader cannot be found, `None` is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.MetaPathFinder.find_spec()", "path": "library/importlib#importlib.abc.MetaPathFinder.find_spec", "type": "Importing", "text": "\nAn abstract method for finding a spec for the specified module. If this is a\ntop-level import, path will be `None`. Otherwise, this is a search for a\nsubpackage or module and path will be the value of `__path__` from the parent\npackage. If a spec cannot be found, `None` is returned. When passed in,\n`target` is a module object that the finder may use to make a more educated\nguess about what spec to return. `importlib.util.spec_from_loader()` may be\nuseful for implementing concrete `MetaPathFinders`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.MetaPathFinder.invalidate_caches()", "path": "library/importlib#importlib.abc.MetaPathFinder.invalidate_caches", "type": "Importing", "text": "\nAn optional method which, when called, should invalidate any internal cache\nused by the finder. Used by `importlib.invalidate_caches()` when invalidating\nthe caches of all finders on `sys.meta_path`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.PathEntryFinder", "path": "library/importlib#importlib.abc.PathEntryFinder", "type": "Importing", "text": "\nAn abstract base class representing a path entry finder. Though it bears some\nsimilarities to `MetaPathFinder`, `PathEntryFinder` is meant for use only\nwithin the path-based import subsystem provided by `PathFinder`. This ABC is a\nsubclass of `Finder` for compatibility reasons only.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.PathEntryFinder.find_loader()", "path": "library/importlib#importlib.abc.PathEntryFinder.find_loader", "type": "Importing", "text": "\nA legacy method for finding a loader for the specified module. Returns a\n2-tuple of `(loader, portion)` where `portion` is a sequence of file system\nlocations contributing to part of a namespace package. The loader may be\n`None` while specifying `portion` to signify the contribution of the file\nsystem locations to a namespace package. An empty list can be used for\n`portion` to signify the loader is not part of a namespace package. If\n`loader` is `None` and `portion` is the empty list then no loader or location\nfor a namespace package were found (i.e. failure to find anything for the\nmodule).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.PathEntryFinder.find_module()", "path": "library/importlib#importlib.abc.PathEntryFinder.find_module", "type": "Importing", "text": "\nA concrete implementation of `Finder.find_module()` which is equivalent to\n`self.find_loader(fullname)[0]`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.PathEntryFinder.find_spec()", "path": "library/importlib#importlib.abc.PathEntryFinder.find_spec", "type": "Importing", "text": "\nAn abstract method for finding a spec for the specified module. The finder\nwill search for the module only within the path entry to which it is assigned.\nIf a spec cannot be found, `None` is returned. When passed in, `target` is a\nmodule object that the finder may use to make a more educated guess about what\nspec to return. `importlib.util.spec_from_loader()` may be useful for\nimplementing concrete `PathEntryFinders`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.PathEntryFinder.invalidate_caches()", "path": "library/importlib#importlib.abc.PathEntryFinder.invalidate_caches", "type": "Importing", "text": "\nAn optional method which, when called, should invalidate any internal cache\nused by the finder. Used by `PathFinder.invalidate_caches()` when invalidating\nthe caches of all cached finders.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.ResourceLoader", "path": "library/importlib#importlib.abc.ResourceLoader", "type": "Importing", "text": "\nAn abstract base class for a loader which implements the optional PEP 302\nprotocol for loading arbitrary resources from the storage back-end.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.ResourceLoader.get_data()", "path": "library/importlib#importlib.abc.ResourceLoader.get_data", "type": "Importing", "text": "\nAn abstract method to return the bytes for the data located at path. Loaders\nthat have a file-like storage back-end that allows storing arbitrary data can\nimplement this abstract method to give direct access to the data stored.\n`OSError` is to be raised if the path cannot be found. The path is expected to\nbe constructed using a module\u2019s `__file__` attribute or an item from a\npackage\u2019s `__path__`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.ResourceReader", "path": "library/importlib#importlib.abc.ResourceReader", "type": "Importing", "text": "\nSuperseded by TraversableReader\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.ResourceReader.contents()", "path": "library/importlib#importlib.abc.ResourceReader.contents", "type": "Importing", "text": "\nReturns an iterable of strings over the contents of the package. Do note that\nit is not required that all names returned by the iterator be actual\nresources, e.g. it is acceptable to return names for which `is_resource()`\nwould be false.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.ResourceReader.is_resource()", "path": "library/importlib#importlib.abc.ResourceReader.is_resource", "type": "Importing", "text": "\nReturns `True` if the named name is considered a resource. `FileNotFoundError`\nis raised if name does not exist.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.ResourceReader.open_resource()", "path": "library/importlib#importlib.abc.ResourceReader.open_resource", "type": "Importing", "text": "\nReturns an opened, file-like object for binary reading of the resource.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.ResourceReader.resource_path()", "path": "library/importlib#importlib.abc.ResourceReader.resource_path", "type": "Importing", "text": "\nReturns the file system path to the resource.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.SourceLoader", "path": "library/importlib#importlib.abc.SourceLoader", "type": "Importing", "text": "\nAn abstract base class for implementing source (and optionally bytecode) file\nloading. The class inherits from both `ResourceLoader` and `ExecutionLoader`,\nrequiring the implementation of:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.SourceLoader.exec_module()", "path": "library/importlib#importlib.abc.SourceLoader.exec_module", "type": "Importing", "text": "\nConcrete implementation of `Loader.exec_module()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.SourceLoader.get_code()", "path": "library/importlib#importlib.abc.SourceLoader.get_code", "type": "Importing", "text": "\nConcrete implementation of `InspectLoader.get_code()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.SourceLoader.get_source()", "path": "library/importlib#importlib.abc.SourceLoader.get_source", "type": "Importing", "text": "\nConcrete implementation of `InspectLoader.get_source()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.SourceLoader.is_package()", "path": "library/importlib#importlib.abc.SourceLoader.is_package", "type": "Importing", "text": "\nConcrete implementation of `InspectLoader.is_package()`. A module is\ndetermined to be a package if its file path (as provided by\n`ExecutionLoader.get_filename()`) is a file named `__init__` when the file\nextension is removed and the module name itself does not end in `__init__`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.SourceLoader.load_module()", "path": "library/importlib#importlib.abc.SourceLoader.load_module", "type": "Importing", "text": "\nConcrete implementation of `Loader.load_module()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.SourceLoader.path_mtime()", "path": "library/importlib#importlib.abc.SourceLoader.path_mtime", "type": "Importing", "text": "\nOptional abstract method which returns the modification time for the specified\npath.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.SourceLoader.path_stats()", "path": "library/importlib#importlib.abc.SourceLoader.path_stats", "type": "Importing", "text": "\nOptional abstract method which returns a `dict` containing metadata about the\nspecified path. Supported dictionary keys are:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.SourceLoader.set_data()", "path": "library/importlib#importlib.abc.SourceLoader.set_data", "type": "Importing", "text": "\nOptional abstract method which writes the specified bytes to a file path. Any\nintermediate directories which do not exist are to be created automatically.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.Traversable", "path": "library/importlib#importlib.abc.Traversable", "type": "Importing", "text": "\nAn object with a subset of pathlib.Path methods suitable for traversing\ndirectories and opening files.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.abc.TraversableReader", "path": "library/importlib#importlib.abc.TraversableReader", "type": "Importing", "text": "\nAn abstract base class for resource readers capable of serving the `files`\ninterface. Subclasses ResourceReader and provides concrete implementations of\nthe ResourceReader\u2019s abstract methods. Therefore, any loader supplying\nTraversableReader also supplies ResourceReader.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.find_loader()", "path": "library/importlib#importlib.find_loader", "type": "Importing", "text": "\nFind the loader for a module, optionally within the specified path. If the\nmodule is in `sys.modules`, then `sys.modules[name].__loader__` is returned\n(unless the loader would be `None` or is not set, in which case `ValueError`\nis raised). Otherwise a search using `sys.meta_path` is done. `None` is\nreturned if no loader is found.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.import_module()", "path": "library/importlib#importlib.import_module", "type": "Importing", "text": "\nImport a module. The name argument specifies what module to import in absolute\nor relative terms (e.g. either `pkg.mod` or `..mod`). If the name is specified\nin relative terms, then the package argument must be set to the name of the\npackage which is to act as the anchor for resolving the package name (e.g.\n`import_module('..mod', 'pkg.subpkg')` will import `pkg.mod`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.invalidate_caches()", "path": "library/importlib#importlib.invalidate_caches", "type": "Importing", "text": "\nInvalidate the internal caches of finders stored at `sys.meta_path`. If a\nfinder implements `invalidate_caches()` then it will be called to perform the\ninvalidation. This function should be called if any modules are\ncreated/installed while your program is running to guarantee all finders will\nnotice the new module\u2019s existence.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.all_suffixes()", "path": "library/importlib#importlib.machinery.all_suffixes", "type": "Importing", "text": "\nReturns a combined list of strings representing all file suffixes for modules\nrecognized by the standard import machinery. This is a helper for code which\nsimply needs to know if a filesystem path potentially refers to a module\nwithout needing any details on the kind of module (for example,\n`inspect.getmodulename()`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.BuiltinImporter", "path": "library/importlib#importlib.machinery.BuiltinImporter", "type": "Importing", "text": "\nAn importer for built-in modules. All known built-in modules are listed in\n`sys.builtin_module_names`. This class implements the\n`importlib.abc.MetaPathFinder` and `importlib.abc.InspectLoader` ABCs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.BYTECODE_SUFFIXES", "path": "library/importlib#importlib.machinery.BYTECODE_SUFFIXES", "type": "Importing", "text": "\nA list of strings representing the recognized file suffixes for bytecode\nmodules (including the leading dot).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.DEBUG_BYTECODE_SUFFIXES", "path": "library/importlib#importlib.machinery.DEBUG_BYTECODE_SUFFIXES", "type": "Importing", "text": "\nA list of strings representing the file suffixes for non-optimized bytecode\nmodules.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.ExtensionFileLoader", "path": "library/importlib#importlib.machinery.ExtensionFileLoader", "type": "Importing", "text": "\nA concrete implementation of `importlib.abc.ExecutionLoader` for extension\nmodules.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.ExtensionFileLoader.create_module()", "path": "library/importlib#importlib.machinery.ExtensionFileLoader.create_module", "type": "Importing", "text": "\nCreates the module object from the given specification in accordance with PEP\n489.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.ExtensionFileLoader.exec_module()", "path": "library/importlib#importlib.machinery.ExtensionFileLoader.exec_module", "type": "Importing", "text": "\nInitializes the given module object in accordance with PEP 489.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.ExtensionFileLoader.get_code()", "path": "library/importlib#importlib.machinery.ExtensionFileLoader.get_code", "type": "Importing", "text": "\nReturns `None` as extension modules lack a code object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.ExtensionFileLoader.get_filename()", "path": "library/importlib#importlib.machinery.ExtensionFileLoader.get_filename", "type": "Importing", "text": "\nReturns `path`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.ExtensionFileLoader.get_source()", "path": "library/importlib#importlib.machinery.ExtensionFileLoader.get_source", "type": "Importing", "text": "\nReturns `None` as extension modules do not have source code.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.ExtensionFileLoader.is_package()", "path": "library/importlib#importlib.machinery.ExtensionFileLoader.is_package", "type": "Importing", "text": "\nReturns `True` if the file path points to a package\u2019s `__init__` module based\non `EXTENSION_SUFFIXES`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.ExtensionFileLoader.name", "path": "library/importlib#importlib.machinery.ExtensionFileLoader.name", "type": "Importing", "text": "\nName of the module the loader supports.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.ExtensionFileLoader.path", "path": "library/importlib#importlib.machinery.ExtensionFileLoader.path", "type": "Importing", "text": "\nPath to the extension module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.EXTENSION_SUFFIXES", "path": "library/importlib#importlib.machinery.EXTENSION_SUFFIXES", "type": "Importing", "text": "\nA list of strings representing the recognized file suffixes for extension\nmodules.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.FileFinder", "path": "library/importlib#importlib.machinery.FileFinder", "type": "Importing", "text": "\nA concrete implementation of `importlib.abc.PathEntryFinder` which caches\nresults from the file system.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.FileFinder.find_loader()", "path": "library/importlib#importlib.machinery.FileFinder.find_loader", "type": "Importing", "text": "\nAttempt to find the loader to handle fullname within `path`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.FileFinder.find_spec()", "path": "library/importlib#importlib.machinery.FileFinder.find_spec", "type": "Importing", "text": "\nAttempt to find the spec to handle fullname within `path`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.FileFinder.invalidate_caches()", "path": "library/importlib#importlib.machinery.FileFinder.invalidate_caches", "type": "Importing", "text": "\nClear out the internal cache.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.FileFinder.path", "path": "library/importlib#importlib.machinery.FileFinder.path", "type": "Importing", "text": "\nThe path the finder will search in.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.FileFinder.path_hook()", "path": "library/importlib#importlib.machinery.FileFinder.path_hook", "type": "Importing", "text": "\nA class method which returns a closure for use on `sys.path_hooks`. An\ninstance of `FileFinder` is returned by the closure using the path argument\ngiven to the closure directly and loader_details indirectly.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.FrozenImporter", "path": "library/importlib#importlib.machinery.FrozenImporter", "type": "Importing", "text": "\nAn importer for frozen modules. This class implements the\n`importlib.abc.MetaPathFinder` and `importlib.abc.InspectLoader` ABCs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.ModuleSpec", "path": "library/importlib#importlib.machinery.ModuleSpec", "type": "Importing", "text": "\nA specification for a module\u2019s import-system-related state. This is typically\nexposed as the module\u2019s `__spec__` attribute. In the descriptions below, the\nnames in parentheses give the corresponding attribute available directly on\nthe module object. E.g. `module.__spec__.origin == module.__file__`. Note\nhowever that while the values are usually equivalent, they can differ since\nthere is no synchronization between the two objects. Thus it is possible to\nupdate the module\u2019s `__path__` at runtime, and this will not be automatically\nreflected in `__spec__.submodule_search_locations`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.ModuleSpec.cached", "path": "library/importlib#importlib.machinery.ModuleSpec.cached", "type": "Importing", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.ModuleSpec.has_location", "path": "library/importlib#importlib.machinery.ModuleSpec.has_location", "type": "Importing", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.ModuleSpec.loader", "path": "library/importlib#importlib.machinery.ModuleSpec.loader", "type": "Importing", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.ModuleSpec.loader_state", "path": "library/importlib#importlib.machinery.ModuleSpec.loader_state", "type": "Importing", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.ModuleSpec.name", "path": "library/importlib#importlib.machinery.ModuleSpec.name", "type": "Importing", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.ModuleSpec.origin", "path": "library/importlib#importlib.machinery.ModuleSpec.origin", "type": "Importing", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.ModuleSpec.parent", "path": "library/importlib#importlib.machinery.ModuleSpec.parent", "type": "Importing", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.ModuleSpec.submodule_search_locations", "path": "library/importlib#importlib.machinery.ModuleSpec.submodule_search_locations", "type": "Importing", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.OPTIMIZED_BYTECODE_SUFFIXES", "path": "library/importlib#importlib.machinery.OPTIMIZED_BYTECODE_SUFFIXES", "type": "Importing", "text": "\nA list of strings representing the file suffixes for optimized bytecode\nmodules.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.PathFinder", "path": "library/importlib#importlib.machinery.PathFinder", "type": "Importing", "text": "\nA Finder for `sys.path` and package `__path__` attributes. This class\nimplements the `importlib.abc.MetaPathFinder` ABC.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.PathFinder.find_module()", "path": "library/importlib#importlib.machinery.PathFinder.find_module", "type": "Importing", "text": "\nA legacy wrapper around `find_spec()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.PathFinder.find_spec()", "path": "library/importlib#importlib.machinery.PathFinder.find_spec", "type": "Importing", "text": "\nClass method that attempts to find a spec for the module specified by fullname\non `sys.path` or, if defined, on path. For each path entry that is searched,\n`sys.path_importer_cache` is checked. If a non-false object is found then it\nis used as the path entry finder to look for the module being searched for. If\nno entry is found in `sys.path_importer_cache`, then `sys.path_hooks` is\nsearched for a finder for the path entry and, if found, is stored in\n`sys.path_importer_cache` along with being queried about the module. If no\nfinder is ever found then `None` is both stored in the cache and returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.PathFinder.invalidate_caches()", "path": "library/importlib#importlib.machinery.PathFinder.invalidate_caches", "type": "Importing", "text": "\nCalls `importlib.abc.PathEntryFinder.invalidate_caches()` on all finders\nstored in `sys.path_importer_cache` that define the method. Otherwise entries\nin `sys.path_importer_cache` set to `None` are deleted.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.SourceFileLoader", "path": "library/importlib#importlib.machinery.SourceFileLoader", "type": "Importing", "text": "\nA concrete implementation of `importlib.abc.SourceLoader` by subclassing\n`importlib.abc.FileLoader` and providing some concrete implementations of\nother methods.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.SourceFileLoader.is_package()", "path": "library/importlib#importlib.machinery.SourceFileLoader.is_package", "type": "Importing", "text": "\nReturn `True` if `path` appears to be for a package.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.SourceFileLoader.load_module()", "path": "library/importlib#importlib.machinery.SourceFileLoader.load_module", "type": "Importing", "text": "\nConcrete implementation of `importlib.abc.Loader.load_module()` where\nspecifying the name of the module to load is optional.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.SourceFileLoader.name", "path": "library/importlib#importlib.machinery.SourceFileLoader.name", "type": "Importing", "text": "\nThe name of the module that this loader will handle.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.SourceFileLoader.path", "path": "library/importlib#importlib.machinery.SourceFileLoader.path", "type": "Importing", "text": "\nThe path to the source file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.SourceFileLoader.path_stats()", "path": "library/importlib#importlib.machinery.SourceFileLoader.path_stats", "type": "Importing", "text": "\nConcrete implementation of `importlib.abc.SourceLoader.path_stats()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.SourceFileLoader.set_data()", "path": "library/importlib#importlib.machinery.SourceFileLoader.set_data", "type": "Importing", "text": "\nConcrete implementation of `importlib.abc.SourceLoader.set_data()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.SourcelessFileLoader", "path": "library/importlib#importlib.machinery.SourcelessFileLoader", "type": "Importing", "text": "\nA concrete implementation of `importlib.abc.FileLoader` which can import\nbytecode files (i.e. no source code files exist).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.SourcelessFileLoader.get_code()", "path": "library/importlib#importlib.machinery.SourcelessFileLoader.get_code", "type": "Importing", "text": "\nReturns the code object for `name` created from `path`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.SourcelessFileLoader.get_source()", "path": "library/importlib#importlib.machinery.SourcelessFileLoader.get_source", "type": "Importing", "text": "\nReturns `None` as bytecode files have no source when this loader is used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.SourcelessFileLoader.is_package()", "path": "library/importlib#importlib.machinery.SourcelessFileLoader.is_package", "type": "Importing", "text": "\nDetermines if the module is a package based on `path`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.SourcelessFileLoader.load_module()", "path": "library/importlib#importlib.machinery.SourcelessFileLoader.load_module", "type": "Importing", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.SourcelessFileLoader.name", "path": "library/importlib#importlib.machinery.SourcelessFileLoader.name", "type": "Importing", "text": "\nThe name of the module the loader will handle.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.SourcelessFileLoader.path", "path": "library/importlib#importlib.machinery.SourcelessFileLoader.path", "type": "Importing", "text": "\nThe path to the bytecode file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.SOURCE_SUFFIXES", "path": "library/importlib#importlib.machinery.SOURCE_SUFFIXES", "type": "Importing", "text": "\nA list of strings representing the recognized file suffixes for source\nmodules.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.machinery.WindowsRegistryFinder", "path": "library/importlib#importlib.machinery.WindowsRegistryFinder", "type": "Importing", "text": "\nFinder for modules declared in the Windows registry. This class implements the\n`importlib.abc.MetaPathFinder` ABC.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.reload()", "path": "library/importlib#importlib.reload", "type": "Importing", "text": "\nReload a previously imported module. The argument must be a module object, so\nit must have been successfully imported before. This is useful if you have\nedited the module source file using an external editor and want to try out the\nnew version without leaving the Python interpreter. The return value is the\nmodule object (which can be different if re-importing causes a different\nobject to be placed in `sys.modules`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.resources.as_file()", "path": "library/importlib#importlib.resources.as_file", "type": "Importing", "text": "\nGiven a `importlib.resources.abc.Traversable` object representing a file,\ntypically from `importlib.resources.files()`, return a context manager for use\nin a `with` statement. The context manager provides a `pathlib.Path` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.resources.contents()", "path": "library/importlib#importlib.resources.contents", "type": "Importing", "text": "\nReturn an iterable over the named items within the package. The iterable\nreturns `str` resources (e.g. files) and non-resources (e.g. directories). The\niterable does not recurse into subdirectories.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.resources.files()", "path": "library/importlib#importlib.resources.files", "type": "Importing", "text": "\nReturns an `importlib.resources.abc.Traversable` object representing the\nresource container for the package (think directory) and its resources (think\nfiles). A Traversable may contain other containers (think subdirectories).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.resources.is_resource()", "path": "library/importlib#importlib.resources.is_resource", "type": "Importing", "text": "\nReturn `True` if there is a resource named name in the package, otherwise\n`False`. Remember that directories are not resources! package is either a name\nor a module object which conforms to the `Package` requirements.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.resources.open_binary()", "path": "library/importlib#importlib.resources.open_binary", "type": "Importing", "text": "\nOpen for binary reading the resource within package.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.resources.open_text()", "path": "library/importlib#importlib.resources.open_text", "type": "Importing", "text": "\nOpen for text reading the resource within package. By default, the resource is\nopened for reading as UTF-8.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.resources.Package", "path": "library/importlib#importlib.resources.Package", "type": "Importing", "text": "\nThe `Package` type is defined as `Union[str, ModuleType]`. This means that\nwhere the function describes accepting a `Package`, you can pass in either a\nstring or a module. Module objects must have a resolvable\n`__spec__.submodule_search_locations` that is not `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.resources.path()", "path": "library/importlib#importlib.resources.path", "type": "Importing", "text": "\nReturn the path to the resource as an actual file system path. This function\nreturns a context manager for use in a `with` statement. The context manager\nprovides a `pathlib.Path` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.resources.read_binary()", "path": "library/importlib#importlib.resources.read_binary", "type": "Importing", "text": "\nRead and return the contents of the resource within package as `bytes`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.resources.read_text()", "path": "library/importlib#importlib.resources.read_text", "type": "Importing", "text": "\nRead and return the contents of resource within package as a `str`. By\ndefault, the contents are read as strict UTF-8.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.resources.Resource", "path": "library/importlib#importlib.resources.Resource", "type": "Importing", "text": "\nThis type describes the resource names passed into the various functions in\nthis package. This is defined as `Union[str, os.PathLike]`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.util.cache_from_source()", "path": "library/importlib#importlib.util.cache_from_source", "type": "Importing", "text": "\nReturn the PEP 3147/PEP 488 path to the byte-compiled file associated with the\nsource path. For example, if path is `/foo/bar/baz.py` the return value would\nbe `/foo/bar/__pycache__/baz.cpython-32.pyc` for Python 3.2. The `cpython-32`\nstring comes from the current magic tag (see `get_tag()`; if\n`sys.implementation.cache_tag` is not defined then `NotImplementedError` will\nbe raised).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.util.decode_source()", "path": "library/importlib#importlib.util.decode_source", "type": "Importing", "text": "\nDecode the given bytes representing source code and return it as a string with\nuniversal newlines (as required by\n`importlib.abc.InspectLoader.get_source()`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.util.find_spec()", "path": "library/importlib#importlib.util.find_spec", "type": "Importing", "text": "\nFind the spec for a module, optionally relative to the specified package name.\nIf the module is in `sys.modules`, then `sys.modules[name].__spec__` is\nreturned (unless the spec would be `None` or is not set, in which case\n`ValueError` is raised). Otherwise a search using `sys.meta_path` is done.\n`None` is returned if no spec is found.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.util.LazyLoader", "path": "library/importlib#importlib.util.LazyLoader", "type": "Importing", "text": "\nA class which postpones the execution of the loader of a module until the\nmodule has an attribute accessed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.util.LazyLoader.factory()", "path": "library/importlib#importlib.util.LazyLoader.factory", "type": "Importing", "text": "\nA static method which returns a callable that creates a lazy loader. This is\nmeant to be used in situations where the loader is passed by class instead of\nby instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.util.MAGIC_NUMBER", "path": "library/importlib#importlib.util.MAGIC_NUMBER", "type": "Importing", "text": "\nThe bytes which represent the bytecode version number. If you need help with\nloading/writing bytecode then consider `importlib.abc.SourceLoader`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.util.module_for_loader()", "path": "library/importlib#importlib.util.module_for_loader", "type": "Importing", "text": "\nA decorator for `importlib.abc.Loader.load_module()` to handle selecting the\nproper module object to load with. The decorated method is expected to have a\ncall signature taking two positional arguments (e.g. `load_module(self,\nmodule)`) for which the second argument will be the module object to be used\nby the loader. Note that the decorator will not work on static methods because\nof the assumption of two arguments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.util.module_from_spec()", "path": "library/importlib#importlib.util.module_from_spec", "type": "Importing", "text": "\nCreate a new module based on spec and `spec.loader.create_module`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.util.resolve_name()", "path": "library/importlib#importlib.util.resolve_name", "type": "Importing", "text": "\nResolve a relative module name to an absolute one.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.util.set_loader()", "path": "library/importlib#importlib.util.set_loader", "type": "Importing", "text": "\nA decorator for `importlib.abc.Loader.load_module()` to set the `__loader__`\nattribute on the returned module. If the attribute is already set the\ndecorator does nothing. It is assumed that the first positional argument to\nthe wrapped method (i.e. `self`) is what `__loader__` should be set to.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.util.set_package()", "path": "library/importlib#importlib.util.set_package", "type": "Importing", "text": "\nA decorator for `importlib.abc.Loader.load_module()` to set the `__package__`\nattribute on the returned module. If `__package__` is set and has a value\nother than `None` it will not be changed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.util.source_from_cache()", "path": "library/importlib#importlib.util.source_from_cache", "type": "Importing", "text": "\nGiven the path to a PEP 3147 file name, return the associated source code file\npath. For example, if path is `/foo/bar/__pycache__/baz.cpython-32.pyc` the\nreturned path would be `/foo/bar/baz.py`. path need not exist, however if it\ndoes not conform to PEP 3147 or PEP 488 format, a `ValueError` is raised. If\n`sys.implementation.cache_tag` is not defined, `NotImplementedError` is\nraised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.util.source_hash()", "path": "library/importlib#importlib.util.source_hash", "type": "Importing", "text": "\nReturn the hash of source_bytes as bytes. A hash-based `.pyc` file embeds the\n`source_hash()` of the corresponding source file\u2019s contents in its header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.util.spec_from_file_location()", "path": "library/importlib#importlib.util.spec_from_file_location", "type": "Importing", "text": "\nA factory function for creating a `ModuleSpec` instance based on the path to a\nfile. Missing information will be filled in on the spec by making use of\nloader APIs and by the implication that the module will be file-based.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.util.spec_from_loader()", "path": "library/importlib#importlib.util.spec_from_loader", "type": "Importing", "text": "\nA factory function for creating a `ModuleSpec` instance based on a loader. The\nparameters have the same meaning as they do for ModuleSpec. The function uses\navailable loader APIs, such as `InspectLoader.is_package()`, to fill in any\nmissing information on the spec.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "importlib.__import__()", "path": "library/importlib#importlib.__import__", "type": "Importing", "text": "\nAn implementation of the built-in `__import__()` function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ImportWarning", "path": "library/exceptions#ImportWarning", "type": "Built-in Exceptions", "text": "\nBase class for warnings about probable mistakes in module imports.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "IndentationError", "path": "library/exceptions#IndentationError", "type": "Built-in Exceptions", "text": "\nBase class for syntax errors related to incorrect indentation. This is a\nsubclass of `SyntaxError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "IndexError", "path": "library/exceptions#IndexError", "type": "Built-in Exceptions", "text": "\nRaised when a sequence subscript is out of range. (Slice indices are silently\ntruncated to fall in the allowed range; if an index is not an integer,\n`TypeError` is raised.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "input()", "path": "library/functions#input", "type": "Built-in Functions", "text": "\nIf the prompt argument is present, it is written to standard output without a\ntrailing newline. The function then reads a line from input, converts it to a\nstring (stripping a trailing newline), and returns that. When EOF is read,\n`EOFError` is raised. Example:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect", "path": "library/inspect", "type": "Runtime", "text": "\nSource code: Lib/inspect.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.BoundArguments", "path": "library/inspect#inspect.BoundArguments", "type": "Runtime", "text": "\nResult of a `Signature.bind()` or `Signature.bind_partial()` call. Holds the\nmapping of arguments to the function\u2019s parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.BoundArguments.apply_defaults()", "path": "library/inspect#inspect.BoundArguments.apply_defaults", "type": "Runtime", "text": "\nSet default values for missing arguments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.BoundArguments.args", "path": "library/inspect#inspect.BoundArguments.args", "type": "Runtime", "text": "\nA tuple of positional arguments values. Dynamically computed from the\n`arguments` attribute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.BoundArguments.arguments", "path": "library/inspect#inspect.BoundArguments.arguments", "type": "Runtime", "text": "\nA mutable mapping of parameters\u2019 names to arguments\u2019 values. Contains only\nexplicitly bound arguments. Changes in `arguments` will reflect in `args` and\n`kwargs`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.BoundArguments.kwargs", "path": "library/inspect#inspect.BoundArguments.kwargs", "type": "Runtime", "text": "\nA dict of keyword arguments values. Dynamically computed from the `arguments`\nattribute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.BoundArguments.signature", "path": "library/inspect#inspect.BoundArguments.signature", "type": "Runtime", "text": "\nA reference to the parent `Signature` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.cleandoc()", "path": "library/inspect#inspect.cleandoc", "type": "Runtime", "text": "\nClean up indentation from docstrings that are indented to line up with blocks\nof code.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.CO_ASYNC_GENERATOR", "path": "library/inspect#inspect.CO_ASYNC_GENERATOR", "type": "Runtime", "text": "\nThe flag is set when the code object is an asynchronous generator function.\nWhen the code object is executed it returns an asynchronous generator object.\nSee PEP 525 for more details.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.CO_COROUTINE", "path": "library/inspect#inspect.CO_COROUTINE", "type": "Runtime", "text": "\nThe flag is set when the code object is a coroutine function. When the code\nobject is executed it returns a coroutine object. See PEP 492 for more\ndetails.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.CO_GENERATOR", "path": "library/inspect#inspect.CO_GENERATOR", "type": "Runtime", "text": "\nThe flag is set when the code object is a generator function, i.e. a generator\nobject is returned when the code object is executed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.CO_ITERABLE_COROUTINE", "path": "library/inspect#inspect.CO_ITERABLE_COROUTINE", "type": "Runtime", "text": "\nThe flag is used to transform generators into generator-based coroutines.\nGenerator objects with this flag can be used in `await` expression, and can\n`yield from` coroutine objects. See PEP 492 for more details.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.CO_NESTED", "path": "library/inspect#inspect.CO_NESTED", "type": "Runtime", "text": "\nThe flag is set when the code object is a nested function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.CO_NEWLOCALS", "path": "library/inspect#inspect.CO_NEWLOCALS", "type": "Runtime", "text": "\nIf set, a new dict will be created for the frame\u2019s `f_locals` when the code\nobject is executed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.CO_NOFREE", "path": "library/inspect#inspect.CO_NOFREE", "type": "Runtime", "text": "\nThe flag is set if there are no free or cell variables.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.CO_OPTIMIZED", "path": "library/inspect#inspect.CO_OPTIMIZED", "type": "Runtime", "text": "\nThe code object is optimized, using fast locals.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.CO_VARARGS", "path": "library/inspect#inspect.CO_VARARGS", "type": "Runtime", "text": "\nThe code object has a variable positional parameter (`*args`-like).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.CO_VARKEYWORDS", "path": "library/inspect#inspect.CO_VARKEYWORDS", "type": "Runtime", "text": "\nThe code object has a variable keyword parameter (`**kwargs`-like).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.currentframe()", "path": "library/inspect#inspect.currentframe", "type": "Runtime", "text": "\nReturn the frame object for the caller\u2019s stack frame.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.formatargspec()", "path": "library/inspect#inspect.formatargspec", "type": "Runtime", "text": "\nFormat a pretty argument spec from the values returned by `getfullargspec()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.formatargvalues()", "path": "library/inspect#inspect.formatargvalues", "type": "Runtime", "text": "\nFormat a pretty argument spec from the four values returned by\n`getargvalues()`. The format* arguments are the corresponding optional\nformatting functions that are called to turn names and values into strings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getargspec()", "path": "library/inspect#inspect.getargspec", "type": "Runtime", "text": "\nGet the names and default values of a Python function\u2019s parameters. A named\ntuple `ArgSpec(args, varargs, keywords, defaults)` is returned. args is a list\nof the parameter names. varargs and keywords are the names of the `*` and `**`\nparameters or `None`. defaults is a tuple of default argument values or `None`\nif there are no default arguments; if this tuple has n elements, they\ncorrespond to the last n elements listed in args.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getargvalues()", "path": "library/inspect#inspect.getargvalues", "type": "Runtime", "text": "\nGet information about arguments passed into a particular frame. A named tuple\n`ArgInfo(args, varargs, keywords, locals)` is returned. args is a list of the\nargument names. varargs and keywords are the names of the `*` and `**`\narguments or `None`. locals is the locals dictionary of the given frame.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getattr_static()", "path": "library/inspect#inspect.getattr_static", "type": "Runtime", "text": "\nRetrieve attributes without triggering dynamic lookup via the descriptor\nprotocol, `__getattr__()` or `__getattribute__()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getcallargs()", "path": "library/inspect#inspect.getcallargs", "type": "Runtime", "text": "\nBind the args and kwds to the argument names of the Python function or method\nfunc, as if it was called with them. For bound methods, bind also the first\nargument (typically named `self`) to the associated instance. A dict is\nreturned, mapping the argument names (including the names of the `*` and `**`\narguments, if any) to their values from args and kwds. In case of invoking\nfunc incorrectly, i.e. whenever `func(*args, **kwds)` would raise an exception\nbecause of incompatible signature, an exception of the same type and the same\nor similar message is raised. For example:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getclasstree()", "path": "library/inspect#inspect.getclasstree", "type": "Runtime", "text": "\nArrange the given list of classes into a hierarchy of nested lists. Where a\nnested list appears, it contains classes derived from the class whose entry\nimmediately precedes the list. Each entry is a 2-tuple containing a class and\na tuple of its base classes. If the unique argument is true, exactly one entry\nappears in the returned structure for each class in the given list. Otherwise,\nclasses using multiple inheritance and their descendants will appear multiple\ntimes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getclosurevars()", "path": "library/inspect#inspect.getclosurevars", "type": "Runtime", "text": "\nGet the mapping of external name references in a Python function or method\nfunc to their current values. A named tuple `ClosureVars(nonlocals, globals,\nbuiltins, unbound)` is returned. nonlocals maps referenced names to lexical\nclosure variables, globals to the function\u2019s module globals and builtins to\nthe builtins visible from the function body. unbound is the set of names\nreferenced in the function that could not be resolved at all given the current\nmodule globals and builtins.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getcomments()", "path": "library/inspect#inspect.getcomments", "type": "Runtime", "text": "\nReturn in a single string any lines of comments immediately preceding the\nobject\u2019s source code (for a class, function, or method), or at the top of the\nPython source file (if the object is a module). If the object\u2019s source code is\nunavailable, return `None`. This could happen if the object has been defined\nin C or the interactive shell.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getcoroutinelocals()", "path": "library/inspect#inspect.getcoroutinelocals", "type": "Runtime", "text": "\nThis function is analogous to `getgeneratorlocals()`, but works for coroutine\nobjects created by `async def` functions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getcoroutinestate()", "path": "library/inspect#inspect.getcoroutinestate", "type": "Runtime", "text": "\nGet current state of a coroutine object. The function is intended to be used\nwith coroutine objects created by `async def` functions, but will accept any\ncoroutine-like object that has `cr_running` and `cr_frame` attributes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getdoc()", "path": "library/inspect#inspect.getdoc", "type": "Runtime", "text": "\nGet the documentation string for an object, cleaned up with `cleandoc()`. If\nthe documentation string for an object is not provided and the object is a\nclass, a method, a property or a descriptor, retrieve the documentation string\nfrom the inheritance hierarchy.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getfile()", "path": "library/inspect#inspect.getfile", "type": "Runtime", "text": "\nReturn the name of the (text or binary) file in which an object was defined.\nThis will fail with a `TypeError` if the object is a built-in module, class,\nor function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getframeinfo()", "path": "library/inspect#inspect.getframeinfo", "type": "Runtime", "text": "\nGet information about a frame or traceback object. A named tuple\n`Traceback(filename, lineno, function, code_context, index)` is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getfullargspec()", "path": "library/inspect#inspect.getfullargspec", "type": "Runtime", "text": "\nGet the names and default values of a Python function\u2019s parameters. A named\ntuple is returned:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getgeneratorlocals()", "path": "library/inspect#inspect.getgeneratorlocals", "type": "Runtime", "text": "\nGet the mapping of live local variables in generator to their current values.\nA dictionary is returned that maps from variable names to values. This is the\nequivalent of calling `locals()` in the body of the generator, and all the\nsame caveats apply.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getgeneratorstate()", "path": "library/inspect#inspect.getgeneratorstate", "type": "Runtime", "text": "\nGet current state of a generator-iterator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getinnerframes()", "path": "library/inspect#inspect.getinnerframes", "type": "Runtime", "text": "\nGet a list of frame records for a traceback\u2019s frame and all inner frames.\nThese frames represent calls made as a consequence of frame. The first entry\nin the list represents traceback; the last entry represents where the\nexception was raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getmembers()", "path": "library/inspect#inspect.getmembers", "type": "Runtime", "text": "\nReturn all the members of an object in a list of `(name, value)` pairs sorted\nby name. If the optional predicate argument\u2014which will be called with the\n`value` object of each member\u2014is supplied, only members for which the\npredicate returns a true value are included.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getmodule()", "path": "library/inspect#inspect.getmodule", "type": "Runtime", "text": "\nTry to guess which module an object was defined in.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getmodulename()", "path": "library/inspect#inspect.getmodulename", "type": "Runtime", "text": "\nReturn the name of the module named by the file path, without including the\nnames of enclosing packages. The file extension is checked against all of the\nentries in `importlib.machinery.all_suffixes()`. If it matches, the final path\ncomponent is returned with the extension removed. Otherwise, `None` is\nreturned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getmro()", "path": "library/inspect#inspect.getmro", "type": "Runtime", "text": "\nReturn a tuple of class cls\u2019s base classes, including cls, in method\nresolution order. No class appears more than once in this tuple. Note that the\nmethod resolution order depends on cls\u2019s type. Unless a very peculiar user-\ndefined metatype is in use, cls will be the first element of the tuple.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getouterframes()", "path": "library/inspect#inspect.getouterframes", "type": "Runtime", "text": "\nGet a list of frame records for a frame and all outer frames. These frames\nrepresent the calls that lead to the creation of frame. The first entry in the\nreturned list represents frame; the last entry represents the outermost call\non frame\u2019s stack.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getsource()", "path": "library/inspect#inspect.getsource", "type": "Runtime", "text": "\nReturn the text of the source code for an object. The argument may be a\nmodule, class, method, function, traceback, frame, or code object. The source\ncode is returned as a single string. An `OSError` is raised if the source code\ncannot be retrieved.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getsourcefile()", "path": "library/inspect#inspect.getsourcefile", "type": "Runtime", "text": "\nReturn the name of the Python source file in which an object was defined. This\nwill fail with a `TypeError` if the object is a built-in module, class, or\nfunction.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.getsourcelines()", "path": "library/inspect#inspect.getsourcelines", "type": "Runtime", "text": "\nReturn a list of source lines and starting line number for an object. The\nargument may be a module, class, method, function, traceback, frame, or code\nobject. The source code is returned as a list of the lines corresponding to\nthe object and the line number indicates where in the original source file the\nfirst line of code was found. An `OSError` is raised if the source code cannot\nbe retrieved.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.isabstract()", "path": "library/inspect#inspect.isabstract", "type": "Runtime", "text": "\nReturn `True` if the object is an abstract base class.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.isasyncgen()", "path": "library/inspect#inspect.isasyncgen", "type": "Runtime", "text": "\nReturn `True` if the object is an asynchronous generator iterator created by\nan asynchronous generator function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.isasyncgenfunction()", "path": "library/inspect#inspect.isasyncgenfunction", "type": "Runtime", "text": "\nReturn `True` if the object is an asynchronous generator function, for\nexample:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.isawaitable()", "path": "library/inspect#inspect.isawaitable", "type": "Runtime", "text": "\nReturn `True` if the object can be used in `await` expression.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.isbuiltin()", "path": "library/inspect#inspect.isbuiltin", "type": "Runtime", "text": "\nReturn `True` if the object is a built-in function or a bound built-in method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.isclass()", "path": "library/inspect#inspect.isclass", "type": "Runtime", "text": "\nReturn `True` if the object is a class, whether built-in or created in Python\ncode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.iscode()", "path": "library/inspect#inspect.iscode", "type": "Runtime", "text": "\nReturn `True` if the object is a code.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.iscoroutine()", "path": "library/inspect#inspect.iscoroutine", "type": "Runtime", "text": "\nReturn `True` if the object is a coroutine created by an `async def` function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.iscoroutinefunction()", "path": "library/inspect#inspect.iscoroutinefunction", "type": "Runtime", "text": "\nReturn `True` if the object is a coroutine function (a function defined with\nan `async def` syntax).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.isdatadescriptor()", "path": "library/inspect#inspect.isdatadescriptor", "type": "Runtime", "text": "\nReturn `True` if the object is a data descriptor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.isframe()", "path": "library/inspect#inspect.isframe", "type": "Runtime", "text": "\nReturn `True` if the object is a frame.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.isfunction()", "path": "library/inspect#inspect.isfunction", "type": "Runtime", "text": "\nReturn `True` if the object is a Python function, which includes functions\ncreated by a lambda expression.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.isgenerator()", "path": "library/inspect#inspect.isgenerator", "type": "Runtime", "text": "\nReturn `True` if the object is a generator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.isgeneratorfunction()", "path": "library/inspect#inspect.isgeneratorfunction", "type": "Runtime", "text": "\nReturn `True` if the object is a Python generator function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.isgetsetdescriptor()", "path": "library/inspect#inspect.isgetsetdescriptor", "type": "Runtime", "text": "\nReturn `True` if the object is a getset descriptor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.ismemberdescriptor()", "path": "library/inspect#inspect.ismemberdescriptor", "type": "Runtime", "text": "\nReturn `True` if the object is a member descriptor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.ismethod()", "path": "library/inspect#inspect.ismethod", "type": "Runtime", "text": "\nReturn `True` if the object is a bound method written in Python.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.ismethoddescriptor()", "path": "library/inspect#inspect.ismethoddescriptor", "type": "Runtime", "text": "\nReturn `True` if the object is a method descriptor, but not if `ismethod()`,\n`isclass()`, `isfunction()` or `isbuiltin()` are true.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.ismodule()", "path": "library/inspect#inspect.ismodule", "type": "Runtime", "text": "\nReturn `True` if the object is a module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.isroutine()", "path": "library/inspect#inspect.isroutine", "type": "Runtime", "text": "\nReturn `True` if the object is a user-defined or built-in function or method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.istraceback()", "path": "library/inspect#inspect.istraceback", "type": "Runtime", "text": "\nReturn `True` if the object is a traceback.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.Parameter", "path": "library/inspect#inspect.Parameter", "type": "Runtime", "text": "\nParameter objects are immutable. Instead of modifying a Parameter object, you\ncan use `Parameter.replace()` to create a modified copy.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.Parameter.annotation", "path": "library/inspect#inspect.Parameter.annotation", "type": "Runtime", "text": "\nThe annotation for the parameter. If the parameter has no annotation, this\nattribute is set to `Parameter.empty`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.Parameter.default", "path": "library/inspect#inspect.Parameter.default", "type": "Runtime", "text": "\nThe default value for the parameter. If the parameter has no default value,\nthis attribute is set to `Parameter.empty`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.Parameter.empty", "path": "library/inspect#inspect.Parameter.empty", "type": "Runtime", "text": "\nA special class-level marker to specify absence of default values and\nannotations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.Parameter.kind", "path": "library/inspect#inspect.Parameter.kind", "type": "Runtime", "text": "\nDescribes how argument values are bound to the parameter. Possible values\n(accessible via `Parameter`, like `Parameter.KEYWORD_ONLY`):\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.Parameter.kind.description", "path": "library/inspect#inspect.Parameter.kind.description", "type": "Runtime", "text": "\nDescribes a enum value of Parameter.kind.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.Parameter.name", "path": "library/inspect#inspect.Parameter.name", "type": "Runtime", "text": "\nThe name of the parameter as a string. The name must be a valid Python\nidentifier.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.Parameter.replace()", "path": "library/inspect#inspect.Parameter.replace", "type": "Runtime", "text": "\nCreate a new Parameter instance based on the instance replaced was invoked on.\nTo override a `Parameter` attribute, pass the corresponding argument. To\nremove a default value or/and an annotation from a Parameter, pass\n`Parameter.empty`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.Signature", "path": "library/inspect#inspect.Signature", "type": "Runtime", "text": "\nA Signature object represents the call signature of a function and its return\nannotation. For each parameter accepted by the function it stores a\n`Parameter` object in its `parameters` collection.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.signature()", "path": "library/inspect#inspect.signature", "type": "Runtime", "text": "\nReturn a `Signature` object for the given `callable`:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.Signature.bind()", "path": "library/inspect#inspect.Signature.bind", "type": "Runtime", "text": "\nCreate a mapping from positional and keyword arguments to parameters. Returns\n`BoundArguments` if `*args` and `**kwargs` match the signature, or raises a\n`TypeError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.Signature.bind_partial()", "path": "library/inspect#inspect.Signature.bind_partial", "type": "Runtime", "text": "\nWorks the same way as `Signature.bind()`, but allows the omission of some\nrequired arguments (mimics `functools.partial()` behavior.) Returns\n`BoundArguments`, or raises a `TypeError` if the passed arguments do not match\nthe signature.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.Signature.empty", "path": "library/inspect#inspect.Signature.empty", "type": "Runtime", "text": "\nA special class-level marker to specify absence of a return annotation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.Signature.from_callable()", "path": "library/inspect#inspect.Signature.from_callable", "type": "Runtime", "text": "\nReturn a `Signature` (or its subclass) object for a given callable `obj`. Pass\n`follow_wrapped=False` to get a signature of `obj` without unwrapping its\n`__wrapped__` chain.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.Signature.parameters", "path": "library/inspect#inspect.Signature.parameters", "type": "Runtime", "text": "\nAn ordered mapping of parameters\u2019 names to the corresponding `Parameter`\nobjects. Parameters appear in strict definition order, including keyword-only\nparameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.Signature.replace()", "path": "library/inspect#inspect.Signature.replace", "type": "Runtime", "text": "\nCreate a new Signature instance based on the instance replace was invoked on.\nIt is possible to pass different `parameters` and/or `return_annotation` to\noverride the corresponding properties of the base signature. To remove\nreturn_annotation from the copied Signature, pass in `Signature.empty`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.Signature.return_annotation", "path": "library/inspect#inspect.Signature.return_annotation", "type": "Runtime", "text": "\nThe \u201creturn\u201d annotation for the callable. If the callable has no \u201creturn\u201d\nannotation, this attribute is set to `Signature.empty`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.stack()", "path": "library/inspect#inspect.stack", "type": "Runtime", "text": "\nReturn a list of frame records for the caller\u2019s stack. The first entry in the\nreturned list represents the caller; the last entry represents the outermost\ncall on the stack.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.trace()", "path": "library/inspect#inspect.trace", "type": "Runtime", "text": "\nReturn a list of frame records for the stack between the current frame and the\nframe in which an exception currently being handled was raised in. The first\nentry in the list represents the caller; the last entry represents where the\nexception was raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "inspect.unwrap()", "path": "library/inspect#inspect.unwrap", "type": "Runtime", "text": "\nGet the object wrapped by func. It follows the chain of `__wrapped__`\nattributes returning the last object in the chain.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "instance.__class__", "path": "library/stdtypes#instance.__class__", "type": "Built-in Types", "text": "\nThe class to which a class instance belongs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "int", "path": "library/functions#int", "type": "Built-in Functions", "text": "\nReturn an integer object constructed from a number or string x, or return `0`\nif no arguments are given. If x defines `__int__()`, `int(x)` returns\n`x.__int__()`. If x defines `__index__()`, it returns `x.__index__()`. If x\ndefines `__trunc__()`, it returns `x.__trunc__()`. For floating point numbers,\nthis truncates towards zero.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "int.as_integer_ratio()", "path": "library/stdtypes#int.as_integer_ratio", "type": "Built-in Types", "text": "\nReturn a pair of integers whose ratio is exactly equal to the original integer\nand with a positive denominator. The integer ratio of integers (whole numbers)\nis always the integer as the numerator and `1` as the denominator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "int.bit_length()", "path": "library/stdtypes#int.bit_length", "type": "Built-in Types", "text": "\nReturn the number of bits necessary to represent an integer in binary,\nexcluding the sign and leading zeros:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "int.from_bytes()", "path": "library/stdtypes#int.from_bytes", "type": "Built-in Types", "text": "\nReturn the integer represented by the given array of bytes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "int.to_bytes()", "path": "library/stdtypes#int.to_bytes", "type": "Built-in Types", "text": "\nReturn an array of bytes representing an integer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "InterruptedError", "path": "library/exceptions#InterruptedError", "type": "Built-in Exceptions", "text": "\nRaised when a system call is interrupted by an incoming signal. Corresponds to\n`errno` `EINTR`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io", "path": "library/io", "type": "Operating System", "text": "\nSource code: Lib/io.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BlockingIOError", "path": "library/io#io.BlockingIOError", "type": "Operating System", "text": "\nThis is a compatibility alias for the builtin `BlockingIOError` exception.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BufferedIOBase", "path": "library/io#io.BufferedIOBase", "type": "Operating System", "text": "\nBase class for binary streams that support some kind of buffering. It inherits\n`IOBase`. There is no public constructor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BufferedIOBase.detach()", "path": "library/io#io.BufferedIOBase.detach", "type": "Operating System", "text": "\nSeparate the underlying raw stream from the buffer and return it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BufferedIOBase.raw", "path": "library/io#io.BufferedIOBase.raw", "type": "Operating System", "text": "\nThe underlying raw stream (a `RawIOBase` instance) that `BufferedIOBase` deals\nwith. This is not part of the `BufferedIOBase` API and may not exist on some\nimplementations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BufferedIOBase.read()", "path": "library/io#io.BufferedIOBase.read", "type": "Operating System", "text": "\nRead and return up to size bytes. If the argument is omitted, `None`, or\nnegative, data is read and returned until EOF is reached. An empty `bytes`\nobject is returned if the stream is already at EOF.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BufferedIOBase.read1()", "path": "library/io#io.BufferedIOBase.read1", "type": "Operating System", "text": "\nRead and return up to size bytes, with at most one call to the underlying raw\nstream\u2019s `read()` (or `readinto()`) method. This can be useful if you are\nimplementing your own buffering on top of a `BufferedIOBase` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BufferedIOBase.readinto()", "path": "library/io#io.BufferedIOBase.readinto", "type": "Operating System", "text": "\nRead bytes into a pre-allocated, writable bytes-like object b and return the\nnumber of bytes read. For example, b might be a `bytearray`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BufferedIOBase.readinto1()", "path": "library/io#io.BufferedIOBase.readinto1", "type": "Operating System", "text": "\nRead bytes into a pre-allocated, writable bytes-like object b, using at most\none call to the underlying raw stream\u2019s `read()` (or `readinto()`) method.\nReturn the number of bytes read.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BufferedIOBase.write()", "path": "library/io#io.BufferedIOBase.write", "type": "Operating System", "text": "\nWrite the given bytes-like object, b, and return the number of bytes written\n(always equal to the length of b in bytes, since if the write fails an\n`OSError` will be raised). Depending on the actual implementation, these bytes\nmay be readily written to the underlying stream, or held in a buffer for\nperformance and latency reasons.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BufferedRandom", "path": "library/io#io.BufferedRandom", "type": "Operating System", "text": "\nA buffered binary stream providing higher-level access to a seekable\n`RawIOBase` raw binary stream. It inherits `BufferedReader` and\n`BufferedWriter`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BufferedReader", "path": "library/io#io.BufferedReader", "type": "Operating System", "text": "\nA buffered binary stream providing higher-level access to a readable, non\nseekable `RawIOBase` raw binary stream. It inherits `BufferedIOBase`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BufferedReader.peek()", "path": "library/io#io.BufferedReader.peek", "type": "Operating System", "text": "\nReturn bytes from the stream without advancing the position. At most one\nsingle read on the raw stream is done to satisfy the call. The number of bytes\nreturned may be less or more than requested.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BufferedReader.read()", "path": "library/io#io.BufferedReader.read", "type": "Operating System", "text": "\nRead and return size bytes, or if size is not given or negative, until EOF or\nif the read call would block in non-blocking mode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BufferedReader.read1()", "path": "library/io#io.BufferedReader.read1", "type": "Operating System", "text": "\nRead and return up to size bytes with only one call on the raw stream. If at\nleast one byte is buffered, only buffered bytes are returned. Otherwise, one\nraw stream read call is made.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BufferedRWPair", "path": "library/io#io.BufferedRWPair", "type": "Operating System", "text": "\nA buffered binary stream providing higher-level access to two non seekable\n`RawIOBase` raw binary streams\u2014one readable, the other writeable. It inherits\n`BufferedIOBase`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BufferedWriter", "path": "library/io#io.BufferedWriter", "type": "Operating System", "text": "\nA buffered binary stream providing higher-level access to a writeable, non\nseekable `RawIOBase` raw binary stream. It inherits `BufferedIOBase`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BufferedWriter.flush()", "path": "library/io#io.BufferedWriter.flush", "type": "Operating System", "text": "\nForce bytes held in the buffer into the raw stream. A `BlockingIOError` should\nbe raised if the raw stream blocks.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BufferedWriter.write()", "path": "library/io#io.BufferedWriter.write", "type": "Operating System", "text": "\nWrite the bytes-like object, b, and return the number of bytes written. When\nin non-blocking mode, a `BlockingIOError` is raised if the buffer needs to be\nwritten out but the raw stream blocks.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BytesIO", "path": "library/io#io.BytesIO", "type": "Operating System", "text": "\nA binary stream using an in-memory bytes buffer. It inherits `BufferedIOBase`.\nThe buffer is discarded when the `close()` method is called.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BytesIO.getbuffer()", "path": "library/io#io.BytesIO.getbuffer", "type": "Operating System", "text": "\nReturn a readable and writable view over the contents of the buffer without\ncopying them. Also, mutating the view will transparently update the contents\nof the buffer:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BytesIO.getvalue()", "path": "library/io#io.BytesIO.getvalue", "type": "Operating System", "text": "\nReturn `bytes` containing the entire contents of the buffer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BytesIO.read1()", "path": "library/io#io.BytesIO.read1", "type": "Operating System", "text": "\nIn `BytesIO`, this is the same as `read()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.BytesIO.readinto1()", "path": "library/io#io.BytesIO.readinto1", "type": "Operating System", "text": "\nIn `BytesIO`, this is the same as `readinto()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.DEFAULT_BUFFER_SIZE", "path": "library/io#io.DEFAULT_BUFFER_SIZE", "type": "Operating System", "text": "\nAn int containing the default buffer size used by the module\u2019s buffered I/O\nclasses. `open()` uses the file\u2019s blksize (as obtained by `os.stat()`) if\npossible.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.FileIO", "path": "library/io#io.FileIO", "type": "Operating System", "text": "\nA raw binary stream representing an OS-level file containing bytes data. It\ninherits `RawIOBase`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.FileIO.mode", "path": "library/io#io.FileIO.mode", "type": "Operating System", "text": "\nThe mode as given in the constructor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.FileIO.name", "path": "library/io#io.FileIO.name", "type": "Operating System", "text": "\nThe file name. This is the file descriptor of the file when no name is given\nin the constructor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.IncrementalNewlineDecoder", "path": "library/io#io.IncrementalNewlineDecoder", "type": "Operating System", "text": "\nA helper codec that decodes newlines for universal newlines mode. It inherits\n`codecs.IncrementalDecoder`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.IOBase", "path": "library/io#io.IOBase", "type": "Operating System", "text": "\nThe abstract base class for all I/O classes, acting on streams of bytes. There\nis no public constructor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.IOBase.close()", "path": "library/io#io.IOBase.close", "type": "Operating System", "text": "\nFlush and close this stream. This method has no effect if the file is already\nclosed. Once the file is closed, any operation on the file (e.g. reading or\nwriting) will raise a `ValueError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.IOBase.closed", "path": "library/io#io.IOBase.closed", "type": "Operating System", "text": "\n`True` if the stream is closed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.IOBase.fileno()", "path": "library/io#io.IOBase.fileno", "type": "Operating System", "text": "\nReturn the underlying file descriptor (an integer) of the stream if it exists.\nAn `OSError` is raised if the IO object does not use a file descriptor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.IOBase.flush()", "path": "library/io#io.IOBase.flush", "type": "Operating System", "text": "\nFlush the write buffers of the stream if applicable. This does nothing for\nread-only and non-blocking streams.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.IOBase.isatty()", "path": "library/io#io.IOBase.isatty", "type": "Operating System", "text": "\nReturn `True` if the stream is interactive (i.e., connected to a terminal/tty\ndevice).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.IOBase.readable()", "path": "library/io#io.IOBase.readable", "type": "Operating System", "text": "\nReturn `True` if the stream can be read from. If `False`, `read()` will raise\n`OSError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.IOBase.readline()", "path": "library/io#io.IOBase.readline", "type": "Operating System", "text": "\nRead and return one line from the stream. If size is specified, at most size\nbytes will be read.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.IOBase.readlines()", "path": "library/io#io.IOBase.readlines", "type": "Operating System", "text": "\nRead and return a list of lines from the stream. hint can be specified to\ncontrol the number of lines read: no more lines will be read if the total size\n(in bytes/characters) of all lines so far exceeds hint.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.IOBase.seek()", "path": "library/io#io.IOBase.seek", "type": "Operating System", "text": "\nChange the stream position to the given byte offset. offset is interpreted\nrelative to the position indicated by whence. The default value for whence is\n`SEEK_SET`. Values for whence are:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.IOBase.seekable()", "path": "library/io#io.IOBase.seekable", "type": "Operating System", "text": "\nReturn `True` if the stream supports random access. If `False`, `seek()`,\n`tell()` and `truncate()` will raise `OSError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.IOBase.tell()", "path": "library/io#io.IOBase.tell", "type": "Operating System", "text": "\nReturn the current stream position.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.IOBase.truncate()", "path": "library/io#io.IOBase.truncate", "type": "Operating System", "text": "\nResize the stream to the given size in bytes (or the current position if size\nis not specified). The current stream position isn\u2019t changed. This resizing\ncan extend or reduce the current file size. In case of extension, the contents\nof the new file area depend on the platform (on most systems, additional bytes\nare zero-filled). The new file size is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.IOBase.writable()", "path": "library/io#io.IOBase.writable", "type": "Operating System", "text": "\nReturn `True` if the stream supports writing. If `False`, `write()` and\n`truncate()` will raise `OSError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.IOBase.writelines()", "path": "library/io#io.IOBase.writelines", "type": "Operating System", "text": "\nWrite a list of lines to the stream. Line separators are not added, so it is\nusual for each of the lines provided to have a line separator at the end.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.IOBase.__del__()", "path": "library/io#io.IOBase.__del__", "type": "Operating System", "text": "\nPrepare for object destruction. `IOBase` provides a default implementation of\nthis method that calls the instance\u2019s `close()` method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.open()", "path": "library/io#io.open", "type": "Operating System", "text": "\nThis is an alias for the builtin `open()` function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.open_code()", "path": "library/io#io.open_code", "type": "Operating System", "text": "\nOpens the provided file with mode `'rb'`. This function should be used when\nthe intent is to treat the contents as executable code.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.RawIOBase", "path": "library/io#io.RawIOBase", "type": "Operating System", "text": "\nBase class for raw binary streams. It inherits `IOBase`. There is no public\nconstructor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.RawIOBase.read()", "path": "library/io#io.RawIOBase.read", "type": "Operating System", "text": "\nRead up to size bytes from the object and return them. As a convenience, if\nsize is unspecified or -1, all bytes until EOF are returned. Otherwise, only\none system call is ever made. Fewer than size bytes may be returned if the\noperating system call returns fewer than size bytes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.RawIOBase.readall()", "path": "library/io#io.RawIOBase.readall", "type": "Operating System", "text": "\nRead and return all the bytes from the stream until EOF, using multiple calls\nto the stream if necessary.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.RawIOBase.readinto()", "path": "library/io#io.RawIOBase.readinto", "type": "Operating System", "text": "\nRead bytes into a pre-allocated, writable bytes-like object b, and return the\nnumber of bytes read. For example, b might be a `bytearray`. If the object is\nin non-blocking mode and no bytes are available, `None` is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.RawIOBase.write()", "path": "library/io#io.RawIOBase.write", "type": "Operating System", "text": "\nWrite the given bytes-like object, b, to the underlying raw stream, and return\nthe number of bytes written. This can be less than the length of b in bytes,\ndepending on specifics of the underlying raw stream, and especially if it is\nin non-blocking mode. `None` is returned if the raw stream is set not to block\nand no single byte could be readily written to it. The caller may release or\nmutate b after this method returns, so the implementation should only access b\nduring the method call.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.StringIO", "path": "library/io#io.StringIO", "type": "Operating System", "text": "\nA text stream using an in-memory text buffer. It inherits `TextIOBase`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.StringIO.getvalue()", "path": "library/io#io.StringIO.getvalue", "type": "Operating System", "text": "\nReturn a `str` containing the entire contents of the buffer. Newlines are\ndecoded as if by `read()`, although the stream position is not changed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.TextIOBase", "path": "library/io#io.TextIOBase", "type": "Operating System", "text": "\nBase class for text streams. This class provides a character and line based\ninterface to stream I/O. It inherits `IOBase`. There is no public constructor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.TextIOBase.buffer", "path": "library/io#io.TextIOBase.buffer", "type": "Operating System", "text": "\nThe underlying binary buffer (a `BufferedIOBase` instance) that `TextIOBase`\ndeals with. This is not part of the `TextIOBase` API and may not exist in some\nimplementations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.TextIOBase.detach()", "path": "library/io#io.TextIOBase.detach", "type": "Operating System", "text": "\nSeparate the underlying binary buffer from the `TextIOBase` and return it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.TextIOBase.encoding", "path": "library/io#io.TextIOBase.encoding", "type": "Operating System", "text": "\nThe name of the encoding used to decode the stream\u2019s bytes into strings, and\nto encode strings into bytes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.TextIOBase.errors", "path": "library/io#io.TextIOBase.errors", "type": "Operating System", "text": "\nThe error setting of the decoder or encoder.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.TextIOBase.newlines", "path": "library/io#io.TextIOBase.newlines", "type": "Operating System", "text": "\nA string, a tuple of strings, or `None`, indicating the newlines translated so\nfar. Depending on the implementation and the initial constructor flags, this\nmay not be available.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.TextIOBase.read()", "path": "library/io#io.TextIOBase.read", "type": "Operating System", "text": "\nRead and return at most size characters from the stream as a single `str`. If\nsize is negative or `None`, reads until EOF.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.TextIOBase.readline()", "path": "library/io#io.TextIOBase.readline", "type": "Operating System", "text": "\nRead until newline or EOF and return a single `str`. If the stream is already\nat EOF, an empty string is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.TextIOBase.seek()", "path": "library/io#io.TextIOBase.seek", "type": "Operating System", "text": "\nChange the stream position to the given offset. Behaviour depends on the\nwhence parameter. The default value for whence is `SEEK_SET`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.TextIOBase.tell()", "path": "library/io#io.TextIOBase.tell", "type": "Operating System", "text": "\nReturn the current stream position as an opaque number. The number does not\nusually represent a number of bytes in the underlying binary storage.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.TextIOBase.write()", "path": "library/io#io.TextIOBase.write", "type": "Operating System", "text": "\nWrite the string s to the stream and return the number of characters written.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.TextIOWrapper", "path": "library/io#io.TextIOWrapper", "type": "Operating System", "text": "\nA buffered text stream providing higher-level access to a `BufferedIOBase`\nbuffered binary stream. It inherits `TextIOBase`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.TextIOWrapper.line_buffering", "path": "library/io#io.TextIOWrapper.line_buffering", "type": "Operating System", "text": "\nWhether line buffering is enabled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.TextIOWrapper.reconfigure()", "path": "library/io#io.TextIOWrapper.reconfigure", "type": "Operating System", "text": "\nReconfigure this text stream using new settings for encoding, errors, newline,\nline_buffering and write_through.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.TextIOWrapper.write_through", "path": "library/io#io.TextIOWrapper.write_through", "type": "Operating System", "text": "\nWhether writes are passed immediately to the underlying binary buffer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "io.UnsupportedOperation", "path": "library/io#io.UnsupportedOperation", "type": "Operating System", "text": "\nAn exception inheriting `OSError` and `ValueError` that is raised when an\nunsupported operation is called on a stream.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "IOError", "path": "library/exceptions#IOError", "type": "Built-in Exceptions", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress", "path": "library/ipaddress", "type": "Internet", "text": "\nSource code: Lib/ipaddress.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.AddressValueError", "path": "library/ipaddress#ipaddress.AddressValueError", "type": "Internet", "text": "\nAny value error related to the address.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.collapse_addresses()", "path": "library/ipaddress#ipaddress.collapse_addresses", "type": "Internet", "text": "\nReturn an iterator of the collapsed `IPv4Network` or `IPv6Network` objects.\naddresses is an iterator of `IPv4Network` or `IPv6Network` objects. A\n`TypeError` is raised if addresses contains mixed version objects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.get_mixed_type_key()", "path": "library/ipaddress#ipaddress.get_mixed_type_key", "type": "Internet", "text": "\nReturn a key suitable for sorting between networks and addresses. Address and\nNetwork objects are not sortable by default; they\u2019re fundamentally different,\nso the expression:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Address", "path": "library/ipaddress#ipaddress.IPv4Address", "type": "Internet", "text": "\nConstruct an IPv4 address. An `AddressValueError` is raised if address is not\na valid IPv4 address.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Address.compressed", "path": "library/ipaddress#ipaddress.IPv4Address.compressed", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Address.exploded", "path": "library/ipaddress#ipaddress.IPv4Address.exploded", "type": "Internet", "text": "\nThe string representation in dotted decimal notation. Leading zeroes are never\nincluded in the representation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Address.is_global", "path": "library/ipaddress#ipaddress.IPv4Address.is_global", "type": "Internet", "text": "\n`True` if the address is allocated for public networks. See iana-ipv4-special-\nregistry (for IPv4) or iana-ipv6-special-registry (for IPv6).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Address.is_link_local", "path": "library/ipaddress#ipaddress.IPv4Address.is_link_local", "type": "Internet", "text": "\n`True` if the address is reserved for link-local usage. See RFC 3927.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Address.is_loopback", "path": "library/ipaddress#ipaddress.IPv4Address.is_loopback", "type": "Internet", "text": "\n`True` if this is a loopback address. See RFC 3330 (for IPv4) or RFC 2373 (for\nIPv6).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Address.is_multicast", "path": "library/ipaddress#ipaddress.IPv4Address.is_multicast", "type": "Internet", "text": "\n`True` if the address is reserved for multicast use. See RFC 3171 (for IPv4)\nor RFC 2373 (for IPv6).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Address.is_private", "path": "library/ipaddress#ipaddress.IPv4Address.is_private", "type": "Internet", "text": "\n`True` if the address is allocated for private networks. See iana-\nipv4-special-registry (for IPv4) or iana-ipv6-special-registry (for IPv6).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Address.is_reserved", "path": "library/ipaddress#ipaddress.IPv4Address.is_reserved", "type": "Internet", "text": "\n`True` if the address is otherwise IETF reserved.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Address.is_unspecified", "path": "library/ipaddress#ipaddress.IPv4Address.is_unspecified", "type": "Internet", "text": "\n`True` if the address is unspecified. See RFC 5735 (for IPv4) or RFC 2373 (for\nIPv6).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Address.max_prefixlen", "path": "library/ipaddress#ipaddress.IPv4Address.max_prefixlen", "type": "Internet", "text": "\nThe total number of bits in the address representation for this version: `32`\nfor IPv4, `128` for IPv6.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Address.packed", "path": "library/ipaddress#ipaddress.IPv4Address.packed", "type": "Internet", "text": "\nThe binary representation of this address - a `bytes` object of the\nappropriate length (most significant octet first). This is 4 bytes for IPv4\nand 16 bytes for IPv6.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Address.reverse_pointer", "path": "library/ipaddress#ipaddress.IPv4Address.reverse_pointer", "type": "Internet", "text": "\nThe name of the reverse DNS PTR record for the IP address, e.g.:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Address.version", "path": "library/ipaddress#ipaddress.IPv4Address.version", "type": "Internet", "text": "\nThe appropriate version number: `4` for IPv4, `6` for IPv6.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Address.__format__()", "path": "library/ipaddress#ipaddress.IPv4Address.__format__", "type": "Internet", "text": "\nReturns a string representation of the IP address, controlled by an explicit\nformat string. fmt can be one of the following: `'s'`, the default option,\nequivalent to `str()`, `'b'` for a zero-padded binary string, `'X'` or `'x'`\nfor an uppercase or lowercase hexadecimal representation, or `'n'`, which is\nequivalent to `'b'` for IPv4 addresses and `'x'` for IPv6. For binary and\nhexadecimal representations, the form specifier `'#'` and the grouping option\n`'_'` are available. `__format__` is used by `format`, `str.format` and\nf-strings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Interface", "path": "library/ipaddress#ipaddress.IPv4Interface", "type": "Internet", "text": "\nConstruct an IPv4 interface. The meaning of address is as in the constructor\nof `IPv4Network`, except that arbitrary host addresses are always accepted.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Interface.ip", "path": "library/ipaddress#ipaddress.IPv4Interface.ip", "type": "Internet", "text": "\nThe address (`IPv4Address`) without network information.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Interface.network", "path": "library/ipaddress#ipaddress.IPv4Interface.network", "type": "Internet", "text": "\nThe network (`IPv4Network`) this interface belongs to.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Interface.with_hostmask", "path": "library/ipaddress#ipaddress.IPv4Interface.with_hostmask", "type": "Internet", "text": "\nA string representation of the interface with the network as a host mask.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Interface.with_netmask", "path": "library/ipaddress#ipaddress.IPv4Interface.with_netmask", "type": "Internet", "text": "\nA string representation of the interface with the network as a net mask.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Interface.with_prefixlen", "path": "library/ipaddress#ipaddress.IPv4Interface.with_prefixlen", "type": "Internet", "text": "\nA string representation of the interface with the mask in prefix notation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Network", "path": "library/ipaddress#ipaddress.IPv4Network", "type": "Internet", "text": "\nConstruct an IPv4 network definition. address can be one of the following:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Network.address_exclude()", "path": "library/ipaddress#ipaddress.IPv4Network.address_exclude", "type": "Internet", "text": "\nComputes the network definitions resulting from removing the given network\nfrom this one. Returns an iterator of network objects. Raises `ValueError` if\nnetwork is not completely contained in this network.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Network.broadcast_address", "path": "library/ipaddress#ipaddress.IPv4Network.broadcast_address", "type": "Internet", "text": "\nThe broadcast address for the network. Packets sent to the broadcast address\nshould be received by every host on the network.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Network.compare_networks()", "path": "library/ipaddress#ipaddress.IPv4Network.compare_networks", "type": "Internet", "text": "\nCompare this network to other. In this comparison only the network addresses\nare considered; host bits aren\u2019t. Returns either `-1`, `0` or `1`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Network.compressed", "path": "library/ipaddress#ipaddress.IPv4Network.compressed", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Network.exploded", "path": "library/ipaddress#ipaddress.IPv4Network.exploded", "type": "Internet", "text": "\nA string representation of the network, with the mask in prefix notation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Network.hostmask", "path": "library/ipaddress#ipaddress.IPv4Network.hostmask", "type": "Internet", "text": "\nThe host mask, as an `IPv4Address` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Network.hosts()", "path": "library/ipaddress#ipaddress.IPv4Network.hosts", "type": "Internet", "text": "\nReturns an iterator over the usable hosts in the network. The usable hosts are\nall the IP addresses that belong to the network, except the network address\nitself and the network broadcast address. For networks with a mask length of\n31, the network address and network broadcast address are also included in the\nresult. Networks with a mask of 32 will return a list containing the single\nhost address.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Network.is_link_local", "path": "library/ipaddress#ipaddress.IPv4Network.is_link_local", "type": "Internet", "text": "\nThese attributes are true for the network as a whole if they are true for both\nthe network address and the broadcast address.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Network.is_loopback", "path": "library/ipaddress#ipaddress.IPv4Network.is_loopback", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Network.is_multicast", "path": "library/ipaddress#ipaddress.IPv4Network.is_multicast", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Network.is_private", "path": "library/ipaddress#ipaddress.IPv4Network.is_private", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Network.is_reserved", "path": "library/ipaddress#ipaddress.IPv4Network.is_reserved", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Network.is_unspecified", "path": "library/ipaddress#ipaddress.IPv4Network.is_unspecified", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Network.max_prefixlen", "path": "library/ipaddress#ipaddress.IPv4Network.max_prefixlen", "type": "Internet", "text": "\nRefer to the corresponding attribute documentation in `IPv4Address`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Network.netmask", "path": "library/ipaddress#ipaddress.IPv4Network.netmask", "type": "Internet", "text": "\nThe net mask, as an `IPv4Address` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Network.network_address", "path": "library/ipaddress#ipaddress.IPv4Network.network_address", "type": "Internet", "text": "\nThe network address for the network. The network address and the prefix length\ntogether uniquely define a network.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Network.num_addresses", "path": "library/ipaddress#ipaddress.IPv4Network.num_addresses", "type": "Internet", "text": "\nThe total number of addresses in the network.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Network.overlaps()", "path": "library/ipaddress#ipaddress.IPv4Network.overlaps", "type": "Internet", "text": "\n`True` if this network is partly or wholly contained in other or other is\nwholly contained in this network.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Network.prefixlen", "path": "library/ipaddress#ipaddress.IPv4Network.prefixlen", "type": "Internet", "text": "\nLength of the network prefix, in bits.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Network.subnets()", "path": "library/ipaddress#ipaddress.IPv4Network.subnets", "type": "Internet", "text": "\nThe subnets that join to make the current network definition, depending on the\nargument values. prefixlen_diff is the amount our prefix length should be\nincreased by. new_prefix is the desired new prefix of the subnets; it must be\nlarger than our prefix. One and only one of prefixlen_diff and new_prefix must\nbe set. Returns an iterator of network objects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Network.subnet_of()", "path": "library/ipaddress#ipaddress.IPv4Network.subnet_of", "type": "Internet", "text": "\nReturn `True` if this network is a subnet of other.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Network.supernet()", "path": "library/ipaddress#ipaddress.IPv4Network.supernet", "type": "Internet", "text": "\nThe supernet containing this network definition, depending on the argument\nvalues. prefixlen_diff is the amount our prefix length should be decreased by.\nnew_prefix is the desired new prefix of the supernet; it must be smaller than\nour prefix. One and only one of prefixlen_diff and new_prefix must be set.\nReturns a single network object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Network.supernet_of()", "path": "library/ipaddress#ipaddress.IPv4Network.supernet_of", "type": "Internet", "text": "\nReturn `True` if this network is a supernet of other.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Network.version", "path": "library/ipaddress#ipaddress.IPv4Network.version", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Network.with_hostmask", "path": "library/ipaddress#ipaddress.IPv4Network.with_hostmask", "type": "Internet", "text": "\nA string representation of the network, with the mask in host mask notation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Network.with_netmask", "path": "library/ipaddress#ipaddress.IPv4Network.with_netmask", "type": "Internet", "text": "\nA string representation of the network, with the mask in net mask notation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv4Network.with_prefixlen", "path": "library/ipaddress#ipaddress.IPv4Network.with_prefixlen", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Address", "path": "library/ipaddress#ipaddress.IPv6Address", "type": "Internet", "text": "\nConstruct an IPv6 address. An `AddressValueError` is raised if address is not\na valid IPv6 address.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Address.compressed", "path": "library/ipaddress#ipaddress.IPv6Address.compressed", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Address.exploded", "path": "library/ipaddress#ipaddress.IPv6Address.exploded", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Address.ipv4_mapped", "path": "library/ipaddress#ipaddress.IPv6Address.ipv4_mapped", "type": "Internet", "text": "\nFor addresses that appear to be IPv4 mapped addresses (starting with\n`::FFFF/96`), this property will report the embedded IPv4 address. For any\nother address, this property will be `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Address.is_global", "path": "library/ipaddress#ipaddress.IPv6Address.is_global", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Address.is_link_local", "path": "library/ipaddress#ipaddress.IPv6Address.is_link_local", "type": "Internet", "text": "\nNew in version 3.4: is_global\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Address.is_loopback", "path": "library/ipaddress#ipaddress.IPv6Address.is_loopback", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Address.is_multicast", "path": "library/ipaddress#ipaddress.IPv6Address.is_multicast", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Address.is_private", "path": "library/ipaddress#ipaddress.IPv6Address.is_private", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Address.is_reserved", "path": "library/ipaddress#ipaddress.IPv6Address.is_reserved", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Address.is_site_local", "path": "library/ipaddress#ipaddress.IPv6Address.is_site_local", "type": "Internet", "text": "\n`True` if the address is reserved for site-local usage. Note that the site-\nlocal address space has been deprecated by RFC 3879. Use `is_private` to test\nif this address is in the space of unique local addresses as defined by RFC\n4193.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Address.is_unspecified", "path": "library/ipaddress#ipaddress.IPv6Address.is_unspecified", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Address.max_prefixlen", "path": "library/ipaddress#ipaddress.IPv6Address.max_prefixlen", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Address.packed", "path": "library/ipaddress#ipaddress.IPv6Address.packed", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Address.reverse_pointer", "path": "library/ipaddress#ipaddress.IPv6Address.reverse_pointer", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Address.scope_id", "path": "library/ipaddress#ipaddress.IPv6Address.scope_id", "type": "Internet", "text": "\nFor scoped addresses as defined by RFC 4007, this property identifies the\nparticular zone of the address\u2019s scope that the address belongs to, as a\nstring. When no scope zone is specified, this property will be `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Address.sixtofour", "path": "library/ipaddress#ipaddress.IPv6Address.sixtofour", "type": "Internet", "text": "\nFor addresses that appear to be 6to4 addresses (starting with `2002::/16`) as\ndefined by RFC 3056, this property will report the embedded IPv4 address. For\nany other address, this property will be `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Address.teredo", "path": "library/ipaddress#ipaddress.IPv6Address.teredo", "type": "Internet", "text": "\nFor addresses that appear to be Teredo addresses (starting with `2001::/32`)\nas defined by RFC 4380, this property will report the embedded `(server,\nclient)` IP address pair. For any other address, this property will be `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Address.version", "path": "library/ipaddress#ipaddress.IPv6Address.version", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Address.__format__()", "path": "library/ipaddress#ipaddress.IPv6Address.__format__", "type": "Internet", "text": "\nRefer to the corresponding method documentation in `IPv4Address`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Interface", "path": "library/ipaddress#ipaddress.IPv6Interface", "type": "Internet", "text": "\nConstruct an IPv6 interface. The meaning of address is as in the constructor\nof `IPv6Network`, except that arbitrary host addresses are always accepted.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Interface.ip", "path": "library/ipaddress#ipaddress.IPv6Interface.ip", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Interface.network", "path": "library/ipaddress#ipaddress.IPv6Interface.network", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Interface.with_hostmask", "path": "library/ipaddress#ipaddress.IPv6Interface.with_hostmask", "type": "Internet", "text": "\nRefer to the corresponding attribute documentation in `IPv4Interface`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Interface.with_netmask", "path": "library/ipaddress#ipaddress.IPv6Interface.with_netmask", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Interface.with_prefixlen", "path": "library/ipaddress#ipaddress.IPv6Interface.with_prefixlen", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Network", "path": "library/ipaddress#ipaddress.IPv6Network", "type": "Internet", "text": "\nConstruct an IPv6 network definition. address can be one of the following:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Network.address_exclude()", "path": "library/ipaddress#ipaddress.IPv6Network.address_exclude", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Network.broadcast_address", "path": "library/ipaddress#ipaddress.IPv6Network.broadcast_address", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Network.compare_networks()", "path": "library/ipaddress#ipaddress.IPv6Network.compare_networks", "type": "Internet", "text": "\nRefer to the corresponding attribute documentation in `IPv4Network`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Network.compressed", "path": "library/ipaddress#ipaddress.IPv6Network.compressed", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Network.exploded", "path": "library/ipaddress#ipaddress.IPv6Network.exploded", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Network.hostmask", "path": "library/ipaddress#ipaddress.IPv6Network.hostmask", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Network.hosts()", "path": "library/ipaddress#ipaddress.IPv6Network.hosts", "type": "Internet", "text": "\nReturns an iterator over the usable hosts in the network. The usable hosts are\nall the IP addresses that belong to the network, except the Subnet-Router\nanycast address. For networks with a mask length of 127, the Subnet-Router\nanycast address is also included in the result. Networks with a mask of 128\nwill return a list containing the single host address.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Network.is_link_local", "path": "library/ipaddress#ipaddress.IPv6Network.is_link_local", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Network.is_loopback", "path": "library/ipaddress#ipaddress.IPv6Network.is_loopback", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Network.is_multicast", "path": "library/ipaddress#ipaddress.IPv6Network.is_multicast", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Network.is_private", "path": "library/ipaddress#ipaddress.IPv6Network.is_private", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Network.is_reserved", "path": "library/ipaddress#ipaddress.IPv6Network.is_reserved", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Network.is_site_local", "path": "library/ipaddress#ipaddress.IPv6Network.is_site_local", "type": "Internet", "text": "\nThese attribute is true for the network as a whole if it is true for both the\nnetwork address and the broadcast address.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Network.is_unspecified", "path": "library/ipaddress#ipaddress.IPv6Network.is_unspecified", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Network.max_prefixlen", "path": "library/ipaddress#ipaddress.IPv6Network.max_prefixlen", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Network.netmask", "path": "library/ipaddress#ipaddress.IPv6Network.netmask", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Network.network_address", "path": "library/ipaddress#ipaddress.IPv6Network.network_address", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Network.num_addresses", "path": "library/ipaddress#ipaddress.IPv6Network.num_addresses", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Network.overlaps()", "path": "library/ipaddress#ipaddress.IPv6Network.overlaps", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Network.prefixlen", "path": "library/ipaddress#ipaddress.IPv6Network.prefixlen", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Network.subnets()", "path": "library/ipaddress#ipaddress.IPv6Network.subnets", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Network.subnet_of()", "path": "library/ipaddress#ipaddress.IPv6Network.subnet_of", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Network.supernet()", "path": "library/ipaddress#ipaddress.IPv6Network.supernet", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Network.supernet_of()", "path": "library/ipaddress#ipaddress.IPv6Network.supernet_of", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Network.version", "path": "library/ipaddress#ipaddress.IPv6Network.version", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Network.with_hostmask", "path": "library/ipaddress#ipaddress.IPv6Network.with_hostmask", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Network.with_netmask", "path": "library/ipaddress#ipaddress.IPv6Network.with_netmask", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.IPv6Network.with_prefixlen", "path": "library/ipaddress#ipaddress.IPv6Network.with_prefixlen", "type": "Internet", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.ip_address()", "path": "library/ipaddress#ipaddress.ip_address", "type": "Internet", "text": "\nReturn an `IPv4Address` or `IPv6Address` object depending on the IP address\npassed as argument. Either IPv4 or IPv6 addresses may be supplied; integers\nless than 2**32 will be considered to be IPv4 by default. A `ValueError` is\nraised if address does not represent a valid IPv4 or IPv6 address.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.ip_interface()", "path": "library/ipaddress#ipaddress.ip_interface", "type": "Internet", "text": "\nReturn an `IPv4Interface` or `IPv6Interface` object depending on the IP\naddress passed as argument. address is a string or integer representing the IP\naddress. Either IPv4 or IPv6 addresses may be supplied; integers less than\n2**32 will be considered to be IPv4 by default. A `ValueError` is raised if\naddress does not represent a valid IPv4 or IPv6 address.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.ip_network()", "path": "library/ipaddress#ipaddress.ip_network", "type": "Internet", "text": "\nReturn an `IPv4Network` or `IPv6Network` object depending on the IP address\npassed as argument. address is a string or integer representing the IP\nnetwork. Either IPv4 or IPv6 networks may be supplied; integers less than\n2**32 will be considered to be IPv4 by default. strict is passed to\n`IPv4Network` or `IPv6Network` constructor. A `ValueError` is raised if\naddress does not represent a valid IPv4 or IPv6 address, or if the network has\nhost bits set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.NetmaskValueError", "path": "library/ipaddress#ipaddress.NetmaskValueError", "type": "Internet", "text": "\nAny value error related to the net mask.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.summarize_address_range()", "path": "library/ipaddress#ipaddress.summarize_address_range", "type": "Internet", "text": "\nReturn an iterator of the summarized network range given the first and last IP\naddresses. first is the first `IPv4Address` or `IPv6Address` in the range and\nlast is the last `IPv4Address` or `IPv6Address` in the range. A `TypeError` is\nraised if first or last are not IP addresses or are not of the same version. A\n`ValueError` is raised if last is not greater than first or if first address\nversion is not 4 or 6.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.v4_int_to_packed()", "path": "library/ipaddress#ipaddress.v4_int_to_packed", "type": "Internet", "text": "\nRepresent an address as 4 packed bytes in network (big-endian) order. address\nis an integer representation of an IPv4 IP address. A `ValueError` is raised\nif the integer is negative or too large to be an IPv4 IP address.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ipaddress.v6_int_to_packed()", "path": "library/ipaddress#ipaddress.v6_int_to_packed", "type": "Internet", "text": "\nRepresent an address as 16 packed bytes in network (big-endian) order. address\nis an integer representation of an IPv6 IP address. A `ValueError` is raised\nif the integer is negative or too large to be an IPv6 IP address.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "IsADirectoryError", "path": "library/exceptions#IsADirectoryError", "type": "Built-in Exceptions", "text": "\nRaised when a file operation (such as `os.remove()`) is requested on a\ndirectory. Corresponds to `errno` `EISDIR`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "isinstance()", "path": "library/functions#isinstance", "type": "Built-in Functions", "text": "\nReturn `True` if the object argument is an instance of the classinfo argument,\nor of a (direct, indirect or virtual) subclass thereof. If object is not an\nobject of the given type, the function always returns `False`. If classinfo is\na tuple of type objects (or recursively, other such tuples), return `True` if\nobject is an instance of any of the types. If classinfo is not a type or tuple\nof types and such tuples, a `TypeError` exception is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "issubclass()", "path": "library/functions#issubclass", "type": "Built-in Functions", "text": "\nReturn `True` if class is a subclass (direct, indirect or virtual) of\nclassinfo. A class is considered a subclass of itself. classinfo may be a\ntuple of class objects, in which case every entry in classinfo will be\nchecked. In any other case, a `TypeError` exception is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "iter()", "path": "library/functions#iter", "type": "Built-in Functions", "text": "\nReturn an iterator object. The first argument is interpreted very differently\ndepending on the presence of the second argument. Without a second argument,\nobject must be a collection object which supports the iteration protocol (the\n`__iter__()` method), or it must support the sequence protocol (the\n`__getitem__()` method with integer arguments starting at `0`). If it does not\nsupport either of those protocols, `TypeError` is raised. If the second\nargument, sentinel, is given, then object must be a callable object. The\niterator created in this case will call object with no arguments for each call\nto its `__next__()` method; if the value returned is equal to sentinel,\n`StopIteration` will be raised, otherwise the value will be returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "iterator.__iter__()", "path": "library/stdtypes#iterator.__iter__", "type": "Built-in Types", "text": "\nReturn the iterator object itself. This is required to allow both containers\nand iterators to be used with the `for` and `in` statements. This method\ncorresponds to the `tp_iter` slot of the type structure for Python objects in\nthe Python/C API.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "iterator.__next__()", "path": "library/stdtypes#iterator.__next__", "type": "Built-in Types", "text": "\nReturn the next item from the container. If there are no further items, raise\nthe `StopIteration` exception. This method corresponds to the `tp_iternext`\nslot of the type structure for Python objects in the Python/C API.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "itertools", "path": "library/itertools", "type": "Functional Programming", "text": "\nThis module implements a number of iterator building blocks inspired by\nconstructs from APL, Haskell, and SML. Each has been recast in a form suitable\nfor Python.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "itertools.accumulate()", "path": "library/itertools#itertools.accumulate", "type": "Functional Programming", "text": "\nMake an iterator that returns accumulated sums, or accumulated results of\nother binary functions (specified via the optional func argument).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "itertools.chain()", "path": "library/itertools#itertools.chain", "type": "Functional Programming", "text": "\nMake an iterator that returns elements from the first iterable until it is\nexhausted, then proceeds to the next iterable, until all of the iterables are\nexhausted. Used for treating consecutive sequences as a single sequence.\nRoughly equivalent to:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "itertools.chain.from_iterable()", "path": "library/itertools#itertools.chain.from_iterable", "type": "Functional Programming", "text": "\nAlternate constructor for `chain()`. Gets chained inputs from a single\niterable argument that is evaluated lazily. Roughly equivalent to:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "itertools.combinations()", "path": "library/itertools#itertools.combinations", "type": "Functional Programming", "text": "\nReturn r length subsequences of elements from the input iterable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "itertools.combinations_with_replacement()", "path": "library/itertools#itertools.combinations_with_replacement", "type": "Functional Programming", "text": "\nReturn r length subsequences of elements from the input iterable allowing\nindividual elements to be repeated more than once.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "itertools.compress()", "path": "library/itertools#itertools.compress", "type": "Functional Programming", "text": "\nMake an iterator that filters elements from data returning only those that\nhave a corresponding element in selectors that evaluates to `True`. Stops when\neither the data or selectors iterables has been exhausted. Roughly equivalent\nto:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "itertools.count()", "path": "library/itertools#itertools.count", "type": "Functional Programming", "text": "\nMake an iterator that returns evenly spaced values starting with number start.\nOften used as an argument to `map()` to generate consecutive data points.\nAlso, used with `zip()` to add sequence numbers. Roughly equivalent to:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "itertools.cycle()", "path": "library/itertools#itertools.cycle", "type": "Functional Programming", "text": "\nMake an iterator returning elements from the iterable and saving a copy of\neach. When the iterable is exhausted, return elements from the saved copy.\nRepeats indefinitely. Roughly equivalent to:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "itertools.dropwhile()", "path": "library/itertools#itertools.dropwhile", "type": "Functional Programming", "text": "\nMake an iterator that drops elements from the iterable as long as the\npredicate is true; afterwards, returns every element. Note, the iterator does\nnot produce any output until the predicate first becomes false, so it may have\na lengthy start-up time. Roughly equivalent to:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "itertools.filterfalse()", "path": "library/itertools#itertools.filterfalse", "type": "Functional Programming", "text": "\nMake an iterator that filters elements from iterable returning only those for\nwhich the predicate is `False`. If predicate is `None`, return the items that\nare false. Roughly equivalent to:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "itertools.groupby()", "path": "library/itertools#itertools.groupby", "type": "Functional Programming", "text": "\nMake an iterator that returns consecutive keys and groups from the iterable.\nThe key is a function computing a key value for each element. If not specified\nor is `None`, key defaults to an identity function and returns the element\nunchanged. Generally, the iterable needs to already be sorted on the same key\nfunction.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "itertools.islice()", "path": "library/itertools#itertools.islice", "type": "Functional Programming", "text": "\nMake an iterator that returns selected elements from the iterable. If start is\nnon-zero, then elements from the iterable are skipped until start is reached.\nAfterward, elements are returned consecutively unless step is set higher than\none which results in items being skipped. If stop is `None`, then iteration\ncontinues until the iterator is exhausted, if at all; otherwise, it stops at\nthe specified position. Unlike regular slicing, `islice()` does not support\nnegative values for start, stop, or step. Can be used to extract related\nfields from data where the internal structure has been flattened (for example,\na multi-line report may list a name field on every third line). Roughly\nequivalent to:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "itertools.permutations()", "path": "library/itertools#itertools.permutations", "type": "Functional Programming", "text": "\nReturn successive r length permutations of elements in the iterable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "itertools.product()", "path": "library/itertools#itertools.product", "type": "Functional Programming", "text": "\nCartesian product of input iterables.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "itertools.repeat()", "path": "library/itertools#itertools.repeat", "type": "Functional Programming", "text": "\nMake an iterator that returns object over and over again. Runs indefinitely\nunless the times argument is specified. Used as argument to `map()` for\ninvariant parameters to the called function. Also used with `zip()` to create\nan invariant part of a tuple record.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "itertools.starmap()", "path": "library/itertools#itertools.starmap", "type": "Functional Programming", "text": "\nMake an iterator that computes the function using arguments obtained from the\niterable. Used instead of `map()` when argument parameters are already grouped\nin tuples from a single iterable (the data has been \u201cpre-zipped\u201d). The\ndifference between `map()` and `starmap()` parallels the distinction between\n`function(a,b)` and `function(*c)`. Roughly equivalent to:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "itertools.takewhile()", "path": "library/itertools#itertools.takewhile", "type": "Functional Programming", "text": "\nMake an iterator that returns elements from the iterable as long as the\npredicate is true. Roughly equivalent to:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "itertools.tee()", "path": "library/itertools#itertools.tee", "type": "Functional Programming", "text": "\nReturn n independent iterators from a single iterable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "itertools.zip_longest()", "path": "library/itertools#itertools.zip_longest", "type": "Functional Programming", "text": "\nMake an iterator that aggregates elements from each of the iterables. If the\niterables are of uneven length, missing values are filled-in with fillvalue.\nIteration continues until the longest iterable is exhausted. Roughly\nequivalent to:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "json", "path": "library/json", "type": "Internet Data", "text": "\nSource code: Lib/json/__init__.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "json.dump()", "path": "library/json#json.dump", "type": "Internet Data", "text": "\nSerialize obj as a JSON formatted stream to fp (a `.write()`-supporting file-\nlike object) using this conversion table.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "json.dumps()", "path": "library/json#json.dumps", "type": "Internet Data", "text": "\nSerialize obj to a JSON formatted `str` using this conversion table. The\narguments have the same meaning as in `dump()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "json.JSONDecodeError", "path": "library/json#json.JSONDecodeError", "type": "Internet Data", "text": "\nSubclass of `ValueError` with the following additional attributes:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "json.JSONDecodeError.colno", "path": "library/json#json.JSONDecodeError.colno", "type": "Internet Data", "text": "\nThe column corresponding to pos.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "json.JSONDecodeError.doc", "path": "library/json#json.JSONDecodeError.doc", "type": "Internet Data", "text": "\nThe JSON document being parsed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "json.JSONDecodeError.lineno", "path": "library/json#json.JSONDecodeError.lineno", "type": "Internet Data", "text": "\nThe line corresponding to pos.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "json.JSONDecodeError.msg", "path": "library/json#json.JSONDecodeError.msg", "type": "Internet Data", "text": "\nThe unformatted error message.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "json.JSONDecodeError.pos", "path": "library/json#json.JSONDecodeError.pos", "type": "Internet Data", "text": "\nThe start index of doc where parsing failed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "json.JSONDecoder", "path": "library/json#json.JSONDecoder", "type": "Internet Data", "text": "\nSimple JSON decoder.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "json.JSONDecoder.decode()", "path": "library/json#json.JSONDecoder.decode", "type": "Internet Data", "text": "\nReturn the Python representation of s (a `str` instance containing a JSON\ndocument).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "json.JSONDecoder.raw_decode()", "path": "library/json#json.JSONDecoder.raw_decode", "type": "Internet Data", "text": "\nDecode a JSON document from s (a `str` beginning with a JSON document) and\nreturn a 2-tuple of the Python representation and the index in s where the\ndocument ended.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "json.JSONEncoder", "path": "library/json#json.JSONEncoder", "type": "Internet Data", "text": "\nExtensible JSON encoder for Python data structures.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "json.JSONEncoder.default()", "path": "library/json#json.JSONEncoder.default", "type": "Internet Data", "text": "\nImplement this method in a subclass such that it returns a serializable object\nfor o, or calls the base implementation (to raise a `TypeError`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "json.JSONEncoder.encode()", "path": "library/json#json.JSONEncoder.encode", "type": "Internet Data", "text": "\nReturn a JSON string representation of a Python data structure, o. For\nexample:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "json.JSONEncoder.iterencode()", "path": "library/json#json.JSONEncoder.iterencode", "type": "Internet Data", "text": "\nEncode the given object, o, and yield each string representation as available.\nFor example:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "json.load()", "path": "library/json#json.load", "type": "Internet Data", "text": "\nDeserialize fp (a `.read()`-supporting text file or binary file containing a\nJSON document) to a Python object using this conversion table.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "json.loads()", "path": "library/json#json.loads", "type": "Internet Data", "text": "\nDeserialize s (a `str`, `bytes` or `bytearray` instance containing a JSON\ndocument) to a Python object using this conversion table.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "KeyboardInterrupt", "path": "library/exceptions#KeyboardInterrupt", "type": "Built-in Exceptions", "text": "\nRaised when the user hits the interrupt key (normally `Control-C` or\n`Delete`). During execution, a check for interrupts is made regularly. The\nexception inherits from `BaseException` so as to not be accidentally caught by\ncode that catches `Exception` and thus prevent the interpreter from exiting.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "KeyError", "path": "library/exceptions#KeyError", "type": "Built-in Exceptions", "text": "\nRaised when a mapping (dictionary) key is not found in the set of existing\nkeys.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "keyword", "path": "library/keyword", "type": "Language", "text": "\nSource code: Lib/keyword.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "keyword.iskeyword()", "path": "library/keyword#keyword.iskeyword", "type": "Language", "text": "\nReturn `True` if s is a Python keyword.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "keyword.issoftkeyword()", "path": "library/keyword#keyword.issoftkeyword", "type": "Language", "text": "\nReturn `True` if s is a Python soft keyword.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "keyword.kwlist", "path": "library/keyword#keyword.kwlist", "type": "Language", "text": "\nSequence containing all the keywords defined for the interpreter. If any\nkeywords are defined to only be active when particular `__future__` statements\nare in effect, these will be included as well.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "keyword.softkwlist", "path": "library/keyword#keyword.softkwlist", "type": "Language", "text": "\nSequence containing all the soft keywords defined for the interpreter. If any\nsoft keywords are defined to only be active when particular `__future__`\nstatements are in effect, these will be included as well.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "len()", "path": "library/functions#len", "type": "Built-in Functions", "text": "\nReturn the length (the number of items) of an object. The argument may be a\nsequence (such as a string, bytes, tuple, list, or range) or a collection\n(such as a dictionary, set, or frozen set).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "license", "path": "library/constants#license", "type": "Built-in Constants", "text": "\nObject that when printed, prints the message \u201cType license() to see the full\nlicense text\u201d, and when called, displays the full license text in a pager-like\nfashion (one screen at a time).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "linecache", "path": "library/linecache", "type": "File & Directory Access", "text": "\nSource code: Lib/linecache.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "linecache.checkcache()", "path": "library/linecache#linecache.checkcache", "type": "File & Directory Access", "text": "\nCheck the cache for validity. Use this function if files in the cache may have\nchanged on disk, and you require the updated version. If filename is omitted,\nit will check all the entries in the cache.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "linecache.clearcache()", "path": "library/linecache#linecache.clearcache", "type": "File & Directory Access", "text": "\nClear the cache. Use this function if you no longer need lines from files\npreviously read using `getline()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "linecache.getline()", "path": "library/linecache#linecache.getline", "type": "File & Directory Access", "text": "\nGet line lineno from file named filename. This function will never raise an\nexception \u2014 it will return `''` on errors (the terminating newline character\nwill be included for lines that are found).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "linecache.lazycache()", "path": "library/linecache#linecache.lazycache", "type": "File & Directory Access", "text": "\nCapture enough detail about a non-file-based module to permit getting its\nlines later via `getline()` even if module_globals is `None` in the later\ncall. This avoids doing I/O until a line is actually needed, without having to\ncarry the module globals around indefinitely.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "list", "path": "library/stdtypes#list", "type": "Built-in Types", "text": "\nLists may be constructed in several ways:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "list", "path": "library/functions#list", "type": "Built-in Functions", "text": "\nRather than being a function, `list` is actually a mutable sequence type, as\ndocumented in Lists and Sequence Types \u2014 list, tuple, range.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "list.sort()", "path": "library/stdtypes#list.sort", "type": "Built-in Types", "text": "\nThis method sorts the list in place, using only `<` comparisons between items.\nExceptions are not suppressed - if any comparison operations fail, the entire\nsort operation will fail (and the list will likely be left in a partially\nmodified state).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale", "path": "library/locale", "type": "Internationalization", "text": "\nSource code: Lib/locale.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.ALT_DIGITS", "path": "library/locale#locale.ALT_DIGITS", "type": "Internationalization", "text": "\nGet a representation of up to 100 values used to represent the values 0 to 99.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.atof()", "path": "library/locale#locale.atof", "type": "Internationalization", "text": "\nConverts a string to a floating point number, following the `LC_NUMERIC`\nsettings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.atoi()", "path": "library/locale#locale.atoi", "type": "Internationalization", "text": "\nConverts a string to an integer, following the `LC_NUMERIC` conventions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.bindtextdomain()", "path": "library/locale#locale.bindtextdomain", "type": "Internationalization", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.CHAR_MAX", "path": "library/locale#locale.CHAR_MAX", "type": "Internationalization", "text": "\nThis is a symbolic constant used for different values returned by\n`localeconv()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.CODESET", "path": "library/locale#locale.CODESET", "type": "Internationalization", "text": "\nGet a string with the name of the character encoding used in the selected\nlocale.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.CRNCYSTR", "path": "library/locale#locale.CRNCYSTR", "type": "Internationalization", "text": "\nGet the currency symbol, preceded by \u201c-\u201d if the symbol should appear before\nthe value, \u201c+\u201d if the symbol should appear after the value, or \u201c.\u201d if the\nsymbol should replace the radix character.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.currency()", "path": "library/locale#locale.currency", "type": "Internationalization", "text": "\nFormats a number val according to the current `LC_MONETARY` settings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.dcgettext()", "path": "library/locale#locale.dcgettext", "type": "Internationalization", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.delocalize()", "path": "library/locale#locale.delocalize", "type": "Internationalization", "text": "\nConverts a string into a normalized number string, following the `LC_NUMERIC`\nsettings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.dgettext()", "path": "library/locale#locale.dgettext", "type": "Internationalization", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.D_FMT", "path": "library/locale#locale.D_FMT", "type": "Internationalization", "text": "\nGet a string that can be used as a format string for `time.strftime()` to\nrepresent a date in a locale-specific way.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.D_T_FMT", "path": "library/locale#locale.D_T_FMT", "type": "Internationalization", "text": "\nGet a string that can be used as a format string for `time.strftime()` to\nrepresent date and time in a locale-specific way.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.ERA", "path": "library/locale#locale.ERA", "type": "Internationalization", "text": "\nGet a string that represents the era used in the current locale.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.ERA_D_FMT", "path": "library/locale#locale.ERA_D_FMT", "type": "Internationalization", "text": "\nGet a format string for `time.strftime()` to represent a date in a locale-\nspecific era-based way.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.ERA_D_T_FMT", "path": "library/locale#locale.ERA_D_T_FMT", "type": "Internationalization", "text": "\nGet a format string for `time.strftime()` to represent date and time in a\nlocale-specific era-based way.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.ERA_T_FMT", "path": "library/locale#locale.ERA_T_FMT", "type": "Internationalization", "text": "\nGet a format string for `time.strftime()` to represent a time in a locale-\nspecific era-based way.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.Error", "path": "library/locale#locale.Error", "type": "Internationalization", "text": "\nException raised when the locale passed to `setlocale()` is not recognized.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.format()", "path": "library/locale#locale.format", "type": "Internationalization", "text": "\nPlease note that this function works like `format_string()` but will only work\nfor exactly one `%char` specifier. For example, `'%f'` and `'%.0f'` are both\nvalid specifiers, but `'%f KiB'` is not.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.format_string()", "path": "library/locale#locale.format_string", "type": "Internationalization", "text": "\nFormats a number val according to the current `LC_NUMERIC` setting. The format\nfollows the conventions of the `%` operator. For floating point values, the\ndecimal point is modified if appropriate. If grouping is true, also takes the\ngrouping into account.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.getdefaultlocale()", "path": "library/locale#locale.getdefaultlocale", "type": "Internationalization", "text": "\nTries to determine the default locale settings and returns them as a tuple of\nthe form `(language code, encoding)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.getlocale()", "path": "library/locale#locale.getlocale", "type": "Internationalization", "text": "\nReturns the current setting for the given locale category as sequence\ncontaining language code, encoding. category may be one of the `LC_*` values\nexcept `LC_ALL`. It defaults to `LC_CTYPE`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.getpreferredencoding()", "path": "library/locale#locale.getpreferredencoding", "type": "Internationalization", "text": "\nReturn the encoding used for text data, according to user preferences. User\npreferences are expressed differently on different systems, and might not be\navailable programmatically on some systems, so this function only returns a\nguess.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.gettext()", "path": "library/locale#locale.gettext", "type": "Internationalization", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.LC_ALL", "path": "library/locale#locale.LC_ALL", "type": "Internationalization", "text": "\nCombination of all locale settings. If this flag is used when the locale is\nchanged, setting the locale for all categories is attempted. If that fails for\nany category, no category is changed at all. When the locale is retrieved\nusing this flag, a string indicating the setting for all categories is\nreturned. This string can be later used to restore the settings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.LC_COLLATE", "path": "library/locale#locale.LC_COLLATE", "type": "Internationalization", "text": "\nLocale category for sorting strings. The functions `strcoll()` and `strxfrm()`\nof the `locale` module are affected.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.LC_CTYPE", "path": "library/locale#locale.LC_CTYPE", "type": "Internationalization", "text": "\nLocale category for the character type functions. Depending on the settings of\nthis category, the functions of module `string` dealing with case change their\nbehaviour.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.LC_MESSAGES", "path": "library/locale#locale.LC_MESSAGES", "type": "Internationalization", "text": "\nLocale category for message display. Python currently does not support\napplication specific locale-aware messages. Messages displayed by the\noperating system, like those returned by `os.strerror()` might be affected by\nthis category.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.LC_MONETARY", "path": "library/locale#locale.LC_MONETARY", "type": "Internationalization", "text": "\nLocale category for formatting of monetary values. The available options are\navailable from the `localeconv()` function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.LC_NUMERIC", "path": "library/locale#locale.LC_NUMERIC", "type": "Internationalization", "text": "\nLocale category for formatting numbers. The functions `format()`, `atoi()`,\n`atof()` and `str()` of the `locale` module are affected by that category. All\nother numeric formatting operations are not affected.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.LC_TIME", "path": "library/locale#locale.LC_TIME", "type": "Internationalization", "text": "\nLocale category for the formatting of time. The function `time.strftime()`\nfollows these conventions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.localeconv()", "path": "library/locale#locale.localeconv", "type": "Internationalization", "text": "\nReturns the database of the local conventions as a dictionary. This dictionary\nhas the following strings as keys:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.nl_langinfo()", "path": "library/locale#locale.nl_langinfo", "type": "Internationalization", "text": "\nReturn some locale-specific information as a string. This function is not\navailable on all systems, and the set of possible options might also vary\nacross platforms. The possible argument values are numbers, for which symbolic\nconstants are available in the locale module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.NOEXPR", "path": "library/locale#locale.NOEXPR", "type": "Internationalization", "text": "\nGet a regular expression that can be used with the regex(3) function to\nrecognize a negative response to a yes/no question.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.normalize()", "path": "library/locale#locale.normalize", "type": "Internationalization", "text": "\nReturns a normalized locale code for the given locale name. The returned\nlocale code is formatted for use with `setlocale()`. If normalization fails,\nthe original name is returned unchanged.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.RADIXCHAR", "path": "library/locale#locale.RADIXCHAR", "type": "Internationalization", "text": "\nGet the radix character (decimal dot, decimal comma, etc.).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.resetlocale()", "path": "library/locale#locale.resetlocale", "type": "Internationalization", "text": "\nSets the locale for category to the default setting.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.setlocale()", "path": "library/locale#locale.setlocale", "type": "Internationalization", "text": "\nIf locale is given and not `None`, `setlocale()` modifies the locale setting\nfor the category. The available categories are listed in the data description\nbelow. locale may be a string, or an iterable of two strings (language code\nand encoding). If it\u2019s an iterable, it\u2019s converted to a locale name using the\nlocale aliasing engine. An empty string specifies the user\u2019s default settings.\nIf the modification of the locale fails, the exception `Error` is raised. If\nsuccessful, the new locale setting is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.str()", "path": "library/locale#locale.str", "type": "Internationalization", "text": "\nFormats a floating point number using the same format as the built-in function\n`str(float)`, but takes the decimal point into account.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.strcoll()", "path": "library/locale#locale.strcoll", "type": "Internationalization", "text": "\nCompares two strings according to the current `LC_COLLATE` setting. As any\nother compare function, returns a negative, or a positive value, or `0`,\ndepending on whether string1 collates before or after string2 or is equal to\nit.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.strxfrm()", "path": "library/locale#locale.strxfrm", "type": "Internationalization", "text": "\nTransforms a string to one that can be used in locale-aware comparisons. For\nexample, `strxfrm(s1) < strxfrm(s2)` is equivalent to `strcoll(s1, s2) < 0`.\nThis function can be used when the same string is compared repeatedly, e.g.\nwhen collating a sequence of strings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.textdomain()", "path": "library/locale#locale.textdomain", "type": "Internationalization", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.THOUSEP", "path": "library/locale#locale.THOUSEP", "type": "Internationalization", "text": "\nGet the separator character for thousands (groups of three digits).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.T_FMT", "path": "library/locale#locale.T_FMT", "type": "Internationalization", "text": "\nGet a string that can be used as a format string for `time.strftime()` to\nrepresent a time in a locale-specific way.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.T_FMT_AMPM", "path": "library/locale#locale.T_FMT_AMPM", "type": "Internationalization", "text": "\nGet a format string for `time.strftime()` to represent time in the am/pm\nformat.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locale.YESEXPR", "path": "library/locale#locale.YESEXPR", "type": "Internationalization", "text": "\nGet a regular expression that can be used with the regex function to recognize\na positive response to a yes/no question.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "locals()", "path": "library/functions#locals", "type": "Built-in Functions", "text": "\nUpdate and return a dictionary representing the current local symbol table.\nFree variables are returned by `locals()` when it is called in function\nblocks, but not in class blocks. Note that at the module level, `locals()` and\n`globals()` are the same dictionary.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging", "path": "library/logging", "type": "Logging", "text": "\nSource code: Lib/logging/__init__.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.addLevelName()", "path": "library/logging#logging.addLevelName", "type": "Logging", "text": "\nAssociates level level with text levelName in an internal dictionary, which is\nused to map numeric levels to a textual representation, for example when a\n`Formatter` formats a message. This function can also be used to define your\nown levels. The only constraints are that all levels used must be registered\nusing this function, levels should be positive integers and they should\nincrease in increasing order of severity.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.basicConfig()", "path": "library/logging#logging.basicConfig", "type": "Logging", "text": "\nDoes basic configuration for the logging system by creating a `StreamHandler`\nwith a default `Formatter` and adding it to the root logger. The functions\n`debug()`, `info()`, `warning()`, `error()` and `critical()` will call\n`basicConfig()` automatically if no handlers are defined for the root logger.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.captureWarnings()", "path": "library/logging#logging.captureWarnings", "type": "Logging", "text": "\nThis function is used to turn the capture of warnings by logging on and off.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.config", "path": "library/logging.config", "type": "Logging", "text": "\nSource code: Lib/logging/config.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.config.dictConfig()", "path": "library/logging.config#logging.config.dictConfig", "type": "Logging", "text": "\nTakes the logging configuration from a dictionary. The contents of this\ndictionary are described in Configuration dictionary schema below.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.config.fileConfig()", "path": "library/logging.config#logging.config.fileConfig", "type": "Logging", "text": "\nReads the logging configuration from a `configparser`-format file. The format\nof the file should be as described in Configuration file format. This function\ncan be called several times from an application, allowing an end user to\nselect from various pre-canned configurations (if the developer provides a\nmechanism to present the choices and load the chosen configuration).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.config.listen()", "path": "library/logging.config#logging.config.listen", "type": "Logging", "text": "\nStarts up a socket server on the specified port, and listens for new\nconfigurations. If no port is specified, the module\u2019s default\n`DEFAULT_LOGGING_CONFIG_PORT` is used. Logging configurations will be sent as\na file suitable for processing by `dictConfig()` or `fileConfig()`. Returns a\n`Thread` instance on which you can call `start()` to start the server, and\nwhich you can `join()` when appropriate. To stop the server, call\n`stopListening()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.config.stopListening()", "path": "library/logging.config#logging.config.stopListening", "type": "Logging", "text": "\nStops the listening server which was created with a call to `listen()`. This\nis typically called before calling `join()` on the return value from\n`listen()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.critical()", "path": "library/logging#logging.critical", "type": "Logging", "text": "\nLogs a message with level `CRITICAL` on the root logger. The arguments are\ninterpreted as for `debug()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.debug()", "path": "library/logging#logging.debug", "type": "Logging", "text": "\nLogs a message with level `DEBUG` on the root logger. The msg is the message\nformat string, and the args are the arguments which are merged into msg using\nthe string formatting operator. (Note that this means that you can use\nkeywords in the format string, together with a single dictionary argument.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.disable()", "path": "library/logging#logging.disable", "type": "Logging", "text": "\nProvides an overriding level level for all loggers which takes precedence over\nthe logger\u2019s own level. When the need arises to temporarily throttle logging\noutput down across the whole application, this function can be useful. Its\neffect is to disable all logging calls of severity level and below, so that if\nyou call it with a value of INFO, then all INFO and DEBUG events would be\ndiscarded, whereas those of severity WARNING and above would be processed\naccording to the logger\u2019s effective level. If\n`logging.disable(logging.NOTSET)` is called, it effectively removes this\noverriding level, so that logging output again depends on the effective levels\nof individual loggers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.error()", "path": "library/logging#logging.error", "type": "Logging", "text": "\nLogs a message with level `ERROR` on the root logger. The arguments are\ninterpreted as for `debug()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.exception()", "path": "library/logging#logging.exception", "type": "Logging", "text": "\nLogs a message with level `ERROR` on the root logger. The arguments are\ninterpreted as for `debug()`. Exception info is added to the logging message.\nThis function should only be called from an exception handler.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.FileHandler", "path": "library/logging.handlers#logging.FileHandler", "type": "Logging", "text": "\nReturns a new instance of the `FileHandler` class. The specified file is\nopened and used as the stream for logging. If mode is not specified, `'a'` is\nused. If encoding is not `None`, it is used to open the file with that\nencoding. If delay is true, then file opening is deferred until the first call\nto `emit()`. By default, the file grows indefinitely. If errors is specified,\nit\u2019s used to determine how encoding errors are handled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.FileHandler.close()", "path": "library/logging.handlers#logging.FileHandler.close", "type": "Logging", "text": "\nCloses the file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.FileHandler.emit()", "path": "library/logging.handlers#logging.FileHandler.emit", "type": "Logging", "text": "\nOutputs the record to the file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Filter", "path": "library/logging#logging.Filter", "type": "Logging", "text": "\nReturns an instance of the `Filter` class. If name is specified, it names a\nlogger which, together with its children, will have its events allowed through\nthe filter. If name is the empty string, allows every event.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Filter.filter()", "path": "library/logging#logging.Filter.filter", "type": "Logging", "text": "\nIs the specified record to be logged? Returns zero for no, nonzero for yes. If\ndeemed appropriate, the record may be modified in-place by this method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Formatter", "path": "library/logging#logging.Formatter", "type": "Logging", "text": "\nReturns a new instance of the `Formatter` class. The instance is initialized\nwith a format string for the message as a whole, as well as a format string\nfor the date/time portion of a message. If no fmt is specified,\n`'%(message)s'` is used. If no datefmt is specified, a format is used which is\ndescribed in the `formatTime()` documentation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Formatter.format()", "path": "library/logging#logging.Formatter.format", "type": "Logging", "text": "\nThe record\u2019s attribute dictionary is used as the operand to a string\nformatting operation. Returns the resulting string. Before formatting the\ndictionary, a couple of preparatory steps are carried out. The message\nattribute of the record is computed using msg % args. If the formatting string\ncontains `'(asctime)'`, `formatTime()` is called to format the event time. If\nthere is exception information, it is formatted using `formatException()` and\nappended to the message. Note that the formatted exception information is\ncached in attribute exc_text. This is useful because the exception information\ncan be pickled and sent across the wire, but you should be careful if you have\nmore than one `Formatter` subclass which customizes the formatting of\nexception information. In this case, you will have to clear the cached value\nafter a formatter has done its formatting, so that the next formatter to\nhandle the event doesn\u2019t use the cached value but recalculates it afresh.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Formatter.formatException()", "path": "library/logging#logging.Formatter.formatException", "type": "Logging", "text": "\nFormats the specified exception information (a standard exception tuple as\nreturned by `sys.exc_info()`) as a string. This default implementation just\nuses `traceback.print_exception()`. The resulting string is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Formatter.formatStack()", "path": "library/logging#logging.Formatter.formatStack", "type": "Logging", "text": "\nFormats the specified stack information (a string as returned by\n`traceback.print_stack()`, but with the last newline removed) as a string.\nThis default implementation just returns the input value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Formatter.formatTime()", "path": "library/logging#logging.Formatter.formatTime", "type": "Logging", "text": "\nThis method should be called from `format()` by a formatter which wants to\nmake use of a formatted time. This method can be overridden in formatters to\nprovide for any specific requirement, but the basic behavior is as follows: if\ndatefmt (a string) is specified, it is used with `time.strftime()` to format\nthe creation time of the record. Otherwise, the format \u2018%Y-%m-%d %H:%M:%S,uuu\u2019\nis used, where the uuu part is a millisecond value and the other letters are\nas per the `time.strftime()` documentation. An example time in this format is\n`2003-01-23 00:29:50,411`. The resulting string is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.getLevelName()", "path": "library/logging#logging.getLevelName", "type": "Logging", "text": "\nReturns the textual or numeric representation of logging level level.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.getLogger()", "path": "library/logging#logging.getLogger", "type": "Logging", "text": "\nReturn a logger with the specified name or, if name is `None`, return a logger\nwhich is the root logger of the hierarchy. If specified, the name is typically\na dot-separated hierarchical name like \u2018a\u2019, \u2018a.b\u2019 or \u2018a.b.c.d\u2019. Choice of\nthese names is entirely up to the developer who is using logging.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.getLoggerClass()", "path": "library/logging#logging.getLoggerClass", "type": "Logging", "text": "\nReturn either the standard `Logger` class, or the last class passed to\n`setLoggerClass()`. This function may be called from within a new class\ndefinition, to ensure that installing a customized `Logger` class will not\nundo customizations already applied by other code. For example:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.getLogRecordFactory()", "path": "library/logging#logging.getLogRecordFactory", "type": "Logging", "text": "\nReturn a callable which is used to create a `LogRecord`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Handler", "path": "library/logging#logging.Handler", "type": "Logging", "text": "\nInitializes the `Handler` instance by setting its level, setting the list of\nfilters to the empty list and creating a lock (using `createLock()`) for\nserializing access to an I/O mechanism.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Handler.acquire()", "path": "library/logging#logging.Handler.acquire", "type": "Logging", "text": "\nAcquires the thread lock created with `createLock()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Handler.addFilter()", "path": "library/logging#logging.Handler.addFilter", "type": "Logging", "text": "\nAdds the specified filter filter to this handler.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Handler.close()", "path": "library/logging#logging.Handler.close", "type": "Logging", "text": "\nTidy up any resources used by the handler. This version does no output but\nremoves the handler from an internal list of handlers which is closed when\n`shutdown()` is called. Subclasses should ensure that this gets called from\noverridden `close()` methods.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Handler.createLock()", "path": "library/logging#logging.Handler.createLock", "type": "Logging", "text": "\nInitializes a thread lock which can be used to serialize access to underlying\nI/O functionality which may not be threadsafe.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Handler.emit()", "path": "library/logging#logging.Handler.emit", "type": "Logging", "text": "\nDo whatever it takes to actually log the specified logging record. This\nversion is intended to be implemented by subclasses and so raises a\n`NotImplementedError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Handler.filter()", "path": "library/logging#logging.Handler.filter", "type": "Logging", "text": "\nApply this handler\u2019s filters to the record and return `True` if the record is\nto be processed. The filters are consulted in turn, until one of them returns\na false value. If none of them return a false value, the record will be\nemitted. If one returns a false value, the handler will not emit the record.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Handler.flush()", "path": "library/logging#logging.Handler.flush", "type": "Logging", "text": "\nEnsure all logging output has been flushed. This version does nothing and is\nintended to be implemented by subclasses.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Handler.format()", "path": "library/logging#logging.Handler.format", "type": "Logging", "text": "\nDo formatting for a record - if a formatter is set, use it. Otherwise, use the\ndefault formatter for the module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Handler.handle()", "path": "library/logging#logging.Handler.handle", "type": "Logging", "text": "\nConditionally emits the specified logging record, depending on filters which\nmay have been added to the handler. Wraps the actual emission of the record\nwith acquisition/release of the I/O thread lock.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Handler.handleError()", "path": "library/logging#logging.Handler.handleError", "type": "Logging", "text": "\nThis method should be called from handlers when an exception is encountered\nduring an `emit()` call. If the module-level attribute `raiseExceptions` is\n`False`, exceptions get silently ignored. This is what is mostly wanted for a\nlogging system - most users will not care about errors in the logging system,\nthey are more interested in application errors. You could, however, replace\nthis with a custom handler if you wish. The specified record is the one which\nwas being processed when the exception occurred. (The default value of\n`raiseExceptions` is `True`, as that is more useful during development).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Handler.release()", "path": "library/logging#logging.Handler.release", "type": "Logging", "text": "\nReleases the thread lock acquired with `acquire()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Handler.removeFilter()", "path": "library/logging#logging.Handler.removeFilter", "type": "Logging", "text": "\nRemoves the specified filter filter from this handler.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Handler.setFormatter()", "path": "library/logging#logging.Handler.setFormatter", "type": "Logging", "text": "\nSets the `Formatter` for this handler to fmt.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Handler.setLevel()", "path": "library/logging#logging.Handler.setLevel", "type": "Logging", "text": "\nSets the threshold for this handler to level. Logging messages which are less\nsevere than level will be ignored. When a handler is created, the level is set\nto `NOTSET` (which causes all messages to be processed).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Handler.__init__()", "path": "library/logging#logging.Handler.__init__", "type": "Logging", "text": "\nInitializes the `Handler` instance by setting its level, setting the list of\nfilters to the empty list and creating a lock (using `createLock()`) for\nserializing access to an I/O mechanism.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers", "path": "library/logging.handlers", "type": "Logging", "text": "\nSource code: Lib/logging/handlers.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.BaseRotatingHandler", "path": "library/logging.handlers#logging.handlers.BaseRotatingHandler", "type": "Logging", "text": "\nThe parameters are as for `FileHandler`. The attributes are:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.BaseRotatingHandler.namer", "path": "library/logging.handlers#logging.handlers.BaseRotatingHandler.namer", "type": "Logging", "text": "\nIf this attribute is set to a callable, the `rotation_filename()` method\ndelegates to this callable. The parameters passed to the callable are those\npassed to `rotation_filename()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.BaseRotatingHandler.rotate()", "path": "library/logging.handlers#logging.handlers.BaseRotatingHandler.rotate", "type": "Logging", "text": "\nWhen rotating, rotate the current log.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.BaseRotatingHandler.rotation_filename()", "path": "library/logging.handlers#logging.handlers.BaseRotatingHandler.rotation_filename", "type": "Logging", "text": "\nModify the filename of a log file when rotating.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.BaseRotatingHandler.rotator", "path": "library/logging.handlers#logging.handlers.BaseRotatingHandler.rotator", "type": "Logging", "text": "\nIf this attribute is set to a callable, the `rotate()` method delegates to\nthis callable. The parameters passed to the callable are those passed to\n`rotate()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.BufferingHandler", "path": "library/logging.handlers#logging.handlers.BufferingHandler", "type": "Logging", "text": "\nInitializes the handler with a buffer of the specified capacity. Here,\ncapacity means the number of logging records buffered.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.BufferingHandler.emit()", "path": "library/logging.handlers#logging.handlers.BufferingHandler.emit", "type": "Logging", "text": "\nAppend the record to the buffer. If `shouldFlush()` returns true, call\n`flush()` to process the buffer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.BufferingHandler.flush()", "path": "library/logging.handlers#logging.handlers.BufferingHandler.flush", "type": "Logging", "text": "\nYou can override this to implement custom flushing behavior. This version just\nzaps the buffer to empty.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.BufferingHandler.shouldFlush()", "path": "library/logging.handlers#logging.handlers.BufferingHandler.shouldFlush", "type": "Logging", "text": "\nReturn `True` if the buffer is up to capacity. This method can be overridden\nto implement custom flushing strategies.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.DatagramHandler", "path": "library/logging.handlers#logging.handlers.DatagramHandler", "type": "Logging", "text": "\nReturns a new instance of the `DatagramHandler` class intended to communicate\nwith a remote machine whose address is given by host and port.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.DatagramHandler.emit()", "path": "library/logging.handlers#logging.handlers.DatagramHandler.emit", "type": "Logging", "text": "\nPickles the record\u2019s attribute dictionary and writes it to the socket in\nbinary format. If there is an error with the socket, silently drops the\npacket. To unpickle the record at the receiving end into a `LogRecord`, use\nthe `makeLogRecord()` function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.DatagramHandler.makeSocket()", "path": "library/logging.handlers#logging.handlers.DatagramHandler.makeSocket", "type": "Logging", "text": "\nThe factory method of `SocketHandler` is here overridden to create a UDP\nsocket (`socket.SOCK_DGRAM`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.DatagramHandler.send()", "path": "library/logging.handlers#logging.handlers.DatagramHandler.send", "type": "Logging", "text": "\nSend a pickled byte-string to a socket. The format of the sent byte-string is\nas described in the documentation for `SocketHandler.makePickle()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.HTTPHandler", "path": "library/logging.handlers#logging.handlers.HTTPHandler", "type": "Logging", "text": "\nReturns a new instance of the `HTTPHandler` class. The host can be of the form\n`host:port`, should you need to use a specific port number. If no method is\nspecified, `GET` is used. If secure is true, a HTTPS connection will be used.\nThe context parameter may be set to a `ssl.SSLContext` instance to configure\nthe SSL settings used for the HTTPS connection. If credentials is specified,\nit should be a 2-tuple consisting of userid and password, which will be placed\nin a HTTP \u2018Authorization\u2019 header using Basic authentication. If you specify\ncredentials, you should also specify secure=True so that your userid and\npassword are not passed in cleartext across the wire.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.HTTPHandler.emit()", "path": "library/logging.handlers#logging.handlers.HTTPHandler.emit", "type": "Logging", "text": "\nSends the record to the Web server as a URL-encoded dictionary. The\n`mapLogRecord()` method is used to convert the record to the dictionary to be\nsent.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.HTTPHandler.mapLogRecord()", "path": "library/logging.handlers#logging.handlers.HTTPHandler.mapLogRecord", "type": "Logging", "text": "\nProvides a dictionary, based on `record`, which is to be URL-encoded and sent\nto the web server. The default implementation just returns `record.__dict__`.\nThis method can be overridden if e.g. only a subset of `LogRecord` is to be\nsent to the web server, or if more specific customization of what\u2019s sent to\nthe server is required.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.MemoryHandler", "path": "library/logging.handlers#logging.handlers.MemoryHandler", "type": "Logging", "text": "\nReturns a new instance of the `MemoryHandler` class. The instance is\ninitialized with a buffer size of capacity (number of records buffered). If\nflushLevel is not specified, `ERROR` is used. If no target is specified, the\ntarget will need to be set using `setTarget()` before this handler does\nanything useful. If flushOnClose is specified as `False`, then the buffer is\nnot flushed when the handler is closed. If not specified or specified as\n`True`, the previous behaviour of flushing the buffer will occur when the\nhandler is closed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.MemoryHandler.close()", "path": "library/logging.handlers#logging.handlers.MemoryHandler.close", "type": "Logging", "text": "\nCalls `flush()`, sets the target to `None` and clears the buffer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.MemoryHandler.flush()", "path": "library/logging.handlers#logging.handlers.MemoryHandler.flush", "type": "Logging", "text": "\nFor a `MemoryHandler`, flushing means just sending the buffered records to the\ntarget, if there is one. The buffer is also cleared when this happens.\nOverride if you want different behavior.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.MemoryHandler.setTarget()", "path": "library/logging.handlers#logging.handlers.MemoryHandler.setTarget", "type": "Logging", "text": "\nSets the target handler for this handler.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.MemoryHandler.shouldFlush()", "path": "library/logging.handlers#logging.handlers.MemoryHandler.shouldFlush", "type": "Logging", "text": "\nChecks for buffer full or a record at the flushLevel or higher.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.NTEventLogHandler", "path": "library/logging.handlers#logging.handlers.NTEventLogHandler", "type": "Logging", "text": "\nReturns a new instance of the `NTEventLogHandler` class. The appname is used\nto define the application name as it appears in the event log. An appropriate\nregistry entry is created using this name. The dllname should give the fully\nqualified pathname of a .dll or .exe which contains message definitions to\nhold in the log (if not specified, `'win32service.pyd'` is used - this is\ninstalled with the Win32 extensions and contains some basic placeholder\nmessage definitions. Note that use of these placeholders will make your event\nlogs big, as the entire message source is held in the log. If you want slimmer\nlogs, you have to pass in the name of your own .dll or .exe which contains the\nmessage definitions you want to use in the event log). The logtype is one of\n`'Application'`, `'System'` or `'Security'`, and defaults to `'Application'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.NTEventLogHandler.close()", "path": "library/logging.handlers#logging.handlers.NTEventLogHandler.close", "type": "Logging", "text": "\nAt this point, you can remove the application name from the registry as a\nsource of event log entries. However, if you do this, you will not be able to\nsee the events as you intended in the Event Log Viewer - it needs to be able\nto access the registry to get the .dll name. The current version does not do\nthis.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.NTEventLogHandler.emit()", "path": "library/logging.handlers#logging.handlers.NTEventLogHandler.emit", "type": "Logging", "text": "\nDetermines the message ID, event category and event type, and then logs the\nmessage in the NT event log.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.NTEventLogHandler.getEventCategory()", "path": "library/logging.handlers#logging.handlers.NTEventLogHandler.getEventCategory", "type": "Logging", "text": "\nReturns the event category for the record. Override this if you want to\nspecify your own categories. This version returns 0.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.NTEventLogHandler.getEventType()", "path": "library/logging.handlers#logging.handlers.NTEventLogHandler.getEventType", "type": "Logging", "text": "\nReturns the event type for the record. Override this if you want to specify\nyour own types. This version does a mapping using the handler\u2019s typemap\nattribute, which is set up in `__init__()` to a dictionary which contains\nmappings for `DEBUG`, `INFO`, `WARNING`, `ERROR` and `CRITICAL`. If you are\nusing your own levels, you will either need to override this method or place a\nsuitable dictionary in the handler\u2019s typemap attribute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.NTEventLogHandler.getMessageID()", "path": "library/logging.handlers#logging.handlers.NTEventLogHandler.getMessageID", "type": "Logging", "text": "\nReturns the message ID for the record. If you are using your own messages, you\ncould do this by having the msg passed to the logger being an ID rather than a\nformat string. Then, in here, you could use a dictionary lookup to get the\nmessage ID. This version returns 1, which is the base message ID in\n`win32service.pyd`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.QueueHandler", "path": "library/logging.handlers#logging.handlers.QueueHandler", "type": "Logging", "text": "\nReturns a new instance of the `QueueHandler` class. The instance is\ninitialized with the queue to send messages to. The queue can be any queue-\nlike object; it\u2019s used as-is by the `enqueue()` method, which needs to know\nhow to send messages to it. The queue is not required to have the task\ntracking API, which means that you can use `SimpleQueue` instances for queue.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.QueueHandler.emit()", "path": "library/logging.handlers#logging.handlers.QueueHandler.emit", "type": "Logging", "text": "\nEnqueues the result of preparing the LogRecord. Should an exception occur\n(e.g. because a bounded queue has filled up), the `handleError()` method is\ncalled to handle the error. This can result in the record silently being\ndropped (if `logging.raiseExceptions` is `False`) or a message printed to\n`sys.stderr` (if `logging.raiseExceptions` is `True`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.QueueHandler.enqueue()", "path": "library/logging.handlers#logging.handlers.QueueHandler.enqueue", "type": "Logging", "text": "\nEnqueues the record on the queue using `put_nowait()`; you may want to\noverride this if you want to use blocking behaviour, or a timeout, or a\ncustomized queue implementation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.QueueHandler.prepare()", "path": "library/logging.handlers#logging.handlers.QueueHandler.prepare", "type": "Logging", "text": "\nPrepares a record for queuing. The object returned by this method is enqueued.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.QueueListener", "path": "library/logging.handlers#logging.handlers.QueueListener", "type": "Logging", "text": "\nReturns a new instance of the `QueueListener` class. The instance is\ninitialized with the queue to send messages to and a list of handlers which\nwill handle entries placed on the queue. The queue can be any queue-like\nobject; it\u2019s passed as-is to the `dequeue()` method, which needs to know how\nto get messages from it. The queue is not required to have the task tracking\nAPI (though it\u2019s used if available), which means that you can use\n`SimpleQueue` instances for queue.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.QueueListener.dequeue()", "path": "library/logging.handlers#logging.handlers.QueueListener.dequeue", "type": "Logging", "text": "\nDequeues a record and return it, optionally blocking.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.QueueListener.enqueue_sentinel()", "path": "library/logging.handlers#logging.handlers.QueueListener.enqueue_sentinel", "type": "Logging", "text": "\nWrites a sentinel to the queue to tell the listener to quit. This\nimplementation uses `put_nowait()`. You may want to override this method if\nyou want to use timeouts or work with custom queue implementations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.QueueListener.handle()", "path": "library/logging.handlers#logging.handlers.QueueListener.handle", "type": "Logging", "text": "\nHandle a record.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.QueueListener.prepare()", "path": "library/logging.handlers#logging.handlers.QueueListener.prepare", "type": "Logging", "text": "\nPrepare a record for handling.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.QueueListener.start()", "path": "library/logging.handlers#logging.handlers.QueueListener.start", "type": "Logging", "text": "\nStarts the listener.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.QueueListener.stop()", "path": "library/logging.handlers#logging.handlers.QueueListener.stop", "type": "Logging", "text": "\nStops the listener.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.RotatingFileHandler", "path": "library/logging.handlers#logging.handlers.RotatingFileHandler", "type": "Logging", "text": "\nReturns a new instance of the `RotatingFileHandler` class. The specified file\nis opened and used as the stream for logging. If mode is not specified, `'a'`\nis used. If encoding is not `None`, it is used to open the file with that\nencoding. If delay is true, then file opening is deferred until the first call\nto `emit()`. By default, the file grows indefinitely. If errors is provided,\nit determines how encoding errors are handled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.RotatingFileHandler.doRollover()", "path": "library/logging.handlers#logging.handlers.RotatingFileHandler.doRollover", "type": "Logging", "text": "\nDoes a rollover, as described above.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.RotatingFileHandler.emit()", "path": "library/logging.handlers#logging.handlers.RotatingFileHandler.emit", "type": "Logging", "text": "\nOutputs the record to the file, catering for rollover as described previously.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.SMTPHandler", "path": "library/logging.handlers#logging.handlers.SMTPHandler", "type": "Logging", "text": "\nReturns a new instance of the `SMTPHandler` class. The instance is initialized\nwith the from and to addresses and subject line of the email. The toaddrs\nshould be a list of strings. To specify a non-standard SMTP port, use the\n(host, port) tuple format for the mailhost argument. If you use a string, the\nstandard SMTP port is used. If your SMTP server requires authentication, you\ncan specify a (username, password) tuple for the credentials argument.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.SMTPHandler.emit()", "path": "library/logging.handlers#logging.handlers.SMTPHandler.emit", "type": "Logging", "text": "\nFormats the record and sends it to the specified addressees.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.SMTPHandler.getSubject()", "path": "library/logging.handlers#logging.handlers.SMTPHandler.getSubject", "type": "Logging", "text": "\nIf you want to specify a subject line which is record-dependent, override this\nmethod.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.SocketHandler", "path": "library/logging.handlers#logging.handlers.SocketHandler", "type": "Logging", "text": "\nReturns a new instance of the `SocketHandler` class intended to communicate\nwith a remote machine whose address is given by host and port.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.SocketHandler.close()", "path": "library/logging.handlers#logging.handlers.SocketHandler.close", "type": "Logging", "text": "\nCloses the socket.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.SocketHandler.createSocket()", "path": "library/logging.handlers#logging.handlers.SocketHandler.createSocket", "type": "Logging", "text": "\nTries to create a socket; on failure, uses an exponential back-off algorithm.\nOn initial failure, the handler will drop the message it was trying to send.\nWhen subsequent messages are handled by the same instance, it will not try\nconnecting until some time has passed. The default parameters are such that\nthe initial delay is one second, and if after that delay the connection still\ncan\u2019t be made, the handler will double the delay each time up to a maximum of\n30 seconds.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.SocketHandler.emit()", "path": "library/logging.handlers#logging.handlers.SocketHandler.emit", "type": "Logging", "text": "\nPickles the record\u2019s attribute dictionary and writes it to the socket in\nbinary format. If there is an error with the socket, silently drops the\npacket. If the connection was previously lost, re-establishes the connection.\nTo unpickle the record at the receiving end into a `LogRecord`, use the\n`makeLogRecord()` function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.SocketHandler.handleError()", "path": "library/logging.handlers#logging.handlers.SocketHandler.handleError", "type": "Logging", "text": "\nHandles an error which has occurred during `emit()`. The most likely cause is\na lost connection. Closes the socket so that we can retry on the next event.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.SocketHandler.makePickle()", "path": "library/logging.handlers#logging.handlers.SocketHandler.makePickle", "type": "Logging", "text": "\nPickles the record\u2019s attribute dictionary in binary format with a length\nprefix, and returns it ready for transmission across the socket. The details\nof this operation are equivalent to:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.SocketHandler.makeSocket()", "path": "library/logging.handlers#logging.handlers.SocketHandler.makeSocket", "type": "Logging", "text": "\nThis is a factory method which allows subclasses to define the precise type of\nsocket they want. The default implementation creates a TCP socket\n(`socket.SOCK_STREAM`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.SocketHandler.send()", "path": "library/logging.handlers#logging.handlers.SocketHandler.send", "type": "Logging", "text": "\nSend a pickled byte-string packet to the socket. The format of the sent byte-\nstring is as described in the documentation for `makePickle()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.SysLogHandler", "path": "library/logging.handlers#logging.handlers.SysLogHandler", "type": "Logging", "text": "\nReturns a new instance of the `SysLogHandler` class intended to communicate\nwith a remote Unix machine whose address is given by address in the form of a\n`(host, port)` tuple. If address is not specified, `('localhost', 514)` is\nused. The address is used to open a socket. An alternative to providing a\n`(host, port)` tuple is providing an address as a string, for example\n\u2018/dev/log\u2019. In this case, a Unix domain socket is used to send the message to\nthe syslog. If facility is not specified, `LOG_USER` is used. The type of\nsocket opened depends on the socktype argument, which defaults to\n`socket.SOCK_DGRAM` and thus opens a UDP socket. To open a TCP socket (for use\nwith the newer syslog daemons such as rsyslog), specify a value of\n`socket.SOCK_STREAM`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.SysLogHandler.close()", "path": "library/logging.handlers#logging.handlers.SysLogHandler.close", "type": "Logging", "text": "\nCloses the socket to the remote host.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.SysLogHandler.emit()", "path": "library/logging.handlers#logging.handlers.SysLogHandler.emit", "type": "Logging", "text": "\nThe record is formatted, and then sent to the syslog server. If exception\ninformation is present, it is not sent to the server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.SysLogHandler.encodePriority()", "path": "library/logging.handlers#logging.handlers.SysLogHandler.encodePriority", "type": "Logging", "text": "\nEncodes the facility and priority into an integer. You can pass in strings or\nintegers - if strings are passed, internal mapping dictionaries are used to\nconvert them to integers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.SysLogHandler.mapPriority()", "path": "library/logging.handlers#logging.handlers.SysLogHandler.mapPriority", "type": "Logging", "text": "\nMaps a logging level name to a syslog priority name. You may need to override\nthis if you are using custom levels, or if the default algorithm is not\nsuitable for your needs. The default algorithm maps `DEBUG`, `INFO`,\n`WARNING`, `ERROR` and `CRITICAL` to the equivalent syslog names, and all\nother level names to \u2018warning\u2019.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.TimedRotatingFileHandler", "path": "library/logging.handlers#logging.handlers.TimedRotatingFileHandler", "type": "Logging", "text": "\nReturns a new instance of the `TimedRotatingFileHandler` class. The specified\nfile is opened and used as the stream for logging. On rotating it also sets\nthe filename suffix. Rotating happens based on the product of when and\ninterval.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.TimedRotatingFileHandler.doRollover()", "path": "library/logging.handlers#logging.handlers.TimedRotatingFileHandler.doRollover", "type": "Logging", "text": "\nDoes a rollover, as described above.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.TimedRotatingFileHandler.emit()", "path": "library/logging.handlers#logging.handlers.TimedRotatingFileHandler.emit", "type": "Logging", "text": "\nOutputs the record to the file, catering for rollover as described above.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.WatchedFileHandler", "path": "library/logging.handlers#logging.handlers.WatchedFileHandler", "type": "Logging", "text": "\nReturns a new instance of the `WatchedFileHandler` class. The specified file\nis opened and used as the stream for logging. If mode is not specified, `'a'`\nis used. If encoding is not `None`, it is used to open the file with that\nencoding. If delay is true, then file opening is deferred until the first call\nto `emit()`. By default, the file grows indefinitely. If errors is provided,\nit determines how encoding errors are handled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.WatchedFileHandler.emit()", "path": "library/logging.handlers#logging.handlers.WatchedFileHandler.emit", "type": "Logging", "text": "\nOutputs the record to the file, but first calls `reopenIfNeeded()` to reopen\nthe file if it has changed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.handlers.WatchedFileHandler.reopenIfNeeded()", "path": "library/logging.handlers#logging.handlers.WatchedFileHandler.reopenIfNeeded", "type": "Logging", "text": "\nChecks to see if the file has changed. If it has, the existing stream is\nflushed and closed and the file opened again, typically as a precursor to\noutputting the record to the file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.info()", "path": "library/logging#logging.info", "type": "Logging", "text": "\nLogs a message with level `INFO` on the root logger. The arguments are\ninterpreted as for `debug()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.lastResort", "path": "library/logging#logging.lastResort", "type": "Logging", "text": "\nA \u201chandler of last resort\u201d is available through this attribute. This is a\n`StreamHandler` writing to `sys.stderr` with a level of `WARNING`, and is used\nto handle logging events in the absence of any logging configuration. The end\nresult is to just print the message to `sys.stderr`. This replaces the earlier\nerror message saying that \u201cno handlers could be found for logger XYZ\u201d. If you\nneed the earlier behaviour for some reason, `lastResort` can be set to `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.log()", "path": "library/logging#logging.log", "type": "Logging", "text": "\nLogs a message with level level on the root logger. The other arguments are\ninterpreted as for `debug()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Logger", "path": "library/logging#logging.Logger", "type": "Logging", "text": "\nIf this attribute evaluates to true, events logged to this logger will be\npassed to the handlers of higher level (ancestor) loggers, in addition to any\nhandlers attached to this logger. Messages are passed directly to the ancestor\nloggers\u2019 handlers - neither the level nor filters of the ancestor loggers in\nquestion are considered.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Logger.addFilter()", "path": "library/logging#logging.Logger.addFilter", "type": "Logging", "text": "\nAdds the specified filter filter to this logger.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Logger.addHandler()", "path": "library/logging#logging.Logger.addHandler", "type": "Logging", "text": "\nAdds the specified handler hdlr to this logger.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Logger.critical()", "path": "library/logging#logging.Logger.critical", "type": "Logging", "text": "\nLogs a message with level `CRITICAL` on this logger. The arguments are\ninterpreted as for `debug()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Logger.debug()", "path": "library/logging#logging.Logger.debug", "type": "Logging", "text": "\nLogs a message with level `DEBUG` on this logger. The msg is the message\nformat string, and the args are the arguments which are merged into msg using\nthe string formatting operator. (Note that this means that you can use\nkeywords in the format string, together with a single dictionary argument.) No\n% formatting operation is performed on msg when no args are supplied.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Logger.error()", "path": "library/logging#logging.Logger.error", "type": "Logging", "text": "\nLogs a message with level `ERROR` on this logger. The arguments are\ninterpreted as for `debug()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Logger.exception()", "path": "library/logging#logging.Logger.exception", "type": "Logging", "text": "\nLogs a message with level `ERROR` on this logger. The arguments are\ninterpreted as for `debug()`. Exception info is added to the logging message.\nThis method should only be called from an exception handler.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Logger.filter()", "path": "library/logging#logging.Logger.filter", "type": "Logging", "text": "\nApply this logger\u2019s filters to the record and return `True` if the record is\nto be processed. The filters are consulted in turn, until one of them returns\na false value. If none of them return a false value, the record will be\nprocessed (passed to handlers). If one returns a false value, no further\nprocessing of the record occurs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Logger.findCaller()", "path": "library/logging#logging.Logger.findCaller", "type": "Logging", "text": "\nFinds the caller\u2019s source filename and line number. Returns the filename, line\nnumber, function name and stack information as a 4-element tuple. The stack\ninformation is returned as `None` unless stack_info is `True`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Logger.getChild()", "path": "library/logging#logging.Logger.getChild", "type": "Logging", "text": "\nReturns a logger which is a descendant to this logger, as determined by the\nsuffix. Thus, `logging.getLogger('abc').getChild('def.ghi')` would return the\nsame logger as would be returned by `logging.getLogger('abc.def.ghi')`. This\nis a convenience method, useful when the parent logger is named using e.g.\n`__name__` rather than a literal string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Logger.getEffectiveLevel()", "path": "library/logging#logging.Logger.getEffectiveLevel", "type": "Logging", "text": "\nIndicates the effective level for this logger. If a value other than `NOTSET`\nhas been set using `setLevel()`, it is returned. Otherwise, the hierarchy is\ntraversed towards the root until a value other than `NOTSET` is found, and\nthat value is returned. The value returned is an integer, typically one of\n`logging.DEBUG`, `logging.INFO` etc.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Logger.handle()", "path": "library/logging#logging.Logger.handle", "type": "Logging", "text": "\nHandles a record by passing it to all handlers associated with this logger and\nits ancestors (until a false value of propagate is found). This method is used\nfor unpickled records received from a socket, as well as those created\nlocally. Logger-level filtering is applied using `filter()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Logger.hasHandlers()", "path": "library/logging#logging.Logger.hasHandlers", "type": "Logging", "text": "\nChecks to see if this logger has any handlers configured. This is done by\nlooking for handlers in this logger and its parents in the logger hierarchy.\nReturns `True` if a handler was found, else `False`. The method stops\nsearching up the hierarchy whenever a logger with the \u2018propagate\u2019 attribute\nset to false is found - that will be the last logger which is checked for the\nexistence of handlers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Logger.info()", "path": "library/logging#logging.Logger.info", "type": "Logging", "text": "\nLogs a message with level `INFO` on this logger. The arguments are interpreted\nas for `debug()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Logger.isEnabledFor()", "path": "library/logging#logging.Logger.isEnabledFor", "type": "Logging", "text": "\nIndicates if a message of severity level would be processed by this logger.\nThis method checks first the module-level level set by\n`logging.disable(level)` and then the logger\u2019s effective level as determined\nby `getEffectiveLevel()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Logger.log()", "path": "library/logging#logging.Logger.log", "type": "Logging", "text": "\nLogs a message with integer level level on this logger. The other arguments\nare interpreted as for `debug()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Logger.makeRecord()", "path": "library/logging#logging.Logger.makeRecord", "type": "Logging", "text": "\nThis is a factory method which can be overridden in subclasses to create\nspecialized `LogRecord` instances.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Logger.propagate", "path": "library/logging#logging.Logger.propagate", "type": "Logging", "text": "\nIf this attribute evaluates to true, events logged to this logger will be\npassed to the handlers of higher level (ancestor) loggers, in addition to any\nhandlers attached to this logger. Messages are passed directly to the ancestor\nloggers\u2019 handlers - neither the level nor filters of the ancestor loggers in\nquestion are considered.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Logger.removeFilter()", "path": "library/logging#logging.Logger.removeFilter", "type": "Logging", "text": "\nRemoves the specified filter filter from this logger.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Logger.removeHandler()", "path": "library/logging#logging.Logger.removeHandler", "type": "Logging", "text": "\nRemoves the specified handler hdlr from this logger.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Logger.setLevel()", "path": "library/logging#logging.Logger.setLevel", "type": "Logging", "text": "\nSets the threshold for this logger to level. Logging messages which are less\nsevere than level will be ignored; logging messages which have severity level\nor higher will be emitted by whichever handler or handlers service this\nlogger, unless a handler\u2019s level has been set to a higher severity level than\nlevel.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.Logger.warning()", "path": "library/logging#logging.Logger.warning", "type": "Logging", "text": "\nLogs a message with level `WARNING` on this logger. The arguments are\ninterpreted as for `debug()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.LoggerAdapter", "path": "library/logging#logging.LoggerAdapter", "type": "Logging", "text": "\nReturns an instance of `LoggerAdapter` initialized with an underlying `Logger`\ninstance and a dict-like object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.LoggerAdapter.process()", "path": "library/logging#logging.LoggerAdapter.process", "type": "Logging", "text": "\nModifies the message and/or keyword arguments passed to a logging call in\norder to insert contextual information. This implementation takes the object\npassed as extra to the constructor and adds it to kwargs using key \u2018extra\u2019.\nThe return value is a (msg, kwargs) tuple which has the (possibly modified)\nversions of the arguments passed in.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.LogRecord", "path": "library/logging#logging.LogRecord", "type": "Logging", "text": "\nContains all the information pertinent to the event being logged.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.LogRecord.getMessage()", "path": "library/logging#logging.LogRecord.getMessage", "type": "Logging", "text": "\nReturns the message for this `LogRecord` instance after merging any user-\nsupplied arguments with the message. If the user-supplied message argument to\nthe logging call is not a string, `str()` is called on it to convert it to a\nstring. This allows use of user-defined classes as messages, whose `__str__`\nmethod can return the actual format string to be used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.makeLogRecord()", "path": "library/logging#logging.makeLogRecord", "type": "Logging", "text": "\nCreates and returns a new `LogRecord` instance whose attributes are defined by\nattrdict. This function is useful for taking a pickled `LogRecord` attribute\ndictionary, sent over a socket, and reconstituting it as a `LogRecord`\ninstance at the receiving end.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.NullHandler", "path": "library/logging.handlers#logging.NullHandler", "type": "Logging", "text": "\nReturns a new instance of the `NullHandler` class.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.NullHandler.createLock()", "path": "library/logging.handlers#logging.NullHandler.createLock", "type": "Logging", "text": "\nThis method returns `None` for the lock, since there is no underlying I/O to\nwhich access needs to be serialized.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.NullHandler.emit()", "path": "library/logging.handlers#logging.NullHandler.emit", "type": "Logging", "text": "\nThis method does nothing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.NullHandler.handle()", "path": "library/logging.handlers#logging.NullHandler.handle", "type": "Logging", "text": "\nThis method does nothing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.setLoggerClass()", "path": "library/logging#logging.setLoggerClass", "type": "Logging", "text": "\nTells the logging system to use the class klass when instantiating a logger.\nThe class should define `__init__()` such that only a name argument is\nrequired, and the `__init__()` should call `Logger.__init__()`. This function\nis typically called before any loggers are instantiated by applications which\nneed to use custom logger behavior. After this call, as at any other time, do\nnot instantiate loggers directly using the subclass: continue to use the\n`logging.getLogger()` API to get your loggers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.setLogRecordFactory()", "path": "library/logging#logging.setLogRecordFactory", "type": "Logging", "text": "\nSet a callable which is used to create a `LogRecord`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.shutdown()", "path": "library/logging#logging.shutdown", "type": "Logging", "text": "\nInforms the logging system to perform an orderly shutdown by flushing and\nclosing all handlers. This should be called at application exit and no further\nuse of the logging system should be made after this call.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.StreamHandler", "path": "library/logging.handlers#logging.StreamHandler", "type": "Logging", "text": "\nReturns a new instance of the `StreamHandler` class. If stream is specified,\nthe instance will use it for logging output; otherwise, sys.stderr will be\nused.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.StreamHandler.emit()", "path": "library/logging.handlers#logging.StreamHandler.emit", "type": "Logging", "text": "\nIf a formatter is specified, it is used to format the record. The record is\nthen written to the stream followed by `terminator`. If exception information\nis present, it is formatted using `traceback.print_exception()` and appended\nto the stream.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.StreamHandler.flush()", "path": "library/logging.handlers#logging.StreamHandler.flush", "type": "Logging", "text": "\nFlushes the stream by calling its `flush()` method. Note that the `close()`\nmethod is inherited from `Handler` and so does no output, so an explicit\n`flush()` call may be needed at times.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.StreamHandler.setStream()", "path": "library/logging.handlers#logging.StreamHandler.setStream", "type": "Logging", "text": "\nSets the instance\u2019s stream to the specified value, if it is different. The old\nstream is flushed before the new stream is set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.StreamHandler.terminator", "path": "library/logging.handlers#logging.StreamHandler.terminator", "type": "Logging", "text": "\nString used as the terminator when writing a formatted record to a stream.\nDefault value is `'\\n'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "logging.warning()", "path": "library/logging#logging.warning", "type": "Logging", "text": "\nLogs a message with level `WARNING` on the root logger. The arguments are\ninterpreted as for `debug()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "LookupError", "path": "library/exceptions#LookupError", "type": "Built-in Exceptions", "text": "\nThe base class for the exceptions that are raised when a key or index used on\na mapping or sequence is invalid: `IndexError`, `KeyError`. This can be raised\ndirectly by `codecs.lookup()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Low-level API Index", "path": "library/asyncio-llapi-index", "type": "Asynchronous I/O", "text": "\nThis page lists all low-level asyncio APIs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "lzma", "path": "library/lzma", "type": "Data Compression", "text": "\nNew in version 3.3.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "lzma.compress()", "path": "library/lzma#lzma.compress", "type": "Data Compression", "text": "\nCompress data (a `bytes` object), returning the compressed data as a `bytes`\nobject.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "lzma.decompress()", "path": "library/lzma#lzma.decompress", "type": "Data Compression", "text": "\nDecompress data (a `bytes` object), returning the uncompressed data as a\n`bytes` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "lzma.is_check_supported()", "path": "library/lzma#lzma.is_check_supported", "type": "Data Compression", "text": "\nReturn `True` if the given integrity check is supported on this system.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "lzma.LZMACompressor", "path": "library/lzma#lzma.LZMACompressor", "type": "Data Compression", "text": "\nCreate a compressor object, which can be used to compress data incrementally.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "lzma.LZMACompressor.compress()", "path": "library/lzma#lzma.LZMACompressor.compress", "type": "Data Compression", "text": "\nCompress data (a `bytes` object), returning a `bytes` object containing\ncompressed data for at least part of the input. Some of data may be buffered\ninternally, for use in later calls to `compress()` and `flush()`. The returned\ndata should be concatenated with the output of any previous calls to\n`compress()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "lzma.LZMACompressor.flush()", "path": "library/lzma#lzma.LZMACompressor.flush", "type": "Data Compression", "text": "\nFinish the compression process, returning a `bytes` object containing any data\nstored in the compressor\u2019s internal buffers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "lzma.LZMADecompressor", "path": "library/lzma#lzma.LZMADecompressor", "type": "Data Compression", "text": "\nCreate a decompressor object, which can be used to decompress data\nincrementally.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "lzma.LZMADecompressor.check", "path": "library/lzma#lzma.LZMADecompressor.check", "type": "Data Compression", "text": "\nThe ID of the integrity check used by the input stream. This may be\n`CHECK_UNKNOWN` until enough of the input has been decoded to determine what\nintegrity check it uses.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "lzma.LZMADecompressor.decompress()", "path": "library/lzma#lzma.LZMADecompressor.decompress", "type": "Data Compression", "text": "\nDecompress data (a bytes-like object), returning uncompressed data as bytes.\nSome of data may be buffered internally, for use in later calls to\n`decompress()`. The returned data should be concatenated with the output of\nany previous calls to `decompress()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "lzma.LZMADecompressor.eof", "path": "library/lzma#lzma.LZMADecompressor.eof", "type": "Data Compression", "text": "\n`True` if the end-of-stream marker has been reached.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "lzma.LZMADecompressor.needs_input", "path": "library/lzma#lzma.LZMADecompressor.needs_input", "type": "Data Compression", "text": "\n`False` if the `decompress()` method can provide more decompressed data before\nrequiring new uncompressed input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "lzma.LZMADecompressor.unused_data", "path": "library/lzma#lzma.LZMADecompressor.unused_data", "type": "Data Compression", "text": "\nData found after the end of the compressed stream.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "lzma.LZMAError", "path": "library/lzma#lzma.LZMAError", "type": "Data Compression", "text": "\nThis exception is raised when an error occurs during compression or\ndecompression, or while initializing the compressor/decompressor state.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "lzma.LZMAFile", "path": "library/lzma#lzma.LZMAFile", "type": "Data Compression", "text": "\nOpen an LZMA-compressed file in binary mode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "lzma.LZMAFile.peek()", "path": "library/lzma#lzma.LZMAFile.peek", "type": "Data Compression", "text": "\nReturn buffered data without advancing the file position. At least one byte of\ndata will be returned, unless EOF has been reached. The exact number of bytes\nreturned is unspecified (the size argument is ignored).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "lzma.open()", "path": "library/lzma#lzma.open", "type": "Data Compression", "text": "\nOpen an LZMA-compressed file in binary or text mode, returning a file object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox", "path": "library/mailbox", "type": "Internet Data", "text": "\nSource code: Lib/mailbox.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Babyl", "path": "library/mailbox#mailbox.Babyl", "type": "Internet Data", "text": "\nA subclass of `Mailbox` for mailboxes in Babyl format. Parameter factory is a\ncallable object that accepts a file-like message representation (which behaves\nas if opened in binary mode) and returns a custom representation. If factory\nis `None`, `BabylMessage` is used as the default message representation. If\ncreate is `True`, the mailbox is created if it does not exist.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Babyl.get_file()", "path": "library/mailbox#mailbox.Babyl.get_file", "type": "Internet Data", "text": "\nIn Babyl mailboxes, the headers of a message are not stored contiguously with\nthe body of the message. To generate a file-like representation, the headers\nand body are copied together into an `io.BytesIO` instance, which has an API\nidentical to that of a file. As a result, the file-like object is truly\nindependent of the underlying mailbox but does not save memory compared to a\nstring representation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Babyl.get_labels()", "path": "library/mailbox#mailbox.Babyl.get_labels", "type": "Internet Data", "text": "\nReturn a list of the names of all user-defined labels used in the mailbox.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Babyl.lock()", "path": "library/mailbox#mailbox.Babyl.lock", "type": "Internet Data", "text": "\nThree locking mechanisms are used\u2014dot locking and, if available, the `flock()`\nand `lockf()` system calls.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Babyl.unlock()", "path": "library/mailbox#mailbox.Babyl.unlock", "type": "Internet Data", "text": "\nThree locking mechanisms are used\u2014dot locking and, if available, the `flock()`\nand `lockf()` system calls.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.BabylMessage", "path": "library/mailbox#mailbox.BabylMessage", "type": "Internet Data", "text": "\nA message with Babyl-specific behaviors. Parameter message has the same\nmeaning as with the `Message` constructor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.BabylMessage.add_label()", "path": "library/mailbox#mailbox.BabylMessage.add_label", "type": "Internet Data", "text": "\nAdd label to the list of labels on the message.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.BabylMessage.get_labels()", "path": "library/mailbox#mailbox.BabylMessage.get_labels", "type": "Internet Data", "text": "\nReturn a list of labels on the message.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.BabylMessage.get_visible()", "path": "library/mailbox#mailbox.BabylMessage.get_visible", "type": "Internet Data", "text": "\nReturn an `Message` instance whose headers are the message\u2019s visible headers\nand whose body is empty.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.BabylMessage.remove_label()", "path": "library/mailbox#mailbox.BabylMessage.remove_label", "type": "Internet Data", "text": "\nRemove label from the list of labels on the message.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.BabylMessage.set_labels()", "path": "library/mailbox#mailbox.BabylMessage.set_labels", "type": "Internet Data", "text": "\nSet the list of labels on the message to labels.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.BabylMessage.set_visible()", "path": "library/mailbox#mailbox.BabylMessage.set_visible", "type": "Internet Data", "text": "\nSet the message\u2019s visible headers to be the same as the headers in message.\nParameter visible should be a `Message` instance, an `email.message.Message`\ninstance, a string, or a file-like object (which should be open in text mode).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.BabylMessage.update_visible()", "path": "library/mailbox#mailbox.BabylMessage.update_visible", "type": "Internet Data", "text": "\nWhen a `BabylMessage` instance\u2019s original headers are modified, the visible\nheaders are not automatically modified to correspond. This method updates the\nvisible headers as follows: each visible header with a corresponding original\nheader is set to the value of the original header, each visible header without\na corresponding original header is removed, and any of Date, From, Reply-To,\nTo, CC, and Subject that are present in the original headers but not the\nvisible headers are added to the visible headers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Error", "path": "library/mailbox#mailbox.Error", "type": "Internet Data", "text": "\nThe based class for all other module-specific exceptions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.ExternalClashError", "path": "library/mailbox#mailbox.ExternalClashError", "type": "Internet Data", "text": "\nRaised when some mailbox-related condition beyond the control of the program\ncauses it to be unable to proceed, such as when failing to acquire a lock that\nanother program already holds a lock, or when a uniquely-generated file name\nalready exists.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.FormatError", "path": "library/mailbox#mailbox.FormatError", "type": "Internet Data", "text": "\nRaised when the data in a file cannot be parsed, such as when an `MH` instance\nattempts to read a corrupted `.mh_sequences` file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Mailbox", "path": "library/mailbox#mailbox.Mailbox", "type": "Internet Data", "text": "\nA mailbox, which may be inspected and modified.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Mailbox.add()", "path": "library/mailbox#mailbox.Mailbox.add", "type": "Internet Data", "text": "\nAdd message to the mailbox and return the key that has been assigned to it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Mailbox.clear()", "path": "library/mailbox#mailbox.Mailbox.clear", "type": "Internet Data", "text": "\nDelete all messages from the mailbox.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Mailbox.close()", "path": "library/mailbox#mailbox.Mailbox.close", "type": "Internet Data", "text": "\nFlush the mailbox, unlock it if necessary, and close any open files. For some\n`Mailbox` subclasses, this method does nothing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Mailbox.discard()", "path": "library/mailbox#mailbox.Mailbox.discard", "type": "Internet Data", "text": "\nDelete the message corresponding to key from the mailbox.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Mailbox.flush()", "path": "library/mailbox#mailbox.Mailbox.flush", "type": "Internet Data", "text": "\nWrite any pending changes to the filesystem. For some `Mailbox` subclasses,\nchanges are always written immediately and `flush()` does nothing, but you\nshould still make a habit of calling this method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Mailbox.get()", "path": "library/mailbox#mailbox.Mailbox.get", "type": "Internet Data", "text": "\nReturn a representation of the message corresponding to key. If no such\nmessage exists, default is returned if the method was called as `get()` and a\n`KeyError` exception is raised if the method was called as `__getitem__()`.\nThe message is represented as an instance of the appropriate format-specific\n`Message` subclass unless a custom message factory was specified when the\n`Mailbox` instance was initialized.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Mailbox.get_bytes()", "path": "library/mailbox#mailbox.Mailbox.get_bytes", "type": "Internet Data", "text": "\nReturn a byte representation of the message corresponding to key, or raise a\n`KeyError` exception if no such message exists.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Mailbox.get_file()", "path": "library/mailbox#mailbox.Mailbox.get_file", "type": "Internet Data", "text": "\nReturn a file-like representation of the message corresponding to key, or\nraise a `KeyError` exception if no such message exists. The file-like object\nbehaves as if open in binary mode. This file should be closed once it is no\nlonger needed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Mailbox.get_message()", "path": "library/mailbox#mailbox.Mailbox.get_message", "type": "Internet Data", "text": "\nReturn a representation of the message corresponding to key as an instance of\nthe appropriate format-specific `Message` subclass, or raise a `KeyError`\nexception if no such message exists.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Mailbox.get_string()", "path": "library/mailbox#mailbox.Mailbox.get_string", "type": "Internet Data", "text": "\nReturn a string representation of the message corresponding to key, or raise a\n`KeyError` exception if no such message exists. The message is processed\nthrough `email.message.Message` to convert it to a 7bit clean representation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Mailbox.items()", "path": "library/mailbox#mailbox.Mailbox.items", "type": "Internet Data", "text": "\nReturn an iterator over (key, message) pairs, where key is a key and message\nis a message representation, if called as `iteritems()` or return a list of\nsuch pairs if called as `items()`. The messages are represented as instances\nof the appropriate format-specific `Message` subclass unless a custom message\nfactory was specified when the `Mailbox` instance was initialized.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Mailbox.iteritems()", "path": "library/mailbox#mailbox.Mailbox.iteritems", "type": "Internet Data", "text": "\nReturn an iterator over (key, message) pairs, where key is a key and message\nis a message representation, if called as `iteritems()` or return a list of\nsuch pairs if called as `items()`. The messages are represented as instances\nof the appropriate format-specific `Message` subclass unless a custom message\nfactory was specified when the `Mailbox` instance was initialized.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Mailbox.iterkeys()", "path": "library/mailbox#mailbox.Mailbox.iterkeys", "type": "Internet Data", "text": "\nReturn an iterator over all keys if called as `iterkeys()` or return a list of\nkeys if called as `keys()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Mailbox.itervalues()", "path": "library/mailbox#mailbox.Mailbox.itervalues", "type": "Internet Data", "text": "\nReturn an iterator over representations of all messages if called as\n`itervalues()` or `__iter__()` or return a list of such representations if\ncalled as `values()`. The messages are represented as instances of the\nappropriate format-specific `Message` subclass unless a custom message factory\nwas specified when the `Mailbox` instance was initialized.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Mailbox.keys()", "path": "library/mailbox#mailbox.Mailbox.keys", "type": "Internet Data", "text": "\nReturn an iterator over all keys if called as `iterkeys()` or return a list of\nkeys if called as `keys()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Mailbox.lock()", "path": "library/mailbox#mailbox.Mailbox.lock", "type": "Internet Data", "text": "\nAcquire an exclusive advisory lock on the mailbox so that other processes know\nnot to modify it. An `ExternalClashError` is raised if the lock is not\navailable. The particular locking mechanisms used depend upon the mailbox\nformat. You should always lock the mailbox before making any modifications to\nits contents.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Mailbox.pop()", "path": "library/mailbox#mailbox.Mailbox.pop", "type": "Internet Data", "text": "\nReturn a representation of the message corresponding to key and delete the\nmessage. If no such message exists, return default. The message is represented\nas an instance of the appropriate format-specific `Message` subclass unless a\ncustom message factory was specified when the `Mailbox` instance was\ninitialized.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Mailbox.popitem()", "path": "library/mailbox#mailbox.Mailbox.popitem", "type": "Internet Data", "text": "\nReturn an arbitrary (key, message) pair, where key is a key and message is a\nmessage representation, and delete the corresponding message. If the mailbox\nis empty, raise a `KeyError` exception. The message is represented as an\ninstance of the appropriate format-specific `Message` subclass unless a custom\nmessage factory was specified when the `Mailbox` instance was initialized.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Mailbox.remove()", "path": "library/mailbox#mailbox.Mailbox.remove", "type": "Internet Data", "text": "\nDelete the message corresponding to key from the mailbox.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Mailbox.unlock()", "path": "library/mailbox#mailbox.Mailbox.unlock", "type": "Internet Data", "text": "\nRelease the lock on the mailbox, if any.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Mailbox.update()", "path": "library/mailbox#mailbox.Mailbox.update", "type": "Internet Data", "text": "\nParameter arg should be a key-to-message mapping or an iterable of (key,\nmessage) pairs. Updates the mailbox so that, for each given key and message,\nthe message corresponding to key is set to message as if by using\n`__setitem__()`. As with `__setitem__()`, each key must already correspond to\na message in the mailbox or else a `KeyError` exception will be raised, so in\ngeneral it is incorrect for arg to be a `Mailbox` instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Mailbox.values()", "path": "library/mailbox#mailbox.Mailbox.values", "type": "Internet Data", "text": "\nReturn an iterator over representations of all messages if called as\n`itervalues()` or `__iter__()` or return a list of such representations if\ncalled as `values()`. The messages are represented as instances of the\nappropriate format-specific `Message` subclass unless a custom message factory\nwas specified when the `Mailbox` instance was initialized.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Mailbox.__contains__()", "path": "library/mailbox#mailbox.Mailbox.__contains__", "type": "Internet Data", "text": "\nReturn `True` if key corresponds to a message, `False` otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Mailbox.__delitem__()", "path": "library/mailbox#mailbox.Mailbox.__delitem__", "type": "Internet Data", "text": "\nDelete the message corresponding to key from the mailbox.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Mailbox.__getitem__()", "path": "library/mailbox#mailbox.Mailbox.__getitem__", "type": "Internet Data", "text": "\nReturn a representation of the message corresponding to key. If no such\nmessage exists, default is returned if the method was called as `get()` and a\n`KeyError` exception is raised if the method was called as `__getitem__()`.\nThe message is represented as an instance of the appropriate format-specific\n`Message` subclass unless a custom message factory was specified when the\n`Mailbox` instance was initialized.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Mailbox.__iter__()", "path": "library/mailbox#mailbox.Mailbox.__iter__", "type": "Internet Data", "text": "\nReturn an iterator over representations of all messages if called as\n`itervalues()` or `__iter__()` or return a list of such representations if\ncalled as `values()`. The messages are represented as instances of the\nappropriate format-specific `Message` subclass unless a custom message factory\nwas specified when the `Mailbox` instance was initialized.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Mailbox.__len__()", "path": "library/mailbox#mailbox.Mailbox.__len__", "type": "Internet Data", "text": "\nReturn a count of messages in the mailbox.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Mailbox.__setitem__()", "path": "library/mailbox#mailbox.Mailbox.__setitem__", "type": "Internet Data", "text": "\nReplace the message corresponding to key with message. Raise a `KeyError`\nexception if no message already corresponds to key.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Maildir", "path": "library/mailbox#mailbox.Maildir", "type": "Internet Data", "text": "\nA subclass of `Mailbox` for mailboxes in Maildir format. Parameter factory is\na callable object that accepts a file-like message representation (which\nbehaves as if opened in binary mode) and returns a custom representation. If\nfactory is `None`, `MaildirMessage` is used as the default message\nrepresentation. If create is `True`, the mailbox is created if it does not\nexist.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Maildir.add()", "path": "library/mailbox#mailbox.Maildir.add", "type": "Internet Data", "text": "\nWarning\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Maildir.add_folder()", "path": "library/mailbox#mailbox.Maildir.add_folder", "type": "Internet Data", "text": "\nCreate a folder whose name is folder and return a `Maildir` instance\nrepresenting it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Maildir.clean()", "path": "library/mailbox#mailbox.Maildir.clean", "type": "Internet Data", "text": "\nDelete temporary files from the mailbox that have not been accessed in the\nlast 36 hours. The Maildir specification says that mail-reading programs\nshould do this occasionally.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Maildir.close()", "path": "library/mailbox#mailbox.Maildir.close", "type": "Internet Data", "text": "\n`Maildir` instances do not keep any open files and the underlying mailboxes do\nnot support locking, so this method does nothing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Maildir.flush()", "path": "library/mailbox#mailbox.Maildir.flush", "type": "Internet Data", "text": "\nAll changes to Maildir mailboxes are immediately applied, so this method does\nnothing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Maildir.get_file()", "path": "library/mailbox#mailbox.Maildir.get_file", "type": "Internet Data", "text": "\nDepending upon the host platform, it may not be possible to modify or remove\nthe underlying message while the returned file remains open.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Maildir.get_folder()", "path": "library/mailbox#mailbox.Maildir.get_folder", "type": "Internet Data", "text": "\nReturn a `Maildir` instance representing the folder whose name is folder. A\n`NoSuchMailboxError` exception is raised if the folder does not exist.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Maildir.list_folders()", "path": "library/mailbox#mailbox.Maildir.list_folders", "type": "Internet Data", "text": "\nReturn a list of the names of all folders.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Maildir.lock()", "path": "library/mailbox#mailbox.Maildir.lock", "type": "Internet Data", "text": "\nMaildir mailboxes do not support (or require) locking, so these methods do\nnothing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Maildir.remove_folder()", "path": "library/mailbox#mailbox.Maildir.remove_folder", "type": "Internet Data", "text": "\nDelete the folder whose name is folder. If the folder contains any messages, a\n`NotEmptyError` exception will be raised and the folder will not be deleted.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Maildir.unlock()", "path": "library/mailbox#mailbox.Maildir.unlock", "type": "Internet Data", "text": "\nMaildir mailboxes do not support (or require) locking, so these methods do\nnothing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Maildir.update()", "path": "library/mailbox#mailbox.Maildir.update", "type": "Internet Data", "text": "\nWarning\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Maildir.__setitem__()", "path": "library/mailbox#mailbox.Maildir.__setitem__", "type": "Internet Data", "text": "\nWarning\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.MaildirMessage", "path": "library/mailbox#mailbox.MaildirMessage", "type": "Internet Data", "text": "\nA message with Maildir-specific behaviors. Parameter message has the same\nmeaning as with the `Message` constructor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.MaildirMessage.add_flag()", "path": "library/mailbox#mailbox.MaildirMessage.add_flag", "type": "Internet Data", "text": "\nSet the flag(s) specified by flag without changing other flags. To add more\nthan one flag at a time, flag may be a string of more than one character. The\ncurrent \u201cinfo\u201d is overwritten whether or not it contains experimental\ninformation rather than flags.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.MaildirMessage.get_date()", "path": "library/mailbox#mailbox.MaildirMessage.get_date", "type": "Internet Data", "text": "\nReturn the delivery date of the message as a floating-point number\nrepresenting seconds since the epoch.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.MaildirMessage.get_flags()", "path": "library/mailbox#mailbox.MaildirMessage.get_flags", "type": "Internet Data", "text": "\nReturn a string specifying the flags that are currently set. If the message\ncomplies with the standard Maildir format, the result is the concatenation in\nalphabetical order of zero or one occurrence of each of `'D'`, `'F'`, `'P'`,\n`'R'`, `'S'`, and `'T'`. The empty string is returned if no flags are set or\nif \u201cinfo\u201d contains experimental semantics.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.MaildirMessage.get_info()", "path": "library/mailbox#mailbox.MaildirMessage.get_info", "type": "Internet Data", "text": "\nReturn a string containing the \u201cinfo\u201d for a message. This is useful for\naccessing and modifying \u201cinfo\u201d that is experimental (i.e., not a list of\nflags).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.MaildirMessage.get_subdir()", "path": "library/mailbox#mailbox.MaildirMessage.get_subdir", "type": "Internet Data", "text": "\nReturn either \u201cnew\u201d (if the message should be stored in the `new`\nsubdirectory) or \u201ccur\u201d (if the message should be stored in the `cur`\nsubdirectory).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.MaildirMessage.remove_flag()", "path": "library/mailbox#mailbox.MaildirMessage.remove_flag", "type": "Internet Data", "text": "\nUnset the flag(s) specified by flag without changing other flags. To remove\nmore than one flag at a time, flag maybe a string of more than one character.\nIf \u201cinfo\u201d contains experimental information rather than flags, the current\n\u201cinfo\u201d is not modified.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.MaildirMessage.set_date()", "path": "library/mailbox#mailbox.MaildirMessage.set_date", "type": "Internet Data", "text": "\nSet the delivery date of the message to date, a floating-point number\nrepresenting seconds since the epoch.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.MaildirMessage.set_flags()", "path": "library/mailbox#mailbox.MaildirMessage.set_flags", "type": "Internet Data", "text": "\nSet the flags specified by flags and unset all others.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.MaildirMessage.set_info()", "path": "library/mailbox#mailbox.MaildirMessage.set_info", "type": "Internet Data", "text": "\nSet \u201cinfo\u201d to info, which should be a string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.MaildirMessage.set_subdir()", "path": "library/mailbox#mailbox.MaildirMessage.set_subdir", "type": "Internet Data", "text": "\nSet the subdirectory the message should be stored in. Parameter subdir must be\neither \u201cnew\u201d or \u201ccur\u201d.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.mbox", "path": "library/mailbox#mailbox.mbox", "type": "Internet Data", "text": "\nA subclass of `Mailbox` for mailboxes in mbox format. Parameter factory is a\ncallable object that accepts a file-like message representation (which behaves\nas if opened in binary mode) and returns a custom representation. If factory\nis `None`, `mboxMessage` is used as the default message representation. If\ncreate is `True`, the mailbox is created if it does not exist.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.mbox.get_file()", "path": "library/mailbox#mailbox.mbox.get_file", "type": "Internet Data", "text": "\nUsing the file after calling `flush()` or `close()` on the `mbox` instance may\nyield unpredictable results or raise an exception.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.mbox.lock()", "path": "library/mailbox#mailbox.mbox.lock", "type": "Internet Data", "text": "\nThree locking mechanisms are used\u2014dot locking and, if available, the `flock()`\nand `lockf()` system calls.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.mbox.unlock()", "path": "library/mailbox#mailbox.mbox.unlock", "type": "Internet Data", "text": "\nThree locking mechanisms are used\u2014dot locking and, if available, the `flock()`\nand `lockf()` system calls.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.mboxMessage", "path": "library/mailbox#mailbox.mboxMessage", "type": "Internet Data", "text": "\nA message with mbox-specific behaviors. Parameter message has the same meaning\nas with the `Message` constructor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.mboxMessage.add_flag()", "path": "library/mailbox#mailbox.mboxMessage.add_flag", "type": "Internet Data", "text": "\nSet the flag(s) specified by flag without changing other flags. To add more\nthan one flag at a time, flag may be a string of more than one character.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.mboxMessage.get_flags()", "path": "library/mailbox#mailbox.mboxMessage.get_flags", "type": "Internet Data", "text": "\nReturn a string specifying the flags that are currently set. If the message\ncomplies with the conventional format, the result is the concatenation in the\nfollowing order of zero or one occurrence of each of `'R'`, `'O'`, `'D'`,\n`'F'`, and `'A'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.mboxMessage.get_from()", "path": "library/mailbox#mailbox.mboxMessage.get_from", "type": "Internet Data", "text": "\nReturn a string representing the \u201cFrom \u201d line that marks the start of the\nmessage in an mbox mailbox. The leading \u201cFrom \u201d and the trailing newline are\nexcluded.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.mboxMessage.remove_flag()", "path": "library/mailbox#mailbox.mboxMessage.remove_flag", "type": "Internet Data", "text": "\nUnset the flag(s) specified by flag without changing other flags. To remove\nmore than one flag at a time, flag maybe a string of more than one character.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.mboxMessage.set_flags()", "path": "library/mailbox#mailbox.mboxMessage.set_flags", "type": "Internet Data", "text": "\nSet the flags specified by flags and unset all others. Parameter flags should\nbe the concatenation in any order of zero or more occurrences of each of\n`'R'`, `'O'`, `'D'`, `'F'`, and `'A'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.mboxMessage.set_from()", "path": "library/mailbox#mailbox.mboxMessage.set_from", "type": "Internet Data", "text": "\nSet the \u201cFrom \u201d line to from_, which should be specified without a leading\n\u201cFrom \u201d or trailing newline. For convenience, time_ may be specified and will\nbe formatted appropriately and appended to from_. If time_ is specified, it\nshould be a `time.struct_time` instance, a tuple suitable for passing to\n`time.strftime()`, or `True` (to use `time.gmtime()`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.Message", "path": "library/mailbox#mailbox.Message", "type": "Internet Data", "text": "\nA subclass of the `email.message` module\u2019s `Message`. Subclasses of\n`mailbox.Message` add mailbox-format-specific state and behavior.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.MH", "path": "library/mailbox#mailbox.MH", "type": "Internet Data", "text": "\nA subclass of `Mailbox` for mailboxes in MH format. Parameter factory is a\ncallable object that accepts a file-like message representation (which behaves\nas if opened in binary mode) and returns a custom representation. If factory\nis `None`, `MHMessage` is used as the default message representation. If\ncreate is `True`, the mailbox is created if it does not exist.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.MH.add_folder()", "path": "library/mailbox#mailbox.MH.add_folder", "type": "Internet Data", "text": "\nCreate a folder whose name is folder and return an `MH` instance representing\nit.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.MH.close()", "path": "library/mailbox#mailbox.MH.close", "type": "Internet Data", "text": "\n`MH` instances do not keep any open files, so this method is equivalent to\n`unlock()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.MH.discard()", "path": "library/mailbox#mailbox.MH.discard", "type": "Internet Data", "text": "\nThese methods immediately delete the message. The MH convention of marking a\nmessage for deletion by prepending a comma to its name is not used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.MH.flush()", "path": "library/mailbox#mailbox.MH.flush", "type": "Internet Data", "text": "\nAll changes to MH mailboxes are immediately applied, so this method does\nnothing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.MH.get_file()", "path": "library/mailbox#mailbox.MH.get_file", "type": "Internet Data", "text": "\nDepending upon the host platform, it may not be possible to remove the\nunderlying message while the returned file remains open.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.MH.get_folder()", "path": "library/mailbox#mailbox.MH.get_folder", "type": "Internet Data", "text": "\nReturn an `MH` instance representing the folder whose name is folder. A\n`NoSuchMailboxError` exception is raised if the folder does not exist.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.MH.get_sequences()", "path": "library/mailbox#mailbox.MH.get_sequences", "type": "Internet Data", "text": "\nReturn a dictionary of sequence names mapped to key lists. If there are no\nsequences, the empty dictionary is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.MH.list_folders()", "path": "library/mailbox#mailbox.MH.list_folders", "type": "Internet Data", "text": "\nReturn a list of the names of all folders.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.MH.lock()", "path": "library/mailbox#mailbox.MH.lock", "type": "Internet Data", "text": "\nThree locking mechanisms are used\u2014dot locking and, if available, the `flock()`\nand `lockf()` system calls. For MH mailboxes, locking the mailbox means\nlocking the `.mh_sequences` file and, only for the duration of any operations\nthat affect them, locking individual message files.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.MH.pack()", "path": "library/mailbox#mailbox.MH.pack", "type": "Internet Data", "text": "\nRename messages in the mailbox as necessary to eliminate gaps in numbering.\nEntries in the sequences list are updated correspondingly.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.MH.remove()", "path": "library/mailbox#mailbox.MH.remove", "type": "Internet Data", "text": "\nThese methods immediately delete the message. The MH convention of marking a\nmessage for deletion by prepending a comma to its name is not used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.MH.remove_folder()", "path": "library/mailbox#mailbox.MH.remove_folder", "type": "Internet Data", "text": "\nDelete the folder whose name is folder. If the folder contains any messages, a\n`NotEmptyError` exception will be raised and the folder will not be deleted.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.MH.set_sequences()", "path": "library/mailbox#mailbox.MH.set_sequences", "type": "Internet Data", "text": "\nRe-define the sequences that exist in the mailbox based upon sequences, a\ndictionary of names mapped to key lists, like returned by `get_sequences()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.MH.unlock()", "path": "library/mailbox#mailbox.MH.unlock", "type": "Internet Data", "text": "\nThree locking mechanisms are used\u2014dot locking and, if available, the `flock()`\nand `lockf()` system calls. For MH mailboxes, locking the mailbox means\nlocking the `.mh_sequences` file and, only for the duration of any operations\nthat affect them, locking individual message files.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.MH.__delitem__()", "path": "library/mailbox#mailbox.MH.__delitem__", "type": "Internet Data", "text": "\nThese methods immediately delete the message. The MH convention of marking a\nmessage for deletion by prepending a comma to its name is not used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.MHMessage", "path": "library/mailbox#mailbox.MHMessage", "type": "Internet Data", "text": "\nA message with MH-specific behaviors. Parameter message has the same meaning\nas with the `Message` constructor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.MHMessage.add_sequence()", "path": "library/mailbox#mailbox.MHMessage.add_sequence", "type": "Internet Data", "text": "\nAdd sequence to the list of sequences that include this message.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.MHMessage.get_sequences()", "path": "library/mailbox#mailbox.MHMessage.get_sequences", "type": "Internet Data", "text": "\nReturn a list of the names of sequences that include this message.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.MHMessage.remove_sequence()", "path": "library/mailbox#mailbox.MHMessage.remove_sequence", "type": "Internet Data", "text": "\nRemove sequence from the list of sequences that include this message.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.MHMessage.set_sequences()", "path": "library/mailbox#mailbox.MHMessage.set_sequences", "type": "Internet Data", "text": "\nSet the list of sequences that include this message.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.MMDF", "path": "library/mailbox#mailbox.MMDF", "type": "Internet Data", "text": "\nA subclass of `Mailbox` for mailboxes in MMDF format. Parameter factory is a\ncallable object that accepts a file-like message representation (which behaves\nas if opened in binary mode) and returns a custom representation. If factory\nis `None`, `MMDFMessage` is used as the default message representation. If\ncreate is `True`, the mailbox is created if it does not exist.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.MMDF.get_file()", "path": "library/mailbox#mailbox.MMDF.get_file", "type": "Internet Data", "text": "\nUsing the file after calling `flush()` or `close()` on the `MMDF` instance may\nyield unpredictable results or raise an exception.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.MMDF.lock()", "path": "library/mailbox#mailbox.MMDF.lock", "type": "Internet Data", "text": "\nThree locking mechanisms are used\u2014dot locking and, if available, the `flock()`\nand `lockf()` system calls.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.MMDF.unlock()", "path": "library/mailbox#mailbox.MMDF.unlock", "type": "Internet Data", "text": "\nThree locking mechanisms are used\u2014dot locking and, if available, the `flock()`\nand `lockf()` system calls.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.MMDFMessage", "path": "library/mailbox#mailbox.MMDFMessage", "type": "Internet Data", "text": "\nA message with MMDF-specific behaviors. Parameter message has the same meaning\nas with the `Message` constructor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.MMDFMessage.add_flag()", "path": "library/mailbox#mailbox.MMDFMessage.add_flag", "type": "Internet Data", "text": "\nSet the flag(s) specified by flag without changing other flags. To add more\nthan one flag at a time, flag may be a string of more than one character.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.MMDFMessage.get_flags()", "path": "library/mailbox#mailbox.MMDFMessage.get_flags", "type": "Internet Data", "text": "\nReturn a string specifying the flags that are currently set. If the message\ncomplies with the conventional format, the result is the concatenation in the\nfollowing order of zero or one occurrence of each of `'R'`, `'O'`, `'D'`,\n`'F'`, and `'A'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.MMDFMessage.get_from()", "path": "library/mailbox#mailbox.MMDFMessage.get_from", "type": "Internet Data", "text": "\nReturn a string representing the \u201cFrom \u201d line that marks the start of the\nmessage in an mbox mailbox. The leading \u201cFrom \u201d and the trailing newline are\nexcluded.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.MMDFMessage.remove_flag()", "path": "library/mailbox#mailbox.MMDFMessage.remove_flag", "type": "Internet Data", "text": "\nUnset the flag(s) specified by flag without changing other flags. To remove\nmore than one flag at a time, flag maybe a string of more than one character.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.MMDFMessage.set_flags()", "path": "library/mailbox#mailbox.MMDFMessage.set_flags", "type": "Internet Data", "text": "\nSet the flags specified by flags and unset all others. Parameter flags should\nbe the concatenation in any order of zero or more occurrences of each of\n`'R'`, `'O'`, `'D'`, `'F'`, and `'A'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.MMDFMessage.set_from()", "path": "library/mailbox#mailbox.MMDFMessage.set_from", "type": "Internet Data", "text": "\nSet the \u201cFrom \u201d line to from_, which should be specified without a leading\n\u201cFrom \u201d or trailing newline. For convenience, time_ may be specified and will\nbe formatted appropriately and appended to from_. If time_ is specified, it\nshould be a `time.struct_time` instance, a tuple suitable for passing to\n`time.strftime()`, or `True` (to use `time.gmtime()`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.NoSuchMailboxError", "path": "library/mailbox#mailbox.NoSuchMailboxError", "type": "Internet Data", "text": "\nRaised when a mailbox is expected but is not found, such as when instantiating\na `Mailbox` subclass with a path that does not exist (and with the create\nparameter set to `False`), or when opening a folder that does not exist.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailbox.NotEmptyError", "path": "library/mailbox#mailbox.NotEmptyError", "type": "Internet Data", "text": "\nRaised when a mailbox is not empty but is expected to be, such as when\ndeleting a folder that contains messages.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailcap", "path": "library/mailcap", "type": "Internet Data", "text": "\nSource code: Lib/mailcap.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailcap.findmatch()", "path": "library/mailcap#mailcap.findmatch", "type": "Internet Data", "text": "\nReturn a 2-tuple; the first element is a string containing the command line to\nbe executed (which can be passed to `os.system()`), and the second element is\nthe mailcap entry for a given MIME type. If no matching MIME type can be\nfound, `(None, None)` is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mailcap.getcaps()", "path": "library/mailcap#mailcap.getcaps", "type": "Internet Data", "text": "\nReturns a dictionary mapping MIME types to a list of mailcap file entries.\nThis dictionary must be passed to the `findmatch()` function. An entry is\nstored as a list of dictionaries, but it shouldn\u2019t be necessary to know the\ndetails of this representation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "map()", "path": "library/functions#map", "type": "Built-in Functions", "text": "\nReturn an iterator that applies function to every item of iterable, yielding\nthe results. If additional iterable arguments are passed, function must take\nthat many arguments and is applied to the items from all iterables in\nparallel. With multiple iterables, the iterator stops when the shortest\niterable is exhausted. For cases where the function inputs are already\narranged into argument tuples, see `itertools.starmap()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "marshal", "path": "library/marshal", "type": "Data Persistence", "text": "\nThis module contains functions that can read and write Python values in a\nbinary format. The format is specific to Python, but independent of machine\narchitecture issues (e.g., you can write a Python value to a file on a PC,\ntransport the file to a Sun, and read it back there). Details of the format\nare undocumented on purpose; it may change between Python versions (although\nit rarely does). 1\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "marshal.dump()", "path": "library/marshal#marshal.dump", "type": "Data Persistence", "text": "\nWrite the value on the open file. The value must be a supported type. The file\nmust be a writeable binary file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "marshal.dumps()", "path": "library/marshal#marshal.dumps", "type": "Data Persistence", "text": "\nReturn the bytes object that would be written to a file by `dump(value,\nfile)`. The value must be a supported type. Raise a `ValueError` exception if\nvalue has (or contains an object that has) an unsupported type.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "marshal.load()", "path": "library/marshal#marshal.load", "type": "Data Persistence", "text": "\nRead one value from the open file and return it. If no valid value is read\n(e.g. because the data has a different Python version\u2019s incompatible marshal\nformat), raise `EOFError`, `ValueError` or `TypeError`. The file must be a\nreadable binary file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "marshal.loads()", "path": "library/marshal#marshal.loads", "type": "Data Persistence", "text": "\nConvert the bytes-like object to a value. If no valid value is found, raise\n`EOFError`, `ValueError` or `TypeError`. Extra bytes in the input are ignored.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "marshal.version", "path": "library/marshal#marshal.version", "type": "Data Persistence", "text": "\nIndicates the format that the module uses. Version 0 is the historical format,\nversion 1 shares interned strings and version 2 uses a binary format for\nfloating point numbers. Version 3 adds support for object instancing and\nrecursion. The current version is 4.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math", "path": "library/math", "type": "Numeric & Mathematical", "text": "\nThis module provides access to the mathematical functions defined by the C\nstandard.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.acos()", "path": "library/math#math.acos", "type": "Numeric & Mathematical", "text": "\nReturn the arc cosine of x, in radians. The result is between `0` and `pi`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.acosh()", "path": "library/math#math.acosh", "type": "Numeric & Mathematical", "text": "\nReturn the inverse hyperbolic cosine of x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.asin()", "path": "library/math#math.asin", "type": "Numeric & Mathematical", "text": "\nReturn the arc sine of x, in radians. The result is between `-pi/2` and\n`pi/2`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.asinh()", "path": "library/math#math.asinh", "type": "Numeric & Mathematical", "text": "\nReturn the inverse hyperbolic sine of x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.atan()", "path": "library/math#math.atan", "type": "Numeric & Mathematical", "text": "\nReturn the arc tangent of x, in radians. The result is between `-pi/2` and\n`pi/2`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.atan2()", "path": "library/math#math.atan2", "type": "Numeric & Mathematical", "text": "\nReturn `atan(y / x)`, in radians. The result is between `-pi` and `pi`. The\nvector in the plane from the origin to point `(x, y)` makes this angle with\nthe positive X axis. The point of `atan2()` is that the signs of both inputs\nare known to it, so it can compute the correct quadrant for the angle. For\nexample, `atan(1)` and `atan2(1, 1)` are both `pi/4`, but `atan2(-1, -1)` is\n`-3*pi/4`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.atanh()", "path": "library/math#math.atanh", "type": "Numeric & Mathematical", "text": "\nReturn the inverse hyperbolic tangent of x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.ceil()", "path": "library/math#math.ceil", "type": "Numeric & Mathematical", "text": "\nReturn the ceiling of x, the smallest integer greater than or equal to x. If x\nis not a float, delegates to `x.__ceil__()`, which should return an `Integral`\nvalue.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.comb()", "path": "library/math#math.comb", "type": "Numeric & Mathematical", "text": "\nReturn the number of ways to choose k items from n items without repetition\nand without order.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.copysign()", "path": "library/math#math.copysign", "type": "Numeric & Mathematical", "text": "\nReturn a float with the magnitude (absolute value) of x but the sign of y. On\nplatforms that support signed zeros, `copysign(1.0, -0.0)` returns -1.0.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.cos()", "path": "library/math#math.cos", "type": "Numeric & Mathematical", "text": "\nReturn the cosine of x radians.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.cosh()", "path": "library/math#math.cosh", "type": "Numeric & Mathematical", "text": "\nReturn the hyperbolic cosine of x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.degrees()", "path": "library/math#math.degrees", "type": "Numeric & Mathematical", "text": "\nConvert angle x from radians to degrees.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.dist()", "path": "library/math#math.dist", "type": "Numeric & Mathematical", "text": "\nReturn the Euclidean distance between two points p and q, each given as a\nsequence (or iterable) of coordinates. The two points must have the same\ndimension.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.e", "path": "library/math#math.e", "type": "Numeric & Mathematical", "text": "\nThe mathematical constant e = 2.718281\u2026, to available precision.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.erf()", "path": "library/math#math.erf", "type": "Numeric & Mathematical", "text": "\nReturn the error function at x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.erfc()", "path": "library/math#math.erfc", "type": "Numeric & Mathematical", "text": "\nReturn the complementary error function at x. The complementary error function\nis defined as `1.0 - erf(x)`. It is used for large values of x where a\nsubtraction from one would cause a loss of significance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.exp()", "path": "library/math#math.exp", "type": "Numeric & Mathematical", "text": "\nReturn e raised to the power x, where e = 2.718281\u2026 is the base of natural\nlogarithms. This is usually more accurate than `math.e ** x` or `pow(math.e,\nx)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.expm1()", "path": "library/math#math.expm1", "type": "Numeric & Mathematical", "text": "\nReturn e raised to the power x, minus 1. Here e is the base of natural\nlogarithms. For small floats x, the subtraction in `exp(x) - 1` can result in\na significant loss of precision; the `expm1()` function provides a way to\ncompute this quantity to full precision:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.fabs()", "path": "library/math#math.fabs", "type": "Numeric & Mathematical", "text": "\nReturn the absolute value of x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.factorial()", "path": "library/math#math.factorial", "type": "Numeric & Mathematical", "text": "\nReturn x factorial as an integer. Raises `ValueError` if x is not integral or\nis negative.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.floor()", "path": "library/math#math.floor", "type": "Numeric & Mathematical", "text": "\nReturn the floor of x, the largest integer less than or equal to x. If x is\nnot a float, delegates to `x.__floor__()`, which should return an `Integral`\nvalue.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.fmod()", "path": "library/math#math.fmod", "type": "Numeric & Mathematical", "text": "\nReturn `fmod(x, y)`, as defined by the platform C library. Note that the\nPython expression `x % y` may not return the same result. The intent of the C\nstandard is that `fmod(x, y)` be exactly (mathematically; to infinite\nprecision) equal to `x - n*y` for some integer n such that the result has the\nsame sign as x and magnitude less than `abs(y)`. Python\u2019s `x % y` returns a\nresult with the sign of y instead, and may not be exactly computable for float\narguments. For example, `fmod(-1e-100, 1e100)` is `-1e-100`, but the result of\nPython\u2019s `-1e-100 % 1e100` is `1e100-1e-100`, which cannot be represented\nexactly as a float, and rounds to the surprising `1e100`. For this reason,\nfunction `fmod()` is generally preferred when working with floats, while\nPython\u2019s `x % y` is preferred when working with integers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.frexp()", "path": "library/math#math.frexp", "type": "Numeric & Mathematical", "text": "\nReturn the mantissa and exponent of x as the pair `(m, e)`. m is a float and e\nis an integer such that `x == m * 2**e` exactly. If x is zero, returns `(0.0,\n0)`, otherwise `0.5 <= abs(m) < 1`. This is used to \u201cpick apart\u201d the internal\nrepresentation of a float in a portable way.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.fsum()", "path": "library/math#math.fsum", "type": "Numeric & Mathematical", "text": "\nReturn an accurate floating point sum of values in the iterable. Avoids loss\nof precision by tracking multiple intermediate partial sums:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.gamma()", "path": "library/math#math.gamma", "type": "Numeric & Mathematical", "text": "\nReturn the Gamma function at x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.gcd()", "path": "library/math#math.gcd", "type": "Numeric & Mathematical", "text": "\nReturn the greatest common divisor of the specified integer arguments. If any\nof the arguments is nonzero, then the returned value is the largest positive\ninteger that is a divisor of all arguments. If all arguments are zero, then\nthe returned value is `0`. `gcd()` without arguments returns `0`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.hypot()", "path": "library/math#math.hypot", "type": "Numeric & Mathematical", "text": "\nReturn the Euclidean norm, `sqrt(sum(x**2 for x in coordinates))`. This is the\nlength of the vector from the origin to the point given by the coordinates.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.inf", "path": "library/math#math.inf", "type": "Numeric & Mathematical", "text": "\nA floating-point positive infinity. (For negative infinity, use `-math.inf`.)\nEquivalent to the output of `float('inf')`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.isclose()", "path": "library/math#math.isclose", "type": "Numeric & Mathematical", "text": "\nReturn `True` if the values a and b are close to each other and `False`\notherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.isfinite()", "path": "library/math#math.isfinite", "type": "Numeric & Mathematical", "text": "\nReturn `True` if x is neither an infinity nor a NaN, and `False` otherwise.\n(Note that `0.0` is considered finite.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.isinf()", "path": "library/math#math.isinf", "type": "Numeric & Mathematical", "text": "\nReturn `True` if x is a positive or negative infinity, and `False` otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.isnan()", "path": "library/math#math.isnan", "type": "Numeric & Mathematical", "text": "\nReturn `True` if x is a NaN (not a number), and `False` otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.isqrt()", "path": "library/math#math.isqrt", "type": "Numeric & Mathematical", "text": "\nReturn the integer square root of the nonnegative integer n. This is the floor\nof the exact square root of n, or equivalently the greatest integer a such\nthat a\u00b2 \u2264 n.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.lcm()", "path": "library/math#math.lcm", "type": "Numeric & Mathematical", "text": "\nReturn the least common multiple of the specified integer arguments. If all\narguments are nonzero, then the returned value is the smallest positive\ninteger that is a multiple of all arguments. If any of the arguments is zero,\nthen the returned value is `0`. `lcm()` without arguments returns `1`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.ldexp()", "path": "library/math#math.ldexp", "type": "Numeric & Mathematical", "text": "\nReturn `x * (2**i)`. This is essentially the inverse of function `frexp()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.lgamma()", "path": "library/math#math.lgamma", "type": "Numeric & Mathematical", "text": "\nReturn the natural logarithm of the absolute value of the Gamma function at x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.log()", "path": "library/math#math.log", "type": "Numeric & Mathematical", "text": "\nWith one argument, return the natural logarithm of x (to base e).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.log10()", "path": "library/math#math.log10", "type": "Numeric & Mathematical", "text": "\nReturn the base-10 logarithm of x. This is usually more accurate than `log(x,\n10)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.log1p()", "path": "library/math#math.log1p", "type": "Numeric & Mathematical", "text": "\nReturn the natural logarithm of 1+x (base e). The result is calculated in a\nway which is accurate for x near zero.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.log2()", "path": "library/math#math.log2", "type": "Numeric & Mathematical", "text": "\nReturn the base-2 logarithm of x. This is usually more accurate than `log(x,\n2)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.modf()", "path": "library/math#math.modf", "type": "Numeric & Mathematical", "text": "\nReturn the fractional and integer parts of x. Both results carry the sign of x\nand are floats.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.nan", "path": "library/math#math.nan", "type": "Numeric & Mathematical", "text": "\nA floating-point \u201cnot a number\u201d (NaN) value. Equivalent to the output of\n`float('nan')`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.nextafter()", "path": "library/math#math.nextafter", "type": "Numeric & Mathematical", "text": "\nReturn the next floating-point value after x towards y.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.perm()", "path": "library/math#math.perm", "type": "Numeric & Mathematical", "text": "\nReturn the number of ways to choose k items from n items without repetition\nand with order.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.pi", "path": "library/math#math.pi", "type": "Numeric & Mathematical", "text": "\nThe mathematical constant \u03c0 = 3.141592\u2026, to available precision.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.pow()", "path": "library/math#math.pow", "type": "Numeric & Mathematical", "text": "\nReturn `x` raised to the power `y`. Exceptional cases follow Annex \u2018F\u2019 of the\nC99 standard as far as possible. In particular, `pow(1.0, x)` and `pow(x,\n0.0)` always return `1.0`, even when `x` is a zero or a NaN. If both `x` and\n`y` are finite, `x` is negative, and `y` is not an integer then `pow(x, y)` is\nundefined, and raises `ValueError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.prod()", "path": "library/math#math.prod", "type": "Numeric & Mathematical", "text": "\nCalculate the product of all the elements in the input iterable. The default\nstart value for the product is `1`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.radians()", "path": "library/math#math.radians", "type": "Numeric & Mathematical", "text": "\nConvert angle x from degrees to radians.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.remainder()", "path": "library/math#math.remainder", "type": "Numeric & Mathematical", "text": "\nReturn the IEEE 754-style remainder of x with respect to y. For finite x and\nfinite nonzero y, this is the difference `x - n*y`, where `n` is the closest\ninteger to the exact value of the quotient `x / y`. If `x / y` is exactly\nhalfway between two consecutive integers, the nearest even integer is used for\n`n`. The remainder `r = remainder(x, y)` thus always satisfies `abs(r) <= 0.5\n* abs(y)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.sin()", "path": "library/math#math.sin", "type": "Numeric & Mathematical", "text": "\nReturn the sine of x radians.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.sinh()", "path": "library/math#math.sinh", "type": "Numeric & Mathematical", "text": "\nReturn the hyperbolic sine of x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.sqrt()", "path": "library/math#math.sqrt", "type": "Numeric & Mathematical", "text": "\nReturn the square root of x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.tan()", "path": "library/math#math.tan", "type": "Numeric & Mathematical", "text": "\nReturn the tangent of x radians.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.tanh()", "path": "library/math#math.tanh", "type": "Numeric & Mathematical", "text": "\nReturn the hyperbolic tangent of x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.tau", "path": "library/math#math.tau", "type": "Numeric & Mathematical", "text": "\nThe mathematical constant \u03c4 = 6.283185\u2026, to available precision. Tau is a\ncircle constant equal to 2\u03c0, the ratio of a circle\u2019s circumference to its\nradius. To learn more about Tau, check out Vi Hart\u2019s video Pi is (still)\nWrong, and start celebrating Tau day by eating twice as much pie!\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.trunc()", "path": "library/math#math.trunc", "type": "Numeric & Mathematical", "text": "\nReturn the `Real` value x truncated to an `Integral` (usually an integer).\nDelegates to `x.__trunc__()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "math.ulp()", "path": "library/math#math.ulp", "type": "Numeric & Mathematical", "text": "\nReturn the value of the least significant bit of the float x:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "max()", "path": "library/functions#max", "type": "Built-in Functions", "text": "\nReturn the largest item in an iterable or the largest of two or more\narguments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "MemoryError", "path": "library/exceptions#MemoryError", "type": "Built-in Exceptions", "text": "\nRaised when an operation runs out of memory but the situation may still be\nrescued (by deleting some objects). The associated value is a string\nindicating what kind of (internal) operation ran out of memory. Note that\nbecause of the underlying memory management architecture (C\u2019s `malloc()`\nfunction), the interpreter may not always be able to completely recover from\nthis situation; it nevertheless raises an exception so that a stack traceback\ncan be printed, in case a run-away program was the cause.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "memoryview", "path": "library/stdtypes#memoryview", "type": "Built-in Types", "text": "\nCreate a `memoryview` that references obj. obj must support the buffer\nprotocol. Built-in objects that support the buffer protocol include `bytes`\nand `bytearray`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "memoryview", "path": "library/functions#memoryview", "type": "Built-in Functions", "text": "\nReturn a \u201cmemory view\u201d object created from the given argument. See Memory\nViews for more information.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "memoryview.cast()", "path": "library/stdtypes#memoryview.cast", "type": "Built-in Types", "text": "\nCast a memoryview to a new format or shape. shape defaults to\n`[byte_length//new_itemsize]`, which means that the result view will be one-\ndimensional. The return value is a new memoryview, but the buffer itself is\nnot copied. Supported casts are 1D -> C-contiguous and C-contiguous -> 1D.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "memoryview.contiguous", "path": "library/stdtypes#memoryview.contiguous", "type": "Built-in Types", "text": "\nA bool indicating whether the memory is contiguous.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "memoryview.c_contiguous", "path": "library/stdtypes#memoryview.c_contiguous", "type": "Built-in Types", "text": "\nA bool indicating whether the memory is C-contiguous.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "memoryview.format", "path": "library/stdtypes#memoryview.format", "type": "Built-in Types", "text": "\nA string containing the format (in `struct` module style) for each element in\nthe view. A memoryview can be created from exporters with arbitrary format\nstrings, but some methods (e.g. `tolist()`) are restricted to native single\nelement formats.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "memoryview.f_contiguous", "path": "library/stdtypes#memoryview.f_contiguous", "type": "Built-in Types", "text": "\nA bool indicating whether the memory is Fortran contiguous.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "memoryview.hex()", "path": "library/stdtypes#memoryview.hex", "type": "Built-in Types", "text": "\nReturn a string object containing two hexadecimal digits for each byte in the\nbuffer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "memoryview.itemsize", "path": "library/stdtypes#memoryview.itemsize", "type": "Built-in Types", "text": "\nThe size in bytes of each element of the memoryview:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "memoryview.nbytes", "path": "library/stdtypes#memoryview.nbytes", "type": "Built-in Types", "text": "\n`nbytes == product(shape) * itemsize == len(m.tobytes())`. This is the amount\nof space in bytes that the array would use in a contiguous representation. It\nis not necessarily equal to `len(m)`:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "memoryview.ndim", "path": "library/stdtypes#memoryview.ndim", "type": "Built-in Types", "text": "\nAn integer indicating how many dimensions of a multi-dimensional array the\nmemory represents.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "memoryview.obj", "path": "library/stdtypes#memoryview.obj", "type": "Built-in Types", "text": "\nThe underlying object of the memoryview:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "memoryview.readonly", "path": "library/stdtypes#memoryview.readonly", "type": "Built-in Types", "text": "\nA bool indicating whether the memory is read only.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "memoryview.release()", "path": "library/stdtypes#memoryview.release", "type": "Built-in Types", "text": "\nRelease the underlying buffer exposed by the memoryview object. Many objects\ntake special actions when a view is held on them (for example, a `bytearray`\nwould temporarily forbid resizing); therefore, calling release() is handy to\nremove these restrictions (and free any dangling resources) as soon as\npossible.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "memoryview.shape", "path": "library/stdtypes#memoryview.shape", "type": "Built-in Types", "text": "\nA tuple of integers the length of `ndim` giving the shape of the memory as an\nN-dimensional array.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "memoryview.strides", "path": "library/stdtypes#memoryview.strides", "type": "Built-in Types", "text": "\nA tuple of integers the length of `ndim` giving the size in bytes to access\neach element for each dimension of the array.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "memoryview.suboffsets", "path": "library/stdtypes#memoryview.suboffsets", "type": "Built-in Types", "text": "\nUsed internally for PIL-style arrays. The value is informational only.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "memoryview.tobytes()", "path": "library/stdtypes#memoryview.tobytes", "type": "Built-in Types", "text": "\nReturn the data in the buffer as a bytestring. This is equivalent to calling\nthe `bytes` constructor on the memoryview.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "memoryview.tolist()", "path": "library/stdtypes#memoryview.tolist", "type": "Built-in Types", "text": "\nReturn the data in the buffer as a list of elements.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "memoryview.toreadonly()", "path": "library/stdtypes#memoryview.toreadonly", "type": "Built-in Types", "text": "\nReturn a readonly version of the memoryview object. The original memoryview\nobject is unchanged.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "memoryview.__eq__()", "path": "library/stdtypes#memoryview.__eq__", "type": "Built-in Types", "text": "\nA memoryview and a PEP 3118 exporter are equal if their shapes are equivalent\nand if all corresponding values are equal when the operands\u2019 respective format\ncodes are interpreted using `struct` syntax.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mimetypes", "path": "library/mimetypes", "type": "Internet Data", "text": "\nSource code: Lib/mimetypes.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mimetypes.add_type()", "path": "library/mimetypes#mimetypes.add_type", "type": "Internet Data", "text": "\nAdd a mapping from the MIME type type to the extension ext. When the extension\nis already known, the new type will replace the old one. When the type is\nalready known the extension will be added to the list of known extensions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mimetypes.common_types", "path": "library/mimetypes#mimetypes.common_types", "type": "Internet Data", "text": "\nDictionary mapping filename extensions to non-standard, but commonly found\nMIME types.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mimetypes.encodings_map", "path": "library/mimetypes#mimetypes.encodings_map", "type": "Internet Data", "text": "\nDictionary mapping filename extensions to encoding types.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mimetypes.guess_all_extensions()", "path": "library/mimetypes#mimetypes.guess_all_extensions", "type": "Internet Data", "text": "\nGuess the extensions for a file based on its MIME type, given by type. The\nreturn value is a list of strings giving all possible filename extensions,\nincluding the leading dot (`'.'`). The extensions are not guaranteed to have\nbeen associated with any particular data stream, but would be mapped to the\nMIME type type by `guess_type()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mimetypes.guess_extension()", "path": "library/mimetypes#mimetypes.guess_extension", "type": "Internet Data", "text": "\nGuess the extension for a file based on its MIME type, given by type. The\nreturn value is a string giving a filename extension, including the leading\ndot (`'.'`). The extension is not guaranteed to have been associated with any\nparticular data stream, but would be mapped to the MIME type type by\n`guess_type()`. If no extension can be guessed for type, `None` is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mimetypes.guess_type()", "path": "library/mimetypes#mimetypes.guess_type", "type": "Internet Data", "text": "\nGuess the type of a file based on its filename, path or URL, given by url. URL\ncan be a string or a path-like object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mimetypes.init()", "path": "library/mimetypes#mimetypes.init", "type": "Internet Data", "text": "\nInitialize the internal data structures. If given, files must be a sequence of\nfile names which should be used to augment the default type map. If omitted,\nthe file names to use are taken from `knownfiles`; on Windows, the current\nregistry settings are loaded. Each file named in files or `knownfiles` takes\nprecedence over those named before it. Calling `init()` repeatedly is allowed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mimetypes.inited", "path": "library/mimetypes#mimetypes.inited", "type": "Internet Data", "text": "\nFlag indicating whether or not the global data structures have been\ninitialized. This is set to `True` by `init()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mimetypes.knownfiles", "path": "library/mimetypes#mimetypes.knownfiles", "type": "Internet Data", "text": "\nList of type map file names commonly installed. These files are typically\nnamed `mime.types` and are installed in different locations by different\npackages.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mimetypes.MimeTypes", "path": "library/mimetypes#mimetypes.MimeTypes", "type": "Internet Data", "text": "\nThis class represents a MIME-types database. By default, it provides access to\nthe same database as the rest of this module. The initial database is a copy\nof that provided by the module, and may be extended by loading additional\n`mime.types`-style files into the database using the `read()` or `readfp()`\nmethods. The mapping dictionaries may also be cleared before loading\nadditional data if the default data is not desired.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mimetypes.MimeTypes.encodings_map", "path": "library/mimetypes#mimetypes.MimeTypes.encodings_map", "type": "Internet Data", "text": "\nDictionary mapping filename extensions to encoding types. This is initially a\ncopy of the global `encodings_map` defined in the module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mimetypes.MimeTypes.guess_all_extensions()", "path": "library/mimetypes#mimetypes.MimeTypes.guess_all_extensions", "type": "Internet Data", "text": "\nSimilar to the `guess_all_extensions()` function, using the tables stored as\npart of the object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mimetypes.MimeTypes.guess_extension()", "path": "library/mimetypes#mimetypes.MimeTypes.guess_extension", "type": "Internet Data", "text": "\nSimilar to the `guess_extension()` function, using the tables stored as part\nof the object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mimetypes.MimeTypes.guess_type()", "path": "library/mimetypes#mimetypes.MimeTypes.guess_type", "type": "Internet Data", "text": "\nSimilar to the `guess_type()` function, using the tables stored as part of the\nobject.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mimetypes.MimeTypes.read()", "path": "library/mimetypes#mimetypes.MimeTypes.read", "type": "Internet Data", "text": "\nLoad MIME information from a file named filename. This uses `readfp()` to\nparse the file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mimetypes.MimeTypes.readfp()", "path": "library/mimetypes#mimetypes.MimeTypes.readfp", "type": "Internet Data", "text": "\nLoad MIME type information from an open file fp. The file must have the format\nof the standard `mime.types` files.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mimetypes.MimeTypes.read_windows_registry()", "path": "library/mimetypes#mimetypes.MimeTypes.read_windows_registry", "type": "Internet Data", "text": "\nLoad MIME type information from the Windows registry.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mimetypes.MimeTypes.suffix_map", "path": "library/mimetypes#mimetypes.MimeTypes.suffix_map", "type": "Internet Data", "text": "\nDictionary mapping suffixes to suffixes. This is used to allow recognition of\nencoded files for which the encoding and the type are indicated by the same\nextension. For example, the `.tgz` extension is mapped to `.tar.gz` to allow\nthe encoding and type to be recognized separately. This is initially a copy of\nthe global `suffix_map` defined in the module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mimetypes.MimeTypes.types_map", "path": "library/mimetypes#mimetypes.MimeTypes.types_map", "type": "Internet Data", "text": "\nTuple containing two dictionaries, mapping filename extensions to MIME types:\nthe first dictionary is for the non-standards types and the second one is for\nthe standard types. They are initialized by `common_types` and `types_map`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mimetypes.MimeTypes.types_map_inv", "path": "library/mimetypes#mimetypes.MimeTypes.types_map_inv", "type": "Internet Data", "text": "\nTuple containing two dictionaries, mapping MIME types to a list of filename\nextensions: the first dictionary is for the non-standards types and the second\none is for the standard types. They are initialized by `common_types` and\n`types_map`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mimetypes.read_mime_types()", "path": "library/mimetypes#mimetypes.read_mime_types", "type": "Internet Data", "text": "\nLoad the type map given in the file filename, if it exists. The type map is\nreturned as a dictionary mapping filename extensions, including the leading\ndot (`'.'`), to strings of the form `'type/subtype'`. If the file filename\ndoes not exist or cannot be read, `None` is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mimetypes.suffix_map", "path": "library/mimetypes#mimetypes.suffix_map", "type": "Internet Data", "text": "\nDictionary mapping suffixes to suffixes. This is used to allow recognition of\nencoded files for which the encoding and the type are indicated by the same\nextension. For example, the `.tgz` extension is mapped to `.tar.gz` to allow\nthe encoding and type to be recognized separately.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mimetypes.types_map", "path": "library/mimetypes#mimetypes.types_map", "type": "Internet Data", "text": "\nDictionary mapping filename extensions to MIME types.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "min()", "path": "library/functions#min", "type": "Built-in Functions", "text": "\nReturn the smallest item in an iterable or the smallest of two or more\narguments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mmap", "path": "library/mmap", "type": "Networking & Interprocess Communication", "text": "\nMemory-mapped file objects behave like both `bytearray` and like file objects.\nYou can use mmap objects in most places where `bytearray` are expected; for\nexample, you can use the `re` module to search through a memory-mapped file.\nYou can also change a single byte by doing `obj[index] = 97`, or change a\nsubsequence by assigning to a slice: `obj[i1:i2] = b'...'`. You can also read\nand write data starting at the current file position, and `seek()` through the\nfile to different positions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mmap.MADV_AUTOSYNC", "path": "library/mmap#mmap.MADV_AUTOSYNC", "type": "Networking & Interprocess Communication", "text": "\nThese options can be passed to `mmap.madvise()`. Not every option will be\npresent on every system.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mmap.MADV_CORE", "path": "library/mmap#mmap.MADV_CORE", "type": "Networking & Interprocess Communication", "text": "\nThese options can be passed to `mmap.madvise()`. Not every option will be\npresent on every system.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mmap.MADV_DODUMP", "path": "library/mmap#mmap.MADV_DODUMP", "type": "Networking & Interprocess Communication", "text": "\nThese options can be passed to `mmap.madvise()`. Not every option will be\npresent on every system.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mmap.MADV_DOFORK", "path": "library/mmap#mmap.MADV_DOFORK", "type": "Networking & Interprocess Communication", "text": "\nThese options can be passed to `mmap.madvise()`. Not every option will be\npresent on every system.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mmap.MADV_DONTDUMP", "path": "library/mmap#mmap.MADV_DONTDUMP", "type": "Networking & Interprocess Communication", "text": "\nThese options can be passed to `mmap.madvise()`. Not every option will be\npresent on every system.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mmap.MADV_DONTFORK", "path": "library/mmap#mmap.MADV_DONTFORK", "type": "Networking & Interprocess Communication", "text": "\nThese options can be passed to `mmap.madvise()`. Not every option will be\npresent on every system.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mmap.MADV_DONTNEED", "path": "library/mmap#mmap.MADV_DONTNEED", "type": "Networking & Interprocess Communication", "text": "\nThese options can be passed to `mmap.madvise()`. Not every option will be\npresent on every system.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mmap.MADV_FREE", "path": "library/mmap#mmap.MADV_FREE", "type": "Networking & Interprocess Communication", "text": "\nThese options can be passed to `mmap.madvise()`. Not every option will be\npresent on every system.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mmap.MADV_HUGEPAGE", "path": "library/mmap#mmap.MADV_HUGEPAGE", "type": "Networking & Interprocess Communication", "text": "\nThese options can be passed to `mmap.madvise()`. Not every option will be\npresent on every system.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mmap.MADV_HWPOISON", "path": "library/mmap#mmap.MADV_HWPOISON", "type": "Networking & Interprocess Communication", "text": "\nThese options can be passed to `mmap.madvise()`. Not every option will be\npresent on every system.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mmap.MADV_MERGEABLE", "path": "library/mmap#mmap.MADV_MERGEABLE", "type": "Networking & Interprocess Communication", "text": "\nThese options can be passed to `mmap.madvise()`. Not every option will be\npresent on every system.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mmap.MADV_NOCORE", "path": "library/mmap#mmap.MADV_NOCORE", "type": "Networking & Interprocess Communication", "text": "\nThese options can be passed to `mmap.madvise()`. Not every option will be\npresent on every system.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mmap.MADV_NOHUGEPAGE", "path": "library/mmap#mmap.MADV_NOHUGEPAGE", "type": "Networking & Interprocess Communication", "text": "\nThese options can be passed to `mmap.madvise()`. Not every option will be\npresent on every system.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mmap.MADV_NORMAL", "path": "library/mmap#mmap.MADV_NORMAL", "type": "Networking & Interprocess Communication", "text": "\nThese options can be passed to `mmap.madvise()`. Not every option will be\npresent on every system.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mmap.MADV_NOSYNC", "path": "library/mmap#mmap.MADV_NOSYNC", "type": "Networking & Interprocess Communication", "text": "\nThese options can be passed to `mmap.madvise()`. Not every option will be\npresent on every system.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mmap.MADV_PROTECT", "path": "library/mmap#mmap.MADV_PROTECT", "type": "Networking & Interprocess Communication", "text": "\nThese options can be passed to `mmap.madvise()`. Not every option will be\npresent on every system.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mmap.MADV_RANDOM", "path": "library/mmap#mmap.MADV_RANDOM", "type": "Networking & Interprocess Communication", "text": "\nThese options can be passed to `mmap.madvise()`. Not every option will be\npresent on every system.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mmap.MADV_REMOVE", "path": "library/mmap#mmap.MADV_REMOVE", "type": "Networking & Interprocess Communication", "text": "\nThese options can be passed to `mmap.madvise()`. Not every option will be\npresent on every system.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mmap.MADV_SEQUENTIAL", "path": "library/mmap#mmap.MADV_SEQUENTIAL", "type": "Networking & Interprocess Communication", "text": "\nThese options can be passed to `mmap.madvise()`. Not every option will be\npresent on every system.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mmap.MADV_SOFT_OFFLINE", "path": "library/mmap#mmap.MADV_SOFT_OFFLINE", "type": "Networking & Interprocess Communication", "text": "\nThese options can be passed to `mmap.madvise()`. Not every option will be\npresent on every system.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mmap.MADV_UNMERGEABLE", "path": "library/mmap#mmap.MADV_UNMERGEABLE", "type": "Networking & Interprocess Communication", "text": "\nThese options can be passed to `mmap.madvise()`. Not every option will be\npresent on every system.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mmap.MADV_WILLNEED", "path": "library/mmap#mmap.MADV_WILLNEED", "type": "Networking & Interprocess Communication", "text": "\nThese options can be passed to `mmap.madvise()`. Not every option will be\npresent on every system.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mmap.mmap", "path": "library/mmap#mmap.mmap", "type": "Networking & Interprocess Communication", "text": "\n(Windows version) Maps length bytes from the file specified by the file handle\nfileno, and creates a mmap object. If length is larger than the current size\nof the file, the file is extended to contain length bytes. If length is `0`,\nthe maximum length of the map is the current size of the file, except that if\nthe file is empty Windows raises an exception (you cannot create an empty\nmapping on Windows).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mmap.mmap.close()", "path": "library/mmap#mmap.mmap.close", "type": "Networking & Interprocess Communication", "text": "\nCloses the mmap. Subsequent calls to other methods of the object will result\nin a ValueError exception being raised. This will not close the open file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mmap.mmap.closed", "path": "library/mmap#mmap.mmap.closed", "type": "Networking & Interprocess Communication", "text": "\n`True` if the file is closed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mmap.mmap.find()", "path": "library/mmap#mmap.mmap.find", "type": "Networking & Interprocess Communication", "text": "\nReturns the lowest index in the object where the subsequence sub is found,\nsuch that sub is contained in the range [start, end]. Optional arguments start\nand end are interpreted as in slice notation. Returns `-1` on failure.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mmap.mmap.flush()", "path": "library/mmap#mmap.mmap.flush", "type": "Networking & Interprocess Communication", "text": "\nFlushes changes made to the in-memory copy of a file back to disk. Without use\nof this call there is no guarantee that changes are written back before the\nobject is destroyed. If offset and size are specified, only changes to the\ngiven range of bytes will be flushed to disk; otherwise, the whole extent of\nthe mapping is flushed. offset must be a multiple of the `PAGESIZE` or\n`ALLOCATIONGRANULARITY`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mmap.mmap.madvise()", "path": "library/mmap#mmap.mmap.madvise", "type": "Networking & Interprocess Communication", "text": "\nSend advice option to the kernel about the memory region beginning at start\nand extending length bytes. option must be one of the MADV_* constants\navailable on the system. If start and length are omitted, the entire mapping\nis spanned. On some systems (including Linux), start must be a multiple of the\n`PAGESIZE`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mmap.mmap.move()", "path": "library/mmap#mmap.mmap.move", "type": "Networking & Interprocess Communication", "text": "\nCopy the count bytes starting at offset src to the destination index dest. If\nthe mmap was created with `ACCESS_READ`, then calls to move will raise a\n`TypeError` exception.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mmap.mmap.read()", "path": "library/mmap#mmap.mmap.read", "type": "Networking & Interprocess Communication", "text": "\nReturn a `bytes` containing up to n bytes starting from the current file\nposition. If the argument is omitted, `None` or negative, return all bytes\nfrom the current file position to the end of the mapping. The file position is\nupdated to point after the bytes that were returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mmap.mmap.readline()", "path": "library/mmap#mmap.mmap.readline", "type": "Networking & Interprocess Communication", "text": "\nReturns a single line, starting at the current file position and up to the\nnext newline. The file position is updated to point after the bytes that were\nreturned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mmap.mmap.read_byte()", "path": "library/mmap#mmap.mmap.read_byte", "type": "Networking & Interprocess Communication", "text": "\nReturns a byte at the current file position as an integer, and advances the\nfile position by 1.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mmap.mmap.resize()", "path": "library/mmap#mmap.mmap.resize", "type": "Networking & Interprocess Communication", "text": "\nResizes the map and the underlying file, if any. If the mmap was created with\n`ACCESS_READ` or `ACCESS_COPY`, resizing the map will raise a `TypeError`\nexception.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mmap.mmap.rfind()", "path": "library/mmap#mmap.mmap.rfind", "type": "Networking & Interprocess Communication", "text": "\nReturns the highest index in the object where the subsequence sub is found,\nsuch that sub is contained in the range [start, end]. Optional arguments start\nand end are interpreted as in slice notation. Returns `-1` on failure.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mmap.mmap.seek()", "path": "library/mmap#mmap.mmap.seek", "type": "Networking & Interprocess Communication", "text": "\nSet the file\u2019s current position. whence argument is optional and defaults to\n`os.SEEK_SET` or `0` (absolute file positioning); other values are\n`os.SEEK_CUR` or `1` (seek relative to the current position) and `os.SEEK_END`\nor `2` (seek relative to the file\u2019s end).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mmap.mmap.size()", "path": "library/mmap#mmap.mmap.size", "type": "Networking & Interprocess Communication", "text": "\nReturn the length of the file, which can be larger than the size of the\nmemory-mapped area.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mmap.mmap.tell()", "path": "library/mmap#mmap.mmap.tell", "type": "Networking & Interprocess Communication", "text": "\nReturns the current position of the file pointer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mmap.mmap.write()", "path": "library/mmap#mmap.mmap.write", "type": "Networking & Interprocess Communication", "text": "\nWrite the bytes in bytes into memory at the current position of the file\npointer and return the number of bytes written (never less than `len(bytes)`,\nsince if the write fails, a `ValueError` will be raised). The file position is\nupdated to point after the bytes that were written. If the mmap was created\nwith `ACCESS_READ`, then writing to it will raise a `TypeError` exception.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mmap.mmap.write_byte()", "path": "library/mmap#mmap.mmap.write_byte", "type": "Networking & Interprocess Communication", "text": "\nWrite the integer byte into memory at the current position of the file\npointer; the file position is advanced by `1`. If the mmap was created with\n`ACCESS_READ`, then writing to it will raise a `TypeError` exception.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "modulefinder", "path": "library/modulefinder", "type": "Importing", "text": "\nSource code: Lib/modulefinder.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "modulefinder.AddPackagePath()", "path": "library/modulefinder#modulefinder.AddPackagePath", "type": "Importing", "text": "\nRecord that the package named pkg_name can be found in the specified path.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "modulefinder.ModuleFinder", "path": "library/modulefinder#modulefinder.ModuleFinder", "type": "Importing", "text": "\nThis class provides `run_script()` and `report()` methods to determine the set\nof modules imported by a script. path can be a list of directories to search\nfor modules; if not specified, `sys.path` is used. debug sets the debugging\nlevel; higher values make the class print debugging messages about what it\u2019s\ndoing. excludes is a list of module names to exclude from the analysis.\nreplace_paths is a list of `(oldpath, newpath)` tuples that will be replaced\nin module paths.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "modulefinder.ModuleFinder.modules", "path": "library/modulefinder#modulefinder.ModuleFinder.modules", "type": "Importing", "text": "\nA dictionary mapping module names to modules. See Example usage of\nModuleFinder.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "modulefinder.ModuleFinder.report()", "path": "library/modulefinder#modulefinder.ModuleFinder.report", "type": "Importing", "text": "\nPrint a report to standard output that lists the modules imported by the\nscript and their paths, as well as modules that are missing or seem to be\nmissing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "modulefinder.ModuleFinder.run_script()", "path": "library/modulefinder#modulefinder.ModuleFinder.run_script", "type": "Importing", "text": "\nAnalyze the contents of the pathname file, which must contain Python code.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "modulefinder.ReplacePackage()", "path": "library/modulefinder#modulefinder.ReplacePackage", "type": "Importing", "text": "\nAllows specifying that the module named oldname is in fact the package named\nnewname.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ModuleNotFoundError", "path": "library/exceptions#ModuleNotFoundError", "type": "Built-in Exceptions", "text": "\nA subclass of `ImportError` which is raised by `import` when a module could\nnot be located. It is also raised when `None` is found in `sys.modules`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib", "path": "library/msilib", "type": "MS Windows", "text": "\nSource code: Lib/msilib/__init__.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.add_data()", "path": "library/msilib#msilib.add_data", "type": "MS Windows", "text": "\nAdd all records to the table named table in database.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.add_stream()", "path": "library/msilib#msilib.add_stream", "type": "MS Windows", "text": "\nAdd the file path into the `_Stream` table of database, with the stream name\nname.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.add_tables()", "path": "library/msilib#msilib.add_tables", "type": "MS Windows", "text": "\nAdd all table content from module to database. module must contain an\nattribute tables listing all tables for which content should be added, and one\nattribute per table that has the actual content.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.Binary", "path": "library/msilib#msilib.Binary", "type": "MS Windows", "text": "\nRepresents entries in the Binary table; inserting such an object using\n`add_data()` reads the file named filename into the table.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.CAB", "path": "library/msilib#msilib.CAB", "type": "MS Windows", "text": "\nThe class `CAB` represents a CAB file. During MSI construction, files will be\nadded simultaneously to the `Files` table, and to a CAB file. Then, when all\nfiles have been added, the CAB file can be written, then added to the MSI\nfile.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.CAB.append()", "path": "library/msilib#msilib.CAB.append", "type": "MS Windows", "text": "\nAdd the file with the pathname full to the CAB file, under the name logical.\nIf there is already a file named logical, a new file name is created.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.CAB.commit()", "path": "library/msilib#msilib.CAB.commit", "type": "MS Windows", "text": "\nGenerate a CAB file, add it as a stream to the MSI file, put it into the\n`Media` table, and remove the generated file from the disk.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.Control", "path": "library/msilib#msilib.Control", "type": "MS Windows", "text": "\nBase class of the dialog controls. dlg is the dialog object the control\nbelongs to, and name is the control\u2019s name.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.Control.condition()", "path": "library/msilib#msilib.Control.condition", "type": "MS Windows", "text": "\nMake an entry into the `ControlCondition` table for this control.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.Control.event()", "path": "library/msilib#msilib.Control.event", "type": "MS Windows", "text": "\nMake an entry into the `ControlEvent` table for this control.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.Control.mapping()", "path": "library/msilib#msilib.Control.mapping", "type": "MS Windows", "text": "\nMake an entry into the `EventMapping` table for this control.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.CreateRecord()", "path": "library/msilib#msilib.CreateRecord", "type": "MS Windows", "text": "\nReturn a new record object by calling `MSICreateRecord()`. count is the number\nof fields of the record.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.Database.Close()", "path": "library/msilib#msilib.Database.Close", "type": "MS Windows", "text": "\nClose the database object, through `MsiCloseHandle()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.Database.Commit()", "path": "library/msilib#msilib.Database.Commit", "type": "MS Windows", "text": "\nCommit the changes pending in the current transaction, by calling\n`MSIDatabaseCommit()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.Database.GetSummaryInformation()", "path": "library/msilib#msilib.Database.GetSummaryInformation", "type": "MS Windows", "text": "\nReturn a new summary information object, by calling\n`MsiGetSummaryInformation()`. count is the maximum number of updated values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.Database.OpenView()", "path": "library/msilib#msilib.Database.OpenView", "type": "MS Windows", "text": "\nReturn a view object, by calling `MSIDatabaseOpenView()`. sql is the SQL\nstatement to execute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.Dialog", "path": "library/msilib#msilib.Dialog", "type": "MS Windows", "text": "\nReturn a new `Dialog` object. An entry in the `Dialog` table is made, with the\nspecified coordinates, dialog attributes, title, name of the first, default,\nand cancel controls.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.Dialog.bitmap()", "path": "library/msilib#msilib.Dialog.bitmap", "type": "MS Windows", "text": "\nAdd and return a `Bitmap` control.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.Dialog.checkbox()", "path": "library/msilib#msilib.Dialog.checkbox", "type": "MS Windows", "text": "\nAdd and return a `CheckBox` control.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.Dialog.control()", "path": "library/msilib#msilib.Dialog.control", "type": "MS Windows", "text": "\nReturn a new `Control` object. An entry in the `Control` table is made with\nthe specified parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.Dialog.line()", "path": "library/msilib#msilib.Dialog.line", "type": "MS Windows", "text": "\nAdd and return a `Line` control.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.Dialog.pushbutton()", "path": "library/msilib#msilib.Dialog.pushbutton", "type": "MS Windows", "text": "\nAdd and return a `PushButton` control.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.Dialog.radiogroup()", "path": "library/msilib#msilib.Dialog.radiogroup", "type": "MS Windows", "text": "\nAdd and return a `RadioButtonGroup` control.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.Dialog.text()", "path": "library/msilib#msilib.Dialog.text", "type": "MS Windows", "text": "\nAdd and return a `Text` control.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.Directory", "path": "library/msilib#msilib.Directory", "type": "MS Windows", "text": "\nCreate a new directory in the Directory table. There is a current component at\neach point in time for the directory, which is either explicitly created\nthrough `start_component()`, or implicitly when files are added for the first\ntime. Files are added into the current component, and into the cab file. To\ncreate a directory, a base directory object needs to be specified (can be\n`None`), the path to the physical directory, and a logical directory name.\ndefault specifies the DefaultDir slot in the directory table. componentflags\nspecifies the default flags that new components get.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.Directory.add_file()", "path": "library/msilib#msilib.Directory.add_file", "type": "MS Windows", "text": "\nAdd a file to the current component of the directory, starting a new one if\nthere is no current component. By default, the file name in the source and the\nfile table will be identical. If the src file is specified, it is interpreted\nrelative to the current directory. Optionally, a version and a language can be\nspecified for the entry in the File table.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.Directory.glob()", "path": "library/msilib#msilib.Directory.glob", "type": "MS Windows", "text": "\nAdd a list of files to the current component as specified in the glob pattern.\nIndividual files can be excluded in the exclude list.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.Directory.remove_pyc()", "path": "library/msilib#msilib.Directory.remove_pyc", "type": "MS Windows", "text": "\nRemove `.pyc` files on uninstall.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.Directory.start_component()", "path": "library/msilib#msilib.Directory.start_component", "type": "MS Windows", "text": "\nAdd an entry to the Component table, and make this component the current\ncomponent for this directory. If no component name is given, the directory\nname is used. If no feature is given, the current feature is used. If no flags\nare given, the directory\u2019s default flags are used. If no keyfile is given, the\nKeyPath is left null in the Component table.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.FCICreate()", "path": "library/msilib#msilib.FCICreate", "type": "MS Windows", "text": "\nCreate a new CAB file named cabname. files must be a list of tuples, each\ncontaining the name of the file on disk, and the name of the file inside the\nCAB file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.Feature", "path": "library/msilib#msilib.Feature", "type": "MS Windows", "text": "\nAdd a new record to the `Feature` table, using the values id, parent.id,\ntitle, desc, display, level, directory, and attributes. The resulting feature\nobject can be passed to the `start_component()` method of `Directory`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.Feature.set_current()", "path": "library/msilib#msilib.Feature.set_current", "type": "MS Windows", "text": "\nMake this feature the current feature of `msilib`. New components are\nautomatically added to the default feature, unless a feature is explicitly\nspecified.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.gen_uuid()", "path": "library/msilib#msilib.gen_uuid", "type": "MS Windows", "text": "\nReturn a new UUID, in the format that MSI typically requires (i.e. in curly\nbraces, and with all hexdigits in upper-case).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.init_database()", "path": "library/msilib#msilib.init_database", "type": "MS Windows", "text": "\nCreate and return a new database name, initialize it with schema, and set the\nproperties ProductName, ProductCode, ProductVersion, and Manufacturer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.OpenDatabase()", "path": "library/msilib#msilib.OpenDatabase", "type": "MS Windows", "text": "\nReturn a new database object by calling MsiOpenDatabase. path is the file name\nof the MSI file; persist can be one of the constants `MSIDBOPEN_CREATEDIRECT`,\n`MSIDBOPEN_CREATE`, `MSIDBOPEN_DIRECT`, `MSIDBOPEN_READONLY`, or\n`MSIDBOPEN_TRANSACT`, and may include the flag `MSIDBOPEN_PATCHFILE`. See the\nMicrosoft documentation for the meaning of these flags; depending on the\nflags, an existing database is opened, or a new one created.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.RadioButtonGroup", "path": "library/msilib#msilib.RadioButtonGroup", "type": "MS Windows", "text": "\nCreate a radio button control named name. property is the installer property\nthat gets set when a radio button is selected.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.RadioButtonGroup.add()", "path": "library/msilib#msilib.RadioButtonGroup.add", "type": "MS Windows", "text": "\nAdd a radio button named name to the group, at the coordinates x, y, width,\nheight, and with the label text. If value is `None`, it defaults to name.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.Record.ClearData()", "path": "library/msilib#msilib.Record.ClearData", "type": "MS Windows", "text": "\nSet all fields of the record to 0, through `MsiRecordClearData()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.Record.GetFieldCount()", "path": "library/msilib#msilib.Record.GetFieldCount", "type": "MS Windows", "text": "\nReturn the number of fields of the record, through `MsiRecordGetFieldCount()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.Record.GetInteger()", "path": "library/msilib#msilib.Record.GetInteger", "type": "MS Windows", "text": "\nReturn the value of field as an integer where possible. field must be an\ninteger.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.Record.GetString()", "path": "library/msilib#msilib.Record.GetString", "type": "MS Windows", "text": "\nReturn the value of field as a string where possible. field must be an\ninteger.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.Record.SetInteger()", "path": "library/msilib#msilib.Record.SetInteger", "type": "MS Windows", "text": "\nSet field to value through `MsiRecordSetInteger()`. Both field and value must\nbe an integer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.Record.SetStream()", "path": "library/msilib#msilib.Record.SetStream", "type": "MS Windows", "text": "\nSet field to the contents of the file named value, through\n`MsiRecordSetStream()`. field must be an integer; value a string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.Record.SetString()", "path": "library/msilib#msilib.Record.SetString", "type": "MS Windows", "text": "\nSet field to value through `MsiRecordSetString()`. field must be an integer;\nvalue a string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.schema", "path": "library/msilib#msilib.schema", "type": "MS Windows", "text": "\nThis is the standard MSI schema for MSI 2.0, with the tables variable\nproviding a list of table definitions, and _Validation_records providing the\ndata for MSI validation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.sequence", "path": "library/msilib#msilib.sequence", "type": "MS Windows", "text": "\nThis module contains table contents for the standard sequence tables:\nAdminExecuteSequence, AdminUISequence, AdvtExecuteSequence,\nInstallExecuteSequence, and InstallUISequence.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.SummaryInformation.GetProperty()", "path": "library/msilib#msilib.SummaryInformation.GetProperty", "type": "MS Windows", "text": "\nReturn a property of the summary, through `MsiSummaryInfoGetProperty()`. field\nis the name of the property, and can be one of the constants `PID_CODEPAGE`,\n`PID_TITLE`, `PID_SUBJECT`, `PID_AUTHOR`, `PID_KEYWORDS`, `PID_COMMENTS`,\n`PID_TEMPLATE`, `PID_LASTAUTHOR`, `PID_REVNUMBER`, `PID_LASTPRINTED`,\n`PID_CREATE_DTM`, `PID_LASTSAVE_DTM`, `PID_PAGECOUNT`, `PID_WORDCOUNT`,\n`PID_CHARCOUNT`, `PID_APPNAME`, or `PID_SECURITY`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.SummaryInformation.GetPropertyCount()", "path": "library/msilib#msilib.SummaryInformation.GetPropertyCount", "type": "MS Windows", "text": "\nReturn the number of summary properties, through\n`MsiSummaryInfoGetPropertyCount()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.SummaryInformation.Persist()", "path": "library/msilib#msilib.SummaryInformation.Persist", "type": "MS Windows", "text": "\nWrite the modified properties to the summary information stream, using\n`MsiSummaryInfoPersist()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.SummaryInformation.SetProperty()", "path": "library/msilib#msilib.SummaryInformation.SetProperty", "type": "MS Windows", "text": "\nSet a property through `MsiSummaryInfoSetProperty()`. field can have the same\nvalues as in `GetProperty()`, value is the new value of the property. Possible\nvalue types are integer and string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.text", "path": "library/msilib#msilib.text", "type": "MS Windows", "text": "\nThis module contains definitions for the UIText and ActionText tables, for the\nstandard installer actions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.UuidCreate()", "path": "library/msilib#msilib.UuidCreate", "type": "MS Windows", "text": "\nReturn the string representation of a new unique identifier. This wraps the\nWindows API functions `UuidCreate()` and `UuidToString()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.View.Close()", "path": "library/msilib#msilib.View.Close", "type": "MS Windows", "text": "\nClose the view, through `MsiViewClose()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.View.Execute()", "path": "library/msilib#msilib.View.Execute", "type": "MS Windows", "text": "\nExecute the SQL query of the view, through `MSIViewExecute()`. If params is\nnot `None`, it is a record describing actual values of the parameter tokens in\nthe query.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.View.Fetch()", "path": "library/msilib#msilib.View.Fetch", "type": "MS Windows", "text": "\nReturn a result record of the query, through calling `MsiViewFetch()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.View.GetColumnInfo()", "path": "library/msilib#msilib.View.GetColumnInfo", "type": "MS Windows", "text": "\nReturn a record describing the columns of the view, through calling\n`MsiViewGetColumnInfo()`. kind can be either `MSICOLINFO_NAMES` or\n`MSICOLINFO_TYPES`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msilib.View.Modify()", "path": "library/msilib#msilib.View.Modify", "type": "MS Windows", "text": "\nModify the view, by calling `MsiViewModify()`. kind can be one of\n`MSIMODIFY_SEEK`, `MSIMODIFY_REFRESH`, `MSIMODIFY_INSERT`, `MSIMODIFY_UPDATE`,\n`MSIMODIFY_ASSIGN`, `MSIMODIFY_REPLACE`, `MSIMODIFY_MERGE`,\n`MSIMODIFY_DELETE`, `MSIMODIFY_INSERT_TEMPORARY`, `MSIMODIFY_VALIDATE`,\n`MSIMODIFY_VALIDATE_NEW`, `MSIMODIFY_VALIDATE_FIELD`, or\n`MSIMODIFY_VALIDATE_DELETE`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msvcrt", "path": "library/msvcrt", "type": "MS Windows", "text": "\nThese functions provide access to some useful capabilities on Windows\nplatforms. Some higher-level modules use these functions to build the Windows\nimplementations of their services. For example, the `getpass` module uses this\nin the implementation of the `getpass()` function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msvcrt.getch()", "path": "library/msvcrt#msvcrt.getch", "type": "MS Windows", "text": "\nRead a keypress and return the resulting character as a byte string. Nothing\nis echoed to the console. This call will block if a keypress is not already\navailable, but will not wait for `Enter` to be pressed. If the pressed key was\na special function key, this will return `'\\000'` or `'\\xe0'`; the next call\nwill return the keycode. The `Control-C` keypress cannot be read with this\nfunction.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msvcrt.getche()", "path": "library/msvcrt#msvcrt.getche", "type": "MS Windows", "text": "\nSimilar to `getch()`, but the keypress will be echoed if it represents a\nprintable character.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msvcrt.getwch()", "path": "library/msvcrt#msvcrt.getwch", "type": "MS Windows", "text": "\nWide char variant of `getch()`, returning a Unicode value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msvcrt.getwche()", "path": "library/msvcrt#msvcrt.getwche", "type": "MS Windows", "text": "\nWide char variant of `getche()`, returning a Unicode value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msvcrt.get_osfhandle()", "path": "library/msvcrt#msvcrt.get_osfhandle", "type": "MS Windows", "text": "\nReturn the file handle for the file descriptor fd. Raises `OSError` if fd is\nnot recognized.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msvcrt.heapmin()", "path": "library/msvcrt#msvcrt.heapmin", "type": "MS Windows", "text": "\nForce the `malloc()` heap to clean itself up and return unused blocks to the\noperating system. On failure, this raises `OSError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msvcrt.kbhit()", "path": "library/msvcrt#msvcrt.kbhit", "type": "MS Windows", "text": "\nReturn `True` if a keypress is waiting to be read.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msvcrt.LK_LOCK", "path": "library/msvcrt#msvcrt.LK_LOCK", "type": "MS Windows", "text": "\nLocks the specified bytes. If the bytes cannot be locked, the program\nimmediately tries again after 1 second. If, after 10 attempts, the bytes\ncannot be locked, `OSError` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msvcrt.LK_NBLCK", "path": "library/msvcrt#msvcrt.LK_NBLCK", "type": "MS Windows", "text": "\nLocks the specified bytes. If the bytes cannot be locked, `OSError` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msvcrt.LK_NBRLCK", "path": "library/msvcrt#msvcrt.LK_NBRLCK", "type": "MS Windows", "text": "\nLocks the specified bytes. If the bytes cannot be locked, `OSError` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msvcrt.LK_RLCK", "path": "library/msvcrt#msvcrt.LK_RLCK", "type": "MS Windows", "text": "\nLocks the specified bytes. If the bytes cannot be locked, the program\nimmediately tries again after 1 second. If, after 10 attempts, the bytes\ncannot be locked, `OSError` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msvcrt.LK_UNLCK", "path": "library/msvcrt#msvcrt.LK_UNLCK", "type": "MS Windows", "text": "\nUnlocks the specified bytes, which must have been previously locked.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msvcrt.locking()", "path": "library/msvcrt#msvcrt.locking", "type": "MS Windows", "text": "\nLock part of a file based on file descriptor fd from the C runtime. Raises\n`OSError` on failure. The locked region of the file extends from the current\nfile position for nbytes bytes, and may continue beyond the end of the file.\nmode must be one of the `LK_*` constants listed below. Multiple regions in a\nfile may be locked at the same time, but may not overlap. Adjacent regions are\nnot merged; they must be unlocked individually.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msvcrt.open_osfhandle()", "path": "library/msvcrt#msvcrt.open_osfhandle", "type": "MS Windows", "text": "\nCreate a C runtime file descriptor from the file handle handle. The flags\nparameter should be a bitwise OR of `os.O_APPEND`, `os.O_RDONLY`, and\n`os.O_TEXT`. The returned file descriptor may be used as a parameter to\n`os.fdopen()` to create a file object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msvcrt.putch()", "path": "library/msvcrt#msvcrt.putch", "type": "MS Windows", "text": "\nPrint the byte string char to the console without buffering.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msvcrt.putwch()", "path": "library/msvcrt#msvcrt.putwch", "type": "MS Windows", "text": "\nWide char variant of `putch()`, accepting a Unicode value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msvcrt.setmode()", "path": "library/msvcrt#msvcrt.setmode", "type": "MS Windows", "text": "\nSet the line-end translation mode for the file descriptor fd. To set it to\ntext mode, flags should be `os.O_TEXT`; for binary, it should be\n`os.O_BINARY`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msvcrt.ungetch()", "path": "library/msvcrt#msvcrt.ungetch", "type": "MS Windows", "text": "\nCause the byte string char to be \u201cpushed back\u201d into the console buffer; it\nwill be the next character read by `getch()` or `getche()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "msvcrt.ungetwch()", "path": "library/msvcrt#msvcrt.ungetwch", "type": "MS Windows", "text": "\nWide char variant of `ungetch()`, accepting a Unicode value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing", "path": "library/multiprocessing", "type": "Concurrent Execution", "text": "\nSource code: Lib/multiprocessing/\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.active_children()", "path": "library/multiprocessing#multiprocessing.active_children", "type": "Concurrent Execution", "text": "\nReturn list of all live children of the current process.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.Array()", "path": "library/multiprocessing#multiprocessing.Array", "type": "Concurrent Execution", "text": "\nReturn a ctypes array allocated from shared memory. By default the return\nvalue is actually a synchronized wrapper for the array.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.AuthenticationError", "path": "library/multiprocessing#multiprocessing.AuthenticationError", "type": "Concurrent Execution", "text": "\nRaised when there is an authentication error.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.Barrier", "path": "library/multiprocessing#multiprocessing.Barrier", "type": "Concurrent Execution", "text": "\nA barrier object: a clone of `threading.Barrier`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.BoundedSemaphore", "path": "library/multiprocessing#multiprocessing.BoundedSemaphore", "type": "Concurrent Execution", "text": "\nA bounded semaphore object: a close analog of `threading.BoundedSemaphore`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.BufferTooShort", "path": "library/multiprocessing#multiprocessing.BufferTooShort", "type": "Concurrent Execution", "text": "\nException raised by `Connection.recv_bytes_into()` when the supplied buffer\nobject is too small for the message read.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.Condition", "path": "library/multiprocessing#multiprocessing.Condition", "type": "Concurrent Execution", "text": "\nA condition variable: an alias for `threading.Condition`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.connection.answer_challenge()", "path": "library/multiprocessing#multiprocessing.connection.answer_challenge", "type": "Concurrent Execution", "text": "\nReceive a message, calculate the digest of the message using authkey as the\nkey, and then send the digest back.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.connection.Client()", "path": "library/multiprocessing#multiprocessing.connection.Client", "type": "Concurrent Execution", "text": "\nAttempt to set up a connection to the listener which is using address address,\nreturning a `Connection`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.connection.Connection", "path": "library/multiprocessing#multiprocessing.connection.Connection", "type": "Concurrent Execution", "text": "\nSend an object to the other end of the connection which should be read using\n`recv()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.connection.Connection.close()", "path": "library/multiprocessing#multiprocessing.connection.Connection.close", "type": "Concurrent Execution", "text": "\nClose the connection.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.connection.Connection.fileno()", "path": "library/multiprocessing#multiprocessing.connection.Connection.fileno", "type": "Concurrent Execution", "text": "\nReturn the file descriptor or handle used by the connection.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.connection.Connection.poll()", "path": "library/multiprocessing#multiprocessing.connection.Connection.poll", "type": "Concurrent Execution", "text": "\nReturn whether there is any data available to be read.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.connection.Connection.recv()", "path": "library/multiprocessing#multiprocessing.connection.Connection.recv", "type": "Concurrent Execution", "text": "\nReturn an object sent from the other end of the connection using `send()`.\nBlocks until there is something to receive. Raises `EOFError` if there is\nnothing left to receive and the other end was closed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.connection.Connection.recv_bytes()", "path": "library/multiprocessing#multiprocessing.connection.Connection.recv_bytes", "type": "Concurrent Execution", "text": "\nReturn a complete message of byte data sent from the other end of the\nconnection as a string. Blocks until there is something to receive. Raises\n`EOFError` if there is nothing left to receive and the other end has closed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.connection.Connection.recv_bytes_into()", "path": "library/multiprocessing#multiprocessing.connection.Connection.recv_bytes_into", "type": "Concurrent Execution", "text": "\nRead into buffer a complete message of byte data sent from the other end of\nthe connection and return the number of bytes in the message. Blocks until\nthere is something to receive. Raises `EOFError` if there is nothing left to\nreceive and the other end was closed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.connection.Connection.send()", "path": "library/multiprocessing#multiprocessing.connection.Connection.send", "type": "Concurrent Execution", "text": "\nSend an object to the other end of the connection which should be read using\n`recv()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.connection.Connection.send_bytes()", "path": "library/multiprocessing#multiprocessing.connection.Connection.send_bytes", "type": "Concurrent Execution", "text": "\nSend byte data from a bytes-like object as a complete message.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.connection.deliver_challenge()", "path": "library/multiprocessing#multiprocessing.connection.deliver_challenge", "type": "Concurrent Execution", "text": "\nSend a randomly generated message to the other end of the connection and wait\nfor a reply.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.connection.Listener", "path": "library/multiprocessing#multiprocessing.connection.Listener", "type": "Concurrent Execution", "text": "\nA wrapper for a bound socket or Windows named pipe which is \u2018listening\u2019 for\nconnections.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.connection.Listener.accept()", "path": "library/multiprocessing#multiprocessing.connection.Listener.accept", "type": "Concurrent Execution", "text": "\nAccept a connection on the bound socket or named pipe of the listener object\nand return a `Connection` object. If authentication is attempted and fails,\nthen `AuthenticationError` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.connection.Listener.address", "path": "library/multiprocessing#multiprocessing.connection.Listener.address", "type": "Concurrent Execution", "text": "\nThe address which is being used by the Listener object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.connection.Listener.close()", "path": "library/multiprocessing#multiprocessing.connection.Listener.close", "type": "Concurrent Execution", "text": "\nClose the bound socket or named pipe of the listener object. This is called\nautomatically when the listener is garbage collected. However it is advisable\nto call it explicitly.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.connection.Listener.last_accepted", "path": "library/multiprocessing#multiprocessing.connection.Listener.last_accepted", "type": "Concurrent Execution", "text": "\nThe address from which the last accepted connection came. If this is\nunavailable then it is `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.connection.wait()", "path": "library/multiprocessing#multiprocessing.connection.wait", "type": "Concurrent Execution", "text": "\nWait till an object in object_list is ready. Returns the list of those objects\nin object_list which are ready. If timeout is a float then the call blocks for\nat most that many seconds. If timeout is `None` then it will block for an\nunlimited period. A negative timeout is equivalent to a zero timeout.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.cpu_count()", "path": "library/multiprocessing#multiprocessing.cpu_count", "type": "Concurrent Execution", "text": "\nReturn the number of CPUs in the system.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.current_process()", "path": "library/multiprocessing#multiprocessing.current_process", "type": "Concurrent Execution", "text": "\nReturn the `Process` object corresponding to the current process.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.Event", "path": "library/multiprocessing#multiprocessing.Event", "type": "Concurrent Execution", "text": "\nA clone of `threading.Event`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.freeze_support()", "path": "library/multiprocessing#multiprocessing.freeze_support", "type": "Concurrent Execution", "text": "\nAdd support for when a program which uses `multiprocessing` has been frozen to\nproduce a Windows executable. (Has been tested with py2exe, PyInstaller and\ncx_Freeze.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.get_all_start_methods()", "path": "library/multiprocessing#multiprocessing.get_all_start_methods", "type": "Concurrent Execution", "text": "\nReturns a list of the supported start methods, the first of which is the\ndefault. The possible start methods are `'fork'`, `'spawn'` and\n`'forkserver'`. On Windows only `'spawn'` is available. On Unix `'fork'` and\n`'spawn'` are always supported, with `'fork'` being the default.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.get_context()", "path": "library/multiprocessing#multiprocessing.get_context", "type": "Concurrent Execution", "text": "\nReturn a context object which has the same attributes as the `multiprocessing`\nmodule.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.get_logger()", "path": "library/multiprocessing#multiprocessing.get_logger", "type": "Concurrent Execution", "text": "\nReturns the logger used by `multiprocessing`. If necessary, a new one will be\ncreated.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.get_start_method()", "path": "library/multiprocessing#multiprocessing.get_start_method", "type": "Concurrent Execution", "text": "\nReturn the name of start method used for starting processes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.JoinableQueue", "path": "library/multiprocessing#multiprocessing.JoinableQueue", "type": "Concurrent Execution", "text": "\n`JoinableQueue`, a `Queue` subclass, is a queue which additionally has\n`task_done()` and `join()` methods.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.JoinableQueue.join()", "path": "library/multiprocessing#multiprocessing.JoinableQueue.join", "type": "Concurrent Execution", "text": "\nBlock until all items in the queue have been gotten and processed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.JoinableQueue.task_done()", "path": "library/multiprocessing#multiprocessing.JoinableQueue.task_done", "type": "Concurrent Execution", "text": "\nIndicate that a formerly enqueued task is complete. Used by queue consumers.\nFor each `get()` used to fetch a task, a subsequent call to `task_done()`\ntells the queue that the processing on the task is complete.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.Lock", "path": "library/multiprocessing#multiprocessing.Lock", "type": "Concurrent Execution", "text": "\nA non-recursive lock object: a close analog of `threading.Lock`. Once a\nprocess or thread has acquired a lock, subsequent attempts to acquire it from\nany process or thread will block until it is released; any process or thread\nmay release it. The concepts and behaviors of `threading.Lock` as it applies\nto threads are replicated here in `multiprocessing.Lock` as it applies to\neither processes or threads, except as noted.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.Lock.acquire()", "path": "library/multiprocessing#multiprocessing.Lock.acquire", "type": "Concurrent Execution", "text": "\nAcquire a lock, blocking or non-blocking.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.Lock.release()", "path": "library/multiprocessing#multiprocessing.Lock.release", "type": "Concurrent Execution", "text": "\nRelease a lock. This can be called from any process or thread, not only the\nprocess or thread which originally acquired the lock.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.log_to_stderr()", "path": "library/multiprocessing#multiprocessing.log_to_stderr", "type": "Concurrent Execution", "text": "\nThis function performs a call to `get_logger()` but in addition to returning\nthe logger created by get_logger, it adds a handler which sends output to\n`sys.stderr` using format `'[%(levelname)s/%(processName)s] %(message)s'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.managers.BaseManager", "path": "library/multiprocessing#multiprocessing.managers.BaseManager", "type": "Concurrent Execution", "text": "\nCreate a BaseManager object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.managers.BaseManager.address", "path": "library/multiprocessing#multiprocessing.managers.BaseManager.address", "type": "Concurrent Execution", "text": "\nThe address used by the manager.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.managers.BaseManager.connect()", "path": "library/multiprocessing#multiprocessing.managers.BaseManager.connect", "type": "Concurrent Execution", "text": "\nConnect a local manager object to a remote manager process:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.managers.BaseManager.get_server()", "path": "library/multiprocessing#multiprocessing.managers.BaseManager.get_server", "type": "Concurrent Execution", "text": "\nReturns a `Server` object which represents the actual server under the control\nof the Manager. The `Server` object supports the `serve_forever()` method:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.managers.BaseManager.register()", "path": "library/multiprocessing#multiprocessing.managers.BaseManager.register", "type": "Concurrent Execution", "text": "\nA classmethod which can be used for registering a type or callable with the\nmanager class.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.managers.BaseManager.shutdown()", "path": "library/multiprocessing#multiprocessing.managers.BaseManager.shutdown", "type": "Concurrent Execution", "text": "\nStop the process used by the manager. This is only available if `start()` has\nbeen used to start the server process.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.managers.BaseManager.start()", "path": "library/multiprocessing#multiprocessing.managers.BaseManager.start", "type": "Concurrent Execution", "text": "\nStart a subprocess to start the manager. If initializer is not `None` then the\nsubprocess will call `initializer(*initargs)` when it starts.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.managers.BaseProxy", "path": "library/multiprocessing#multiprocessing.managers.BaseProxy", "type": "Concurrent Execution", "text": "\nProxy objects are instances of subclasses of `BaseProxy`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.managers.BaseProxy._callmethod()", "path": "library/multiprocessing#multiprocessing.managers.BaseProxy._callmethod", "type": "Concurrent Execution", "text": "\nCall and return the result of a method of the proxy\u2019s referent.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.managers.BaseProxy._getvalue()", "path": "library/multiprocessing#multiprocessing.managers.BaseProxy._getvalue", "type": "Concurrent Execution", "text": "\nReturn a copy of the referent.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.managers.BaseProxy.__repr__()", "path": "library/multiprocessing#multiprocessing.managers.BaseProxy.__repr__", "type": "Concurrent Execution", "text": "\nReturn a representation of the proxy object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.managers.BaseProxy.__str__()", "path": "library/multiprocessing#multiprocessing.managers.BaseProxy.__str__", "type": "Concurrent Execution", "text": "\nReturn the representation of the referent.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.managers.Namespace", "path": "library/multiprocessing#multiprocessing.managers.Namespace", "type": "Concurrent Execution", "text": "\nA type that can register with `SyncManager`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.managers.SharedMemoryManager", "path": "library/multiprocessing.shared_memory#multiprocessing.managers.SharedMemoryManager", "type": "Concurrent Execution", "text": "\nA subclass of `BaseManager` which can be used for the management of shared\nmemory blocks across processes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.managers.SharedMemoryManager.ShareableList()", "path": "library/multiprocessing.shared_memory#multiprocessing.managers.SharedMemoryManager.ShareableList", "type": "Concurrent Execution", "text": "\nCreate and return a new `ShareableList` object, initialized by the values from\nthe input `sequence`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.managers.SharedMemoryManager.SharedMemory()", "path": "library/multiprocessing.shared_memory#multiprocessing.managers.SharedMemoryManager.SharedMemory", "type": "Concurrent Execution", "text": "\nCreate and return a new `SharedMemory` object with the specified `size` in\nbytes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.managers.SyncManager", "path": "library/multiprocessing#multiprocessing.managers.SyncManager", "type": "Concurrent Execution", "text": "\nA subclass of `BaseManager` which can be used for the synchronization of\nprocesses. Objects of this type are returned by `multiprocessing.Manager()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.managers.SyncManager.Array()", "path": "library/multiprocessing#multiprocessing.managers.SyncManager.Array", "type": "Concurrent Execution", "text": "\nCreate an array and return a proxy for it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.managers.SyncManager.Barrier()", "path": "library/multiprocessing#multiprocessing.managers.SyncManager.Barrier", "type": "Concurrent Execution", "text": "\nCreate a shared `threading.Barrier` object and return a proxy for it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.managers.SyncManager.BoundedSemaphore()", "path": "library/multiprocessing#multiprocessing.managers.SyncManager.BoundedSemaphore", "type": "Concurrent Execution", "text": "\nCreate a shared `threading.BoundedSemaphore` object and return a proxy for it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.managers.SyncManager.Condition()", "path": "library/multiprocessing#multiprocessing.managers.SyncManager.Condition", "type": "Concurrent Execution", "text": "\nCreate a shared `threading.Condition` object and return a proxy for it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.managers.SyncManager.dict()", "path": "library/multiprocessing#multiprocessing.managers.SyncManager.dict", "type": "Concurrent Execution", "text": "\nCreate a shared `dict` object and return a proxy for it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.managers.SyncManager.Event()", "path": "library/multiprocessing#multiprocessing.managers.SyncManager.Event", "type": "Concurrent Execution", "text": "\nCreate a shared `threading.Event` object and return a proxy for it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.managers.SyncManager.list()", "path": "library/multiprocessing#multiprocessing.managers.SyncManager.list", "type": "Concurrent Execution", "text": "\nCreate a shared `list` object and return a proxy for it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.managers.SyncManager.Lock()", "path": "library/multiprocessing#multiprocessing.managers.SyncManager.Lock", "type": "Concurrent Execution", "text": "\nCreate a shared `threading.Lock` object and return a proxy for it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.managers.SyncManager.Namespace()", "path": "library/multiprocessing#multiprocessing.managers.SyncManager.Namespace", "type": "Concurrent Execution", "text": "\nCreate a shared `Namespace` object and return a proxy for it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.managers.SyncManager.Queue()", "path": "library/multiprocessing#multiprocessing.managers.SyncManager.Queue", "type": "Concurrent Execution", "text": "\nCreate a shared `queue.Queue` object and return a proxy for it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.managers.SyncManager.RLock()", "path": "library/multiprocessing#multiprocessing.managers.SyncManager.RLock", "type": "Concurrent Execution", "text": "\nCreate a shared `threading.RLock` object and return a proxy for it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.managers.SyncManager.Semaphore()", "path": "library/multiprocessing#multiprocessing.managers.SyncManager.Semaphore", "type": "Concurrent Execution", "text": "\nCreate a shared `threading.Semaphore` object and return a proxy for it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.managers.SyncManager.Value()", "path": "library/multiprocessing#multiprocessing.managers.SyncManager.Value", "type": "Concurrent Execution", "text": "\nCreate an object with a writable `value` attribute and return a proxy for it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.parent_process()", "path": "library/multiprocessing#multiprocessing.parent_process", "type": "Concurrent Execution", "text": "\nReturn the `Process` object corresponding to the parent process of the\n`current_process()`. For the main process, `parent_process` will be `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.Pipe()", "path": "library/multiprocessing#multiprocessing.Pipe", "type": "Concurrent Execution", "text": "\nReturns a pair `(conn1, conn2)` of `Connection` objects representing the ends\nof a pipe.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.pool.AsyncResult", "path": "library/multiprocessing#multiprocessing.pool.AsyncResult", "type": "Concurrent Execution", "text": "\nThe class of the result returned by `Pool.apply_async()` and\n`Pool.map_async()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.pool.AsyncResult.get()", "path": "library/multiprocessing#multiprocessing.pool.AsyncResult.get", "type": "Concurrent Execution", "text": "\nReturn the result when it arrives. If timeout is not `None` and the result\ndoes not arrive within timeout seconds then `multiprocessing.TimeoutError` is\nraised. If the remote call raised an exception then that exception will be\nreraised by `get()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.pool.AsyncResult.ready()", "path": "library/multiprocessing#multiprocessing.pool.AsyncResult.ready", "type": "Concurrent Execution", "text": "\nReturn whether the call has completed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.pool.AsyncResult.successful()", "path": "library/multiprocessing#multiprocessing.pool.AsyncResult.successful", "type": "Concurrent Execution", "text": "\nReturn whether the call completed without raising an exception. Will raise\n`ValueError` if the result is not ready.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.pool.AsyncResult.wait()", "path": "library/multiprocessing#multiprocessing.pool.AsyncResult.wait", "type": "Concurrent Execution", "text": "\nWait until the result is available or until timeout seconds pass.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.pool.Pool", "path": "library/multiprocessing#multiprocessing.pool.Pool", "type": "Concurrent Execution", "text": "\nA process pool object which controls a pool of worker processes to which jobs\ncan be submitted. It supports asynchronous results with timeouts and callbacks\nand has a parallel map implementation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.pool.Pool.apply()", "path": "library/multiprocessing#multiprocessing.pool.Pool.apply", "type": "Concurrent Execution", "text": "\nCall func with arguments args and keyword arguments kwds. It blocks until the\nresult is ready. Given this blocks, `apply_async()` is better suited for\nperforming work in parallel. Additionally, func is only executed in one of the\nworkers of the pool.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.pool.Pool.apply_async()", "path": "library/multiprocessing#multiprocessing.pool.Pool.apply_async", "type": "Concurrent Execution", "text": "\nA variant of the `apply()` method which returns a `AsyncResult` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.pool.Pool.close()", "path": "library/multiprocessing#multiprocessing.pool.Pool.close", "type": "Concurrent Execution", "text": "\nPrevents any more tasks from being submitted to the pool. Once all the tasks\nhave been completed the worker processes will exit.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.pool.Pool.imap()", "path": "library/multiprocessing#multiprocessing.pool.Pool.imap", "type": "Concurrent Execution", "text": "\nA lazier version of `map()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.pool.Pool.imap_unordered()", "path": "library/multiprocessing#multiprocessing.pool.Pool.imap_unordered", "type": "Concurrent Execution", "text": "\nThe same as `imap()` except that the ordering of the results from the returned\niterator should be considered arbitrary. (Only when there is only one worker\nprocess is the order guaranteed to be \u201ccorrect\u201d.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.pool.Pool.join()", "path": "library/multiprocessing#multiprocessing.pool.Pool.join", "type": "Concurrent Execution", "text": "\nWait for the worker processes to exit. One must call `close()` or\n`terminate()` before using `join()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.pool.Pool.map()", "path": "library/multiprocessing#multiprocessing.pool.Pool.map", "type": "Concurrent Execution", "text": "\nA parallel equivalent of the `map()` built-in function (it supports only one\niterable argument though, for multiple iterables see `starmap()`). It blocks\nuntil the result is ready.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.pool.Pool.map_async()", "path": "library/multiprocessing#multiprocessing.pool.Pool.map_async", "type": "Concurrent Execution", "text": "\nA variant of the `map()` method which returns a `AsyncResult` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.pool.Pool.starmap()", "path": "library/multiprocessing#multiprocessing.pool.Pool.starmap", "type": "Concurrent Execution", "text": "\nLike `map()` except that the elements of the iterable are expected to be\niterables that are unpacked as arguments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.pool.Pool.starmap_async()", "path": "library/multiprocessing#multiprocessing.pool.Pool.starmap_async", "type": "Concurrent Execution", "text": "\nA combination of `starmap()` and `map_async()` that iterates over iterable of\niterables and calls func with the iterables unpacked. Returns a result object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.pool.Pool.terminate()", "path": "library/multiprocessing#multiprocessing.pool.Pool.terminate", "type": "Concurrent Execution", "text": "\nStops the worker processes immediately without completing outstanding work.\nWhen the pool object is garbage collected `terminate()` will be called\nimmediately.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.pool.ThreadPool", "path": "library/multiprocessing#multiprocessing.pool.ThreadPool", "type": "Concurrent Execution", "text": "\nA thread pool object which controls a pool of worker threads to which jobs can\nbe submitted. `ThreadPool` instances are fully interface compatible with\n`Pool` instances, and their resources must also be properly managed, either by\nusing the pool as a context manager or by calling `close()` and `terminate()`\nmanually.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.Process", "path": "library/multiprocessing#multiprocessing.Process", "type": "Concurrent Execution", "text": "\nProcess objects represent activity that is run in a separate process. The\n`Process` class has equivalents of all the methods of `threading.Thread`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.Process.authkey", "path": "library/multiprocessing#multiprocessing.Process.authkey", "type": "Concurrent Execution", "text": "\nThe process\u2019s authentication key (a byte string).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.Process.close()", "path": "library/multiprocessing#multiprocessing.Process.close", "type": "Concurrent Execution", "text": "\nClose the `Process` object, releasing all resources associated with it.\n`ValueError` is raised if the underlying process is still running. Once\n`close()` returns successfully, most other methods and attributes of the\n`Process` object will raise `ValueError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.Process.daemon", "path": "library/multiprocessing#multiprocessing.Process.daemon", "type": "Concurrent Execution", "text": "\nThe process\u2019s daemon flag, a Boolean value. This must be set before `start()`\nis called.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.Process.exitcode", "path": "library/multiprocessing#multiprocessing.Process.exitcode", "type": "Concurrent Execution", "text": "\nThe child\u2019s exit code. This will be `None` if the process has not yet\nterminated. A negative value -N indicates that the child was terminated by\nsignal N.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.Process.is_alive()", "path": "library/multiprocessing#multiprocessing.Process.is_alive", "type": "Concurrent Execution", "text": "\nReturn whether the process is alive.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.Process.join()", "path": "library/multiprocessing#multiprocessing.Process.join", "type": "Concurrent Execution", "text": "\nIf the optional argument timeout is `None` (the default), the method blocks\nuntil the process whose `join()` method is called terminates. If timeout is a\npositive number, it blocks at most timeout seconds. Note that the method\nreturns `None` if its process terminates or if the method times out. Check the\nprocess\u2019s `exitcode` to determine if it terminated.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.Process.kill()", "path": "library/multiprocessing#multiprocessing.Process.kill", "type": "Concurrent Execution", "text": "\nSame as `terminate()` but using the `SIGKILL` signal on Unix.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.Process.name", "path": "library/multiprocessing#multiprocessing.Process.name", "type": "Concurrent Execution", "text": "\nThe process\u2019s name. The name is a string used for identification purposes\nonly. It has no semantics. Multiple processes may be given the same name.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.Process.pid", "path": "library/multiprocessing#multiprocessing.Process.pid", "type": "Concurrent Execution", "text": "\nReturn the process ID. Before the process is spawned, this will be `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.Process.run()", "path": "library/multiprocessing#multiprocessing.Process.run", "type": "Concurrent Execution", "text": "\nMethod representing the process\u2019s activity.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.Process.sentinel", "path": "library/multiprocessing#multiprocessing.Process.sentinel", "type": "Concurrent Execution", "text": "\nA numeric handle of a system object which will become \u201cready\u201d when the process\nends.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.Process.start()", "path": "library/multiprocessing#multiprocessing.Process.start", "type": "Concurrent Execution", "text": "\nStart the process\u2019s activity.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.Process.terminate()", "path": "library/multiprocessing#multiprocessing.Process.terminate", "type": "Concurrent Execution", "text": "\nTerminate the process. On Unix this is done using the `SIGTERM` signal; on\nWindows `TerminateProcess()` is used. Note that exit handlers and finally\nclauses, etc., will not be executed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.ProcessError", "path": "library/multiprocessing#multiprocessing.ProcessError", "type": "Concurrent Execution", "text": "\nThe base class of all `multiprocessing` exceptions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.Queue", "path": "library/multiprocessing#multiprocessing.Queue", "type": "Concurrent Execution", "text": "\nReturns a process shared queue implemented using a pipe and a few\nlocks/semaphores. When a process first puts an item on the queue a feeder\nthread is started which transfers objects from a buffer into the pipe.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.Queue.cancel_join_thread()", "path": "library/multiprocessing#multiprocessing.Queue.cancel_join_thread", "type": "Concurrent Execution", "text": "\nPrevent `join_thread()` from blocking. In particular, this prevents the\nbackground thread from being joined automatically when the process exits \u2013 see\n`join_thread()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.Queue.close()", "path": "library/multiprocessing#multiprocessing.Queue.close", "type": "Concurrent Execution", "text": "\nIndicate that no more data will be put on this queue by the current process.\nThe background thread will quit once it has flushed all buffered data to the\npipe. This is called automatically when the queue is garbage collected.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.Queue.empty()", "path": "library/multiprocessing#multiprocessing.Queue.empty", "type": "Concurrent Execution", "text": "\nReturn `True` if the queue is empty, `False` otherwise. Because of\nmultithreading/multiprocessing semantics, this is not reliable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.Queue.full()", "path": "library/multiprocessing#multiprocessing.Queue.full", "type": "Concurrent Execution", "text": "\nReturn `True` if the queue is full, `False` otherwise. Because of\nmultithreading/multiprocessing semantics, this is not reliable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.Queue.get()", "path": "library/multiprocessing#multiprocessing.Queue.get", "type": "Concurrent Execution", "text": "\nRemove and return an item from the queue. If optional args block is `True`\n(the default) and timeout is `None` (the default), block if necessary until an\nitem is available. If timeout is a positive number, it blocks at most timeout\nseconds and raises the `queue.Empty` exception if no item was available within\nthat time. Otherwise (block is `False`), return an item if one is immediately\navailable, else raise the `queue.Empty` exception (timeout is ignored in that\ncase).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.Queue.get_nowait()", "path": "library/multiprocessing#multiprocessing.Queue.get_nowait", "type": "Concurrent Execution", "text": "\nEquivalent to `get(False)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.Queue.join_thread()", "path": "library/multiprocessing#multiprocessing.Queue.join_thread", "type": "Concurrent Execution", "text": "\nJoin the background thread. This can only be used after `close()` has been\ncalled. It blocks until the background thread exits, ensuring that all data in\nthe buffer has been flushed to the pipe.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.Queue.put()", "path": "library/multiprocessing#multiprocessing.Queue.put", "type": "Concurrent Execution", "text": "\nPut obj into the queue. If the optional argument block is `True` (the default)\nand timeout is `None` (the default), block if necessary until a free slot is\navailable. If timeout is a positive number, it blocks at most timeout seconds\nand raises the `queue.Full` exception if no free slot was available within\nthat time. Otherwise (block is `False`), put an item on the queue if a free\nslot is immediately available, else raise the `queue.Full` exception (timeout\nis ignored in that case).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.Queue.put_nowait()", "path": "library/multiprocessing#multiprocessing.Queue.put_nowait", "type": "Concurrent Execution", "text": "\nEquivalent to `put(obj, False)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.Queue.qsize()", "path": "library/multiprocessing#multiprocessing.Queue.qsize", "type": "Concurrent Execution", "text": "\nReturn the approximate size of the queue. Because of\nmultithreading/multiprocessing semantics, this number is not reliable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.RLock", "path": "library/multiprocessing#multiprocessing.RLock", "type": "Concurrent Execution", "text": "\nA recursive lock object: a close analog of `threading.RLock`. A recursive lock\nmust be released by the process or thread that acquired it. Once a process or\nthread has acquired a recursive lock, the same process or thread may acquire\nit again without blocking; that process or thread must release it once for\neach time it has been acquired.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.RLock.acquire()", "path": "library/multiprocessing#multiprocessing.RLock.acquire", "type": "Concurrent Execution", "text": "\nAcquire a lock, blocking or non-blocking.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.RLock.release()", "path": "library/multiprocessing#multiprocessing.RLock.release", "type": "Concurrent Execution", "text": "\nRelease a lock, decrementing the recursion level. If after the decrement the\nrecursion level is zero, reset the lock to unlocked (not owned by any process\nor thread) and if any other processes or threads are blocked waiting for the\nlock to become unlocked, allow exactly one of them to proceed. If after the\ndecrement the recursion level is still nonzero, the lock remains locked and\nowned by the calling process or thread.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.Semaphore", "path": "library/multiprocessing#multiprocessing.Semaphore", "type": "Concurrent Execution", "text": "\nA semaphore object: a close analog of `threading.Semaphore`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.set_executable()", "path": "library/multiprocessing#multiprocessing.set_executable", "type": "Concurrent Execution", "text": "\nSets the path of the Python interpreter to use when starting a child process.\n(By default `sys.executable` is used). Embedders will probably need to do some\nthing like\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.set_start_method()", "path": "library/multiprocessing#multiprocessing.set_start_method", "type": "Concurrent Execution", "text": "\nSet the method which should be used to start child processes. method can be\n`'fork'`, `'spawn'` or `'forkserver'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.sharedctypes.Array()", "path": "library/multiprocessing#multiprocessing.sharedctypes.Array", "type": "Concurrent Execution", "text": "\nThe same as `RawArray()` except that depending on the value of lock a process-\nsafe synchronization wrapper may be returned instead of a raw ctypes array.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.sharedctypes.copy()", "path": "library/multiprocessing#multiprocessing.sharedctypes.copy", "type": "Concurrent Execution", "text": "\nReturn a ctypes object allocated from shared memory which is a copy of the\nctypes object obj.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.sharedctypes.multiprocessing.Manager()", "path": "library/multiprocessing#multiprocessing.sharedctypes.multiprocessing.Manager", "type": "Concurrent Execution", "text": "\nReturns a started `SyncManager` object which can be used for sharing objects\nbetween processes. The returned manager object corresponds to a spawned child\nprocess and has methods which will create shared objects and return\ncorresponding proxies.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.sharedctypes.RawArray()", "path": "library/multiprocessing#multiprocessing.sharedctypes.RawArray", "type": "Concurrent Execution", "text": "\nReturn a ctypes array allocated from shared memory.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.sharedctypes.RawValue()", "path": "library/multiprocessing#multiprocessing.sharedctypes.RawValue", "type": "Concurrent Execution", "text": "\nReturn a ctypes object allocated from shared memory.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.sharedctypes.synchronized()", "path": "library/multiprocessing#multiprocessing.sharedctypes.synchronized", "type": "Concurrent Execution", "text": "\nReturn a process-safe wrapper object for a ctypes object which uses lock to\nsynchronize access. If lock is `None` (the default) then a\n`multiprocessing.RLock` object is created automatically.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.sharedctypes.Value()", "path": "library/multiprocessing#multiprocessing.sharedctypes.Value", "type": "Concurrent Execution", "text": "\nThe same as `RawValue()` except that depending on the value of lock a process-\nsafe synchronization wrapper may be returned instead of a raw ctypes object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.shared_memory", "path": "library/multiprocessing.shared_memory", "type": "Concurrent Execution", "text": "\nSource code: Lib/multiprocessing/shared_memory.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.shared_memory.ShareableList", "path": "library/multiprocessing.shared_memory#multiprocessing.shared_memory.ShareableList", "type": "Concurrent Execution", "text": "\nProvides a mutable list-like object where all values stored within are stored\nin a shared memory block. This constrains storable values to only the `int`,\n`float`, `bool`, `str` (less than 10M bytes each), `bytes` (less than 10M\nbytes each), and `None` built-in data types. It also notably differs from the\nbuilt-in `list` type in that these lists can not change their overall length\n(i.e. no append, insert, etc.) and do not support the dynamic creation of new\n`ShareableList` instances via slicing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.shared_memory.ShareableList.count()", "path": "library/multiprocessing.shared_memory#multiprocessing.shared_memory.ShareableList.count", "type": "Concurrent Execution", "text": "\nReturns the number of occurrences of `value`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.shared_memory.ShareableList.format", "path": "library/multiprocessing.shared_memory#multiprocessing.shared_memory.ShareableList.format", "type": "Concurrent Execution", "text": "\nRead-only attribute containing the `struct` packing format used by all\ncurrently stored values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.shared_memory.ShareableList.index()", "path": "library/multiprocessing.shared_memory#multiprocessing.shared_memory.ShareableList.index", "type": "Concurrent Execution", "text": "\nReturns first index position of `value`. Raises `ValueError` if `value` is not\npresent.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.shared_memory.ShareableList.shm", "path": "library/multiprocessing.shared_memory#multiprocessing.shared_memory.ShareableList.shm", "type": "Concurrent Execution", "text": "\nThe `SharedMemory` instance where the values are stored.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.shared_memory.SharedMemory", "path": "library/multiprocessing.shared_memory#multiprocessing.shared_memory.SharedMemory", "type": "Concurrent Execution", "text": "\nCreates a new shared memory block or attaches to an existing shared memory\nblock. Each shared memory block is assigned a unique name. In this way, one\nprocess can create a shared memory block with a particular name and a\ndifferent process can attach to that same shared memory block using that same\nname.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.shared_memory.SharedMemory.buf", "path": "library/multiprocessing.shared_memory#multiprocessing.shared_memory.SharedMemory.buf", "type": "Concurrent Execution", "text": "\nA memoryview of contents of the shared memory block.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.shared_memory.SharedMemory.close()", "path": "library/multiprocessing.shared_memory#multiprocessing.shared_memory.SharedMemory.close", "type": "Concurrent Execution", "text": "\nCloses access to the shared memory from this instance. In order to ensure\nproper cleanup of resources, all instances should call `close()` once the\ninstance is no longer needed. Note that calling `close()` does not cause the\nshared memory block itself to be destroyed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.shared_memory.SharedMemory.name", "path": "library/multiprocessing.shared_memory#multiprocessing.shared_memory.SharedMemory.name", "type": "Concurrent Execution", "text": "\nRead-only access to the unique name of the shared memory block.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.shared_memory.SharedMemory.size", "path": "library/multiprocessing.shared_memory#multiprocessing.shared_memory.SharedMemory.size", "type": "Concurrent Execution", "text": "\nRead-only access to size in bytes of the shared memory block.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.shared_memory.SharedMemory.unlink()", "path": "library/multiprocessing.shared_memory#multiprocessing.shared_memory.SharedMemory.unlink", "type": "Concurrent Execution", "text": "\nRequests that the underlying shared memory block be destroyed. In order to\nensure proper cleanup of resources, `unlink()` should be called once (and only\nonce) across all processes which have need for the shared memory block. After\nrequesting its destruction, a shared memory block may or may not be\nimmediately destroyed and this behavior may differ across platforms. Attempts\nto access data inside the shared memory block after `unlink()` has been called\nmay result in memory access errors. Note: the last process relinquishing its\nhold on a shared memory block may call `unlink()` and `close()` in either\norder.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.SimpleQueue", "path": "library/multiprocessing#multiprocessing.SimpleQueue", "type": "Concurrent Execution", "text": "\nIt is a simplified `Queue` type, very close to a locked `Pipe`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.SimpleQueue.close()", "path": "library/multiprocessing#multiprocessing.SimpleQueue.close", "type": "Concurrent Execution", "text": "\nClose the queue: release internal resources.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.SimpleQueue.empty()", "path": "library/multiprocessing#multiprocessing.SimpleQueue.empty", "type": "Concurrent Execution", "text": "\nReturn `True` if the queue is empty, `False` otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.SimpleQueue.get()", "path": "library/multiprocessing#multiprocessing.SimpleQueue.get", "type": "Concurrent Execution", "text": "\nRemove and return an item from the queue.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.SimpleQueue.put()", "path": "library/multiprocessing#multiprocessing.SimpleQueue.put", "type": "Concurrent Execution", "text": "\nPut item into the queue.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.TimeoutError", "path": "library/multiprocessing#multiprocessing.TimeoutError", "type": "Concurrent Execution", "text": "\nRaised by methods with a timeout when the timeout expires.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "multiprocessing.Value()", "path": "library/multiprocessing#multiprocessing.Value", "type": "Concurrent Execution", "text": "\nReturn a `ctypes` object allocated from shared memory. By default the return\nvalue is actually a synchronized wrapper for the object. The object itself can\nbe accessed via the value attribute of a `Value`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "NameError", "path": "library/exceptions#NameError", "type": "Built-in Exceptions", "text": "\nRaised when a local or global name is not found. This applies only to\nunqualified names. The associated value is an error message that includes the\nname that could not be found.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "netrc", "path": "library/netrc", "type": "File Formats", "text": "\nSource code: Lib/netrc.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "netrc.netrc", "path": "library/netrc#netrc.netrc", "type": "File Formats", "text": "\nA `netrc` instance or subclass instance encapsulates data from a netrc file.\nThe initialization argument, if present, specifies the file to parse. If no\nargument is given, the file `.netrc` in the user\u2019s home directory \u2013 as\ndetermined by `os.path.expanduser()` \u2013 will be read. Otherwise, a\n`FileNotFoundError` exception will be raised. Parse errors will raise\n`NetrcParseError` with diagnostic information including the file name, line\nnumber, and terminating token. If no argument is specified on a POSIX system,\nthe presence of passwords in the `.netrc` file will raise a `NetrcParseError`\nif the file ownership or permissions are insecure (owned by a user other than\nthe user running the process, or accessible for read or write by any other\nuser). This implements security behavior equivalent to that of ftp and other\nprograms that use `.netrc`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "netrc.netrc.authenticators()", "path": "library/netrc#netrc.netrc.authenticators", "type": "File Formats", "text": "\nReturn a 3-tuple `(login, account, password)` of authenticators for host. If\nthe netrc file did not contain an entry for the given host, return the tuple\nassociated with the \u2018default\u2019 entry. If neither matching host nor default\nentry is available, return `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "netrc.netrc.hosts", "path": "library/netrc#netrc.netrc.hosts", "type": "File Formats", "text": "\nDictionary mapping host names to `(login, account, password)` tuples. The\n\u2018default\u2019 entry, if any, is represented as a pseudo-host by that name.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "netrc.netrc.macros", "path": "library/netrc#netrc.netrc.macros", "type": "File Formats", "text": "\nDictionary mapping macro names to string lists.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "netrc.netrc.__repr__()", "path": "library/netrc#netrc.netrc.__repr__", "type": "File Formats", "text": "\nDump the class data as a string in the format of a netrc file. (This discards\ncomments and may reorder the entries.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "netrc.NetrcParseError", "path": "library/netrc#netrc.NetrcParseError", "type": "File Formats", "text": "\nException raised by the `netrc` class when syntactical errors are encountered\nin source text. Instances of this exception provide three interesting\nattributes: `msg` is a textual explanation of the error, `filename` is the\nname of the source file, and `lineno` gives the line number on which the error\nwas found.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "next()", "path": "library/functions#next", "type": "Built-in Functions", "text": "\nRetrieve the next item from the iterator by calling its `__next__()` method.\nIf default is given, it is returned if the iterator is exhausted, otherwise\n`StopIteration` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nis", "path": "library/nis", "type": "Unix", "text": "\nThe `nis` module gives a thin wrapper around the NIS library, useful for\ncentral administration of several hosts.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nis.cat()", "path": "library/nis#nis.cat", "type": "Unix", "text": "\nReturn a dictionary mapping key to value such that `match(key,\nmapname)==value`. Note that both keys and values of the dictionary are\narbitrary arrays of bytes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nis.error", "path": "library/nis#nis.error", "type": "Unix", "text": "\nAn error raised when a NIS function returns an error code.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nis.get_default_domain()", "path": "library/nis#nis.get_default_domain", "type": "Unix", "text": "\nReturn the system default NIS domain.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nis.maps()", "path": "library/nis#nis.maps", "type": "Unix", "text": "\nReturn a list of all valid maps.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nis.match()", "path": "library/nis#nis.match", "type": "Unix", "text": "\nReturn the match for key in map mapname, or raise an error (`nis.error`) if\nthere is none. Both should be strings, key is 8-bit clean. Return value is an\narbitrary array of bytes (may contain `NULL` and other joys).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nnn()", "path": "library/urllib.request#nnn", "type": "Internet", "text": "\nnnn should be a three-digit HTTP error code. This method is also not defined\nin `BaseHandler`, but will be called, if it exists, on an instance of a\nsubclass, when an HTTP error with code nnn occurs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nntplib", "path": "library/nntplib", "type": "Internet", "text": "\nSource code: Lib/nntplib.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nntplib.decode_header()", "path": "library/nntplib#nntplib.decode_header", "type": "Internet", "text": "\nDecode a header value, un-escaping any escaped non-ASCII characters.\nheader_str must be a `str` object. The unescaped value is returned. Using this\nfunction is recommended to display some headers in a human readable form:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nntplib.NNTP", "path": "library/nntplib#nntplib.NNTP", "type": "Internet", "text": "\nReturn a new `NNTP` object, representing a connection to the NNTP server\nrunning on host host, listening at port port. An optional timeout can be\nspecified for the socket connection. If the optional user and password are\nprovided, or if suitable credentials are present in `/.netrc` and the optional\nflag usenetrc is true, the `AUTHINFO USER` and `AUTHINFO PASS` commands are\nused to identify and authenticate the user to the server. If the optional flag\nreadermode is true, then a `mode reader` command is sent before authentication\nis performed. Reader mode is sometimes necessary if you are connecting to an\nNNTP server on the local machine and intend to call reader-specific commands,\nsuch as `group`. If you get unexpected `NNTPPermanentError`s, you might need\nto set readermode. The `NNTP` class supports the `with` statement to\nunconditionally consume `OSError` exceptions and to close the NNTP connection\nwhen done, e.g.:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nntplib.NNTP.article()", "path": "library/nntplib#nntplib.NNTP.article", "type": "Internet", "text": "\nSend an `ARTICLE` command, where message_spec has the same meaning as for\n`stat()`. Return a tuple `(response, info)` where info is a `namedtuple` with\nthree attributes number, message_id and lines (in that order). number is the\narticle number in the group (or 0 if the information is not available),\nmessage_id the message id as a string, and lines a list of lines (without\nterminating newlines) comprising the raw message including headers and body.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nntplib.NNTP.body()", "path": "library/nntplib#nntplib.NNTP.body", "type": "Internet", "text": "\nSame as `article()`, but sends a `BODY` command. The lines returned (or\nwritten to file) will only contain the message body, not the headers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nntplib.NNTP.date()", "path": "library/nntplib#nntplib.NNTP.date", "type": "Internet", "text": "\nReturn a pair `(response, date)`. date is a `datetime` object containing the\ncurrent date and time of the server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nntplib.NNTP.description()", "path": "library/nntplib#nntplib.NNTP.description", "type": "Internet", "text": "\nGet a description for a single group group. If more than one group matches (if\n\u2018group\u2019 is a real wildmat string), return the first match. If no group\nmatches, return an empty string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nntplib.NNTP.descriptions()", "path": "library/nntplib#nntplib.NNTP.descriptions", "type": "Internet", "text": "\nSend a `LIST NEWSGROUPS` command, where grouppattern is a wildmat string as\nspecified in RFC 3977 (it\u2019s essentially the same as DOS or UNIX shell wildcard\nstrings). Return a pair `(response, descriptions)`, where descriptions is a\ndictionary mapping group names to textual descriptions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nntplib.NNTP.getcapabilities()", "path": "library/nntplib#nntplib.NNTP.getcapabilities", "type": "Internet", "text": "\nReturn the RFC 3977 capabilities advertised by the server, as a `dict`\ninstance mapping capability names to (possibly empty) lists of values. On\nlegacy servers which don\u2019t understand the `CAPABILITIES` command, an empty\ndictionary is returned instead.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nntplib.NNTP.getwelcome()", "path": "library/nntplib#nntplib.NNTP.getwelcome", "type": "Internet", "text": "\nReturn the welcome message sent by the server in reply to the initial\nconnection. (This message sometimes contains disclaimers or help information\nthat may be relevant to the user.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nntplib.NNTP.group()", "path": "library/nntplib#nntplib.NNTP.group", "type": "Internet", "text": "\nSend a `GROUP` command, where name is the group name. The group is selected as\nthe current group, if it exists. Return a tuple `(response, count, first,\nlast, name)` where count is the (estimated) number of articles in the group,\nfirst is the first article number in the group, last is the last article\nnumber in the group, and name is the group name.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nntplib.NNTP.head()", "path": "library/nntplib#nntplib.NNTP.head", "type": "Internet", "text": "\nSame as `article()`, but sends a `HEAD` command. The lines returned (or\nwritten to file) will only contain the message headers, not the body.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nntplib.NNTP.help()", "path": "library/nntplib#nntplib.NNTP.help", "type": "Internet", "text": "\nSend a `HELP` command. Return a pair `(response, list)` where list is a list\nof help strings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nntplib.NNTP.ihave()", "path": "library/nntplib#nntplib.NNTP.ihave", "type": "Internet", "text": "\nSend an `IHAVE` command. message_id is the id of the message to send to the\nserver (enclosed in `'<'` and `'>'`). The data parameter and the return value\nare the same as for `post()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nntplib.NNTP.last()", "path": "library/nntplib#nntplib.NNTP.last", "type": "Internet", "text": "\nSend a `LAST` command. Return as for `stat()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nntplib.NNTP.list()", "path": "library/nntplib#nntplib.NNTP.list", "type": "Internet", "text": "\nSend a `LIST` or `LIST ACTIVE` command. Return a pair `(response, list)` where\nlist is a list of tuples representing all the groups available from this NNTP\nserver, optionally matching the pattern string group_pattern. Each tuple has\nthe form `(group, last, first, flag)`, where group is a group name, last and\nfirst are the last and first article numbers, and flag usually takes one of\nthese values:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nntplib.NNTP.login()", "path": "library/nntplib#nntplib.NNTP.login", "type": "Internet", "text": "\nSend `AUTHINFO` commands with the user name and password. If user and password\nare `None` and usenetrc is true, credentials from `~/.netrc` will be used if\npossible.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nntplib.NNTP.newgroups()", "path": "library/nntplib#nntplib.NNTP.newgroups", "type": "Internet", "text": "\nSend a `NEWGROUPS` command. The date argument should be a `datetime.date` or\n`datetime.datetime` object. Return a pair `(response, groups)` where groups is\na list representing the groups that are new since the given date. If file is\nsupplied, though, then groups will be empty.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nntplib.NNTP.newnews()", "path": "library/nntplib#nntplib.NNTP.newnews", "type": "Internet", "text": "\nSend a `NEWNEWS` command. Here, group is a group name or `'*'`, and date has\nthe same meaning as for `newgroups()`. Return a pair `(response, articles)`\nwhere articles is a list of message ids.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nntplib.NNTP.next()", "path": "library/nntplib#nntplib.NNTP.next", "type": "Internet", "text": "\nSend a `NEXT` command. Return as for `stat()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nntplib.NNTP.nntp_implementation", "path": "library/nntplib#nntplib.NNTP.nntp_implementation", "type": "Internet", "text": "\nA string describing the software name and version of the NNTP server, or\n`None` if not advertised by the server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nntplib.NNTP.nntp_version", "path": "library/nntplib#nntplib.NNTP.nntp_version", "type": "Internet", "text": "\nAn integer representing the version of the NNTP protocol supported by the\nserver. In practice, this should be `2` for servers advertising RFC 3977\ncompliance and `1` for others.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nntplib.NNTP.over()", "path": "library/nntplib#nntplib.NNTP.over", "type": "Internet", "text": "\nSend an `OVER` command, or an `XOVER` command on legacy servers. message_spec\ncan be either a string representing a message id, or a `(first, last)` tuple\nof numbers indicating a range of articles in the current group, or a `(first,\nNone)` tuple indicating a range of articles starting from first to the last\narticle in the current group, or `None` to select the current article in the\ncurrent group.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nntplib.NNTP.post()", "path": "library/nntplib#nntplib.NNTP.post", "type": "Internet", "text": "\nPost an article using the `POST` command. The data argument is either a file\nobject opened for binary reading, or any iterable of bytes objects\n(representing raw lines of the article to be posted). It should represent a\nwell-formed news article, including the required headers. The `post()` method\nautomatically escapes lines beginning with `.` and appends the termination\nline.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nntplib.NNTP.quit()", "path": "library/nntplib#nntplib.NNTP.quit", "type": "Internet", "text": "\nSend a `QUIT` command and close the connection. Once this method has been\ncalled, no other methods of the NNTP object should be called.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nntplib.NNTP.set_debuglevel()", "path": "library/nntplib#nntplib.NNTP.set_debuglevel", "type": "Internet", "text": "\nSet the instance\u2019s debugging level. This controls the amount of debugging\noutput printed. The default, `0`, produces no debugging output. A value of `1`\nproduces a moderate amount of debugging output, generally a single line per\nrequest or response. A value of `2` or higher produces the maximum amount of\ndebugging output, logging each line sent and received on the connection\n(including message text).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nntplib.NNTP.slave()", "path": "library/nntplib#nntplib.NNTP.slave", "type": "Internet", "text": "\nSend a `SLAVE` command. Return the server\u2019s response.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nntplib.NNTP.starttls()", "path": "library/nntplib#nntplib.NNTP.starttls", "type": "Internet", "text": "\nSend a `STARTTLS` command. This will enable encryption on the NNTP connection.\nThe context argument is optional and should be a `ssl.SSLContext` object.\nPlease read Security considerations for best practices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nntplib.NNTP.stat()", "path": "library/nntplib#nntplib.NNTP.stat", "type": "Internet", "text": "\nSend a `STAT` command, where message_spec is either a message id (enclosed in\n`'<'` and `'>'`) or an article number in the current group. If message_spec is\nomitted or `None`, the current article in the current group is considered.\nReturn a triple `(response, number, id)` where number is the article number\nand id is the message id.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nntplib.NNTP.xhdr()", "path": "library/nntplib#nntplib.NNTP.xhdr", "type": "Internet", "text": "\nSend an `XHDR` command. The hdr argument is a header keyword, e.g.\n`'subject'`. The str argument should have the form `'first-last'` where first\nand last are the first and last article numbers to search. Return a pair\n`(response, list)`, where list is a list of pairs `(id, text)`, where id is an\narticle number (as a string) and text is the text of the requested header for\nthat article. If the file parameter is supplied, then the output of the `XHDR`\ncommand is stored in a file. If file is a string, then the method will open a\nfile with that name, write to it then close it. If file is a file object, then\nit will start calling `write()` on it to store the lines of the command\noutput. If file is supplied, then the returned list is an empty list.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nntplib.NNTP.xover()", "path": "library/nntplib#nntplib.NNTP.xover", "type": "Internet", "text": "\nSend an `XOVER` command. start and end are article numbers delimiting the\nrange of articles to select. The return value is the same of for `over()`. It\nis recommended to use `over()` instead, since it will automatically use the\nnewer `OVER` command if available.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nntplib.NNTPDataError", "path": "library/nntplib#nntplib.NNTPDataError", "type": "Internet", "text": "\nException raised when there is some error in the response data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nntplib.NNTPError", "path": "library/nntplib#nntplib.NNTPError", "type": "Internet", "text": "\nDerived from the standard exception `Exception`, this is the base class for\nall exceptions raised by the `nntplib` module. Instances of this class have\nthe following attribute:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nntplib.NNTPError.response", "path": "library/nntplib#nntplib.NNTPError.response", "type": "Internet", "text": "\nThe response of the server if available, as a `str` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nntplib.NNTPPermanentError", "path": "library/nntplib#nntplib.NNTPPermanentError", "type": "Internet", "text": "\nException raised when a response code in the range 500\u2013599 is received.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nntplib.NNTPProtocolError", "path": "library/nntplib#nntplib.NNTPProtocolError", "type": "Internet", "text": "\nException raised when a reply is received from the server that does not begin\nwith a digit in the range 1\u20135.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nntplib.NNTPReplyError", "path": "library/nntplib#nntplib.NNTPReplyError", "type": "Internet", "text": "\nException raised when an unexpected reply is received from the server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nntplib.NNTPTemporaryError", "path": "library/nntplib#nntplib.NNTPTemporaryError", "type": "Internet", "text": "\nException raised when a response code in the range 400\u2013499 is received.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "nntplib.NNTP_SSL", "path": "library/nntplib#nntplib.NNTP_SSL", "type": "Internet", "text": "\nReturn a new `NNTP_SSL` object, representing an encrypted connection to the\nNNTP server running on host host, listening at port port. `NNTP_SSL` objects\nhave the same methods as `NNTP` objects. If port is omitted, port 563 (NNTPS)\nis used. ssl_context is also optional, and is a `SSLContext` object. Please\nread Security considerations for best practices. All other parameters behave\nthe same as for `NNTP`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "None", "path": "library/constants#None", "type": "Built-in Constants", "text": "\nThe sole value of the type `NoneType`. `None` is frequently used to represent\nthe absence of a value, as when default arguments are not passed to a\nfunction. Assignments to `None` are illegal and raise a `SyntaxError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "NotADirectoryError", "path": "library/exceptions#NotADirectoryError", "type": "Built-in Exceptions", "text": "\nRaised when a directory operation (such as `os.listdir()`) is requested on\nsomething which is not a directory. Corresponds to `errno` `ENOTDIR`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "NotImplemented", "path": "library/constants#NotImplemented", "type": "Built-in Constants", "text": "\nSpecial value which should be returned by the binary special methods (e.g.\n`__eq__()`, `__lt__()`, `__add__()`, `__rsub__()`, etc.) to indicate that the\noperation is not implemented with respect to the other type; may be returned\nby the in-place binary special methods (e.g. `__imul__()`, `__iand__()`, etc.)\nfor the same purpose. It should not be evaluated in a boolean context.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "NotImplementedError", "path": "library/exceptions#NotImplementedError", "type": "Built-in Exceptions", "text": "\nThis exception is derived from `RuntimeError`. In user defined base classes,\nabstract methods should raise this exception when they require derived classes\nto override the method, or while the class is being developed to indicate that\nthe real implementation still needs to be added.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "numbers", "path": "library/numbers", "type": "Numeric & Mathematical", "text": "\nSource code: Lib/numbers.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "numbers.Complex", "path": "library/numbers#numbers.Complex", "type": "Numeric & Mathematical", "text": "\nSubclasses of this type describe complex numbers and include the operations\nthat work on the built-in `complex` type. These are: conversions to `complex`\nand `bool`, `real`, `imag`, `+`, `-`, `*`, `/`, `abs()`, `conjugate()`, `==`,\nand `!=`. All except `-` and `!=` are abstract.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "numbers.Complex.conjugate()", "path": "library/numbers#numbers.Complex.conjugate", "type": "Numeric & Mathematical", "text": "\nAbstract. Returns the complex conjugate. For example, `(1+3j).conjugate() ==\n(1-3j)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "numbers.Complex.imag", "path": "library/numbers#numbers.Complex.imag", "type": "Numeric & Mathematical", "text": "\nAbstract. Retrieves the imaginary component of this number.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "numbers.Complex.real", "path": "library/numbers#numbers.Complex.real", "type": "Numeric & Mathematical", "text": "\nAbstract. Retrieves the real component of this number.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "numbers.Integral", "path": "library/numbers#numbers.Integral", "type": "Numeric & Mathematical", "text": "\nSubtypes `Rational` and adds a conversion to `int`. Provides defaults for\n`float()`, `numerator`, and `denominator`. Adds abstract methods for `**` and\nbit-string operations: `<<`, `>>`, `&`, `^`, `|`, `~`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "numbers.Number", "path": "library/numbers#numbers.Number", "type": "Numeric & Mathematical", "text": "\nThe root of the numeric hierarchy. If you just want to check if an argument x\nis a number, without caring what kind, use `isinstance(x, Number)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "numbers.Rational", "path": "library/numbers#numbers.Rational", "type": "Numeric & Mathematical", "text": "\nSubtypes `Real` and adds `numerator` and `denominator` properties, which\nshould be in lowest terms. With these, it provides a default for `float()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "numbers.Rational.denominator", "path": "library/numbers#numbers.Rational.denominator", "type": "Numeric & Mathematical", "text": "\nAbstract.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "numbers.Rational.numerator", "path": "library/numbers#numbers.Rational.numerator", "type": "Numeric & Mathematical", "text": "\nAbstract.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "numbers.Real", "path": "library/numbers#numbers.Real", "type": "Numeric & Mathematical", "text": "\nTo `Complex`, `Real` adds the operations that work on real numbers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "object", "path": "library/functions#object", "type": "Built-in Functions", "text": "\nReturn a new featureless object. `object` is a base for all classes. It has\nthe methods that are common to all instances of Python classes. This function\ndoes not accept any arguments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "object.__dict__", "path": "library/stdtypes#object.__dict__", "type": "Built-in Types", "text": "\nA dictionary or other mapping object used to store an object\u2019s (writable)\nattributes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "object.__getnewargs_ex__()", "path": "library/pickle#object.__getnewargs_ex__", "type": "Data Persistence", "text": "\nIn protocols 2 and newer, classes that implements the `__getnewargs_ex__()`\nmethod can dictate the values passed to the `__new__()` method upon\nunpickling. The method must return a pair `(args, kwargs)` where args is a\ntuple of positional arguments and kwargs a dictionary of named arguments for\nconstructing the object. Those will be passed to the `__new__()` method upon\nunpickling.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "object.__getnewargs__()", "path": "library/pickle#object.__getnewargs__", "type": "Data Persistence", "text": "\nThis method serves a similar purpose as `__getnewargs_ex__()`, but supports\nonly positional arguments. It must return a tuple of arguments `args` which\nwill be passed to the `__new__()` method upon unpickling.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "object.__getstate__()", "path": "library/pickle#object.__getstate__", "type": "Data Persistence", "text": "\nClasses can further influence how their instances are pickled; if the class\ndefines the method `__getstate__()`, it is called and the returned object is\npickled as the contents for the instance, instead of the contents of the\ninstance\u2019s dictionary. If the `__getstate__()` method is absent, the\ninstance\u2019s `__dict__` is pickled as usual.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "object.__reduce_ex__()", "path": "library/pickle#object.__reduce_ex__", "type": "Data Persistence", "text": "\nAlternatively, a `__reduce_ex__()` method may be defined. The only difference\nis this method should take a single integer argument, the protocol version.\nWhen defined, pickle will prefer it over the `__reduce__()` method. In\naddition, `__reduce__()` automatically becomes a synonym for the extended\nversion. The main use for this method is to provide backwards-compatible\nreduce values for older Python releases.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "object.__reduce__()", "path": "library/pickle#object.__reduce__", "type": "Data Persistence", "text": "\nThe interface is currently defined as follows. The `__reduce__()` method takes\nno argument and shall return either a string or preferably a tuple (the\nreturned object is often referred to as the \u201creduce value\u201d).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "object.__setstate__()", "path": "library/pickle#object.__setstate__", "type": "Data Persistence", "text": "\nUpon unpickling, if the class defines `__setstate__()`, it is called with the\nunpickled state. In that case, there is no requirement for the state object to\nbe a dictionary. Otherwise, the pickled state must be a dictionary and its\nitems are assigned to the new instance\u2019s dictionary.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "oct()", "path": "library/functions#oct", "type": "Built-in Functions", "text": "\nConvert an integer number to an octal string prefixed with \u201c0o\u201d. The result is\na valid Python expression. If x is not a Python `int` object, it has to define\nan `__index__()` method that returns an integer. For example:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "open()", "path": "library/functions#open", "type": "Built-in Functions", "text": "\nOpen file and return a corresponding file object. If the file cannot be\nopened, an `OSError` is raised. See Reading and Writing Files for more\nexamples of how to use this function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "open()", "path": "library/urllib.request#open", "type": "Internet", "text": "\nThis method is not defined in `BaseHandler`, but subclasses should define it\nif they want to handle URLs with the given protocol.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator", "path": "library/operator", "type": "Functional Programming", "text": "\nSource code: Lib/operator.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.abs()", "path": "library/operator#operator.abs", "type": "Functional Programming", "text": "\nReturn the absolute value of obj.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.add()", "path": "library/operator#operator.add", "type": "Functional Programming", "text": "\nReturn `a + b`, for a and b numbers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.and_()", "path": "library/operator#operator.and_", "type": "Functional Programming", "text": "\nReturn the bitwise and of a and b.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.attrgetter()", "path": "library/operator#operator.attrgetter", "type": "Functional Programming", "text": "\nReturn a callable object that fetches attr from its operand. If more than one\nattribute is requested, returns a tuple of attributes. The attribute names can\nalso contain dots. For example:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.concat()", "path": "library/operator#operator.concat", "type": "Functional Programming", "text": "\nReturn `a + b` for a and b sequences.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.contains()", "path": "library/operator#operator.contains", "type": "Functional Programming", "text": "\nReturn the outcome of the test `b in a`. Note the reversed operands.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.countOf()", "path": "library/operator#operator.countOf", "type": "Functional Programming", "text": "\nReturn the number of occurrences of b in a.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.delitem()", "path": "library/operator#operator.delitem", "type": "Functional Programming", "text": "\nRemove the value of a at index b.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.eq()", "path": "library/operator#operator.eq", "type": "Functional Programming", "text": "\nPerform \u201crich comparisons\u201d between a and b. Specifically, `lt(a, b)` is\nequivalent to `a < b`, `le(a, b)` is equivalent to `a <= b`, `eq(a, b)` is\nequivalent to `a == b`, `ne(a, b)` is equivalent to `a != b`, `gt(a, b)` is\nequivalent to `a > b` and `ge(a, b)` is equivalent to `a >= b`. Note that\nthese functions can return any value, which may or may not be interpretable as\na Boolean value. See Comparisons for more information about rich comparisons.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.floordiv()", "path": "library/operator#operator.floordiv", "type": "Functional Programming", "text": "\nReturn `a // b`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.ge()", "path": "library/operator#operator.ge", "type": "Functional Programming", "text": "\nPerform \u201crich comparisons\u201d between a and b. Specifically, `lt(a, b)` is\nequivalent to `a < b`, `le(a, b)` is equivalent to `a <= b`, `eq(a, b)` is\nequivalent to `a == b`, `ne(a, b)` is equivalent to `a != b`, `gt(a, b)` is\nequivalent to `a > b` and `ge(a, b)` is equivalent to `a >= b`. Note that\nthese functions can return any value, which may or may not be interpretable as\na Boolean value. See Comparisons for more information about rich comparisons.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.getitem()", "path": "library/operator#operator.getitem", "type": "Functional Programming", "text": "\nReturn the value of a at index b.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.gt()", "path": "library/operator#operator.gt", "type": "Functional Programming", "text": "\nPerform \u201crich comparisons\u201d between a and b. Specifically, `lt(a, b)` is\nequivalent to `a < b`, `le(a, b)` is equivalent to `a <= b`, `eq(a, b)` is\nequivalent to `a == b`, `ne(a, b)` is equivalent to `a != b`, `gt(a, b)` is\nequivalent to `a > b` and `ge(a, b)` is equivalent to `a >= b`. Note that\nthese functions can return any value, which may or may not be interpretable as\na Boolean value. See Comparisons for more information about rich comparisons.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.iadd()", "path": "library/operator#operator.iadd", "type": "Functional Programming", "text": "\n`a = iadd(a, b)` is equivalent to `a += b`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.iand()", "path": "library/operator#operator.iand", "type": "Functional Programming", "text": "\n`a = iand(a, b)` is equivalent to `a &= b`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.iconcat()", "path": "library/operator#operator.iconcat", "type": "Functional Programming", "text": "\n`a = iconcat(a, b)` is equivalent to `a += b` for a and b sequences.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.ifloordiv()", "path": "library/operator#operator.ifloordiv", "type": "Functional Programming", "text": "\n`a = ifloordiv(a, b)` is equivalent to `a //= b`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.ilshift()", "path": "library/operator#operator.ilshift", "type": "Functional Programming", "text": "\n`a = ilshift(a, b)` is equivalent to `a <<= b`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.imatmul()", "path": "library/operator#operator.imatmul", "type": "Functional Programming", "text": "\n`a = imatmul(a, b)` is equivalent to `a @= b`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.imod()", "path": "library/operator#operator.imod", "type": "Functional Programming", "text": "\n`a = imod(a, b)` is equivalent to `a %= b`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.imul()", "path": "library/operator#operator.imul", "type": "Functional Programming", "text": "\n`a = imul(a, b)` is equivalent to `a *= b`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.index()", "path": "library/operator#operator.index", "type": "Functional Programming", "text": "\nReturn a converted to an integer. Equivalent to `a.__index__()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.indexOf()", "path": "library/operator#operator.indexOf", "type": "Functional Programming", "text": "\nReturn the index of the first of occurrence of b in a.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.inv()", "path": "library/operator#operator.inv", "type": "Functional Programming", "text": "\nReturn the bitwise inverse of the number obj. This is equivalent to `~obj`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.invert()", "path": "library/operator#operator.invert", "type": "Functional Programming", "text": "\nReturn the bitwise inverse of the number obj. This is equivalent to `~obj`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.ior()", "path": "library/operator#operator.ior", "type": "Functional Programming", "text": "\n`a = ior(a, b)` is equivalent to `a |= b`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.ipow()", "path": "library/operator#operator.ipow", "type": "Functional Programming", "text": "\n`a = ipow(a, b)` is equivalent to `a **= b`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.irshift()", "path": "library/operator#operator.irshift", "type": "Functional Programming", "text": "\n`a = irshift(a, b)` is equivalent to `a >>= b`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.isub()", "path": "library/operator#operator.isub", "type": "Functional Programming", "text": "\n`a = isub(a, b)` is equivalent to `a -= b`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.is_()", "path": "library/operator#operator.is_", "type": "Functional Programming", "text": "\nReturn `a is b`. Tests object identity.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.is_not()", "path": "library/operator#operator.is_not", "type": "Functional Programming", "text": "\nReturn `a is not b`. Tests object identity.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.itemgetter()", "path": "library/operator#operator.itemgetter", "type": "Functional Programming", "text": "\nReturn a callable object that fetches item from its operand using the\noperand\u2019s `__getitem__()` method. If multiple items are specified, returns a\ntuple of lookup values. For example:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.itruediv()", "path": "library/operator#operator.itruediv", "type": "Functional Programming", "text": "\n`a = itruediv(a, b)` is equivalent to `a /= b`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.ixor()", "path": "library/operator#operator.ixor", "type": "Functional Programming", "text": "\n`a = ixor(a, b)` is equivalent to `a ^= b`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.le()", "path": "library/operator#operator.le", "type": "Functional Programming", "text": "\nPerform \u201crich comparisons\u201d between a and b. Specifically, `lt(a, b)` is\nequivalent to `a < b`, `le(a, b)` is equivalent to `a <= b`, `eq(a, b)` is\nequivalent to `a == b`, `ne(a, b)` is equivalent to `a != b`, `gt(a, b)` is\nequivalent to `a > b` and `ge(a, b)` is equivalent to `a >= b`. Note that\nthese functions can return any value, which may or may not be interpretable as\na Boolean value. See Comparisons for more information about rich comparisons.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.length_hint()", "path": "library/operator#operator.length_hint", "type": "Functional Programming", "text": "\nReturn an estimated length for the object o. First try to return its actual\nlength, then an estimate using `object.__length_hint__()`, and finally return\nthe default value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.lshift()", "path": "library/operator#operator.lshift", "type": "Functional Programming", "text": "\nReturn a shifted left by b.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.lt()", "path": "library/operator#operator.lt", "type": "Functional Programming", "text": "\nPerform \u201crich comparisons\u201d between a and b. Specifically, `lt(a, b)` is\nequivalent to `a < b`, `le(a, b)` is equivalent to `a <= b`, `eq(a, b)` is\nequivalent to `a == b`, `ne(a, b)` is equivalent to `a != b`, `gt(a, b)` is\nequivalent to `a > b` and `ge(a, b)` is equivalent to `a >= b`. Note that\nthese functions can return any value, which may or may not be interpretable as\na Boolean value. See Comparisons for more information about rich comparisons.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.matmul()", "path": "library/operator#operator.matmul", "type": "Functional Programming", "text": "\nReturn `a @ b`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.methodcaller()", "path": "library/operator#operator.methodcaller", "type": "Functional Programming", "text": "\nReturn a callable object that calls the method name on its operand. If\nadditional arguments and/or keyword arguments are given, they will be given to\nthe method as well. For example:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.mod()", "path": "library/operator#operator.mod", "type": "Functional Programming", "text": "\nReturn `a % b`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.mul()", "path": "library/operator#operator.mul", "type": "Functional Programming", "text": "\nReturn `a * b`, for a and b numbers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.ne()", "path": "library/operator#operator.ne", "type": "Functional Programming", "text": "\nPerform \u201crich comparisons\u201d between a and b. Specifically, `lt(a, b)` is\nequivalent to `a < b`, `le(a, b)` is equivalent to `a <= b`, `eq(a, b)` is\nequivalent to `a == b`, `ne(a, b)` is equivalent to `a != b`, `gt(a, b)` is\nequivalent to `a > b` and `ge(a, b)` is equivalent to `a >= b`. Note that\nthese functions can return any value, which may or may not be interpretable as\na Boolean value. See Comparisons for more information about rich comparisons.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.neg()", "path": "library/operator#operator.neg", "type": "Functional Programming", "text": "\nReturn obj negated (`-obj`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.not_()", "path": "library/operator#operator.not_", "type": "Functional Programming", "text": "\nReturn the outcome of `not` obj. (Note that there is no `__not__()` method for\nobject instances; only the interpreter core defines this operation. The result\nis affected by the `__bool__()` and `__len__()` methods.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.or_()", "path": "library/operator#operator.or_", "type": "Functional Programming", "text": "\nReturn the bitwise or of a and b.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.pos()", "path": "library/operator#operator.pos", "type": "Functional Programming", "text": "\nReturn obj positive (`+obj`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.pow()", "path": "library/operator#operator.pow", "type": "Functional Programming", "text": "\nReturn `a ** b`, for a and b numbers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.rshift()", "path": "library/operator#operator.rshift", "type": "Functional Programming", "text": "\nReturn a shifted right by b.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.setitem()", "path": "library/operator#operator.setitem", "type": "Functional Programming", "text": "\nSet the value of a at index b to c.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.sub()", "path": "library/operator#operator.sub", "type": "Functional Programming", "text": "\nReturn `a - b`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.truediv()", "path": "library/operator#operator.truediv", "type": "Functional Programming", "text": "\nReturn `a / b` where 2/3 is .66 rather than 0. This is also known as \u201ctrue\u201d\ndivision.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.truth()", "path": "library/operator#operator.truth", "type": "Functional Programming", "text": "\nReturn `True` if obj is true, and `False` otherwise. This is equivalent to\nusing the `bool` constructor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.xor()", "path": "library/operator#operator.xor", "type": "Functional Programming", "text": "\nReturn the bitwise exclusive or of a and b.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__abs__()", "path": "library/operator#operator.__abs__", "type": "Functional Programming", "text": "\nReturn the absolute value of obj.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__add__()", "path": "library/operator#operator.__add__", "type": "Functional Programming", "text": "\nReturn `a + b`, for a and b numbers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__and__()", "path": "library/operator#operator.__and__", "type": "Functional Programming", "text": "\nReturn the bitwise and of a and b.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__concat__()", "path": "library/operator#operator.__concat__", "type": "Functional Programming", "text": "\nReturn `a + b` for a and b sequences.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__contains__()", "path": "library/operator#operator.__contains__", "type": "Functional Programming", "text": "\nReturn the outcome of the test `b in a`. Note the reversed operands.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__delitem__()", "path": "library/operator#operator.__delitem__", "type": "Functional Programming", "text": "\nRemove the value of a at index b.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__eq__()", "path": "library/operator#operator.__eq__", "type": "Functional Programming", "text": "\nPerform \u201crich comparisons\u201d between a and b. Specifically, `lt(a, b)` is\nequivalent to `a < b`, `le(a, b)` is equivalent to `a <= b`, `eq(a, b)` is\nequivalent to `a == b`, `ne(a, b)` is equivalent to `a != b`, `gt(a, b)` is\nequivalent to `a > b` and `ge(a, b)` is equivalent to `a >= b`. Note that\nthese functions can return any value, which may or may not be interpretable as\na Boolean value. See Comparisons for more information about rich comparisons.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__floordiv__()", "path": "library/operator#operator.__floordiv__", "type": "Functional Programming", "text": "\nReturn `a // b`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__getitem__()", "path": "library/operator#operator.__getitem__", "type": "Functional Programming", "text": "\nReturn the value of a at index b.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__ge__()", "path": "library/operator#operator.__ge__", "type": "Functional Programming", "text": "\nPerform \u201crich comparisons\u201d between a and b. Specifically, `lt(a, b)` is\nequivalent to `a < b`, `le(a, b)` is equivalent to `a <= b`, `eq(a, b)` is\nequivalent to `a == b`, `ne(a, b)` is equivalent to `a != b`, `gt(a, b)` is\nequivalent to `a > b` and `ge(a, b)` is equivalent to `a >= b`. Note that\nthese functions can return any value, which may or may not be interpretable as\na Boolean value. See Comparisons for more information about rich comparisons.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__gt__()", "path": "library/operator#operator.__gt__", "type": "Functional Programming", "text": "\nPerform \u201crich comparisons\u201d between a and b. Specifically, `lt(a, b)` is\nequivalent to `a < b`, `le(a, b)` is equivalent to `a <= b`, `eq(a, b)` is\nequivalent to `a == b`, `ne(a, b)` is equivalent to `a != b`, `gt(a, b)` is\nequivalent to `a > b` and `ge(a, b)` is equivalent to `a >= b`. Note that\nthese functions can return any value, which may or may not be interpretable as\na Boolean value. See Comparisons for more information about rich comparisons.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__iadd__()", "path": "library/operator#operator.__iadd__", "type": "Functional Programming", "text": "\n`a = iadd(a, b)` is equivalent to `a += b`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__iand__()", "path": "library/operator#operator.__iand__", "type": "Functional Programming", "text": "\n`a = iand(a, b)` is equivalent to `a &= b`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__iconcat__()", "path": "library/operator#operator.__iconcat__", "type": "Functional Programming", "text": "\n`a = iconcat(a, b)` is equivalent to `a += b` for a and b sequences.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__ifloordiv__()", "path": "library/operator#operator.__ifloordiv__", "type": "Functional Programming", "text": "\n`a = ifloordiv(a, b)` is equivalent to `a //= b`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__ilshift__()", "path": "library/operator#operator.__ilshift__", "type": "Functional Programming", "text": "\n`a = ilshift(a, b)` is equivalent to `a <<= b`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__imatmul__()", "path": "library/operator#operator.__imatmul__", "type": "Functional Programming", "text": "\n`a = imatmul(a, b)` is equivalent to `a @= b`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__imod__()", "path": "library/operator#operator.__imod__", "type": "Functional Programming", "text": "\n`a = imod(a, b)` is equivalent to `a %= b`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__imul__()", "path": "library/operator#operator.__imul__", "type": "Functional Programming", "text": "\n`a = imul(a, b)` is equivalent to `a *= b`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__index__()", "path": "library/operator#operator.__index__", "type": "Functional Programming", "text": "\nReturn a converted to an integer. Equivalent to `a.__index__()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__invert__()", "path": "library/operator#operator.__invert__", "type": "Functional Programming", "text": "\nReturn the bitwise inverse of the number obj. This is equivalent to `~obj`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__inv__()", "path": "library/operator#operator.__inv__", "type": "Functional Programming", "text": "\nReturn the bitwise inverse of the number obj. This is equivalent to `~obj`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__ior__()", "path": "library/operator#operator.__ior__", "type": "Functional Programming", "text": "\n`a = ior(a, b)` is equivalent to `a |= b`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__ipow__()", "path": "library/operator#operator.__ipow__", "type": "Functional Programming", "text": "\n`a = ipow(a, b)` is equivalent to `a **= b`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__irshift__()", "path": "library/operator#operator.__irshift__", "type": "Functional Programming", "text": "\n`a = irshift(a, b)` is equivalent to `a >>= b`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__isub__()", "path": "library/operator#operator.__isub__", "type": "Functional Programming", "text": "\n`a = isub(a, b)` is equivalent to `a -= b`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__itruediv__()", "path": "library/operator#operator.__itruediv__", "type": "Functional Programming", "text": "\n`a = itruediv(a, b)` is equivalent to `a /= b`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__ixor__()", "path": "library/operator#operator.__ixor__", "type": "Functional Programming", "text": "\n`a = ixor(a, b)` is equivalent to `a ^= b`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__le__()", "path": "library/operator#operator.__le__", "type": "Functional Programming", "text": "\nPerform \u201crich comparisons\u201d between a and b. Specifically, `lt(a, b)` is\nequivalent to `a < b`, `le(a, b)` is equivalent to `a <= b`, `eq(a, b)` is\nequivalent to `a == b`, `ne(a, b)` is equivalent to `a != b`, `gt(a, b)` is\nequivalent to `a > b` and `ge(a, b)` is equivalent to `a >= b`. Note that\nthese functions can return any value, which may or may not be interpretable as\na Boolean value. See Comparisons for more information about rich comparisons.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__lshift__()", "path": "library/operator#operator.__lshift__", "type": "Functional Programming", "text": "\nReturn a shifted left by b.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__lt__()", "path": "library/operator#operator.__lt__", "type": "Functional Programming", "text": "\nPerform \u201crich comparisons\u201d between a and b. Specifically, `lt(a, b)` is\nequivalent to `a < b`, `le(a, b)` is equivalent to `a <= b`, `eq(a, b)` is\nequivalent to `a == b`, `ne(a, b)` is equivalent to `a != b`, `gt(a, b)` is\nequivalent to `a > b` and `ge(a, b)` is equivalent to `a >= b`. Note that\nthese functions can return any value, which may or may not be interpretable as\na Boolean value. See Comparisons for more information about rich comparisons.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__matmul__()", "path": "library/operator#operator.__matmul__", "type": "Functional Programming", "text": "\nReturn `a @ b`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__mod__()", "path": "library/operator#operator.__mod__", "type": "Functional Programming", "text": "\nReturn `a % b`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__mul__()", "path": "library/operator#operator.__mul__", "type": "Functional Programming", "text": "\nReturn `a * b`, for a and b numbers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__neg__()", "path": "library/operator#operator.__neg__", "type": "Functional Programming", "text": "\nReturn obj negated (`-obj`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__ne__()", "path": "library/operator#operator.__ne__", "type": "Functional Programming", "text": "\nPerform \u201crich comparisons\u201d between a and b. Specifically, `lt(a, b)` is\nequivalent to `a < b`, `le(a, b)` is equivalent to `a <= b`, `eq(a, b)` is\nequivalent to `a == b`, `ne(a, b)` is equivalent to `a != b`, `gt(a, b)` is\nequivalent to `a > b` and `ge(a, b)` is equivalent to `a >= b`. Note that\nthese functions can return any value, which may or may not be interpretable as\na Boolean value. See Comparisons for more information about rich comparisons.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__not__()", "path": "library/operator#operator.__not__", "type": "Functional Programming", "text": "\nReturn the outcome of `not` obj. (Note that there is no `__not__()` method for\nobject instances; only the interpreter core defines this operation. The result\nis affected by the `__bool__()` and `__len__()` methods.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__or__()", "path": "library/operator#operator.__or__", "type": "Functional Programming", "text": "\nReturn the bitwise or of a and b.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__pos__()", "path": "library/operator#operator.__pos__", "type": "Functional Programming", "text": "\nReturn obj positive (`+obj`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__pow__()", "path": "library/operator#operator.__pow__", "type": "Functional Programming", "text": "\nReturn `a ** b`, for a and b numbers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__rshift__()", "path": "library/operator#operator.__rshift__", "type": "Functional Programming", "text": "\nReturn a shifted right by b.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__setitem__()", "path": "library/operator#operator.__setitem__", "type": "Functional Programming", "text": "\nSet the value of a at index b to c.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__sub__()", "path": "library/operator#operator.__sub__", "type": "Functional Programming", "text": "\nReturn `a - b`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__truediv__()", "path": "library/operator#operator.__truediv__", "type": "Functional Programming", "text": "\nReturn `a / b` where 2/3 is .66 rather than 0. This is also known as \u201ctrue\u201d\ndivision.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "operator.__xor__()", "path": "library/operator#operator.__xor__", "type": "Functional Programming", "text": "\nReturn the bitwise exclusive or of a and b.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ord()", "path": "library/functions#ord", "type": "Built-in Functions", "text": "\nGiven a string representing one Unicode character, return an integer\nrepresenting the Unicode code point of that character. For example, `ord('a')`\nreturns the integer `97` and `ord('\u20ac')` (Euro sign) returns `8364`. This is\nthe inverse of `chr()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os", "path": "library/os", "type": "Operating System", "text": "\nSource code: Lib/os.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.abort()", "path": "library/os#os.abort", "type": "Operating System", "text": "\nGenerate a `SIGABRT` signal to the current process. On Unix, the default\nbehavior is to produce a core dump; on Windows, the process immediately\nreturns an exit code of `3`. Be aware that calling this function will not call\nthe Python signal handler registered for `SIGABRT` with `signal.signal()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.access()", "path": "library/os#os.access", "type": "Operating System", "text": "\nUse the real uid/gid to test for access to path. Note that most operations\nwill use the effective uid/gid, therefore this routine can be used in a\nsuid/sgid environment to test if the invoking user has the specified access to\npath. mode should be `F_OK` to test the existence of path, or it can be the\ninclusive OR of one or more of `R_OK`, `W_OK`, and `X_OK` to test permissions.\nReturn `True` if access is allowed, `False` if not. See the Unix man page\naccess(2) for more information.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.add_dll_directory()", "path": "library/os#os.add_dll_directory", "type": "Operating System", "text": "\nAdd a path to the DLL search path.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.altsep", "path": "library/os#os.altsep", "type": "Operating System", "text": "\nAn alternative character used by the operating system to separate pathname\ncomponents, or `None` if only one separator character exists. This is set to\n`'/'` on Windows systems where `sep` is a backslash. Also available via\n`os.path`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.chdir()", "path": "library/os#os.chdir", "type": "Operating System", "text": "\nChange the current working directory to path.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.chflags()", "path": "library/os#os.chflags", "type": "Operating System", "text": "\nSet the flags of path to the numeric flags. flags may take a combination\n(bitwise OR) of the following values (as defined in the `stat` module):\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.chmod()", "path": "library/os#os.chmod", "type": "Operating System", "text": "\nChange the mode of path to the numeric mode. mode may take one of the\nfollowing values (as defined in the `stat` module) or bitwise ORed\ncombinations of them:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.chown()", "path": "library/os#os.chown", "type": "Operating System", "text": "\nChange the owner and group id of path to the numeric uid and gid. To leave one\nof the ids unchanged, set it to -1.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.chroot()", "path": "library/os#os.chroot", "type": "Operating System", "text": "\nChange the root directory of the current process to path.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.CLD_CONTINUED", "path": "library/os#os.CLD_CONTINUED", "type": "Operating System", "text": "\nThese are the possible values for `si_code` in the result returned by\n`waitid()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.CLD_DUMPED", "path": "library/os#os.CLD_DUMPED", "type": "Operating System", "text": "\nThese are the possible values for `si_code` in the result returned by\n`waitid()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.CLD_EXITED", "path": "library/os#os.CLD_EXITED", "type": "Operating System", "text": "\nThese are the possible values for `si_code` in the result returned by\n`waitid()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.CLD_KILLED", "path": "library/os#os.CLD_KILLED", "type": "Operating System", "text": "\nThese are the possible values for `si_code` in the result returned by\n`waitid()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.CLD_STOPPED", "path": "library/os#os.CLD_STOPPED", "type": "Operating System", "text": "\nThese are the possible values for `si_code` in the result returned by\n`waitid()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.CLD_TRAPPED", "path": "library/os#os.CLD_TRAPPED", "type": "Operating System", "text": "\nThese are the possible values for `si_code` in the result returned by\n`waitid()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.close()", "path": "library/os#os.close", "type": "Operating System", "text": "\nClose file descriptor fd.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.closerange()", "path": "library/os#os.closerange", "type": "Operating System", "text": "\nClose all file descriptors from fd_low (inclusive) to fd_high (exclusive),\nignoring errors. Equivalent to (but much faster than):\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.confstr()", "path": "library/os#os.confstr", "type": "Operating System", "text": "\nReturn string-valued system configuration values. name specifies the\nconfiguration value to retrieve; it may be a string which is the name of a\ndefined system value; these names are specified in a number of standards\n(POSIX, Unix 95, Unix 98, and others). Some platforms define additional names\nas well. The names known to the host operating system are given as the keys of\nthe `confstr_names` dictionary. For configuration variables not included in\nthat mapping, passing an integer for name is also accepted.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.confstr_names", "path": "library/os#os.confstr_names", "type": "Operating System", "text": "\nDictionary mapping names accepted by `confstr()` to the integer values defined\nfor those names by the host operating system. This can be used to determine\nthe set of names known to the system.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.copy_file_range()", "path": "library/os#os.copy_file_range", "type": "Operating System", "text": "\nCopy count bytes from file descriptor src, starting from offset offset_src, to\nfile descriptor dst, starting from offset offset_dst. If offset_src is None,\nthen src is read from the current position; respectively for offset_dst. The\nfiles pointed by src and dst must reside in the same filesystem, otherwise an\n`OSError` is raised with `errno` set to `errno.EXDEV`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.cpu_count()", "path": "library/os#os.cpu_count", "type": "Operating System", "text": "\nReturn the number of CPUs in the system. Returns `None` if undetermined.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.ctermid()", "path": "library/os#os.ctermid", "type": "Operating System", "text": "\nReturn the filename corresponding to the controlling terminal of the process.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.curdir", "path": "library/os#os.curdir", "type": "Operating System", "text": "\nThe constant string used by the operating system to refer to the current\ndirectory. This is `'.'` for Windows and POSIX. Also available via `os.path`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.defpath", "path": "library/os#os.defpath", "type": "Operating System", "text": "\nThe default search path used by `exec*p*` and `spawn*p*` if the environment\ndoesn\u2019t have a `'PATH'` key. Also available via `os.path`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.device_encoding()", "path": "library/os#os.device_encoding", "type": "Operating System", "text": "\nReturn a string describing the encoding of the device associated with fd if it\nis connected to a terminal; else return `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.devnull", "path": "library/os#os.devnull", "type": "Operating System", "text": "\nThe file path of the null device. For example: `'/dev/null'` for POSIX,\n`'nul'` for Windows. Also available via `os.path`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.DirEntry", "path": "library/os#os.DirEntry", "type": "Operating System", "text": "\nObject yielded by `scandir()` to expose the file path and other file\nattributes of a directory entry.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.DirEntry.inode()", "path": "library/os#os.DirEntry.inode", "type": "Operating System", "text": "\nReturn the inode number of the entry.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.DirEntry.is_dir()", "path": "library/os#os.DirEntry.is_dir", "type": "Operating System", "text": "\nReturn `True` if this entry is a directory or a symbolic link pointing to a\ndirectory; return `False` if the entry is or points to any other kind of file,\nor if it doesn\u2019t exist anymore.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.DirEntry.is_file()", "path": "library/os#os.DirEntry.is_file", "type": "Operating System", "text": "\nReturn `True` if this entry is a file or a symbolic link pointing to a file;\nreturn `False` if the entry is or points to a directory or other non-file\nentry, or if it doesn\u2019t exist anymore.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.DirEntry.is_symlink()", "path": "library/os#os.DirEntry.is_symlink", "type": "Operating System", "text": "\nReturn `True` if this entry is a symbolic link (even if broken); return\n`False` if the entry points to a directory or any kind of file, or if it\ndoesn\u2019t exist anymore.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.DirEntry.name", "path": "library/os#os.DirEntry.name", "type": "Operating System", "text": "\nThe entry\u2019s base filename, relative to the `scandir()` path argument.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.DirEntry.path", "path": "library/os#os.DirEntry.path", "type": "Operating System", "text": "\nThe entry\u2019s full path name: equivalent to `os.path.join(scandir_path,\nentry.name)` where scandir_path is the `scandir()` path argument. The path is\nonly absolute if the `scandir()` path argument was absolute. If the\n`scandir()` path argument was a file descriptor, the `path` attribute is the\nsame as the `name` attribute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.DirEntry.stat()", "path": "library/os#os.DirEntry.stat", "type": "Operating System", "text": "\nReturn a `stat_result` object for this entry. This method follows symbolic\nlinks by default; to stat a symbolic link add the `follow_symlinks=False`\nargument.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.dup()", "path": "library/os#os.dup", "type": "Operating System", "text": "\nReturn a duplicate of file descriptor fd. The new file descriptor is non-\ninheritable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.dup2()", "path": "library/os#os.dup2", "type": "Operating System", "text": "\nDuplicate file descriptor fd to fd2, closing the latter first if necessary.\nReturn fd2. The new file descriptor is inheritable by default or non-\ninheritable if inheritable is `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.environ", "path": "library/os#os.environ", "type": "Operating System", "text": "\nA mapping object representing the string environment. For example,\n`environ['HOME']` is the pathname of your home directory (on some platforms),\nand is equivalent to `getenv(\"HOME\")` in C.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.environb", "path": "library/os#os.environb", "type": "Operating System", "text": "\nBytes version of `environ`: a mapping object representing the environment as\nbyte strings. `environ` and `environb` are synchronized (modify `environb`\nupdates `environ`, and vice versa).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.error", "path": "library/os#os.error", "type": "Operating System", "text": "\nAn alias for the built-in `OSError` exception.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.execl()", "path": "library/os#os.execl", "type": "Operating System", "text": "\nThese functions all execute a new program, replacing the current process; they\ndo not return. On Unix, the new executable is loaded into the current process,\nand will have the same process id as the caller. Errors will be reported as\n`OSError` exceptions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.execle()", "path": "library/os#os.execle", "type": "Operating System", "text": "\nThese functions all execute a new program, replacing the current process; they\ndo not return. On Unix, the new executable is loaded into the current process,\nand will have the same process id as the caller. Errors will be reported as\n`OSError` exceptions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.execlp()", "path": "library/os#os.execlp", "type": "Operating System", "text": "\nThese functions all execute a new program, replacing the current process; they\ndo not return. On Unix, the new executable is loaded into the current process,\nand will have the same process id as the caller. Errors will be reported as\n`OSError` exceptions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.execlpe()", "path": "library/os#os.execlpe", "type": "Operating System", "text": "\nThese functions all execute a new program, replacing the current process; they\ndo not return. On Unix, the new executable is loaded into the current process,\nand will have the same process id as the caller. Errors will be reported as\n`OSError` exceptions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.execv()", "path": "library/os#os.execv", "type": "Operating System", "text": "\nThese functions all execute a new program, replacing the current process; they\ndo not return. On Unix, the new executable is loaded into the current process,\nand will have the same process id as the caller. Errors will be reported as\n`OSError` exceptions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.execve()", "path": "library/os#os.execve", "type": "Operating System", "text": "\nThese functions all execute a new program, replacing the current process; they\ndo not return. On Unix, the new executable is loaded into the current process,\nand will have the same process id as the caller. Errors will be reported as\n`OSError` exceptions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.execvp()", "path": "library/os#os.execvp", "type": "Operating System", "text": "\nThese functions all execute a new program, replacing the current process; they\ndo not return. On Unix, the new executable is loaded into the current process,\nand will have the same process id as the caller. Errors will be reported as\n`OSError` exceptions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.execvpe()", "path": "library/os#os.execvpe", "type": "Operating System", "text": "\nThese functions all execute a new program, replacing the current process; they\ndo not return. On Unix, the new executable is loaded into the current process,\nand will have the same process id as the caller. Errors will be reported as\n`OSError` exceptions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.extsep", "path": "library/os#os.extsep", "type": "Operating System", "text": "\nThe character which separates the base filename from the extension; for\nexample, the `'.'` in `os.py`. Also available via `os.path`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.EX_CANTCREAT", "path": "library/os#os.EX_CANTCREAT", "type": "Operating System", "text": "\nExit code that means a user specified output file could not be created.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.EX_CONFIG", "path": "library/os#os.EX_CONFIG", "type": "Operating System", "text": "\nExit code that means that some kind of configuration error occurred.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.EX_DATAERR", "path": "library/os#os.EX_DATAERR", "type": "Operating System", "text": "\nExit code that means the input data was incorrect.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.EX_IOERR", "path": "library/os#os.EX_IOERR", "type": "Operating System", "text": "\nExit code that means that an error occurred while doing I/O on some file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.EX_NOHOST", "path": "library/os#os.EX_NOHOST", "type": "Operating System", "text": "\nExit code that means a specified host did not exist.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.EX_NOINPUT", "path": "library/os#os.EX_NOINPUT", "type": "Operating System", "text": "\nExit code that means an input file did not exist or was not readable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.EX_NOPERM", "path": "library/os#os.EX_NOPERM", "type": "Operating System", "text": "\nExit code that means that there were insufficient permissions to perform the\noperation (but not intended for file system problems).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.EX_NOTFOUND", "path": "library/os#os.EX_NOTFOUND", "type": "Operating System", "text": "\nExit code that means something like \u201can entry was not found\u201d.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.EX_NOUSER", "path": "library/os#os.EX_NOUSER", "type": "Operating System", "text": "\nExit code that means a specified user did not exist.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.EX_OK", "path": "library/os#os.EX_OK", "type": "Operating System", "text": "\nExit code that means no error occurred.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.EX_OSERR", "path": "library/os#os.EX_OSERR", "type": "Operating System", "text": "\nExit code that means an operating system error was detected, such as the\ninability to fork or create a pipe.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.EX_OSFILE", "path": "library/os#os.EX_OSFILE", "type": "Operating System", "text": "\nExit code that means some system file did not exist, could not be opened, or\nhad some other kind of error.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.EX_PROTOCOL", "path": "library/os#os.EX_PROTOCOL", "type": "Operating System", "text": "\nExit code that means that a protocol exchange was illegal, invalid, or not\nunderstood.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.EX_SOFTWARE", "path": "library/os#os.EX_SOFTWARE", "type": "Operating System", "text": "\nExit code that means an internal software error was detected.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.EX_TEMPFAIL", "path": "library/os#os.EX_TEMPFAIL", "type": "Operating System", "text": "\nExit code that means a temporary failure occurred. This indicates something\nthat may not really be an error, such as a network connection that couldn\u2019t be\nmade during a retryable operation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.EX_UNAVAILABLE", "path": "library/os#os.EX_UNAVAILABLE", "type": "Operating System", "text": "\nExit code that means that a required service is unavailable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.EX_USAGE", "path": "library/os#os.EX_USAGE", "type": "Operating System", "text": "\nExit code that means the command was used incorrectly, such as when the wrong\nnumber of arguments are given.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.fchdir()", "path": "library/os#os.fchdir", "type": "Operating System", "text": "\nChange the current working directory to the directory represented by the file\ndescriptor fd. The descriptor must refer to an opened directory, not an open\nfile. As of Python 3.3, this is equivalent to `os.chdir(fd)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.fchmod()", "path": "library/os#os.fchmod", "type": "Operating System", "text": "\nChange the mode of the file given by fd to the numeric mode. See the docs for\n`chmod()` for possible values of mode. As of Python 3.3, this is equivalent to\n`os.chmod(fd, mode)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.fchown()", "path": "library/os#os.fchown", "type": "Operating System", "text": "\nChange the owner and group id of the file given by fd to the numeric uid and\ngid. To leave one of the ids unchanged, set it to -1. See `chown()`. As of\nPython 3.3, this is equivalent to `os.chown(fd, uid, gid)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.fdatasync()", "path": "library/os#os.fdatasync", "type": "Operating System", "text": "\nForce write of file with filedescriptor fd to disk. Does not force update of\nmetadata.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.fdopen()", "path": "library/os#os.fdopen", "type": "Operating System", "text": "\nReturn an open file object connected to the file descriptor fd. This is an\nalias of the `open()` built-in function and accepts the same arguments. The\nonly difference is that the first argument of `fdopen()` must always be an\ninteger.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.fork()", "path": "library/os#os.fork", "type": "Operating System", "text": "\nFork a child process. Return `0` in the child and the child\u2019s process id in\nthe parent. If an error occurs `OSError` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.forkpty()", "path": "library/os#os.forkpty", "type": "Operating System", "text": "\nFork a child process, using a new pseudo-terminal as the child\u2019s controlling\nterminal. Return a pair of `(pid, fd)`, where pid is `0` in the child, the new\nchild\u2019s process id in the parent, and fd is the file descriptor of the master\nend of the pseudo-terminal. For a more portable approach, use the `pty`\nmodule. If an error occurs `OSError` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.fpathconf()", "path": "library/os#os.fpathconf", "type": "Operating System", "text": "\nReturn system configuration information relevant to an open file. name\nspecifies the configuration value to retrieve; it may be a string which is the\nname of a defined system value; these names are specified in a number of\nstandards (POSIX.1, Unix 95, Unix 98, and others). Some platforms define\nadditional names as well. The names known to the host operating system are\ngiven in the `pathconf_names` dictionary. For configuration variables not\nincluded in that mapping, passing an integer for name is also accepted.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.fsdecode()", "path": "library/os#os.fsdecode", "type": "Operating System", "text": "\nDecode the path-like filename from the filesystem encoding with\n`'surrogateescape'` error handler, or `'strict'` on Windows; return `str`\nunchanged.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.fsencode()", "path": "library/os#os.fsencode", "type": "Operating System", "text": "\nEncode path-like filename to the filesystem encoding with `'surrogateescape'`\nerror handler, or `'strict'` on Windows; return `bytes` unchanged.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.fspath()", "path": "library/os#os.fspath", "type": "Operating System", "text": "\nReturn the file system representation of the path.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.fstat()", "path": "library/os#os.fstat", "type": "Operating System", "text": "\nGet the status of the file descriptor fd. Return a `stat_result` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.fstatvfs()", "path": "library/os#os.fstatvfs", "type": "Operating System", "text": "\nReturn information about the filesystem containing the file associated with\nfile descriptor fd, like `statvfs()`. As of Python 3.3, this is equivalent to\n`os.statvfs(fd)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.fsync()", "path": "library/os#os.fsync", "type": "Operating System", "text": "\nForce write of file with filedescriptor fd to disk. On Unix, this calls the\nnative `fsync()` function; on Windows, the MS `_commit()` function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.ftruncate()", "path": "library/os#os.ftruncate", "type": "Operating System", "text": "\nTruncate the file corresponding to file descriptor fd, so that it is at most\nlength bytes in size. As of Python 3.3, this is equivalent to `os.truncate(fd,\nlength)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.fwalk()", "path": "library/os#os.fwalk", "type": "Operating System", "text": "\nThis behaves exactly like `walk()`, except that it yields a 4-tuple `(dirpath,\ndirnames, filenames, dirfd)`, and it supports `dir_fd`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.F_LOCK", "path": "library/os#os.F_LOCK", "type": "Operating System", "text": "\nFlags that specify what action `lockf()` will take.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.F_OK", "path": "library/os#os.F_OK", "type": "Operating System", "text": "\nValues to pass as the mode parameter of `access()` to test the existence,\nreadability, writability and executability of path, respectively.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.F_TEST", "path": "library/os#os.F_TEST", "type": "Operating System", "text": "\nFlags that specify what action `lockf()` will take.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.F_TLOCK", "path": "library/os#os.F_TLOCK", "type": "Operating System", "text": "\nFlags that specify what action `lockf()` will take.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.F_ULOCK", "path": "library/os#os.F_ULOCK", "type": "Operating System", "text": "\nFlags that specify what action `lockf()` will take.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.getcwd()", "path": "library/os#os.getcwd", "type": "Operating System", "text": "\nReturn a string representing the current working directory.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.getcwdb()", "path": "library/os#os.getcwdb", "type": "Operating System", "text": "\nReturn a bytestring representing the current working directory.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.getegid()", "path": "library/os#os.getegid", "type": "Operating System", "text": "\nReturn the effective group id of the current process. This corresponds to the\n\u201cset id\u201d bit on the file being executed in the current process.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.getenv()", "path": "library/os#os.getenv", "type": "Operating System", "text": "\nReturn the value of the environment variable key if it exists, or default if\nit doesn\u2019t. key, default and the result are str.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.getenvb()", "path": "library/os#os.getenvb", "type": "Operating System", "text": "\nReturn the value of the environment variable key if it exists, or default if\nit doesn\u2019t. key, default and the result are bytes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.geteuid()", "path": "library/os#os.geteuid", "type": "Operating System", "text": "\nReturn the current process\u2019s effective user id.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.getgid()", "path": "library/os#os.getgid", "type": "Operating System", "text": "\nReturn the real group id of the current process.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.getgrouplist()", "path": "library/os#os.getgrouplist", "type": "Operating System", "text": "\nReturn list of group ids that user belongs to. If group is not in the list, it\nis included; typically, group is specified as the group ID field from the\npassword record for user.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.getgroups()", "path": "library/os#os.getgroups", "type": "Operating System", "text": "\nReturn list of supplemental group ids associated with the current process.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.getloadavg()", "path": "library/os#os.getloadavg", "type": "Operating System", "text": "\nReturn the number of processes in the system run queue averaged over the last\n1, 5, and 15 minutes or raises `OSError` if the load average was unobtainable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.getlogin()", "path": "library/os#os.getlogin", "type": "Operating System", "text": "\nReturn the name of the user logged in on the controlling terminal of the\nprocess. For most purposes, it is more useful to use `getpass.getuser()` since\nthe latter checks the environment variables `LOGNAME` or `USERNAME` to find\nout who the user is, and falls back to `pwd.getpwuid(os.getuid())[0]` to get\nthe login name of the current real user id.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.getpgid()", "path": "library/os#os.getpgid", "type": "Operating System", "text": "\nReturn the process group id of the process with process id pid. If pid is 0,\nthe process group id of the current process is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.getpgrp()", "path": "library/os#os.getpgrp", "type": "Operating System", "text": "\nReturn the id of the current process group.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.getpid()", "path": "library/os#os.getpid", "type": "Operating System", "text": "\nReturn the current process id.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.getppid()", "path": "library/os#os.getppid", "type": "Operating System", "text": "\nReturn the parent\u2019s process id. When the parent process has exited, on Unix\nthe id returned is the one of the init process (1), on Windows it is still the\nsame id, which may be already reused by another process.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.getpriority()", "path": "library/os#os.getpriority", "type": "Operating System", "text": "\nGet program scheduling priority. The value which is one of `PRIO_PROCESS`,\n`PRIO_PGRP`, or `PRIO_USER`, and who is interpreted relative to which (a\nprocess identifier for `PRIO_PROCESS`, process group identifier for\n`PRIO_PGRP`, and a user ID for `PRIO_USER`). A zero value for who denotes\n(respectively) the calling process, the process group of the calling process,\nor the real user ID of the calling process.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.getrandom()", "path": "library/os#os.getrandom", "type": "Operating System", "text": "\nGet up to size random bytes. The function can return less bytes than\nrequested.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.getresgid()", "path": "library/os#os.getresgid", "type": "Operating System", "text": "\nReturn a tuple (rgid, egid, sgid) denoting the current process\u2019s real,\neffective, and saved group ids.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.getresuid()", "path": "library/os#os.getresuid", "type": "Operating System", "text": "\nReturn a tuple (ruid, euid, suid) denoting the current process\u2019s real,\neffective, and saved user ids.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.getsid()", "path": "library/os#os.getsid", "type": "Operating System", "text": "\nCall the system call `getsid()`. See the Unix manual for the semantics.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.getuid()", "path": "library/os#os.getuid", "type": "Operating System", "text": "\nReturn the current process\u2019s real user id.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.getxattr()", "path": "library/os#os.getxattr", "type": "Operating System", "text": "\nReturn the value of the extended filesystem attribute attribute for path.\nattribute can be bytes or str (directly or indirectly through the `PathLike`\ninterface). If it is str, it is encoded with the filesystem encoding.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.get_blocking()", "path": "library/os#os.get_blocking", "type": "Operating System", "text": "\nGet the blocking mode of the file descriptor: `False` if the `O_NONBLOCK` flag\nis set, `True` if the flag is cleared.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.get_exec_path()", "path": "library/os#os.get_exec_path", "type": "Operating System", "text": "\nReturns the list of directories that will be searched for a named executable,\nsimilar to a shell, when launching a process. env, when specified, should be\nan environment variable dictionary to lookup the PATH in. By default, when env\nis `None`, `environ` is used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.get_handle_inheritable()", "path": "library/os#os.get_handle_inheritable", "type": "Operating System", "text": "\nGet the \u201cinheritable\u201d flag of the specified handle (a boolean).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.get_inheritable()", "path": "library/os#os.get_inheritable", "type": "Operating System", "text": "\nGet the \u201cinheritable\u201d flag of the specified file descriptor (a boolean).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.get_terminal_size()", "path": "library/os#os.get_terminal_size", "type": "Operating System", "text": "\nReturn the size of the terminal window as `(columns, lines)`, tuple of type\n`terminal_size`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.GRND_NONBLOCK", "path": "library/os#os.GRND_NONBLOCK", "type": "Operating System", "text": "\nBy default, when reading from `/dev/random`, `getrandom()` blocks if no random\nbytes are available, and when reading from `/dev/urandom`, it blocks if the\nentropy pool has not yet been initialized.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.GRND_RANDOM", "path": "library/os#os.GRND_RANDOM", "type": "Operating System", "text": "\nIf this bit is set, then random bytes are drawn from the `/dev/random` pool\ninstead of the `/dev/urandom` pool.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.initgroups()", "path": "library/os#os.initgroups", "type": "Operating System", "text": "\nCall the system initgroups() to initialize the group access list with all of\nthe groups of which the specified username is a member, plus the specified\ngroup id.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.isatty()", "path": "library/os#os.isatty", "type": "Operating System", "text": "\nReturn `True` if the file descriptor fd is open and connected to a tty(-like)\ndevice, else `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.kill()", "path": "library/os#os.kill", "type": "Operating System", "text": "\nSend signal sig to the process pid. Constants for the specific signals\navailable on the host platform are defined in the `signal` module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.killpg()", "path": "library/os#os.killpg", "type": "Operating System", "text": "\nSend the signal sig to the process group pgid.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.lchflags()", "path": "library/os#os.lchflags", "type": "Operating System", "text": "\nSet the flags of path to the numeric flags, like `chflags()`, but do not\nfollow symbolic links. As of Python 3.3, this is equivalent to\n`os.chflags(path, flags, follow_symlinks=False)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.lchmod()", "path": "library/os#os.lchmod", "type": "Operating System", "text": "\nChange the mode of path to the numeric mode. If path is a symlink, this\naffects the symlink rather than the target. See the docs for `chmod()` for\npossible values of mode. As of Python 3.3, this is equivalent to\n`os.chmod(path, mode, follow_symlinks=False)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.lchown()", "path": "library/os#os.lchown", "type": "Operating System", "text": "\nChange the owner and group id of path to the numeric uid and gid. This\nfunction will not follow symbolic links. As of Python 3.3, this is equivalent\nto `os.chown(path, uid, gid, follow_symlinks=False)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.linesep", "path": "library/os#os.linesep", "type": "Operating System", "text": "\nThe string used to separate (or, rather, terminate) lines on the current\nplatform. This may be a single character, such as `'\\n'` for POSIX, or\nmultiple characters, for example, `'\\r\\n'` for Windows. Do not use os.linesep\nas a line terminator when writing files opened in text mode (the default); use\na single `'\\n'` instead, on all platforms.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.link()", "path": "library/os#os.link", "type": "Operating System", "text": "\nCreate a hard link pointing to src named dst.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.listdir()", "path": "library/os#os.listdir", "type": "Operating System", "text": "\nReturn a list containing the names of the entries in the directory given by\npath. The list is in arbitrary order, and does not include the special entries\n`'.'` and `'..'` even if they are present in the directory. If a file is\nremoved from or added to the directory during the call of this function,\nwhether a name for that file be included is unspecified.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.listxattr()", "path": "library/os#os.listxattr", "type": "Operating System", "text": "\nReturn a list of the extended filesystem attributes on path. The attributes in\nthe list are represented as strings decoded with the filesystem encoding. If\npath is `None`, `listxattr()` will examine the current directory.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.lockf()", "path": "library/os#os.lockf", "type": "Operating System", "text": "\nApply, test or remove a POSIX lock on an open file descriptor. fd is an open\nfile descriptor. cmd specifies the command to use - one of `F_LOCK`,\n`F_TLOCK`, `F_ULOCK` or `F_TEST`. len specifies the section of the file to\nlock.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.lseek()", "path": "library/os#os.lseek", "type": "Operating System", "text": "\nSet the current position of file descriptor fd to position pos, modified by\nhow: `SEEK_SET` or `0` to set the position relative to the beginning of the\nfile; `SEEK_CUR` or `1` to set it relative to the current position; `SEEK_END`\nor `2` to set it relative to the end of the file. Return the new cursor\nposition in bytes, starting from the beginning.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.lstat()", "path": "library/os#os.lstat", "type": "Operating System", "text": "\nPerform the equivalent of an `lstat()` system call on the given path. Similar\nto `stat()`, but does not follow symbolic links. Return a `stat_result`\nobject.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.major()", "path": "library/os#os.major", "type": "Operating System", "text": "\nExtract the device major number from a raw device number (usually the `st_dev`\nor `st_rdev` field from `stat`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.makedev()", "path": "library/os#os.makedev", "type": "Operating System", "text": "\nCompose a raw device number from the major and minor device numbers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.makedirs()", "path": "library/os#os.makedirs", "type": "Operating System", "text": "\nRecursive directory creation function. Like `mkdir()`, but makes all\nintermediate-level directories needed to contain the leaf directory.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.memfd_create()", "path": "library/os#os.memfd_create", "type": "Operating System", "text": "\nCreate an anonymous file and return a file descriptor that refers to it. flags\nmust be one of the `os.MFD_*` constants available on the system (or a bitwise\nORed combination of them). By default, the new file descriptor is non-\ninheritable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.MFD_ALLOW_SEALING", "path": "library/os#os.MFD_ALLOW_SEALING", "type": "Operating System", "text": "\nThese flags can be passed to `memfd_create()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.MFD_CLOEXEC", "path": "library/os#os.MFD_CLOEXEC", "type": "Operating System", "text": "\nThese flags can be passed to `memfd_create()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.MFD_HUGETLB", "path": "library/os#os.MFD_HUGETLB", "type": "Operating System", "text": "\nThese flags can be passed to `memfd_create()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.MFD_HUGE_16GB", "path": "library/os#os.MFD_HUGE_16GB", "type": "Operating System", "text": "\nThese flags can be passed to `memfd_create()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.MFD_HUGE_16MB", "path": "library/os#os.MFD_HUGE_16MB", "type": "Operating System", "text": "\nThese flags can be passed to `memfd_create()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.MFD_HUGE_1GB", "path": "library/os#os.MFD_HUGE_1GB", "type": "Operating System", "text": "\nThese flags can be passed to `memfd_create()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.MFD_HUGE_1MB", "path": "library/os#os.MFD_HUGE_1MB", "type": "Operating System", "text": "\nThese flags can be passed to `memfd_create()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.MFD_HUGE_256MB", "path": "library/os#os.MFD_HUGE_256MB", "type": "Operating System", "text": "\nThese flags can be passed to `memfd_create()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.MFD_HUGE_2GB", "path": "library/os#os.MFD_HUGE_2GB", "type": "Operating System", "text": "\nThese flags can be passed to `memfd_create()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.MFD_HUGE_2MB", "path": "library/os#os.MFD_HUGE_2MB", "type": "Operating System", "text": "\nThese flags can be passed to `memfd_create()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.MFD_HUGE_32MB", "path": "library/os#os.MFD_HUGE_32MB", "type": "Operating System", "text": "\nThese flags can be passed to `memfd_create()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.MFD_HUGE_512KB", "path": "library/os#os.MFD_HUGE_512KB", "type": "Operating System", "text": "\nThese flags can be passed to `memfd_create()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.MFD_HUGE_512MB", "path": "library/os#os.MFD_HUGE_512MB", "type": "Operating System", "text": "\nThese flags can be passed to `memfd_create()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.MFD_HUGE_64KB", "path": "library/os#os.MFD_HUGE_64KB", "type": "Operating System", "text": "\nThese flags can be passed to `memfd_create()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.MFD_HUGE_8MB", "path": "library/os#os.MFD_HUGE_8MB", "type": "Operating System", "text": "\nThese flags can be passed to `memfd_create()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.MFD_HUGE_MASK", "path": "library/os#os.MFD_HUGE_MASK", "type": "Operating System", "text": "\nThese flags can be passed to `memfd_create()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.MFD_HUGE_SHIFT", "path": "library/os#os.MFD_HUGE_SHIFT", "type": "Operating System", "text": "\nThese flags can be passed to `memfd_create()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.minor()", "path": "library/os#os.minor", "type": "Operating System", "text": "\nExtract the device minor number from a raw device number (usually the `st_dev`\nor `st_rdev` field from `stat`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.mkdir()", "path": "library/os#os.mkdir", "type": "Operating System", "text": "\nCreate a directory named path with numeric mode mode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.mkfifo()", "path": "library/os#os.mkfifo", "type": "Operating System", "text": "\nCreate a FIFO (a named pipe) named path with numeric mode mode. The current\numask value is first masked out from the mode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.mknod()", "path": "library/os#os.mknod", "type": "Operating System", "text": "\nCreate a filesystem node (file, device special file or named pipe) named path.\nmode specifies both the permissions to use and the type of node to be created,\nbeing combined (bitwise OR) with one of `stat.S_IFREG`, `stat.S_IFCHR`,\n`stat.S_IFBLK`, and `stat.S_IFIFO` (those constants are available in `stat`).\nFor `stat.S_IFCHR` and `stat.S_IFBLK`, device defines the newly created device\nspecial file (probably using `os.makedev()`), otherwise it is ignored.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.name", "path": "library/os#os.name", "type": "Operating System", "text": "\nThe name of the operating system dependent module imported. The following\nnames have currently been registered: `'posix'`, `'nt'`, `'java'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.nice()", "path": "library/os#os.nice", "type": "Operating System", "text": "\nAdd increment to the process\u2019s \u201cniceness\u201d. Return the new niceness.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.open()", "path": "library/os#os.open", "type": "Operating System", "text": "\nOpen the file path and set various flags according to flags and possibly its\nmode according to mode. When computing mode, the current umask value is first\nmasked out. Return the file descriptor for the newly opened file. The new file\ndescriptor is non-inheritable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.openpty()", "path": "library/os#os.openpty", "type": "Operating System", "text": "\nOpen a new pseudo-terminal pair. Return a pair of file descriptors `(master,\nslave)` for the pty and the tty, respectively. The new file descriptors are\nnon-inheritable. For a (slightly) more portable approach, use the `pty`\nmodule.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.O_APPEND", "path": "library/os#os.O_APPEND", "type": "Operating System", "text": "\nThe above constants are available on Unix and Windows.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.O_ASYNC", "path": "library/os#os.O_ASYNC", "type": "Operating System", "text": "\nThe above constants are extensions and not present if they are not defined by\nthe C library.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.O_BINARY", "path": "library/os#os.O_BINARY", "type": "Operating System", "text": "\nThe above constants are only available on Windows.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.O_CLOEXEC", "path": "library/os#os.O_CLOEXEC", "type": "Operating System", "text": "\nThe above constants are only available on Unix.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.O_CREAT", "path": "library/os#os.O_CREAT", "type": "Operating System", "text": "\nThe above constants are available on Unix and Windows.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.O_DIRECT", "path": "library/os#os.O_DIRECT", "type": "Operating System", "text": "\nThe above constants are extensions and not present if they are not defined by\nthe C library.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.O_DIRECTORY", "path": "library/os#os.O_DIRECTORY", "type": "Operating System", "text": "\nThe above constants are extensions and not present if they are not defined by\nthe C library.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.O_DSYNC", "path": "library/os#os.O_DSYNC", "type": "Operating System", "text": "\nThe above constants are only available on Unix.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.O_EXCL", "path": "library/os#os.O_EXCL", "type": "Operating System", "text": "\nThe above constants are available on Unix and Windows.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.O_EXLOCK", "path": "library/os#os.O_EXLOCK", "type": "Operating System", "text": "\nThe above constants are extensions and not present if they are not defined by\nthe C library.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.O_NDELAY", "path": "library/os#os.O_NDELAY", "type": "Operating System", "text": "\nThe above constants are only available on Unix.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.O_NOATIME", "path": "library/os#os.O_NOATIME", "type": "Operating System", "text": "\nThe above constants are extensions and not present if they are not defined by\nthe C library.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.O_NOCTTY", "path": "library/os#os.O_NOCTTY", "type": "Operating System", "text": "\nThe above constants are only available on Unix.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.O_NOFOLLOW", "path": "library/os#os.O_NOFOLLOW", "type": "Operating System", "text": "\nThe above constants are extensions and not present if they are not defined by\nthe C library.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.O_NOINHERIT", "path": "library/os#os.O_NOINHERIT", "type": "Operating System", "text": "\nThe above constants are only available on Windows.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.O_NONBLOCK", "path": "library/os#os.O_NONBLOCK", "type": "Operating System", "text": "\nThe above constants are only available on Unix.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.O_PATH", "path": "library/os#os.O_PATH", "type": "Operating System", "text": "\nThe above constants are extensions and not present if they are not defined by\nthe C library.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.O_RANDOM", "path": "library/os#os.O_RANDOM", "type": "Operating System", "text": "\nThe above constants are only available on Windows.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.O_RDONLY", "path": "library/os#os.O_RDONLY", "type": "Operating System", "text": "\nThe above constants are available on Unix and Windows.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.O_RDWR", "path": "library/os#os.O_RDWR", "type": "Operating System", "text": "\nThe above constants are available on Unix and Windows.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.O_RSYNC", "path": "library/os#os.O_RSYNC", "type": "Operating System", "text": "\nThe above constants are only available on Unix.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.O_SEQUENTIAL", "path": "library/os#os.O_SEQUENTIAL", "type": "Operating System", "text": "\nThe above constants are only available on Windows.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.O_SHLOCK", "path": "library/os#os.O_SHLOCK", "type": "Operating System", "text": "\nThe above constants are extensions and not present if they are not defined by\nthe C library.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.O_SHORT_LIVED", "path": "library/os#os.O_SHORT_LIVED", "type": "Operating System", "text": "\nThe above constants are only available on Windows.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.O_SYNC", "path": "library/os#os.O_SYNC", "type": "Operating System", "text": "\nThe above constants are only available on Unix.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.O_TEMPORARY", "path": "library/os#os.O_TEMPORARY", "type": "Operating System", "text": "\nThe above constants are only available on Windows.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.O_TEXT", "path": "library/os#os.O_TEXT", "type": "Operating System", "text": "\nThe above constants are only available on Windows.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.O_TMPFILE", "path": "library/os#os.O_TMPFILE", "type": "Operating System", "text": "\nThe above constants are extensions and not present if they are not defined by\nthe C library.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.O_TRUNC", "path": "library/os#os.O_TRUNC", "type": "Operating System", "text": "\nThe above constants are available on Unix and Windows.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.O_WRONLY", "path": "library/os#os.O_WRONLY", "type": "Operating System", "text": "\nThe above constants are available on Unix and Windows.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.pardir", "path": "library/os#os.pardir", "type": "Operating System", "text": "\nThe constant string used by the operating system to refer to the parent\ndirectory. This is `'..'` for Windows and POSIX. Also available via `os.path`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.path", "path": "library/os.path", "type": "File & Directory Access", "text": "\nSource code: Lib/posixpath.py (for POSIX) and Lib/ntpath.py (for Windows NT).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.path.abspath()", "path": "library/os.path#os.path.abspath", "type": "File & Directory Access", "text": "\nReturn a normalized absolutized version of the pathname path. On most\nplatforms, this is equivalent to calling the function `normpath()` as follows:\n`normpath(join(os.getcwd(), path))`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.path.basename()", "path": "library/os.path#os.path.basename", "type": "File & Directory Access", "text": "\nReturn the base name of pathname path. This is the second element of the pair\nreturned by passing path to the function `split()`. Note that the result of\nthis function is different from the Unix basename program; where basename for\n`'/foo/bar/'` returns `'bar'`, the `basename()` function returns an empty\nstring (`''`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.path.commonpath()", "path": "library/os.path#os.path.commonpath", "type": "File & Directory Access", "text": "\nReturn the longest common sub-path of each pathname in the sequence paths.\nRaise `ValueError` if paths contain both absolute and relative pathnames, the\npaths are on the different drives or if paths is empty. Unlike\n`commonprefix()`, this returns a valid path.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.path.commonprefix()", "path": "library/os.path#os.path.commonprefix", "type": "File & Directory Access", "text": "\nReturn the longest path prefix (taken character-by-character) that is a prefix\nof all paths in list. If list is empty, return the empty string (`''`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.path.dirname()", "path": "library/os.path#os.path.dirname", "type": "File & Directory Access", "text": "\nReturn the directory name of pathname path. This is the first element of the\npair returned by passing path to the function `split()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.path.exists()", "path": "library/os.path#os.path.exists", "type": "File & Directory Access", "text": "\nReturn `True` if path refers to an existing path or an open file descriptor.\nReturns `False` for broken symbolic links. On some platforms, this function\nmay return `False` if permission is not granted to execute `os.stat()` on the\nrequested file, even if the path physically exists.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.path.expanduser()", "path": "library/os.path#os.path.expanduser", "type": "File & Directory Access", "text": "\nOn Unix and Windows, return the argument with an initial component of `~` or\n`~user` replaced by that user\u2019s home directory.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.path.expandvars()", "path": "library/os.path#os.path.expandvars", "type": "File & Directory Access", "text": "\nReturn the argument with environment variables expanded. Substrings of the\nform `$name` or `${name}` are replaced by the value of environment variable\nname. Malformed variable names and references to non-existing variables are\nleft unchanged.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.path.getatime()", "path": "library/os.path#os.path.getatime", "type": "File & Directory Access", "text": "\nReturn the time of last access of path. The return value is a floating point\nnumber giving the number of seconds since the epoch (see the `time` module).\nRaise `OSError` if the file does not exist or is inaccessible.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.path.getctime()", "path": "library/os.path#os.path.getctime", "type": "File & Directory Access", "text": "\nReturn the system\u2019s ctime which, on some systems (like Unix) is the time of\nthe last metadata change, and, on others (like Windows), is the creation time\nfor path. The return value is a number giving the number of seconds since the\nepoch (see the `time` module). Raise `OSError` if the file does not exist or\nis inaccessible.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.path.getmtime()", "path": "library/os.path#os.path.getmtime", "type": "File & Directory Access", "text": "\nReturn the time of last modification of path. The return value is a floating\npoint number giving the number of seconds since the epoch (see the `time`\nmodule). Raise `OSError` if the file does not exist or is inaccessible.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.path.getsize()", "path": "library/os.path#os.path.getsize", "type": "File & Directory Access", "text": "\nReturn the size, in bytes, of path. Raise `OSError` if the file does not exist\nor is inaccessible.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.path.isabs()", "path": "library/os.path#os.path.isabs", "type": "File & Directory Access", "text": "\nReturn `True` if path is an absolute pathname. On Unix, that means it begins\nwith a slash, on Windows that it begins with a (back)slash after chopping off\na potential drive letter.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.path.isdir()", "path": "library/os.path#os.path.isdir", "type": "File & Directory Access", "text": "\nReturn `True` if path is an `existing` directory. This follows symbolic links,\nso both `islink()` and `isdir()` can be true for the same path.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.path.isfile()", "path": "library/os.path#os.path.isfile", "type": "File & Directory Access", "text": "\nReturn `True` if path is an `existing` regular file. This follows symbolic\nlinks, so both `islink()` and `isfile()` can be true for the same path.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.path.islink()", "path": "library/os.path#os.path.islink", "type": "File & Directory Access", "text": "\nReturn `True` if path refers to an `existing` directory entry that is a\nsymbolic link. Always `False` if symbolic links are not supported by the\nPython runtime.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.path.ismount()", "path": "library/os.path#os.path.ismount", "type": "File & Directory Access", "text": "\nReturn `True` if pathname path is a mount point: a point in a file system\nwhere a different file system has been mounted. On POSIX, the function checks\nwhether path\u2019s parent, `path/..`, is on a different device than path, or\nwhether `path/..` and path point to the same i-node on the same device \u2014 this\nshould detect mount points for all Unix and POSIX variants. It is not able to\nreliably detect bind mounts on the same filesystem. On Windows, a drive letter\nroot and a share UNC are always mount points, and for any other path\n`GetVolumePathName` is called to see if it is different from the input path.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.path.join()", "path": "library/os.path#os.path.join", "type": "File & Directory Access", "text": "\nJoin one or more path components intelligently. The return value is the\nconcatenation of path and any members of *paths with exactly one directory\nseparator following each non-empty part except the last, meaning that the\nresult will only end in a separator if the last part is empty. If a component\nis an absolute path, all previous components are thrown away and joining\ncontinues from the absolute path component.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.path.lexists()", "path": "library/os.path#os.path.lexists", "type": "File & Directory Access", "text": "\nReturn `True` if path refers to an existing path. Returns `True` for broken\nsymbolic links. Equivalent to `exists()` on platforms lacking `os.lstat()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.path.normcase()", "path": "library/os.path#os.path.normcase", "type": "File & Directory Access", "text": "\nNormalize the case of a pathname. On Windows, convert all characters in the\npathname to lowercase, and also convert forward slashes to backward slashes.\nOn other operating systems, return the path unchanged.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.path.normpath()", "path": "library/os.path#os.path.normpath", "type": "File & Directory Access", "text": "\nNormalize a pathname by collapsing redundant separators and up-level\nreferences so that `A//B`, `A/B/`, `A/./B` and `A/foo/../B` all become `A/B`.\nThis string manipulation may change the meaning of a path that contains\nsymbolic links. On Windows, it converts forward slashes to backward slashes.\nTo normalize case, use `normcase()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.path.realpath()", "path": "library/os.path#os.path.realpath", "type": "File & Directory Access", "text": "\nReturn the canonical path of the specified filename, eliminating any symbolic\nlinks encountered in the path (if they are supported by the operating system).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.path.relpath()", "path": "library/os.path#os.path.relpath", "type": "File & Directory Access", "text": "\nReturn a relative filepath to path either from the current directory or from\nan optional start directory. This is a path computation: the filesystem is not\naccessed to confirm the existence or nature of path or start. On Windows,\n`ValueError` is raised when path and start are on different drives.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.path.samefile()", "path": "library/os.path#os.path.samefile", "type": "File & Directory Access", "text": "\nReturn `True` if both pathname arguments refer to the same file or directory.\nThis is determined by the device number and i-node number and raises an\nexception if an `os.stat()` call on either pathname fails.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.path.sameopenfile()", "path": "library/os.path#os.path.sameopenfile", "type": "File & Directory Access", "text": "\nReturn `True` if the file descriptors fp1 and fp2 refer to the same file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.path.samestat()", "path": "library/os.path#os.path.samestat", "type": "File & Directory Access", "text": "\nReturn `True` if the stat tuples stat1 and stat2 refer to the same file. These\nstructures may have been returned by `os.fstat()`, `os.lstat()`, or\n`os.stat()`. This function implements the underlying comparison used by\n`samefile()` and `sameopenfile()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.path.split()", "path": "library/os.path#os.path.split", "type": "File & Directory Access", "text": "\nSplit the pathname path into a pair, `(head, tail)` where tail is the last\npathname component and head is everything leading up to that. The tail part\nwill never contain a slash; if path ends in a slash, tail will be empty. If\nthere is no slash in path, head will be empty. If path is empty, both head and\ntail are empty. Trailing slashes are stripped from head unless it is the root\n(one or more slashes only). In all cases, `join(head, tail)` returns a path to\nthe same location as path (but the strings may differ). Also see the functions\n`dirname()` and `basename()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.path.splitdrive()", "path": "library/os.path#os.path.splitdrive", "type": "File & Directory Access", "text": "\nSplit the pathname path into a pair `(drive, tail)` where drive is either a\nmount point or the empty string. On systems which do not use drive\nspecifications, drive will always be the empty string. In all cases, `drive +\ntail` will be the same as path.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.path.splitext()", "path": "library/os.path#os.path.splitext", "type": "File & Directory Access", "text": "\nSplit the pathname path into a pair `(root, ext)` such that `root + ext ==\npath`, and ext is empty or begins with a period and contains at most one\nperiod. Leading periods on the basename are ignored; `splitext('.cshrc')`\nreturns `('.cshrc', '')`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.path.supports_unicode_filenames", "path": "library/os.path#os.path.supports_unicode_filenames", "type": "File & Directory Access", "text": "\n`True` if arbitrary Unicode strings can be used as file names (within\nlimitations imposed by the file system).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.pathconf()", "path": "library/os#os.pathconf", "type": "Operating System", "text": "\nReturn system configuration information relevant to a named file. name\nspecifies the configuration value to retrieve; it may be a string which is the\nname of a defined system value; these names are specified in a number of\nstandards (POSIX.1, Unix 95, Unix 98, and others). Some platforms define\nadditional names as well. The names known to the host operating system are\ngiven in the `pathconf_names` dictionary. For configuration variables not\nincluded in that mapping, passing an integer for name is also accepted.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.pathconf_names", "path": "library/os#os.pathconf_names", "type": "Operating System", "text": "\nDictionary mapping names accepted by `pathconf()` and `fpathconf()` to the\ninteger values defined for those names by the host operating system. This can\nbe used to determine the set of names known to the system.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.PathLike", "path": "library/os#os.PathLike", "type": "Operating System", "text": "\nAn abstract base class for objects representing a file system path, e.g.\n`pathlib.PurePath`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.PathLike.__fspath__()", "path": "library/os#os.PathLike.__fspath__", "type": "Operating System", "text": "\nReturn the file system path representation of the object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.pathsep", "path": "library/os#os.pathsep", "type": "Operating System", "text": "\nThe character conventionally used by the operating system to separate search\npath components (as in `PATH`), such as `':'` for POSIX or `';'` for Windows.\nAlso available via `os.path`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.pidfd_open()", "path": "library/os#os.pidfd_open", "type": "Operating System", "text": "\nReturn a file descriptor referring to the process pid. This descriptor can be\nused to perform process management without races and signals. The flags\nargument is provided for future extensions; no flag values are currently\ndefined.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.pipe()", "path": "library/os#os.pipe", "type": "Operating System", "text": "\nCreate a pipe. Return a pair of file descriptors `(r, w)` usable for reading\nand writing, respectively. The new file descriptor is non-inheritable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.pipe2()", "path": "library/os#os.pipe2", "type": "Operating System", "text": "\nCreate a pipe with flags set atomically. flags can be constructed by ORing\ntogether one or more of these values: `O_NONBLOCK`, `O_CLOEXEC`. Return a pair\nof file descriptors `(r, w)` usable for reading and writing, respectively.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.plock()", "path": "library/os#os.plock", "type": "Operating System", "text": "\nLock program segments into memory. The value of op (defined in `<sys/lock.h>`)\ndetermines which segments are locked.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.popen()", "path": "library/os#os.popen", "type": "Operating System", "text": "\nOpen a pipe to or from command cmd. The return value is an open file object\nconnected to the pipe, which can be read or written depending on whether mode\nis `'r'` (default) or `'w'`. The buffering argument has the same meaning as\nthe corresponding argument to the built-in `open()` function. The returned\nfile object reads or writes text strings rather than bytes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.posix_fadvise()", "path": "library/os#os.posix_fadvise", "type": "Operating System", "text": "\nAnnounces an intention to access data in a specific pattern thus allowing the\nkernel to make optimizations. The advice applies to the region of the file\nspecified by fd starting at offset and continuing for len bytes. advice is one\nof `POSIX_FADV_NORMAL`, `POSIX_FADV_SEQUENTIAL`, `POSIX_FADV_RANDOM`,\n`POSIX_FADV_NOREUSE`, `POSIX_FADV_WILLNEED` or `POSIX_FADV_DONTNEED`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.POSIX_FADV_DONTNEED", "path": "library/os#os.POSIX_FADV_DONTNEED", "type": "Operating System", "text": "\nFlags that can be used in advice in `posix_fadvise()` that specify the access\npattern that is likely to be used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.POSIX_FADV_NOREUSE", "path": "library/os#os.POSIX_FADV_NOREUSE", "type": "Operating System", "text": "\nFlags that can be used in advice in `posix_fadvise()` that specify the access\npattern that is likely to be used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.POSIX_FADV_NORMAL", "path": "library/os#os.POSIX_FADV_NORMAL", "type": "Operating System", "text": "\nFlags that can be used in advice in `posix_fadvise()` that specify the access\npattern that is likely to be used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.POSIX_FADV_RANDOM", "path": "library/os#os.POSIX_FADV_RANDOM", "type": "Operating System", "text": "\nFlags that can be used in advice in `posix_fadvise()` that specify the access\npattern that is likely to be used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.POSIX_FADV_SEQUENTIAL", "path": "library/os#os.POSIX_FADV_SEQUENTIAL", "type": "Operating System", "text": "\nFlags that can be used in advice in `posix_fadvise()` that specify the access\npattern that is likely to be used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.POSIX_FADV_WILLNEED", "path": "library/os#os.POSIX_FADV_WILLNEED", "type": "Operating System", "text": "\nFlags that can be used in advice in `posix_fadvise()` that specify the access\npattern that is likely to be used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.posix_fallocate()", "path": "library/os#os.posix_fallocate", "type": "Operating System", "text": "\nEnsures that enough disk space is allocated for the file specified by fd\nstarting from offset and continuing for len bytes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.posix_spawn()", "path": "library/os#os.posix_spawn", "type": "Operating System", "text": "\nWraps the `posix_spawn()` C library API for use from Python.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.posix_spawnp()", "path": "library/os#os.posix_spawnp", "type": "Operating System", "text": "\nWraps the `posix_spawnp()` C library API for use from Python.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.POSIX_SPAWN_CLOSE", "path": "library/os#os.POSIX_SPAWN_CLOSE", "type": "Operating System", "text": "\n(`os.POSIX_SPAWN_CLOSE`, fd)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.POSIX_SPAWN_DUP2", "path": "library/os#os.POSIX_SPAWN_DUP2", "type": "Operating System", "text": "\n(`os.POSIX_SPAWN_DUP2`, fd, new_fd)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.POSIX_SPAWN_OPEN", "path": "library/os#os.POSIX_SPAWN_OPEN", "type": "Operating System", "text": "\n(`os.POSIX_SPAWN_OPEN`, fd, path, flags, mode)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.pread()", "path": "library/os#os.pread", "type": "Operating System", "text": "\nRead at most n bytes from file descriptor fd at a position of offset, leaving\nthe file offset unchanged.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.preadv()", "path": "library/os#os.preadv", "type": "Operating System", "text": "\nRead from a file descriptor fd at a position of offset into mutable bytes-like\nobjects buffers, leaving the file offset unchanged. Transfer data into each\nbuffer until it is full and then move on to the next buffer in the sequence to\nhold the rest of the data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.PRIO_PGRP", "path": "library/os#os.PRIO_PGRP", "type": "Operating System", "text": "\nParameters for the `getpriority()` and `setpriority()` functions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.PRIO_PROCESS", "path": "library/os#os.PRIO_PROCESS", "type": "Operating System", "text": "\nParameters for the `getpriority()` and `setpriority()` functions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.PRIO_USER", "path": "library/os#os.PRIO_USER", "type": "Operating System", "text": "\nParameters for the `getpriority()` and `setpriority()` functions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.putenv()", "path": "library/os#os.putenv", "type": "Operating System", "text": "\nSet the environment variable named key to the string value. Such changes to\nthe environment affect subprocesses started with `os.system()`, `popen()` or\n`fork()` and `execv()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.pwrite()", "path": "library/os#os.pwrite", "type": "Operating System", "text": "\nWrite the bytestring in str to file descriptor fd at position of offset,\nleaving the file offset unchanged.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.pwritev()", "path": "library/os#os.pwritev", "type": "Operating System", "text": "\nWrite the buffers contents to file descriptor fd at a offset offset, leaving\nthe file offset unchanged. buffers must be a sequence of bytes-like objects.\nBuffers are processed in array order. Entire contents of the first buffer is\nwritten before proceeding to the second, and so on.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.P_ALL", "path": "library/os#os.P_ALL", "type": "Operating System", "text": "\nThese are the possible values for idtype in `waitid()`. They affect how id is\ninterpreted.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.P_DETACH", "path": "library/os#os.P_DETACH", "type": "Operating System", "text": "\nPossible values for the mode parameter to the `spawn*` family of functions.\nThese are less portable than those listed above. `P_DETACH` is similar to\n`P_NOWAIT`, but the new process is detached from the console of the calling\nprocess. If `P_OVERLAY` is used, the current process will be replaced; the\n`spawn*` function will not return.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.P_NOWAIT", "path": "library/os#os.P_NOWAIT", "type": "Operating System", "text": "\nPossible values for the mode parameter to the `spawn*` family of functions. If\neither of these values is given, the `spawn*()` functions will return as soon\nas the new process has been created, with the process id as the return value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.P_NOWAITO", "path": "library/os#os.P_NOWAITO", "type": "Operating System", "text": "\nPossible values for the mode parameter to the `spawn*` family of functions. If\neither of these values is given, the `spawn*()` functions will return as soon\nas the new process has been created, with the process id as the return value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.P_OVERLAY", "path": "library/os#os.P_OVERLAY", "type": "Operating System", "text": "\nPossible values for the mode parameter to the `spawn*` family of functions.\nThese are less portable than those listed above. `P_DETACH` is similar to\n`P_NOWAIT`, but the new process is detached from the console of the calling\nprocess. If `P_OVERLAY` is used, the current process will be replaced; the\n`spawn*` function will not return.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.P_PGID", "path": "library/os#os.P_PGID", "type": "Operating System", "text": "\nThese are the possible values for idtype in `waitid()`. They affect how id is\ninterpreted.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.P_PID", "path": "library/os#os.P_PID", "type": "Operating System", "text": "\nThese are the possible values for idtype in `waitid()`. They affect how id is\ninterpreted.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.P_PIDFD", "path": "library/os#os.P_PIDFD", "type": "Operating System", "text": "\nThis is a Linux-specific idtype that indicates that id is a file descriptor\nthat refers to a process.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.P_WAIT", "path": "library/os#os.P_WAIT", "type": "Operating System", "text": "\nPossible value for the mode parameter to the `spawn*` family of functions. If\nthis is given as mode, the `spawn*()` functions will not return until the new\nprocess has run to completion and will return the exit code of the process the\nrun is successful, or `-signal` if a signal kills the process.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.read()", "path": "library/os#os.read", "type": "Operating System", "text": "\nRead at most n bytes from file descriptor fd.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.readlink()", "path": "library/os#os.readlink", "type": "Operating System", "text": "\nReturn a string representing the path to which the symbolic link points. The\nresult may be either an absolute or relative pathname; if it is relative, it\nmay be converted to an absolute pathname using\n`os.path.join(os.path.dirname(path), result)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.readv()", "path": "library/os#os.readv", "type": "Operating System", "text": "\nRead from a file descriptor fd into a number of mutable bytes-like objects\nbuffers. Transfer data into each buffer until it is full and then move on to\nthe next buffer in the sequence to hold the rest of the data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.register_at_fork()", "path": "library/os#os.register_at_fork", "type": "Operating System", "text": "\nRegister callables to be executed when a new child process is forked using\n`os.fork()` or similar process cloning APIs. The parameters are optional and\nkeyword-only. Each specifies a different call point.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.remove()", "path": "library/os#os.remove", "type": "Operating System", "text": "\nRemove (delete) the file path. If path is a directory, an `IsADirectoryError`\nis raised. Use `rmdir()` to remove directories. If the file does not exist, a\n`FileNotFoundError` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.removedirs()", "path": "library/os#os.removedirs", "type": "Operating System", "text": "\nRemove directories recursively. Works like `rmdir()` except that, if the leaf\ndirectory is successfully removed, `removedirs()` tries to successively remove\nevery parent directory mentioned in path until an error is raised (which is\nignored, because it generally means that a parent directory is not empty). For\nexample, `os.removedirs('foo/bar/baz')` will first remove the directory\n`'foo/bar/baz'`, and then remove `'foo/bar'` and `'foo'` if they are empty.\nRaises `OSError` if the leaf directory could not be successfully removed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.removexattr()", "path": "library/os#os.removexattr", "type": "Operating System", "text": "\nRemoves the extended filesystem attribute attribute from path. attribute\nshould be bytes or str (directly or indirectly through the `PathLike`\ninterface). If it is a string, it is encoded with the filesystem encoding.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.rename()", "path": "library/os#os.rename", "type": "Operating System", "text": "\nRename the file or directory src to dst. If dst exists, the operation will\nfail with an `OSError` subclass in a number of cases:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.renames()", "path": "library/os#os.renames", "type": "Operating System", "text": "\nRecursive directory or file renaming function. Works like `rename()`, except\ncreation of any intermediate directories needed to make the new pathname good\nis attempted first. After the rename, directories corresponding to rightmost\npath segments of the old name will be pruned away using `removedirs()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.replace()", "path": "library/os#os.replace", "type": "Operating System", "text": "\nRename the file or directory src to dst. If dst is a directory, `OSError` will\nbe raised. If dst exists and is a file, it will be replaced silently if the\nuser has permission. The operation may fail if src and dst are on different\nfilesystems. If successful, the renaming will be an atomic operation (this is\na POSIX requirement).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.rmdir()", "path": "library/os#os.rmdir", "type": "Operating System", "text": "\nRemove (delete) the directory path. If the directory does not exist or is not\nempty, an `FileNotFoundError` or an `OSError` is raised respectively. In order\nto remove whole directory trees, `shutil.rmtree()` can be used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.RTLD_DEEPBIND", "path": "library/os#os.RTLD_DEEPBIND", "type": "Operating System", "text": "\nFlags for use with the `setdlopenflags()` and `getdlopenflags()` functions.\nSee the Unix manual page dlopen(3) for what the different flags mean.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.RTLD_GLOBAL", "path": "library/os#os.RTLD_GLOBAL", "type": "Operating System", "text": "\nFlags for use with the `setdlopenflags()` and `getdlopenflags()` functions.\nSee the Unix manual page dlopen(3) for what the different flags mean.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.RTLD_LAZY", "path": "library/os#os.RTLD_LAZY", "type": "Operating System", "text": "\nFlags for use with the `setdlopenflags()` and `getdlopenflags()` functions.\nSee the Unix manual page dlopen(3) for what the different flags mean.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.RTLD_LOCAL", "path": "library/os#os.RTLD_LOCAL", "type": "Operating System", "text": "\nFlags for use with the `setdlopenflags()` and `getdlopenflags()` functions.\nSee the Unix manual page dlopen(3) for what the different flags mean.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.RTLD_NODELETE", "path": "library/os#os.RTLD_NODELETE", "type": "Operating System", "text": "\nFlags for use with the `setdlopenflags()` and `getdlopenflags()` functions.\nSee the Unix manual page dlopen(3) for what the different flags mean.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.RTLD_NOLOAD", "path": "library/os#os.RTLD_NOLOAD", "type": "Operating System", "text": "\nFlags for use with the `setdlopenflags()` and `getdlopenflags()` functions.\nSee the Unix manual page dlopen(3) for what the different flags mean.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.RTLD_NOW", "path": "library/os#os.RTLD_NOW", "type": "Operating System", "text": "\nFlags for use with the `setdlopenflags()` and `getdlopenflags()` functions.\nSee the Unix manual page dlopen(3) for what the different flags mean.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.RWF_DSYNC", "path": "library/os#os.RWF_DSYNC", "type": "Operating System", "text": "\nProvide a per-write equivalent of the `O_DSYNC` `open(2)` flag. This flag\neffect applies only to the data range written by the system call.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.RWF_HIPRI", "path": "library/os#os.RWF_HIPRI", "type": "Operating System", "text": "\nHigh priority read/write. Allows block-based filesystems to use polling of the\ndevice, which provides lower latency, but may use additional resources.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.RWF_NOWAIT", "path": "library/os#os.RWF_NOWAIT", "type": "Operating System", "text": "\nDo not wait for data which is not immediately available. If this flag is\nspecified, the system call will return instantly if it would have to read data\nfrom the backing storage or wait for a lock.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.RWF_SYNC", "path": "library/os#os.RWF_SYNC", "type": "Operating System", "text": "\nProvide a per-write equivalent of the `O_SYNC` `open(2)` flag. This flag\neffect applies only to the data range written by the system call.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.R_OK", "path": "library/os#os.R_OK", "type": "Operating System", "text": "\nValues to pass as the mode parameter of `access()` to test the existence,\nreadability, writability and executability of path, respectively.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.scandir()", "path": "library/os#os.scandir", "type": "Operating System", "text": "\nReturn an iterator of `os.DirEntry` objects corresponding to the entries in\nthe directory given by path. The entries are yielded in arbitrary order, and\nthe special entries `'.'` and `'..'` are not included. If a file is removed\nfrom or added to the directory after creating the iterator, whether an entry\nfor that file be included is unspecified.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.scandir.close()", "path": "library/os#os.scandir.close", "type": "Operating System", "text": "\nClose the iterator and free acquired resources.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.SCHED_BATCH", "path": "library/os#os.SCHED_BATCH", "type": "Operating System", "text": "\nScheduling policy for CPU-intensive processes that tries to preserve\ninteractivity on the rest of the computer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.SCHED_FIFO", "path": "library/os#os.SCHED_FIFO", "type": "Operating System", "text": "\nA First In First Out scheduling policy.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.sched_getaffinity()", "path": "library/os#os.sched_getaffinity", "type": "Operating System", "text": "\nReturn the set of CPUs the process with PID pid (or the current process if\nzero) is restricted to.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.sched_getparam()", "path": "library/os#os.sched_getparam", "type": "Operating System", "text": "\nReturn the scheduling parameters as a `sched_param` instance for the process\nwith PID pid. A pid of 0 means the calling process.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.sched_getscheduler()", "path": "library/os#os.sched_getscheduler", "type": "Operating System", "text": "\nReturn the scheduling policy for the process with PID pid. A pid of 0 means\nthe calling process. The result is one of the scheduling policy constants\nabove.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.sched_get_priority_max()", "path": "library/os#os.sched_get_priority_max", "type": "Operating System", "text": "\nGet the maximum priority value for policy. policy is one of the scheduling\npolicy constants above.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.sched_get_priority_min()", "path": "library/os#os.sched_get_priority_min", "type": "Operating System", "text": "\nGet the minimum priority value for policy. policy is one of the scheduling\npolicy constants above.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.SCHED_IDLE", "path": "library/os#os.SCHED_IDLE", "type": "Operating System", "text": "\nScheduling policy for extremely low priority background tasks.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.SCHED_OTHER", "path": "library/os#os.SCHED_OTHER", "type": "Operating System", "text": "\nThe default scheduling policy.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.sched_param", "path": "library/os#os.sched_param", "type": "Operating System", "text": "\nThis class represents tunable scheduling parameters used in\n`sched_setparam()`, `sched_setscheduler()`, and `sched_getparam()`. It is\nimmutable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.sched_param.sched_priority", "path": "library/os#os.sched_param.sched_priority", "type": "Operating System", "text": "\nThe scheduling priority for a scheduling policy.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.SCHED_RESET_ON_FORK", "path": "library/os#os.SCHED_RESET_ON_FORK", "type": "Operating System", "text": "\nThis flag can be OR\u2019ed with any other scheduling policy. When a process with\nthis flag set forks, its child\u2019s scheduling policy and priority are reset to\nthe default.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.SCHED_RR", "path": "library/os#os.SCHED_RR", "type": "Operating System", "text": "\nA round-robin scheduling policy.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.sched_rr_get_interval()", "path": "library/os#os.sched_rr_get_interval", "type": "Operating System", "text": "\nReturn the round-robin quantum in seconds for the process with PID pid. A pid\nof 0 means the calling process.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.sched_setaffinity()", "path": "library/os#os.sched_setaffinity", "type": "Operating System", "text": "\nRestrict the process with PID pid (or the current process if zero) to a set of\nCPUs. mask is an iterable of integers representing the set of CPUs to which\nthe process should be restricted.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.sched_setparam()", "path": "library/os#os.sched_setparam", "type": "Operating System", "text": "\nSet a scheduling parameters for the process with PID pid. A pid of 0 means the\ncalling process. param is a `sched_param` instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.sched_setscheduler()", "path": "library/os#os.sched_setscheduler", "type": "Operating System", "text": "\nSet the scheduling policy for the process with PID pid. A pid of 0 means the\ncalling process. policy is one of the scheduling policy constants above. param\nis a `sched_param` instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.SCHED_SPORADIC", "path": "library/os#os.SCHED_SPORADIC", "type": "Operating System", "text": "\nScheduling policy for sporadic server programs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.sched_yield()", "path": "library/os#os.sched_yield", "type": "Operating System", "text": "\nVoluntarily relinquish the CPU.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.SEEK_CUR", "path": "library/os#os.SEEK_CUR", "type": "Operating System", "text": "\nParameters to the `lseek()` function. Their values are 0, 1, and 2,\nrespectively.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.SEEK_END", "path": "library/os#os.SEEK_END", "type": "Operating System", "text": "\nParameters to the `lseek()` function. Their values are 0, 1, and 2,\nrespectively.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.SEEK_SET", "path": "library/os#os.SEEK_SET", "type": "Operating System", "text": "\nParameters to the `lseek()` function. Their values are 0, 1, and 2,\nrespectively.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.sendfile()", "path": "library/os#os.sendfile", "type": "Operating System", "text": "\nCopy count bytes from file descriptor in_fd to file descriptor out_fd starting\nat offset. Return the number of bytes sent. When EOF is reached return `0`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.sep", "path": "library/os#os.sep", "type": "Operating System", "text": "\nThe character used by the operating system to separate pathname components.\nThis is `'/'` for POSIX and `'\\\\'` for Windows. Note that knowing this is not\nsufficient to be able to parse or concatenate pathnames \u2014 use\n`os.path.split()` and `os.path.join()` \u2014 but it is occasionally useful. Also\navailable via `os.path`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.setegid()", "path": "library/os#os.setegid", "type": "Operating System", "text": "\nSet the current process\u2019s effective group id.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.seteuid()", "path": "library/os#os.seteuid", "type": "Operating System", "text": "\nSet the current process\u2019s effective user id.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.setgid()", "path": "library/os#os.setgid", "type": "Operating System", "text": "\nSet the current process\u2019 group id.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.setgroups()", "path": "library/os#os.setgroups", "type": "Operating System", "text": "\nSet the list of supplemental group ids associated with the current process to\ngroups. groups must be a sequence, and each element must be an integer\nidentifying a group. This operation is typically available only to the\nsuperuser.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.setpgid()", "path": "library/os#os.setpgid", "type": "Operating System", "text": "\nCall the system call `setpgid()` to set the process group id of the process\nwith id pid to the process group with id pgrp. See the Unix manual for the\nsemantics.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.setpgrp()", "path": "library/os#os.setpgrp", "type": "Operating System", "text": "\nCall the system call `setpgrp()` or `setpgrp(0, 0)` depending on which version\nis implemented (if any). See the Unix manual for the semantics.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.setpriority()", "path": "library/os#os.setpriority", "type": "Operating System", "text": "\nSet program scheduling priority. The value which is one of `PRIO_PROCESS`,\n`PRIO_PGRP`, or `PRIO_USER`, and who is interpreted relative to which (a\nprocess identifier for `PRIO_PROCESS`, process group identifier for\n`PRIO_PGRP`, and a user ID for `PRIO_USER`). A zero value for who denotes\n(respectively) the calling process, the process group of the calling process,\nor the real user ID of the calling process. priority is a value in the range\n-20 to 19. The default priority is 0; lower priorities cause more favorable\nscheduling.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.setregid()", "path": "library/os#os.setregid", "type": "Operating System", "text": "\nSet the current process\u2019s real and effective group ids.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.setresgid()", "path": "library/os#os.setresgid", "type": "Operating System", "text": "\nSet the current process\u2019s real, effective, and saved group ids.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.setresuid()", "path": "library/os#os.setresuid", "type": "Operating System", "text": "\nSet the current process\u2019s real, effective, and saved user ids.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.setreuid()", "path": "library/os#os.setreuid", "type": "Operating System", "text": "\nSet the current process\u2019s real and effective user ids.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.setsid()", "path": "library/os#os.setsid", "type": "Operating System", "text": "\nCall the system call `setsid()`. See the Unix manual for the semantics.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.setuid()", "path": "library/os#os.setuid", "type": "Operating System", "text": "\nSet the current process\u2019s user id.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.setxattr()", "path": "library/os#os.setxattr", "type": "Operating System", "text": "\nSet the extended filesystem attribute attribute on path to value. attribute\nmust be a bytes or str with no embedded NULs (directly or indirectly through\nthe `PathLike` interface). If it is a str, it is encoded with the filesystem\nencoding. flags may be `XATTR_REPLACE` or `XATTR_CREATE`. If `XATTR_REPLACE`\nis given and the attribute does not exist, `EEXISTS` will be raised. If\n`XATTR_CREATE` is given and the attribute already exists, the attribute will\nnot be created and `ENODATA` will be raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.set_blocking()", "path": "library/os#os.set_blocking", "type": "Operating System", "text": "\nSet the blocking mode of the specified file descriptor. Set the `O_NONBLOCK`\nflag if blocking is `False`, clear the flag otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.set_handle_inheritable()", "path": "library/os#os.set_handle_inheritable", "type": "Operating System", "text": "\nSet the \u201cinheritable\u201d flag of the specified handle.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.set_inheritable()", "path": "library/os#os.set_inheritable", "type": "Operating System", "text": "\nSet the \u201cinheritable\u201d flag of the specified file descriptor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.SF_MNOWAIT", "path": "library/os#os.SF_MNOWAIT", "type": "Operating System", "text": "\nParameters to the `sendfile()` function, if the implementation supports them.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.SF_NODISKIO", "path": "library/os#os.SF_NODISKIO", "type": "Operating System", "text": "\nParameters to the `sendfile()` function, if the implementation supports them.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.SF_SYNC", "path": "library/os#os.SF_SYNC", "type": "Operating System", "text": "\nParameters to the `sendfile()` function, if the implementation supports them.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.spawnl()", "path": "library/os#os.spawnl", "type": "Operating System", "text": "\nExecute the program path in a new process.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.spawnle()", "path": "library/os#os.spawnle", "type": "Operating System", "text": "\nExecute the program path in a new process.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.spawnlp()", "path": "library/os#os.spawnlp", "type": "Operating System", "text": "\nExecute the program path in a new process.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.spawnlpe()", "path": "library/os#os.spawnlpe", "type": "Operating System", "text": "\nExecute the program path in a new process.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.spawnv()", "path": "library/os#os.spawnv", "type": "Operating System", "text": "\nExecute the program path in a new process.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.spawnve()", "path": "library/os#os.spawnve", "type": "Operating System", "text": "\nExecute the program path in a new process.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.spawnvp()", "path": "library/os#os.spawnvp", "type": "Operating System", "text": "\nExecute the program path in a new process.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.spawnvpe()", "path": "library/os#os.spawnvpe", "type": "Operating System", "text": "\nExecute the program path in a new process.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.startfile()", "path": "library/os#os.startfile", "type": "Operating System", "text": "\nStart a file with its associated application.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.stat()", "path": "library/os#os.stat", "type": "Operating System", "text": "\nGet the status of a file or a file descriptor. Perform the equivalent of a\n`stat()` system call on the given path. path may be specified as either a\nstring or bytes \u2013 directly or indirectly through the `PathLike` interface \u2013 or\nas an open file descriptor. Return a `stat_result` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.statvfs()", "path": "library/os#os.statvfs", "type": "Operating System", "text": "\nPerform a `statvfs()` system call on the given path. The return value is an\nobject whose attributes describe the filesystem on the given path, and\ncorrespond to the members of the `statvfs` structure, namely: `f_bsize`,\n`f_frsize`, `f_blocks`, `f_bfree`, `f_bavail`, `f_files`, `f_ffree`,\n`f_favail`, `f_flag`, `f_namemax`, `f_fsid`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.stat_result", "path": "library/os#os.stat_result", "type": "Operating System", "text": "\nObject whose attributes correspond roughly to the members of the `stat`\nstructure. It is used for the result of `os.stat()`, `os.fstat()` and\n`os.lstat()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.stat_result.st_atime", "path": "library/os#os.stat_result.st_atime", "type": "Operating System", "text": "\nTime of most recent access expressed in seconds.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.stat_result.st_atime_ns", "path": "library/os#os.stat_result.st_atime_ns", "type": "Operating System", "text": "\nTime of most recent access expressed in nanoseconds as an integer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.stat_result.st_birthtime", "path": "library/os#os.stat_result.st_birthtime", "type": "Operating System", "text": "\nTime of file creation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.stat_result.st_blksize", "path": "library/os#os.stat_result.st_blksize", "type": "Operating System", "text": "\n\u201cPreferred\u201d blocksize for efficient file system I/O. Writing to a file in\nsmaller chunks may cause an inefficient read-modify-rewrite.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.stat_result.st_blocks", "path": "library/os#os.stat_result.st_blocks", "type": "Operating System", "text": "\nNumber of 512-byte blocks allocated for file. This may be smaller than\n`st_size`/512 when the file has holes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.stat_result.st_creator", "path": "library/os#os.stat_result.st_creator", "type": "Operating System", "text": "\nCreator of the file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.stat_result.st_ctime", "path": "library/os#os.stat_result.st_ctime", "type": "Operating System", "text": "\nPlatform dependent:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.stat_result.st_ctime_ns", "path": "library/os#os.stat_result.st_ctime_ns", "type": "Operating System", "text": "\nPlatform dependent:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.stat_result.st_dev", "path": "library/os#os.stat_result.st_dev", "type": "Operating System", "text": "\nIdentifier of the device on which this file resides.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.stat_result.st_file_attributes", "path": "library/os#os.stat_result.st_file_attributes", "type": "Operating System", "text": "\nWindows file attributes: `dwFileAttributes` member of the\n`BY_HANDLE_FILE_INFORMATION` structure returned by\n`GetFileInformationByHandle()`. See the `FILE_ATTRIBUTE_*` constants in the\n`stat` module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.stat_result.st_flags", "path": "library/os#os.stat_result.st_flags", "type": "Operating System", "text": "\nUser defined flags for file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.stat_result.st_fstype", "path": "library/os#os.stat_result.st_fstype", "type": "Operating System", "text": "\nString that uniquely identifies the type of the filesystem that contains the\nfile.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.stat_result.st_gen", "path": "library/os#os.stat_result.st_gen", "type": "Operating System", "text": "\nFile generation number.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.stat_result.st_gid", "path": "library/os#os.stat_result.st_gid", "type": "Operating System", "text": "\nGroup identifier of the file owner.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.stat_result.st_ino", "path": "library/os#os.stat_result.st_ino", "type": "Operating System", "text": "\nPlatform dependent, but if non-zero, uniquely identifies the file for a given\nvalue of `st_dev`. Typically:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.stat_result.st_mode", "path": "library/os#os.stat_result.st_mode", "type": "Operating System", "text": "\nFile mode: file type and file mode bits (permissions).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.stat_result.st_mtime", "path": "library/os#os.stat_result.st_mtime", "type": "Operating System", "text": "\nTime of most recent content modification expressed in seconds.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.stat_result.st_mtime_ns", "path": "library/os#os.stat_result.st_mtime_ns", "type": "Operating System", "text": "\nTime of most recent content modification expressed in nanoseconds as an\ninteger.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.stat_result.st_nlink", "path": "library/os#os.stat_result.st_nlink", "type": "Operating System", "text": "\nNumber of hard links.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.stat_result.st_rdev", "path": "library/os#os.stat_result.st_rdev", "type": "Operating System", "text": "\nType of device if an inode device.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.stat_result.st_reparse_tag", "path": "library/os#os.stat_result.st_reparse_tag", "type": "Operating System", "text": "\nWhen `st_file_attributes` has the `FILE_ATTRIBUTE_REPARSE_POINT` set, this\nfield contains the tag identifying the type of reparse point. See the\n`IO_REPARSE_TAG_*` constants in the `stat` module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.stat_result.st_rsize", "path": "library/os#os.stat_result.st_rsize", "type": "Operating System", "text": "\nReal size of the file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.stat_result.st_size", "path": "library/os#os.stat_result.st_size", "type": "Operating System", "text": "\nSize of the file in bytes, if it is a regular file or a symbolic link. The\nsize of a symbolic link is the length of the pathname it contains, without a\nterminating null byte.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.stat_result.st_type", "path": "library/os#os.stat_result.st_type", "type": "Operating System", "text": "\nFile type.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.stat_result.st_uid", "path": "library/os#os.stat_result.st_uid", "type": "Operating System", "text": "\nUser identifier of the file owner.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.strerror()", "path": "library/os#os.strerror", "type": "Operating System", "text": "\nReturn the error message corresponding to the error code in code. On platforms\nwhere `strerror()` returns `NULL` when given an unknown error number,\n`ValueError` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.supports_bytes_environ", "path": "library/os#os.supports_bytes_environ", "type": "Operating System", "text": "\n`True` if the native OS type of the environment is bytes (eg. `False` on\nWindows).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.supports_dir_fd", "path": "library/os#os.supports_dir_fd", "type": "Operating System", "text": "\nA `set` object indicating which functions in the `os` module accept an open\nfile descriptor for their dir_fd parameter. Different platforms provide\ndifferent features, and the underlying functionality Python uses to implement\nthe dir_fd parameter is not available on all platforms Python supports. For\nconsistency\u2019s sake, functions that may support dir_fd always allow specifying\nthe parameter, but will throw an exception if the functionality is used when\nit\u2019s not locally available. (Specifying `None` for dir_fd is always supported\non all platforms.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.supports_effective_ids", "path": "library/os#os.supports_effective_ids", "type": "Operating System", "text": "\nA `set` object indicating whether `os.access()` permits specifying `True` for\nits effective_ids parameter on the local platform. (Specifying `False` for\neffective_ids is always supported on all platforms.) If the local platform\nsupports it, the collection will contain `os.access()`; otherwise it will be\nempty.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.supports_fd", "path": "library/os#os.supports_fd", "type": "Operating System", "text": "\nA `set` object indicating which functions in the `os` module permit specifying\ntheir path parameter as an open file descriptor on the local platform.\nDifferent platforms provide different features, and the underlying\nfunctionality Python uses to accept open file descriptors as path arguments is\nnot available on all platforms Python supports.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.supports_follow_symlinks", "path": "library/os#os.supports_follow_symlinks", "type": "Operating System", "text": "\nA `set` object indicating which functions in the `os` module accept `False`\nfor their follow_symlinks parameter on the local platform. Different platforms\nprovide different features, and the underlying functionality Python uses to\nimplement follow_symlinks is not available on all platforms Python supports.\nFor consistency\u2019s sake, functions that may support follow_symlinks always\nallow specifying the parameter, but will throw an exception if the\nfunctionality is used when it\u2019s not locally available. (Specifying `True` for\nfollow_symlinks is always supported on all platforms.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.symlink()", "path": "library/os#os.symlink", "type": "Operating System", "text": "\nCreate a symbolic link pointing to src named dst.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.sync()", "path": "library/os#os.sync", "type": "Operating System", "text": "\nForce write of everything to disk.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.sysconf()", "path": "library/os#os.sysconf", "type": "Operating System", "text": "\nReturn integer-valued system configuration values. If the configuration value\nspecified by name isn\u2019t defined, `-1` is returned. The comments regarding the\nname parameter for `confstr()` apply here as well; the dictionary that\nprovides information on the known names is given by `sysconf_names`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.sysconf_names", "path": "library/os#os.sysconf_names", "type": "Operating System", "text": "\nDictionary mapping names accepted by `sysconf()` to the integer values defined\nfor those names by the host operating system. This can be used to determine\nthe set of names known to the system.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.system()", "path": "library/os#os.system", "type": "Operating System", "text": "\nExecute the command (a string) in a subshell. This is implemented by calling\nthe Standard C function `system()`, and has the same limitations. Changes to\n`sys.stdin`, etc. are not reflected in the environment of the executed\ncommand. If command generates any output, it will be sent to the interpreter\nstandard output stream.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.tcgetpgrp()", "path": "library/os#os.tcgetpgrp", "type": "Operating System", "text": "\nReturn the process group associated with the terminal given by fd (an open\nfile descriptor as returned by `os.open()`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.tcsetpgrp()", "path": "library/os#os.tcsetpgrp", "type": "Operating System", "text": "\nSet the process group associated with the terminal given by fd (an open file\ndescriptor as returned by `os.open()`) to pg.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.terminal_size", "path": "library/os#os.terminal_size", "type": "Operating System", "text": "\nA subclass of tuple, holding `(columns, lines)` of the terminal window size.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.terminal_size.columns", "path": "library/os#os.terminal_size.columns", "type": "Operating System", "text": "\nWidth of the terminal window in characters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.terminal_size.lines", "path": "library/os#os.terminal_size.lines", "type": "Operating System", "text": "\nHeight of the terminal window in characters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.times()", "path": "library/os#os.times", "type": "Operating System", "text": "\nReturns the current global process times. The return value is an object with\nfive attributes:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.truncate()", "path": "library/os#os.truncate", "type": "Operating System", "text": "\nTruncate the file corresponding to path, so that it is at most length bytes in\nsize.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.ttyname()", "path": "library/os#os.ttyname", "type": "Operating System", "text": "\nReturn a string which specifies the terminal device associated with file\ndescriptor fd. If fd is not associated with a terminal device, an exception is\nraised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.umask()", "path": "library/os#os.umask", "type": "Operating System", "text": "\nSet the current numeric umask and return the previous umask.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.uname()", "path": "library/os#os.uname", "type": "Operating System", "text": "\nReturns information identifying the current operating system. The return value\nis an object with five attributes:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.unlink()", "path": "library/os#os.unlink", "type": "Operating System", "text": "\nRemove (delete) the file path. This function is semantically identical to\n`remove()`; the `unlink` name is its traditional Unix name. Please see the\ndocumentation for `remove()` for further information.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.unsetenv()", "path": "library/os#os.unsetenv", "type": "Operating System", "text": "\nUnset (delete) the environment variable named key. Such changes to the\nenvironment affect subprocesses started with `os.system()`, `popen()` or\n`fork()` and `execv()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.urandom()", "path": "library/os#os.urandom", "type": "Operating System", "text": "\nReturn a string of size random bytes suitable for cryptographic use.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.utime()", "path": "library/os#os.utime", "type": "Operating System", "text": "\nSet the access and modified times of the file specified by path.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.wait()", "path": "library/os#os.wait", "type": "Operating System", "text": "\nWait for completion of a child process, and return a tuple containing its pid\nand exit status indication: a 16-bit number, whose low byte is the signal\nnumber that killed the process, and whose high byte is the exit status (if the\nsignal number is zero); the high bit of the low byte is set if a core file was\nproduced.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.wait3()", "path": "library/os#os.wait3", "type": "Operating System", "text": "\nSimilar to `waitpid()`, except no process id argument is given and a 3-element\ntuple containing the child\u2019s process id, exit status indication, and resource\nusage information is returned. Refer to `resource`.`getrusage()` for details\non resource usage information. The option argument is the same as that\nprovided to `waitpid()` and `wait4()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.wait4()", "path": "library/os#os.wait4", "type": "Operating System", "text": "\nSimilar to `waitpid()`, except a 3-element tuple, containing the child\u2019s\nprocess id, exit status indication, and resource usage information is\nreturned. Refer to `resource`.`getrusage()` for details on resource usage\ninformation. The arguments to `wait4()` are the same as those provided to\n`waitpid()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.waitid()", "path": "library/os#os.waitid", "type": "Operating System", "text": "\nWait for the completion of one or more child processes. idtype can be `P_PID`,\n`P_PGID`, `P_ALL`, or `P_PIDFD` on Linux. id specifies the pid to wait on.\noptions is constructed from the ORing of one or more of `WEXITED`, `WSTOPPED`\nor `WCONTINUED` and additionally may be ORed with `WNOHANG` or `WNOWAIT`. The\nreturn value is an object representing the data contained in the `siginfo_t`\nstructure, namely: `si_pid`, `si_uid`, `si_signo`, `si_status`, `si_code` or\n`None` if `WNOHANG` is specified and there are no children in a waitable\nstate.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.waitpid()", "path": "library/os#os.waitpid", "type": "Operating System", "text": "\nThe details of this function differ on Unix and Windows.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.waitstatus_to_exitcode()", "path": "library/os#os.waitstatus_to_exitcode", "type": "Operating System", "text": "\nConvert a wait status to an exit code.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.walk()", "path": "library/os#os.walk", "type": "Operating System", "text": "\nGenerate the file names in a directory tree by walking the tree either top-\ndown or bottom-up. For each directory in the tree rooted at directory top\n(including top itself), it yields a 3-tuple `(dirpath, dirnames, filenames)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.WCONTINUED", "path": "library/os#os.WCONTINUED", "type": "Operating System", "text": "\nThis option causes child processes to be reported if they have been continued\nfrom a job control stop since their status was last reported.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.WCOREDUMP()", "path": "library/os#os.WCOREDUMP", "type": "Operating System", "text": "\nReturn `True` if a core dump was generated for the process, otherwise return\n`False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.WEXITED", "path": "library/os#os.WEXITED", "type": "Operating System", "text": "\nFlags that can be used in options in `waitid()` that specify what child signal\nto wait for.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.WEXITSTATUS()", "path": "library/os#os.WEXITSTATUS", "type": "Operating System", "text": "\nReturn the process exit status.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.WIFCONTINUED()", "path": "library/os#os.WIFCONTINUED", "type": "Operating System", "text": "\nReturn `True` if a stopped child has been resumed by delivery of `SIGCONT` (if\nthe process has been continued from a job control stop), otherwise return\n`False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.WIFEXITED()", "path": "library/os#os.WIFEXITED", "type": "Operating System", "text": "\nReturn `True` if the process exited terminated normally, that is, by calling\n`exit()` or `_exit()`, or by returning from `main()`; otherwise return\n`False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.WIFSIGNALED()", "path": "library/os#os.WIFSIGNALED", "type": "Operating System", "text": "\nReturn `True` if the process was terminated by a signal, otherwise return\n`False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.WIFSTOPPED()", "path": "library/os#os.WIFSTOPPED", "type": "Operating System", "text": "\nReturn `True` if the process was stopped by delivery of a signal, otherwise\nreturn `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.WNOHANG", "path": "library/os#os.WNOHANG", "type": "Operating System", "text": "\nThe option for `waitpid()` to return immediately if no child process status is\navailable immediately. The function returns `(0, 0)` in this case.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.WNOWAIT", "path": "library/os#os.WNOWAIT", "type": "Operating System", "text": "\nFlags that can be used in options in `waitid()` that specify what child signal\nto wait for.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.write()", "path": "library/os#os.write", "type": "Operating System", "text": "\nWrite the bytestring in str to file descriptor fd.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.writev()", "path": "library/os#os.writev", "type": "Operating System", "text": "\nWrite the contents of buffers to file descriptor fd. buffers must be a\nsequence of bytes-like objects. Buffers are processed in array order. Entire\ncontents of the first buffer is written before proceeding to the second, and\nso on.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.WSTOPPED", "path": "library/os#os.WSTOPPED", "type": "Operating System", "text": "\nFlags that can be used in options in `waitid()` that specify what child signal\nto wait for.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.WSTOPSIG()", "path": "library/os#os.WSTOPSIG", "type": "Operating System", "text": "\nReturn the signal which caused the process to stop.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.WTERMSIG()", "path": "library/os#os.WTERMSIG", "type": "Operating System", "text": "\nReturn the number of the signal that caused the process to terminate.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.WUNTRACED", "path": "library/os#os.WUNTRACED", "type": "Operating System", "text": "\nThis option causes child processes to be reported if they have been stopped\nbut their current state has not been reported since they were stopped.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.W_OK", "path": "library/os#os.W_OK", "type": "Operating System", "text": "\nValues to pass as the mode parameter of `access()` to test the existence,\nreadability, writability and executability of path, respectively.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.XATTR_CREATE", "path": "library/os#os.XATTR_CREATE", "type": "Operating System", "text": "\nThis is a possible value for the flags argument in `setxattr()`. It indicates\nthe operation must create an attribute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.XATTR_REPLACE", "path": "library/os#os.XATTR_REPLACE", "type": "Operating System", "text": "\nThis is a possible value for the flags argument in `setxattr()`. It indicates\nthe operation must replace an existing attribute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.XATTR_SIZE_MAX", "path": "library/os#os.XATTR_SIZE_MAX", "type": "Operating System", "text": "\nThe maximum size the value of an extended attribute can be. Currently, this is\n64 KiB on Linux.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os.X_OK", "path": "library/os#os.X_OK", "type": "Operating System", "text": "\nValues to pass as the mode parameter of `access()` to test the existence,\nreadability, writability and executability of path, respectively.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "os._exit()", "path": "library/os#os._exit", "type": "Operating System", "text": "\nExit the process with status n, without calling cleanup handlers, flushing\nstdio buffers, etc.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "OSError", "path": "library/exceptions#OSError", "type": "Built-in Exceptions", "text": "\nThis exception is raised when a system function returns a system-related\nerror, including I/O failures such as \u201cfile not found\u201d or \u201cdisk full\u201d (not for\nillegal argument types or other incidental errors).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "OSError.errno", "path": "library/exceptions#OSError.errno", "type": "Built-in Exceptions", "text": "\nA numeric error code from the C variable `errno`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "OSError.filename", "path": "library/exceptions#OSError.filename", "type": "Built-in Exceptions", "text": "\nFor exceptions that involve a file system path (such as `open()` or\n`os.unlink()`), `filename` is the file name passed to the function. For\nfunctions that involve two file system paths (such as `os.rename()`),\n`filename2` corresponds to the second file name passed to the function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "OSError.filename2", "path": "library/exceptions#OSError.filename2", "type": "Built-in Exceptions", "text": "\nFor exceptions that involve a file system path (such as `open()` or\n`os.unlink()`), `filename` is the file name passed to the function. For\nfunctions that involve two file system paths (such as `os.rename()`),\n`filename2` corresponds to the second file name passed to the function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "OSError.strerror", "path": "library/exceptions#OSError.strerror", "type": "Built-in Exceptions", "text": "\nThe corresponding error message, as provided by the operating system. It is\nformatted by the C functions `perror()` under POSIX, and `FormatMessage()`\nunder Windows.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "OSError.winerror", "path": "library/exceptions#OSError.winerror", "type": "Built-in Exceptions", "text": "\nUnder Windows, this gives you the native Windows error code. The `errno`\nattribute is then an approximate translation, in POSIX terms, of that native\nerror code.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ossaudiodev", "path": "library/ossaudiodev", "type": "Multimedia", "text": "\nThis module allows you to access the OSS (Open Sound System) audio interface.\nOSS is available for a wide range of open-source and commercial Unices, and is\nthe standard audio interface for Linux and recent versions of FreeBSD.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ossaudiodev.open()", "path": "library/ossaudiodev#ossaudiodev.open", "type": "Multimedia", "text": "\nOpen an audio device and return an OSS audio device object. This object\nsupports many file-like methods, such as `read()`, `write()`, and `fileno()`\n(although there are subtle differences between conventional Unix read/write\nsemantics and those of OSS audio devices). It also supports a number of audio-\nspecific methods; see below for the complete list of methods.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ossaudiodev.openmixer()", "path": "library/ossaudiodev#ossaudiodev.openmixer", "type": "Multimedia", "text": "\nOpen a mixer device and return an OSS mixer device object. device is the mixer\ndevice filename to use. If it is not specified, this module first looks in the\nenvironment variable `MIXERDEV` for a device to use. If not found, it falls\nback to `/dev/mixer`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ossaudiodev.OSSAudioError", "path": "library/ossaudiodev#ossaudiodev.OSSAudioError", "type": "Multimedia", "text": "\nThis exception is raised on certain errors. The argument is a string\ndescribing what went wrong.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ossaudiodev.oss_audio_device.bufsize()", "path": "library/ossaudiodev#ossaudiodev.oss_audio_device.bufsize", "type": "Multimedia", "text": "\nReturns the size of the hardware buffer, in samples.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ossaudiodev.oss_audio_device.channels()", "path": "library/ossaudiodev#ossaudiodev.oss_audio_device.channels", "type": "Multimedia", "text": "\nSet the number of output channels to nchannels. A value of 1 indicates\nmonophonic sound, 2 stereophonic. Some devices may have more than 2 channels,\nand some high-end devices may not support mono. Returns the number of channels\nthe device was set to.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ossaudiodev.oss_audio_device.close()", "path": "library/ossaudiodev#ossaudiodev.oss_audio_device.close", "type": "Multimedia", "text": "\nExplicitly close the audio device. When you are done writing to or reading\nfrom an audio device, you should explicitly close it. A closed device cannot\nbe used again.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ossaudiodev.oss_audio_device.closed", "path": "library/ossaudiodev#ossaudiodev.oss_audio_device.closed", "type": "Multimedia", "text": "\nBoolean indicating whether the device has been closed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ossaudiodev.oss_audio_device.fileno()", "path": "library/ossaudiodev#ossaudiodev.oss_audio_device.fileno", "type": "Multimedia", "text": "\nReturn the file descriptor associated with the device.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ossaudiodev.oss_audio_device.getfmts()", "path": "library/ossaudiodev#ossaudiodev.oss_audio_device.getfmts", "type": "Multimedia", "text": "\nReturn a bitmask of the audio output formats supported by the soundcard. Some\nof the formats supported by OSS are:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ossaudiodev.oss_audio_device.mode", "path": "library/ossaudiodev#ossaudiodev.oss_audio_device.mode", "type": "Multimedia", "text": "\nThe I/O mode for the file, either `\"r\"`, `\"rw\"`, or `\"w\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ossaudiodev.oss_audio_device.name", "path": "library/ossaudiodev#ossaudiodev.oss_audio_device.name", "type": "Multimedia", "text": "\nString containing the name of the device file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ossaudiodev.oss_audio_device.nonblock()", "path": "library/ossaudiodev#ossaudiodev.oss_audio_device.nonblock", "type": "Multimedia", "text": "\nPut the device into non-blocking mode. Once in non-blocking mode, there is no\nway to return it to blocking mode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ossaudiodev.oss_audio_device.obufcount()", "path": "library/ossaudiodev#ossaudiodev.oss_audio_device.obufcount", "type": "Multimedia", "text": "\nReturns the number of samples that are in the hardware buffer yet to be\nplayed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ossaudiodev.oss_audio_device.obuffree()", "path": "library/ossaudiodev#ossaudiodev.oss_audio_device.obuffree", "type": "Multimedia", "text": "\nReturns the number of samples that could be queued into the hardware buffer to\nbe played without blocking.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ossaudiodev.oss_audio_device.post()", "path": "library/ossaudiodev#ossaudiodev.oss_audio_device.post", "type": "Multimedia", "text": "\nTell the driver that there is likely to be a pause in the output, making it\npossible for the device to handle the pause more intelligently. You might use\nthis after playing a spot sound effect, before waiting for user input, or\nbefore doing disk I/O.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ossaudiodev.oss_audio_device.read()", "path": "library/ossaudiodev#ossaudiodev.oss_audio_device.read", "type": "Multimedia", "text": "\nRead size bytes from the audio input and return them as a Python string.\nUnlike most Unix device drivers, OSS audio devices in blocking mode (the\ndefault) will block `read()` until the entire requested amount of data is\navailable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ossaudiodev.oss_audio_device.reset()", "path": "library/ossaudiodev#ossaudiodev.oss_audio_device.reset", "type": "Multimedia", "text": "\nImmediately stop playing or recording and return the device to a state where\nit can accept commands. The OSS documentation recommends closing and re-\nopening the device after calling `reset()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ossaudiodev.oss_audio_device.setfmt()", "path": "library/ossaudiodev#ossaudiodev.oss_audio_device.setfmt", "type": "Multimedia", "text": "\nTry to set the current audio format to format\u2014see `getfmts()` for a list.\nReturns the audio format that the device was set to, which may not be the\nrequested format. May also be used to return the current audio format\u2014do this\nby passing an \u201caudio format\u201d of `AFMT_QUERY`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ossaudiodev.oss_audio_device.setparameters()", "path": "library/ossaudiodev#ossaudiodev.oss_audio_device.setparameters", "type": "Multimedia", "text": "\nSet the key audio sampling parameters\u2014sample format, number of channels, and\nsampling rate\u2014in one method call. format, nchannels, and samplerate should be\nas specified in the `setfmt()`, `channels()`, and `speed()` methods. If strict\nis true, `setparameters()` checks to see if each parameter was actually set to\nthe requested value, and raises `OSSAudioError` if not. Returns a tuple\n(format, nchannels, samplerate) indicating the parameter values that were\nactually set by the device driver (i.e., the same as the return values of\n`setfmt()`, `channels()`, and `speed()`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ossaudiodev.oss_audio_device.speed()", "path": "library/ossaudiodev#ossaudiodev.oss_audio_device.speed", "type": "Multimedia", "text": "\nTry to set the audio sampling rate to samplerate samples per second. Returns\nthe rate actually set. Most sound devices don\u2019t support arbitrary sampling\nrates. Common rates are:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ossaudiodev.oss_audio_device.sync()", "path": "library/ossaudiodev#ossaudiodev.oss_audio_device.sync", "type": "Multimedia", "text": "\nWait until the sound device has played every byte in its buffer. (This happens\nimplicitly when the device is closed.) The OSS documentation recommends\nclosing and re-opening the device rather than using `sync()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ossaudiodev.oss_audio_device.write()", "path": "library/ossaudiodev#ossaudiodev.oss_audio_device.write", "type": "Multimedia", "text": "\nWrite a bytes-like object data to the audio device and return the number of\nbytes written. If the audio device is in blocking mode (the default), the\nentire data is always written (again, this is different from usual Unix device\nsemantics). If the device is in non-blocking mode, some data may not be\nwritten\u2014see `writeall()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ossaudiodev.oss_audio_device.writeall()", "path": "library/ossaudiodev#ossaudiodev.oss_audio_device.writeall", "type": "Multimedia", "text": "\nWrite a bytes-like object data to the audio device: waits until the audio\ndevice is able to accept data, writes as much data as it will accept, and\nrepeats until data has been completely written. If the device is in blocking\nmode (the default), this has the same effect as `write()`; `writeall()` is\nonly useful in non-blocking mode. Has no return value, since the amount of\ndata written is always equal to the amount of data supplied.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ossaudiodev.oss_mixer_device.close()", "path": "library/ossaudiodev#ossaudiodev.oss_mixer_device.close", "type": "Multimedia", "text": "\nThis method closes the open mixer device file. Any further attempts to use the\nmixer after this file is closed will raise an `OSError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ossaudiodev.oss_mixer_device.controls()", "path": "library/ossaudiodev#ossaudiodev.oss_mixer_device.controls", "type": "Multimedia", "text": "\nThis method returns a bitmask specifying the available mixer controls\n(\u201cControl\u201d being a specific mixable \u201cchannel\u201d, such as `SOUND_MIXER_PCM` or\n`SOUND_MIXER_SYNTH`). This bitmask indicates a subset of all available mixer\ncontrols\u2014the `SOUND_MIXER_*` constants defined at module level. To determine\nif, for example, the current mixer object supports a PCM mixer, use the\nfollowing Python code:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ossaudiodev.oss_mixer_device.fileno()", "path": "library/ossaudiodev#ossaudiodev.oss_mixer_device.fileno", "type": "Multimedia", "text": "\nReturns the file handle number of the open mixer device file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ossaudiodev.oss_mixer_device.get()", "path": "library/ossaudiodev#ossaudiodev.oss_mixer_device.get", "type": "Multimedia", "text": "\nReturns the volume of a given mixer control. The returned volume is a 2-tuple\n`(left_volume,right_volume)`. Volumes are specified as numbers from 0 (silent)\nto 100 (full volume). If the control is monophonic, a 2-tuple is still\nreturned, but both volumes are the same.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ossaudiodev.oss_mixer_device.get_recsrc()", "path": "library/ossaudiodev#ossaudiodev.oss_mixer_device.get_recsrc", "type": "Multimedia", "text": "\nThis method returns a bitmask indicating which control(s) are currently being\nused as a recording source.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ossaudiodev.oss_mixer_device.reccontrols()", "path": "library/ossaudiodev#ossaudiodev.oss_mixer_device.reccontrols", "type": "Multimedia", "text": "\nReturns a bitmask specifying the mixer controls that may be used to record.\nSee the code example for `controls()` for an example of reading from a\nbitmask.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ossaudiodev.oss_mixer_device.set()", "path": "library/ossaudiodev#ossaudiodev.oss_mixer_device.set", "type": "Multimedia", "text": "\nSets the volume for a given mixer control to `(left,right)`. `left` and\n`right` must be ints and between 0 (silent) and 100 (full volume). On success,\nthe new volume is returned as a 2-tuple. Note that this may not be exactly the\nsame as the volume specified, because of the limited resolution of some\nsoundcard\u2019s mixers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ossaudiodev.oss_mixer_device.set_recsrc()", "path": "library/ossaudiodev#ossaudiodev.oss_mixer_device.set_recsrc", "type": "Multimedia", "text": "\nCall this function to specify a recording source. Returns a bitmask indicating\nthe new recording source (or sources) if successful; raises `OSError` if an\ninvalid source was specified. To set the current recording source to the\nmicrophone input:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ossaudiodev.oss_mixer_device.stereocontrols()", "path": "library/ossaudiodev#ossaudiodev.oss_mixer_device.stereocontrols", "type": "Multimedia", "text": "\nReturns a bitmask indicating stereo mixer controls. If a bit is set, the\ncorresponding control is stereo; if it is unset, the control is either\nmonophonic or not supported by the mixer (use in combination with `controls()`\nto determine which).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Other Graphical User Interface Packages", "path": "library/othergui", "type": "Tk", "text": "\nMajor cross-platform (Windows, Mac OS X, Unix-like) GUI toolkits are available\nfor Python:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "OverflowError", "path": "library/exceptions#OverflowError", "type": "Built-in Exceptions", "text": "\nRaised when the result of an arithmetic operation is too large to be\nrepresented. This cannot occur for integers (which would rather raise\n`MemoryError` than give up). However, for historical reasons, OverflowError is\nsometimes raised for integers that are outside a required range. Because of\nthe lack of standardization of floating point exception handling in C, most\nfloating point operations are not checked.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "parser", "path": "library/parser", "type": "Language", "text": "\nThe `parser` module provides an interface to Python\u2019s internal parser and\nbyte-code compiler. The primary purpose for this interface is to allow Python\ncode to edit the parse tree of a Python expression and create executable code\nfrom this. This is better than trying to parse and modify an arbitrary Python\ncode fragment as a string because parsing is performed in a manner identical\nto the code forming the application. It is also faster.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "parser.compilest()", "path": "library/parser#parser.compilest", "type": "Language", "text": "\nThe Python byte compiler can be invoked on an ST object to produce code\nobjects which can be used as part of a call to the built-in `exec()` or\n`eval()` functions. This function provides the interface to the compiler,\npassing the internal parse tree from st to the parser, using the source file\nname specified by the filename parameter. The default value supplied for\nfilename indicates that the source was an ST object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "parser.expr()", "path": "library/parser#parser.expr", "type": "Language", "text": "\nThe `expr()` function parses the parameter source as if it were an input to\n`compile(source, 'file.py', 'eval')`. If the parse succeeds, an ST object is\ncreated to hold the internal parse tree representation, otherwise an\nappropriate exception is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "parser.isexpr()", "path": "library/parser#parser.isexpr", "type": "Language", "text": "\nWhen st represents an `'eval'` form, this function returns `True`, otherwise\nit returns `False`. This is useful, since code objects normally cannot be\nqueried for this information using existing built-in functions. Note that the\ncode objects created by `compilest()` cannot be queried like this either, and\nare identical to those created by the built-in `compile()` function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "parser.issuite()", "path": "library/parser#parser.issuite", "type": "Language", "text": "\nThis function mirrors `isexpr()` in that it reports whether an ST object\nrepresents an `'exec'` form, commonly known as a \u201csuite.\u201d It is not safe to\nassume that this function is equivalent to `not isexpr(st)`, as additional\nsyntactic fragments may be supported in the future.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "parser.ParserError", "path": "library/parser#parser.ParserError", "type": "Language", "text": "\nException raised when a failure occurs within the parser module. This is\ngenerally produced for validation failures rather than the built-in\n`SyntaxError` raised during normal parsing. The exception argument is either a\nstring describing the reason of the failure or a tuple containing a sequence\ncausing the failure from a parse tree passed to `sequence2st()` and an\nexplanatory string. Calls to `sequence2st()` need to be able to handle either\ntype of exception, while calls to other functions in the module will only need\nto be aware of the simple string values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "parser.sequence2st()", "path": "library/parser#parser.sequence2st", "type": "Language", "text": "\nThis function accepts a parse tree represented as a sequence and builds an\ninternal representation if possible. If it can validate that the tree conforms\nto the Python grammar and all nodes are valid node types in the host version\nof Python, an ST object is created from the internal representation and\nreturned to the called. If there is a problem creating the internal\nrepresentation, or if the tree cannot be validated, a `ParserError` exception\nis raised. An ST object created this way should not be assumed to compile\ncorrectly; normal exceptions raised by compilation may still be initiated when\nthe ST object is passed to `compilest()`. This may indicate problems not\nrelated to syntax (such as a `MemoryError` exception), but may also be due to\nconstructs such as the result of parsing `del f(0)`, which escapes the Python\nparser but is checked by the bytecode compiler.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "parser.ST.compile()", "path": "library/parser#parser.ST.compile", "type": "Language", "text": "\nSame as `compilest(st, filename)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "parser.ST.isexpr()", "path": "library/parser#parser.ST.isexpr", "type": "Language", "text": "\nSame as `isexpr(st)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "parser.ST.issuite()", "path": "library/parser#parser.ST.issuite", "type": "Language", "text": "\nSame as `issuite(st)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "parser.ST.tolist()", "path": "library/parser#parser.ST.tolist", "type": "Language", "text": "\nSame as `st2list(st, line_info, col_info)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "parser.ST.totuple()", "path": "library/parser#parser.ST.totuple", "type": "Language", "text": "\nSame as `st2tuple(st, line_info, col_info)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "parser.st2list()", "path": "library/parser#parser.st2list", "type": "Language", "text": "\nThis function accepts an ST object from the caller in st and returns a Python\nlist representing the equivalent parse tree. The resulting list representation\ncan be used for inspection or the creation of a new parse tree in list form.\nThis function does not fail so long as memory is available to build the list\nrepresentation. If the parse tree will only be used for inspection,\n`st2tuple()` should be used instead to reduce memory consumption and\nfragmentation. When the list representation is required, this function is\nsignificantly faster than retrieving a tuple representation and converting\nthat to nested lists.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "parser.st2tuple()", "path": "library/parser#parser.st2tuple", "type": "Language", "text": "\nThis function accepts an ST object from the caller in st and returns a Python\ntuple representing the equivalent parse tree. Other than returning a tuple\ninstead of a list, this function is identical to `st2list()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "parser.STType", "path": "library/parser#parser.STType", "type": "Language", "text": "\nThe type of the objects returned by `expr()`, `suite()` and `sequence2st()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "parser.suite()", "path": "library/parser#parser.suite", "type": "Language", "text": "\nThe `suite()` function parses the parameter source as if it were an input to\n`compile(source, 'file.py', 'exec')`. If the parse succeeds, an ST object is\ncreated to hold the internal parse tree representation, otherwise an\nappropriate exception is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "parser.tuple2st()", "path": "library/parser#parser.tuple2st", "type": "Language", "text": "\nThis is the same function as `sequence2st()`. This entry point is maintained\nfor backward compatibility.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib", "path": "library/pathlib", "type": "File & Directory Access", "text": "\nNew in version 3.4.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.Path", "path": "library/pathlib#pathlib.Path", "type": "File & Directory Access", "text": "\nA subclass of `PurePath`, this class represents concrete paths of the system\u2019s\npath flavour (instantiating it creates either a `PosixPath` or a\n`WindowsPath`):\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.Path.chmod()", "path": "library/pathlib#pathlib.Path.chmod", "type": "File & Directory Access", "text": "\nChange the file mode and permissions, like `os.chmod()`:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.Path.cwd()", "path": "library/pathlib#pathlib.Path.cwd", "type": "File & Directory Access", "text": "\nReturn a new path object representing the current directory (as returned by\n`os.getcwd()`):\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.Path.exists()", "path": "library/pathlib#pathlib.Path.exists", "type": "File & Directory Access", "text": "\nWhether the path points to an existing file or directory:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.Path.expanduser()", "path": "library/pathlib#pathlib.Path.expanduser", "type": "File & Directory Access", "text": "\nReturn a new path with expanded `~` and `~user` constructs, as returned by\n`os.path.expanduser()`:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.Path.glob()", "path": "library/pathlib#pathlib.Path.glob", "type": "File & Directory Access", "text": "\nGlob the given relative pattern in the directory represented by this path,\nyielding all matching files (of any kind):\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.Path.group()", "path": "library/pathlib#pathlib.Path.group", "type": "File & Directory Access", "text": "\nReturn the name of the group owning the file. `KeyError` is raised if the\nfile\u2019s gid isn\u2019t found in the system database.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.Path.home()", "path": "library/pathlib#pathlib.Path.home", "type": "File & Directory Access", "text": "\nReturn a new path object representing the user\u2019s home directory (as returned\nby `os.path.expanduser()` with `~` construct):\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.Path.is_block_device()", "path": "library/pathlib#pathlib.Path.is_block_device", "type": "File & Directory Access", "text": "\nReturn `True` if the path points to a block device (or a symbolic link\npointing to a block device), `False` if it points to another kind of file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.Path.is_char_device()", "path": "library/pathlib#pathlib.Path.is_char_device", "type": "File & Directory Access", "text": "\nReturn `True` if the path points to a character device (or a symbolic link\npointing to a character device), `False` if it points to another kind of file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.Path.is_dir()", "path": "library/pathlib#pathlib.Path.is_dir", "type": "File & Directory Access", "text": "\nReturn `True` if the path points to a directory (or a symbolic link pointing\nto a directory), `False` if it points to another kind of file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.Path.is_fifo()", "path": "library/pathlib#pathlib.Path.is_fifo", "type": "File & Directory Access", "text": "\nReturn `True` if the path points to a FIFO (or a symbolic link pointing to a\nFIFO), `False` if it points to another kind of file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.Path.is_file()", "path": "library/pathlib#pathlib.Path.is_file", "type": "File & Directory Access", "text": "\nReturn `True` if the path points to a regular file (or a symbolic link\npointing to a regular file), `False` if it points to another kind of file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.Path.is_mount()", "path": "library/pathlib#pathlib.Path.is_mount", "type": "File & Directory Access", "text": "\nReturn `True` if the path is a mount point: a point in a file system where a\ndifferent file system has been mounted. On POSIX, the function checks whether\npath\u2019s parent, `path/..`, is on a different device than path, or whether\n`path/..` and path point to the same i-node on the same device \u2014 this should\ndetect mount points for all Unix and POSIX variants. Not implemented on\nWindows.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.Path.is_socket()", "path": "library/pathlib#pathlib.Path.is_socket", "type": "File & Directory Access", "text": "\nReturn `True` if the path points to a Unix socket (or a symbolic link pointing\nto a Unix socket), `False` if it points to another kind of file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.Path.is_symlink()", "path": "library/pathlib#pathlib.Path.is_symlink", "type": "File & Directory Access", "text": "\nReturn `True` if the path points to a symbolic link, `False` otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.Path.iterdir()", "path": "library/pathlib#pathlib.Path.iterdir", "type": "File & Directory Access", "text": "\nWhen the path points to a directory, yield path objects of the directory\ncontents:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.Path.lchmod()", "path": "library/pathlib#pathlib.Path.lchmod", "type": "File & Directory Access", "text": "\nLike `Path.chmod()` but, if the path points to a symbolic link, the symbolic\nlink\u2019s mode is changed rather than its target\u2019s.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.Path.link_to()", "path": "library/pathlib#pathlib.Path.link_to", "type": "File & Directory Access", "text": "\nMake target a hard link to this path.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.Path.lstat()", "path": "library/pathlib#pathlib.Path.lstat", "type": "File & Directory Access", "text": "\nLike `Path.stat()` but, if the path points to a symbolic link, return the\nsymbolic link\u2019s information rather than its target\u2019s.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.Path.mkdir()", "path": "library/pathlib#pathlib.Path.mkdir", "type": "File & Directory Access", "text": "\nCreate a new directory at this given path. If mode is given, it is combined\nwith the process\u2019 `umask` value to determine the file mode and access flags.\nIf the path already exists, `FileExistsError` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.Path.open()", "path": "library/pathlib#pathlib.Path.open", "type": "File & Directory Access", "text": "\nOpen the file pointed to by the path, like the built-in `open()` function\ndoes:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.Path.owner()", "path": "library/pathlib#pathlib.Path.owner", "type": "File & Directory Access", "text": "\nReturn the name of the user owning the file. `KeyError` is raised if the\nfile\u2019s uid isn\u2019t found in the system database.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.Path.readlink()", "path": "library/pathlib#pathlib.Path.readlink", "type": "File & Directory Access", "text": "\nReturn the path to which the symbolic link points (as returned by\n`os.readlink()`):\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.Path.read_bytes()", "path": "library/pathlib#pathlib.Path.read_bytes", "type": "File & Directory Access", "text": "\nReturn the binary contents of the pointed-to file as a bytes object:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.Path.read_text()", "path": "library/pathlib#pathlib.Path.read_text", "type": "File & Directory Access", "text": "\nReturn the decoded contents of the pointed-to file as a string:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.Path.rename()", "path": "library/pathlib#pathlib.Path.rename", "type": "File & Directory Access", "text": "\nRename this file or directory to the given target, and return a new Path\ninstance pointing to target. On Unix, if target exists and is a file, it will\nbe replaced silently if the user has permission. target can be either a string\nor another path object:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.Path.replace()", "path": "library/pathlib#pathlib.Path.replace", "type": "File & Directory Access", "text": "\nRename this file or directory to the given target, and return a new Path\ninstance pointing to target. If target points to an existing file or\ndirectory, it will be unconditionally replaced.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.Path.resolve()", "path": "library/pathlib#pathlib.Path.resolve", "type": "File & Directory Access", "text": "\nMake the path absolute, resolving any symlinks. A new path object is returned:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.Path.rglob()", "path": "library/pathlib#pathlib.Path.rglob", "type": "File & Directory Access", "text": "\nThis is like calling `Path.glob()` with \u201c`**/`\u201d added in front of the given\nrelative pattern:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.Path.rmdir()", "path": "library/pathlib#pathlib.Path.rmdir", "type": "File & Directory Access", "text": "\nRemove this directory. The directory must be empty.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.Path.samefile()", "path": "library/pathlib#pathlib.Path.samefile", "type": "File & Directory Access", "text": "\nReturn whether this path points to the same file as other_path, which can be\neither a Path object, or a string. The semantics are similar to\n`os.path.samefile()` and `os.path.samestat()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.Path.stat()", "path": "library/pathlib#pathlib.Path.stat", "type": "File & Directory Access", "text": "\nReturn a `os.stat_result` object containing information about this path, like\n`os.stat()`. The result is looked up at each call to this method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.Path.symlink_to()", "path": "library/pathlib#pathlib.Path.symlink_to", "type": "File & Directory Access", "text": "\nMake this path a symbolic link to target. Under Windows, target_is_directory\nmust be true (default `False`) if the link\u2019s target is a directory. Under\nPOSIX, target_is_directory\u2019s value is ignored.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.Path.touch()", "path": "library/pathlib#pathlib.Path.touch", "type": "File & Directory Access", "text": "\nCreate a file at this given path. If mode is given, it is combined with the\nprocess\u2019 `umask` value to determine the file mode and access flags. If the\nfile already exists, the function succeeds if exist_ok is true (and its\nmodification time is updated to the current time), otherwise `FileExistsError`\nis raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.Path.unlink()", "path": "library/pathlib#pathlib.Path.unlink", "type": "File & Directory Access", "text": "\nRemove this file or symbolic link. If the path points to a directory, use\n`Path.rmdir()` instead.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.Path.write_bytes()", "path": "library/pathlib#pathlib.Path.write_bytes", "type": "File & Directory Access", "text": "\nOpen the file pointed to in bytes mode, write data to it, and close the file:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.Path.write_text()", "path": "library/pathlib#pathlib.Path.write_text", "type": "File & Directory Access", "text": "\nOpen the file pointed to in text mode, write data to it, and close the file:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.PosixPath", "path": "library/pathlib#pathlib.PosixPath", "type": "File & Directory Access", "text": "\nA subclass of `Path` and `PurePosixPath`, this class represents concrete non-\nWindows filesystem paths:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.PurePath", "path": "library/pathlib#pathlib.PurePath", "type": "File & Directory Access", "text": "\nA generic class that represents the system\u2019s path flavour (instantiating it\ncreates either a `PurePosixPath` or a `PureWindowsPath`):\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.PurePath.anchor", "path": "library/pathlib#pathlib.PurePath.anchor", "type": "File & Directory Access", "text": "\nThe concatenation of the drive and root:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.PurePath.as_posix()", "path": "library/pathlib#pathlib.PurePath.as_posix", "type": "File & Directory Access", "text": "\nReturn a string representation of the path with forward slashes (`/`):\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.PurePath.as_uri()", "path": "library/pathlib#pathlib.PurePath.as_uri", "type": "File & Directory Access", "text": "\nRepresent the path as a `file` URI. `ValueError` is raised if the path isn\u2019t\nabsolute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.PurePath.drive", "path": "library/pathlib#pathlib.PurePath.drive", "type": "File & Directory Access", "text": "\nA string representing the drive letter or name, if any:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.PurePath.is_absolute()", "path": "library/pathlib#pathlib.PurePath.is_absolute", "type": "File & Directory Access", "text": "\nReturn whether the path is absolute or not. A path is considered absolute if\nit has both a root and (if the flavour allows) a drive:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.PurePath.is_relative_to()", "path": "library/pathlib#pathlib.PurePath.is_relative_to", "type": "File & Directory Access", "text": "\nReturn whether or not this path is relative to the other path.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.PurePath.is_reserved()", "path": "library/pathlib#pathlib.PurePath.is_reserved", "type": "File & Directory Access", "text": "\nWith `PureWindowsPath`, return `True` if the path is considered reserved under\nWindows, `False` otherwise. With `PurePosixPath`, `False` is always returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.PurePath.joinpath()", "path": "library/pathlib#pathlib.PurePath.joinpath", "type": "File & Directory Access", "text": "\nCalling this method is equivalent to combining the path with each of the other\narguments in turn:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.PurePath.match()", "path": "library/pathlib#pathlib.PurePath.match", "type": "File & Directory Access", "text": "\nMatch this path against the provided glob-style pattern. Return `True` if\nmatching is successful, `False` otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.PurePath.name", "path": "library/pathlib#pathlib.PurePath.name", "type": "File & Directory Access", "text": "\nA string representing the final path component, excluding the drive and root,\nif any:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.PurePath.parent", "path": "library/pathlib#pathlib.PurePath.parent", "type": "File & Directory Access", "text": "\nThe logical parent of the path:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.PurePath.parents", "path": "library/pathlib#pathlib.PurePath.parents", "type": "File & Directory Access", "text": "\nAn immutable sequence providing access to the logical ancestors of the path:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.PurePath.parts", "path": "library/pathlib#pathlib.PurePath.parts", "type": "File & Directory Access", "text": "\nA tuple giving access to the path\u2019s various components:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.PurePath.relative_to()", "path": "library/pathlib#pathlib.PurePath.relative_to", "type": "File & Directory Access", "text": "\nCompute a version of this path relative to the path represented by other. If\nit\u2019s impossible, ValueError is raised:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.PurePath.root", "path": "library/pathlib#pathlib.PurePath.root", "type": "File & Directory Access", "text": "\nA string representing the (local or global) root, if any:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.PurePath.stem", "path": "library/pathlib#pathlib.PurePath.stem", "type": "File & Directory Access", "text": "\nThe final path component, without its suffix:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.PurePath.suffix", "path": "library/pathlib#pathlib.PurePath.suffix", "type": "File & Directory Access", "text": "\nThe file extension of the final component, if any:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.PurePath.suffixes", "path": "library/pathlib#pathlib.PurePath.suffixes", "type": "File & Directory Access", "text": "\nA list of the path\u2019s file extensions:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.PurePath.with_name()", "path": "library/pathlib#pathlib.PurePath.with_name", "type": "File & Directory Access", "text": "\nReturn a new path with the `name` changed. If the original path doesn\u2019t have a\nname, ValueError is raised:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.PurePath.with_stem()", "path": "library/pathlib#pathlib.PurePath.with_stem", "type": "File & Directory Access", "text": "\nReturn a new path with the `stem` changed. If the original path doesn\u2019t have a\nname, ValueError is raised:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.PurePath.with_suffix()", "path": "library/pathlib#pathlib.PurePath.with_suffix", "type": "File & Directory Access", "text": "\nReturn a new path with the `suffix` changed. If the original path doesn\u2019t have\na suffix, the new suffix is appended instead. If the suffix is an empty\nstring, the original suffix is removed:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.PurePosixPath", "path": "library/pathlib#pathlib.PurePosixPath", "type": "File & Directory Access", "text": "\nA subclass of `PurePath`, this path flavour represents non-Windows filesystem\npaths:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.PureWindowsPath", "path": "library/pathlib#pathlib.PureWindowsPath", "type": "File & Directory Access", "text": "\nA subclass of `PurePath`, this path flavour represents Windows filesystem\npaths:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pathlib.WindowsPath", "path": "library/pathlib#pathlib.WindowsPath", "type": "File & Directory Access", "text": "\nA subclass of `Path` and `PureWindowsPath`, this class represents concrete\nWindows filesystem paths:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pdb", "path": "library/pdb", "type": "Debugging & Profiling", "text": "\nSource code: Lib/pdb.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pdb.Pdb", "path": "library/pdb#pdb.Pdb", "type": "Debugging & Profiling", "text": "\n`Pdb` is the debugger class.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pdb.Pdb.run()", "path": "library/pdb#pdb.Pdb.run", "type": "Debugging & Profiling", "text": "\nSee the documentation for the functions explained above.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pdb.Pdb.runcall()", "path": "library/pdb#pdb.Pdb.runcall", "type": "Debugging & Profiling", "text": "\nSee the documentation for the functions explained above.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pdb.Pdb.runeval()", "path": "library/pdb#pdb.Pdb.runeval", "type": "Debugging & Profiling", "text": "\nSee the documentation for the functions explained above.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pdb.Pdb.set_trace()", "path": "library/pdb#pdb.Pdb.set_trace", "type": "Debugging & Profiling", "text": "\nSee the documentation for the functions explained above.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pdb.pm()", "path": "library/pdb#pdb.pm", "type": "Debugging & Profiling", "text": "\nEnter post-mortem debugging of the traceback found in `sys.last_traceback`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pdb.post_mortem()", "path": "library/pdb#pdb.post_mortem", "type": "Debugging & Profiling", "text": "\nEnter post-mortem debugging of the given traceback object. If no traceback is\ngiven, it uses the one of the exception that is currently being handled (an\nexception must be being handled if the default is to be used).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pdb.run()", "path": "library/pdb#pdb.run", "type": "Debugging & Profiling", "text": "\nExecute the statement (given as a string or a code object) under debugger\ncontrol. The debugger prompt appears before any code is executed; you can set\nbreakpoints and type `continue`, or you can step through the statement using\n`step` or `next` (all these commands are explained below). The optional\nglobals and locals arguments specify the environment in which the code is\nexecuted; by default the dictionary of the module `__main__` is used. (See the\nexplanation of the built-in `exec()` or `eval()` functions.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pdb.runcall()", "path": "library/pdb#pdb.runcall", "type": "Debugging & Profiling", "text": "\nCall the function (a function or method object, not a string) with the given\narguments. When `runcall()` returns, it returns whatever the function call\nreturned. The debugger prompt appears as soon as the function is entered.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pdb.runeval()", "path": "library/pdb#pdb.runeval", "type": "Debugging & Profiling", "text": "\nEvaluate the expression (given as a string or a code object) under debugger\ncontrol. When `runeval()` returns, it returns the value of the expression.\nOtherwise this function is similar to `run()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pdb.set_trace()", "path": "library/pdb#pdb.set_trace", "type": "Debugging & Profiling", "text": "\nEnter the debugger at the calling stack frame. This is useful to hard-code a\nbreakpoint at a given point in a program, even if the code is not otherwise\nbeing debugged (e.g. when an assertion fails). If given, header is printed to\nthe console just before debugging begins.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "PendingDeprecationWarning", "path": "library/exceptions#PendingDeprecationWarning", "type": "Built-in Exceptions", "text": "\nBase class for warnings about features which are obsolete and expected to be\ndeprecated in the future, but are not deprecated at the moment.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "PermissionError", "path": "library/exceptions#PermissionError", "type": "Built-in Exceptions", "text": "\nRaised when trying to run an operation without the adequate access rights -\nfor example filesystem permissions. Corresponds to `errno` `EACCES` and\n`EPERM`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pickle", "path": "library/pickle", "type": "Data Persistence", "text": "\nSource code: Lib/pickle.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pickle.DEFAULT_PROTOCOL", "path": "library/pickle#pickle.DEFAULT_PROTOCOL", "type": "Data Persistence", "text": "\nAn integer, the default protocol version used for pickling. May be less than\n`HIGHEST_PROTOCOL`. Currently the default protocol is 4, first introduced in\nPython 3.4 and incompatible with previous versions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pickle.dump()", "path": "library/pickle#pickle.dump", "type": "Data Persistence", "text": "\nWrite the pickled representation of the object obj to the open file object\nfile. This is equivalent to `Pickler(file, protocol).dump(obj)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pickle.dumps()", "path": "library/pickle#pickle.dumps", "type": "Data Persistence", "text": "\nReturn the pickled representation of the object obj as a `bytes` object,\ninstead of writing it to a file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pickle.HIGHEST_PROTOCOL", "path": "library/pickle#pickle.HIGHEST_PROTOCOL", "type": "Data Persistence", "text": "\nAn integer, the highest protocol version available. This value can be passed\nas a protocol value to functions `dump()` and `dumps()` as well as the\n`Pickler` constructor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pickle.load()", "path": "library/pickle#pickle.load", "type": "Data Persistence", "text": "\nRead the pickled representation of an object from the open file object file\nand return the reconstituted object hierarchy specified therein. This is\nequivalent to `Unpickler(file).load()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pickle.loads()", "path": "library/pickle#pickle.loads", "type": "Data Persistence", "text": "\nReturn the reconstituted object hierarchy of the pickled representation data\nof an object. data must be a bytes-like object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pickle.PickleBuffer", "path": "library/pickle#pickle.PickleBuffer", "type": "Data Persistence", "text": "\nA wrapper for a buffer representing picklable data. buffer must be a buffer-\nproviding object, such as a bytes-like object or a N-dimensional array.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pickle.PickleBuffer.raw()", "path": "library/pickle#pickle.PickleBuffer.raw", "type": "Data Persistence", "text": "\nReturn a `memoryview` of the memory area underlying this buffer. The returned\nobject is a one-dimensional, C-contiguous memoryview with format `B` (unsigned\nbytes). `BufferError` is raised if the buffer is neither C- nor Fortran-\ncontiguous.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pickle.PickleBuffer.release()", "path": "library/pickle#pickle.PickleBuffer.release", "type": "Data Persistence", "text": "\nRelease the underlying buffer exposed by the PickleBuffer object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pickle.PickleError", "path": "library/pickle#pickle.PickleError", "type": "Data Persistence", "text": "\nCommon base class for the other pickling exceptions. It inherits `Exception`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pickle.Pickler", "path": "library/pickle#pickle.Pickler", "type": "Data Persistence", "text": "\nThis takes a binary file for writing a pickle data stream.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pickle.Pickler.dispatch_table", "path": "library/pickle#pickle.Pickler.dispatch_table", "type": "Data Persistence", "text": "\nA pickler object\u2019s dispatch table is a registry of reduction functions of the\nkind which can be declared using `copyreg.pickle()`. It is a mapping whose\nkeys are classes and whose values are reduction functions. A reduction\nfunction takes a single argument of the associated class and should conform to\nthe same interface as a `__reduce__()` method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pickle.Pickler.dump()", "path": "library/pickle#pickle.Pickler.dump", "type": "Data Persistence", "text": "\nWrite the pickled representation of obj to the open file object given in the\nconstructor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pickle.Pickler.fast", "path": "library/pickle#pickle.Pickler.fast", "type": "Data Persistence", "text": "\nDeprecated. Enable fast mode if set to a true value. The fast mode disables\nthe usage of memo, therefore speeding the pickling process by not generating\nsuperfluous PUT opcodes. It should not be used with self-referential objects,\ndoing otherwise will cause `Pickler` to recurse infinitely.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pickle.Pickler.persistent_id()", "path": "library/pickle#pickle.Pickler.persistent_id", "type": "Data Persistence", "text": "\nDo nothing by default. This exists so a subclass can override it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pickle.Pickler.reducer_override()", "path": "library/pickle#pickle.Pickler.reducer_override", "type": "Data Persistence", "text": "\nSpecial reducer that can be defined in `Pickler` subclasses. This method has\npriority over any reducer in the `dispatch_table`. It should conform to the\nsame interface as a `__reduce__()` method, and can optionally return\n`NotImplemented` to fallback on `dispatch_table`-registered reducers to pickle\n`obj`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pickle.PicklingError", "path": "library/pickle#pickle.PicklingError", "type": "Data Persistence", "text": "\nError raised when an unpicklable object is encountered by `Pickler`. It\ninherits `PickleError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pickle.Unpickler", "path": "library/pickle#pickle.Unpickler", "type": "Data Persistence", "text": "\nThis takes a binary file for reading a pickle data stream.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pickle.Unpickler.find_class()", "path": "library/pickle#pickle.Unpickler.find_class", "type": "Data Persistence", "text": "\nImport module if necessary and return the object called name from it, where\nthe module and name arguments are `str` objects. Note, unlike its name\nsuggests, `find_class()` is also used for finding functions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pickle.Unpickler.load()", "path": "library/pickle#pickle.Unpickler.load", "type": "Data Persistence", "text": "\nRead the pickled representation of an object from the open file object given\nin the constructor, and return the reconstituted object hierarchy specified\ntherein. Bytes past the pickled representation of the object are ignored.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pickle.Unpickler.persistent_load()", "path": "library/pickle#pickle.Unpickler.persistent_load", "type": "Data Persistence", "text": "\nRaise an `UnpicklingError` by default.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pickle.UnpicklingError", "path": "library/pickle#pickle.UnpicklingError", "type": "Data Persistence", "text": "\nError raised when there is a problem unpickling an object, such as a data\ncorruption or a security violation. It inherits `PickleError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pickletools", "path": "library/pickletools", "type": "Language", "text": "\nSource code: Lib/pickletools.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pickletools.dis()", "path": "library/pickletools#pickletools.dis", "type": "Language", "text": "\nOutputs a symbolic disassembly of the pickle to the file-like object out,\ndefaulting to `sys.stdout`. pickle can be a string or a file-like object. memo\ncan be a Python dictionary that will be used as the pickle\u2019s memo; it can be\nused to perform disassemblies across multiple pickles created by the same\npickler. Successive levels, indicated by `MARK` opcodes in the stream, are\nindented by indentlevel spaces. If a nonzero value is given to annotate, each\nopcode in the output is annotated with a short description. The value of\nannotate is used as a hint for the column where annotation should start.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pickletools.genops()", "path": "library/pickletools#pickletools.genops", "type": "Language", "text": "\nProvides an iterator over all of the opcodes in a pickle, returning a sequence\nof `(opcode, arg, pos)` triples. opcode is an instance of an `OpcodeInfo`\nclass; arg is the decoded value, as a Python object, of the opcode\u2019s argument;\npos is the position at which this opcode is located. pickle can be a string or\na file-like object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pickletools.optimize()", "path": "library/pickletools#pickletools.optimize", "type": "Language", "text": "\nReturns a new equivalent pickle string after eliminating unused `PUT` opcodes.\nThe optimized pickle is shorter, takes less transmission time, requires less\nstorage space, and unpickles more efficiently.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pipes", "path": "library/pipes", "type": "Unix", "text": "\nSource code: Lib/pipes.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pipes.Template", "path": "library/pipes#pipes.Template", "type": "Unix", "text": "\nAn abstraction of a pipeline.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pipes.Template.append()", "path": "library/pipes#pipes.Template.append", "type": "Unix", "text": "\nAppend a new action at the end. The cmd variable must be a valid bourne shell\ncommand. The kind variable consists of two letters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pipes.Template.clone()", "path": "library/pipes#pipes.Template.clone", "type": "Unix", "text": "\nReturn a new, equivalent, pipeline template.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pipes.Template.copy()", "path": "library/pipes#pipes.Template.copy", "type": "Unix", "text": "\nCopy infile to outfile through the pipe.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pipes.Template.debug()", "path": "library/pipes#pipes.Template.debug", "type": "Unix", "text": "\nIf flag is true, turn debugging on. Otherwise, turn debugging off. When\ndebugging is on, commands to be executed are printed, and the shell is given\n`set -x` command to be more verbose.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pipes.Template.open()", "path": "library/pipes#pipes.Template.open", "type": "Unix", "text": "\nReturn a file-like object, open to file, but read from or written to by the\npipeline. Note that only one of `'r'`, `'w'` may be given.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pipes.Template.prepend()", "path": "library/pipes#pipes.Template.prepend", "type": "Unix", "text": "\nAdd a new action at the beginning. See `append()` for explanations of the\narguments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pipes.Template.reset()", "path": "library/pipes#pipes.Template.reset", "type": "Unix", "text": "\nRestore a pipeline template to its initial state.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pkgutil", "path": "library/pkgutil", "type": "Importing", "text": "\nSource code: Lib/pkgutil.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pkgutil.extend_path()", "path": "library/pkgutil#pkgutil.extend_path", "type": "Importing", "text": "\nExtend the search path for the modules which comprise a package. Intended use\nis to place the following code in a package\u2019s `__init__.py`:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pkgutil.find_loader()", "path": "library/pkgutil#pkgutil.find_loader", "type": "Importing", "text": "\nRetrieve a module loader for the given fullname.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pkgutil.get_data()", "path": "library/pkgutil#pkgutil.get_data", "type": "Importing", "text": "\nGet a resource from a package.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pkgutil.get_importer()", "path": "library/pkgutil#pkgutil.get_importer", "type": "Importing", "text": "\nRetrieve a finder for the given path_item.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pkgutil.get_loader()", "path": "library/pkgutil#pkgutil.get_loader", "type": "Importing", "text": "\nGet a loader object for module_or_name.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pkgutil.ImpImporter", "path": "library/pkgutil#pkgutil.ImpImporter", "type": "Importing", "text": "\nPEP 302 Finder that wraps Python\u2019s \u201cclassic\u201d import algorithm.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pkgutil.ImpLoader", "path": "library/pkgutil#pkgutil.ImpLoader", "type": "Importing", "text": "\nLoader that wraps Python\u2019s \u201cclassic\u201d import algorithm.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pkgutil.iter_importers()", "path": "library/pkgutil#pkgutil.iter_importers", "type": "Importing", "text": "\nYield finder objects for the given module name.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pkgutil.iter_modules()", "path": "library/pkgutil#pkgutil.iter_modules", "type": "Importing", "text": "\nYields `ModuleInfo` for all submodules on path, or, if path is `None`, all\ntop-level modules on `sys.path`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pkgutil.ModuleInfo", "path": "library/pkgutil#pkgutil.ModuleInfo", "type": "Importing", "text": "\nA namedtuple that holds a brief summary of a module\u2019s info.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pkgutil.resolve_name()", "path": "library/pkgutil#pkgutil.resolve_name", "type": "Importing", "text": "\nResolve a name to an object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pkgutil.walk_packages()", "path": "library/pkgutil#pkgutil.walk_packages", "type": "Importing", "text": "\nYields `ModuleInfo` for all modules recursively on path, or, if path is\n`None`, all accessible modules.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "platform", "path": "library/platform", "type": "Operating System", "text": "\nSource code: Lib/platform.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Platform Support", "path": "library/asyncio-platforms", "type": "Asynchronous I/O", "text": "\nThe `asyncio` module is designed to be portable, but some platforms have\nsubtle differences and limitations due to the platforms\u2019 underlying\narchitecture and capabilities.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "platform.architecture()", "path": "library/platform#platform.architecture", "type": "Operating System", "text": "\nQueries the given executable (defaults to the Python interpreter binary) for\nvarious architecture information.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "platform.java_ver()", "path": "library/platform#platform.java_ver", "type": "Operating System", "text": "\nVersion interface for Jython.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "platform.libc_ver()", "path": "library/platform#platform.libc_ver", "type": "Operating System", "text": "\nTries to determine the libc version against which the file executable\n(defaults to the Python interpreter) is linked. Returns a tuple of strings\n`(lib, version)` which default to the given parameters in case the lookup\nfails.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "platform.machine()", "path": "library/platform#platform.machine", "type": "Operating System", "text": "\nReturns the machine type, e.g. `'i386'`. An empty string is returned if the\nvalue cannot be determined.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "platform.mac_ver()", "path": "library/platform#platform.mac_ver", "type": "Operating System", "text": "\nGet Mac OS version information and return it as tuple `(release, versioninfo,\nmachine)` with versioninfo being a tuple `(version, dev_stage,\nnon_release_version)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "platform.node()", "path": "library/platform#platform.node", "type": "Operating System", "text": "\nReturns the computer\u2019s network name (may not be fully qualified!). An empty\nstring is returned if the value cannot be determined.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "platform.platform()", "path": "library/platform#platform.platform", "type": "Operating System", "text": "\nReturns a single string identifying the underlying platform with as much\nuseful information as possible.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "platform.processor()", "path": "library/platform#platform.processor", "type": "Operating System", "text": "\nReturns the (real) processor name, e.g. `'amdk6'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "platform.python_branch()", "path": "library/platform#platform.python_branch", "type": "Operating System", "text": "\nReturns a string identifying the Python implementation SCM branch.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "platform.python_build()", "path": "library/platform#platform.python_build", "type": "Operating System", "text": "\nReturns a tuple `(buildno, builddate)` stating the Python build number and\ndate as strings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "platform.python_compiler()", "path": "library/platform#platform.python_compiler", "type": "Operating System", "text": "\nReturns a string identifying the compiler used for compiling Python.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "platform.python_implementation()", "path": "library/platform#platform.python_implementation", "type": "Operating System", "text": "\nReturns a string identifying the Python implementation. Possible return values\nare: \u2018CPython\u2019, \u2018IronPython\u2019, \u2018Jython\u2019, \u2018PyPy\u2019.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "platform.python_revision()", "path": "library/platform#platform.python_revision", "type": "Operating System", "text": "\nReturns a string identifying the Python implementation SCM revision.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "platform.python_version()", "path": "library/platform#platform.python_version", "type": "Operating System", "text": "\nReturns the Python version as string `'major.minor.patchlevel'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "platform.python_version_tuple()", "path": "library/platform#platform.python_version_tuple", "type": "Operating System", "text": "\nReturns the Python version as tuple `(major, minor, patchlevel)` of strings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "platform.release()", "path": "library/platform#platform.release", "type": "Operating System", "text": "\nReturns the system\u2019s release, e.g. `'2.2.0'` or `'NT'` An empty string is\nreturned if the value cannot be determined.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "platform.system()", "path": "library/platform#platform.system", "type": "Operating System", "text": "\nReturns the system/OS name, such as `'Linux'`, `'Darwin'`, `'Java'`,\n`'Windows'`. An empty string is returned if the value cannot be determined.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "platform.system_alias()", "path": "library/platform#platform.system_alias", "type": "Operating System", "text": "\nReturns `(system, release, version)` aliased to common marketing names used\nfor some systems. It also does some reordering of the information in some\ncases where it would otherwise cause confusion.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "platform.uname()", "path": "library/platform#platform.uname", "type": "Operating System", "text": "\nFairly portable uname interface. Returns a `namedtuple()` containing six\nattributes: `system`, `node`, `release`, `version`, `machine`, and\n`processor`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "platform.version()", "path": "library/platform#platform.version", "type": "Operating System", "text": "\nReturns the system\u2019s release version, e.g. `'#3 on degas'`. An empty string is\nreturned if the value cannot be determined.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "platform.win32_edition()", "path": "library/platform#platform.win32_edition", "type": "Operating System", "text": "\nReturns a string representing the current Windows edition. Possible values\ninclude but are not limited to `'Enterprise'`, `'IoTUAP'`, `'ServerStandard'`,\nand `'nanoserver'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "platform.win32_is_iot()", "path": "library/platform#platform.win32_is_iot", "type": "Operating System", "text": "\nReturn `True` if the Windows edition returned by `win32_edition()` is\nrecognized as an IoT edition.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "platform.win32_ver()", "path": "library/platform#platform.win32_ver", "type": "Operating System", "text": "\nGet additional version information from the Windows Registry and return a\ntuple `(release, version, csd, ptype)` referring to OS release, version\nnumber, CSD level (service pack) and OS type (multi/single processor).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "plistlib", "path": "library/plistlib", "type": "File Formats", "text": "\nSource code: Lib/plistlib.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "plistlib.dump()", "path": "library/plistlib#plistlib.dump", "type": "File Formats", "text": "\nWrite value to a plist file. Fp should be a writable, binary file object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "plistlib.dumps()", "path": "library/plistlib#plistlib.dumps", "type": "File Formats", "text": "\nReturn value as a plist-formatted bytes object. See the documentation for\n`dump()` for an explanation of the keyword arguments of this function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "plistlib.FMT_BINARY", "path": "library/plistlib#plistlib.FMT_BINARY", "type": "File Formats", "text": "\nThe binary format for plist files\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "plistlib.FMT_XML", "path": "library/plistlib#plistlib.FMT_XML", "type": "File Formats", "text": "\nThe XML format for plist files.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "plistlib.load()", "path": "library/plistlib#plistlib.load", "type": "File Formats", "text": "\nRead a plist file. fp should be a readable and binary file object. Return the\nunpacked root object (which usually is a dictionary).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "plistlib.loads()", "path": "library/plistlib#plistlib.loads", "type": "File Formats", "text": "\nLoad a plist from a bytes object. See `load()` for an explanation of the\nkeyword arguments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "plistlib.UID", "path": "library/plistlib#plistlib.UID", "type": "File Formats", "text": "\nWraps an `int`. This is used when reading or writing NSKeyedArchiver encoded\ndata, which contains UID (see PList manual).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Policies", "path": "library/asyncio-policy", "type": "Asynchronous I/O", "text": "\nAn event loop policy is a global per-process object that controls the\nmanagement of the event loop. Each event loop has a default policy, which can\nbe changed and customized using the policy API.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "poplib", "path": "library/poplib", "type": "Internet", "text": "\nSource code: Lib/poplib.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "poplib.error_proto", "path": "library/poplib#poplib.error_proto", "type": "Internet", "text": "\nException raised on any errors from this module (errors from `socket` module\nare not caught). The reason for the exception is passed to the constructor as\na string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "poplib.POP3", "path": "library/poplib#poplib.POP3", "type": "Internet", "text": "\nThis class implements the actual POP3 protocol. The connection is created when\nthe instance is initialized. If port is omitted, the standard POP3 port (110)\nis used. The optional timeout parameter specifies a timeout in seconds for the\nconnection attempt (if not specified, the global default timeout setting will\nbe used).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "poplib.POP3.apop()", "path": "library/poplib#poplib.POP3.apop", "type": "Internet", "text": "\nUse the more secure APOP authentication to log into the POP3 server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "poplib.POP3.capa()", "path": "library/poplib#poplib.POP3.capa", "type": "Internet", "text": "\nQuery the server\u2019s capabilities as specified in RFC 2449. Returns a dictionary\nin the form `{'name': ['param'...]}`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "poplib.POP3.dele()", "path": "library/poplib#poplib.POP3.dele", "type": "Internet", "text": "\nFlag message number which for deletion. On most servers deletions are not\nactually performed until QUIT (the major exception is Eudora QPOP, which\ndeliberately violates the RFCs by doing pending deletes on any disconnect).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "poplib.POP3.getwelcome()", "path": "library/poplib#poplib.POP3.getwelcome", "type": "Internet", "text": "\nReturns the greeting string sent by the POP3 server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "poplib.POP3.list()", "path": "library/poplib#poplib.POP3.list", "type": "Internet", "text": "\nRequest message list, result is in the form `(response, ['mesg_num octets',\n...], octets)`. If which is set, it is the message to list.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "poplib.POP3.noop()", "path": "library/poplib#poplib.POP3.noop", "type": "Internet", "text": "\nDo nothing. Might be used as a keep-alive.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "poplib.POP3.pass_()", "path": "library/poplib#poplib.POP3.pass_", "type": "Internet", "text": "\nSend password, response includes message count and mailbox size. Note: the\nmailbox on the server is locked until `quit()` is called.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "poplib.POP3.quit()", "path": "library/poplib#poplib.POP3.quit", "type": "Internet", "text": "\nSignoff: commit changes, unlock mailbox, drop connection.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "poplib.POP3.retr()", "path": "library/poplib#poplib.POP3.retr", "type": "Internet", "text": "\nRetrieve whole message number which, and set its seen flag. Result is in form\n`(response, ['line', ...], octets)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "poplib.POP3.rpop()", "path": "library/poplib#poplib.POP3.rpop", "type": "Internet", "text": "\nUse RPOP authentication (similar to UNIX r-commands) to log into POP3 server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "poplib.POP3.rset()", "path": "library/poplib#poplib.POP3.rset", "type": "Internet", "text": "\nRemove any deletion marks for the mailbox.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "poplib.POP3.set_debuglevel()", "path": "library/poplib#poplib.POP3.set_debuglevel", "type": "Internet", "text": "\nSet the instance\u2019s debugging level. This controls the amount of debugging\noutput printed. The default, `0`, produces no debugging output. A value of `1`\nproduces a moderate amount of debugging output, generally a single line per\nrequest. A value of `2` or higher produces the maximum amount of debugging\noutput, logging each line sent and received on the control connection.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "poplib.POP3.stat()", "path": "library/poplib#poplib.POP3.stat", "type": "Internet", "text": "\nGet mailbox status. The result is a tuple of 2 integers: `(message count,\nmailbox size)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "poplib.POP3.stls()", "path": "library/poplib#poplib.POP3.stls", "type": "Internet", "text": "\nStart a TLS session on the active connection as specified in RFC 2595. This is\nonly allowed before user authentication\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "poplib.POP3.top()", "path": "library/poplib#poplib.POP3.top", "type": "Internet", "text": "\nRetrieves the message header plus howmuch lines of the message after the\nheader of message number which. Result is in form `(response, ['line', ...],\noctets)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "poplib.POP3.uidl()", "path": "library/poplib#poplib.POP3.uidl", "type": "Internet", "text": "\nReturn message digest (unique id) list. If which is specified, result contains\nthe unique id for that message in the form `'response mesgnum uid`, otherwise\nresult is list `(response, ['mesgnum uid', ...], octets)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "poplib.POP3.user()", "path": "library/poplib#poplib.POP3.user", "type": "Internet", "text": "\nSend user command, response should indicate that a password is required.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "poplib.POP3.utf8()", "path": "library/poplib#poplib.POP3.utf8", "type": "Internet", "text": "\nTry to switch to UTF-8 mode. Returns the server response if successful, raises\n`error_proto` if not. Specified in RFC 6856.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "poplib.POP3_SSL", "path": "library/poplib#poplib.POP3_SSL", "type": "Internet", "text": "\nThis is a subclass of `POP3` that connects to the server over an SSL encrypted\nsocket. If port is not specified, 995, the standard POP3-over-SSL port is\nused. timeout works as in the `POP3` constructor. context is an optional\n`ssl.SSLContext` object which allows bundling SSL configuration options,\ncertificates and private keys into a single (potentially long-lived)\nstructure. Please read Security considerations for best practices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "posix", "path": "library/posix", "type": "Unix", "text": "\nThis module provides access to operating system functionality that is\nstandardized by the C Standard and the POSIX standard (a thinly disguised Unix\ninterface).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "posix.environ", "path": "library/posix#posix.environ", "type": "Unix", "text": "\nA dictionary representing the string environment at the time the interpreter\nwas started. Keys and values are bytes on Unix and str on Windows. For\nexample, `environ[b'HOME']` (`environ['HOME']` on Windows) is the pathname of\nyour home directory, equivalent to `getenv(\"HOME\")` in C.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pow()", "path": "library/functions#pow", "type": "Built-in Functions", "text": "\nReturn base to the power exp; if mod is present, return base to the power exp,\nmodulo mod (computed more efficiently than `pow(base, exp) % mod`). The two-\nargument form `pow(base, exp)` is equivalent to using the power operator:\n`base**exp`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pprint", "path": "library/pprint", "type": "Data Types", "text": "\nSource code: Lib/pprint.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pprint.isreadable()", "path": "library/pprint#pprint.isreadable", "type": "Data Types", "text": "\nDetermine if the formatted representation of object is \u201creadable\u201d, or can be\nused to reconstruct the value using `eval()`. This always returns `False` for\nrecursive objects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pprint.isrecursive()", "path": "library/pprint#pprint.isrecursive", "type": "Data Types", "text": "\nDetermine if object requires a recursive representation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pprint.pformat()", "path": "library/pprint#pprint.pformat", "type": "Data Types", "text": "\nReturn the formatted representation of object as a string. indent, width,\ndepth, compact and sort_dicts will be passed to the `PrettyPrinter`\nconstructor as formatting parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pprint.pp()", "path": "library/pprint#pprint.pp", "type": "Data Types", "text": "\nPrints the formatted representation of object followed by a newline. If\nsort_dicts is false (the default), dictionaries will be displayed with their\nkeys in insertion order, otherwise the dict keys will be sorted. args and\nkwargs will be passed to `pprint()` as formatting parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pprint.pprint()", "path": "library/pprint#pprint.pprint", "type": "Data Types", "text": "\nPrints the formatted representation of object on stream, followed by a\nnewline. If stream is `None`, `sys.stdout` is used. This may be used in the\ninteractive interpreter instead of the `print()` function for inspecting\nvalues (you can even reassign `print = pprint.pprint` for use within a scope).\nindent, width, depth, compact and sort_dicts will be passed to the\n`PrettyPrinter` constructor as formatting parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pprint.PrettyPrinter", "path": "library/pprint#pprint.PrettyPrinter", "type": "Data Types", "text": "\nConstruct a `PrettyPrinter` instance. This constructor understands several\nkeyword parameters. An output stream may be set using the stream keyword; the\nonly method used on the stream object is the file protocol\u2019s `write()` method.\nIf not specified, the `PrettyPrinter` adopts `sys.stdout`. The amount of\nindentation added for each recursive level is specified by indent; the default\nis one. Other values can cause output to look a little odd, but can make\nnesting easier to spot. The number of levels which may be printed is\ncontrolled by depth; if the data structure being printed is too deep, the next\ncontained level is replaced by `...`. By default, there is no constraint on\nthe depth of the objects being formatted. The desired output width is\nconstrained using the width parameter; the default is 80 characters. If a\nstructure cannot be formatted within the constrained width, a best effort will\nbe made. If compact is false (the default) each item of a long sequence will\nbe formatted on a separate line. If compact is true, as many items as will fit\nwithin the width will be formatted on each output line. If sort_dicts is true\n(the default), dictionaries will be formatted with their keys sorted,\notherwise they will display in insertion order.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pprint.PrettyPrinter.format()", "path": "library/pprint#pprint.PrettyPrinter.format", "type": "Data Types", "text": "\nReturns three values: the formatted version of object as a string, a flag\nindicating whether the result is readable, and a flag indicating whether\nrecursion was detected. The first argument is the object to be presented. The\nsecond is a dictionary which contains the `id()` of objects that are part of\nthe current presentation context (direct and indirect containers for object\nthat are affecting the presentation) as the keys; if an object needs to be\npresented which is already represented in context, the third return value\nshould be `True`. Recursive calls to the `format()` method should add\nadditional entries for containers to this dictionary. The third argument,\nmaxlevels, gives the requested limit to recursion; this will be `0` if there\nis no requested limit. This argument should be passed unmodified to recursive\ncalls. The fourth argument, level, gives the current level; recursive calls\nshould be passed a value less than that of the current call.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pprint.PrettyPrinter.isreadable()", "path": "library/pprint#pprint.PrettyPrinter.isreadable", "type": "Data Types", "text": "\nDetermine if the formatted representation of the object is \u201creadable,\u201d or can\nbe used to reconstruct the value using `eval()`. Note that this returns\n`False` for recursive objects. If the depth parameter of the `PrettyPrinter`\nis set and the object is deeper than allowed, this returns `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pprint.PrettyPrinter.isrecursive()", "path": "library/pprint#pprint.PrettyPrinter.isrecursive", "type": "Data Types", "text": "\nDetermine if the object requires a recursive representation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pprint.PrettyPrinter.pformat()", "path": "library/pprint#pprint.PrettyPrinter.pformat", "type": "Data Types", "text": "\nReturn the formatted representation of object. This takes into account the\noptions passed to the `PrettyPrinter` constructor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pprint.PrettyPrinter.pprint()", "path": "library/pprint#pprint.PrettyPrinter.pprint", "type": "Data Types", "text": "\nPrint the formatted representation of object on the configured stream,\nfollowed by a newline.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pprint.saferepr()", "path": "library/pprint#pprint.saferepr", "type": "Data Types", "text": "\nReturn a string representation of object, protected against recursive data\nstructures. If the representation of object exposes a recursive entry, the\nrecursive reference will be represented as `<Recursion on typename with\nid=number>`. The representation is not otherwise formatted.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "print()", "path": "library/functions#print", "type": "Built-in Functions", "text": "\nPrint objects to the text stream file, separated by sep and followed by end.\nsep, end, file and flush, if present, must be given as keyword arguments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ProcessLookupError", "path": "library/exceptions#ProcessLookupError", "type": "Built-in Exceptions", "text": "\nRaised when a given process doesn\u2019t exist. Corresponds to `errno` `ESRCH`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "profile.Profile", "path": "library/profile#profile.Profile", "type": "Debugging & Profiling", "text": "\nThis class is normally only used if more precise control over profiling is\nneeded than what the `cProfile.run()` function provides.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "profile.Profile.create_stats()", "path": "library/profile#profile.Profile.create_stats", "type": "Debugging & Profiling", "text": "\nStop collecting profiling data and record the results internally as the\ncurrent profile.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "profile.Profile.disable()", "path": "library/profile#profile.Profile.disable", "type": "Debugging & Profiling", "text": "\nStop collecting profiling data. Only in `cProfile`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "profile.Profile.dump_stats()", "path": "library/profile#profile.Profile.dump_stats", "type": "Debugging & Profiling", "text": "\nWrite the results of the current profile to filename.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "profile.Profile.enable()", "path": "library/profile#profile.Profile.enable", "type": "Debugging & Profiling", "text": "\nStart collecting profiling data. Only in `cProfile`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "profile.Profile.print_stats()", "path": "library/profile#profile.Profile.print_stats", "type": "Debugging & Profiling", "text": "\nCreate a `Stats` object based on the current profile and print the results to\nstdout.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "profile.Profile.run()", "path": "library/profile#profile.Profile.run", "type": "Debugging & Profiling", "text": "\nProfile the cmd via `exec()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "profile.Profile.runcall()", "path": "library/profile#profile.Profile.runcall", "type": "Debugging & Profiling", "text": "\nProfile `func(*args, **kwargs)`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "profile.Profile.runctx()", "path": "library/profile#profile.Profile.runctx", "type": "Debugging & Profiling", "text": "\nProfile the cmd via `exec()` with the specified global and local environment.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "profile.run()", "path": "library/profile#profile.run", "type": "Debugging & Profiling", "text": "\nThis function takes a single argument that can be passed to the `exec()`\nfunction, and an optional file name. In all cases this routine executes:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "profile.runctx()", "path": "library/profile#profile.runctx", "type": "Debugging & Profiling", "text": "\nThis function is similar to `run()`, with added arguments to supply the\nglobals and locals dictionaries for the command string. This routine executes:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "property", "path": "library/functions#property", "type": "Built-in Functions", "text": "\nReturn a property attribute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pstats.Stats", "path": "library/profile#pstats.Stats", "type": "Debugging & Profiling", "text": "\nThis class constructor creates an instance of a \u201cstatistics object\u201d from a\nfilename (or list of filenames) or from a `Profile` instance. Output will be\nprinted to the stream specified by stream.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pstats.Stats.add()", "path": "library/profile#pstats.Stats.add", "type": "Debugging & Profiling", "text": "\nThis method of the `Stats` class accumulates additional profiling information\ninto the current profiling object. Its arguments should refer to filenames\ncreated by the corresponding version of `profile.run()` or `cProfile.run()`.\nStatistics for identically named (re: file, line, name) functions are\nautomatically accumulated into single function statistics.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pstats.Stats.dump_stats()", "path": "library/profile#pstats.Stats.dump_stats", "type": "Debugging & Profiling", "text": "\nSave the data loaded into the `Stats` object to a file named filename. The\nfile is created if it does not exist, and is overwritten if it already exists.\nThis is equivalent to the method of the same name on the `profile.Profile` and\n`cProfile.Profile` classes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pstats.Stats.get_stats_profile()", "path": "library/profile#pstats.Stats.get_stats_profile", "type": "Debugging & Profiling", "text": "\nThis method returns an instance of StatsProfile, which contains a mapping of\nfunction names to instances of FunctionProfile. Each FunctionProfile instance\nholds information related to the function\u2019s profile such as how long the\nfunction took to run, how many times it was called, etc\u2026\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pstats.Stats.print_callees()", "path": "library/profile#pstats.Stats.print_callees", "type": "Debugging & Profiling", "text": "\nThis method for the `Stats` class prints a list of all function that were\ncalled by the indicated function. Aside from this reversal of direction of\ncalls (re: called vs was called by), the arguments and ordering are identical\nto the `print_callers()` method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pstats.Stats.print_callers()", "path": "library/profile#pstats.Stats.print_callers", "type": "Debugging & Profiling", "text": "\nThis method for the `Stats` class prints a list of all functions that called\neach function in the profiled database. The ordering is identical to that\nprovided by `print_stats()`, and the definition of the restricting argument is\nalso identical. Each caller is reported on its own line. The format differs\nslightly depending on the profiler that produced the stats:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pstats.Stats.print_stats()", "path": "library/profile#pstats.Stats.print_stats", "type": "Debugging & Profiling", "text": "\nThis method for the `Stats` class prints out a report as described in the\n`profile.run()` definition.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pstats.Stats.reverse_order()", "path": "library/profile#pstats.Stats.reverse_order", "type": "Debugging & Profiling", "text": "\nThis method for the `Stats` class reverses the ordering of the basic list\nwithin the object. Note that by default ascending vs descending order is\nproperly selected based on the sort key of choice.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pstats.Stats.sort_stats()", "path": "library/profile#pstats.Stats.sort_stats", "type": "Debugging & Profiling", "text": "\nThis method modifies the `Stats` object by sorting it according to the\nsupplied criteria. The argument can be either a string or a SortKey enum\nidentifying the basis of a sort (example: `'time'`, `'name'`, `SortKey.TIME`\nor `SortKey.NAME`). The SortKey enums argument have advantage over the string\nargument in that it is more robust and less error prone.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pstats.Stats.strip_dirs()", "path": "library/profile#pstats.Stats.strip_dirs", "type": "Debugging & Profiling", "text": "\nThis method for the `Stats` class removes all leading path information from\nfile names. It is very useful in reducing the size of the printout to fit\nwithin (close to) 80 columns. This method modifies the object, and the\nstripped information is lost. After performing a strip operation, the object\nis considered to have its entries in a \u201crandom\u201d order, as it was just after\nobject initialization and loading. If `strip_dirs()` causes two function names\nto be indistinguishable (they are on the same line of the same filename, and\nhave the same function name), then the statistics for these two entries are\naccumulated into a single entry.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pty", "path": "library/pty", "type": "Unix", "text": "\nSource code: Lib/pty.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pty.fork()", "path": "library/pty#pty.fork", "type": "Unix", "text": "\nFork. Connect the child\u2019s controlling terminal to a pseudo-terminal. Return\nvalue is `(pid, fd)`. Note that the child gets pid 0, and the fd is invalid.\nThe parent\u2019s return value is the pid of the child, and fd is a file descriptor\nconnected to the child\u2019s controlling terminal (and also to the child\u2019s\nstandard input and output).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pty.openpty()", "path": "library/pty#pty.openpty", "type": "Unix", "text": "\nOpen a new pseudo-terminal pair, using `os.openpty()` if possible, or\nemulation code for generic Unix systems. Return a pair of file descriptors\n`(master, slave)`, for the master and the slave end, respectively.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pty.spawn()", "path": "library/pty#pty.spawn", "type": "Unix", "text": "\nSpawn a process, and connect its controlling terminal with the current\nprocess\u2019s standard io. This is often used to baffle programs which insist on\nreading from the controlling terminal. It is expected that the process spawned\nbehind the pty will eventually terminate, and when it does spawn will return.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pwd", "path": "library/pwd", "type": "Unix", "text": "\nThis module provides access to the Unix user account and password database. It\nis available on all Unix versions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pwd.getpwall()", "path": "library/pwd#pwd.getpwall", "type": "Unix", "text": "\nReturn a list of all available password database entries, in arbitrary order.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pwd.getpwnam()", "path": "library/pwd#pwd.getpwnam", "type": "Unix", "text": "\nReturn the password database entry for the given user name.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pwd.getpwuid()", "path": "library/pwd#pwd.getpwuid", "type": "Unix", "text": "\nReturn the password database entry for the given numeric user ID.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pyclbr", "path": "library/pyclbr", "type": "Language", "text": "\nSource code: Lib/pyclbr.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pyclbr.Class.children", "path": "library/pyclbr#pyclbr.Class.children", "type": "Language", "text": "\nA dictionary mapping names to descriptors for nested functions and classes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pyclbr.Class.file", "path": "library/pyclbr#pyclbr.Class.file", "type": "Language", "text": "\nName of the file in which the class is defined.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pyclbr.Class.lineno", "path": "library/pyclbr#pyclbr.Class.lineno", "type": "Language", "text": "\nThe line number in the file where the definition starts.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pyclbr.Class.methods", "path": "library/pyclbr#pyclbr.Class.methods", "type": "Language", "text": "\nA dictionary mapping method names to line numbers. This can be derived from\nthe newer children dictionary, but remains for back-compatibility.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pyclbr.Class.module", "path": "library/pyclbr#pyclbr.Class.module", "type": "Language", "text": "\nThe name of the module defining the class described.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pyclbr.Class.name", "path": "library/pyclbr#pyclbr.Class.name", "type": "Language", "text": "\nThe name of the class.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pyclbr.Class.parent", "path": "library/pyclbr#pyclbr.Class.parent", "type": "Language", "text": "\nFor top-level classes, None. For nested classes, the parent.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pyclbr.Class.super", "path": "library/pyclbr#pyclbr.Class.super", "type": "Language", "text": "\nA list of `Class` objects which describe the immediate base classes of the\nclass being described. Classes which are named as superclasses but which are\nnot discoverable by `readmodule_ex()` are listed as a string with the class\nname instead of as `Class` objects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pyclbr.Function.children", "path": "library/pyclbr#pyclbr.Function.children", "type": "Language", "text": "\nA dictionary mapping names to descriptors for nested functions and classes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pyclbr.Function.file", "path": "library/pyclbr#pyclbr.Function.file", "type": "Language", "text": "\nName of the file in which the function is defined.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pyclbr.Function.lineno", "path": "library/pyclbr#pyclbr.Function.lineno", "type": "Language", "text": "\nThe line number in the file where the definition starts.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pyclbr.Function.module", "path": "library/pyclbr#pyclbr.Function.module", "type": "Language", "text": "\nThe name of the module defining the function described.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pyclbr.Function.name", "path": "library/pyclbr#pyclbr.Function.name", "type": "Language", "text": "\nThe name of the function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pyclbr.Function.parent", "path": "library/pyclbr#pyclbr.Function.parent", "type": "Language", "text": "\nFor top-level functions, None. For nested functions, the parent.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pyclbr.readmodule()", "path": "library/pyclbr#pyclbr.readmodule", "type": "Language", "text": "\nReturn a dictionary mapping module-level class names to class descriptors. If\npossible, descriptors for imported base classes are included. Parameter module\nis a string with the name of the module to read; it may be the name of a\nmodule within a package. If given, path is a sequence of directory paths\nprepended to `sys.path`, which is used to locate the module source code.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pyclbr.readmodule_ex()", "path": "library/pyclbr#pyclbr.readmodule_ex", "type": "Language", "text": "\nReturn a dictionary-based tree containing a function or class descriptors for\neach function and class defined in the module with a `def` or `class`\nstatement. The returned dictionary maps module-level function and class names\nto their descriptors. Nested objects are entered into the children dictionary\nof their parent. As with readmodule, module names the module to be read and\npath is prepended to sys.path. If the module being read is a package, the\nreturned dictionary has a key `'__path__'` whose value is a list containing\nthe package search path.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pydoc", "path": "library/pydoc", "type": "Development Tools", "text": "\nSource code: Lib/pydoc.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Python Development Mode", "path": "library/devmode", "type": "Development Tools", "text": "\nNew in version 3.7.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "py_compile", "path": "library/py_compile", "type": "Language", "text": "\nSource code: Lib/py_compile.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "py_compile.compile()", "path": "library/py_compile#py_compile.compile", "type": "Language", "text": "\nCompile a source file to byte-code and write out the byte-code cache file. The\nsource code is loaded from the file named file. The byte-code is written to\ncfile, which defaults to the PEP 3147/PEP 488 path, ending in `.pyc`. For\nexample, if file is `/foo/bar/baz.py` cfile will default to\n`/foo/bar/__pycache__/baz.cpython-32.pyc` for Python 3.2. If dfile is\nspecified, it is used as the name of the source file in error messages instead\nof file. If doraise is true, a `PyCompileError` is raised when an error is\nencountered while compiling file. If doraise is false (the default), an error\nstring is written to `sys.stderr`, but no exception is raised. This function\nreturns the path to byte-compiled file, i.e. whatever cfile value was used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "py_compile.main()", "path": "library/py_compile#py_compile.main", "type": "Language", "text": "\nCompile several source files. The files named in args (or on the command line,\nif args is `None`) are compiled and the resulting byte-code is cached in the\nnormal manner. This function does not search a directory structure to locate\nsource files; it only compiles files named explicitly. If `'-'` is the only\nparameter in args, the list of files is taken from standard input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "py_compile.PycInvalidationMode", "path": "library/py_compile#py_compile.PycInvalidationMode", "type": "Language", "text": "\nA enumeration of possible methods the interpreter can use to determine whether\na bytecode file is up to date with a source file. The `.pyc` file indicates\nthe desired invalidation mode in its header. See Cached bytecode invalidation\nfor more information on how Python invalidates `.pyc` files at runtime.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "py_compile.PycInvalidationMode.CHECKED_HASH", "path": "library/py_compile#py_compile.PycInvalidationMode.CHECKED_HASH", "type": "Language", "text": "\nThe `.pyc` file includes a hash of the source file content, which Python will\ncompare against the source at runtime to determine if the `.pyc` file needs to\nbe regenerated.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "py_compile.PycInvalidationMode.TIMESTAMP", "path": "library/py_compile#py_compile.PycInvalidationMode.TIMESTAMP", "type": "Language", "text": "\nThe `.pyc` file includes the timestamp and size of the source file, which\nPython will compare against the metadata of the source file at runtime to\ndetermine if the `.pyc` file needs to be regenerated.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "py_compile.PycInvalidationMode.UNCHECKED_HASH", "path": "library/py_compile#py_compile.PycInvalidationMode.UNCHECKED_HASH", "type": "Language", "text": "\nLike `CHECKED_HASH`, the `.pyc` file includes a hash of the source file\ncontent. However, Python will at runtime assume the `.pyc` file is up to date\nand not validate the `.pyc` against the source file at all.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "py_compile.PyCompileError", "path": "library/py_compile#py_compile.PyCompileError", "type": "Language", "text": "\nException raised when an error occurs while attempting to compile the file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "queue", "path": "library/queue", "type": "Concurrent Execution", "text": "\nSource code: Lib/queue.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "queue.Empty", "path": "library/queue#queue.Empty", "type": "Concurrent Execution", "text": "\nException raised when non-blocking `get()` (or `get_nowait()`) is called on a\n`Queue` object which is empty.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "queue.Full", "path": "library/queue#queue.Full", "type": "Concurrent Execution", "text": "\nException raised when non-blocking `put()` (or `put_nowait()`) is called on a\n`Queue` object which is full.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "queue.LifoQueue", "path": "library/queue#queue.LifoQueue", "type": "Concurrent Execution", "text": "\nConstructor for a LIFO queue. maxsize is an integer that sets the upperbound\nlimit on the number of items that can be placed in the queue. Insertion will\nblock once this size has been reached, until queue items are consumed. If\nmaxsize is less than or equal to zero, the queue size is infinite.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "queue.PriorityQueue", "path": "library/queue#queue.PriorityQueue", "type": "Concurrent Execution", "text": "\nConstructor for a priority queue. maxsize is an integer that sets the\nupperbound limit on the number of items that can be placed in the queue.\nInsertion will block once this size has been reached, until queue items are\nconsumed. If maxsize is less than or equal to zero, the queue size is\ninfinite.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "queue.Queue", "path": "library/queue#queue.Queue", "type": "Concurrent Execution", "text": "\nConstructor for a FIFO queue. maxsize is an integer that sets the upperbound\nlimit on the number of items that can be placed in the queue. Insertion will\nblock once this size has been reached, until queue items are consumed. If\nmaxsize is less than or equal to zero, the queue size is infinite.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "queue.Queue.empty()", "path": "library/queue#queue.Queue.empty", "type": "Concurrent Execution", "text": "\nReturn `True` if the queue is empty, `False` otherwise. If empty() returns\n`True` it doesn\u2019t guarantee that a subsequent call to put() will not block.\nSimilarly, if empty() returns `False` it doesn\u2019t guarantee that a subsequent\ncall to get() will not block.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "queue.Queue.full()", "path": "library/queue#queue.Queue.full", "type": "Concurrent Execution", "text": "\nReturn `True` if the queue is full, `False` otherwise. If full() returns\n`True` it doesn\u2019t guarantee that a subsequent call to get() will not block.\nSimilarly, if full() returns `False` it doesn\u2019t guarantee that a subsequent\ncall to put() will not block.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "queue.Queue.get()", "path": "library/queue#queue.Queue.get", "type": "Concurrent Execution", "text": "\nRemove and return an item from the queue. If optional args block is true and\ntimeout is `None` (the default), block if necessary until an item is\navailable. If timeout is a positive number, it blocks at most timeout seconds\nand raises the `Empty` exception if no item was available within that time.\nOtherwise (block is false), return an item if one is immediately available,\nelse raise the `Empty` exception (timeout is ignored in that case).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "queue.Queue.get_nowait()", "path": "library/queue#queue.Queue.get_nowait", "type": "Concurrent Execution", "text": "\nEquivalent to `get(False)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "queue.Queue.join()", "path": "library/queue#queue.Queue.join", "type": "Concurrent Execution", "text": "\nBlocks until all items in the queue have been gotten and processed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "queue.Queue.put()", "path": "library/queue#queue.Queue.put", "type": "Concurrent Execution", "text": "\nPut item into the queue. If optional args block is true and timeout is `None`\n(the default), block if necessary until a free slot is available. If timeout\nis a positive number, it blocks at most timeout seconds and raises the `Full`\nexception if no free slot was available within that time. Otherwise (block is\nfalse), put an item on the queue if a free slot is immediately available, else\nraise the `Full` exception (timeout is ignored in that case).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "queue.Queue.put_nowait()", "path": "library/queue#queue.Queue.put_nowait", "type": "Concurrent Execution", "text": "\nEquivalent to `put(item, False)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "queue.Queue.qsize()", "path": "library/queue#queue.Queue.qsize", "type": "Concurrent Execution", "text": "\nReturn the approximate size of the queue. Note, qsize() > 0 doesn\u2019t guarantee\nthat a subsequent get() will not block, nor will qsize() < maxsize guarantee\nthat put() will not block.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "queue.Queue.task_done()", "path": "library/queue#queue.Queue.task_done", "type": "Concurrent Execution", "text": "\nIndicate that a formerly enqueued task is complete. Used by queue consumer\nthreads. For each `get()` used to fetch a task, a subsequent call to\n`task_done()` tells the queue that the processing on the task is complete.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "queue.SimpleQueue", "path": "library/queue#queue.SimpleQueue", "type": "Concurrent Execution", "text": "\nConstructor for an unbounded FIFO queue. Simple queues lack advanced\nfunctionality such as task tracking.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "queue.SimpleQueue.empty()", "path": "library/queue#queue.SimpleQueue.empty", "type": "Concurrent Execution", "text": "\nReturn `True` if the queue is empty, `False` otherwise. If empty() returns\n`False` it doesn\u2019t guarantee that a subsequent call to get() will not block.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "queue.SimpleQueue.get()", "path": "library/queue#queue.SimpleQueue.get", "type": "Concurrent Execution", "text": "\nRemove and return an item from the queue. If optional args block is true and\ntimeout is `None` (the default), block if necessary until an item is\navailable. If timeout is a positive number, it blocks at most timeout seconds\nand raises the `Empty` exception if no item was available within that time.\nOtherwise (block is false), return an item if one is immediately available,\nelse raise the `Empty` exception (timeout is ignored in that case).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "queue.SimpleQueue.get_nowait()", "path": "library/queue#queue.SimpleQueue.get_nowait", "type": "Concurrent Execution", "text": "\nEquivalent to `get(False)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "queue.SimpleQueue.put()", "path": "library/queue#queue.SimpleQueue.put", "type": "Concurrent Execution", "text": "\nPut item into the queue. The method never blocks and always succeeds (except\nfor potential low-level errors such as failure to allocate memory). The\noptional args block and timeout are ignored and only provided for\ncompatibility with `Queue.put()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "queue.SimpleQueue.put_nowait()", "path": "library/queue#queue.SimpleQueue.put_nowait", "type": "Concurrent Execution", "text": "\nEquivalent to `put(item)`, provided for compatibility with\n`Queue.put_nowait()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "queue.SimpleQueue.qsize()", "path": "library/queue#queue.SimpleQueue.qsize", "type": "Concurrent Execution", "text": "\nReturn the approximate size of the queue. Note, qsize() > 0 doesn\u2019t guarantee\nthat a subsequent get() will not block.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Queues", "path": "library/asyncio-queue", "type": "Asynchronous I/O", "text": "\nSource code: Lib/asyncio/queues.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "quit", "path": "library/constants#quit", "type": "Built-in Constants", "text": "\nObjects that when printed, print a message like \u201cUse quit() or Ctrl-D (i.e.\nEOF) to exit\u201d, and when called, raise `SystemExit` with the specified exit\ncode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "quopri", "path": "library/quopri", "type": "Internet Data", "text": "\nSource code: Lib/quopri.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "quopri.decode()", "path": "library/quopri#quopri.decode", "type": "Internet Data", "text": "\nDecode the contents of the input file and write the resulting decoded binary\ndata to the output file. input and output must be binary file objects. If the\noptional argument header is present and true, underscore will be decoded as\nspace. This is used to decode \u201cQ\u201d-encoded headers as described in RFC 1522:\n\u201cMIME (Multipurpose Internet Mail Extensions) Part Two: Message Header\nExtensions for Non-ASCII Text\u201d.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "quopri.decodestring()", "path": "library/quopri#quopri.decodestring", "type": "Internet Data", "text": "\nLike `decode()`, except that it accepts a source `bytes` and returns the\ncorresponding decoded `bytes`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "quopri.encode()", "path": "library/quopri#quopri.encode", "type": "Internet Data", "text": "\nEncode the contents of the input file and write the resulting quoted-printable\ndata to the output file. input and output must be binary file objects.\nquotetabs, a non-optional flag which controls whether to encode embedded\nspaces and tabs; when true it encodes such embedded whitespace, and when false\nit leaves them unencoded. Note that spaces and tabs appearing at the end of\nlines are always encoded, as per RFC 1521. header is a flag which controls if\nspaces are encoded as underscores as per RFC 1522.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "quopri.encodestring()", "path": "library/quopri#quopri.encodestring", "type": "Internet Data", "text": "\nLike `encode()`, except that it accepts a source `bytes` and returns the\ncorresponding encoded `bytes`. By default, it sends a `False` value to\nquotetabs parameter of the `encode()` function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "random", "path": "library/random", "type": "Numeric & Mathematical", "text": "\nSource code: Lib/random.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "random.betavariate()", "path": "library/random#random.betavariate", "type": "Numeric & Mathematical", "text": "\nBeta distribution. Conditions on the parameters are `alpha > 0` and `beta >\n0`. Returned values range between 0 and 1.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "random.choice()", "path": "library/random#random.choice", "type": "Numeric & Mathematical", "text": "\nReturn a random element from the non-empty sequence seq. If seq is empty,\nraises `IndexError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "random.choices()", "path": "library/random#random.choices", "type": "Numeric & Mathematical", "text": "\nReturn a k sized list of elements chosen from the population with replacement.\nIf the population is empty, raises `IndexError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "random.expovariate()", "path": "library/random#random.expovariate", "type": "Numeric & Mathematical", "text": "\nExponential distribution. lambd is 1.0 divided by the desired mean. It should\nbe nonzero. (The parameter would be called \u201clambda\u201d, but that is a reserved\nword in Python.) Returned values range from 0 to positive infinity if lambd is\npositive, and from negative infinity to 0 if lambd is negative.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "random.gammavariate()", "path": "library/random#random.gammavariate", "type": "Numeric & Mathematical", "text": "\nGamma distribution. (Not the gamma function!) Conditions on the parameters are\n`alpha > 0` and `beta > 0`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "random.gauss()", "path": "library/random#random.gauss", "type": "Numeric & Mathematical", "text": "\nGaussian distribution. mu is the mean, and sigma is the standard deviation.\nThis is slightly faster than the `normalvariate()` function defined below.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "random.getrandbits()", "path": "library/random#random.getrandbits", "type": "Numeric & Mathematical", "text": "\nReturns a non-negative Python integer with k random bits. This method is\nsupplied with the MersenneTwister generator and some other generators may also\nprovide it as an optional part of the API. When available, `getrandbits()`\nenables `randrange()` to handle arbitrarily large ranges.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "random.getstate()", "path": "library/random#random.getstate", "type": "Numeric & Mathematical", "text": "\nReturn an object capturing the current internal state of the generator. This\nobject can be passed to `setstate()` to restore the state.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "random.lognormvariate()", "path": "library/random#random.lognormvariate", "type": "Numeric & Mathematical", "text": "\nLog normal distribution. If you take the natural logarithm of this\ndistribution, you\u2019ll get a normal distribution with mean mu and standard\ndeviation sigma. mu can have any value, and sigma must be greater than zero.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "random.normalvariate()", "path": "library/random#random.normalvariate", "type": "Numeric & Mathematical", "text": "\nNormal distribution. mu is the mean, and sigma is the standard deviation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "random.paretovariate()", "path": "library/random#random.paretovariate", "type": "Numeric & Mathematical", "text": "\nPareto distribution. alpha is the shape parameter.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "random.randbytes()", "path": "library/random#random.randbytes", "type": "Numeric & Mathematical", "text": "\nGenerate n random bytes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "random.randint()", "path": "library/random#random.randint", "type": "Numeric & Mathematical", "text": "\nReturn a random integer N such that `a <= N <= b`. Alias for `randrange(a,\nb+1)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "random.Random", "path": "library/random#random.Random", "type": "Numeric & Mathematical", "text": "\nClass that implements the default pseudo-random number generator used by the\n`random` module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "random.random()", "path": "library/random#random.random", "type": "Numeric & Mathematical", "text": "\nReturn the next random floating point number in the range [0.0, 1.0).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "random.randrange()", "path": "library/random#random.randrange", "type": "Numeric & Mathematical", "text": "\nReturn a randomly selected element from `range(start, stop, step)`. This is\nequivalent to `choice(range(start, stop, step))`, but doesn\u2019t actually build a\nrange object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "random.sample()", "path": "library/random#random.sample", "type": "Numeric & Mathematical", "text": "\nReturn a k length list of unique elements chosen from the population sequence\nor set. Used for random sampling without replacement.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "random.seed()", "path": "library/random#random.seed", "type": "Numeric & Mathematical", "text": "\nInitialize the random number generator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "random.setstate()", "path": "library/random#random.setstate", "type": "Numeric & Mathematical", "text": "\nstate should have been obtained from a previous call to `getstate()`, and\n`setstate()` restores the internal state of the generator to what it was at\nthe time `getstate()` was called.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "random.shuffle()", "path": "library/random#random.shuffle", "type": "Numeric & Mathematical", "text": "\nShuffle the sequence x in place.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "random.SystemRandom", "path": "library/random#random.SystemRandom", "type": "Numeric & Mathematical", "text": "\nClass that uses the `os.urandom()` function for generating random numbers from\nsources provided by the operating system. Not available on all systems. Does\nnot rely on software state, and sequences are not reproducible. Accordingly,\nthe `seed()` method has no effect and is ignored. The `getstate()` and\n`setstate()` methods raise `NotImplementedError` if called.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "random.triangular()", "path": "library/random#random.triangular", "type": "Numeric & Mathematical", "text": "\nReturn a random floating point number N such that `low <= N <= high` and with\nthe specified mode between those bounds. The low and high bounds default to\nzero and one. The mode argument defaults to the midpoint between the bounds,\ngiving a symmetric distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "random.uniform()", "path": "library/random#random.uniform", "type": "Numeric & Mathematical", "text": "\nReturn a random floating point number N such that `a <= N <= b` for `a <= b`\nand `b <= N <= a` for `b < a`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "random.vonmisesvariate()", "path": "library/random#random.vonmisesvariate", "type": "Numeric & Mathematical", "text": "\nmu is the mean angle, expressed in radians between 0 and 2*pi, and kappa is\nthe concentration parameter, which must be greater than or equal to zero. If\nkappa is equal to zero, this distribution reduces to a uniform random angle\nover the range 0 to 2*pi.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "random.weibullvariate()", "path": "library/random#random.weibullvariate", "type": "Numeric & Mathematical", "text": "\nWeibull distribution. alpha is the scale parameter and beta is the shape\nparameter.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "range", "path": "library/stdtypes#range", "type": "Built-in Types", "text": "\nThe arguments to the range constructor must be integers (either built-in `int`\nor any object that implements the `__index__` special method). If the step\nargument is omitted, it defaults to `1`. If the start argument is omitted, it\ndefaults to `0`. If step is zero, `ValueError` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "range", "path": "library/functions#range", "type": "Built-in Functions", "text": "\nRather than being a function, `range` is actually an immutable sequence type,\nas documented in Ranges and Sequence Types \u2014 list, tuple, range.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "range.start", "path": "library/stdtypes#range.start", "type": "Built-in Types", "text": "\nThe value of the start parameter (or `0` if the parameter was not supplied)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "range.step", "path": "library/stdtypes#range.step", "type": "Built-in Types", "text": "\nThe value of the step parameter (or `1` if the parameter was not supplied)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "range.stop", "path": "library/stdtypes#range.stop", "type": "Built-in Types", "text": "\nThe value of the stop parameter\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re", "path": "library/re", "type": "Text Processing", "text": "\nSource code: Lib/re.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.A", "path": "library/re#re.A", "type": "Text Processing", "text": "\nMake `\\w`, `\\W`, `\\b`, `\\B`, `\\d`, `\\D`, `\\s` and `\\S` perform ASCII-only\nmatching instead of full Unicode matching. This is only meaningful for Unicode\npatterns, and is ignored for byte patterns. Corresponds to the inline flag\n`(?a)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.ASCII", "path": "library/re#re.ASCII", "type": "Text Processing", "text": "\nMake `\\w`, `\\W`, `\\b`, `\\B`, `\\d`, `\\D`, `\\s` and `\\S` perform ASCII-only\nmatching instead of full Unicode matching. This is only meaningful for Unicode\npatterns, and is ignored for byte patterns. Corresponds to the inline flag\n`(?a)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.compile()", "path": "library/re#re.compile", "type": "Text Processing", "text": "\nCompile a regular expression pattern into a regular expression object, which\ncan be used for matching using its `match()`, `search()` and other methods,\ndescribed below.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.DEBUG", "path": "library/re#re.DEBUG", "type": "Text Processing", "text": "\nDisplay debug information about compiled expression. No corresponding inline\nflag.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.DOTALL", "path": "library/re#re.DOTALL", "type": "Text Processing", "text": "\nMake the `'.'` special character match any character at all, including a\nnewline; without this flag, `'.'` will match anything except a newline.\nCorresponds to the inline flag `(?s)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.error", "path": "library/re#re.error", "type": "Text Processing", "text": "\nException raised when a string passed to one of the functions here is not a\nvalid regular expression (for example, it might contain unmatched parentheses)\nor when some other error occurs during compilation or matching. It is never an\nerror if a string contains no match for a pattern. The error instance has the\nfollowing additional attributes:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.error.colno", "path": "library/re#re.error.colno", "type": "Text Processing", "text": "\nThe column corresponding to pos (may be `None`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.error.lineno", "path": "library/re#re.error.lineno", "type": "Text Processing", "text": "\nThe line corresponding to pos (may be `None`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.error.msg", "path": "library/re#re.error.msg", "type": "Text Processing", "text": "\nThe unformatted error message.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.error.pattern", "path": "library/re#re.error.pattern", "type": "Text Processing", "text": "\nThe regular expression pattern.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.error.pos", "path": "library/re#re.error.pos", "type": "Text Processing", "text": "\nThe index in pattern where compilation failed (may be `None`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.escape()", "path": "library/re#re.escape", "type": "Text Processing", "text": "\nEscape special characters in pattern. This is useful if you want to match an\narbitrary literal string that may have regular expression metacharacters in\nit. For example:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.findall()", "path": "library/re#re.findall", "type": "Text Processing", "text": "\nReturn all non-overlapping matches of pattern in string, as a list of strings.\nThe string is scanned left-to-right, and matches are returned in the order\nfound. If one or more groups are present in the pattern, return a list of\ngroups; this will be a list of tuples if the pattern has more than one group.\nEmpty matches are included in the result.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.finditer()", "path": "library/re#re.finditer", "type": "Text Processing", "text": "\nReturn an iterator yielding match objects over all non-overlapping matches for\nthe RE pattern in string. The string is scanned left-to-right, and matches are\nreturned in the order found. Empty matches are included in the result.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.fullmatch()", "path": "library/re#re.fullmatch", "type": "Text Processing", "text": "\nIf the whole string matches the regular expression pattern, return a\ncorresponding match object. Return `None` if the string does not match the\npattern; note that this is different from a zero-length match.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.I", "path": "library/re#re.I", "type": "Text Processing", "text": "\nPerform case-insensitive matching; expressions like `[A-Z]` will also match\nlowercase letters. Full Unicode matching (such as `\u00dc` matching `\u00fc`) also works\nunless the `re.ASCII` flag is used to disable non-ASCII matches. The current\nlocale does not change the effect of this flag unless the `re.LOCALE` flag is\nalso used. Corresponds to the inline flag `(?i)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.IGNORECASE", "path": "library/re#re.IGNORECASE", "type": "Text Processing", "text": "\nPerform case-insensitive matching; expressions like `[A-Z]` will also match\nlowercase letters. Full Unicode matching (such as `\u00dc` matching `\u00fc`) also works\nunless the `re.ASCII` flag is used to disable non-ASCII matches. The current\nlocale does not change the effect of this flag unless the `re.LOCALE` flag is\nalso used. Corresponds to the inline flag `(?i)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.L", "path": "library/re#re.L", "type": "Text Processing", "text": "\nMake `\\w`, `\\W`, `\\b`, `\\B` and case-insensitive matching dependent on the\ncurrent locale. This flag can be used only with bytes patterns. The use of\nthis flag is discouraged as the locale mechanism is very unreliable, it only\nhandles one \u201cculture\u201d at a time, and it only works with 8-bit locales. Unicode\nmatching is already enabled by default in Python 3 for Unicode (str) patterns,\nand it is able to handle different locales/languages. Corresponds to the\ninline flag `(?L)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.LOCALE", "path": "library/re#re.LOCALE", "type": "Text Processing", "text": "\nMake `\\w`, `\\W`, `\\b`, `\\B` and case-insensitive matching dependent on the\ncurrent locale. This flag can be used only with bytes patterns. The use of\nthis flag is discouraged as the locale mechanism is very unreliable, it only\nhandles one \u201cculture\u201d at a time, and it only works with 8-bit locales. Unicode\nmatching is already enabled by default in Python 3 for Unicode (str) patterns,\nand it is able to handle different locales/languages. Corresponds to the\ninline flag `(?L)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.M", "path": "library/re#re.M", "type": "Text Processing", "text": "\nWhen specified, the pattern character `'^'` matches at the beginning of the\nstring and at the beginning of each line (immediately following each newline);\nand the pattern character `'$'` matches at the end of the string and at the\nend of each line (immediately preceding each newline). By default, `'^'`\nmatches only at the beginning of the string, and `'$'` only at the end of the\nstring and immediately before the newline (if any) at the end of the string.\nCorresponds to the inline flag `(?m)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.match()", "path": "library/re#re.match", "type": "Text Processing", "text": "\nIf zero or more characters at the beginning of string match the regular\nexpression pattern, return a corresponding match object. Return `None` if the\nstring does not match the pattern; note that this is different from a zero-\nlength match.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.Match.end()", "path": "library/re#re.Match.end", "type": "Text Processing", "text": "\nReturn the indices of the start and end of the substring matched by group;\ngroup defaults to zero (meaning the whole matched substring). Return `-1` if\ngroup exists but did not contribute to the match. For a match object m, and a\ngroup g that did contribute to the match, the substring matched by group g\n(equivalent to `m.group(g)`) is\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.Match.endpos", "path": "library/re#re.Match.endpos", "type": "Text Processing", "text": "\nThe value of endpos which was passed to the `search()` or `match()` method of\na regex object. This is the index into the string beyond which the RE engine\nwill not go.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.Match.expand()", "path": "library/re#re.Match.expand", "type": "Text Processing", "text": "\nReturn the string obtained by doing backslash substitution on the template\nstring template, as done by the `sub()` method. Escapes such as `\\n` are\nconverted to the appropriate characters, and numeric backreferences (`\\1`,\n`\\2`) and named backreferences (`\\g<1>`, `\\g<name>`) are replaced by the\ncontents of the corresponding group.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.Match.group()", "path": "library/re#re.Match.group", "type": "Text Processing", "text": "\nReturns one or more subgroups of the match. If there is a single argument, the\nresult is a single string; if there are multiple arguments, the result is a\ntuple with one item per argument. Without arguments, group1 defaults to zero\n(the whole match is returned). If a groupN argument is zero, the corresponding\nreturn value is the entire matching string; if it is in the inclusive range\n[1..99], it is the string matching the corresponding parenthesized group. If a\ngroup number is negative or larger than the number of groups defined in the\npattern, an `IndexError` exception is raised. If a group is contained in a\npart of the pattern that did not match, the corresponding result is `None`. If\na group is contained in a part of the pattern that matched multiple times, the\nlast match is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.Match.groupdict()", "path": "library/re#re.Match.groupdict", "type": "Text Processing", "text": "\nReturn a dictionary containing all the named subgroups of the match, keyed by\nthe subgroup name. The default argument is used for groups that did not\nparticipate in the match; it defaults to `None`. For example:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.Match.groups()", "path": "library/re#re.Match.groups", "type": "Text Processing", "text": "\nReturn a tuple containing all the subgroups of the match, from 1 up to however\nmany groups are in the pattern. The default argument is used for groups that\ndid not participate in the match; it defaults to `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.Match.lastgroup", "path": "library/re#re.Match.lastgroup", "type": "Text Processing", "text": "\nThe name of the last matched capturing group, or `None` if the group didn\u2019t\nhave a name, or if no group was matched at all.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.Match.lastindex", "path": "library/re#re.Match.lastindex", "type": "Text Processing", "text": "\nThe integer index of the last matched capturing group, or `None` if no group\nwas matched at all. For example, the expressions `(a)b`, `((a)(b))`, and\n`((ab))` will have `lastindex == 1` if applied to the string `'ab'`, while the\nexpression `(a)(b)` will have `lastindex == 2`, if applied to the same string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.Match.pos", "path": "library/re#re.Match.pos", "type": "Text Processing", "text": "\nThe value of pos which was passed to the `search()` or `match()` method of a\nregex object. This is the index into the string at which the RE engine started\nlooking for a match.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.Match.re", "path": "library/re#re.Match.re", "type": "Text Processing", "text": "\nThe regular expression object whose `match()` or `search()` method produced\nthis match instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.Match.span()", "path": "library/re#re.Match.span", "type": "Text Processing", "text": "\nFor a match m, return the 2-tuple `(m.start(group), m.end(group))`. Note that\nif group did not contribute to the match, this is `(-1, -1)`. group defaults\nto zero, the entire match.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.Match.start()", "path": "library/re#re.Match.start", "type": "Text Processing", "text": "\nReturn the indices of the start and end of the substring matched by group;\ngroup defaults to zero (meaning the whole matched substring). Return `-1` if\ngroup exists but did not contribute to the match. For a match object m, and a\ngroup g that did contribute to the match, the substring matched by group g\n(equivalent to `m.group(g)`) is\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.Match.string", "path": "library/re#re.Match.string", "type": "Text Processing", "text": "\nThe string passed to `match()` or `search()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.Match.__getitem__()", "path": "library/re#re.Match.__getitem__", "type": "Text Processing", "text": "\nThis is identical to `m.group(g)`. This allows easier access to an individual\ngroup from a match:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.MULTILINE", "path": "library/re#re.MULTILINE", "type": "Text Processing", "text": "\nWhen specified, the pattern character `'^'` matches at the beginning of the\nstring and at the beginning of each line (immediately following each newline);\nand the pattern character `'$'` matches at the end of the string and at the\nend of each line (immediately preceding each newline). By default, `'^'`\nmatches only at the beginning of the string, and `'$'` only at the end of the\nstring and immediately before the newline (if any) at the end of the string.\nCorresponds to the inline flag `(?m)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.Pattern.findall()", "path": "library/re#re.Pattern.findall", "type": "Text Processing", "text": "\nSimilar to the `findall()` function, using the compiled pattern, but also\naccepts optional pos and endpos parameters that limit the search region like\nfor `search()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.Pattern.finditer()", "path": "library/re#re.Pattern.finditer", "type": "Text Processing", "text": "\nSimilar to the `finditer()` function, using the compiled pattern, but also\naccepts optional pos and endpos parameters that limit the search region like\nfor `search()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.Pattern.flags", "path": "library/re#re.Pattern.flags", "type": "Text Processing", "text": "\nThe regex matching flags. This is a combination of the flags given to\n`compile()`, any `(?...)` inline flags in the pattern, and implicit flags such\nas `UNICODE` if the pattern is a Unicode string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.Pattern.fullmatch()", "path": "library/re#re.Pattern.fullmatch", "type": "Text Processing", "text": "\nIf the whole string matches this regular expression, return a corresponding\nmatch object. Return `None` if the string does not match the pattern; note\nthat this is different from a zero-length match.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.Pattern.groupindex", "path": "library/re#re.Pattern.groupindex", "type": "Text Processing", "text": "\nA dictionary mapping any symbolic group names defined by `(?P<id>)` to group\nnumbers. The dictionary is empty if no symbolic groups were used in the\npattern.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.Pattern.groups", "path": "library/re#re.Pattern.groups", "type": "Text Processing", "text": "\nThe number of capturing groups in the pattern.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.Pattern.match()", "path": "library/re#re.Pattern.match", "type": "Text Processing", "text": "\nIf zero or more characters at the beginning of string match this regular\nexpression, return a corresponding match object. Return `None` if the string\ndoes not match the pattern; note that this is different from a zero-length\nmatch.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.Pattern.pattern", "path": "library/re#re.Pattern.pattern", "type": "Text Processing", "text": "\nThe pattern string from which the pattern object was compiled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.Pattern.search()", "path": "library/re#re.Pattern.search", "type": "Text Processing", "text": "\nScan through string looking for the first location where this regular\nexpression produces a match, and return a corresponding match object. Return\n`None` if no position in the string matches the pattern; note that this is\ndifferent from finding a zero-length match at some point in the string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.Pattern.split()", "path": "library/re#re.Pattern.split", "type": "Text Processing", "text": "\nIdentical to the `split()` function, using the compiled pattern.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.Pattern.sub()", "path": "library/re#re.Pattern.sub", "type": "Text Processing", "text": "\nIdentical to the `sub()` function, using the compiled pattern.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.Pattern.subn()", "path": "library/re#re.Pattern.subn", "type": "Text Processing", "text": "\nIdentical to the `subn()` function, using the compiled pattern.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.purge()", "path": "library/re#re.purge", "type": "Text Processing", "text": "\nClear the regular expression cache.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.S", "path": "library/re#re.S", "type": "Text Processing", "text": "\nMake the `'.'` special character match any character at all, including a\nnewline; without this flag, `'.'` will match anything except a newline.\nCorresponds to the inline flag `(?s)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.search()", "path": "library/re#re.search", "type": "Text Processing", "text": "\nScan through string looking for the first location where the regular\nexpression pattern produces a match, and return a corresponding match object.\nReturn `None` if no position in the string matches the pattern; note that this\nis different from finding a zero-length match at some point in the string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.split()", "path": "library/re#re.split", "type": "Text Processing", "text": "\nSplit string by the occurrences of pattern. If capturing parentheses are used\nin pattern, then the text of all groups in the pattern are also returned as\npart of the resulting list. If maxsplit is nonzero, at most maxsplit splits\noccur, and the remainder of the string is returned as the final element of the\nlist.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.sub()", "path": "library/re#re.sub", "type": "Text Processing", "text": "\nReturn the string obtained by replacing the leftmost non-overlapping\noccurrences of pattern in string by the replacement repl. If the pattern isn\u2019t\nfound, string is returned unchanged. repl can be a string or a function; if it\nis a string, any backslash escapes in it are processed. That is, `\\n` is\nconverted to a single newline character, `\\r` is converted to a carriage\nreturn, and so forth. Unknown escapes of ASCII letters are reserved for future\nuse and treated as errors. Other unknown escapes such as `\\&` are left alone.\nBackreferences, such as `\\6`, are replaced with the substring matched by group\n6 in the pattern. For example:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.subn()", "path": "library/re#re.subn", "type": "Text Processing", "text": "\nPerform the same operation as `sub()`, but return a tuple `(new_string,\nnumber_of_subs_made)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.VERBOSE", "path": "library/re#re.VERBOSE", "type": "Text Processing", "text": "\nThis flag allows you to write regular expressions that look nicer and are more\nreadable by allowing you to visually separate logical sections of the pattern\nand add comments. Whitespace within the pattern is ignored, except when in a\ncharacter class, or when preceded by an unescaped backslash, or within tokens\nlike `*?`, `(?:` or `(?P<...>`. When a line contains a `#` that is not in a\ncharacter class and is not preceded by an unescaped backslash, all characters\nfrom the leftmost such `#` through the end of the line are ignored.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "re.X", "path": "library/re#re.X", "type": "Text Processing", "text": "\nThis flag allows you to write regular expressions that look nicer and are more\nreadable by allowing you to visually separate logical sections of the pattern\nand add comments. Whitespace within the pattern is ignored, except when in a\ncharacter class, or when preceded by an unescaped backslash, or within tokens\nlike `*?`, `(?:` or `(?P<...>`. When a line contains a `#` that is not in a\ncharacter class and is not preceded by an unescaped backslash, all characters\nfrom the leftmost such `#` through the end of the line are ignored.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "readline", "path": "library/readline", "type": "Text Processing", "text": "\nThe `readline` module defines a number of functions to facilitate completion\nand reading/writing of history files from the Python interpreter. This module\ncan be used directly, or via the `rlcompleter` module, which supports\ncompletion of Python identifiers at the interactive prompt. Settings made\nusing this module affect the behaviour of both the interpreter\u2019s interactive\nprompt and the prompts offered by the built-in `input()` function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "readline.add_history()", "path": "library/readline#readline.add_history", "type": "Text Processing", "text": "\nAppend line to the history buffer, as if it was the last line typed. This\ncalls `add_history()` in the underlying library.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "readline.append_history_file()", "path": "library/readline#readline.append_history_file", "type": "Text Processing", "text": "\nAppend the last nelements items of history to a file. The default filename is\n`~/.history`. The file must already exist. This calls `append_history()` in\nthe underlying library. This function only exists if Python was compiled for a\nversion of the library that supports it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "readline.clear_history()", "path": "library/readline#readline.clear_history", "type": "Text Processing", "text": "\nClear the current history. This calls `clear_history()` in the underlying\nlibrary. The Python function only exists if Python was compiled for a version\nof the library that supports it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "readline.get_begidx()", "path": "library/readline#readline.get_begidx", "type": "Text Processing", "text": "\nGet the beginning or ending index of the completion scope. These indexes are\nthe start and end arguments passed to the `rl_attempted_completion_function`\ncallback of the underlying library.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "readline.get_completer()", "path": "library/readline#readline.get_completer", "type": "Text Processing", "text": "\nGet the completer function, or `None` if no completer function has been set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "readline.get_completer_delims()", "path": "library/readline#readline.get_completer_delims", "type": "Text Processing", "text": "\nSet or get the word delimiters for completion. These determine the start of\nthe word to be considered for completion (the completion scope). These\nfunctions access the `rl_completer_word_break_characters` variable in the\nunderlying library.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "readline.get_completion_type()", "path": "library/readline#readline.get_completion_type", "type": "Text Processing", "text": "\nGet the type of completion being attempted. This returns the\n`rl_completion_type` variable in the underlying library as an integer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "readline.get_current_history_length()", "path": "library/readline#readline.get_current_history_length", "type": "Text Processing", "text": "\nReturn the number of items currently in the history. (This is different from\n`get_history_length()`, which returns the maximum number of lines that will be\nwritten to a history file.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "readline.get_endidx()", "path": "library/readline#readline.get_endidx", "type": "Text Processing", "text": "\nGet the beginning or ending index of the completion scope. These indexes are\nthe start and end arguments passed to the `rl_attempted_completion_function`\ncallback of the underlying library.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "readline.get_history_item()", "path": "library/readline#readline.get_history_item", "type": "Text Processing", "text": "\nReturn the current contents of history item at index. The item index is one-\nbased. This calls `history_get()` in the underlying library.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "readline.get_history_length()", "path": "library/readline#readline.get_history_length", "type": "Text Processing", "text": "\nSet or return the desired number of lines to save in the history file. The\n`write_history_file()` function uses this value to truncate the history file,\nby calling `history_truncate_file()` in the underlying library. Negative\nvalues imply unlimited history file size.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "readline.get_line_buffer()", "path": "library/readline#readline.get_line_buffer", "type": "Text Processing", "text": "\nReturn the current contents of the line buffer (`rl_line_buffer` in the\nunderlying library).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "readline.insert_text()", "path": "library/readline#readline.insert_text", "type": "Text Processing", "text": "\nInsert text into the line buffer at the cursor position. This calls\n`rl_insert_text()` in the underlying library, but ignores the return value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "readline.parse_and_bind()", "path": "library/readline#readline.parse_and_bind", "type": "Text Processing", "text": "\nExecute the init line provided in the string argument. This calls\n`rl_parse_and_bind()` in the underlying library.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "readline.read_history_file()", "path": "library/readline#readline.read_history_file", "type": "Text Processing", "text": "\nLoad a readline history file, and append it to the history list. The default\nfilename is `~/.history`. This calls `read_history()` in the underlying\nlibrary.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "readline.read_init_file()", "path": "library/readline#readline.read_init_file", "type": "Text Processing", "text": "\nExecute a readline initialization file. The default filename is the last\nfilename used. This calls `rl_read_init_file()` in the underlying library.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "readline.redisplay()", "path": "library/readline#readline.redisplay", "type": "Text Processing", "text": "\nChange what\u2019s displayed on the screen to reflect the current contents of the\nline buffer. This calls `rl_redisplay()` in the underlying library.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "readline.remove_history_item()", "path": "library/readline#readline.remove_history_item", "type": "Text Processing", "text": "\nRemove history item specified by its position from the history. The position\nis zero-based. This calls `remove_history()` in the underlying library.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "readline.replace_history_item()", "path": "library/readline#readline.replace_history_item", "type": "Text Processing", "text": "\nReplace history item specified by its position with line. The position is\nzero-based. This calls `replace_history_entry()` in the underlying library.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "readline.set_auto_history()", "path": "library/readline#readline.set_auto_history", "type": "Text Processing", "text": "\nEnable or disable automatic calls to `add_history()` when reading input via\nreadline. The enabled argument should be a Boolean value that when true,\nenables auto history, and that when false, disables auto history.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "readline.set_completer()", "path": "library/readline#readline.set_completer", "type": "Text Processing", "text": "\nSet or remove the completer function. If function is specified, it will be\nused as the new completer function; if omitted or `None`, any completer\nfunction already installed is removed. The completer function is called as\n`function(text, state)`, for state in `0`, `1`, `2`, \u2026, until it returns a\nnon-string value. It should return the next possible completion starting with\ntext.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "readline.set_completer_delims()", "path": "library/readline#readline.set_completer_delims", "type": "Text Processing", "text": "\nSet or get the word delimiters for completion. These determine the start of\nthe word to be considered for completion (the completion scope). These\nfunctions access the `rl_completer_word_break_characters` variable in the\nunderlying library.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "readline.set_completion_display_matches_hook()", "path": "library/readline#readline.set_completion_display_matches_hook", "type": "Text Processing", "text": "\nSet or remove the completion display function. If function is specified, it\nwill be used as the new completion display function; if omitted or `None`, any\ncompletion display function already installed is removed. This sets or clears\nthe `rl_completion_display_matches_hook` callback in the underlying library.\nThe completion display function is called as `function(substitution,\n[matches], longest_match_length)` once each time matches need to be displayed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "readline.set_history_length()", "path": "library/readline#readline.set_history_length", "type": "Text Processing", "text": "\nSet or return the desired number of lines to save in the history file. The\n`write_history_file()` function uses this value to truncate the history file,\nby calling `history_truncate_file()` in the underlying library. Negative\nvalues imply unlimited history file size.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "readline.set_pre_input_hook()", "path": "library/readline#readline.set_pre_input_hook", "type": "Text Processing", "text": "\nSet or remove the function invoked by the `rl_pre_input_hook` callback of the\nunderlying library. If function is specified, it will be used as the new hook\nfunction; if omitted or `None`, any function already installed is removed. The\nhook is called with no arguments after the first prompt has been printed and\njust before readline starts reading input characters. This function only\nexists if Python was compiled for a version of the library that supports it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "readline.set_startup_hook()", "path": "library/readline#readline.set_startup_hook", "type": "Text Processing", "text": "\nSet or remove the function invoked by the `rl_startup_hook` callback of the\nunderlying library. If function is specified, it will be used as the new hook\nfunction; if omitted or `None`, any function already installed is removed. The\nhook is called with no arguments just before readline prints the first prompt.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "readline.write_history_file()", "path": "library/readline#readline.write_history_file", "type": "Text Processing", "text": "\nSave the history list to a readline history file, overwriting any existing\nfile. The default filename is `~/.history`. This calls `write_history()` in\nthe underlying library.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "RecursionError", "path": "library/exceptions#RecursionError", "type": "Built-in Exceptions", "text": "\nThis exception is derived from `RuntimeError`. It is raised when the\ninterpreter detects that the maximum recursion depth (see\n`sys.getrecursionlimit()`) is exceeded.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ReferenceError", "path": "library/exceptions#ReferenceError", "type": "Built-in Exceptions", "text": "\nThis exception is raised when a weak reference proxy, created by the\n`weakref.proxy()` function, is used to access an attribute of the referent\nafter it has been garbage collected. For more information on weak references,\nsee the `weakref` module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "repr()", "path": "library/functions#repr", "type": "Built-in Functions", "text": "\nReturn a string containing a printable representation of an object. For many\ntypes, this function makes an attempt to return a string that would yield an\nobject with the same value when passed to `eval()`, otherwise the\nrepresentation is a string enclosed in angle brackets that contains the name\nof the type of the object together with additional information often including\nthe name and address of the object. A class can control what this function\nreturns for its instances by defining a `__repr__()` method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "reprlib", "path": "library/reprlib", "type": "Data Types", "text": "\nSource code: Lib/reprlib.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "reprlib.aRepr", "path": "library/reprlib#reprlib.aRepr", "type": "Data Types", "text": "\nThis is an instance of `Repr` which is used to provide the `repr()` function\ndescribed below. Changing the attributes of this object will affect the size\nlimits used by `repr()` and the Python debugger.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "reprlib.recursive_repr()", "path": "library/reprlib#reprlib.recursive_repr", "type": "Data Types", "text": "\nDecorator for `__repr__()` methods to detect recursive calls within the same\nthread. If a recursive call is made, the fillvalue is returned, otherwise, the\nusual `__repr__()` call is made. For example:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "reprlib.Repr", "path": "library/reprlib#reprlib.Repr", "type": "Data Types", "text": "\nClass which provides formatting services useful in implementing functions\nsimilar to the built-in `repr()`; size limits for different object types are\nadded to avoid the generation of representations which are excessively long.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "reprlib.repr()", "path": "library/reprlib#reprlib.repr", "type": "Data Types", "text": "\nThis is the `repr()` method of `aRepr`. It returns a string similar to that\nreturned by the built-in function of the same name, but with limits on most\nsizes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "reprlib.Repr.maxarray", "path": "library/reprlib#reprlib.Repr.maxarray", "type": "Data Types", "text": "\nLimits on the number of entries represented for the named object type. The\ndefault is `4` for `maxdict`, `5` for `maxarray`, and `6` for the others.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "reprlib.Repr.maxdeque", "path": "library/reprlib#reprlib.Repr.maxdeque", "type": "Data Types", "text": "\nLimits on the number of entries represented for the named object type. The\ndefault is `4` for `maxdict`, `5` for `maxarray`, and `6` for the others.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "reprlib.Repr.maxdict", "path": "library/reprlib#reprlib.Repr.maxdict", "type": "Data Types", "text": "\nLimits on the number of entries represented for the named object type. The\ndefault is `4` for `maxdict`, `5` for `maxarray`, and `6` for the others.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "reprlib.Repr.maxfrozenset", "path": "library/reprlib#reprlib.Repr.maxfrozenset", "type": "Data Types", "text": "\nLimits on the number of entries represented for the named object type. The\ndefault is `4` for `maxdict`, `5` for `maxarray`, and `6` for the others.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "reprlib.Repr.maxlevel", "path": "library/reprlib#reprlib.Repr.maxlevel", "type": "Data Types", "text": "\nDepth limit on the creation of recursive representations. The default is `6`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "reprlib.Repr.maxlist", "path": "library/reprlib#reprlib.Repr.maxlist", "type": "Data Types", "text": "\nLimits on the number of entries represented for the named object type. The\ndefault is `4` for `maxdict`, `5` for `maxarray`, and `6` for the others.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "reprlib.Repr.maxlong", "path": "library/reprlib#reprlib.Repr.maxlong", "type": "Data Types", "text": "\nMaximum number of characters in the representation for an integer. Digits are\ndropped from the middle. The default is `40`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "reprlib.Repr.maxother", "path": "library/reprlib#reprlib.Repr.maxother", "type": "Data Types", "text": "\nThis limit is used to control the size of object types for which no specific\nformatting method is available on the `Repr` object. It is applied in a\nsimilar manner as `maxstring`. The default is `20`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "reprlib.Repr.maxset", "path": "library/reprlib#reprlib.Repr.maxset", "type": "Data Types", "text": "\nLimits on the number of entries represented for the named object type. The\ndefault is `4` for `maxdict`, `5` for `maxarray`, and `6` for the others.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "reprlib.Repr.maxstring", "path": "library/reprlib#reprlib.Repr.maxstring", "type": "Data Types", "text": "\nLimit on the number of characters in the representation of the string. Note\nthat the \u201cnormal\u201d representation of the string is used as the character\nsource: if escape sequences are needed in the representation, these may be\nmangled when the representation is shortened. The default is `30`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "reprlib.Repr.maxtuple", "path": "library/reprlib#reprlib.Repr.maxtuple", "type": "Data Types", "text": "\nLimits on the number of entries represented for the named object type. The\ndefault is `4` for `maxdict`, `5` for `maxarray`, and `6` for the others.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "reprlib.Repr.repr()", "path": "library/reprlib#reprlib.Repr.repr", "type": "Data Types", "text": "\nThe equivalent to the built-in `repr()` that uses the formatting imposed by\nthe instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "reprlib.Repr.repr1()", "path": "library/reprlib#reprlib.Repr.repr1", "type": "Data Types", "text": "\nRecursive implementation used by `repr()`. This uses the type of obj to\ndetermine which formatting method to call, passing it obj and level. The type-\nspecific methods should call `repr1()` to perform recursive formatting, with\n`level - 1` for the value of level in the recursive call.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "request()", "path": "library/urllib.request#request", "type": "Internet", "text": "\nThis method is not defined in `BaseHandler`, but subclasses should define it\nif they want to pre-process requests of the given protocol.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "resource", "path": "library/resource", "type": "Unix", "text": "\nThis module provides basic mechanisms for measuring and controlling system\nresources utilized by a program.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "resource.error", "path": "library/resource#resource.error", "type": "Unix", "text": "\nA deprecated alias of `OSError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "resource.getpagesize()", "path": "library/resource#resource.getpagesize", "type": "Unix", "text": "\nReturns the number of bytes in a system page. (This need not be the same as\nthe hardware page size.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "resource.getrlimit()", "path": "library/resource#resource.getrlimit", "type": "Unix", "text": "\nReturns a tuple `(soft, hard)` with the current soft and hard limits of\nresource. Raises `ValueError` if an invalid resource is specified, or `error`\nif the underlying system call fails unexpectedly.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "resource.getrusage()", "path": "library/resource#resource.getrusage", "type": "Unix", "text": "\nThis function returns an object that describes the resources consumed by\neither the current process or its children, as specified by the who parameter.\nThe who parameter should be specified using one of the `RUSAGE_*` constants\ndescribed below.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "resource.prlimit()", "path": "library/resource#resource.prlimit", "type": "Unix", "text": "\nCombines `setrlimit()` and `getrlimit()` in one function and supports to get\nand set the resources limits of an arbitrary process. If pid is 0, then the\ncall applies to the current process. resource and limits have the same meaning\nas in `setrlimit()`, except that limits is optional.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "resource.RLIMIT_AS", "path": "library/resource#resource.RLIMIT_AS", "type": "Unix", "text": "\nThe maximum area (in bytes) of address space which may be taken by the\nprocess.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "resource.RLIMIT_CORE", "path": "library/resource#resource.RLIMIT_CORE", "type": "Unix", "text": "\nThe maximum size (in bytes) of a core file that the current process can\ncreate. This may result in the creation of a partial core file if a larger\ncore would be required to contain the entire process image.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "resource.RLIMIT_CPU", "path": "library/resource#resource.RLIMIT_CPU", "type": "Unix", "text": "\nThe maximum amount of processor time (in seconds) that a process can use. If\nthis limit is exceeded, a `SIGXCPU` signal is sent to the process. (See the\n`signal` module documentation for information about how to catch this signal\nand do something useful, e.g. flush open files to disk.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "resource.RLIMIT_DATA", "path": "library/resource#resource.RLIMIT_DATA", "type": "Unix", "text": "\nThe maximum size (in bytes) of the process\u2019s heap.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "resource.RLIMIT_FSIZE", "path": "library/resource#resource.RLIMIT_FSIZE", "type": "Unix", "text": "\nThe maximum size of a file which the process may create.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "resource.RLIMIT_MEMLOCK", "path": "library/resource#resource.RLIMIT_MEMLOCK", "type": "Unix", "text": "\nThe maximum address space which may be locked in memory.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "resource.RLIMIT_MSGQUEUE", "path": "library/resource#resource.RLIMIT_MSGQUEUE", "type": "Unix", "text": "\nThe number of bytes that can be allocated for POSIX message queues.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "resource.RLIMIT_NICE", "path": "library/resource#resource.RLIMIT_NICE", "type": "Unix", "text": "\nThe ceiling for the process\u2019s nice level (calculated as 20 - rlim_cur).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "resource.RLIMIT_NOFILE", "path": "library/resource#resource.RLIMIT_NOFILE", "type": "Unix", "text": "\nThe maximum number of open file descriptors for the current process.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "resource.RLIMIT_NPROC", "path": "library/resource#resource.RLIMIT_NPROC", "type": "Unix", "text": "\nThe maximum number of processes the current process may create.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "resource.RLIMIT_NPTS", "path": "library/resource#resource.RLIMIT_NPTS", "type": "Unix", "text": "\nThe maximum number of pseudo-terminals created by this user id.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "resource.RLIMIT_OFILE", "path": "library/resource#resource.RLIMIT_OFILE", "type": "Unix", "text": "\nThe BSD name for `RLIMIT_NOFILE`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "resource.RLIMIT_RSS", "path": "library/resource#resource.RLIMIT_RSS", "type": "Unix", "text": "\nThe maximum resident set size that should be made available to the process.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "resource.RLIMIT_RTPRIO", "path": "library/resource#resource.RLIMIT_RTPRIO", "type": "Unix", "text": "\nThe ceiling of the real-time priority.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "resource.RLIMIT_RTTIME", "path": "library/resource#resource.RLIMIT_RTTIME", "type": "Unix", "text": "\nThe time limit (in microseconds) on CPU time that a process can spend under\nreal-time scheduling without making a blocking syscall.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "resource.RLIMIT_SBSIZE", "path": "library/resource#resource.RLIMIT_SBSIZE", "type": "Unix", "text": "\nThe maximum size (in bytes) of socket buffer usage for this user. This limits\nthe amount of network memory, and hence the amount of mbufs, that this user\nmay hold at any time.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "resource.RLIMIT_SIGPENDING", "path": "library/resource#resource.RLIMIT_SIGPENDING", "type": "Unix", "text": "\nThe number of signals which the process may queue.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "resource.RLIMIT_STACK", "path": "library/resource#resource.RLIMIT_STACK", "type": "Unix", "text": "\nThe maximum size (in bytes) of the call stack for the current process. This\nonly affects the stack of the main thread in a multi-threaded process.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "resource.RLIMIT_SWAP", "path": "library/resource#resource.RLIMIT_SWAP", "type": "Unix", "text": "\nThe maximum size (in bytes) of the swap space that may be reserved or used by\nall of this user id\u2019s processes. This limit is enforced only if bit 1 of the\nvm.overcommit sysctl is set. Please see tuning(7) for a complete description\nof this sysctl.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "resource.RLIMIT_VMEM", "path": "library/resource#resource.RLIMIT_VMEM", "type": "Unix", "text": "\nThe largest area of mapped memory which the process may occupy.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "resource.RLIM_INFINITY", "path": "library/resource#resource.RLIM_INFINITY", "type": "Unix", "text": "\nConstant used to represent the limit for an unlimited resource.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "resource.RUSAGE_BOTH", "path": "library/resource#resource.RUSAGE_BOTH", "type": "Unix", "text": "\nPass to `getrusage()` to request resources consumed by both the current\nprocess and child processes. May not be available on all systems.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "resource.RUSAGE_CHILDREN", "path": "library/resource#resource.RUSAGE_CHILDREN", "type": "Unix", "text": "\nPass to `getrusage()` to request resources consumed by child processes of the\ncalling process which have been terminated and waited for.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "resource.RUSAGE_SELF", "path": "library/resource#resource.RUSAGE_SELF", "type": "Unix", "text": "\nPass to `getrusage()` to request resources consumed by the calling process,\nwhich is the sum of resources used by all threads in the process.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "resource.RUSAGE_THREAD", "path": "library/resource#resource.RUSAGE_THREAD", "type": "Unix", "text": "\nPass to `getrusage()` to request resources consumed by the current thread. May\nnot be available on all systems.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "resource.setrlimit()", "path": "library/resource#resource.setrlimit", "type": "Unix", "text": "\nSets new limits of consumption of resource. The limits argument must be a\ntuple `(soft, hard)` of two integers describing the new limits. A value of\n`RLIM_INFINITY` can be used to request a limit that is unlimited.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ResourceWarning", "path": "library/exceptions#ResourceWarning", "type": "Built-in Exceptions", "text": "\nBase class for warnings related to resource usage.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "response()", "path": "library/urllib.request#response", "type": "Internet", "text": "\nThis method is not defined in `BaseHandler`, but subclasses should define it\nif they want to post-process responses of the given protocol.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "reversed()", "path": "library/functions#reversed", "type": "Built-in Functions", "text": "\nReturn a reverse iterator. seq must be an object which has a `__reversed__()`\nmethod or supports the sequence protocol (the `__len__()` method and the\n`__getitem__()` method with integer arguments starting at `0`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "rlcompleter", "path": "library/rlcompleter", "type": "Text Processing", "text": "\nSource code: Lib/rlcompleter.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "rlcompleter.Completer.complete()", "path": "library/rlcompleter#rlcompleter.Completer.complete", "type": "Text Processing", "text": "\nReturn the stateth completion for text.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "round()", "path": "library/functions#round", "type": "Built-in Functions", "text": "\nReturn number rounded to ndigits precision after the decimal point. If ndigits\nis omitted or is `None`, it returns the nearest integer to its input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "runpy", "path": "library/runpy", "type": "Importing", "text": "\nSource code: Lib/runpy.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "runpy.run_module()", "path": "library/runpy#runpy.run_module", "type": "Importing", "text": "\nExecute the code of the specified module and return the resulting module\nglobals dictionary. The module\u2019s code is first located using the standard\nimport mechanism (refer to PEP 302 for details) and then executed in a fresh\nmodule namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "runpy.run_path()", "path": "library/runpy#runpy.run_path", "type": "Importing", "text": "\nExecute the code at the named filesystem location and return the resulting\nmodule globals dictionary. As with a script name supplied to the CPython\ncommand line, the supplied path may refer to a Python source file, a compiled\nbytecode file or a valid sys.path entry containing a `__main__` module (e.g. a\nzipfile containing a top-level `__main__.py` file).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "RuntimeError", "path": "library/exceptions#RuntimeError", "type": "Built-in Exceptions", "text": "\nRaised when an error is detected that doesn\u2019t fall in any of the other\ncategories. The associated value is a string indicating what precisely went\nwrong.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "RuntimeWarning", "path": "library/exceptions#RuntimeWarning", "type": "Built-in Exceptions", "text": "\nBase class for warnings about dubious runtime behavior.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sched", "path": "library/sched", "type": "Concurrent Execution", "text": "\nSource code: Lib/sched.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sched.scheduler", "path": "library/sched#sched.scheduler", "type": "Concurrent Execution", "text": "\nThe `scheduler` class defines a generic interface to scheduling events. It\nneeds two functions to actually deal with the \u201coutside world\u201d \u2014 timefunc\nshould be callable without arguments, and return a number (the \u201ctime\u201d, in any\nunits whatsoever). The delayfunc function should be callable with one\nargument, compatible with the output of timefunc, and should delay that many\ntime units. delayfunc will also be called with the argument `0` after each\nevent is run to allow other threads an opportunity to run in multi-threaded\napplications.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sched.scheduler.cancel()", "path": "library/sched#sched.scheduler.cancel", "type": "Concurrent Execution", "text": "\nRemove the event from the queue. If event is not an event currently in the\nqueue, this method will raise a `ValueError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sched.scheduler.empty()", "path": "library/sched#sched.scheduler.empty", "type": "Concurrent Execution", "text": "\nReturn `True` if the event queue is empty.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sched.scheduler.enter()", "path": "library/sched#sched.scheduler.enter", "type": "Concurrent Execution", "text": "\nSchedule an event for delay more time units. Other than the relative time, the\nother arguments, the effect and the return value are the same as those for\n`enterabs()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sched.scheduler.enterabs()", "path": "library/sched#sched.scheduler.enterabs", "type": "Concurrent Execution", "text": "\nSchedule a new event. The time argument should be a numeric type compatible\nwith the return value of the timefunc function passed to the constructor.\nEvents scheduled for the same time will be executed in the order of their\npriority. A lower number represents a higher priority.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sched.scheduler.queue", "path": "library/sched#sched.scheduler.queue", "type": "Concurrent Execution", "text": "\nRead-only attribute returning a list of upcoming events in the order they will\nbe run. Each event is shown as a named tuple with the following fields: time,\npriority, action, argument, kwargs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sched.scheduler.run()", "path": "library/sched#sched.scheduler.run", "type": "Concurrent Execution", "text": "\nRun all scheduled events. This method will wait (using the `delayfunc()`\nfunction passed to the constructor) for the next event, then execute it and so\non until there are no more scheduled events.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "secrets", "path": "library/secrets", "type": "Cryptography", "text": "\nNew in version 3.6.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "secrets.choice()", "path": "library/secrets#secrets.choice", "type": "Cryptography", "text": "\nReturn a randomly-chosen element from a non-empty sequence.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "secrets.compare_digest()", "path": "library/secrets#secrets.compare_digest", "type": "Cryptography", "text": "\nReturn `True` if strings a and b are equal, otherwise `False`, in such a way\nas to reduce the risk of timing attacks. See `hmac.compare_digest()` for\nadditional details.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "secrets.randbelow()", "path": "library/secrets#secrets.randbelow", "type": "Cryptography", "text": "\nReturn a random int in the range [0, n).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "secrets.randbits()", "path": "library/secrets#secrets.randbits", "type": "Cryptography", "text": "\nReturn an int with k random bits.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "secrets.SystemRandom", "path": "library/secrets#secrets.SystemRandom", "type": "Cryptography", "text": "\nA class for generating random numbers using the highest-quality sources\nprovided by the operating system. See `random.SystemRandom` for additional\ndetails.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "secrets.token_bytes()", "path": "library/secrets#secrets.token_bytes", "type": "Cryptography", "text": "\nReturn a random byte string containing nbytes number of bytes. If nbytes is\n`None` or not supplied, a reasonable default is used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "secrets.token_hex()", "path": "library/secrets#secrets.token_hex", "type": "Cryptography", "text": "\nReturn a random text string, in hexadecimal. The string has nbytes random\nbytes, each byte converted to two hex digits. If nbytes is `None` or not\nsupplied, a reasonable default is used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "secrets.token_urlsafe()", "path": "library/secrets#secrets.token_urlsafe", "type": "Cryptography", "text": "\nReturn a random URL-safe text string, containing nbytes random bytes. The text\nis Base64 encoded, so on average each byte results in approximately 1.3\ncharacters. If nbytes is `None` or not supplied, a reasonable default is used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "select", "path": "library/select", "type": "Input/ouput", "text": "\nThis module provides access to the `select()` and `poll()` functions available\nin most operating systems, `devpoll()` available on Solaris and derivatives,\n`epoll()` available on Linux 2.5+ and `kqueue()` available on most BSD. Note\nthat on Windows, it only works for sockets; on other operating systems, it\nalso works for other file types (in particular, on Unix, it works on pipes).\nIt cannot be used on regular files to determine whether a file has grown since\nit was last read.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "select.devpoll()", "path": "library/select#select.devpoll", "type": "Input/ouput", "text": "\n(Only supported on Solaris and derivatives.) Returns a `/dev/poll` polling\nobject; see section /dev/poll Polling Objects below for the methods supported\nby devpoll objects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "select.devpoll.close()", "path": "library/select#select.devpoll.close", "type": "Input/ouput", "text": "\nClose the file descriptor of the polling object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "select.devpoll.closed", "path": "library/select#select.devpoll.closed", "type": "Input/ouput", "text": "\n`True` if the polling object is closed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "select.devpoll.fileno()", "path": "library/select#select.devpoll.fileno", "type": "Input/ouput", "text": "\nReturn the file descriptor number of the polling object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "select.devpoll.modify()", "path": "library/select#select.devpoll.modify", "type": "Input/ouput", "text": "\nThis method does an `unregister()` followed by a `register()`. It is (a bit)\nmore efficient that doing the same explicitly.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "select.devpoll.poll()", "path": "library/select#select.devpoll.poll", "type": "Input/ouput", "text": "\nPolls the set of registered file descriptors, and returns a possibly-empty\nlist containing `(fd, event)` 2-tuples for the descriptors that have events or\nerrors to report. fd is the file descriptor, and event is a bitmask with bits\nset for the reported events for that descriptor \u2014 `POLLIN` for waiting input,\n`POLLOUT` to indicate that the descriptor can be written to, and so forth. An\nempty list indicates that the call timed out and no file descriptors had any\nevents to report. If timeout is given, it specifies the length of time in\nmilliseconds which the system will wait for events before returning. If\ntimeout is omitted, -1, or `None`, the call will block until there is an event\nfor this poll object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "select.devpoll.register()", "path": "library/select#select.devpoll.register", "type": "Input/ouput", "text": "\nRegister a file descriptor with the polling object. Future calls to the\n`poll()` method will then check whether the file descriptor has any pending\nI/O events. fd can be either an integer, or an object with a `fileno()` method\nthat returns an integer. File objects implement `fileno()`, so they can also\nbe used as the argument.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "select.devpoll.unregister()", "path": "library/select#select.devpoll.unregister", "type": "Input/ouput", "text": "\nRemove a file descriptor being tracked by a polling object. Just like the\n`register()` method, fd can be an integer or an object with a `fileno()`\nmethod that returns an integer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "select.epoll()", "path": "library/select#select.epoll", "type": "Input/ouput", "text": "\n(Only supported on Linux 2.5.44 and newer.) Return an edge polling object,\nwhich can be used as Edge or Level Triggered interface for I/O events.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "select.epoll.close()", "path": "library/select#select.epoll.close", "type": "Input/ouput", "text": "\nClose the control file descriptor of the epoll object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "select.epoll.closed", "path": "library/select#select.epoll.closed", "type": "Input/ouput", "text": "\n`True` if the epoll object is closed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "select.epoll.fileno()", "path": "library/select#select.epoll.fileno", "type": "Input/ouput", "text": "\nReturn the file descriptor number of the control fd.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "select.epoll.fromfd()", "path": "library/select#select.epoll.fromfd", "type": "Input/ouput", "text": "\nCreate an epoll object from a given file descriptor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "select.epoll.modify()", "path": "library/select#select.epoll.modify", "type": "Input/ouput", "text": "\nModify a registered file descriptor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "select.epoll.poll()", "path": "library/select#select.epoll.poll", "type": "Input/ouput", "text": "\nWait for events. timeout in seconds (float)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "select.epoll.register()", "path": "library/select#select.epoll.register", "type": "Input/ouput", "text": "\nRegister a fd descriptor with the epoll object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "select.epoll.unregister()", "path": "library/select#select.epoll.unregister", "type": "Input/ouput", "text": "\nRemove a registered file descriptor from the epoll object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "select.error", "path": "library/select#select.error", "type": "Input/ouput", "text": "\nA deprecated alias of `OSError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "select.kevent()", "path": "library/select#select.kevent", "type": "Input/ouput", "text": "\n(Only supported on BSD.) Returns a kernel event object; see section Kevent\nObjects below for the methods supported by kevent objects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "select.kevent.data", "path": "library/select#select.kevent.data", "type": "Input/ouput", "text": "\nFilter specific data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "select.kevent.fflags", "path": "library/select#select.kevent.fflags", "type": "Input/ouput", "text": "\nFilter specific flags.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "select.kevent.filter", "path": "library/select#select.kevent.filter", "type": "Input/ouput", "text": "\nName of the kernel filter.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "select.kevent.flags", "path": "library/select#select.kevent.flags", "type": "Input/ouput", "text": "\nFilter action.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "select.kevent.ident", "path": "library/select#select.kevent.ident", "type": "Input/ouput", "text": "\nValue used to identify the event. The interpretation depends on the filter but\nit\u2019s usually the file descriptor. In the constructor ident can either be an\nint or an object with a `fileno()` method. kevent stores the integer\ninternally.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "select.kevent.udata", "path": "library/select#select.kevent.udata", "type": "Input/ouput", "text": "\nUser defined value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "select.kqueue()", "path": "library/select#select.kqueue", "type": "Input/ouput", "text": "\n(Only supported on BSD.) Returns a kernel queue object; see section Kqueue\nObjects below for the methods supported by kqueue objects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "select.kqueue.close()", "path": "library/select#select.kqueue.close", "type": "Input/ouput", "text": "\nClose the control file descriptor of the kqueue object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "select.kqueue.closed", "path": "library/select#select.kqueue.closed", "type": "Input/ouput", "text": "\n`True` if the kqueue object is closed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "select.kqueue.control()", "path": "library/select#select.kqueue.control", "type": "Input/ouput", "text": "\nLow level interface to kevent\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "select.kqueue.fileno()", "path": "library/select#select.kqueue.fileno", "type": "Input/ouput", "text": "\nReturn the file descriptor number of the control fd.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "select.kqueue.fromfd()", "path": "library/select#select.kqueue.fromfd", "type": "Input/ouput", "text": "\nCreate a kqueue object from a given file descriptor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "select.PIPE_BUF", "path": "library/select#select.PIPE_BUF", "type": "Input/ouput", "text": "\nThe minimum number of bytes which can be written without blocking to a pipe\nwhen the pipe has been reported as ready for writing by `select()`, `poll()`\nor another interface in this module. This doesn\u2019t apply to other kind of file-\nlike objects such as sockets.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "select.poll()", "path": "library/select#select.poll", "type": "Input/ouput", "text": "\n(Not supported by all operating systems.) Returns a polling object, which\nsupports registering and unregistering file descriptors, and then polling them\nfor I/O events; see section Polling Objects below for the methods supported by\npolling objects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "select.poll.modify()", "path": "library/select#select.poll.modify", "type": "Input/ouput", "text": "\nModifies an already registered fd. This has the same effect as `register(fd,\neventmask)`. Attempting to modify a file descriptor that was never registered\ncauses an `OSError` exception with errno `ENOENT` to be raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "select.poll.poll()", "path": "library/select#select.poll.poll", "type": "Input/ouput", "text": "\nPolls the set of registered file descriptors, and returns a possibly-empty\nlist containing `(fd, event)` 2-tuples for the descriptors that have events or\nerrors to report. fd is the file descriptor, and event is a bitmask with bits\nset for the reported events for that descriptor \u2014 `POLLIN` for waiting input,\n`POLLOUT` to indicate that the descriptor can be written to, and so forth. An\nempty list indicates that the call timed out and no file descriptors had any\nevents to report. If timeout is given, it specifies the length of time in\nmilliseconds which the system will wait for events before returning. If\ntimeout is omitted, negative, or `None`, the call will block until there is an\nevent for this poll object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "select.poll.register()", "path": "library/select#select.poll.register", "type": "Input/ouput", "text": "\nRegister a file descriptor with the polling object. Future calls to the\n`poll()` method will then check whether the file descriptor has any pending\nI/O events. fd can be either an integer, or an object with a `fileno()` method\nthat returns an integer. File objects implement `fileno()`, so they can also\nbe used as the argument.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "select.poll.unregister()", "path": "library/select#select.poll.unregister", "type": "Input/ouput", "text": "\nRemove a file descriptor being tracked by a polling object. Just like the\n`register()` method, fd can be an integer or an object with a `fileno()`\nmethod that returns an integer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "select.select()", "path": "library/select#select.select", "type": "Input/ouput", "text": "\nThis is a straightforward interface to the Unix `select()` system call. The\nfirst three arguments are iterables of \u2018waitable objects\u2019: either integers\nrepresenting file descriptors or objects with a parameterless method named\n`fileno()` returning such an integer:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "selectors", "path": "library/selectors", "type": "Input/ouput", "text": "\nNew in version 3.4.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "selectors.BaseSelector", "path": "library/selectors#selectors.BaseSelector", "type": "Input/ouput", "text": "\nA `BaseSelector` is used to wait for I/O event readiness on multiple file\nobjects. It supports file stream registration, unregistration, and a method to\nwait for I/O events on those streams, with an optional timeout. It\u2019s an\nabstract base class, so cannot be instantiated. Use `DefaultSelector` instead,\nor one of `SelectSelector`, `KqueueSelector` etc. if you want to specifically\nuse an implementation, and your platform supports it. `BaseSelector` and its\nconcrete implementations support the context manager protocol.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "selectors.BaseSelector.close()", "path": "library/selectors#selectors.BaseSelector.close", "type": "Input/ouput", "text": "\nClose the selector.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "selectors.BaseSelector.get_key()", "path": "library/selectors#selectors.BaseSelector.get_key", "type": "Input/ouput", "text": "\nReturn the key associated with a registered file object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "selectors.BaseSelector.get_map()", "path": "library/selectors#selectors.BaseSelector.get_map", "type": "Input/ouput", "text": "\nReturn a mapping of file objects to selector keys.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "selectors.BaseSelector.modify()", "path": "library/selectors#selectors.BaseSelector.modify", "type": "Input/ouput", "text": "\nChange a registered file object\u2019s monitored events or attached data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "selectors.BaseSelector.register()", "path": "library/selectors#selectors.BaseSelector.register", "type": "Input/ouput", "text": "\nRegister a file object for selection, monitoring it for I/O events.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "selectors.BaseSelector.select()", "path": "library/selectors#selectors.BaseSelector.select", "type": "Input/ouput", "text": "\nWait until some registered file objects become ready, or the timeout expires.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "selectors.BaseSelector.unregister()", "path": "library/selectors#selectors.BaseSelector.unregister", "type": "Input/ouput", "text": "\nUnregister a file object from selection, removing it from monitoring. A file\nobject shall be unregistered prior to being closed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "selectors.DefaultSelector", "path": "library/selectors#selectors.DefaultSelector", "type": "Input/ouput", "text": "\nThe default selector class, using the most efficient implementation available\non the current platform. This should be the default choice for most users.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "selectors.DevpollSelector", "path": "library/selectors#selectors.DevpollSelector", "type": "Input/ouput", "text": "\n`select.devpoll()`-based selector.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "selectors.DevpollSelector.fileno()", "path": "library/selectors#selectors.DevpollSelector.fileno", "type": "Input/ouput", "text": "\nThis returns the file descriptor used by the underlying `select.devpoll()`\nobject.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "selectors.EpollSelector", "path": "library/selectors#selectors.EpollSelector", "type": "Input/ouput", "text": "\n`select.epoll()`-based selector.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "selectors.EpollSelector.fileno()", "path": "library/selectors#selectors.EpollSelector.fileno", "type": "Input/ouput", "text": "\nThis returns the file descriptor used by the underlying `select.epoll()`\nobject.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "selectors.KqueueSelector", "path": "library/selectors#selectors.KqueueSelector", "type": "Input/ouput", "text": "\n`select.kqueue()`-based selector.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "selectors.KqueueSelector.fileno()", "path": "library/selectors#selectors.KqueueSelector.fileno", "type": "Input/ouput", "text": "\nThis returns the file descriptor used by the underlying `select.kqueue()`\nobject.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "selectors.PollSelector", "path": "library/selectors#selectors.PollSelector", "type": "Input/ouput", "text": "\n`select.poll()`-based selector.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "selectors.SelectorKey", "path": "library/selectors#selectors.SelectorKey", "type": "Input/ouput", "text": "\nA `SelectorKey` is a `namedtuple` used to associate a file object to its\nunderlying file descriptor, selected event mask and attached data. It is\nreturned by several `BaseSelector` methods.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "selectors.SelectorKey.data", "path": "library/selectors#selectors.SelectorKey.data", "type": "Input/ouput", "text": "\nOptional opaque data associated to this file object: for example, this could\nbe used to store a per-client session ID.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "selectors.SelectorKey.events", "path": "library/selectors#selectors.SelectorKey.events", "type": "Input/ouput", "text": "\nEvents that must be waited for on this file object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "selectors.SelectorKey.fd", "path": "library/selectors#selectors.SelectorKey.fd", "type": "Input/ouput", "text": "\nUnderlying file descriptor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "selectors.SelectorKey.fileobj", "path": "library/selectors#selectors.SelectorKey.fileobj", "type": "Input/ouput", "text": "\nFile object registered.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "selectors.SelectSelector", "path": "library/selectors#selectors.SelectSelector", "type": "Input/ouput", "text": "\n`select.select()`-based selector.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "set", "path": "library/functions#set", "type": "Built-in Functions", "text": "\nReturn a new `set` object, optionally with elements taken from iterable. `set`\nis a built-in class. See `set` and Set Types \u2014 set, frozenset for\ndocumentation about this class.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "set", "path": "library/stdtypes#set", "type": "Built-in Types", "text": "\nReturn a new set or frozenset object whose elements are taken from iterable.\nThe elements of a set must be hashable. To represent sets of sets, the inner\nsets must be `frozenset` objects. If iterable is not specified, a new empty\nset is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "setattr()", "path": "library/functions#setattr", "type": "Built-in Functions", "text": "\nThis is the counterpart of `getattr()`. The arguments are an object, a string\nand an arbitrary value. The string may name an existing attribute or a new\nattribute. The function assigns the value to the attribute, provided the\nobject allows it. For example, `setattr(x, 'foobar', 123)` is equivalent to\n`x.foobar = 123`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shelve", "path": "library/shelve", "type": "Data Persistence", "text": "\nSource code: Lib/shelve.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shelve.BsdDbShelf", "path": "library/shelve#shelve.BsdDbShelf", "type": "Data Persistence", "text": "\nA subclass of `Shelf` which exposes `first()`, `next()`, `previous()`,\n`last()` and `set_location()` which are available in the third-party `bsddb`\nmodule from pybsddb but not in other database modules. The dict object passed\nto the constructor must support those methods. This is generally accomplished\nby calling one of `bsddb.hashopen()`, `bsddb.btopen()` or `bsddb.rnopen()`.\nThe optional protocol, writeback, and keyencoding parameters have the same\ninterpretation as for the `Shelf` class.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shelve.DbfilenameShelf", "path": "library/shelve#shelve.DbfilenameShelf", "type": "Data Persistence", "text": "\nA subclass of `Shelf` which accepts a filename instead of a dict-like object.\nThe underlying file will be opened using `dbm.open()`. By default, the file\nwill be created and opened for both read and write. The optional flag\nparameter has the same interpretation as for the `open()` function. The\noptional protocol and writeback parameters have the same interpretation as for\nthe `Shelf` class.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shelve.open()", "path": "library/shelve#shelve.open", "type": "Data Persistence", "text": "\nOpen a persistent dictionary. The filename specified is the base filename for\nthe underlying database. As a side-effect, an extension may be added to the\nfilename and more than one file may be created. By default, the underlying\ndatabase file is opened for reading and writing. The optional flag parameter\nhas the same interpretation as the flag parameter of `dbm.open()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shelve.Shelf", "path": "library/shelve#shelve.Shelf", "type": "Data Persistence", "text": "\nA subclass of `collections.abc.MutableMapping` which stores pickled values in\nthe dict object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shelve.Shelf.close()", "path": "library/shelve#shelve.Shelf.close", "type": "Data Persistence", "text": "\nSynchronize and close the persistent dict object. Operations on a closed shelf\nwill fail with a `ValueError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shelve.Shelf.sync()", "path": "library/shelve#shelve.Shelf.sync", "type": "Data Persistence", "text": "\nWrite back all entries in the cache if the shelf was opened with writeback set\nto `True`. Also empty the cache and synchronize the persistent dictionary on\ndisk, if feasible. This is called automatically when the shelf is closed with\n`close()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shlex", "path": "library/shlex", "type": "Frameworks", "text": "\nSource code: Lib/shlex.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shlex.join()", "path": "library/shlex#shlex.join", "type": "Frameworks", "text": "\nConcatenate the tokens of the list split_command and return a string. This\nfunction is the inverse of `split()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shlex.quote()", "path": "library/shlex#shlex.quote", "type": "Frameworks", "text": "\nReturn a shell-escaped version of the string s. The returned value is a string\nthat can safely be used as one token in a shell command line, for cases where\nyou cannot use a list.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shlex.shlex", "path": "library/shlex#shlex.shlex", "type": "Frameworks", "text": "\nA `shlex` instance or subclass instance is a lexical analyzer object. The\ninitialization argument, if present, specifies where to read characters from.\nIt must be a file-/stream-like object with `read()` and `readline()` methods,\nor a string. If no argument is given, input will be taken from `sys.stdin`.\nThe second optional argument is a filename string, which sets the initial\nvalue of the `infile` attribute. If the instream argument is omitted or equal\nto `sys.stdin`, this second argument defaults to \u201cstdin\u201d. The posix argument\ndefines the operational mode: when posix is not true (default), the `shlex`\ninstance will operate in compatibility mode. When operating in POSIX mode,\n`shlex` will try to be as close as possible to the POSIX shell parsing rules.\nThe punctuation_chars argument provides a way to make the behaviour even\ncloser to how real shells parse. This can take a number of values: the default\nvalue, `False`, preserves the behaviour seen under Python 3.5 and earlier. If\nset to `True`, then parsing of the characters `();<>|&` is changed: any run of\nthese characters (considered punctuation characters) is returned as a single\ntoken. If set to a non-empty string of characters, those characters will be\nused as the punctuation characters. Any characters in the `wordchars`\nattribute that appear in punctuation_chars will be removed from `wordchars`.\nSee Improved Compatibility with Shells for more information. punctuation_chars\ncan be set only upon `shlex` instance creation and can\u2019t be modified later.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shlex.shlex.commenters", "path": "library/shlex#shlex.shlex.commenters", "type": "Frameworks", "text": "\nThe string of characters that are recognized as comment beginners. All\ncharacters from the comment beginner to end of line are ignored. Includes just\n`'#'` by default.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shlex.shlex.debug", "path": "library/shlex#shlex.shlex.debug", "type": "Frameworks", "text": "\nIf this attribute is numeric and `1` or more, a `shlex` instance will print\nverbose progress output on its behavior. If you need to use this, you can read\nthe module source code to learn the details.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shlex.shlex.eof", "path": "library/shlex#shlex.shlex.eof", "type": "Frameworks", "text": "\nToken used to determine end of file. This will be set to the empty string\n(`''`), in non-POSIX mode, and to `None` in POSIX mode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shlex.shlex.error_leader()", "path": "library/shlex#shlex.shlex.error_leader", "type": "Frameworks", "text": "\nThis method generates an error message leader in the format of a Unix C\ncompiler error label; the format is `'\"%s\", line %d: '`, where the `%s` is\nreplaced with the name of the current source file and the `%d` with the\ncurrent input line number (the optional arguments can be used to override\nthese).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shlex.shlex.escape", "path": "library/shlex#shlex.shlex.escape", "type": "Frameworks", "text": "\nCharacters that will be considered as escape. This will be only used in POSIX\nmode, and includes just `'\\'` by default.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shlex.shlex.escapedquotes", "path": "library/shlex#shlex.shlex.escapedquotes", "type": "Frameworks", "text": "\nCharacters in `quotes` that will interpret escape characters defined in\n`escape`. This is only used in POSIX mode, and includes just `'\"'` by default.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shlex.shlex.get_token()", "path": "library/shlex#shlex.shlex.get_token", "type": "Frameworks", "text": "\nReturn a token. If tokens have been stacked using `push_token()`, pop a token\noff the stack. Otherwise, read one from the input stream. If reading\nencounters an immediate end-of-file, `eof` is returned (the empty string\n(`''`) in non-POSIX mode, and `None` in POSIX mode).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shlex.shlex.infile", "path": "library/shlex#shlex.shlex.infile", "type": "Frameworks", "text": "\nThe name of the current input file, as initially set at class instantiation\ntime or stacked by later source requests. It may be useful to examine this\nwhen constructing error messages.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shlex.shlex.instream", "path": "library/shlex#shlex.shlex.instream", "type": "Frameworks", "text": "\nThe input stream from which this `shlex` instance is reading characters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shlex.shlex.lineno", "path": "library/shlex#shlex.shlex.lineno", "type": "Frameworks", "text": "\nSource line number (count of newlines seen so far plus one).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shlex.shlex.pop_source()", "path": "library/shlex#shlex.shlex.pop_source", "type": "Frameworks", "text": "\nPop the last-pushed input source from the input stack. This is the same method\nused internally when the lexer reaches EOF on a stacked input stream.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shlex.shlex.punctuation_chars", "path": "library/shlex#shlex.shlex.punctuation_chars", "type": "Frameworks", "text": "\nA read-only property. Characters that will be considered punctuation. Runs of\npunctuation characters will be returned as a single token. However, note that\nno semantic validity checking will be performed: for example, \u2018>>>\u2019 could be\nreturned as a token, even though it may not be recognised as such by shells.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shlex.shlex.push_source()", "path": "library/shlex#shlex.shlex.push_source", "type": "Frameworks", "text": "\nPush an input source stream onto the input stack. If the filename argument is\nspecified it will later be available for use in error messages. This is the\nsame method used internally by the `sourcehook()` method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shlex.shlex.push_token()", "path": "library/shlex#shlex.shlex.push_token", "type": "Frameworks", "text": "\nPush the argument onto the token stack.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shlex.shlex.quotes", "path": "library/shlex#shlex.shlex.quotes", "type": "Frameworks", "text": "\nCharacters that will be considered string quotes. The token accumulates until\nthe same quote is encountered again (thus, different quote types protect each\nother as in the shell.) By default, includes ASCII single and double quotes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shlex.shlex.read_token()", "path": "library/shlex#shlex.shlex.read_token", "type": "Frameworks", "text": "\nRead a raw token. Ignore the pushback stack, and do not interpret source\nrequests. (This is not ordinarily a useful entry point, and is documented here\nonly for the sake of completeness.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shlex.shlex.source", "path": "library/shlex#shlex.shlex.source", "type": "Frameworks", "text": "\nThis attribute is `None` by default. If you assign a string to it, that string\nwill be recognized as a lexical-level inclusion request similar to the\n`source` keyword in various shells. That is, the immediately following token\nwill be opened as a filename and input will be taken from that stream until\nEOF, at which point the `close()` method of that stream will be called and the\ninput source will again become the original input stream. Source requests may\nbe stacked any number of levels deep.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shlex.shlex.sourcehook()", "path": "library/shlex#shlex.shlex.sourcehook", "type": "Frameworks", "text": "\nWhen `shlex` detects a source request (see `source` below) this method is\ngiven the following token as argument, and expected to return a tuple\nconsisting of a filename and an open file-like object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shlex.shlex.token", "path": "library/shlex#shlex.shlex.token", "type": "Frameworks", "text": "\nThe token buffer. It may be useful to examine this when catching exceptions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shlex.shlex.whitespace", "path": "library/shlex#shlex.shlex.whitespace", "type": "Frameworks", "text": "\nCharacters that will be considered whitespace and skipped. Whitespace bounds\ntokens. By default, includes space, tab, linefeed and carriage-return.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shlex.shlex.whitespace_split", "path": "library/shlex#shlex.shlex.whitespace_split", "type": "Frameworks", "text": "\nIf `True`, tokens will only be split in whitespaces. This is useful, for\nexample, for parsing command lines with `shlex`, getting tokens in a similar\nway to shell arguments. When used in combination with `punctuation_chars`,\ntokens will be split on whitespace in addition to those characters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shlex.shlex.wordchars", "path": "library/shlex#shlex.shlex.wordchars", "type": "Frameworks", "text": "\nThe string of characters that will accumulate into multi-character tokens. By\ndefault, includes all ASCII alphanumerics and underscore. In POSIX mode, the\naccented characters in the Latin-1 set are also included. If\n`punctuation_chars` is not empty, the characters `~-./*?=`, which can appear\nin filename specifications and command line parameters, will also be included\nin this attribute, and any characters which appear in `punctuation_chars` will\nbe removed from `wordchars` if they are present there. If `whitespace_split`\nis set to `True`, this will have no effect.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shlex.split()", "path": "library/shlex#shlex.split", "type": "Frameworks", "text": "\nSplit the string s using shell-like syntax. If comments is `False` (the\ndefault), the parsing of comments in the given string will be disabled\n(setting the `commenters` attribute of the `shlex` instance to the empty\nstring). This function operates in POSIX mode by default, but uses non-POSIX\nmode if the posix argument is false.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shutil", "path": "library/shutil", "type": "File & Directory Access", "text": "\nSource code: Lib/shutil.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shutil.chown()", "path": "library/shutil#shutil.chown", "type": "File & Directory Access", "text": "\nChange owner user and/or group of the given path.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shutil.copy()", "path": "library/shutil#shutil.copy", "type": "File & Directory Access", "text": "\nCopies the file src to the file or directory dst. src and dst should be path-\nlike objects or strings. If dst specifies a directory, the file will be copied\ninto dst using the base filename from src. Returns the path to the newly\ncreated file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shutil.copy2()", "path": "library/shutil#shutil.copy2", "type": "File & Directory Access", "text": "\nIdentical to `copy()` except that `copy2()` also attempts to preserve file\nmetadata.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shutil.copyfile()", "path": "library/shutil#shutil.copyfile", "type": "File & Directory Access", "text": "\nCopy the contents (no metadata) of the file named src to a file named dst and\nreturn dst in the most efficient way possible. src and dst are path-like\nobjects or path names given as strings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shutil.copyfileobj()", "path": "library/shutil#shutil.copyfileobj", "type": "File & Directory Access", "text": "\nCopy the contents of the file-like object fsrc to the file-like object fdst.\nThe integer length, if given, is the buffer size. In particular, a negative\nlength value means to copy the data without looping over the source data in\nchunks; by default the data is read in chunks to avoid uncontrolled memory\nconsumption. Note that if the current file position of the fsrc object is not\n0, only the contents from the current file position to the end of the file\nwill be copied.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shutil.copymode()", "path": "library/shutil#shutil.copymode", "type": "File & Directory Access", "text": "\nCopy the permission bits from src to dst. The file contents, owner, and group\nare unaffected. src and dst are path-like objects or path names given as\nstrings. If follow_symlinks is false, and both src and dst are symbolic links,\n`copymode()` will attempt to modify the mode of dst itself (rather than the\nfile it points to). This functionality is not available on every platform;\nplease see `copystat()` for more information. If `copymode()` cannot modify\nsymbolic links on the local platform, and it is asked to do so, it will do\nnothing and return.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shutil.copystat()", "path": "library/shutil#shutil.copystat", "type": "File & Directory Access", "text": "\nCopy the permission bits, last access time, last modification time, and flags\nfrom src to dst. On Linux, `copystat()` also copies the \u201cextended attributes\u201d\nwhere possible. The file contents, owner, and group are unaffected. src and\ndst are path-like objects or path names given as strings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shutil.copytree()", "path": "library/shutil#shutil.copytree", "type": "File & Directory Access", "text": "\nRecursively copy an entire directory tree rooted at src to a directory named\ndst and return the destination directory. dirs_exist_ok dictates whether to\nraise an exception in case dst or any missing parent directory already exists.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shutil.disk_usage()", "path": "library/shutil#shutil.disk_usage", "type": "File & Directory Access", "text": "\nReturn disk usage statistics about the given path as a named tuple with the\nattributes total, used and free, which are the amount of total, used and free\nspace, in bytes. path may be a file or a directory.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shutil.Error", "path": "library/shutil#shutil.Error", "type": "File & Directory Access", "text": "\nThis exception collects exceptions that are raised during a multi-file\noperation. For `copytree()`, the exception argument is a list of 3-tuples\n(srcname, dstname, exception).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shutil.get_archive_formats()", "path": "library/shutil#shutil.get_archive_formats", "type": "File & Directory Access", "text": "\nReturn a list of supported formats for archiving. Each element of the returned\nsequence is a tuple `(name, description)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shutil.get_terminal_size()", "path": "library/shutil#shutil.get_terminal_size", "type": "File & Directory Access", "text": "\nGet the size of the terminal window.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shutil.get_unpack_formats()", "path": "library/shutil#shutil.get_unpack_formats", "type": "File & Directory Access", "text": "\nReturn a list of all registered formats for unpacking. Each element of the\nreturned sequence is a tuple `(name, extensions, description)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shutil.ignore_patterns()", "path": "library/shutil#shutil.ignore_patterns", "type": "File & Directory Access", "text": "\nThis factory function creates a function that can be used as a callable for\n`copytree()`\u2019s ignore argument, ignoring files and directories that match one\nof the glob-style patterns provided. See the example below.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shutil.make_archive()", "path": "library/shutil#shutil.make_archive", "type": "File & Directory Access", "text": "\nCreate an archive file (such as zip or tar) and return its name.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shutil.move()", "path": "library/shutil#shutil.move", "type": "File & Directory Access", "text": "\nRecursively move a file or directory (src) to another location (dst) and\nreturn the destination.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shutil.register_archive_format()", "path": "library/shutil#shutil.register_archive_format", "type": "File & Directory Access", "text": "\nRegister an archiver for the format name.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shutil.register_unpack_format()", "path": "library/shutil#shutil.register_unpack_format", "type": "File & Directory Access", "text": "\nRegisters an unpack format. name is the name of the format and extensions is a\nlist of extensions corresponding to the format, like `.zip` for Zip files.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shutil.rmtree()", "path": "library/shutil#shutil.rmtree", "type": "File & Directory Access", "text": "\nDelete an entire directory tree; path must point to a directory (but not a\nsymbolic link to a directory). If ignore_errors is true, errors resulting from\nfailed removals will be ignored; if false or omitted, such errors are handled\nby calling a handler specified by onerror or, if that is omitted, they raise\nan exception.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shutil.rmtree.avoids_symlink_attacks", "path": "library/shutil#shutil.rmtree.avoids_symlink_attacks", "type": "File & Directory Access", "text": "\nIndicates whether the current platform and implementation provides a symlink\nattack resistant version of `rmtree()`. Currently this is only true for\nplatforms supporting fd-based directory access functions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shutil.SameFileError", "path": "library/shutil#shutil.SameFileError", "type": "File & Directory Access", "text": "\nThis exception is raised if source and destination in `copyfile()` are the\nsame file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shutil.unpack_archive()", "path": "library/shutil#shutil.unpack_archive", "type": "File & Directory Access", "text": "\nUnpack an archive. filename is the full path of the archive.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shutil.unregister_archive_format()", "path": "library/shutil#shutil.unregister_archive_format", "type": "File & Directory Access", "text": "\nRemove the archive format name from the list of supported formats.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shutil.unregister_unpack_format()", "path": "library/shutil#shutil.unregister_unpack_format", "type": "File & Directory Access", "text": "\nUnregister an unpack format. name is the name of the format.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "shutil.which()", "path": "library/shutil#shutil.which", "type": "File & Directory Access", "text": "\nReturn the path to an executable which would be run if the given cmd was\ncalled. If no cmd would be called, return `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal", "path": "library/signal", "type": "Networking & Interprocess Communication", "text": "\nThis module provides mechanisms to use signal handlers in Python.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.alarm()", "path": "library/signal#signal.alarm", "type": "Networking & Interprocess Communication", "text": "\nIf time is non-zero, this function requests that a `SIGALRM` signal be sent to\nthe process in time seconds. Any previously scheduled alarm is canceled (only\none alarm can be scheduled at any time). The returned value is then the number\nof seconds before any previously set alarm was to have been delivered. If time\nis zero, no alarm is scheduled, and any scheduled alarm is canceled. If the\nreturn value is zero, no alarm is currently scheduled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.CTRL_BREAK_EVENT", "path": "library/signal#signal.CTRL_BREAK_EVENT", "type": "Networking & Interprocess Communication", "text": "\nThe signal corresponding to the `Ctrl+Break` keystroke event. This signal can\nonly be used with `os.kill()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.CTRL_C_EVENT", "path": "library/signal#signal.CTRL_C_EVENT", "type": "Networking & Interprocess Communication", "text": "\nThe signal corresponding to the `Ctrl+C` keystroke event. This signal can only\nbe used with `os.kill()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.getitimer()", "path": "library/signal#signal.getitimer", "type": "Networking & Interprocess Communication", "text": "\nReturns current value of a given interval timer specified by which.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.getsignal()", "path": "library/signal#signal.getsignal", "type": "Networking & Interprocess Communication", "text": "\nReturn the current signal handler for the signal signalnum. The returned value\nmay be a callable Python object, or one of the special values\n`signal.SIG_IGN`, `signal.SIG_DFL` or `None`. Here, `signal.SIG_IGN` means\nthat the signal was previously ignored, `signal.SIG_DFL` means that the\ndefault way of handling the signal was previously in use, and `None` means\nthat the previous signal handler was not installed from Python.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.ItimerError", "path": "library/signal#signal.ItimerError", "type": "Networking & Interprocess Communication", "text": "\nRaised to signal an error from the underlying `setitimer()` or `getitimer()`\nimplementation. Expect this error if an invalid interval timer or a negative\ntime is passed to `setitimer()`. This error is a subtype of `OSError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.ITIMER_PROF", "path": "library/signal#signal.ITIMER_PROF", "type": "Networking & Interprocess Communication", "text": "\nDecrements interval timer both when the process executes and when the system\nis executing on behalf of the process. Coupled with ITIMER_VIRTUAL, this timer\nis usually used to profile the time spent by the application in user and\nkernel space. SIGPROF is delivered upon expiration.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.ITIMER_REAL", "path": "library/signal#signal.ITIMER_REAL", "type": "Networking & Interprocess Communication", "text": "\nDecrements interval timer in real time, and delivers `SIGALRM` upon\nexpiration.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.ITIMER_VIRTUAL", "path": "library/signal#signal.ITIMER_VIRTUAL", "type": "Networking & Interprocess Communication", "text": "\nDecrements interval timer only when the process is executing, and delivers\nSIGVTALRM upon expiration.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.NSIG", "path": "library/signal#signal.NSIG", "type": "Networking & Interprocess Communication", "text": "\nOne more than the number of the highest signal number.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.pause()", "path": "library/signal#signal.pause", "type": "Networking & Interprocess Communication", "text": "\nCause the process to sleep until a signal is received; the appropriate handler\nwill then be called. Returns nothing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.pidfd_send_signal()", "path": "library/signal#signal.pidfd_send_signal", "type": "Networking & Interprocess Communication", "text": "\nSend signal sig to the process referred to by file descriptor pidfd. Python\ndoes not currently support the siginfo parameter; it must be `None`. The flags\nargument is provided for future extensions; no flag values are currently\ndefined.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.pthread_kill()", "path": "library/signal#signal.pthread_kill", "type": "Networking & Interprocess Communication", "text": "\nSend the signal signalnum to the thread thread_id, another thread in the same\nprocess as the caller. The target thread can be executing any code (Python or\nnot). However, if the target thread is executing the Python interpreter, the\nPython signal handlers will be executed by the main thread of the main\ninterpreter. Therefore, the only point of sending a signal to a particular\nPython thread would be to force a running system call to fail with\n`InterruptedError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.pthread_sigmask()", "path": "library/signal#signal.pthread_sigmask", "type": "Networking & Interprocess Communication", "text": "\nFetch and/or change the signal mask of the calling thread. The signal mask is\nthe set of signals whose delivery is currently blocked for the caller. Return\nthe old signal mask as a set of signals.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.raise_signal()", "path": "library/signal#signal.raise_signal", "type": "Networking & Interprocess Communication", "text": "\nSends a signal to the calling process. Returns nothing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.setitimer()", "path": "library/signal#signal.setitimer", "type": "Networking & Interprocess Communication", "text": "\nSets given interval timer (one of `signal.ITIMER_REAL`,\n`signal.ITIMER_VIRTUAL` or `signal.ITIMER_PROF`) specified by which to fire\nafter seconds (float is accepted, different from `alarm()`) and after that\nevery interval seconds (if interval is non-zero). The interval timer specified\nby which can be cleared by setting seconds to zero.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.set_wakeup_fd()", "path": "library/signal#signal.set_wakeup_fd", "type": "Networking & Interprocess Communication", "text": "\nSet the wakeup file descriptor to fd. When a signal is received, the signal\nnumber is written as a single byte into the fd. This can be used by a library\nto wakeup a poll or select call, allowing the signal to be fully processed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.SIGABRT", "path": "library/signal#signal.SIGABRT", "type": "Networking & Interprocess Communication", "text": "\nAbort signal from abort(3).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.SIGALRM", "path": "library/signal#signal.SIGALRM", "type": "Networking & Interprocess Communication", "text": "\nTimer signal from alarm(2).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.SIGBREAK", "path": "library/signal#signal.SIGBREAK", "type": "Networking & Interprocess Communication", "text": "\nInterrupt from keyboard (CTRL + BREAK).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.SIGBUS", "path": "library/signal#signal.SIGBUS", "type": "Networking & Interprocess Communication", "text": "\nBus error (bad memory access).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.SIGCHLD", "path": "library/signal#signal.SIGCHLD", "type": "Networking & Interprocess Communication", "text": "\nChild process stopped or terminated.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.SIGCLD", "path": "library/signal#signal.SIGCLD", "type": "Networking & Interprocess Communication", "text": "\nAlias to `SIGCHLD`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.SIGCONT", "path": "library/signal#signal.SIGCONT", "type": "Networking & Interprocess Communication", "text": "\nContinue the process if it is currently stopped\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.SIGFPE", "path": "library/signal#signal.SIGFPE", "type": "Networking & Interprocess Communication", "text": "\nFloating-point exception. For example, division by zero.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.SIGHUP", "path": "library/signal#signal.SIGHUP", "type": "Networking & Interprocess Communication", "text": "\nHangup detected on controlling terminal or death of controlling process.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.SIGILL", "path": "library/signal#signal.SIGILL", "type": "Networking & Interprocess Communication", "text": "\nIllegal instruction.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.SIGINT", "path": "library/signal#signal.SIGINT", "type": "Networking & Interprocess Communication", "text": "\nInterrupt from keyboard (CTRL + C).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.siginterrupt()", "path": "library/signal#signal.siginterrupt", "type": "Networking & Interprocess Communication", "text": "\nChange system call restart behaviour: if flag is `False`, system calls will be\nrestarted when interrupted by signal signalnum, otherwise system calls will be\ninterrupted. Returns nothing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.SIGKILL", "path": "library/signal#signal.SIGKILL", "type": "Networking & Interprocess Communication", "text": "\nKill signal.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.signal()", "path": "library/signal#signal.signal", "type": "Networking & Interprocess Communication", "text": "\nSet the handler for signal signalnum to the function handler. handler can be a\ncallable Python object taking two arguments (see below), or one of the special\nvalues `signal.SIG_IGN` or `signal.SIG_DFL`. The previous signal handler will\nbe returned (see the description of `getsignal()` above). (See the Unix man\npage signal(2) for further information.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.sigpending()", "path": "library/signal#signal.sigpending", "type": "Networking & Interprocess Communication", "text": "\nExamine the set of signals that are pending for delivery to the calling thread\n(i.e., the signals which have been raised while blocked). Return the set of\nthe pending signals.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.SIGPIPE", "path": "library/signal#signal.SIGPIPE", "type": "Networking & Interprocess Communication", "text": "\nBroken pipe: write to pipe with no readers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.SIGSEGV", "path": "library/signal#signal.SIGSEGV", "type": "Networking & Interprocess Communication", "text": "\nSegmentation fault: invalid memory reference.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.SIGTERM", "path": "library/signal#signal.SIGTERM", "type": "Networking & Interprocess Communication", "text": "\nTermination signal.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.sigtimedwait()", "path": "library/signal#signal.sigtimedwait", "type": "Networking & Interprocess Communication", "text": "\nLike `sigwaitinfo()`, but takes an additional timeout argument specifying a\ntimeout. If timeout is specified as `0`, a poll is performed. Returns `None`\nif a timeout occurs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.SIGUSR1", "path": "library/signal#signal.SIGUSR1", "type": "Networking & Interprocess Communication", "text": "\nUser-defined signal 1.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.SIGUSR2", "path": "library/signal#signal.SIGUSR2", "type": "Networking & Interprocess Communication", "text": "\nUser-defined signal 2.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.sigwait()", "path": "library/signal#signal.sigwait", "type": "Networking & Interprocess Communication", "text": "\nSuspend execution of the calling thread until the delivery of one of the\nsignals specified in the signal set sigset. The function accepts the signal\n(removes it from the pending list of signals), and returns the signal number.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.sigwaitinfo()", "path": "library/signal#signal.sigwaitinfo", "type": "Networking & Interprocess Communication", "text": "\nSuspend execution of the calling thread until the delivery of one of the\nsignals specified in the signal set sigset. The function accepts the signal\nand removes it from the pending list of signals. If one of the signals in\nsigset is already pending for the calling thread, the function will return\nimmediately with information about that signal. The signal handler is not\ncalled for the delivered signal. The function raises an `InterruptedError` if\nit is interrupted by a signal that is not in sigset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.SIGWINCH", "path": "library/signal#signal.SIGWINCH", "type": "Networking & Interprocess Communication", "text": "\nWindow resize signal.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.SIG_BLOCK", "path": "library/signal#signal.SIG_BLOCK", "type": "Networking & Interprocess Communication", "text": "\nA possible value for the how parameter to `pthread_sigmask()` indicating that\nsignals are to be blocked.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.SIG_DFL", "path": "library/signal#signal.SIG_DFL", "type": "Networking & Interprocess Communication", "text": "\nThis is one of two standard signal handling options; it will simply perform\nthe default function for the signal. For example, on most systems the default\naction for `SIGQUIT` is to dump core and exit, while the default action for\n`SIGCHLD` is to simply ignore it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.SIG_IGN", "path": "library/signal#signal.SIG_IGN", "type": "Networking & Interprocess Communication", "text": "\nThis is another standard signal handler, which will simply ignore the given\nsignal.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.SIG_SETMASK", "path": "library/signal#signal.SIG_SETMASK", "type": "Networking & Interprocess Communication", "text": "\nA possible value for the how parameter to `pthread_sigmask()` indicating that\nthe signal mask is to be replaced.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.SIG_UNBLOCK", "path": "library/signal#signal.SIG_UNBLOCK", "type": "Networking & Interprocess Communication", "text": "\nA possible value for the how parameter to `pthread_sigmask()` indicating that\nsignals are to be unblocked.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.strsignal()", "path": "library/signal#signal.strsignal", "type": "Networking & Interprocess Communication", "text": "\nReturn the system description of the signal signalnum, such as \u201cInterrupt\u201d,\n\u201cSegmentation fault\u201d, etc. Returns `None` if the signal is not recognized.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "signal.valid_signals()", "path": "library/signal#signal.valid_signals", "type": "Networking & Interprocess Communication", "text": "\nReturn the set of valid signal numbers on this platform. This can be less than\n`range(1, NSIG)` if some signals are reserved by the system for internal use.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "site", "path": "library/site", "type": "Runtime", "text": "\nSource code: Lib/site.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "site.addsitedir()", "path": "library/site#site.addsitedir", "type": "Runtime", "text": "\nAdd a directory to sys.path and process its `.pth` files. Typically used in\n`sitecustomize` or `usercustomize` (see above).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "site.ENABLE_USER_SITE", "path": "library/site#site.ENABLE_USER_SITE", "type": "Runtime", "text": "\nFlag showing the status of the user site-packages directory. `True` means that\nit is enabled and was added to `sys.path`. `False` means that it was disabled\nby user request (with `-s` or `PYTHONNOUSERSITE`). `None` means it was\ndisabled for security reasons (mismatch between user or group id and effective\nid) or by an administrator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "site.getsitepackages()", "path": "library/site#site.getsitepackages", "type": "Runtime", "text": "\nReturn a list containing all global site-packages directories.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "site.getuserbase()", "path": "library/site#site.getuserbase", "type": "Runtime", "text": "\nReturn the path of the user base directory, `USER_BASE`. If it is not\ninitialized yet, this function will also set it, respecting `PYTHONUSERBASE`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "site.getusersitepackages()", "path": "library/site#site.getusersitepackages", "type": "Runtime", "text": "\nReturn the path of the user-specific site-packages directory, `USER_SITE`. If\nit is not initialized yet, this function will also set it, respecting\n`USER_BASE`. To determine if the user-specific site-packages was added to\n`sys.path` `ENABLE_USER_SITE` should be used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "site.main()", "path": "library/site#site.main", "type": "Runtime", "text": "\nAdds all the standard site-specific directories to the module search path.\nThis function is called automatically when this module is imported, unless the\nPython interpreter was started with the `-S` flag.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "site.PREFIXES", "path": "library/site#site.PREFIXES", "type": "Runtime", "text": "\nA list of prefixes for site-packages directories.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "site.USER_BASE", "path": "library/site#site.USER_BASE", "type": "Runtime", "text": "\nPath to the base directory for the user site-packages. Can be `None` if\n`getuserbase()` hasn\u2019t been called yet. Default value is `~/.local` for UNIX\nand Mac OS X non-framework builds, `~/Library/Python/X.Y` for Mac framework\nbuilds, and `%APPDATA%\\Python` for Windows. This value is used by Distutils to\ncompute the installation directories for scripts, data files, Python modules,\netc. for the user installation scheme. See also `PYTHONUSERBASE`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "site.USER_SITE", "path": "library/site#site.USER_SITE", "type": "Runtime", "text": "\nPath to the user site-packages for the running Python. Can be `None` if\n`getusersitepackages()` hasn\u2019t been called yet. Default value is\n`~/.local/lib/pythonX.Y/site-packages` for UNIX and non-framework Mac OS X\nbuilds, `~/Library/Python/X.Y/lib/python/site-packages` for Mac framework\nbuilds, and `%APPDATA%\\Python\\PythonXY\\site-packages` on Windows. This\ndirectory is a site directory, which means that `.pth` files in it will be\nprocessed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "slice", "path": "library/functions#slice", "type": "Built-in Functions", "text": "\nReturn a slice object representing the set of indices specified by\n`range(start, stop, step)`. The start and step arguments default to `None`.\nSlice objects have read-only data attributes `start`, `stop` and `step` which\nmerely return the argument values (or their default). They have no other\nexplicit functionality; however they are used by Numerical Python and other\nthird party extensions. Slice objects are also generated when extended\nindexing syntax is used. For example: `a[start:stop:step]` or `a[start:stop,\ni]`. See `itertools.islice()` for an alternate version that returns an\niterator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtpd", "path": "library/smtpd", "type": "Internet", "text": "\nSource code: Lib/smtpd.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtpd.DebuggingServer", "path": "library/smtpd#smtpd.DebuggingServer", "type": "Internet", "text": "\nCreate a new debugging server. Arguments are as per `SMTPServer`. Messages\nwill be discarded, and printed on stdout.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtpd.MailmanProxy", "path": "library/smtpd#smtpd.MailmanProxy", "type": "Internet", "text": "\nDeprecated since version 3.9, will be removed in version 3.11: `MailmanProxy`\nis deprecated, it depends on a `Mailman` module which no longer exists and\ntherefore is already broken.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtpd.PureProxy", "path": "library/smtpd#smtpd.PureProxy", "type": "Internet", "text": "\nCreate a new pure proxy server. Arguments are as per `SMTPServer`. Everything\nwill be relayed to remoteaddr. Note that running this has a good chance to\nmake you into an open relay, so please be careful.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtpd.SMTPChannel", "path": "library/smtpd#smtpd.SMTPChannel", "type": "Internet", "text": "\nCreate a new `SMTPChannel` object which manages the communication between the\nserver and a single SMTP client.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtpd.SMTPChannel.addr", "path": "library/smtpd#smtpd.SMTPChannel.addr", "type": "Internet", "text": "\nHolds the address of the client, the second value returned by `socket.accept`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtpd.SMTPChannel.conn", "path": "library/smtpd#smtpd.SMTPChannel.conn", "type": "Internet", "text": "\nHolds the socket object connecting to the client.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtpd.SMTPChannel.fqdn", "path": "library/smtpd#smtpd.SMTPChannel.fqdn", "type": "Internet", "text": "\nHolds the fully-qualified domain name of the server as returned by\n`socket.getfqdn()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtpd.SMTPChannel.mailfrom", "path": "library/smtpd#smtpd.SMTPChannel.mailfrom", "type": "Internet", "text": "\nHolds a string containing the address identified in the \u201cMAIL FROM:\u201d line from\nthe client.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtpd.SMTPChannel.peer", "path": "library/smtpd#smtpd.SMTPChannel.peer", "type": "Internet", "text": "\nHolds the name of the client peer as returned by `conn.getpeername()` where\n`conn` is `conn`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtpd.SMTPChannel.rcpttos", "path": "library/smtpd#smtpd.SMTPChannel.rcpttos", "type": "Internet", "text": "\nHolds a list of strings containing the addresses identified in the \u201cRCPT TO:\u201d\nlines from the client.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtpd.SMTPChannel.received_data", "path": "library/smtpd#smtpd.SMTPChannel.received_data", "type": "Internet", "text": "\nHolds a string containing all of the data sent by the client during the DATA\nstate, up to but not including the terminating `\"\\r\\n.\\r\\n\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtpd.SMTPChannel.received_lines", "path": "library/smtpd#smtpd.SMTPChannel.received_lines", "type": "Internet", "text": "\nHolds a list of the line strings (decoded using UTF-8) received from the\nclient. The lines have their `\"\\r\\n\"` line ending translated to `\"\\n\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtpd.SMTPChannel.seen_greeting", "path": "library/smtpd#smtpd.SMTPChannel.seen_greeting", "type": "Internet", "text": "\nHolds a string containing the greeting sent by the client in its \u201cHELO\u201d.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtpd.SMTPChannel.smtp_server", "path": "library/smtpd#smtpd.SMTPChannel.smtp_server", "type": "Internet", "text": "\nHolds the `SMTPServer` that spawned this channel.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtpd.SMTPChannel.smtp_state", "path": "library/smtpd#smtpd.SMTPChannel.smtp_state", "type": "Internet", "text": "\nHolds the current state of the channel. This will be either `COMMAND`\ninitially and then `DATA` after the client sends a \u201cDATA\u201d line.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtpd.SMTPServer", "path": "library/smtpd#smtpd.SMTPServer", "type": "Internet", "text": "\nCreate a new `SMTPServer` object, which binds to local address localaddr. It\nwill treat remoteaddr as an upstream SMTP relayer. Both localaddr and\nremoteaddr should be a (host, port) tuple. The object inherits from\n`asyncore.dispatcher`, and so will insert itself into `asyncore`\u2019s event loop\non instantiation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtpd.SMTPServer.channel_class", "path": "library/smtpd#smtpd.SMTPServer.channel_class", "type": "Internet", "text": "\nOverride this in subclasses to use a custom `SMTPChannel` for managing SMTP\nclients.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtpd.SMTPServer.process_message()", "path": "library/smtpd#smtpd.SMTPServer.process_message", "type": "Internet", "text": "\nRaise a `NotImplementedError` exception. Override this in subclasses to do\nsomething useful with this message. Whatever was passed in the constructor as\nremoteaddr will be available as the `_remoteaddr` attribute. peer is the\nremote host\u2019s address, mailfrom is the envelope originator, rcpttos are the\nenvelope recipients and data is a string containing the contents of the e-mail\n(which should be in RFC 5321 format).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtplib", "path": "library/smtplib", "type": "Internet", "text": "\nSource code: Lib/smtplib.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtplib.LMTP", "path": "library/smtplib#smtplib.LMTP", "type": "Internet", "text": "\nThe LMTP protocol, which is very similar to ESMTP, is heavily based on the\nstandard SMTP client. It\u2019s common to use Unix sockets for LMTP, so our\n`connect()` method must support that as well as a regular host:port server.\nThe optional arguments local_hostname and source_address have the same meaning\nas they do in the `SMTP` class. To specify a Unix socket, you must use an\nabsolute path for host, starting with a \u2018/\u2019.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtplib.SMTP", "path": "library/smtplib#smtplib.SMTP", "type": "Internet", "text": "\nAn `SMTP` instance encapsulates an SMTP connection. It has methods that\nsupport a full repertoire of SMTP and ESMTP operations. If the optional host\nand port parameters are given, the SMTP `connect()` method is called with\nthose parameters during initialization. If specified, local_hostname is used\nas the FQDN of the local host in the HELO/EHLO command. Otherwise, the local\nhostname is found using `socket.getfqdn()`. If the `connect()` call returns\nanything other than a success code, an `SMTPConnectError` is raised. The\noptional timeout parameter specifies a timeout in seconds for blocking\noperations like the connection attempt (if not specified, the global default\ntimeout setting will be used). If the timeout expires, `socket.timeout` is\nraised. The optional source_address parameter allows binding to some specific\nsource address in a machine with multiple network interfaces, and/or to some\nspecific source TCP port. It takes a 2-tuple (host, port), for the socket to\nbind to as its source address before connecting. If omitted (or if host or\nport are `''` and/or 0 respectively) the OS default behavior will be used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtplib.SMTP.auth()", "path": "library/smtplib#smtplib.SMTP.auth", "type": "Internet", "text": "\nIssue an `SMTP` `AUTH` command for the specified authentication mechanism, and\nhandle the challenge response via authobject.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtplib.SMTP.connect()", "path": "library/smtplib#smtplib.SMTP.connect", "type": "Internet", "text": "\nConnect to a host on a given port. The defaults are to connect to the local\nhost at the standard SMTP port (25). If the hostname ends with a colon (`':'`)\nfollowed by a number, that suffix will be stripped off and the number\ninterpreted as the port number to use. This method is automatically invoked by\nthe constructor if a host is specified during instantiation. Returns a 2-tuple\nof the response code and message sent by the server in its connection\nresponse.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtplib.SMTP.docmd()", "path": "library/smtplib#smtplib.SMTP.docmd", "type": "Internet", "text": "\nSend a command cmd to the server. The optional argument args is simply\nconcatenated to the command, separated by a space.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtplib.SMTP.ehlo()", "path": "library/smtplib#smtplib.SMTP.ehlo", "type": "Internet", "text": "\nIdentify yourself to an ESMTP server using `EHLO`. The hostname argument\ndefaults to the fully qualified domain name of the local host. Examine the\nresponse for ESMTP option and store them for use by `has_extn()`. Also sets\nseveral informational attributes: the message returned by the server is stored\nas the `ehlo_resp` attribute, `does_esmtp` is set to true or false depending\non whether the server supports ESMTP, and `esmtp_features` will be a\ndictionary containing the names of the SMTP service extensions this server\nsupports, and their parameters (if any).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtplib.SMTP.ehlo_or_helo_if_needed()", "path": "library/smtplib#smtplib.SMTP.ehlo_or_helo_if_needed", "type": "Internet", "text": "\nThis method calls `ehlo()` and/or `helo()` if there has been no previous\n`EHLO` or `HELO` command this session. It tries ESMTP `EHLO` first.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtplib.SMTP.has_extn()", "path": "library/smtplib#smtplib.SMTP.has_extn", "type": "Internet", "text": "\nReturn `True` if name is in the set of SMTP service extensions returned by the\nserver, `False` otherwise. Case is ignored.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtplib.SMTP.helo()", "path": "library/smtplib#smtplib.SMTP.helo", "type": "Internet", "text": "\nIdentify yourself to the SMTP server using `HELO`. The hostname argument\ndefaults to the fully qualified domain name of the local host. The message\nreturned by the server is stored as the `helo_resp` attribute of the object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtplib.SMTP.login()", "path": "library/smtplib#smtplib.SMTP.login", "type": "Internet", "text": "\nLog in on an SMTP server that requires authentication. The arguments are the\nusername and the password to authenticate with. If there has been no previous\n`EHLO` or `HELO` command this session, this method tries ESMTP `EHLO` first.\nThis method will return normally if the authentication was successful, or may\nraise the following exceptions:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtplib.SMTP.quit()", "path": "library/smtplib#smtplib.SMTP.quit", "type": "Internet", "text": "\nTerminate the SMTP session and close the connection. Return the result of the\nSMTP `QUIT` command.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtplib.SMTP.sendmail()", "path": "library/smtplib#smtplib.SMTP.sendmail", "type": "Internet", "text": "\nSend mail. The required arguments are an RFC 822 from-address string, a list\nof RFC 822 to-address strings (a bare string will be treated as a list with 1\naddress), and a message string. The caller may pass a list of ESMTP options\n(such as `8bitmime`) to be used in `MAIL FROM` commands as mail_options. ESMTP\noptions (such as `DSN` commands) that should be used with all `RCPT` commands\ncan be passed as rcpt_options. (If you need to use different ESMTP options to\ndifferent recipients you have to use the low-level methods such as `mail()`,\n`rcpt()` and `data()` to send the message.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtplib.SMTP.send_message()", "path": "library/smtplib#smtplib.SMTP.send_message", "type": "Internet", "text": "\nThis is a convenience method for calling `sendmail()` with the message\nrepresented by an `email.message.Message` object. The arguments have the same\nmeaning as for `sendmail()`, except that msg is a `Message` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtplib.SMTP.set_debuglevel()", "path": "library/smtplib#smtplib.SMTP.set_debuglevel", "type": "Internet", "text": "\nSet the debug output level. A value of 1 or `True` for level results in debug\nmessages for connection and for all messages sent to and received from the\nserver. A value of 2 for level results in these messages being timestamped.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtplib.SMTP.starttls()", "path": "library/smtplib#smtplib.SMTP.starttls", "type": "Internet", "text": "\nPut the SMTP connection in TLS (Transport Layer Security) mode. All SMTP\ncommands that follow will be encrypted. You should then call `ehlo()` again.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtplib.SMTP.verify()", "path": "library/smtplib#smtplib.SMTP.verify", "type": "Internet", "text": "\nCheck the validity of an address on this server using SMTP `VRFY`. Returns a\ntuple consisting of code 250 and a full RFC 822 address (including human name)\nif the user address is valid. Otherwise returns an SMTP error code of 400 or\ngreater and an error string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtplib.SMTPAuthenticationError", "path": "library/smtplib#smtplib.SMTPAuthenticationError", "type": "Internet", "text": "\nSMTP authentication went wrong. Most probably the server didn\u2019t accept the\nusername/password combination provided.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtplib.SMTPConnectError", "path": "library/smtplib#smtplib.SMTPConnectError", "type": "Internet", "text": "\nError occurred during establishment of a connection with the server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtplib.SMTPDataError", "path": "library/smtplib#smtplib.SMTPDataError", "type": "Internet", "text": "\nThe SMTP server refused to accept the message data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtplib.SMTPException", "path": "library/smtplib#smtplib.SMTPException", "type": "Internet", "text": "\nSubclass of `OSError` that is the base exception class for all the other\nexceptions provided by this module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtplib.SMTPHeloError", "path": "library/smtplib#smtplib.SMTPHeloError", "type": "Internet", "text": "\nThe server refused our `HELO` message.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtplib.SMTPNotSupportedError", "path": "library/smtplib#smtplib.SMTPNotSupportedError", "type": "Internet", "text": "\nThe command or option attempted is not supported by the server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtplib.SMTPRecipientsRefused", "path": "library/smtplib#smtplib.SMTPRecipientsRefused", "type": "Internet", "text": "\nAll recipient addresses refused. The errors for each recipient are accessible\nthrough the attribute `recipients`, which is a dictionary of exactly the same\nsort as `SMTP.sendmail()` returns.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtplib.SMTPResponseException", "path": "library/smtplib#smtplib.SMTPResponseException", "type": "Internet", "text": "\nBase class for all exceptions that include an SMTP error code. These\nexceptions are generated in some instances when the SMTP server returns an\nerror code. The error code is stored in the `smtp_code` attribute of the\nerror, and the `smtp_error` attribute is set to the error message.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtplib.SMTPSenderRefused", "path": "library/smtplib#smtplib.SMTPSenderRefused", "type": "Internet", "text": "\nSender address refused. In addition to the attributes set by on all\n`SMTPResponseException` exceptions, this sets \u2018sender\u2019 to the string that the\nSMTP server refused.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtplib.SMTPServerDisconnected", "path": "library/smtplib#smtplib.SMTPServerDisconnected", "type": "Internet", "text": "\nThis exception is raised when the server unexpectedly disconnects, or when an\nattempt is made to use the `SMTP` instance before connecting it to a server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "smtplib.SMTP_SSL", "path": "library/smtplib#smtplib.SMTP_SSL", "type": "Internet", "text": "\nAn `SMTP_SSL` instance behaves exactly the same as instances of `SMTP`.\n`SMTP_SSL` should be used for situations where SSL is required from the\nbeginning of the connection and using `starttls()` is not appropriate. If host\nis not specified, the local host is used. If port is zero, the standard SMTP-\nover-SSL port (465) is used. The optional arguments local_hostname, timeout\nand source_address have the same meaning as they do in the `SMTP` class.\ncontext, also optional, can contain a `SSLContext` and allows configuring\nvarious aspects of the secure connection. Please read Security considerations\nfor best practices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sndhdr", "path": "library/sndhdr", "type": "Multimedia", "text": "\nSource code: Lib/sndhdr.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sndhdr.what()", "path": "library/sndhdr#sndhdr.what", "type": "Multimedia", "text": "\nDetermines the type of sound data stored in the file filename using\n`whathdr()`. If it succeeds, returns a namedtuple as described above,\notherwise `None` is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sndhdr.whathdr()", "path": "library/sndhdr#sndhdr.whathdr", "type": "Multimedia", "text": "\nDetermines the type of sound data stored in a file based on the file header.\nThe name of the file is given by filename. This function returns a namedtuple\nas described above on success, or `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket", "path": "library/socket", "type": "Networking & Interprocess Communication", "text": "\nSource code: Lib/socket.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.AF_ALG", "path": "library/socket#socket.AF_ALG", "type": "Networking & Interprocess Communication", "text": "\nConstants for Linux Kernel cryptography.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.AF_CAN", "path": "library/socket#socket.AF_CAN", "type": "Networking & Interprocess Communication", "text": "\nMany constants of these forms, documented in the Linux documentation, are also\ndefined in the socket module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.AF_INET", "path": "library/socket#socket.AF_INET", "type": "Networking & Interprocess Communication", "text": "\nThese constants represent the address (and protocol) families, used for the\nfirst argument to `socket()`. If the `AF_UNIX` constant is not defined then\nthis protocol is unsupported. More constants may be available depending on the\nsystem.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.AF_INET6", "path": "library/socket#socket.AF_INET6", "type": "Networking & Interprocess Communication", "text": "\nThese constants represent the address (and protocol) families, used for the\nfirst argument to `socket()`. If the `AF_UNIX` constant is not defined then\nthis protocol is unsupported. More constants may be available depending on the\nsystem.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.AF_LINK", "path": "library/socket#socket.AF_LINK", "type": "Networking & Interprocess Communication", "text": "\nAvailability: BSD, OSX.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.AF_PACKET", "path": "library/socket#socket.AF_PACKET", "type": "Networking & Interprocess Communication", "text": "\nMany constants of these forms, documented in the Linux documentation, are also\ndefined in the socket module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.AF_QIPCRTR", "path": "library/socket#socket.AF_QIPCRTR", "type": "Networking & Interprocess Communication", "text": "\nConstant for Qualcomm\u2019s IPC router protocol, used to communicate with service\nproviding remote processors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.AF_RDS", "path": "library/socket#socket.AF_RDS", "type": "Networking & Interprocess Communication", "text": "\nMany constants of these forms, documented in the Linux documentation, are also\ndefined in the socket module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.AF_UNIX", "path": "library/socket#socket.AF_UNIX", "type": "Networking & Interprocess Communication", "text": "\nThese constants represent the address (and protocol) families, used for the\nfirst argument to `socket()`. If the `AF_UNIX` constant is not defined then\nthis protocol is unsupported. More constants may be available depending on the\nsystem.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.AF_VSOCK", "path": "library/socket#socket.AF_VSOCK", "type": "Networking & Interprocess Communication", "text": "\nConstants for Linux host/guest communication.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.BDADDR_ANY", "path": "library/socket#socket.BDADDR_ANY", "type": "Networking & Interprocess Communication", "text": "\nThese are string constants containing Bluetooth addresses with special\nmeanings. For example, `BDADDR_ANY` can be used to indicate any address when\nspecifying the binding socket with `BTPROTO_RFCOMM`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.BDADDR_LOCAL", "path": "library/socket#socket.BDADDR_LOCAL", "type": "Networking & Interprocess Communication", "text": "\nThese are string constants containing Bluetooth addresses with special\nmeanings. For example, `BDADDR_ANY` can be used to indicate any address when\nspecifying the binding socket with `BTPROTO_RFCOMM`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.CAN_BCM", "path": "library/socket#socket.CAN_BCM", "type": "Networking & Interprocess Communication", "text": "\nCAN_BCM, in the CAN protocol family, is the broadcast manager (BCM) protocol.\nBroadcast manager constants, documented in the Linux documentation, are also\ndefined in the socket module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.CAN_ISOTP", "path": "library/socket#socket.CAN_ISOTP", "type": "Networking & Interprocess Communication", "text": "\nCAN_ISOTP, in the CAN protocol family, is the ISO-TP (ISO 15765-2) protocol.\nISO-TP constants, documented in the Linux documentation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.CAN_J1939", "path": "library/socket#socket.CAN_J1939", "type": "Networking & Interprocess Communication", "text": "\nCAN_J1939, in the CAN protocol family, is the SAE J1939 protocol. J1939\nconstants, documented in the Linux documentation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.CAN_RAW_FD_FRAMES", "path": "library/socket#socket.CAN_RAW_FD_FRAMES", "type": "Networking & Interprocess Communication", "text": "\nEnables CAN FD support in a CAN_RAW socket. This is disabled by default. This\nallows your application to send both CAN and CAN FD frames; however, you must\naccept both CAN and CAN FD frames when reading from the socket.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.CAN_RAW_JOIN_FILTERS", "path": "library/socket#socket.CAN_RAW_JOIN_FILTERS", "type": "Networking & Interprocess Communication", "text": "\nJoins the applied CAN filters such that only CAN frames that match all given\nCAN filters are passed to user space.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.close()", "path": "library/socket#socket.close", "type": "Networking & Interprocess Communication", "text": "\nClose a socket file descriptor. This is like `os.close()`, but for sockets. On\nsome platforms (most noticeable Windows) `os.close()` does not work for socket\nfile descriptors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.CMSG_LEN()", "path": "library/socket#socket.CMSG_LEN", "type": "Networking & Interprocess Communication", "text": "\nReturn the total length, without trailing padding, of an ancillary data item\nwith associated data of the given length. This value can often be used as the\nbuffer size for `recvmsg()` to receive a single item of ancillary data, but\nRFC 3542 requires portable applications to use `CMSG_SPACE()` and thus include\nspace for padding, even when the item will be the last in the buffer. Raises\n`OverflowError` if length is outside the permissible range of values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.CMSG_SPACE()", "path": "library/socket#socket.CMSG_SPACE", "type": "Networking & Interprocess Communication", "text": "\nReturn the buffer size needed for `recvmsg()` to receive an ancillary data\nitem with associated data of the given length, along with any trailing\npadding. The buffer space needed to receive multiple items is the sum of the\n`CMSG_SPACE()` values for their associated data lengths. Raises\n`OverflowError` if length is outside the permissible range of values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.create_connection()", "path": "library/socket#socket.create_connection", "type": "Networking & Interprocess Communication", "text": "\nConnect to a TCP service listening on the Internet address (a 2-tuple `(host,\nport)`), and return the socket object. This is a higher-level function than\n`socket.connect()`: if host is a non-numeric hostname, it will try to resolve\nit for both `AF_INET` and `AF_INET6`, and then try to connect to all possible\naddresses in turn until a connection succeeds. This makes it easy to write\nclients that are compatible to both IPv4 and IPv6.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.create_server()", "path": "library/socket#socket.create_server", "type": "Networking & Interprocess Communication", "text": "\nConvenience function which creates a TCP socket bound to address (a 2-tuple\n`(host, port)`) and return the socket object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.error", "path": "library/socket#socket.error", "type": "Networking & Interprocess Communication", "text": "\nA deprecated alias of `OSError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.fromfd()", "path": "library/socket#socket.fromfd", "type": "Networking & Interprocess Communication", "text": "\nDuplicate the file descriptor fd (an integer as returned by a file object\u2019s\n`fileno()` method) and build a socket object from the result. Address family,\nsocket type and protocol number are as for the `socket()` function above. The\nfile descriptor should refer to a socket, but this is not checked \u2014 subsequent\noperations on the object may fail if the file descriptor is invalid. This\nfunction is rarely needed, but can be used to get or set socket options on a\nsocket passed to a program as standard input or output (such as a server\nstarted by the Unix inet daemon). The socket is assumed to be in blocking\nmode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.fromshare()", "path": "library/socket#socket.fromshare", "type": "Networking & Interprocess Communication", "text": "\nInstantiate a socket from data obtained from the `socket.share()` method. The\nsocket is assumed to be in blocking mode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.gaierror", "path": "library/socket#socket.gaierror", "type": "Networking & Interprocess Communication", "text": "\nA subclass of `OSError`, this exception is raised for address-related errors\nby `getaddrinfo()` and `getnameinfo()`. The accompanying value is a pair\n`(error, string)` representing an error returned by a library call. string\nrepresents the description of error, as returned by the `gai_strerror()` C\nfunction. The numeric error value will match one of the `EAI_*` constants\ndefined in this module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.getaddrinfo()", "path": "library/socket#socket.getaddrinfo", "type": "Networking & Interprocess Communication", "text": "\nTranslate the host/port argument into a sequence of 5-tuples that contain all\nthe necessary arguments for creating a socket connected to that service. host\nis a domain name, a string representation of an IPv4/v6 address or `None`.\nport is a string service name such as `'http'`, a numeric port number or\n`None`. By passing `None` as the value of host and port, you can pass `NULL`\nto the underlying C API.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.getdefaulttimeout()", "path": "library/socket#socket.getdefaulttimeout", "type": "Networking & Interprocess Communication", "text": "\nReturn the default timeout in seconds (float) for new socket objects. A value\nof `None` indicates that new socket objects have no timeout. When the socket\nmodule is first imported, the default is `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.getfqdn()", "path": "library/socket#socket.getfqdn", "type": "Networking & Interprocess Communication", "text": "\nReturn a fully qualified domain name for name. If name is omitted or empty, it\nis interpreted as the local host. To find the fully qualified name, the\nhostname returned by `gethostbyaddr()` is checked, followed by aliases for the\nhost, if available. The first name which includes a period is selected. In\ncase no fully qualified domain name is available, the hostname as returned by\n`gethostname()` is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.gethostbyaddr()", "path": "library/socket#socket.gethostbyaddr", "type": "Networking & Interprocess Communication", "text": "\nReturn a triple `(hostname, aliaslist, ipaddrlist)` where hostname is the\nprimary host name responding to the given ip_address, aliaslist is a (possibly\nempty) list of alternative host names for the same address, and ipaddrlist is\na list of IPv4/v6 addresses for the same interface on the same host (most\nlikely containing only a single address). To find the fully qualified domain\nname, use the function `getfqdn()`. `gethostbyaddr()` supports both IPv4 and\nIPv6.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.gethostbyname()", "path": "library/socket#socket.gethostbyname", "type": "Networking & Interprocess Communication", "text": "\nTranslate a host name to IPv4 address format. The IPv4 address is returned as\na string, such as `'100.50.200.5'`. If the host name is an IPv4 address itself\nit is returned unchanged. See `gethostbyname_ex()` for a more complete\ninterface. `gethostbyname()` does not support IPv6 name resolution, and\n`getaddrinfo()` should be used instead for IPv4/v6 dual stack support.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.gethostbyname_ex()", "path": "library/socket#socket.gethostbyname_ex", "type": "Networking & Interprocess Communication", "text": "\nTranslate a host name to IPv4 address format, extended interface. Return a\ntriple `(hostname, aliaslist, ipaddrlist)` where hostname is the primary host\nname responding to the given ip_address, aliaslist is a (possibly empty) list\nof alternative host names for the same address, and ipaddrlist is a list of\nIPv4 addresses for the same interface on the same host (often but not always a\nsingle address). `gethostbyname_ex()` does not support IPv6 name resolution,\nand `getaddrinfo()` should be used instead for IPv4/v6 dual stack support.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.gethostname()", "path": "library/socket#socket.gethostname", "type": "Networking & Interprocess Communication", "text": "\nReturn a string containing the hostname of the machine where the Python\ninterpreter is currently executing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.getnameinfo()", "path": "library/socket#socket.getnameinfo", "type": "Networking & Interprocess Communication", "text": "\nTranslate a socket address sockaddr into a 2-tuple `(host, port)`. Depending\non the settings of flags, the result can contain a fully-qualified domain name\nor numeric address representation in host. Similarly, port can contain a\nstring port name or a numeric port number.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.getprotobyname()", "path": "library/socket#socket.getprotobyname", "type": "Networking & Interprocess Communication", "text": "\nTranslate an Internet protocol name (for example, `'icmp'`) to a constant\nsuitable for passing as the (optional) third argument to the `socket()`\nfunction. This is usually only needed for sockets opened in \u201craw\u201d mode\n(`SOCK_RAW`); for the normal socket modes, the correct protocol is chosen\nautomatically if the protocol is omitted or zero.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.getservbyname()", "path": "library/socket#socket.getservbyname", "type": "Networking & Interprocess Communication", "text": "\nTranslate an Internet service name and protocol name to a port number for that\nservice. The optional protocol name, if given, should be `'tcp'` or `'udp'`,\notherwise any protocol will match.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.getservbyport()", "path": "library/socket#socket.getservbyport", "type": "Networking & Interprocess Communication", "text": "\nTranslate an Internet port number and protocol name to a service name for that\nservice. The optional protocol name, if given, should be `'tcp'` or `'udp'`,\notherwise any protocol will match.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.has_dualstack_ipv6()", "path": "library/socket#socket.has_dualstack_ipv6", "type": "Networking & Interprocess Communication", "text": "\nReturn `True` if the platform supports creating a TCP socket which can handle\nboth IPv4 and IPv6 connections.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.has_ipv6", "path": "library/socket#socket.has_ipv6", "type": "Networking & Interprocess Communication", "text": "\nThis constant contains a boolean value which indicates if IPv6 is supported on\nthis platform.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.HCI_DATA_DIR", "path": "library/socket#socket.HCI_DATA_DIR", "type": "Networking & Interprocess Communication", "text": "\nFor use with `BTPROTO_HCI`. `HCI_FILTER` is not available for NetBSD or\nDragonFlyBSD. `HCI_TIME_STAMP` and `HCI_DATA_DIR` are not available for\nFreeBSD, NetBSD, or DragonFlyBSD.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.HCI_FILTER", "path": "library/socket#socket.HCI_FILTER", "type": "Networking & Interprocess Communication", "text": "\nFor use with `BTPROTO_HCI`. `HCI_FILTER` is not available for NetBSD or\nDragonFlyBSD. `HCI_TIME_STAMP` and `HCI_DATA_DIR` are not available for\nFreeBSD, NetBSD, or DragonFlyBSD.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.HCI_TIME_STAMP", "path": "library/socket#socket.HCI_TIME_STAMP", "type": "Networking & Interprocess Communication", "text": "\nFor use with `BTPROTO_HCI`. `HCI_FILTER` is not available for NetBSD or\nDragonFlyBSD. `HCI_TIME_STAMP` and `HCI_DATA_DIR` are not available for\nFreeBSD, NetBSD, or DragonFlyBSD.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.herror", "path": "library/socket#socket.herror", "type": "Networking & Interprocess Communication", "text": "\nA subclass of `OSError`, this exception is raised for address-related errors,\ni.e. for functions that use h_errno in the POSIX C API, including\n`gethostbyname_ex()` and `gethostbyaddr()`. The accompanying value is a pair\n`(h_errno, string)` representing an error returned by a library call. h_errno\nis a numeric value, while string represents the description of h_errno, as\nreturned by the `hstrerror()` C function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.htonl()", "path": "library/socket#socket.htonl", "type": "Networking & Interprocess Communication", "text": "\nConvert 32-bit positive integers from host to network byte order. On machines\nwhere the host byte order is the same as network byte order, this is a no-op;\notherwise, it performs a 4-byte swap operation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.htons()", "path": "library/socket#socket.htons", "type": "Networking & Interprocess Communication", "text": "\nConvert 16-bit positive integers from host to network byte order. On machines\nwhere the host byte order is the same as network byte order, this is a no-op;\notherwise, it performs a 2-byte swap operation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.if_indextoname()", "path": "library/socket#socket.if_indextoname", "type": "Networking & Interprocess Communication", "text": "\nReturn a network interface name corresponding to an interface index number.\n`OSError` if no interface with the given index exists.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.if_nameindex()", "path": "library/socket#socket.if_nameindex", "type": "Networking & Interprocess Communication", "text": "\nReturn a list of network interface information (index int, name string)\ntuples. `OSError` if the system call fails.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.if_nametoindex()", "path": "library/socket#socket.if_nametoindex", "type": "Networking & Interprocess Communication", "text": "\nReturn a network interface index number corresponding to an interface name.\n`OSError` if no interface with the given name exists.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.inet_aton()", "path": "library/socket#socket.inet_aton", "type": "Networking & Interprocess Communication", "text": "\nConvert an IPv4 address from dotted-quad string format (for example,\n\u2018123.45.67.89\u2019) to 32-bit packed binary format, as a bytes object four\ncharacters in length. This is useful when conversing with a program that uses\nthe standard C library and needs objects of type `struct in_addr`, which is\nthe C type for the 32-bit packed binary this function returns.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.inet_ntoa()", "path": "library/socket#socket.inet_ntoa", "type": "Networking & Interprocess Communication", "text": "\nConvert a 32-bit packed IPv4 address (a bytes-like object four bytes in\nlength) to its standard dotted-quad string representation (for example,\n\u2018123.45.67.89\u2019). This is useful when conversing with a program that uses the\nstandard C library and needs objects of type `struct in_addr`, which is the C\ntype for the 32-bit packed binary data this function takes as an argument.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.inet_ntop()", "path": "library/socket#socket.inet_ntop", "type": "Networking & Interprocess Communication", "text": "\nConvert a packed IP address (a bytes-like object of some number of bytes) to\nits standard, family-specific string representation (for example, `'7.10.0.5'`\nor `'5aef:2b::8'`). `inet_ntop()` is useful when a library or network protocol\nreturns an object of type `struct in_addr` (similar to `inet_ntoa()`) or\n`struct in6_addr`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.inet_pton()", "path": "library/socket#socket.inet_pton", "type": "Networking & Interprocess Communication", "text": "\nConvert an IP address from its family-specific string format to a packed,\nbinary format. `inet_pton()` is useful when a library or network protocol\ncalls for an object of type `struct in_addr` (similar to `inet_aton()`) or\n`struct in6_addr`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.IOCTL_VM_SOCKETS_GET_LOCAL_CID", "path": "library/socket#socket.IOCTL_VM_SOCKETS_GET_LOCAL_CID", "type": "Networking & Interprocess Communication", "text": "\nConstants for Linux host/guest communication.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.ntohl()", "path": "library/socket#socket.ntohl", "type": "Networking & Interprocess Communication", "text": "\nConvert 32-bit positive integers from network to host byte order. On machines\nwhere the host byte order is the same as network byte order, this is a no-op;\notherwise, it performs a 4-byte swap operation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.ntohs()", "path": "library/socket#socket.ntohs", "type": "Networking & Interprocess Communication", "text": "\nConvert 16-bit positive integers from network to host byte order. On machines\nwhere the host byte order is the same as network byte order, this is a no-op;\notherwise, it performs a 2-byte swap operation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.PF_CAN", "path": "library/socket#socket.PF_CAN", "type": "Networking & Interprocess Communication", "text": "\nMany constants of these forms, documented in the Linux documentation, are also\ndefined in the socket module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.PF_PACKET", "path": "library/socket#socket.PF_PACKET", "type": "Networking & Interprocess Communication", "text": "\nMany constants of these forms, documented in the Linux documentation, are also\ndefined in the socket module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.PF_RDS", "path": "library/socket#socket.PF_RDS", "type": "Networking & Interprocess Communication", "text": "\nMany constants of these forms, documented in the Linux documentation, are also\ndefined in the socket module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.recv_fds()", "path": "library/socket#socket.recv_fds", "type": "Networking & Interprocess Communication", "text": "\nReceive up to maxfds file descriptors from an `AF_UNIX` socket sock. Return\n`(msg, list(fds), flags, addr)`. Consult `recvmsg()` for the documentation of\nthese parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.send_fds()", "path": "library/socket#socket.send_fds", "type": "Networking & Interprocess Communication", "text": "\nSend the list of file descriptors fds over an `AF_UNIX` socket sock. The fds\nparameter is a sequence of file descriptors. Consult `sendmsg()` for the\ndocumentation of these parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.setdefaulttimeout()", "path": "library/socket#socket.setdefaulttimeout", "type": "Networking & Interprocess Communication", "text": "\nSet the default timeout in seconds (float) for new socket objects. When the\nsocket module is first imported, the default is `None`. See `settimeout()` for\npossible values and their respective meanings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.sethostname()", "path": "library/socket#socket.sethostname", "type": "Networking & Interprocess Communication", "text": "\nSet the machine\u2019s hostname to name. This will raise an `OSError` if you don\u2019t\nhave enough rights.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.SIO_KEEPALIVE_VALS", "path": "library/socket#socket.SIO_KEEPALIVE_VALS", "type": "Networking & Interprocess Communication", "text": "\nConstants for Windows\u2019 WSAIoctl(). The constants are used as arguments to the\n`ioctl()` method of socket objects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.SIO_LOOPBACK_FAST_PATH", "path": "library/socket#socket.SIO_LOOPBACK_FAST_PATH", "type": "Networking & Interprocess Communication", "text": "\nConstants for Windows\u2019 WSAIoctl(). The constants are used as arguments to the\n`ioctl()` method of socket objects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.SIO_RCVALL", "path": "library/socket#socket.SIO_RCVALL", "type": "Networking & Interprocess Communication", "text": "\nConstants for Windows\u2019 WSAIoctl(). The constants are used as arguments to the\n`ioctl()` method of socket objects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.socket()", "path": "library/socket#socket.socket", "type": "Networking & Interprocess Communication", "text": "\nCreate a new socket using the given address family, socket type and protocol\nnumber. The address family should be `AF_INET` (the default), `AF_INET6`,\n`AF_UNIX`, `AF_CAN`, `AF_PACKET`, or `AF_RDS`. The socket type should be\n`SOCK_STREAM` (the default), `SOCK_DGRAM`, `SOCK_RAW` or perhaps one of the\nother `SOCK_` constants. The protocol number is usually zero and may be\nomitted or in the case where the address family is `AF_CAN` the protocol\nshould be one of `CAN_RAW`, `CAN_BCM`, `CAN_ISOTP` or `CAN_J1939`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.socket.accept()", "path": "library/socket#socket.socket.accept", "type": "Networking & Interprocess Communication", "text": "\nAccept a connection. The socket must be bound to an address and listening for\nconnections. The return value is a pair `(conn, address)` where conn is a new\nsocket object usable to send and receive data on the connection, and address\nis the address bound to the socket on the other end of the connection.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.socket.bind()", "path": "library/socket#socket.socket.bind", "type": "Networking & Interprocess Communication", "text": "\nBind the socket to address. The socket must not already be bound. (The format\nof address depends on the address family \u2014 see above.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.socket.close()", "path": "library/socket#socket.socket.close", "type": "Networking & Interprocess Communication", "text": "\nMark the socket closed. The underlying system resource (e.g. a file\ndescriptor) is also closed when all file objects from `makefile()` are closed.\nOnce that happens, all future operations on the socket object will fail. The\nremote end will receive no more data (after queued data is flushed).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.socket.connect()", "path": "library/socket#socket.socket.connect", "type": "Networking & Interprocess Communication", "text": "\nConnect to a remote socket at address. (The format of address depends on the\naddress family \u2014 see above.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.socket.connect_ex()", "path": "library/socket#socket.socket.connect_ex", "type": "Networking & Interprocess Communication", "text": "\nLike `connect(address)`, but return an error indicator instead of raising an\nexception for errors returned by the C-level `connect()` call (other problems,\nsuch as \u201chost not found,\u201d can still raise exceptions). The error indicator is\n`0` if the operation succeeded, otherwise the value of the `errno` variable.\nThis is useful to support, for example, asynchronous connects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.socket.detach()", "path": "library/socket#socket.socket.detach", "type": "Networking & Interprocess Communication", "text": "\nPut the socket object into closed state without actually closing the\nunderlying file descriptor. The file descriptor is returned, and can be reused\nfor other purposes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.socket.dup()", "path": "library/socket#socket.socket.dup", "type": "Networking & Interprocess Communication", "text": "\nDuplicate the socket.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.socket.family", "path": "library/socket#socket.socket.family", "type": "Networking & Interprocess Communication", "text": "\nThe socket family.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.socket.fileno()", "path": "library/socket#socket.socket.fileno", "type": "Networking & Interprocess Communication", "text": "\nReturn the socket\u2019s file descriptor (a small integer), or -1 on failure. This\nis useful with `select.select()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.socket.getblocking()", "path": "library/socket#socket.socket.getblocking", "type": "Networking & Interprocess Communication", "text": "\nReturn `True` if socket is in blocking mode, `False` if in non-blocking.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.socket.getpeername()", "path": "library/socket#socket.socket.getpeername", "type": "Networking & Interprocess Communication", "text": "\nReturn the remote address to which the socket is connected. This is useful to\nfind out the port number of a remote IPv4/v6 socket, for instance. (The format\nof the address returned depends on the address family \u2014 see above.) On some\nsystems this function is not supported.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.socket.getsockname()", "path": "library/socket#socket.socket.getsockname", "type": "Networking & Interprocess Communication", "text": "\nReturn the socket\u2019s own address. This is useful to find out the port number of\nan IPv4/v6 socket, for instance. (The format of the address returned depends\non the address family \u2014 see above.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.socket.getsockopt()", "path": "library/socket#socket.socket.getsockopt", "type": "Networking & Interprocess Communication", "text": "\nReturn the value of the given socket option (see the Unix man page\ngetsockopt(2)). The needed symbolic constants (`SO_*` etc.) are defined in\nthis module. If buflen is absent, an integer option is assumed and its integer\nvalue is returned by the function. If buflen is present, it specifies the\nmaximum length of the buffer used to receive the option in, and this buffer is\nreturned as a bytes object. It is up to the caller to decode the contents of\nthe buffer (see the optional built-in module `struct` for a way to decode C\nstructures encoded as byte strings).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.socket.gettimeout()", "path": "library/socket#socket.socket.gettimeout", "type": "Networking & Interprocess Communication", "text": "\nReturn the timeout in seconds (float) associated with socket operations, or\n`None` if no timeout is set. This reflects the last call to `setblocking()` or\n`settimeout()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.socket.get_inheritable()", "path": "library/socket#socket.socket.get_inheritable", "type": "Networking & Interprocess Communication", "text": "\nGet the inheritable flag of the socket\u2019s file descriptor or socket\u2019s handle:\n`True` if the socket can be inherited in child processes, `False` if it\ncannot.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.socket.ioctl()", "path": "library/socket#socket.socket.ioctl", "type": "Networking & Interprocess Communication", "text": "\nWindows\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.socket.listen()", "path": "library/socket#socket.socket.listen", "type": "Networking & Interprocess Communication", "text": "\nEnable a server to accept connections. If backlog is specified, it must be at\nleast 0 (if it is lower, it is set to 0); it specifies the number of\nunaccepted connections that the system will allow before refusing new\nconnections. If not specified, a default reasonable value is chosen.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.socket.makefile()", "path": "library/socket#socket.socket.makefile", "type": "Networking & Interprocess Communication", "text": "\nReturn a file object associated with the socket. The exact returned type\ndepends on the arguments given to `makefile()`. These arguments are\ninterpreted the same way as by the built-in `open()` function, except the only\nsupported mode values are `'r'` (default), `'w'` and `'b'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.socket.proto", "path": "library/socket#socket.socket.proto", "type": "Networking & Interprocess Communication", "text": "\nThe socket protocol.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.socket.recv()", "path": "library/socket#socket.socket.recv", "type": "Networking & Interprocess Communication", "text": "\nReceive data from the socket. The return value is a bytes object representing\nthe data received. The maximum amount of data to be received at once is\nspecified by bufsize. See the Unix manual page recv(2) for the meaning of the\noptional argument flags; it defaults to zero.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.socket.recvfrom()", "path": "library/socket#socket.socket.recvfrom", "type": "Networking & Interprocess Communication", "text": "\nReceive data from the socket. The return value is a pair `(bytes, address)`\nwhere bytes is a bytes object representing the data received and address is\nthe address of the socket sending the data. See the Unix manual page recv(2)\nfor the meaning of the optional argument flags; it defaults to zero. (The\nformat of address depends on the address family \u2014 see above.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.socket.recvfrom_into()", "path": "library/socket#socket.socket.recvfrom_into", "type": "Networking & Interprocess Communication", "text": "\nReceive data from the socket, writing it into buffer instead of creating a new\nbytestring. The return value is a pair `(nbytes, address)` where nbytes is the\nnumber of bytes received and address is the address of the socket sending the\ndata. See the Unix manual page recv(2) for the meaning of the optional\nargument flags; it defaults to zero. (The format of address depends on the\naddress family \u2014 see above.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.socket.recvmsg()", "path": "library/socket#socket.socket.recvmsg", "type": "Networking & Interprocess Communication", "text": "\nReceive normal data (up to bufsize bytes) and ancillary data from the socket.\nThe ancbufsize argument sets the size in bytes of the internal buffer used to\nreceive the ancillary data; it defaults to 0, meaning that no ancillary data\nwill be received. Appropriate buffer sizes for ancillary data can be\ncalculated using `CMSG_SPACE()` or `CMSG_LEN()`, and items which do not fit\ninto the buffer might be truncated or discarded. The flags argument defaults\nto 0 and has the same meaning as for `recv()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.socket.recvmsg_into()", "path": "library/socket#socket.socket.recvmsg_into", "type": "Networking & Interprocess Communication", "text": "\nReceive normal data and ancillary data from the socket, behaving as\n`recvmsg()` would, but scatter the non-ancillary data into a series of buffers\ninstead of returning a new bytes object. The buffers argument must be an\niterable of objects that export writable buffers (e.g. `bytearray` objects);\nthese will be filled with successive chunks of the non-ancillary data until it\nhas all been written or there are no more buffers. The operating system may\nset a limit (`sysconf()` value `SC_IOV_MAX`) on the number of buffers that can\nbe used. The ancbufsize and flags arguments have the same meaning as for\n`recvmsg()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.socket.recv_into()", "path": "library/socket#socket.socket.recv_into", "type": "Networking & Interprocess Communication", "text": "\nReceive up to nbytes bytes from the socket, storing the data into a buffer\nrather than creating a new bytestring. If nbytes is not specified (or 0),\nreceive up to the size available in the given buffer. Returns the number of\nbytes received. See the Unix manual page recv(2) for the meaning of the\noptional argument flags; it defaults to zero.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.socket.send()", "path": "library/socket#socket.socket.send", "type": "Networking & Interprocess Communication", "text": "\nSend data to the socket. The socket must be connected to a remote socket. The\noptional flags argument has the same meaning as for `recv()` above. Returns\nthe number of bytes sent. Applications are responsible for checking that all\ndata has been sent; if only some of the data was transmitted, the application\nneeds to attempt delivery of the remaining data. For further information on\nthis topic, consult the Socket Programming HOWTO.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.socket.sendall()", "path": "library/socket#socket.socket.sendall", "type": "Networking & Interprocess Communication", "text": "\nSend data to the socket. The socket must be connected to a remote socket. The\noptional flags argument has the same meaning as for `recv()` above. Unlike\n`send()`, this method continues to send data from bytes until either all data\nhas been sent or an error occurs. `None` is returned on success. On error, an\nexception is raised, and there is no way to determine how much data, if any,\nwas successfully sent.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.socket.sendfile()", "path": "library/socket#socket.socket.sendfile", "type": "Networking & Interprocess Communication", "text": "\nSend a file until EOF is reached by using high-performance `os.sendfile` and\nreturn the total number of bytes which were sent. file must be a regular file\nobject opened in binary mode. If `os.sendfile` is not available (e.g. Windows)\nor file is not a regular file `send()` will be used instead. offset tells from\nwhere to start reading the file. If specified, count is the total number of\nbytes to transmit as opposed to sending the file until EOF is reached. File\nposition is updated on return or also in case of error in which case\n`file.tell()` can be used to figure out the number of bytes which were sent.\nThe socket must be of `SOCK_STREAM` type. Non-blocking sockets are not\nsupported.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.socket.sendmsg()", "path": "library/socket#socket.socket.sendmsg", "type": "Networking & Interprocess Communication", "text": "\nSend normal and ancillary data to the socket, gathering the non-ancillary data\nfrom a series of buffers and concatenating it into a single message. The\nbuffers argument specifies the non-ancillary data as an iterable of bytes-like\nobjects (e.g. `bytes` objects); the operating system may set a limit\n(`sysconf()` value `SC_IOV_MAX`) on the number of buffers that can be used.\nThe ancdata argument specifies the ancillary data (control messages) as an\niterable of zero or more tuples `(cmsg_level, cmsg_type, cmsg_data)`, where\ncmsg_level and cmsg_type are integers specifying the protocol level and\nprotocol-specific type respectively, and cmsg_data is a bytes-like object\nholding the associated data. Note that some systems (in particular, systems\nwithout `CMSG_SPACE()`) might support sending only one control message per\ncall. The flags argument defaults to 0 and has the same meaning as for\n`send()`. If address is supplied and not `None`, it sets a destination address\nfor the message. The return value is the number of bytes of non-ancillary data\nsent.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.socket.sendmsg_afalg()", "path": "library/socket#socket.socket.sendmsg_afalg", "type": "Networking & Interprocess Communication", "text": "\nSpecialized version of `sendmsg()` for `AF_ALG` socket. Set mode, IV, AEAD\nassociated data length and flags for `AF_ALG` socket.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.socket.sendto()", "path": "library/socket#socket.socket.sendto", "type": "Networking & Interprocess Communication", "text": "\nSend data to the socket. The socket should not be connected to a remote\nsocket, since the destination socket is specified by address. The optional\nflags argument has the same meaning as for `recv()` above. Return the number\nof bytes sent. (The format of address depends on the address family \u2014 see\nabove.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.socket.setblocking()", "path": "library/socket#socket.socket.setblocking", "type": "Networking & Interprocess Communication", "text": "\nSet blocking or non-blocking mode of the socket: if flag is false, the socket\nis set to non-blocking, else to blocking mode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.socket.setsockopt()", "path": "library/socket#socket.socket.setsockopt", "type": "Networking & Interprocess Communication", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.socket.settimeout()", "path": "library/socket#socket.socket.settimeout", "type": "Networking & Interprocess Communication", "text": "\nSet a timeout on blocking socket operations. The value argument can be a\nnonnegative floating point number expressing seconds, or `None`. If a non-zero\nvalue is given, subsequent socket operations will raise a `timeout` exception\nif the timeout period value has elapsed before the operation has completed. If\nzero is given, the socket is put in non-blocking mode. If `None` is given, the\nsocket is put in blocking mode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.socket.set_inheritable()", "path": "library/socket#socket.socket.set_inheritable", "type": "Networking & Interprocess Communication", "text": "\nSet the inheritable flag of the socket\u2019s file descriptor or socket\u2019s handle.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.socket.share()", "path": "library/socket#socket.socket.share", "type": "Networking & Interprocess Communication", "text": "\nDuplicate a socket and prepare it for sharing with a target process. The\ntarget process must be provided with process_id. The resulting bytes object\ncan then be passed to the target process using some form of interprocess\ncommunication and the socket can be recreated there using `fromshare()`. Once\nthis method has been called, it is safe to close the socket since the\noperating system has already duplicated it for the target process.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.socket.shutdown()", "path": "library/socket#socket.socket.shutdown", "type": "Networking & Interprocess Communication", "text": "\nShut down one or both halves of the connection. If how is `SHUT_RD`, further\nreceives are disallowed. If how is `SHUT_WR`, further sends are disallowed. If\nhow is `SHUT_RDWR`, further sends and receives are disallowed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.socket.type", "path": "library/socket#socket.socket.type", "type": "Networking & Interprocess Communication", "text": "\nThe socket type.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.socketpair()", "path": "library/socket#socket.socketpair", "type": "Networking & Interprocess Communication", "text": "\nBuild a pair of connected socket objects using the given address family,\nsocket type, and protocol number. Address family, socket type, and protocol\nnumber are as for the `socket()` function above. The default family is\n`AF_UNIX` if defined on the platform; otherwise, the default is `AF_INET`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.SocketType", "path": "library/socket#socket.SocketType", "type": "Networking & Interprocess Communication", "text": "\nThis is a Python type object that represents the socket object type. It is the\nsame as `type(socket(...))`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.SOCK_CLOEXEC", "path": "library/socket#socket.SOCK_CLOEXEC", "type": "Networking & Interprocess Communication", "text": "\nThese two constants, if defined, can be combined with the socket types and\nallow you to set some flags atomically (thus avoiding possible race conditions\nand the need for separate calls).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.SOCK_DGRAM", "path": "library/socket#socket.SOCK_DGRAM", "type": "Networking & Interprocess Communication", "text": "\nThese constants represent the socket types, used for the second argument to\n`socket()`. More constants may be available depending on the system. (Only\n`SOCK_STREAM` and `SOCK_DGRAM` appear to be generally useful.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.SOCK_NONBLOCK", "path": "library/socket#socket.SOCK_NONBLOCK", "type": "Networking & Interprocess Communication", "text": "\nThese two constants, if defined, can be combined with the socket types and\nallow you to set some flags atomically (thus avoiding possible race conditions\nand the need for separate calls).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.SOCK_RAW", "path": "library/socket#socket.SOCK_RAW", "type": "Networking & Interprocess Communication", "text": "\nThese constants represent the socket types, used for the second argument to\n`socket()`. More constants may be available depending on the system. (Only\n`SOCK_STREAM` and `SOCK_DGRAM` appear to be generally useful.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.SOCK_RDM", "path": "library/socket#socket.SOCK_RDM", "type": "Networking & Interprocess Communication", "text": "\nThese constants represent the socket types, used for the second argument to\n`socket()`. More constants may be available depending on the system. (Only\n`SOCK_STREAM` and `SOCK_DGRAM` appear to be generally useful.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.SOCK_SEQPACKET", "path": "library/socket#socket.SOCK_SEQPACKET", "type": "Networking & Interprocess Communication", "text": "\nThese constants represent the socket types, used for the second argument to\n`socket()`. More constants may be available depending on the system. (Only\n`SOCK_STREAM` and `SOCK_DGRAM` appear to be generally useful.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.SOCK_STREAM", "path": "library/socket#socket.SOCK_STREAM", "type": "Networking & Interprocess Communication", "text": "\nThese constants represent the socket types, used for the second argument to\n`socket()`. More constants may be available depending on the system. (Only\n`SOCK_STREAM` and `SOCK_DGRAM` appear to be generally useful.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.SOL_ALG", "path": "library/socket#socket.SOL_ALG", "type": "Networking & Interprocess Communication", "text": "\nConstants for Linux Kernel cryptography.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.SOL_RDS", "path": "library/socket#socket.SOL_RDS", "type": "Networking & Interprocess Communication", "text": "\nMany constants of these forms, documented in the Linux documentation, are also\ndefined in the socket module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.SOMAXCONN", "path": "library/socket#socket.SOMAXCONN", "type": "Networking & Interprocess Communication", "text": "\nMany constants of these forms, documented in the Unix documentation on sockets\nand/or the IP protocol, are also defined in the socket module. They are\ngenerally used in arguments to the `setsockopt()` and `getsockopt()` methods\nof socket objects. In most cases, only those symbols that are defined in the\nUnix header files are defined; for a few symbols, default values are provided.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socket.timeout", "path": "library/socket#socket.timeout", "type": "Networking & Interprocess Communication", "text": "\nA subclass of `OSError`, this exception is raised when a timeout occurs on a\nsocket which has had timeouts enabled via a prior call to `settimeout()` (or\nimplicitly through `setdefaulttimeout()`). The accompanying value is a string\nwhose value is currently always \u201ctimed out\u201d.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socketserver", "path": "library/socketserver", "type": "Internet", "text": "\nSource code: Lib/socketserver.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socketserver.BaseRequestHandler", "path": "library/socketserver#socketserver.BaseRequestHandler", "type": "Internet", "text": "\nThis is the superclass of all request handler objects. It defines the\ninterface, given below. A concrete request handler subclass must define a new\n`handle()` method, and can override any of the other methods. A new instance\nof the subclass is created for each request.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socketserver.BaseRequestHandler.finish()", "path": "library/socketserver#socketserver.BaseRequestHandler.finish", "type": "Internet", "text": "\nCalled after the `handle()` method to perform any clean-up actions required.\nThe default implementation does nothing. If `setup()` raises an exception,\nthis function will not be called.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socketserver.BaseRequestHandler.handle()", "path": "library/socketserver#socketserver.BaseRequestHandler.handle", "type": "Internet", "text": "\nThis function must do all the work required to service a request. The default\nimplementation does nothing. Several instance attributes are available to it;\nthe request is available as `self.request`; the client address as\n`self.client_address`; and the server instance as `self.server`, in case it\nneeds access to per-server information.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socketserver.BaseRequestHandler.setup()", "path": "library/socketserver#socketserver.BaseRequestHandler.setup", "type": "Internet", "text": "\nCalled before the `handle()` method to perform any initialization actions\nrequired. The default implementation does nothing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socketserver.BaseServer", "path": "library/socketserver#socketserver.BaseServer", "type": "Internet", "text": "\nThis is the superclass of all Server objects in the module. It defines the\ninterface, given below, but does not implement most of the methods, which is\ndone in subclasses. The two parameters are stored in the respective\n`server_address` and `RequestHandlerClass` attributes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socketserver.BaseServer.address_family", "path": "library/socketserver#socketserver.BaseServer.address_family", "type": "Internet", "text": "\nThe family of protocols to which the server\u2019s socket belongs. Common examples\nare `socket.AF_INET` and `socket.AF_UNIX`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socketserver.BaseServer.allow_reuse_address", "path": "library/socketserver#socketserver.BaseServer.allow_reuse_address", "type": "Internet", "text": "\nWhether the server will allow the reuse of an address. This defaults to\n`False`, and can be set in subclasses to change the policy.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socketserver.BaseServer.fileno()", "path": "library/socketserver#socketserver.BaseServer.fileno", "type": "Internet", "text": "\nReturn an integer file descriptor for the socket on which the server is\nlistening. This function is most commonly passed to `selectors`, to allow\nmonitoring multiple servers in the same process.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socketserver.BaseServer.finish_request()", "path": "library/socketserver#socketserver.BaseServer.finish_request", "type": "Internet", "text": "\nActually processes the request by instantiating `RequestHandlerClass` and\ncalling its `handle()` method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socketserver.BaseServer.get_request()", "path": "library/socketserver#socketserver.BaseServer.get_request", "type": "Internet", "text": "\nMust accept a request from the socket, and return a 2-tuple containing the new\nsocket object to be used to communicate with the client, and the client\u2019s\naddress.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socketserver.BaseServer.handle_error()", "path": "library/socketserver#socketserver.BaseServer.handle_error", "type": "Internet", "text": "\nThis function is called if the `handle()` method of a `RequestHandlerClass`\ninstance raises an exception. The default action is to print the traceback to\nstandard error and continue handling further requests.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socketserver.BaseServer.handle_request()", "path": "library/socketserver#socketserver.BaseServer.handle_request", "type": "Internet", "text": "\nProcess a single request. This function calls the following methods in order:\n`get_request()`, `verify_request()`, and `process_request()`. If the user-\nprovided `handle()` method of the handler class raises an exception, the\nserver\u2019s `handle_error()` method will be called. If no request is received\nwithin `timeout` seconds, `handle_timeout()` will be called and\n`handle_request()` will return.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socketserver.BaseServer.handle_timeout()", "path": "library/socketserver#socketserver.BaseServer.handle_timeout", "type": "Internet", "text": "\nThis function is called when the `timeout` attribute has been set to a value\nother than `None` and the timeout period has passed with no requests being\nreceived. The default action for forking servers is to collect the status of\nany child processes that have exited, while in threading servers this method\ndoes nothing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socketserver.BaseServer.process_request()", "path": "library/socketserver#socketserver.BaseServer.process_request", "type": "Internet", "text": "\nCalls `finish_request()` to create an instance of the `RequestHandlerClass`.\nIf desired, this function can create a new process or thread to handle the\nrequest; the `ForkingMixIn` and `ThreadingMixIn` classes do this.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socketserver.BaseServer.RequestHandlerClass", "path": "library/socketserver#socketserver.BaseServer.RequestHandlerClass", "type": "Internet", "text": "\nThe user-provided request handler class; an instance of this class is created\nfor each request.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socketserver.BaseServer.request_queue_size", "path": "library/socketserver#socketserver.BaseServer.request_queue_size", "type": "Internet", "text": "\nThe size of the request queue. If it takes a long time to process a single\nrequest, any requests that arrive while the server is busy are placed into a\nqueue, up to `request_queue_size` requests. Once the queue is full, further\nrequests from clients will get a \u201cConnection denied\u201d error. The default value\nis usually 5, but this can be overridden by subclasses.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socketserver.BaseServer.server_activate()", "path": "library/socketserver#socketserver.BaseServer.server_activate", "type": "Internet", "text": "\nCalled by the server\u2019s constructor to activate the server. The default\nbehavior for a TCP server just invokes `listen()` on the server\u2019s socket. May\nbe overridden.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socketserver.BaseServer.server_address", "path": "library/socketserver#socketserver.BaseServer.server_address", "type": "Internet", "text": "\nThe address on which the server is listening. The format of addresses varies\ndepending on the protocol family; see the documentation for the `socket`\nmodule for details. For Internet protocols, this is a tuple containing a\nstring giving the address, and an integer port number: `('127.0.0.1', 80)`,\nfor example.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socketserver.BaseServer.server_bind()", "path": "library/socketserver#socketserver.BaseServer.server_bind", "type": "Internet", "text": "\nCalled by the server\u2019s constructor to bind the socket to the desired address.\nMay be overridden.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socketserver.BaseServer.server_close()", "path": "library/socketserver#socketserver.BaseServer.server_close", "type": "Internet", "text": "\nClean up the server. May be overridden.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socketserver.BaseServer.serve_forever()", "path": "library/socketserver#socketserver.BaseServer.serve_forever", "type": "Internet", "text": "\nHandle requests until an explicit `shutdown()` request. Poll for shutdown\nevery poll_interval seconds. Ignores the `timeout` attribute. It also calls\n`service_actions()`, which may be used by a subclass or mixin to provide\nactions specific to a given service. For example, the `ForkingMixIn` class\nuses `service_actions()` to clean up zombie child processes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socketserver.BaseServer.service_actions()", "path": "library/socketserver#socketserver.BaseServer.service_actions", "type": "Internet", "text": "\nThis is called in the `serve_forever()` loop. This method can be overridden by\nsubclasses or mixin classes to perform actions specific to a given service,\nsuch as cleanup actions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socketserver.BaseServer.shutdown()", "path": "library/socketserver#socketserver.BaseServer.shutdown", "type": "Internet", "text": "\nTell the `serve_forever()` loop to stop and wait until it does. `shutdown()`\nmust be called while `serve_forever()` is running in a different thread\notherwise it will deadlock.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socketserver.BaseServer.socket", "path": "library/socketserver#socketserver.BaseServer.socket", "type": "Internet", "text": "\nThe socket object on which the server will listen for incoming requests.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socketserver.BaseServer.socket_type", "path": "library/socketserver#socketserver.BaseServer.socket_type", "type": "Internet", "text": "\nThe type of socket used by the server; `socket.SOCK_STREAM` and\n`socket.SOCK_DGRAM` are two common values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socketserver.BaseServer.timeout", "path": "library/socketserver#socketserver.BaseServer.timeout", "type": "Internet", "text": "\nTimeout duration, measured in seconds, or `None` if no timeout is desired. If\n`handle_request()` receives no incoming requests within the timeout period,\nthe `handle_timeout()` method is called.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socketserver.BaseServer.verify_request()", "path": "library/socketserver#socketserver.BaseServer.verify_request", "type": "Internet", "text": "\nMust return a Boolean value; if the value is `True`, the request will be\nprocessed, and if it\u2019s `False`, the request will be denied. This function can\nbe overridden to implement access controls for a server. The default\nimplementation always returns `True`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socketserver.DatagramRequestHandler", "path": "library/socketserver#socketserver.DatagramRequestHandler", "type": "Internet", "text": "\nThese `BaseRequestHandler` subclasses override the `setup()` and `finish()`\nmethods, and provide `self.rfile` and `self.wfile` attributes. The\n`self.rfile` and `self.wfile` attributes can be read or written, respectively,\nto get the request data or return data to the client.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socketserver.ForkingMixIn", "path": "library/socketserver#socketserver.ForkingMixIn", "type": "Internet", "text": "\nForking and threading versions of each type of server can be created using\nthese mix-in classes. For instance, `ThreadingUDPServer` is created as\nfollows:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socketserver.ForkingTCPServer", "path": "library/socketserver#socketserver.ForkingTCPServer", "type": "Internet", "text": "\nThese classes are pre-defined using the mix-in classes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socketserver.ForkingUDPServer", "path": "library/socketserver#socketserver.ForkingUDPServer", "type": "Internet", "text": "\nThese classes are pre-defined using the mix-in classes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socketserver.StreamRequestHandler", "path": "library/socketserver#socketserver.StreamRequestHandler", "type": "Internet", "text": "\nThese `BaseRequestHandler` subclasses override the `setup()` and `finish()`\nmethods, and provide `self.rfile` and `self.wfile` attributes. The\n`self.rfile` and `self.wfile` attributes can be read or written, respectively,\nto get the request data or return data to the client.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socketserver.TCPServer", "path": "library/socketserver#socketserver.TCPServer", "type": "Internet", "text": "\nThis uses the Internet TCP protocol, which provides for continuous streams of\ndata between the client and server. If bind_and_activate is true, the\nconstructor automatically attempts to invoke `server_bind()` and\n`server_activate()`. The other parameters are passed to the `BaseServer` base\nclass.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socketserver.ThreadingMixIn", "path": "library/socketserver#socketserver.ThreadingMixIn", "type": "Internet", "text": "\nForking and threading versions of each type of server can be created using\nthese mix-in classes. For instance, `ThreadingUDPServer` is created as\nfollows:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socketserver.ThreadingTCPServer", "path": "library/socketserver#socketserver.ThreadingTCPServer", "type": "Internet", "text": "\nThese classes are pre-defined using the mix-in classes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socketserver.ThreadingUDPServer", "path": "library/socketserver#socketserver.ThreadingUDPServer", "type": "Internet", "text": "\nThese classes are pre-defined using the mix-in classes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socketserver.UDPServer", "path": "library/socketserver#socketserver.UDPServer", "type": "Internet", "text": "\nThis uses datagrams, which are discrete packets of information that may arrive\nout of order or be lost while in transit. The parameters are the same as for\n`TCPServer`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socketserver.UnixDatagramServer", "path": "library/socketserver#socketserver.UnixDatagramServer", "type": "Internet", "text": "\nThese more infrequently used classes are similar to the TCP and UDP classes,\nbut use Unix domain sockets; they\u2019re not available on non-Unix platforms. The\nparameters are the same as for `TCPServer`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "socketserver.UnixStreamServer", "path": "library/socketserver#socketserver.UnixStreamServer", "type": "Internet", "text": "\nThese more infrequently used classes are similar to the TCP and UDP classes,\nbut use Unix domain sockets; they\u2019re not available on non-Unix platforms. The\nparameters are the same as for `TCPServer`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sorted()", "path": "library/functions#sorted", "type": "Built-in Functions", "text": "\nReturn a new sorted list from the items in iterable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "spwd", "path": "library/spwd", "type": "Unix", "text": "\nThis module provides access to the Unix shadow password database. It is\navailable on various Unix versions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "spwd.getspall()", "path": "library/spwd#spwd.getspall", "type": "Unix", "text": "\nReturn a list of all available shadow password database entries, in arbitrary\norder.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "spwd.getspnam()", "path": "library/spwd#spwd.getspnam", "type": "Unix", "text": "\nReturn the shadow password database entry for the given user name.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3", "path": "library/sqlite3", "type": "Data Persistence", "text": "\nSource code: Lib/sqlite3/\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.complete_statement()", "path": "library/sqlite3#sqlite3.complete_statement", "type": "Data Persistence", "text": "\nReturns `True` if the string sql contains one or more complete SQL statements\nterminated by semicolons. It does not verify that the SQL is syntactically\ncorrect, only that there are no unclosed string literals and the statement is\nterminated by a semicolon.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.connect()", "path": "library/sqlite3#sqlite3.connect", "type": "Data Persistence", "text": "\nOpens a connection to the SQLite database file database. By default returns a\n`Connection` object, unless a custom factory is given.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.Connection", "path": "library/sqlite3#sqlite3.Connection", "type": "Data Persistence", "text": "\nA SQLite database connection has the following attributes and methods:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.Connection.backup()", "path": "library/sqlite3#sqlite3.Connection.backup", "type": "Data Persistence", "text": "\nThis method makes a backup of a SQLite database even while it\u2019s being accessed\nby other clients, or concurrently by the same connection. The copy will be\nwritten into the mandatory argument target, that must be another `Connection`\ninstance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.Connection.close()", "path": "library/sqlite3#sqlite3.Connection.close", "type": "Data Persistence", "text": "\nThis closes the database connection. Note that this does not automatically\ncall `commit()`. If you just close your database connection without calling\n`commit()` first, your changes will be lost!\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.Connection.commit()", "path": "library/sqlite3#sqlite3.Connection.commit", "type": "Data Persistence", "text": "\nThis method commits the current transaction. If you don\u2019t call this method,\nanything you did since the last call to `commit()` is not visible from other\ndatabase connections. If you wonder why you don\u2019t see the data you\u2019ve written\nto the database, please check you didn\u2019t forget to call this method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.Connection.create_aggregate()", "path": "library/sqlite3#sqlite3.Connection.create_aggregate", "type": "Data Persistence", "text": "\nCreates a user-defined aggregate function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.Connection.create_collation()", "path": "library/sqlite3#sqlite3.Connection.create_collation", "type": "Data Persistence", "text": "\nCreates a collation with the specified name and callable. The callable will be\npassed two string arguments. It should return -1 if the first is ordered lower\nthan the second, 0 if they are ordered equal and 1 if the first is ordered\nhigher than the second. Note that this controls sorting (ORDER BY in SQL) so\nyour comparisons don\u2019t affect other SQL operations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.Connection.create_function()", "path": "library/sqlite3#sqlite3.Connection.create_function", "type": "Data Persistence", "text": "\nCreates a user-defined function that you can later use from within SQL\nstatements under the function name name. num_params is the number of\nparameters the function accepts (if num_params is -1, the function may take\nany number of arguments), and func is a Python callable that is called as the\nSQL function. If deterministic is true, the created function is marked as\ndeterministic, which allows SQLite to perform additional optimizations. This\nflag is supported by SQLite 3.8.3 or higher, `NotSupportedError` will be\nraised if used with older versions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.Connection.cursor()", "path": "library/sqlite3#sqlite3.Connection.cursor", "type": "Data Persistence", "text": "\nThe cursor method accepts a single optional parameter factory. If supplied,\nthis must be a callable returning an instance of `Cursor` or its subclasses.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.Connection.enable_load_extension()", "path": "library/sqlite3#sqlite3.Connection.enable_load_extension", "type": "Data Persistence", "text": "\nThis routine allows/disallows the SQLite engine to load SQLite extensions from\nshared libraries. SQLite extensions can define new functions, aggregates or\nwhole new virtual table implementations. One well-known extension is the\nfulltext-search extension distributed with SQLite.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.Connection.execute()", "path": "library/sqlite3#sqlite3.Connection.execute", "type": "Data Persistence", "text": "\nThis is a nonstandard shortcut that creates a cursor object by calling the\n`cursor()` method, calls the cursor\u2019s `execute()` method with the parameters\ngiven, and returns the cursor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.Connection.executemany()", "path": "library/sqlite3#sqlite3.Connection.executemany", "type": "Data Persistence", "text": "\nThis is a nonstandard shortcut that creates a cursor object by calling the\n`cursor()` method, calls the cursor\u2019s `executemany()` method with the\nparameters given, and returns the cursor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.Connection.executescript()", "path": "library/sqlite3#sqlite3.Connection.executescript", "type": "Data Persistence", "text": "\nThis is a nonstandard shortcut that creates a cursor object by calling the\n`cursor()` method, calls the cursor\u2019s `executescript()` method with the given\nsql_script, and returns the cursor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.Connection.interrupt()", "path": "library/sqlite3#sqlite3.Connection.interrupt", "type": "Data Persistence", "text": "\nYou can call this method from a different thread to abort any queries that\nmight be executing on the connection. The query will then abort and the caller\nwill get an exception.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.Connection.in_transaction", "path": "library/sqlite3#sqlite3.Connection.in_transaction", "type": "Data Persistence", "text": "\n`True` if a transaction is active (there are uncommitted changes), `False`\notherwise. Read-only attribute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.Connection.isolation_level", "path": "library/sqlite3#sqlite3.Connection.isolation_level", "type": "Data Persistence", "text": "\nGet or set the current default isolation level. `None` for autocommit mode or\none of \u201cDEFERRED\u201d, \u201cIMMEDIATE\u201d or \u201cEXCLUSIVE\u201d. See section Controlling\nTransactions for a more detailed explanation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.Connection.iterdump()", "path": "library/sqlite3#sqlite3.Connection.iterdump", "type": "Data Persistence", "text": "\nReturns an iterator to dump the database in an SQL text format. Useful when\nsaving an in-memory database for later restoration. This function provides the\nsame capabilities as the `.dump` command in the sqlite3 shell.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.Connection.load_extension()", "path": "library/sqlite3#sqlite3.Connection.load_extension", "type": "Data Persistence", "text": "\nThis routine loads a SQLite extension from a shared library. You have to\nenable extension loading with `enable_load_extension()` before you can use\nthis routine.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.Connection.rollback()", "path": "library/sqlite3#sqlite3.Connection.rollback", "type": "Data Persistence", "text": "\nThis method rolls back any changes to the database since the last call to\n`commit()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.Connection.row_factory", "path": "library/sqlite3#sqlite3.Connection.row_factory", "type": "Data Persistence", "text": "\nYou can change this attribute to a callable that accepts the cursor and the\noriginal row as a tuple and will return the real result row. This way, you can\nimplement more advanced ways of returning results, such as returning an object\nthat can also access columns by name.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.Connection.set_authorizer()", "path": "library/sqlite3#sqlite3.Connection.set_authorizer", "type": "Data Persistence", "text": "\nThis routine registers a callback. The callback is invoked for each attempt to\naccess a column of a table in the database. The callback should return\n`SQLITE_OK` if access is allowed, `SQLITE_DENY` if the entire SQL statement\nshould be aborted with an error and `SQLITE_IGNORE` if the column should be\ntreated as a NULL value. These constants are available in the `sqlite3`\nmodule.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.Connection.set_progress_handler()", "path": "library/sqlite3#sqlite3.Connection.set_progress_handler", "type": "Data Persistence", "text": "\nThis routine registers a callback. The callback is invoked for every n\ninstructions of the SQLite virtual machine. This is useful if you want to get\ncalled from SQLite during long-running operations, for example to update a\nGUI.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.Connection.set_trace_callback()", "path": "library/sqlite3#sqlite3.Connection.set_trace_callback", "type": "Data Persistence", "text": "\nRegisters trace_callback to be called for each SQL statement that is actually\nexecuted by the SQLite backend.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.Connection.text_factory", "path": "library/sqlite3#sqlite3.Connection.text_factory", "type": "Data Persistence", "text": "\nUsing this attribute you can control what objects are returned for the `TEXT`\ndata type. By default, this attribute is set to `str` and the `sqlite3` module\nwill return Unicode objects for `TEXT`. If you want to return bytestrings\ninstead, you can set it to `bytes`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.Connection.total_changes", "path": "library/sqlite3#sqlite3.Connection.total_changes", "type": "Data Persistence", "text": "\nReturns the total number of database rows that have been modified, inserted,\nor deleted since the database connection was opened.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.Cursor", "path": "library/sqlite3#sqlite3.Cursor", "type": "Data Persistence", "text": "\nA `Cursor` instance has the following attributes and methods.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.Cursor.arraysize", "path": "library/sqlite3#sqlite3.Cursor.arraysize", "type": "Data Persistence", "text": "\nRead/write attribute that controls the number of rows returned by\n`fetchmany()`. The default value is 1 which means a single row would be\nfetched per call.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.Cursor.close()", "path": "library/sqlite3#sqlite3.Cursor.close", "type": "Data Persistence", "text": "\nClose the cursor now (rather than whenever `__del__` is called).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.Cursor.connection", "path": "library/sqlite3#sqlite3.Cursor.connection", "type": "Data Persistence", "text": "\nThis read-only attribute provides the SQLite database `Connection` used by the\n`Cursor` object. A `Cursor` object created by calling `con.cursor()` will have\na `connection` attribute that refers to con:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.Cursor.description", "path": "library/sqlite3#sqlite3.Cursor.description", "type": "Data Persistence", "text": "\nThis read-only attribute provides the column names of the last query. To\nremain compatible with the Python DB API, it returns a 7-tuple for each column\nwhere the last six items of each tuple are `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.Cursor.execute()", "path": "library/sqlite3#sqlite3.Cursor.execute", "type": "Data Persistence", "text": "\nExecutes an SQL statement. Values may be bound to the statement using\nplaceholders.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.Cursor.executemany()", "path": "library/sqlite3#sqlite3.Cursor.executemany", "type": "Data Persistence", "text": "\nExecutes a parameterized SQL command against all parameter sequences or\nmappings found in the sequence seq_of_parameters. The `sqlite3` module also\nallows using an iterator yielding parameters instead of a sequence.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.Cursor.executescript()", "path": "library/sqlite3#sqlite3.Cursor.executescript", "type": "Data Persistence", "text": "\nThis is a nonstandard convenience method for executing multiple SQL statements\nat once. It issues a `COMMIT` statement first, then executes the SQL script it\ngets as a parameter.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.Cursor.fetchall()", "path": "library/sqlite3#sqlite3.Cursor.fetchall", "type": "Data Persistence", "text": "\nFetches all (remaining) rows of a query result, returning a list. Note that\nthe cursor\u2019s arraysize attribute can affect the performance of this operation.\nAn empty list is returned when no rows are available.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.Cursor.fetchmany()", "path": "library/sqlite3#sqlite3.Cursor.fetchmany", "type": "Data Persistence", "text": "\nFetches the next set of rows of a query result, returning a list. An empty\nlist is returned when no more rows are available.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.Cursor.fetchone()", "path": "library/sqlite3#sqlite3.Cursor.fetchone", "type": "Data Persistence", "text": "\nFetches the next row of a query result set, returning a single sequence, or\n`None` when no more data is available.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.Cursor.lastrowid", "path": "library/sqlite3#sqlite3.Cursor.lastrowid", "type": "Data Persistence", "text": "\nThis read-only attribute provides the rowid of the last modified row. It is\nonly set if you issued an `INSERT` or a `REPLACE` statement using the\n`execute()` method. For operations other than `INSERT` or `REPLACE` or when\n`executemany()` is called, `lastrowid` is set to `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.Cursor.rowcount", "path": "library/sqlite3#sqlite3.Cursor.rowcount", "type": "Data Persistence", "text": "\nAlthough the `Cursor` class of the `sqlite3` module implements this attribute,\nthe database engine\u2019s own support for the determination of \u201crows\naffected\u201d/\u201drows selected\u201d is quirky.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.DatabaseError", "path": "library/sqlite3#sqlite3.DatabaseError", "type": "Data Persistence", "text": "\nException raised for errors that are related to the database.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.enable_callback_tracebacks()", "path": "library/sqlite3#sqlite3.enable_callback_tracebacks", "type": "Data Persistence", "text": "\nBy default you will not get any tracebacks in user-defined functions,\naggregates, converters, authorizer callbacks etc. If you want to debug them,\nyou can call this function with flag set to `True`. Afterwards, you will get\ntracebacks from callbacks on `sys.stderr`. Use `False` to disable the feature\nagain.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.Error", "path": "library/sqlite3#sqlite3.Error", "type": "Data Persistence", "text": "\nThe base class of the other exceptions in this module. It is a subclass of\n`Exception`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.IntegrityError", "path": "library/sqlite3#sqlite3.IntegrityError", "type": "Data Persistence", "text": "\nException raised when the relational integrity of the database is affected,\ne.g. a foreign key check fails. It is a subclass of `DatabaseError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.NotSupportedError", "path": "library/sqlite3#sqlite3.NotSupportedError", "type": "Data Persistence", "text": "\nException raised in case a method or database API was used which is not\nsupported by the database, e.g. calling the `rollback()` method on a\nconnection that does not support transaction or has transactions turned off.\nIt is a subclass of `DatabaseError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.OperationalError", "path": "library/sqlite3#sqlite3.OperationalError", "type": "Data Persistence", "text": "\nException raised for errors that are related to the database\u2019s operation and\nnot necessarily under the control of the programmer, e.g. an unexpected\ndisconnect occurs, the data source name is not found, a transaction could not\nbe processed, etc. It is a subclass of `DatabaseError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.PARSE_COLNAMES", "path": "library/sqlite3#sqlite3.PARSE_COLNAMES", "type": "Data Persistence", "text": "\nThis constant is meant to be used with the detect_types parameter of the\n`connect()` function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.PARSE_DECLTYPES", "path": "library/sqlite3#sqlite3.PARSE_DECLTYPES", "type": "Data Persistence", "text": "\nThis constant is meant to be used with the detect_types parameter of the\n`connect()` function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.ProgrammingError", "path": "library/sqlite3#sqlite3.ProgrammingError", "type": "Data Persistence", "text": "\nException raised for programming errors, e.g. table not found or already\nexists, syntax error in the SQL statement, wrong number of parameters\nspecified, etc. It is a subclass of `DatabaseError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.register_adapter()", "path": "library/sqlite3#sqlite3.register_adapter", "type": "Data Persistence", "text": "\nRegisters a callable to convert the custom Python type type into one of\nSQLite\u2019s supported types. The callable callable accepts as single parameter\nthe Python value, and must return a value of the following types: int, float,\nstr or bytes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.register_converter()", "path": "library/sqlite3#sqlite3.register_converter", "type": "Data Persistence", "text": "\nRegisters a callable to convert a bytestring from the database into a custom\nPython type. The callable will be invoked for all database values that are of\nthe type typename. Confer the parameter detect_types of the `connect()`\nfunction for how the type detection works. Note that typename and the name of\nthe type in your query are matched in case-insensitive manner.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.Row", "path": "library/sqlite3#sqlite3.Row", "type": "Data Persistence", "text": "\nA `Row` instance serves as a highly optimized `row_factory` for `Connection`\nobjects. It tries to mimic a tuple in most of its features.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.Row.keys()", "path": "library/sqlite3#sqlite3.Row.keys", "type": "Data Persistence", "text": "\nThis method returns a list of column names. Immediately after a query, it is\nthe first member of each tuple in `Cursor.description`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.sqlite_version", "path": "library/sqlite3#sqlite3.sqlite_version", "type": "Data Persistence", "text": "\nThe version number of the run-time SQLite library, as a string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.sqlite_version_info", "path": "library/sqlite3#sqlite3.sqlite_version_info", "type": "Data Persistence", "text": "\nThe version number of the run-time SQLite library, as a tuple of integers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.version", "path": "library/sqlite3#sqlite3.version", "type": "Data Persistence", "text": "\nThe version number of this module, as a string. This is not the version of the\nSQLite library.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.version_info", "path": "library/sqlite3#sqlite3.version_info", "type": "Data Persistence", "text": "\nThe version number of this module, as a tuple of integers. This is not the\nversion of the SQLite library.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sqlite3.Warning", "path": "library/sqlite3#sqlite3.Warning", "type": "Data Persistence", "text": "\nA subclass of `Exception`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl", "path": "library/ssl", "type": "Networking & Interprocess Communication", "text": "\nSource code: Lib/ssl.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.AlertDescription", "path": "library/ssl#ssl.AlertDescription", "type": "Networking & Interprocess Communication", "text": "\n`enum.IntEnum` collection of ALERT_DESCRIPTION_* constants.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.ALERT_DESCRIPTION_HANDSHAKE_FAILURE", "path": "library/ssl#ssl.ALERT_DESCRIPTION_HANDSHAKE_FAILURE", "type": "Networking & Interprocess Communication", "text": "\nAlert Descriptions from RFC 5246 and others. The IANA TLS Alert Registry\ncontains this list and references to the RFCs where their meaning is defined.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.ALERT_DESCRIPTION_INTERNAL_ERROR", "path": "library/ssl#ssl.ALERT_DESCRIPTION_INTERNAL_ERROR", "type": "Networking & Interprocess Communication", "text": "\nAlert Descriptions from RFC 5246 and others. The IANA TLS Alert Registry\ncontains this list and references to the RFCs where their meaning is defined.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.CertificateError", "path": "library/ssl#ssl.CertificateError", "type": "Networking & Interprocess Communication", "text": "\nAn alias for `SSLCertVerificationError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.CERT_NONE", "path": "library/ssl#ssl.CERT_NONE", "type": "Networking & Interprocess Communication", "text": "\nPossible value for `SSLContext.verify_mode`, or the `cert_reqs` parameter to\n`wrap_socket()`. Except for `PROTOCOL_TLS_CLIENT`, it is the default mode.\nWith client-side sockets, just about any cert is accepted. Validation errors,\nsuch as untrusted or expired cert, are ignored and do not abort the TLS/SSL\nhandshake.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.CERT_OPTIONAL", "path": "library/ssl#ssl.CERT_OPTIONAL", "type": "Networking & Interprocess Communication", "text": "\nPossible value for `SSLContext.verify_mode`, or the `cert_reqs` parameter to\n`wrap_socket()`. In client mode, `CERT_OPTIONAL` has the same meaning as\n`CERT_REQUIRED`. It is recommended to use `CERT_REQUIRED` for client-side\nsockets instead.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.CERT_REQUIRED", "path": "library/ssl#ssl.CERT_REQUIRED", "type": "Networking & Interprocess Communication", "text": "\nPossible value for `SSLContext.verify_mode`, or the `cert_reqs` parameter to\n`wrap_socket()`. In this mode, certificates are required from the other side\nof the socket connection; an `SSLError` will be raised if no certificate is\nprovided, or if its validation fails. This mode is not sufficient to verify a\ncertificate in client mode as it does not match hostnames. `check_hostname`\nmust be enabled as well to verify the authenticity of a cert.\n`PROTOCOL_TLS_CLIENT` uses `CERT_REQUIRED` and enables `check_hostname` by\ndefault.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.cert_time_to_seconds()", "path": "library/ssl#ssl.cert_time_to_seconds", "type": "Networking & Interprocess Communication", "text": "\nReturn the time in seconds since the Epoch, given the `cert_time` string\nrepresenting the \u201cnotBefore\u201d or \u201cnotAfter\u201d date from a certificate in `\"%b %d\n%H:%M:%S %Y %Z\"` strptime format (C locale).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.CHANNEL_BINDING_TYPES", "path": "library/ssl#ssl.CHANNEL_BINDING_TYPES", "type": "Networking & Interprocess Communication", "text": "\nList of supported TLS channel binding types. Strings in this list can be used\nas arguments to `SSLSocket.get_channel_binding()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.create_default_context()", "path": "library/ssl#ssl.create_default_context", "type": "Networking & Interprocess Communication", "text": "\nReturn a new `SSLContext` object with default settings for the given purpose.\nThe settings are chosen by the `ssl` module, and usually represent a higher\nsecurity level than when calling the `SSLContext` constructor directly.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.DER_cert_to_PEM_cert()", "path": "library/ssl#ssl.DER_cert_to_PEM_cert", "type": "Networking & Interprocess Communication", "text": "\nGiven a certificate as a DER-encoded blob of bytes, returns a PEM-encoded\nstring version of the same certificate.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.enum_certificates()", "path": "library/ssl#ssl.enum_certificates", "type": "Networking & Interprocess Communication", "text": "\nRetrieve certificates from Windows\u2019 system cert store. store_name may be one\nof `CA`, `ROOT` or `MY`. Windows may provide additional cert stores, too.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.enum_crls()", "path": "library/ssl#ssl.enum_crls", "type": "Networking & Interprocess Communication", "text": "\nRetrieve CRLs from Windows\u2019 system cert store. store_name may be one of `CA`,\n`ROOT` or `MY`. Windows may provide additional cert stores, too.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.get_default_verify_paths()", "path": "library/ssl#ssl.get_default_verify_paths", "type": "Networking & Interprocess Communication", "text": "\nReturns a named tuple with paths to OpenSSL\u2019s default cafile and capath. The\npaths are the same as used by `SSLContext.set_default_verify_paths()`. The\nreturn value is a named tuple `DefaultVerifyPaths`:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.get_server_certificate()", "path": "library/ssl#ssl.get_server_certificate", "type": "Networking & Interprocess Communication", "text": "\nGiven the address `addr` of an SSL-protected server, as a (hostname, port-\nnumber) pair, fetches the server\u2019s certificate, and returns it as a PEM-\nencoded string. If `ssl_version` is specified, uses that version of the SSL\nprotocol to attempt to connect to the server. If `ca_certs` is specified, it\nshould be a file containing a list of root certificates, the same format as\nused for the same parameter in `SSLContext.wrap_socket()`. The call will\nattempt to validate the server certificate against that set of root\ncertificates, and will fail if the validation attempt fails.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.HAS_ALPN", "path": "library/ssl#ssl.HAS_ALPN", "type": "Networking & Interprocess Communication", "text": "\nWhether the OpenSSL library has built-in support for the Application-Layer\nProtocol Negotiation TLS extension as described in RFC 7301.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.HAS_ECDH", "path": "library/ssl#ssl.HAS_ECDH", "type": "Networking & Interprocess Communication", "text": "\nWhether the OpenSSL library has built-in support for the Elliptic Curve-based\nDiffie-Hellman key exchange. This should be true unless the feature was\nexplicitly disabled by the distributor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.HAS_NEVER_CHECK_COMMON_NAME", "path": "library/ssl#ssl.HAS_NEVER_CHECK_COMMON_NAME", "type": "Networking & Interprocess Communication", "text": "\nWhether the OpenSSL library has built-in support not checking subject common\nname and `SSLContext.hostname_checks_common_name` is writeable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.HAS_NPN", "path": "library/ssl#ssl.HAS_NPN", "type": "Networking & Interprocess Communication", "text": "\nWhether the OpenSSL library has built-in support for the Next Protocol\nNegotiation as described in the Application Layer Protocol Negotiation. When\ntrue, you can use the `SSLContext.set_npn_protocols()` method to advertise\nwhich protocols you want to support.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.HAS_SNI", "path": "library/ssl#ssl.HAS_SNI", "type": "Networking & Interprocess Communication", "text": "\nWhether the OpenSSL library has built-in support for the Server Name\nIndication extension (as defined in RFC 6066).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.HAS_SSLv2", "path": "library/ssl#ssl.HAS_SSLv2", "type": "Networking & Interprocess Communication", "text": "\nWhether the OpenSSL library has built-in support for the SSL 2.0 protocol.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.HAS_SSLv3", "path": "library/ssl#ssl.HAS_SSLv3", "type": "Networking & Interprocess Communication", "text": "\nWhether the OpenSSL library has built-in support for the SSL 3.0 protocol.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.HAS_TLSv1", "path": "library/ssl#ssl.HAS_TLSv1", "type": "Networking & Interprocess Communication", "text": "\nWhether the OpenSSL library has built-in support for the TLS 1.0 protocol.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.HAS_TLSv1_1", "path": "library/ssl#ssl.HAS_TLSv1_1", "type": "Networking & Interprocess Communication", "text": "\nWhether the OpenSSL library has built-in support for the TLS 1.1 protocol.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.HAS_TLSv1_2", "path": "library/ssl#ssl.HAS_TLSv1_2", "type": "Networking & Interprocess Communication", "text": "\nWhether the OpenSSL library has built-in support for the TLS 1.2 protocol.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.HAS_TLSv1_3", "path": "library/ssl#ssl.HAS_TLSv1_3", "type": "Networking & Interprocess Communication", "text": "\nWhether the OpenSSL library has built-in support for the TLS 1.3 protocol.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.match_hostname()", "path": "library/ssl#ssl.match_hostname", "type": "Networking & Interprocess Communication", "text": "\nVerify that cert (in decoded format as returned by `SSLSocket.getpeercert()`)\nmatches the given hostname. The rules applied are those for checking the\nidentity of HTTPS servers as outlined in RFC 2818, RFC 5280 and RFC 6125. In\naddition to HTTPS, this function should be suitable for checking the identity\nof servers in various SSL-based protocols such as FTPS, IMAPS, POPS and\nothers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.MemoryBIO", "path": "library/ssl#ssl.MemoryBIO", "type": "Networking & Interprocess Communication", "text": "\nA memory buffer that can be used to pass data between Python and an SSL\nprotocol instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.MemoryBIO.eof", "path": "library/ssl#ssl.MemoryBIO.eof", "type": "Networking & Interprocess Communication", "text": "\nA boolean indicating whether the memory BIO is current at the end-of-file\nposition.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.MemoryBIO.pending", "path": "library/ssl#ssl.MemoryBIO.pending", "type": "Networking & Interprocess Communication", "text": "\nReturn the number of bytes currently in the memory buffer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.MemoryBIO.read()", "path": "library/ssl#ssl.MemoryBIO.read", "type": "Networking & Interprocess Communication", "text": "\nRead up to n bytes from the memory buffer. If n is not specified or negative,\nall bytes are returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.MemoryBIO.write()", "path": "library/ssl#ssl.MemoryBIO.write", "type": "Networking & Interprocess Communication", "text": "\nWrite the bytes from buf to the memory BIO. The buf argument must be an object\nsupporting the buffer protocol.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.MemoryBIO.write_eof()", "path": "library/ssl#ssl.MemoryBIO.write_eof", "type": "Networking & Interprocess Communication", "text": "\nWrite an EOF marker to the memory BIO. After this method has been called, it\nis illegal to call `write()`. The attribute `eof` will become true after all\ndata currently in the buffer has been read.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.OPENSSL_VERSION", "path": "library/ssl#ssl.OPENSSL_VERSION", "type": "Networking & Interprocess Communication", "text": "\nThe version string of the OpenSSL library loaded by the interpreter:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.OPENSSL_VERSION_INFO", "path": "library/ssl#ssl.OPENSSL_VERSION_INFO", "type": "Networking & Interprocess Communication", "text": "\nA tuple of five integers representing version information about the OpenSSL\nlibrary:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.OPENSSL_VERSION_NUMBER", "path": "library/ssl#ssl.OPENSSL_VERSION_NUMBER", "type": "Networking & Interprocess Communication", "text": "\nThe raw version number of the OpenSSL library, as a single integer:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.Options", "path": "library/ssl#ssl.Options", "type": "Networking & Interprocess Communication", "text": "\n`enum.IntFlag` collection of OP_* constants.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.OP_ALL", "path": "library/ssl#ssl.OP_ALL", "type": "Networking & Interprocess Communication", "text": "\nEnables workarounds for various bugs present in other SSL implementations.\nThis option is set by default. It does not necessarily set the same flags as\nOpenSSL\u2019s `SSL_OP_ALL` constant.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.OP_CIPHER_SERVER_PREFERENCE", "path": "library/ssl#ssl.OP_CIPHER_SERVER_PREFERENCE", "type": "Networking & Interprocess Communication", "text": "\nUse the server\u2019s cipher ordering preference, rather than the client\u2019s. This\noption has no effect on client sockets and SSLv2 server sockets.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.OP_ENABLE_MIDDLEBOX_COMPAT", "path": "library/ssl#ssl.OP_ENABLE_MIDDLEBOX_COMPAT", "type": "Networking & Interprocess Communication", "text": "\nSend dummy Change Cipher Spec (CCS) messages in TLS 1.3 handshake to make a\nTLS 1.3 connection look more like a TLS 1.2 connection.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.OP_IGNORE_UNEXPECTED_EOF", "path": "library/ssl#ssl.OP_IGNORE_UNEXPECTED_EOF", "type": "Networking & Interprocess Communication", "text": "\nIgnore unexpected shutdown of TLS connections.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.OP_NO_COMPRESSION", "path": "library/ssl#ssl.OP_NO_COMPRESSION", "type": "Networking & Interprocess Communication", "text": "\nDisable compression on the SSL channel. This is useful if the application\nprotocol supports its own compression scheme.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.OP_NO_RENEGOTIATION", "path": "library/ssl#ssl.OP_NO_RENEGOTIATION", "type": "Networking & Interprocess Communication", "text": "\nDisable all renegotiation in TLSv1.2 and earlier. Do not send HelloRequest\nmessages, and ignore renegotiation requests via ClientHello.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.OP_NO_SSLv2", "path": "library/ssl#ssl.OP_NO_SSLv2", "type": "Networking & Interprocess Communication", "text": "\nPrevents an SSLv2 connection. This option is only applicable in conjunction\nwith `PROTOCOL_TLS`. It prevents the peers from choosing SSLv2 as the protocol\nversion.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.OP_NO_SSLv3", "path": "library/ssl#ssl.OP_NO_SSLv3", "type": "Networking & Interprocess Communication", "text": "\nPrevents an SSLv3 connection. This option is only applicable in conjunction\nwith `PROTOCOL_TLS`. It prevents the peers from choosing SSLv3 as the protocol\nversion.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.OP_NO_TICKET", "path": "library/ssl#ssl.OP_NO_TICKET", "type": "Networking & Interprocess Communication", "text": "\nPrevent client side from requesting a session ticket.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.OP_NO_TLSv1", "path": "library/ssl#ssl.OP_NO_TLSv1", "type": "Networking & Interprocess Communication", "text": "\nPrevents a TLSv1 connection. This option is only applicable in conjunction\nwith `PROTOCOL_TLS`. It prevents the peers from choosing TLSv1 as the protocol\nversion.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.OP_NO_TLSv1_1", "path": "library/ssl#ssl.OP_NO_TLSv1_1", "type": "Networking & Interprocess Communication", "text": "\nPrevents a TLSv1.1 connection. This option is only applicable in conjunction\nwith `PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.1 as the\nprotocol version. Available only with openssl version 1.0.1+.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.OP_NO_TLSv1_2", "path": "library/ssl#ssl.OP_NO_TLSv1_2", "type": "Networking & Interprocess Communication", "text": "\nPrevents a TLSv1.2 connection. This option is only applicable in conjunction\nwith `PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.2 as the\nprotocol version. Available only with openssl version 1.0.1+.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.OP_NO_TLSv1_3", "path": "library/ssl#ssl.OP_NO_TLSv1_3", "type": "Networking & Interprocess Communication", "text": "\nPrevents a TLSv1.3 connection. This option is only applicable in conjunction\nwith `PROTOCOL_TLS`. It prevents the peers from choosing TLSv1.3 as the\nprotocol version. TLS 1.3 is available with OpenSSL 1.1.1 or later. When\nPython has been compiled against an older version of OpenSSL, the flag\ndefaults to 0.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.OP_SINGLE_DH_USE", "path": "library/ssl#ssl.OP_SINGLE_DH_USE", "type": "Networking & Interprocess Communication", "text": "\nPrevents re-use of the same DH key for distinct SSL sessions. This improves\nforward secrecy but requires more computational resources. This option only\napplies to server sockets.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.OP_SINGLE_ECDH_USE", "path": "library/ssl#ssl.OP_SINGLE_ECDH_USE", "type": "Networking & Interprocess Communication", "text": "\nPrevents re-use of the same ECDH key for distinct SSL sessions. This improves\nforward secrecy but requires more computational resources. This option only\napplies to server sockets.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.PEM_cert_to_DER_cert()", "path": "library/ssl#ssl.PEM_cert_to_DER_cert", "type": "Networking & Interprocess Communication", "text": "\nGiven a certificate as an ASCII PEM string, returns a DER-encoded sequence of\nbytes for that same certificate.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.PROTOCOL_SSLv2", "path": "library/ssl#ssl.PROTOCOL_SSLv2", "type": "Networking & Interprocess Communication", "text": "\nSelects SSL version 2 as the channel encryption protocol.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.PROTOCOL_SSLv23", "path": "library/ssl#ssl.PROTOCOL_SSLv23", "type": "Networking & Interprocess Communication", "text": "\nAlias for `PROTOCOL_TLS`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.PROTOCOL_SSLv3", "path": "library/ssl#ssl.PROTOCOL_SSLv3", "type": "Networking & Interprocess Communication", "text": "\nSelects SSL version 3 as the channel encryption protocol.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.PROTOCOL_TLS", "path": "library/ssl#ssl.PROTOCOL_TLS", "type": "Networking & Interprocess Communication", "text": "\nSelects the highest protocol version that both the client and server support.\nDespite the name, this option can select both \u201cSSL\u201d and \u201cTLS\u201d protocols.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.PROTOCOL_TLSv1", "path": "library/ssl#ssl.PROTOCOL_TLSv1", "type": "Networking & Interprocess Communication", "text": "\nSelects TLS version 1.0 as the channel encryption protocol.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.PROTOCOL_TLSv1_1", "path": "library/ssl#ssl.PROTOCOL_TLSv1_1", "type": "Networking & Interprocess Communication", "text": "\nSelects TLS version 1.1 as the channel encryption protocol. Available only\nwith openssl version 1.0.1+.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.PROTOCOL_TLSv1_2", "path": "library/ssl#ssl.PROTOCOL_TLSv1_2", "type": "Networking & Interprocess Communication", "text": "\nSelects TLS version 1.2 as the channel encryption protocol. This is the most\nmodern version, and probably the best choice for maximum protection, if both\nsides can speak it. Available only with openssl version 1.0.1+.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.PROTOCOL_TLS_CLIENT", "path": "library/ssl#ssl.PROTOCOL_TLS_CLIENT", "type": "Networking & Interprocess Communication", "text": "\nAuto-negotiate the highest protocol version like `PROTOCOL_TLS`, but only\nsupport client-side `SSLSocket` connections. The protocol enables\n`CERT_REQUIRED` and `check_hostname` by default.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.PROTOCOL_TLS_SERVER", "path": "library/ssl#ssl.PROTOCOL_TLS_SERVER", "type": "Networking & Interprocess Communication", "text": "\nAuto-negotiate the highest protocol version like `PROTOCOL_TLS`, but only\nsupport server-side `SSLSocket` connections.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.Purpose.CLIENT_AUTH", "path": "library/ssl#ssl.Purpose.CLIENT_AUTH", "type": "Networking & Interprocess Communication", "text": "\nOption for `create_default_context()` and `SSLContext.load_default_certs()`.\nThis value indicates that the context may be used to authenticate Web clients\n(therefore, it will be used to create server-side sockets).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.Purpose.SERVER_AUTH", "path": "library/ssl#ssl.Purpose.SERVER_AUTH", "type": "Networking & Interprocess Communication", "text": "\nOption for `create_default_context()` and `SSLContext.load_default_certs()`.\nThis value indicates that the context may be used to authenticate Web servers\n(therefore, it will be used to create client-side sockets).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.RAND_add()", "path": "library/ssl#ssl.RAND_add", "type": "Networking & Interprocess Communication", "text": "\nMix the given bytes into the SSL pseudo-random number generator. The parameter\nentropy (a float) is a lower bound on the entropy contained in string (so you\ncan always use `0.0`). See RFC 1750 for more information on sources of\nentropy.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.RAND_bytes()", "path": "library/ssl#ssl.RAND_bytes", "type": "Networking & Interprocess Communication", "text": "\nReturn num cryptographically strong pseudo-random bytes. Raises an `SSLError`\nif the PRNG has not been seeded with enough data or if the operation is not\nsupported by the current RAND method. `RAND_status()` can be used to check the\nstatus of the PRNG and `RAND_add()` can be used to seed the PRNG.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.RAND_egd()", "path": "library/ssl#ssl.RAND_egd", "type": "Networking & Interprocess Communication", "text": "\nIf you are running an entropy-gathering daemon (EGD) somewhere, and path is\nthe pathname of a socket connection open to it, this will read 256 bytes of\nrandomness from the socket, and add it to the SSL pseudo-random number\ngenerator to increase the security of generated secret keys. This is typically\nonly necessary on systems without better sources of randomness.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.RAND_pseudo_bytes()", "path": "library/ssl#ssl.RAND_pseudo_bytes", "type": "Networking & Interprocess Communication", "text": "\nReturn (bytes, is_cryptographic): bytes are num pseudo-random bytes,\nis_cryptographic is `True` if the bytes generated are cryptographically\nstrong. Raises an `SSLError` if the operation is not supported by the current\nRAND method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.RAND_status()", "path": "library/ssl#ssl.RAND_status", "type": "Networking & Interprocess Communication", "text": "\nReturn `True` if the SSL pseudo-random number generator has been seeded with\n\u2018enough\u2019 randomness, and `False` otherwise. You can use `ssl.RAND_egd()` and\n`ssl.RAND_add()` to increase the randomness of the pseudo-random number\ngenerator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLCertVerificationError", "path": "library/ssl#ssl.SSLCertVerificationError", "type": "Networking & Interprocess Communication", "text": "\nA subclass of `SSLError` raised when certificate validation has failed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLCertVerificationError.verify_code", "path": "library/ssl#ssl.SSLCertVerificationError.verify_code", "type": "Networking & Interprocess Communication", "text": "\nA numeric error number that denotes the verification error.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLCertVerificationError.verify_message", "path": "library/ssl#ssl.SSLCertVerificationError.verify_message", "type": "Networking & Interprocess Communication", "text": "\nA human readable string of the verification error.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLContext", "path": "library/ssl#ssl.SSLContext", "type": "Networking & Interprocess Communication", "text": "\nCreate a new SSL context. You may pass protocol which must be one of the\n`PROTOCOL_*` constants defined in this module. The parameter specifies which\nversion of the SSL protocol to use. Typically, the server chooses a particular\nprotocol version, and the client must adapt to the server\u2019s choice. Most of\nthe versions are not interoperable with the other versions. If not specified,\nthe default is `PROTOCOL_TLS`; it provides the most compatibility with other\nversions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLContext.cert_store_stats()", "path": "library/ssl#ssl.SSLContext.cert_store_stats", "type": "Networking & Interprocess Communication", "text": "\nGet statistics about quantities of loaded X.509 certificates, count of X.509\ncertificates flagged as CA certificates and certificate revocation lists as\ndictionary.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLContext.check_hostname", "path": "library/ssl#ssl.SSLContext.check_hostname", "type": "Networking & Interprocess Communication", "text": "\nWhether to match the peer cert\u2019s hostname in `SSLSocket.do_handshake()`. The\ncontext\u2019s `verify_mode` must be set to `CERT_OPTIONAL` or `CERT_REQUIRED`, and\nyou must pass server_hostname to `wrap_socket()` in order to match the\nhostname. Enabling hostname checking automatically sets `verify_mode` from\n`CERT_NONE` to `CERT_REQUIRED`. It cannot be set back to `CERT_NONE` as long\nas hostname checking is enabled. The `PROTOCOL_TLS_CLIENT` protocol enables\nhostname checking by default. With other protocols, hostname checking must be\nenabled explicitly.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLContext.get_ca_certs()", "path": "library/ssl#ssl.SSLContext.get_ca_certs", "type": "Networking & Interprocess Communication", "text": "\nGet a list of loaded \u201ccertification authority\u201d (CA) certificates. If the\n`binary_form` parameter is `False` each list entry is a dict like the output\nof `SSLSocket.getpeercert()`. Otherwise the method returns a list of DER-\nencoded certificates. The returned list does not contain certificates from\ncapath unless a certificate was requested and loaded by a SSL connection.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLContext.get_ciphers()", "path": "library/ssl#ssl.SSLContext.get_ciphers", "type": "Networking & Interprocess Communication", "text": "\nGet a list of enabled ciphers. The list is in order of cipher priority. See\n`SSLContext.set_ciphers()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLContext.hostname_checks_common_name", "path": "library/ssl#ssl.SSLContext.hostname_checks_common_name", "type": "Networking & Interprocess Communication", "text": "\nWhether `check_hostname` falls back to verify the cert\u2019s subject common name\nin the absence of a subject alternative name extension (default: true).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLContext.keylog_filename", "path": "library/ssl#ssl.SSLContext.keylog_filename", "type": "Networking & Interprocess Communication", "text": "\nWrite TLS keys to a keylog file, whenever key material is generated or\nreceived. The keylog file is designed for debugging purposes only. The file\nformat is specified by NSS and used by many traffic analyzers such as\nWireshark. The log file is opened in append-only mode. Writes are synchronized\nbetween threads, but not between processes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLContext.load_cert_chain()", "path": "library/ssl#ssl.SSLContext.load_cert_chain", "type": "Networking & Interprocess Communication", "text": "\nLoad a private key and the corresponding certificate. The certfile string must\nbe the path to a single file in PEM format containing the certificate as well\nas any number of CA certificates needed to establish the certificate\u2019s\nauthenticity. The keyfile string, if present, must point to a file containing\nthe private key in. Otherwise the private key will be taken from certfile as\nwell. See the discussion of Certificates for more information on how the\ncertificate is stored in the certfile.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLContext.load_default_certs()", "path": "library/ssl#ssl.SSLContext.load_default_certs", "type": "Networking & Interprocess Communication", "text": "\nLoad a set of default \u201ccertification authority\u201d (CA) certificates from default\nlocations. On Windows it loads CA certs from the `CA` and `ROOT` system\nstores. On other systems it calls `SSLContext.set_default_verify_paths()`. In\nthe future the method may load CA certificates from other locations, too.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLContext.load_dh_params()", "path": "library/ssl#ssl.SSLContext.load_dh_params", "type": "Networking & Interprocess Communication", "text": "\nLoad the key generation parameters for Diffie-Hellman (DH) key exchange. Using\nDH key exchange improves forward secrecy at the expense of computational\nresources (both on the server and on the client). The dhfile parameter should\nbe the path to a file containing DH parameters in PEM format.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLContext.load_verify_locations()", "path": "library/ssl#ssl.SSLContext.load_verify_locations", "type": "Networking & Interprocess Communication", "text": "\nLoad a set of \u201ccertification authority\u201d (CA) certificates used to validate\nother peers\u2019 certificates when `verify_mode` is other than `CERT_NONE`. At\nleast one of cafile or capath must be specified.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLContext.maximum_version", "path": "library/ssl#ssl.SSLContext.maximum_version", "type": "Networking & Interprocess Communication", "text": "\nA `TLSVersion` enum member representing the highest supported TLS version. The\nvalue defaults to `TLSVersion.MAXIMUM_SUPPORTED`. The attribute is read-only\nfor protocols other than `PROTOCOL_TLS`, `PROTOCOL_TLS_CLIENT`, and\n`PROTOCOL_TLS_SERVER`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLContext.minimum_version", "path": "library/ssl#ssl.SSLContext.minimum_version", "type": "Networking & Interprocess Communication", "text": "\nLike `SSLContext.maximum_version` except it is the lowest supported version or\n`TLSVersion.MINIMUM_SUPPORTED`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLContext.num_tickets", "path": "library/ssl#ssl.SSLContext.num_tickets", "type": "Networking & Interprocess Communication", "text": "\nControl the number of TLS 1.3 session tickets of a `TLS_PROTOCOL_SERVER`\ncontext. The setting has no impact on TLS 1.0 to 1.2 connections.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLContext.options", "path": "library/ssl#ssl.SSLContext.options", "type": "Networking & Interprocess Communication", "text": "\nAn integer representing the set of SSL options enabled on this context. The\ndefault value is `OP_ALL`, but you can specify other options such as\n`OP_NO_SSLv2` by ORing them together.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLContext.post_handshake_auth", "path": "library/ssl#ssl.SSLContext.post_handshake_auth", "type": "Networking & Interprocess Communication", "text": "\nEnable TLS 1.3 post-handshake client authentication. Post-handshake auth is\ndisabled by default and a server can only request a TLS client certificate\nduring the initial handshake. When enabled, a server may request a TLS client\ncertificate at any time after the handshake.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLContext.protocol", "path": "library/ssl#ssl.SSLContext.protocol", "type": "Networking & Interprocess Communication", "text": "\nThe protocol version chosen when constructing the context. This attribute is\nread-only.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLContext.session_stats()", "path": "library/ssl#ssl.SSLContext.session_stats", "type": "Networking & Interprocess Communication", "text": "\nGet statistics about the SSL sessions created or managed by this context. A\ndictionary is returned which maps the names of each piece of information to\ntheir numeric values. For example, here is the total number of hits and misses\nin the session cache since the context was created:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLContext.set_alpn_protocols()", "path": "library/ssl#ssl.SSLContext.set_alpn_protocols", "type": "Networking & Interprocess Communication", "text": "\nSpecify which protocols the socket should advertise during the SSL/TLS\nhandshake. It should be a list of ASCII strings, like `['http/1.1',\n'spdy/2']`, ordered by preference. The selection of a protocol will happen\nduring the handshake, and will play out according to RFC 7301. After a\nsuccessful handshake, the `SSLSocket.selected_alpn_protocol()` method will\nreturn the agreed-upon protocol.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLContext.set_ciphers()", "path": "library/ssl#ssl.SSLContext.set_ciphers", "type": "Networking & Interprocess Communication", "text": "\nSet the available ciphers for sockets created with this context. It should be\na string in the OpenSSL cipher list format. If no cipher can be selected\n(because compile-time options or other configuration forbids use of all the\nspecified ciphers), an `SSLError` will be raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLContext.set_default_verify_paths()", "path": "library/ssl#ssl.SSLContext.set_default_verify_paths", "type": "Networking & Interprocess Communication", "text": "\nLoad a set of default \u201ccertification authority\u201d (CA) certificates from a\nfilesystem path defined when building the OpenSSL library. Unfortunately,\nthere\u2019s no easy way to know whether this method succeeds: no error is returned\nif no certificates are to be found. When the OpenSSL library is provided as\npart of the operating system, though, it is likely to be configured properly.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLContext.set_ecdh_curve()", "path": "library/ssl#ssl.SSLContext.set_ecdh_curve", "type": "Networking & Interprocess Communication", "text": "\nSet the curve name for Elliptic Curve-based Diffie-Hellman (ECDH) key\nexchange. ECDH is significantly faster than regular DH while arguably as\nsecure. The curve_name parameter should be a string describing a well-known\nelliptic curve, for example `prime256v1` for a widely supported curve.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLContext.set_npn_protocols()", "path": "library/ssl#ssl.SSLContext.set_npn_protocols", "type": "Networking & Interprocess Communication", "text": "\nSpecify which protocols the socket should advertise during the SSL/TLS\nhandshake. It should be a list of strings, like `['http/1.1', 'spdy/2']`,\nordered by preference. The selection of a protocol will happen during the\nhandshake, and will play out according to the Application Layer Protocol\nNegotiation. After a successful handshake, the\n`SSLSocket.selected_npn_protocol()` method will return the agreed-upon\nprotocol.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLContext.set_servername_callback", "path": "library/ssl#ssl.SSLContext.set_servername_callback", "type": "Networking & Interprocess Communication", "text": "\nThis is a legacy API retained for backwards compatibility. When possible, you\nshould use `sni_callback` instead. The given server_name_callback is similar\nto sni_callback, except that when the server hostname is an IDN-encoded\ninternationalized domain name, the server_name_callback receives a decoded\nU-label (`\"pyth\u00f6n.org\"`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLContext.sni_callback", "path": "library/ssl#ssl.SSLContext.sni_callback", "type": "Networking & Interprocess Communication", "text": "\nRegister a callback function that will be called after the TLS Client Hello\nhandshake message has been received by the SSL/TLS server when the TLS client\nspecifies a server name indication. The server name indication mechanism is\nspecified in RFC 6066 section 3 - Server Name Indication.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLContext.sslobject_class", "path": "library/ssl#ssl.SSLContext.sslobject_class", "type": "Networking & Interprocess Communication", "text": "\nThe return type of `SSLContext.wrap_bio()`, defaults to `SSLObject`. The\nattribute can be overridden on instance of class in order to return a custom\nsubclass of `SSLObject`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLContext.sslsocket_class", "path": "library/ssl#ssl.SSLContext.sslsocket_class", "type": "Networking & Interprocess Communication", "text": "\nThe return type of `SSLContext.wrap_socket()`, defaults to `SSLSocket`. The\nattribute can be overridden on instance of class in order to return a custom\nsubclass of `SSLSocket`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLContext.verify_flags", "path": "library/ssl#ssl.SSLContext.verify_flags", "type": "Networking & Interprocess Communication", "text": "\nThe flags for certificate verification operations. You can set flags like\n`VERIFY_CRL_CHECK_LEAF` by ORing them together. By default OpenSSL does\nneither require nor verify certificate revocation lists (CRLs). Available only\nwith openssl version 0.9.8+.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLContext.verify_mode", "path": "library/ssl#ssl.SSLContext.verify_mode", "type": "Networking & Interprocess Communication", "text": "\nWhether to try to verify other peers\u2019 certificates and how to behave if\nverification fails. This attribute must be one of `CERT_NONE`, `CERT_OPTIONAL`\nor `CERT_REQUIRED`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLContext.wrap_bio()", "path": "library/ssl#ssl.SSLContext.wrap_bio", "type": "Networking & Interprocess Communication", "text": "\nWrap the BIO objects incoming and outgoing and return an instance of\n`SSLContext.sslobject_class` (default `SSLObject`). The SSL routines will read\ninput data from the incoming BIO and write data to the outgoing BIO.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLContext.wrap_socket()", "path": "library/ssl#ssl.SSLContext.wrap_socket", "type": "Networking & Interprocess Communication", "text": "\nWrap an existing Python socket sock and return an instance of\n`SSLContext.sslsocket_class` (default `SSLSocket`). The returned SSL socket is\ntied to the context, its settings and certificates. sock must be a\n`SOCK_STREAM` socket; other socket types are unsupported.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLEOFError", "path": "library/ssl#ssl.SSLEOFError", "type": "Networking & Interprocess Communication", "text": "\nA subclass of `SSLError` raised when the SSL connection has been terminated\nabruptly. Generally, you shouldn\u2019t try to reuse the underlying transport when\nthis error is encountered.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLError", "path": "library/ssl#ssl.SSLError", "type": "Networking & Interprocess Communication", "text": "\nRaised to signal an error from the underlying SSL implementation (currently\nprovided by the OpenSSL library). This signifies some problem in the higher-\nlevel encryption and authentication layer that\u2019s superimposed on the\nunderlying network connection. This error is a subtype of `OSError`. The error\ncode and message of `SSLError` instances are provided by the OpenSSL library.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLError.library", "path": "library/ssl#ssl.SSLError.library", "type": "Networking & Interprocess Communication", "text": "\nA string mnemonic designating the OpenSSL submodule in which the error\noccurred, such as `SSL`, `PEM` or `X509`. The range of possible values depends\non the OpenSSL version.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLError.reason", "path": "library/ssl#ssl.SSLError.reason", "type": "Networking & Interprocess Communication", "text": "\nA string mnemonic designating the reason this error occurred, for example\n`CERTIFICATE_VERIFY_FAILED`. The range of possible values depends on the\nOpenSSL version.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLErrorNumber", "path": "library/ssl#ssl.SSLErrorNumber", "type": "Networking & Interprocess Communication", "text": "\n`enum.IntEnum` collection of SSL_ERROR_* constants.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLObject", "path": "library/ssl#ssl.SSLObject", "type": "Networking & Interprocess Communication", "text": "\nA reduced-scope variant of `SSLSocket` representing an SSL protocol instance\nthat does not contain any network IO methods. This class is typically used by\nframework authors that want to implement asynchronous IO for SSL through\nmemory buffers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLSession", "path": "library/ssl#ssl.SSLSession", "type": "Networking & Interprocess Communication", "text": "\nSession object used by `session`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLSession.has_ticket", "path": "library/ssl#ssl.SSLSession.has_ticket", "type": "Networking & Interprocess Communication", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLSession.id", "path": "library/ssl#ssl.SSLSession.id", "type": "Networking & Interprocess Communication", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLSession.ticket_lifetime_hint", "path": "library/ssl#ssl.SSLSession.ticket_lifetime_hint", "type": "Networking & Interprocess Communication", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLSession.time", "path": "library/ssl#ssl.SSLSession.time", "type": "Networking & Interprocess Communication", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLSession.timeout", "path": "library/ssl#ssl.SSLSession.timeout", "type": "Networking & Interprocess Communication", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLSocket", "path": "library/ssl#ssl.SSLSocket", "type": "Networking & Interprocess Communication", "text": "\nSSL sockets provide the following methods of Socket Objects:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLSocket.cipher()", "path": "library/ssl#ssl.SSLSocket.cipher", "type": "Networking & Interprocess Communication", "text": "\nReturns a three-value tuple containing the name of the cipher being used, the\nversion of the SSL protocol that defines its use, and the number of secret\nbits being used. If no connection has been established, returns `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLSocket.compression()", "path": "library/ssl#ssl.SSLSocket.compression", "type": "Networking & Interprocess Communication", "text": "\nReturn the compression algorithm being used as a string, or `None` if the\nconnection isn\u2019t compressed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLSocket.context", "path": "library/ssl#ssl.SSLSocket.context", "type": "Networking & Interprocess Communication", "text": "\nThe `SSLContext` object this SSL socket is tied to. If the SSL socket was\ncreated using the deprecated `wrap_socket()` function (rather than\n`SSLContext.wrap_socket()`), this is a custom context object created for this\nSSL socket.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLSocket.do_handshake()", "path": "library/ssl#ssl.SSLSocket.do_handshake", "type": "Networking & Interprocess Communication", "text": "\nPerform the SSL setup handshake.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLSocket.getpeercert()", "path": "library/ssl#ssl.SSLSocket.getpeercert", "type": "Networking & Interprocess Communication", "text": "\nIf there is no certificate for the peer on the other end of the connection,\nreturn `None`. If the SSL handshake hasn\u2019t been done yet, raise `ValueError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLSocket.get_channel_binding()", "path": "library/ssl#ssl.SSLSocket.get_channel_binding", "type": "Networking & Interprocess Communication", "text": "\nGet channel binding data for current connection, as a bytes object. Returns\n`None` if not connected or the handshake has not been completed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLSocket.pending()", "path": "library/ssl#ssl.SSLSocket.pending", "type": "Networking & Interprocess Communication", "text": "\nReturns the number of already decrypted bytes available for read, pending on\nthe connection.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLSocket.read()", "path": "library/ssl#ssl.SSLSocket.read", "type": "Networking & Interprocess Communication", "text": "\nRead up to len bytes of data from the SSL socket and return the result as a\n`bytes` instance. If buffer is specified, then read into the buffer instead,\nand return the number of bytes read.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLSocket.selected_alpn_protocol()", "path": "library/ssl#ssl.SSLSocket.selected_alpn_protocol", "type": "Networking & Interprocess Communication", "text": "\nReturn the protocol that was selected during the TLS handshake. If\n`SSLContext.set_alpn_protocols()` was not called, if the other party does not\nsupport ALPN, if this socket does not support any of the client\u2019s proposed\nprotocols, or if the handshake has not happened yet, `None` is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLSocket.selected_npn_protocol()", "path": "library/ssl#ssl.SSLSocket.selected_npn_protocol", "type": "Networking & Interprocess Communication", "text": "\nReturn the higher-level protocol that was selected during the TLS/SSL\nhandshake. If `SSLContext.set_npn_protocols()` was not called, or if the other\nparty does not support NPN, or if the handshake has not yet happened, this\nwill return `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLSocket.server_hostname", "path": "library/ssl#ssl.SSLSocket.server_hostname", "type": "Networking & Interprocess Communication", "text": "\nHostname of the server: `str` type, or `None` for server-side socket or if the\nhostname was not specified in the constructor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLSocket.server_side", "path": "library/ssl#ssl.SSLSocket.server_side", "type": "Networking & Interprocess Communication", "text": "\nA boolean which is `True` for server-side sockets and `False` for client-side\nsockets.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLSocket.session", "path": "library/ssl#ssl.SSLSocket.session", "type": "Networking & Interprocess Communication", "text": "\nThe `SSLSession` for this SSL connection. The session is available for client\nand server side sockets after the TLS handshake has been performed. For client\nsockets the session can be set before `do_handshake()` has been called to\nreuse a session.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLSocket.session_reused", "path": "library/ssl#ssl.SSLSocket.session_reused", "type": "Networking & Interprocess Communication", "text": "\nNew in version 3.6.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLSocket.shared_ciphers()", "path": "library/ssl#ssl.SSLSocket.shared_ciphers", "type": "Networking & Interprocess Communication", "text": "\nReturn the list of ciphers shared by the client during the handshake. Each\nentry of the returned list is a three-value tuple containing the name of the\ncipher, the version of the SSL protocol that defines its use, and the number\nof secret bits the cipher uses. `shared_ciphers()` returns `None` if no\nconnection has been established or the socket is a client socket.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLSocket.unwrap()", "path": "library/ssl#ssl.SSLSocket.unwrap", "type": "Networking & Interprocess Communication", "text": "\nPerforms the SSL shutdown handshake, which removes the TLS layer from the\nunderlying socket, and returns the underlying socket object. This can be used\nto go from encrypted operation over a connection to unencrypted. The returned\nsocket should always be used for further communication with the other side of\nthe connection, rather than the original socket.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLSocket.verify_client_post_handshake()", "path": "library/ssl#ssl.SSLSocket.verify_client_post_handshake", "type": "Networking & Interprocess Communication", "text": "\nRequests post-handshake authentication (PHA) from a TLS 1.3 client. PHA can\nonly be initiated for a TLS 1.3 connection from a server-side socket, after\nthe initial TLS handshake and with PHA enabled on both sides, see\n`SSLContext.post_handshake_auth`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLSocket.version()", "path": "library/ssl#ssl.SSLSocket.version", "type": "Networking & Interprocess Communication", "text": "\nReturn the actual SSL protocol version negotiated by the connection as a\nstring, or `None` is no secure connection is established. As of this writing,\npossible return values include `\"SSLv2\"`, `\"SSLv3\"`, `\"TLSv1\"`, `\"TLSv1.1\"`\nand `\"TLSv1.2\"`. Recent OpenSSL versions may define more return values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLSocket.write()", "path": "library/ssl#ssl.SSLSocket.write", "type": "Networking & Interprocess Communication", "text": "\nWrite buf to the SSL socket and return the number of bytes written. The buf\nargument must be an object supporting the buffer interface.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLSyscallError", "path": "library/ssl#ssl.SSLSyscallError", "type": "Networking & Interprocess Communication", "text": "\nA subclass of `SSLError` raised when a system error was encountered while\ntrying to fulfill an operation on a SSL socket. Unfortunately, there is no\neasy way to inspect the original errno number.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLWantReadError", "path": "library/ssl#ssl.SSLWantReadError", "type": "Networking & Interprocess Communication", "text": "\nA subclass of `SSLError` raised by a non-blocking SSL socket when trying to\nread or write data, but more data needs to be received on the underlying TCP\ntransport before the request can be fulfilled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLWantWriteError", "path": "library/ssl#ssl.SSLWantWriteError", "type": "Networking & Interprocess Communication", "text": "\nA subclass of `SSLError` raised by a non-blocking SSL socket when trying to\nread or write data, but more data needs to be sent on the underlying TCP\ntransport before the request can be fulfilled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.SSLZeroReturnError", "path": "library/ssl#ssl.SSLZeroReturnError", "type": "Networking & Interprocess Communication", "text": "\nA subclass of `SSLError` raised when trying to read or write and the SSL\nconnection has been closed cleanly. Note that this doesn\u2019t mean that the\nunderlying transport (read TCP) has been closed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.TLSVersion", "path": "library/ssl#ssl.TLSVersion", "type": "Networking & Interprocess Communication", "text": "\n`enum.IntEnum` collection of SSL and TLS versions for\n`SSLContext.maximum_version` and `SSLContext.minimum_version`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.TLSVersion.MAXIMUM_SUPPORTED", "path": "library/ssl#ssl.TLSVersion.MAXIMUM_SUPPORTED", "type": "Networking & Interprocess Communication", "text": "\nThe minimum or maximum supported SSL or TLS version. These are magic\nconstants. Their values don\u2019t reflect the lowest and highest available TLS/SSL\nversions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.TLSVersion.MINIMUM_SUPPORTED", "path": "library/ssl#ssl.TLSVersion.MINIMUM_SUPPORTED", "type": "Networking & Interprocess Communication", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.TLSVersion.SSLv3", "path": "library/ssl#ssl.TLSVersion.SSLv3", "type": "Networking & Interprocess Communication", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.TLSVersion.TLSv1", "path": "library/ssl#ssl.TLSVersion.TLSv1", "type": "Networking & Interprocess Communication", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.TLSVersion.TLSv1_1", "path": "library/ssl#ssl.TLSVersion.TLSv1_1", "type": "Networking & Interprocess Communication", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.TLSVersion.TLSv1_2", "path": "library/ssl#ssl.TLSVersion.TLSv1_2", "type": "Networking & Interprocess Communication", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.TLSVersion.TLSv1_3", "path": "library/ssl#ssl.TLSVersion.TLSv1_3", "type": "Networking & Interprocess Communication", "text": "\nSSL 3.0 to TLS 1.3.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.VerifyFlags", "path": "library/ssl#ssl.VerifyFlags", "type": "Networking & Interprocess Communication", "text": "\n`enum.IntFlag` collection of VERIFY_* constants.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.VerifyMode", "path": "library/ssl#ssl.VerifyMode", "type": "Networking & Interprocess Communication", "text": "\n`enum.IntEnum` collection of CERT_* constants.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.VERIFY_CRL_CHECK_CHAIN", "path": "library/ssl#ssl.VERIFY_CRL_CHECK_CHAIN", "type": "Networking & Interprocess Communication", "text": "\nPossible value for `SSLContext.verify_flags`. In this mode, CRLs of all\ncertificates in the peer cert chain are checked.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.VERIFY_CRL_CHECK_LEAF", "path": "library/ssl#ssl.VERIFY_CRL_CHECK_LEAF", "type": "Networking & Interprocess Communication", "text": "\nPossible value for `SSLContext.verify_flags`. In this mode, only the peer cert\nis checked but none of the intermediate CA certificates. The mode requires a\nvalid CRL that is signed by the peer cert\u2019s issuer (its direct ancestor CA).\nIf no proper CRL has been loaded with `SSLContext.load_verify_locations`,\nvalidation will fail.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.VERIFY_DEFAULT", "path": "library/ssl#ssl.VERIFY_DEFAULT", "type": "Networking & Interprocess Communication", "text": "\nPossible value for `SSLContext.verify_flags`. In this mode, certificate\nrevocation lists (CRLs) are not checked. By default OpenSSL does neither\nrequire nor verify CRLs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.VERIFY_X509_STRICT", "path": "library/ssl#ssl.VERIFY_X509_STRICT", "type": "Networking & Interprocess Communication", "text": "\nPossible value for `SSLContext.verify_flags` to disable workarounds for broken\nX.509 certificates.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.VERIFY_X509_TRUSTED_FIRST", "path": "library/ssl#ssl.VERIFY_X509_TRUSTED_FIRST", "type": "Networking & Interprocess Communication", "text": "\nPossible value for `SSLContext.verify_flags`. It instructs OpenSSL to prefer\ntrusted certificates when building the trust chain to validate a certificate.\nThis flag is enabled by default.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ssl.wrap_socket()", "path": "library/ssl#ssl.wrap_socket", "type": "Networking & Interprocess Communication", "text": "\nTakes an instance `sock` of `socket.socket`, and returns an instance of\n`ssl.SSLSocket`, a subtype of `socket.socket`, which wraps the underlying\nsocket in an SSL context. `sock` must be a `SOCK_STREAM` socket; other socket\ntypes are unsupported.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat", "path": "library/stat", "type": "File & Directory Access", "text": "\nSource code: Lib/stat.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.filemode()", "path": "library/stat#stat.filemode", "type": "File & Directory Access", "text": "\nConvert a file\u2019s mode to a string of the form \u2018-rwxrwxrwx\u2019.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.FILE_ATTRIBUTE_ARCHIVE", "path": "library/stat#stat.FILE_ATTRIBUTE_ARCHIVE", "type": "File & Directory Access", "text": "\nNew in version 3.5.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.FILE_ATTRIBUTE_COMPRESSED", "path": "library/stat#stat.FILE_ATTRIBUTE_COMPRESSED", "type": "File & Directory Access", "text": "\nNew in version 3.5.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.FILE_ATTRIBUTE_DEVICE", "path": "library/stat#stat.FILE_ATTRIBUTE_DEVICE", "type": "File & Directory Access", "text": "\nNew in version 3.5.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.FILE_ATTRIBUTE_DIRECTORY", "path": "library/stat#stat.FILE_ATTRIBUTE_DIRECTORY", "type": "File & Directory Access", "text": "\nNew in version 3.5.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.FILE_ATTRIBUTE_ENCRYPTED", "path": "library/stat#stat.FILE_ATTRIBUTE_ENCRYPTED", "type": "File & Directory Access", "text": "\nNew in version 3.5.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.FILE_ATTRIBUTE_HIDDEN", "path": "library/stat#stat.FILE_ATTRIBUTE_HIDDEN", "type": "File & Directory Access", "text": "\nNew in version 3.5.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.FILE_ATTRIBUTE_INTEGRITY_STREAM", "path": "library/stat#stat.FILE_ATTRIBUTE_INTEGRITY_STREAM", "type": "File & Directory Access", "text": "\nNew in version 3.5.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.FILE_ATTRIBUTE_NORMAL", "path": "library/stat#stat.FILE_ATTRIBUTE_NORMAL", "type": "File & Directory Access", "text": "\nNew in version 3.5.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.FILE_ATTRIBUTE_NOT_CONTENT_INDEXED", "path": "library/stat#stat.FILE_ATTRIBUTE_NOT_CONTENT_INDEXED", "type": "File & Directory Access", "text": "\nNew in version 3.5.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.FILE_ATTRIBUTE_NO_SCRUB_DATA", "path": "library/stat#stat.FILE_ATTRIBUTE_NO_SCRUB_DATA", "type": "File & Directory Access", "text": "\nNew in version 3.5.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.FILE_ATTRIBUTE_OFFLINE", "path": "library/stat#stat.FILE_ATTRIBUTE_OFFLINE", "type": "File & Directory Access", "text": "\nNew in version 3.5.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.FILE_ATTRIBUTE_READONLY", "path": "library/stat#stat.FILE_ATTRIBUTE_READONLY", "type": "File & Directory Access", "text": "\nNew in version 3.5.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.FILE_ATTRIBUTE_REPARSE_POINT", "path": "library/stat#stat.FILE_ATTRIBUTE_REPARSE_POINT", "type": "File & Directory Access", "text": "\nNew in version 3.5.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.FILE_ATTRIBUTE_SPARSE_FILE", "path": "library/stat#stat.FILE_ATTRIBUTE_SPARSE_FILE", "type": "File & Directory Access", "text": "\nNew in version 3.5.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.FILE_ATTRIBUTE_SYSTEM", "path": "library/stat#stat.FILE_ATTRIBUTE_SYSTEM", "type": "File & Directory Access", "text": "\nNew in version 3.5.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.FILE_ATTRIBUTE_TEMPORARY", "path": "library/stat#stat.FILE_ATTRIBUTE_TEMPORARY", "type": "File & Directory Access", "text": "\nNew in version 3.5.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.FILE_ATTRIBUTE_VIRTUAL", "path": "library/stat#stat.FILE_ATTRIBUTE_VIRTUAL", "type": "File & Directory Access", "text": "\nNew in version 3.5.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.IO_REPARSE_TAG_APPEXECLINK", "path": "library/stat#stat.IO_REPARSE_TAG_APPEXECLINK", "type": "File & Directory Access", "text": "\nNew in version 3.8.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.IO_REPARSE_TAG_MOUNT_POINT", "path": "library/stat#stat.IO_REPARSE_TAG_MOUNT_POINT", "type": "File & Directory Access", "text": "\nNew in version 3.8.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.IO_REPARSE_TAG_SYMLINK", "path": "library/stat#stat.IO_REPARSE_TAG_SYMLINK", "type": "File & Directory Access", "text": "\nNew in version 3.8.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.SF_APPEND", "path": "library/stat#stat.SF_APPEND", "type": "File & Directory Access", "text": "\nThe file may only be appended to.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.SF_ARCHIVED", "path": "library/stat#stat.SF_ARCHIVED", "type": "File & Directory Access", "text": "\nThe file may be archived.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.SF_IMMUTABLE", "path": "library/stat#stat.SF_IMMUTABLE", "type": "File & Directory Access", "text": "\nThe file may not be changed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.SF_NOUNLINK", "path": "library/stat#stat.SF_NOUNLINK", "type": "File & Directory Access", "text": "\nThe file may not be renamed or deleted.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.SF_SNAPSHOT", "path": "library/stat#stat.SF_SNAPSHOT", "type": "File & Directory Access", "text": "\nThe file is a snapshot file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.ST_ATIME", "path": "library/stat#stat.ST_ATIME", "type": "File & Directory Access", "text": "\nTime of last access.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.ST_CTIME", "path": "library/stat#stat.ST_CTIME", "type": "File & Directory Access", "text": "\nThe \u201cctime\u201d as reported by the operating system. On some systems (like Unix)\nis the time of the last metadata change, and, on others (like Windows), is the\ncreation time (see platform documentation for details).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.ST_DEV", "path": "library/stat#stat.ST_DEV", "type": "File & Directory Access", "text": "\nDevice inode resides on.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.ST_GID", "path": "library/stat#stat.ST_GID", "type": "File & Directory Access", "text": "\nGroup id of the owner.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.ST_INO", "path": "library/stat#stat.ST_INO", "type": "File & Directory Access", "text": "\nInode number.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.ST_MODE", "path": "library/stat#stat.ST_MODE", "type": "File & Directory Access", "text": "\nInode protection mode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.ST_MTIME", "path": "library/stat#stat.ST_MTIME", "type": "File & Directory Access", "text": "\nTime of last modification.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.ST_NLINK", "path": "library/stat#stat.ST_NLINK", "type": "File & Directory Access", "text": "\nNumber of links to the inode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.ST_SIZE", "path": "library/stat#stat.ST_SIZE", "type": "File & Directory Access", "text": "\nSize in bytes of a plain file; amount of data waiting on some special files.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.ST_UID", "path": "library/stat#stat.ST_UID", "type": "File & Directory Access", "text": "\nUser id of the owner.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.S_ENFMT", "path": "library/stat#stat.S_ENFMT", "type": "File & Directory Access", "text": "\nSystem V file locking enforcement. This flag is shared with `S_ISGID`:\nfile/record locking is enforced on files that do not have the group execution\nbit (`S_IXGRP`) set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.S_IEXEC", "path": "library/stat#stat.S_IEXEC", "type": "File & Directory Access", "text": "\nUnix V7 synonym for `S_IXUSR`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.S_IFBLK", "path": "library/stat#stat.S_IFBLK", "type": "File & Directory Access", "text": "\nBlock device.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.S_IFCHR", "path": "library/stat#stat.S_IFCHR", "type": "File & Directory Access", "text": "\nCharacter device.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.S_IFDIR", "path": "library/stat#stat.S_IFDIR", "type": "File & Directory Access", "text": "\nDirectory.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.S_IFDOOR", "path": "library/stat#stat.S_IFDOOR", "type": "File & Directory Access", "text": "\nDoor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.S_IFIFO", "path": "library/stat#stat.S_IFIFO", "type": "File & Directory Access", "text": "\nFIFO.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.S_IFLNK", "path": "library/stat#stat.S_IFLNK", "type": "File & Directory Access", "text": "\nSymbolic link.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.S_IFMT()", "path": "library/stat#stat.S_IFMT", "type": "File & Directory Access", "text": "\nReturn the portion of the file\u2019s mode that describes the file type (used by\nthe `S_IS*()` functions above).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.S_IFPORT", "path": "library/stat#stat.S_IFPORT", "type": "File & Directory Access", "text": "\nEvent port.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.S_IFREG", "path": "library/stat#stat.S_IFREG", "type": "File & Directory Access", "text": "\nRegular file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.S_IFSOCK", "path": "library/stat#stat.S_IFSOCK", "type": "File & Directory Access", "text": "\nSocket.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.S_IFWHT", "path": "library/stat#stat.S_IFWHT", "type": "File & Directory Access", "text": "\nWhiteout.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.S_IMODE()", "path": "library/stat#stat.S_IMODE", "type": "File & Directory Access", "text": "\nReturn the portion of the file\u2019s mode that can be set by `os.chmod()`\u2014that is,\nthe file\u2019s permission bits, plus the sticky bit, set-group-id, and set-user-id\nbits (on systems that support them).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.S_IREAD", "path": "library/stat#stat.S_IREAD", "type": "File & Directory Access", "text": "\nUnix V7 synonym for `S_IRUSR`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.S_IRGRP", "path": "library/stat#stat.S_IRGRP", "type": "File & Directory Access", "text": "\nGroup has read permission.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.S_IROTH", "path": "library/stat#stat.S_IROTH", "type": "File & Directory Access", "text": "\nOthers have read permission.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.S_IRUSR", "path": "library/stat#stat.S_IRUSR", "type": "File & Directory Access", "text": "\nOwner has read permission.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.S_IRWXG", "path": "library/stat#stat.S_IRWXG", "type": "File & Directory Access", "text": "\nMask for group permissions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.S_IRWXO", "path": "library/stat#stat.S_IRWXO", "type": "File & Directory Access", "text": "\nMask for permissions for others (not in group).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.S_IRWXU", "path": "library/stat#stat.S_IRWXU", "type": "File & Directory Access", "text": "\nMask for file owner permissions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.S_ISBLK()", "path": "library/stat#stat.S_ISBLK", "type": "File & Directory Access", "text": "\nReturn non-zero if the mode is from a block special device file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.S_ISCHR()", "path": "library/stat#stat.S_ISCHR", "type": "File & Directory Access", "text": "\nReturn non-zero if the mode is from a character special device file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.S_ISDIR()", "path": "library/stat#stat.S_ISDIR", "type": "File & Directory Access", "text": "\nReturn non-zero if the mode is from a directory.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.S_ISDOOR()", "path": "library/stat#stat.S_ISDOOR", "type": "File & Directory Access", "text": "\nReturn non-zero if the mode is from a door.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.S_ISFIFO()", "path": "library/stat#stat.S_ISFIFO", "type": "File & Directory Access", "text": "\nReturn non-zero if the mode is from a FIFO (named pipe).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.S_ISGID", "path": "library/stat#stat.S_ISGID", "type": "File & Directory Access", "text": "\nSet-group-ID bit. This bit has several special uses. For a directory it\nindicates that BSD semantics is to be used for that directory: files created\nthere inherit their group ID from the directory, not from the effective group\nID of the creating process, and directories created there will also get the\n`S_ISGID` bit set. For a file that does not have the group execution bit\n(`S_IXGRP`) set, the set-group-ID bit indicates mandatory file/record locking\n(see also `S_ENFMT`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.S_ISLNK()", "path": "library/stat#stat.S_ISLNK", "type": "File & Directory Access", "text": "\nReturn non-zero if the mode is from a symbolic link.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.S_ISPORT()", "path": "library/stat#stat.S_ISPORT", "type": "File & Directory Access", "text": "\nReturn non-zero if the mode is from an event port.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.S_ISREG()", "path": "library/stat#stat.S_ISREG", "type": "File & Directory Access", "text": "\nReturn non-zero if the mode is from a regular file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.S_ISSOCK()", "path": "library/stat#stat.S_ISSOCK", "type": "File & Directory Access", "text": "\nReturn non-zero if the mode is from a socket.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.S_ISUID", "path": "library/stat#stat.S_ISUID", "type": "File & Directory Access", "text": "\nSet UID bit.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.S_ISVTX", "path": "library/stat#stat.S_ISVTX", "type": "File & Directory Access", "text": "\nSticky bit. When this bit is set on a directory it means that a file in that\ndirectory can be renamed or deleted only by the owner of the file, by the\nowner of the directory, or by a privileged process.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.S_ISWHT()", "path": "library/stat#stat.S_ISWHT", "type": "File & Directory Access", "text": "\nReturn non-zero if the mode is from a whiteout.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.S_IWGRP", "path": "library/stat#stat.S_IWGRP", "type": "File & Directory Access", "text": "\nGroup has write permission.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.S_IWOTH", "path": "library/stat#stat.S_IWOTH", "type": "File & Directory Access", "text": "\nOthers have write permission.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.S_IWRITE", "path": "library/stat#stat.S_IWRITE", "type": "File & Directory Access", "text": "\nUnix V7 synonym for `S_IWUSR`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.S_IWUSR", "path": "library/stat#stat.S_IWUSR", "type": "File & Directory Access", "text": "\nOwner has write permission.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.S_IXGRP", "path": "library/stat#stat.S_IXGRP", "type": "File & Directory Access", "text": "\nGroup has execute permission.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.S_IXOTH", "path": "library/stat#stat.S_IXOTH", "type": "File & Directory Access", "text": "\nOthers have execute permission.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.S_IXUSR", "path": "library/stat#stat.S_IXUSR", "type": "File & Directory Access", "text": "\nOwner has execute permission.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.UF_APPEND", "path": "library/stat#stat.UF_APPEND", "type": "File & Directory Access", "text": "\nThe file may only be appended to.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.UF_COMPRESSED", "path": "library/stat#stat.UF_COMPRESSED", "type": "File & Directory Access", "text": "\nThe file is stored compressed (Mac OS X 10.6+).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.UF_HIDDEN", "path": "library/stat#stat.UF_HIDDEN", "type": "File & Directory Access", "text": "\nThe file should not be displayed in a GUI (Mac OS X 10.5+).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.UF_IMMUTABLE", "path": "library/stat#stat.UF_IMMUTABLE", "type": "File & Directory Access", "text": "\nThe file may not be changed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.UF_NODUMP", "path": "library/stat#stat.UF_NODUMP", "type": "File & Directory Access", "text": "\nDo not dump the file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.UF_NOUNLINK", "path": "library/stat#stat.UF_NOUNLINK", "type": "File & Directory Access", "text": "\nThe file may not be renamed or deleted.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stat.UF_OPAQUE", "path": "library/stat#stat.UF_OPAQUE", "type": "File & Directory Access", "text": "\nThe directory is opaque when viewed through a union stack.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "staticmethod()", "path": "library/functions#staticmethod", "type": "Built-in Functions", "text": "\nTransform a method into a static method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "statistics", "path": "library/statistics", "type": "Numeric & Mathematical", "text": "\nNew in version 3.4.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "statistics.fmean()", "path": "library/statistics#statistics.fmean", "type": "Numeric & Mathematical", "text": "\nConvert data to floats and compute the arithmetic mean.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "statistics.geometric_mean()", "path": "library/statistics#statistics.geometric_mean", "type": "Numeric & Mathematical", "text": "\nConvert data to floats and compute the geometric mean.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "statistics.harmonic_mean()", "path": "library/statistics#statistics.harmonic_mean", "type": "Numeric & Mathematical", "text": "\nReturn the harmonic mean of data, a sequence or iterable of real-valued\nnumbers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "statistics.mean()", "path": "library/statistics#statistics.mean", "type": "Numeric & Mathematical", "text": "\nReturn the sample arithmetic mean of data which can be a sequence or iterable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "statistics.median()", "path": "library/statistics#statistics.median", "type": "Numeric & Mathematical", "text": "\nReturn the median (middle value) of numeric data, using the common \u201cmean of\nmiddle two\u201d method. If data is empty, `StatisticsError` is raised. data can be\na sequence or iterable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "statistics.median_grouped()", "path": "library/statistics#statistics.median_grouped", "type": "Numeric & Mathematical", "text": "\nReturn the median of grouped continuous data, calculated as the 50th\npercentile, using interpolation. If data is empty, `StatisticsError` is\nraised. data can be a sequence or iterable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "statistics.median_high()", "path": "library/statistics#statistics.median_high", "type": "Numeric & Mathematical", "text": "\nReturn the high median of data. If data is empty, `StatisticsError` is raised.\ndata can be a sequence or iterable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "statistics.median_low()", "path": "library/statistics#statistics.median_low", "type": "Numeric & Mathematical", "text": "\nReturn the low median of numeric data. If data is empty, `StatisticsError` is\nraised. data can be a sequence or iterable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "statistics.mode()", "path": "library/statistics#statistics.mode", "type": "Numeric & Mathematical", "text": "\nReturn the single most common data point from discrete or nominal data. The\nmode (when it exists) is the most typical value and serves as a measure of\ncentral location.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "statistics.multimode()", "path": "library/statistics#statistics.multimode", "type": "Numeric & Mathematical", "text": "\nReturn a list of the most frequently occurring values in the order they were\nfirst encountered in the data. Will return more than one result if there are\nmultiple modes or an empty list if the data is empty:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "statistics.NormalDist", "path": "library/statistics#statistics.NormalDist", "type": "Numeric & Mathematical", "text": "\nReturns a new NormalDist object where mu represents the arithmetic mean and\nsigma represents the standard deviation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "statistics.NormalDist.cdf()", "path": "library/statistics#statistics.NormalDist.cdf", "type": "Numeric & Mathematical", "text": "\nUsing a cumulative distribution function (cdf), compute the probability that a\nrandom variable X will be less than or equal to x. Mathematically, it is\nwritten `P(X <= x)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "statistics.NormalDist.from_samples()", "path": "library/statistics#statistics.NormalDist.from_samples", "type": "Numeric & Mathematical", "text": "\nMakes a normal distribution instance with mu and sigma parameters estimated\nfrom the data using `fmean()` and `stdev()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "statistics.NormalDist.inv_cdf()", "path": "library/statistics#statistics.NormalDist.inv_cdf", "type": "Numeric & Mathematical", "text": "\nCompute the inverse cumulative distribution function, also known as the\nquantile function or the percent-point function. Mathematically, it is written\n`x : P(X <= x) = p`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "statistics.NormalDist.mean", "path": "library/statistics#statistics.NormalDist.mean", "type": "Numeric & Mathematical", "text": "\nA read-only property for the arithmetic mean of a normal distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "statistics.NormalDist.median", "path": "library/statistics#statistics.NormalDist.median", "type": "Numeric & Mathematical", "text": "\nA read-only property for the median of a normal distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "statistics.NormalDist.mode", "path": "library/statistics#statistics.NormalDist.mode", "type": "Numeric & Mathematical", "text": "\nA read-only property for the mode of a normal distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "statistics.NormalDist.overlap()", "path": "library/statistics#statistics.NormalDist.overlap", "type": "Numeric & Mathematical", "text": "\nMeasures the agreement between two normal probability distributions. Returns a\nvalue between 0.0 and 1.0 giving the overlapping area for the two probability\ndensity functions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "statistics.NormalDist.pdf()", "path": "library/statistics#statistics.NormalDist.pdf", "type": "Numeric & Mathematical", "text": "\nUsing a probability density function (pdf), compute the relative likelihood\nthat a random variable X will be near the given value x. Mathematically, it is\nthe limit of the ratio `P(x <= X < x+dx) / dx` as dx approaches zero.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "statistics.NormalDist.quantiles()", "path": "library/statistics#statistics.NormalDist.quantiles", "type": "Numeric & Mathematical", "text": "\nDivide the normal distribution into n continuous intervals with equal\nprobability. Returns a list of (n - 1) cut points separating the intervals.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "statistics.NormalDist.samples()", "path": "library/statistics#statistics.NormalDist.samples", "type": "Numeric & Mathematical", "text": "\nGenerates n random samples for a given mean and standard deviation. Returns a\n`list` of `float` values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "statistics.NormalDist.stdev", "path": "library/statistics#statistics.NormalDist.stdev", "type": "Numeric & Mathematical", "text": "\nA read-only property for the standard deviation of a normal distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "statistics.NormalDist.variance", "path": "library/statistics#statistics.NormalDist.variance", "type": "Numeric & Mathematical", "text": "\nA read-only property for the variance of a normal distribution. Equal to the\nsquare of the standard deviation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "statistics.NormalDist.zscore()", "path": "library/statistics#statistics.NormalDist.zscore", "type": "Numeric & Mathematical", "text": "\nCompute the Standard Score describing x in terms of the number of standard\ndeviations above or below the mean of the normal distribution: `(x - mean) /\nstdev`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "statistics.pstdev()", "path": "library/statistics#statistics.pstdev", "type": "Numeric & Mathematical", "text": "\nReturn the population standard deviation (the square root of the population\nvariance). See `pvariance()` for arguments and other details.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "statistics.pvariance()", "path": "library/statistics#statistics.pvariance", "type": "Numeric & Mathematical", "text": "\nReturn the population variance of data, a non-empty sequence or iterable of\nreal-valued numbers. Variance, or second moment about the mean, is a measure\nof the variability (spread or dispersion) of data. A large variance indicates\nthat the data is spread out; a small variance indicates it is clustered\nclosely around the mean.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "statistics.quantiles()", "path": "library/statistics#statistics.quantiles", "type": "Numeric & Mathematical", "text": "\nDivide data into n continuous intervals with equal probability. Returns a list\nof `n - 1` cut points separating the intervals.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "statistics.StatisticsError", "path": "library/statistics#statistics.StatisticsError", "type": "Numeric & Mathematical", "text": "\nSubclass of `ValueError` for statistics-related exceptions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "statistics.stdev()", "path": "library/statistics#statistics.stdev", "type": "Numeric & Mathematical", "text": "\nReturn the sample standard deviation (the square root of the sample variance).\nSee `variance()` for arguments and other details.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "statistics.variance()", "path": "library/statistics#statistics.variance", "type": "Numeric & Mathematical", "text": "\nReturn the sample variance of data, an iterable of at least two real-valued\nnumbers. Variance, or second moment about the mean, is a measure of the\nvariability (spread or dispersion) of data. A large variance indicates that\nthe data is spread out; a small variance indicates it is clustered closely\naround the mean.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "StopAsyncIteration", "path": "library/exceptions#StopAsyncIteration", "type": "Built-in Exceptions", "text": "\nMust be raised by `__anext__()` method of an asynchronous iterator object to\nstop the iteration.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "StopIteration", "path": "library/exceptions#StopIteration", "type": "Built-in Exceptions", "text": "\nRaised by built-in function `next()` and an iterator\u2019s `__next__()` method to\nsignal that there are no further items produced by the iterator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str", "path": "library/functions#str", "type": "Built-in Functions", "text": "\nReturn a `str` version of object. See `str()` for details.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str", "path": "library/stdtypes#str", "type": "Built-in Types", "text": "\nReturn a string version of object. If object is not provided, returns the\nempty string. Otherwise, the behavior of `str()` depends on whether encoding\nor errors is given, as follows.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.capitalize()", "path": "library/stdtypes#str.capitalize", "type": "Built-in Types", "text": "\nReturn a copy of the string with its first character capitalized and the rest\nlowercased.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.casefold()", "path": "library/stdtypes#str.casefold", "type": "Built-in Types", "text": "\nReturn a casefolded copy of the string. Casefolded strings may be used for\ncaseless matching.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.center()", "path": "library/stdtypes#str.center", "type": "Built-in Types", "text": "\nReturn centered in a string of length width. Padding is done using the\nspecified fillchar (default is an ASCII space). The original string is\nreturned if width is less than or equal to `len(s)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.count()", "path": "library/stdtypes#str.count", "type": "Built-in Types", "text": "\nReturn the number of non-overlapping occurrences of substring sub in the range\n[start, end]. Optional arguments start and end are interpreted as in slice\nnotation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.encode()", "path": "library/stdtypes#str.encode", "type": "Built-in Types", "text": "\nReturn an encoded version of the string as a bytes object. Default encoding is\n`'utf-8'`. errors may be given to set a different error handling scheme. The\ndefault for errors is `'strict'`, meaning that encoding errors raise a\n`UnicodeError`. Other possible values are `'ignore'`, `'replace'`,\n`'xmlcharrefreplace'`, `'backslashreplace'` and any other name registered via\n`codecs.register_error()`, see section Error Handlers. For a list of possible\nencodings, see section Standard Encodings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.endswith()", "path": "library/stdtypes#str.endswith", "type": "Built-in Types", "text": "\nReturn `True` if the string ends with the specified suffix, otherwise return\n`False`. suffix can also be a tuple of suffixes to look for. With optional\nstart, test beginning at that position. With optional end, stop comparing at\nthat position.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.expandtabs()", "path": "library/stdtypes#str.expandtabs", "type": "Built-in Types", "text": "\nReturn a copy of the string where all tab characters are replaced by one or\nmore spaces, depending on the current column and the given tab size. Tab\npositions occur every tabsize characters (default is 8, giving tab positions\nat columns 0, 8, 16 and so on). To expand the string, the current column is\nset to zero and the string is examined character by character. If the\ncharacter is a tab (`\\t`), one or more space characters are inserted in the\nresult until the current column is equal to the next tab position. (The tab\ncharacter itself is not copied.) If the character is a newline (`\\n`) or\nreturn (`\\r`), it is copied and the current column is reset to zero. Any other\ncharacter is copied unchanged and the current column is incremented by one\nregardless of how the character is represented when printed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.find()", "path": "library/stdtypes#str.find", "type": "Built-in Types", "text": "\nReturn the lowest index in the string where substring sub is found within the\nslice `s[start:end]`. Optional arguments start and end are interpreted as in\nslice notation. Return `-1` if sub is not found.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.format()", "path": "library/stdtypes#str.format", "type": "Built-in Types", "text": "\nPerform a string formatting operation. The string on which this method is\ncalled can contain literal text or replacement fields delimited by braces\n`{}`. Each replacement field contains either the numeric index of a positional\nargument, or the name of a keyword argument. Returns a copy of the string\nwhere each replacement field is replaced with the string value of the\ncorresponding argument.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.format_map()", "path": "library/stdtypes#str.format_map", "type": "Built-in Types", "text": "\nSimilar to `str.format(**mapping)`, except that `mapping` is used directly and\nnot copied to a `dict`. This is useful if for example `mapping` is a dict\nsubclass:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.index()", "path": "library/stdtypes#str.index", "type": "Built-in Types", "text": "\nLike `find()`, but raise `ValueError` when the substring is not found.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.isalnum()", "path": "library/stdtypes#str.isalnum", "type": "Built-in Types", "text": "\nReturn `True` if all characters in the string are alphanumeric and there is at\nleast one character, `False` otherwise. A character `c` is alphanumeric if one\nof the following returns `True`: `c.isalpha()`, `c.isdecimal()`,\n`c.isdigit()`, or `c.isnumeric()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.isalpha()", "path": "library/stdtypes#str.isalpha", "type": "Built-in Types", "text": "\nReturn `True` if all characters in the string are alphabetic and there is at\nleast one character, `False` otherwise. Alphabetic characters are those\ncharacters defined in the Unicode character database as \u201cLetter\u201d, i.e., those\nwith general category property being one of \u201cLm\u201d, \u201cLt\u201d, \u201cLu\u201d, \u201cLl\u201d, or \u201cLo\u201d.\nNote that this is different from the \u201cAlphabetic\u201d property defined in the\nUnicode Standard.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.isascii()", "path": "library/stdtypes#str.isascii", "type": "Built-in Types", "text": "\nReturn `True` if the string is empty or all characters in the string are\nASCII, `False` otherwise. ASCII characters have code points in the range\nU+0000-U+007F.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.isdecimal()", "path": "library/stdtypes#str.isdecimal", "type": "Built-in Types", "text": "\nReturn `True` if all characters in the string are decimal characters and there\nis at least one character, `False` otherwise. Decimal characters are those\nthat can be used to form numbers in base 10, e.g. U+0660, ARABIC-INDIC DIGIT\nZERO. Formally a decimal character is a character in the Unicode General\nCategory \u201cNd\u201d.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.isdigit()", "path": "library/stdtypes#str.isdigit", "type": "Built-in Types", "text": "\nReturn `True` if all characters in the string are digits and there is at least\none character, `False` otherwise. Digits include decimal characters and digits\nthat need special handling, such as the compatibility superscript digits. This\ncovers digits which cannot be used to form numbers in base 10, like the\nKharosthi numbers. Formally, a digit is a character that has the property\nvalue Numeric_Type=Digit or Numeric_Type=Decimal.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.isidentifier()", "path": "library/stdtypes#str.isidentifier", "type": "Built-in Types", "text": "\nReturn `True` if the string is a valid identifier according to the language\ndefinition, section Identifiers and keywords.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.islower()", "path": "library/stdtypes#str.islower", "type": "Built-in Types", "text": "\nReturn `True` if all cased characters 4 in the string are lowercase and there\nis at least one cased character, `False` otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.isnumeric()", "path": "library/stdtypes#str.isnumeric", "type": "Built-in Types", "text": "\nReturn `True` if all characters in the string are numeric characters, and\nthere is at least one character, `False` otherwise. Numeric characters include\ndigit characters, and all characters that have the Unicode numeric value\nproperty, e.g. U+2155, VULGAR FRACTION ONE FIFTH. Formally, numeric characters\nare those with the property value Numeric_Type=Digit, Numeric_Type=Decimal or\nNumeric_Type=Numeric.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.isprintable()", "path": "library/stdtypes#str.isprintable", "type": "Built-in Types", "text": "\nReturn `True` if all characters in the string are printable or the string is\nempty, `False` otherwise. Nonprintable characters are those characters defined\nin the Unicode character database as \u201cOther\u201d or \u201cSeparator\u201d, excepting the\nASCII space (0x20) which is considered printable. (Note that printable\ncharacters in this context are those which should not be escaped when `repr()`\nis invoked on a string. It has no bearing on the handling of strings written\nto `sys.stdout` or `sys.stderr`.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.isspace()", "path": "library/stdtypes#str.isspace", "type": "Built-in Types", "text": "\nReturn `True` if there are only whitespace characters in the string and there\nis at least one character, `False` otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.istitle()", "path": "library/stdtypes#str.istitle", "type": "Built-in Types", "text": "\nReturn `True` if the string is a titlecased string and there is at least one\ncharacter, for example uppercase characters may only follow uncased characters\nand lowercase characters only cased ones. Return `False` otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.isupper()", "path": "library/stdtypes#str.isupper", "type": "Built-in Types", "text": "\nReturn `True` if all cased characters 4 in the string are uppercase and there\nis at least one cased character, `False` otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.join()", "path": "library/stdtypes#str.join", "type": "Built-in Types", "text": "\nReturn a string which is the concatenation of the strings in iterable. A\n`TypeError` will be raised if there are any non-string values in iterable,\nincluding `bytes` objects. The separator between elements is the string\nproviding this method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.ljust()", "path": "library/stdtypes#str.ljust", "type": "Built-in Types", "text": "\nReturn the string left justified in a string of length width. Padding is done\nusing the specified fillchar (default is an ASCII space). The original string\nis returned if width is less than or equal to `len(s)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.lower()", "path": "library/stdtypes#str.lower", "type": "Built-in Types", "text": "\nReturn a copy of the string with all the cased characters 4 converted to\nlowercase.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.lstrip()", "path": "library/stdtypes#str.lstrip", "type": "Built-in Types", "text": "\nReturn a copy of the string with leading characters removed. The chars\nargument is a string specifying the set of characters to be removed. If\nomitted or `None`, the chars argument defaults to removing whitespace. The\nchars argument is not a prefix; rather, all combinations of its values are\nstripped:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.maketrans()", "path": "library/stdtypes#str.maketrans", "type": "Built-in Types", "text": "\nThis static method returns a translation table usable for `str.translate()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.partition()", "path": "library/stdtypes#str.partition", "type": "Built-in Types", "text": "\nSplit the string at the first occurrence of sep, and return a 3-tuple\ncontaining the part before the separator, the separator itself, and the part\nafter the separator. If the separator is not found, return a 3-tuple\ncontaining the string itself, followed by two empty strings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.removeprefix()", "path": "library/stdtypes#str.removeprefix", "type": "Built-in Types", "text": "\nIf the string starts with the prefix string, return `string[len(prefix):]`.\nOtherwise, return a copy of the original string:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.removesuffix()", "path": "library/stdtypes#str.removesuffix", "type": "Built-in Types", "text": "\nIf the string ends with the suffix string and that suffix is not empty, return\n`string[:-len(suffix)]`. Otherwise, return a copy of the original string:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.replace()", "path": "library/stdtypes#str.replace", "type": "Built-in Types", "text": "\nReturn a copy of the string with all occurrences of substring old replaced by\nnew. If the optional argument count is given, only the first count occurrences\nare replaced.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.rfind()", "path": "library/stdtypes#str.rfind", "type": "Built-in Types", "text": "\nReturn the highest index in the string where substring sub is found, such that\nsub is contained within `s[start:end]`. Optional arguments start and end are\ninterpreted as in slice notation. Return `-1` on failure.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.rindex()", "path": "library/stdtypes#str.rindex", "type": "Built-in Types", "text": "\nLike `rfind()` but raises `ValueError` when the substring sub is not found.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.rjust()", "path": "library/stdtypes#str.rjust", "type": "Built-in Types", "text": "\nReturn the string right justified in a string of length width. Padding is done\nusing the specified fillchar (default is an ASCII space). The original string\nis returned if width is less than or equal to `len(s)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.rpartition()", "path": "library/stdtypes#str.rpartition", "type": "Built-in Types", "text": "\nSplit the string at the last occurrence of sep, and return a 3-tuple\ncontaining the part before the separator, the separator itself, and the part\nafter the separator. If the separator is not found, return a 3-tuple\ncontaining two empty strings, followed by the string itself.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.rsplit()", "path": "library/stdtypes#str.rsplit", "type": "Built-in Types", "text": "\nReturn a list of the words in the string, using sep as the delimiter string.\nIf maxsplit is given, at most maxsplit splits are done, the rightmost ones. If\nsep is not specified or `None`, any whitespace string is a separator. Except\nfor splitting from the right, `rsplit()` behaves like `split()` which is\ndescribed in detail below.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.rstrip()", "path": "library/stdtypes#str.rstrip", "type": "Built-in Types", "text": "\nReturn a copy of the string with trailing characters removed. The chars\nargument is a string specifying the set of characters to be removed. If\nomitted or `None`, the chars argument defaults to removing whitespace. The\nchars argument is not a suffix; rather, all combinations of its values are\nstripped:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.split()", "path": "library/stdtypes#str.split", "type": "Built-in Types", "text": "\nReturn a list of the words in the string, using sep as the delimiter string.\nIf maxsplit is given, at most maxsplit splits are done (thus, the list will\nhave at most `maxsplit+1` elements). If maxsplit is not specified or `-1`,\nthen there is no limit on the number of splits (all possible splits are made).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.splitlines()", "path": "library/stdtypes#str.splitlines", "type": "Built-in Types", "text": "\nReturn a list of the lines in the string, breaking at line boundaries. Line\nbreaks are not included in the resulting list unless keepends is given and\ntrue.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.startswith()", "path": "library/stdtypes#str.startswith", "type": "Built-in Types", "text": "\nReturn `True` if string starts with the prefix, otherwise return `False`.\nprefix can also be a tuple of prefixes to look for. With optional start, test\nstring beginning at that position. With optional end, stop comparing string at\nthat position.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.strip()", "path": "library/stdtypes#str.strip", "type": "Built-in Types", "text": "\nReturn a copy of the string with the leading and trailing characters removed.\nThe chars argument is a string specifying the set of characters to be removed.\nIf omitted or `None`, the chars argument defaults to removing whitespace. The\nchars argument is not a prefix or suffix; rather, all combinations of its\nvalues are stripped:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.swapcase()", "path": "library/stdtypes#str.swapcase", "type": "Built-in Types", "text": "\nReturn a copy of the string with uppercase characters converted to lowercase\nand vice versa. Note that it is not necessarily true that\n`s.swapcase().swapcase() == s`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.title()", "path": "library/stdtypes#str.title", "type": "Built-in Types", "text": "\nReturn a titlecased version of the string where words start with an uppercase\ncharacter and the remaining characters are lowercase.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.translate()", "path": "library/stdtypes#str.translate", "type": "Built-in Types", "text": "\nReturn a copy of the string in which each character has been mapped through\nthe given translation table. The table must be an object that implements\nindexing via `__getitem__()`, typically a mapping or sequence. When indexed by\na Unicode ordinal (an integer), the table object can do any of the following:\nreturn a Unicode ordinal or a string, to map the character to one or more\nother characters; return `None`, to delete the character from the return\nstring; or raise a `LookupError` exception, to map the character to itself.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.upper()", "path": "library/stdtypes#str.upper", "type": "Built-in Types", "text": "\nReturn a copy of the string with all the cased characters 4 converted to\nuppercase. Note that `s.upper().isupper()` might be `False` if `s` contains\nuncased characters or if the Unicode category of the resulting character(s) is\nnot \u201cLu\u201d (Letter, uppercase), but e.g. \u201cLt\u201d (Letter, titlecase).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "str.zfill()", "path": "library/stdtypes#str.zfill", "type": "Built-in Types", "text": "\nReturn a copy of the string left filled with ASCII `'0'` digits to make a\nstring of length width. A leading sign prefix (`'+'`/`'-'`) is handled by\ninserting the padding after the sign character rather than before. The\noriginal string is returned if width is less than or equal to `len(s)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Streams", "path": "library/asyncio-stream", "type": "Asynchronous I/O", "text": "\nSource code: Lib/asyncio/streams.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "string", "path": "library/string", "type": "Text Processing", "text": "\nSource code: Lib/string.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "string.ascii_letters", "path": "library/string#string.ascii_letters", "type": "Text Processing", "text": "\nThe concatenation of the `ascii_lowercase` and `ascii_uppercase` constants\ndescribed below. This value is not locale-dependent.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "string.ascii_lowercase", "path": "library/string#string.ascii_lowercase", "type": "Text Processing", "text": "\nThe lowercase letters `'abcdefghijklmnopqrstuvwxyz'`. This value is not\nlocale-dependent and will not change.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "string.ascii_uppercase", "path": "library/string#string.ascii_uppercase", "type": "Text Processing", "text": "\nThe uppercase letters `'ABCDEFGHIJKLMNOPQRSTUVWXYZ'`. This value is not\nlocale-dependent and will not change.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "string.capwords()", "path": "library/string#string.capwords", "type": "Text Processing", "text": "\nSplit the argument into words using `str.split()`, capitalize each word using\n`str.capitalize()`, and join the capitalized words using `str.join()`. If the\noptional second argument sep is absent or `None`, runs of whitespace\ncharacters are replaced by a single space and leading and trailing whitespace\nare removed, otherwise sep is used to split and join the words.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "string.digits", "path": "library/string#string.digits", "type": "Text Processing", "text": "\nThe string `'0123456789'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "string.Formatter", "path": "library/string#string.Formatter", "type": "Text Processing", "text": "\nThe `Formatter` class has the following public methods:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "string.Formatter.check_unused_args()", "path": "library/string#string.Formatter.check_unused_args", "type": "Text Processing", "text": "\nImplement checking for unused arguments if desired. The arguments to this\nfunction is the set of all argument keys that were actually referred to in the\nformat string (integers for positional arguments, and strings for named\narguments), and a reference to the args and kwargs that was passed to vformat.\nThe set of unused args can be calculated from these parameters.\n`check_unused_args()` is assumed to raise an exception if the check fails.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "string.Formatter.convert_field()", "path": "library/string#string.Formatter.convert_field", "type": "Text Processing", "text": "\nConverts the value (returned by `get_field()`) given a conversion type (as in\nthe tuple returned by the `parse()` method). The default version understands\n\u2018s\u2019 (str), \u2018r\u2019 (repr) and \u2018a\u2019 (ascii) conversion types.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "string.Formatter.format()", "path": "library/string#string.Formatter.format", "type": "Text Processing", "text": "\nThe primary API method. It takes a format string and an arbitrary set of\npositional and keyword arguments. It is just a wrapper that calls `vformat()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "string.Formatter.format_field()", "path": "library/string#string.Formatter.format_field", "type": "Text Processing", "text": "\n`format_field()` simply calls the global `format()` built-in. The method is\nprovided so that subclasses can override it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "string.Formatter.get_field()", "path": "library/string#string.Formatter.get_field", "type": "Text Processing", "text": "\nGiven field_name as returned by `parse()` (see above), convert it to an object\nto be formatted. Returns a tuple (obj, used_key). The default version takes\nstrings of the form defined in PEP 3101, such as \u201c0[name]\u201d or \u201clabel.title\u201d.\nargs and kwargs are as passed in to `vformat()`. The return value used_key has\nthe same meaning as the key parameter to `get_value()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "string.Formatter.get_value()", "path": "library/string#string.Formatter.get_value", "type": "Text Processing", "text": "\nRetrieve a given field value. The key argument will be either an integer or a\nstring. If it is an integer, it represents the index of the positional\nargument in args; if it is a string, then it represents a named argument in\nkwargs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "string.Formatter.parse()", "path": "library/string#string.Formatter.parse", "type": "Text Processing", "text": "\nLoop over the format_string and return an iterable of tuples (literal_text,\nfield_name, format_spec, conversion). This is used by `vformat()` to break the\nstring into either literal text, or replacement fields.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "string.Formatter.vformat()", "path": "library/string#string.Formatter.vformat", "type": "Text Processing", "text": "\nThis function does the actual work of formatting. It is exposed as a separate\nfunction for cases where you want to pass in a predefined dictionary of\narguments, rather than unpacking and repacking the dictionary as individual\narguments using the `*args` and `**kwargs` syntax. `vformat()` does the work\nof breaking up the format string into character data and replacement fields.\nIt calls the various methods described below.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "string.hexdigits", "path": "library/string#string.hexdigits", "type": "Text Processing", "text": "\nThe string `'0123456789abcdefABCDEF'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "string.octdigits", "path": "library/string#string.octdigits", "type": "Text Processing", "text": "\nThe string `'01234567'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "string.printable", "path": "library/string#string.printable", "type": "Text Processing", "text": "\nString of ASCII characters which are considered printable. This is a\ncombination of `digits`, `ascii_letters`, `punctuation`, and `whitespace`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "string.punctuation", "path": "library/string#string.punctuation", "type": "Text Processing", "text": "\nString of ASCII characters which are considered punctuation characters in the\n`C` locale: `!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "string.Template", "path": "library/string#string.Template", "type": "Text Processing", "text": "\nThe constructor takes a single argument which is the template string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "string.Template.safe_substitute()", "path": "library/string#string.Template.safe_substitute", "type": "Text Processing", "text": "\nLike `substitute()`, except that if placeholders are missing from mapping and\nkwds, instead of raising a `KeyError` exception, the original placeholder will\nappear in the resulting string intact. Also, unlike with `substitute()`, any\nother appearances of the `$` will simply return `$` instead of raising\n`ValueError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "string.Template.substitute()", "path": "library/string#string.Template.substitute", "type": "Text Processing", "text": "\nPerforms the template substitution, returning a new string. mapping is any\ndictionary-like object with keys that match the placeholders in the template.\nAlternatively, you can provide keyword arguments, where the keywords are the\nplaceholders. When both mapping and kwds are given and there are duplicates,\nthe placeholders from kwds take precedence.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "string.Template.template", "path": "library/string#string.Template.template", "type": "Text Processing", "text": "\nThis is the object passed to the constructor\u2019s template argument. In general,\nyou shouldn\u2019t change it, but read-only access is not enforced.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "string.whitespace", "path": "library/string#string.whitespace", "type": "Text Processing", "text": "\nA string containing all ASCII characters that are considered whitespace. This\nincludes the characters space, tab, linefeed, return, formfeed, and vertical\ntab.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stringprep", "path": "library/stringprep", "type": "Text Processing", "text": "\nSource code: Lib/stringprep.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stringprep.in_table_a1()", "path": "library/stringprep#stringprep.in_table_a1", "type": "Text Processing", "text": "\nDetermine whether code is in tableA.1 (Unassigned code points in Unicode 3.2).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stringprep.in_table_b1()", "path": "library/stringprep#stringprep.in_table_b1", "type": "Text Processing", "text": "\nDetermine whether code is in tableB.1 (Commonly mapped to nothing).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stringprep.in_table_c11()", "path": "library/stringprep#stringprep.in_table_c11", "type": "Text Processing", "text": "\nDetermine whether code is in tableC.1.1 (ASCII space characters).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stringprep.in_table_c11_c12()", "path": "library/stringprep#stringprep.in_table_c11_c12", "type": "Text Processing", "text": "\nDetermine whether code is in tableC.1 (Space characters, union of C.1.1 and\nC.1.2).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stringprep.in_table_c12()", "path": "library/stringprep#stringprep.in_table_c12", "type": "Text Processing", "text": "\nDetermine whether code is in tableC.1.2 (Non-ASCII space characters).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stringprep.in_table_c21()", "path": "library/stringprep#stringprep.in_table_c21", "type": "Text Processing", "text": "\nDetermine whether code is in tableC.2.1 (ASCII control characters).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stringprep.in_table_c21_c22()", "path": "library/stringprep#stringprep.in_table_c21_c22", "type": "Text Processing", "text": "\nDetermine whether code is in tableC.2 (Control characters, union of C.2.1 and\nC.2.2).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stringprep.in_table_c22()", "path": "library/stringprep#stringprep.in_table_c22", "type": "Text Processing", "text": "\nDetermine whether code is in tableC.2.2 (Non-ASCII control characters).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stringprep.in_table_c3()", "path": "library/stringprep#stringprep.in_table_c3", "type": "Text Processing", "text": "\nDetermine whether code is in tableC.3 (Private use).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stringprep.in_table_c4()", "path": "library/stringprep#stringprep.in_table_c4", "type": "Text Processing", "text": "\nDetermine whether code is in tableC.4 (Non-character code points).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stringprep.in_table_c5()", "path": "library/stringprep#stringprep.in_table_c5", "type": "Text Processing", "text": "\nDetermine whether code is in tableC.5 (Surrogate codes).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stringprep.in_table_c6()", "path": "library/stringprep#stringprep.in_table_c6", "type": "Text Processing", "text": "\nDetermine whether code is in tableC.6 (Inappropriate for plain text).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stringprep.in_table_c7()", "path": "library/stringprep#stringprep.in_table_c7", "type": "Text Processing", "text": "\nDetermine whether code is in tableC.7 (Inappropriate for canonical\nrepresentation).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stringprep.in_table_c8()", "path": "library/stringprep#stringprep.in_table_c8", "type": "Text Processing", "text": "\nDetermine whether code is in tableC.8 (Change display properties or are\ndeprecated).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stringprep.in_table_c9()", "path": "library/stringprep#stringprep.in_table_c9", "type": "Text Processing", "text": "\nDetermine whether code is in tableC.9 (Tagging characters).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stringprep.in_table_d1()", "path": "library/stringprep#stringprep.in_table_d1", "type": "Text Processing", "text": "\nDetermine whether code is in tableD.1 (Characters with bidirectional property\n\u201cR\u201d or \u201cAL\u201d).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stringprep.in_table_d2()", "path": "library/stringprep#stringprep.in_table_d2", "type": "Text Processing", "text": "\nDetermine whether code is in tableD.2 (Characters with bidirectional property\n\u201cL\u201d).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stringprep.map_table_b2()", "path": "library/stringprep#stringprep.map_table_b2", "type": "Text Processing", "text": "\nReturn the mapped value for code according to tableB.2 (Mapping for case-\nfolding used with NFKC).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "stringprep.map_table_b3()", "path": "library/stringprep#stringprep.map_table_b3", "type": "Text Processing", "text": "\nReturn the mapped value for code according to tableB.3 (Mapping for case-\nfolding used with no normalization).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "struct", "path": "library/struct", "type": "Binary Data", "text": "\nSource code: Lib/struct.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "struct.calcsize()", "path": "library/struct#struct.calcsize", "type": "Binary Data", "text": "\nReturn the size of the struct (and hence of the bytes object produced by\n`pack(format, ...)`) corresponding to the format string format.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "struct.error", "path": "library/struct#struct.error", "type": "Binary Data", "text": "\nException raised on various occasions; argument is a string describing what is\nwrong.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "struct.iter_unpack()", "path": "library/struct#struct.iter_unpack", "type": "Binary Data", "text": "\nIteratively unpack from the buffer buffer according to the format string\nformat. This function returns an iterator which will read equally-sized chunks\nfrom the buffer until all its contents have been consumed. The buffer\u2019s size\nin bytes must be a multiple of the size required by the format, as reflected\nby `calcsize()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "struct.pack()", "path": "library/struct#struct.pack", "type": "Binary Data", "text": "\nReturn a bytes object containing the values v1, v2, \u2026 packed according to the\nformat string format. The arguments must match the values required by the\nformat exactly.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "struct.pack_into()", "path": "library/struct#struct.pack_into", "type": "Binary Data", "text": "\nPack the values v1, v2, \u2026 according to the format string format and write the\npacked bytes into the writable buffer buffer starting at position offset. Note\nthat offset is a required argument.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "struct.Struct", "path": "library/struct#struct.Struct", "type": "Binary Data", "text": "\nReturn a new Struct object which writes and reads binary data according to the\nformat string format. Creating a Struct object once and calling its methods is\nmore efficient than calling the `struct` functions with the same format since\nthe format string only needs to be compiled once.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "struct.Struct.format", "path": "library/struct#struct.Struct.format", "type": "Binary Data", "text": "\nThe format string used to construct this Struct object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "struct.Struct.iter_unpack()", "path": "library/struct#struct.Struct.iter_unpack", "type": "Binary Data", "text": "\nIdentical to the `iter_unpack()` function, using the compiled format. The\nbuffer\u2019s size in bytes must be a multiple of `size`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "struct.Struct.pack()", "path": "library/struct#struct.Struct.pack", "type": "Binary Data", "text": "\nIdentical to the `pack()` function, using the compiled format. (`len(result)`\nwill equal `size`.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "struct.Struct.pack_into()", "path": "library/struct#struct.Struct.pack_into", "type": "Binary Data", "text": "\nIdentical to the `pack_into()` function, using the compiled format.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "struct.Struct.size", "path": "library/struct#struct.Struct.size", "type": "Binary Data", "text": "\nThe calculated size of the struct (and hence of the bytes object produced by\nthe `pack()` method) corresponding to `format`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "struct.Struct.unpack()", "path": "library/struct#struct.Struct.unpack", "type": "Binary Data", "text": "\nIdentical to the `unpack()` function, using the compiled format. The buffer\u2019s\nsize in bytes must equal `size`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "struct.Struct.unpack_from()", "path": "library/struct#struct.Struct.unpack_from", "type": "Binary Data", "text": "\nIdentical to the `unpack_from()` function, using the compiled format. The\nbuffer\u2019s size in bytes, starting at position offset, must be at least `size`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "struct.unpack()", "path": "library/struct#struct.unpack", "type": "Binary Data", "text": "\nUnpack from the buffer buffer (presumably packed by `pack(format, ...)`)\naccording to the format string format. The result is a tuple even if it\ncontains exactly one item. The buffer\u2019s size in bytes must match the size\nrequired by the format, as reflected by `calcsize()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "struct.unpack_from()", "path": "library/struct#struct.unpack_from", "type": "Binary Data", "text": "\nUnpack from buffer starting at position offset, according to the format string\nformat. The result is a tuple even if it contains exactly one item. The\nbuffer\u2019s size in bytes, starting at position offset, must be at least the size\nrequired by the format, as reflected by `calcsize()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess", "path": "library/subprocess", "type": "Concurrent Execution", "text": "\nSource code: Lib/subprocess.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.ABOVE_NORMAL_PRIORITY_CLASS", "path": "library/subprocess#subprocess.ABOVE_NORMAL_PRIORITY_CLASS", "type": "Concurrent Execution", "text": "\nA `Popen` `creationflags` parameter to specify that a new process will have an\nabove average priority.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.BELOW_NORMAL_PRIORITY_CLASS", "path": "library/subprocess#subprocess.BELOW_NORMAL_PRIORITY_CLASS", "type": "Concurrent Execution", "text": "\nA `Popen` `creationflags` parameter to specify that a new process will have a\nbelow average priority.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.call()", "path": "library/subprocess#subprocess.call", "type": "Concurrent Execution", "text": "\nRun the command described by args. Wait for command to complete, then return\nthe `returncode` attribute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.CalledProcessError", "path": "library/subprocess#subprocess.CalledProcessError", "type": "Concurrent Execution", "text": "\nSubclass of `SubprocessError`, raised when a process run by `check_call()` or\n`check_output()` returns a non-zero exit status.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.CalledProcessError.cmd", "path": "library/subprocess#subprocess.CalledProcessError.cmd", "type": "Concurrent Execution", "text": "\nCommand that was used to spawn the child process.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.CalledProcessError.output", "path": "library/subprocess#subprocess.CalledProcessError.output", "type": "Concurrent Execution", "text": "\nOutput of the child process if it was captured by `run()` or `check_output()`.\nOtherwise, `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.CalledProcessError.returncode", "path": "library/subprocess#subprocess.CalledProcessError.returncode", "type": "Concurrent Execution", "text": "\nExit status of the child process. If the process exited due to a signal, this\nwill be the negative signal number.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.CalledProcessError.stderr", "path": "library/subprocess#subprocess.CalledProcessError.stderr", "type": "Concurrent Execution", "text": "\nStderr output of the child process if it was captured by `run()`. Otherwise,\n`None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.CalledProcessError.stdout", "path": "library/subprocess#subprocess.CalledProcessError.stdout", "type": "Concurrent Execution", "text": "\nAlias for output, for symmetry with `stderr`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.check_call()", "path": "library/subprocess#subprocess.check_call", "type": "Concurrent Execution", "text": "\nRun command with arguments. Wait for command to complete. If the return code\nwas zero then return, otherwise raise `CalledProcessError`. The\n`CalledProcessError` object will have the return code in the `returncode`\nattribute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.check_output()", "path": "library/subprocess#subprocess.check_output", "type": "Concurrent Execution", "text": "\nRun command with arguments and return its output.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.CompletedProcess", "path": "library/subprocess#subprocess.CompletedProcess", "type": "Concurrent Execution", "text": "\nThe return value from `run()`, representing a process that has finished.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.CompletedProcess.args", "path": "library/subprocess#subprocess.CompletedProcess.args", "type": "Concurrent Execution", "text": "\nThe arguments used to launch the process. This may be a list or a string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.CompletedProcess.check_returncode()", "path": "library/subprocess#subprocess.CompletedProcess.check_returncode", "type": "Concurrent Execution", "text": "\nIf `returncode` is non-zero, raise a `CalledProcessError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.CompletedProcess.returncode", "path": "library/subprocess#subprocess.CompletedProcess.returncode", "type": "Concurrent Execution", "text": "\nExit status of the child process. Typically, an exit status of 0 indicates\nthat it ran successfully.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.CompletedProcess.stderr", "path": "library/subprocess#subprocess.CompletedProcess.stderr", "type": "Concurrent Execution", "text": "\nCaptured stderr from the child process. A bytes sequence, or a string if\n`run()` was called with an encoding, errors, or text=True. `None` if stderr\nwas not captured.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.CompletedProcess.stdout", "path": "library/subprocess#subprocess.CompletedProcess.stdout", "type": "Concurrent Execution", "text": "\nCaptured stdout from the child process. A bytes sequence, or a string if\n`run()` was called with an encoding, errors, or text=True. `None` if stdout\nwas not captured.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.CREATE_BREAKAWAY_FROM_JOB", "path": "library/subprocess#subprocess.CREATE_BREAKAWAY_FROM_JOB", "type": "Concurrent Execution", "text": "\nA `Popen` `creationflags` parameter to specify that a new process is not\nassociated with the job.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.CREATE_DEFAULT_ERROR_MODE", "path": "library/subprocess#subprocess.CREATE_DEFAULT_ERROR_MODE", "type": "Concurrent Execution", "text": "\nA `Popen` `creationflags` parameter to specify that a new process does not\ninherit the error mode of the calling process. Instead, the new process gets\nthe default error mode. This feature is particularly useful for multithreaded\nshell applications that run with hard errors disabled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.CREATE_NEW_CONSOLE", "path": "library/subprocess#subprocess.CREATE_NEW_CONSOLE", "type": "Concurrent Execution", "text": "\nThe new process has a new console, instead of inheriting its parent\u2019s console\n(the default).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.CREATE_NEW_PROCESS_GROUP", "path": "library/subprocess#subprocess.CREATE_NEW_PROCESS_GROUP", "type": "Concurrent Execution", "text": "\nA `Popen` `creationflags` parameter to specify that a new process group will\nbe created. This flag is necessary for using `os.kill()` on the subprocess.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.CREATE_NO_WINDOW", "path": "library/subprocess#subprocess.CREATE_NO_WINDOW", "type": "Concurrent Execution", "text": "\nA `Popen` `creationflags` parameter to specify that a new process will not\ncreate a window.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.DETACHED_PROCESS", "path": "library/subprocess#subprocess.DETACHED_PROCESS", "type": "Concurrent Execution", "text": "\nA `Popen` `creationflags` parameter to specify that a new process will not\ninherit its parent\u2019s console. This value cannot be used with\nCREATE_NEW_CONSOLE.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.DEVNULL", "path": "library/subprocess#subprocess.DEVNULL", "type": "Concurrent Execution", "text": "\nSpecial value that can be used as the stdin, stdout or stderr argument to\n`Popen` and indicates that the special file `os.devnull` will be used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.getoutput()", "path": "library/subprocess#subprocess.getoutput", "type": "Concurrent Execution", "text": "\nReturn output (stdout and stderr) of executing cmd in a shell.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.getstatusoutput()", "path": "library/subprocess#subprocess.getstatusoutput", "type": "Concurrent Execution", "text": "\nReturn `(exitcode, output)` of executing cmd in a shell.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.HIGH_PRIORITY_CLASS", "path": "library/subprocess#subprocess.HIGH_PRIORITY_CLASS", "type": "Concurrent Execution", "text": "\nA `Popen` `creationflags` parameter to specify that a new process will have a\nhigh priority.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.IDLE_PRIORITY_CLASS", "path": "library/subprocess#subprocess.IDLE_PRIORITY_CLASS", "type": "Concurrent Execution", "text": "\nA `Popen` `creationflags` parameter to specify that a new process will have an\nidle (lowest) priority.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.NORMAL_PRIORITY_CLASS", "path": "library/subprocess#subprocess.NORMAL_PRIORITY_CLASS", "type": "Concurrent Execution", "text": "\nA `Popen` `creationflags` parameter to specify that a new process will have an\nnormal priority. (default)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.PIPE", "path": "library/subprocess#subprocess.PIPE", "type": "Concurrent Execution", "text": "\nSpecial value that can be used as the stdin, stdout or stderr argument to\n`Popen` and indicates that a pipe to the standard stream should be opened.\nMost useful with `Popen.communicate()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.Popen", "path": "library/subprocess#subprocess.Popen", "type": "Concurrent Execution", "text": "\nExecute a child program in a new process. On POSIX, the class uses\n`os.execvp()`-like behavior to execute the child program. On Windows, the\nclass uses the Windows `CreateProcess()` function. The arguments to `Popen`\nare as follows.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.Popen.args", "path": "library/subprocess#subprocess.Popen.args", "type": "Concurrent Execution", "text": "\nThe args argument as it was passed to `Popen` \u2013 a sequence of program\narguments or else a single string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.Popen.communicate()", "path": "library/subprocess#subprocess.Popen.communicate", "type": "Concurrent Execution", "text": "\nInteract with process: Send data to stdin. Read data from stdout and stderr,\nuntil end-of-file is reached. Wait for process to terminate and set the\n`returncode` attribute. The optional input argument should be data to be sent\nto the child process, or `None`, if no data should be sent to the child. If\nstreams were opened in text mode, input must be a string. Otherwise, it must\nbe bytes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.Popen.kill()", "path": "library/subprocess#subprocess.Popen.kill", "type": "Concurrent Execution", "text": "\nKills the child. On POSIX OSs the function sends SIGKILL to the child. On\nWindows `kill()` is an alias for `terminate()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.Popen.pid", "path": "library/subprocess#subprocess.Popen.pid", "type": "Concurrent Execution", "text": "\nThe process ID of the child process.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.Popen.poll()", "path": "library/subprocess#subprocess.Popen.poll", "type": "Concurrent Execution", "text": "\nCheck if child process has terminated. Set and return `returncode` attribute.\nOtherwise, returns `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.Popen.returncode", "path": "library/subprocess#subprocess.Popen.returncode", "type": "Concurrent Execution", "text": "\nThe child return code, set by `poll()` and `wait()` (and indirectly by\n`communicate()`). A `None` value indicates that the process hasn\u2019t terminated\nyet.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.Popen.send_signal()", "path": "library/subprocess#subprocess.Popen.send_signal", "type": "Concurrent Execution", "text": "\nSends the signal signal to the child.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.Popen.stderr", "path": "library/subprocess#subprocess.Popen.stderr", "type": "Concurrent Execution", "text": "\nIf the stderr argument was `PIPE`, this attribute is a readable stream object\nas returned by `open()`. Reading from the stream provides error output from\nthe child process. If the encoding or errors arguments were specified or the\nuniversal_newlines argument was `True`, the stream is a text stream, otherwise\nit is a byte stream. If the stderr argument was not `PIPE`, this attribute is\n`None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.Popen.stdin", "path": "library/subprocess#subprocess.Popen.stdin", "type": "Concurrent Execution", "text": "\nIf the stdin argument was `PIPE`, this attribute is a writeable stream object\nas returned by `open()`. If the encoding or errors arguments were specified or\nthe universal_newlines argument was `True`, the stream is a text stream,\notherwise it is a byte stream. If the stdin argument was not `PIPE`, this\nattribute is `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.Popen.stdout", "path": "library/subprocess#subprocess.Popen.stdout", "type": "Concurrent Execution", "text": "\nIf the stdout argument was `PIPE`, this attribute is a readable stream object\nas returned by `open()`. Reading from the stream provides output from the\nchild process. If the encoding or errors arguments were specified or the\nuniversal_newlines argument was `True`, the stream is a text stream, otherwise\nit is a byte stream. If the stdout argument was not `PIPE`, this attribute is\n`None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.Popen.terminate()", "path": "library/subprocess#subprocess.Popen.terminate", "type": "Concurrent Execution", "text": "\nStop the child. On POSIX OSs the method sends SIGTERM to the child. On Windows\nthe Win32 API function `TerminateProcess()` is called to stop the child.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.Popen.wait()", "path": "library/subprocess#subprocess.Popen.wait", "type": "Concurrent Execution", "text": "\nWait for child process to terminate. Set and return `returncode` attribute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.REALTIME_PRIORITY_CLASS", "path": "library/subprocess#subprocess.REALTIME_PRIORITY_CLASS", "type": "Concurrent Execution", "text": "\nA `Popen` `creationflags` parameter to specify that a new process will have\nrealtime priority. You should almost never use REALTIME_PRIORITY_CLASS,\nbecause this interrupts system threads that manage mouse input, keyboard\ninput, and background disk flushing. This class can be appropriate for\napplications that \u201ctalk\u201d directly to hardware or that perform brief tasks that\nshould have limited interruptions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.run()", "path": "library/subprocess#subprocess.run", "type": "Concurrent Execution", "text": "\nRun the command described by args. Wait for command to complete, then return a\n`CompletedProcess` instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.STARTF_USESHOWWINDOW", "path": "library/subprocess#subprocess.STARTF_USESHOWWINDOW", "type": "Concurrent Execution", "text": "\nSpecifies that the `STARTUPINFO.wShowWindow` attribute contains additional\ninformation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.STARTF_USESTDHANDLES", "path": "library/subprocess#subprocess.STARTF_USESTDHANDLES", "type": "Concurrent Execution", "text": "\nSpecifies that the `STARTUPINFO.hStdInput`, `STARTUPINFO.hStdOutput`, and\n`STARTUPINFO.hStdError` attributes contain additional information.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.STARTUPINFO", "path": "library/subprocess#subprocess.STARTUPINFO", "type": "Concurrent Execution", "text": "\nPartial support of the Windows STARTUPINFO structure is used for `Popen`\ncreation. The following attributes can be set by passing them as keyword-only\narguments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.STARTUPINFO.dwFlags", "path": "library/subprocess#subprocess.STARTUPINFO.dwFlags", "type": "Concurrent Execution", "text": "\nA bit field that determines whether certain `STARTUPINFO` attributes are used\nwhen the process creates a window.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.STARTUPINFO.hStdError", "path": "library/subprocess#subprocess.STARTUPINFO.hStdError", "type": "Concurrent Execution", "text": "\nIf `dwFlags` specifies `STARTF_USESTDHANDLES`, this attribute is the standard\nerror handle for the process. Otherwise, this attribute is ignored and the\ndefault for standard error is the console window\u2019s buffer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.STARTUPINFO.hStdInput", "path": "library/subprocess#subprocess.STARTUPINFO.hStdInput", "type": "Concurrent Execution", "text": "\nIf `dwFlags` specifies `STARTF_USESTDHANDLES`, this attribute is the standard\ninput handle for the process. If `STARTF_USESTDHANDLES` is not specified, the\ndefault for standard input is the keyboard buffer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.STARTUPINFO.hStdOutput", "path": "library/subprocess#subprocess.STARTUPINFO.hStdOutput", "type": "Concurrent Execution", "text": "\nIf `dwFlags` specifies `STARTF_USESTDHANDLES`, this attribute is the standard\noutput handle for the process. Otherwise, this attribute is ignored and the\ndefault for standard output is the console window\u2019s buffer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.STARTUPINFO.lpAttributeList", "path": "library/subprocess#subprocess.STARTUPINFO.lpAttributeList", "type": "Concurrent Execution", "text": "\nA dictionary of additional attributes for process creation as given in\n`STARTUPINFOEX`, see UpdateProcThreadAttribute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.STARTUPINFO.wShowWindow", "path": "library/subprocess#subprocess.STARTUPINFO.wShowWindow", "type": "Concurrent Execution", "text": "\nIf `dwFlags` specifies `STARTF_USESHOWWINDOW`, this attribute can be any of\nthe values that can be specified in the `nCmdShow` parameter for the\nShowWindow function, except for `SW_SHOWDEFAULT`. Otherwise, this attribute is\nignored.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.STDOUT", "path": "library/subprocess#subprocess.STDOUT", "type": "Concurrent Execution", "text": "\nSpecial value that can be used as the stderr argument to `Popen` and indicates\nthat standard error should go into the same handle as standard output.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.STD_ERROR_HANDLE", "path": "library/subprocess#subprocess.STD_ERROR_HANDLE", "type": "Concurrent Execution", "text": "\nThe standard error device. Initially, this is the active console screen\nbuffer, `CONOUT$`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.STD_INPUT_HANDLE", "path": "library/subprocess#subprocess.STD_INPUT_HANDLE", "type": "Concurrent Execution", "text": "\nThe standard input device. Initially, this is the console input buffer,\n`CONIN$`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.STD_OUTPUT_HANDLE", "path": "library/subprocess#subprocess.STD_OUTPUT_HANDLE", "type": "Concurrent Execution", "text": "\nThe standard output device. Initially, this is the active console screen\nbuffer, `CONOUT$`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.SubprocessError", "path": "library/subprocess#subprocess.SubprocessError", "type": "Concurrent Execution", "text": "\nBase class for all other exceptions from this module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.SW_HIDE", "path": "library/subprocess#subprocess.SW_HIDE", "type": "Concurrent Execution", "text": "\nHides the window. Another window will be activated.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.TimeoutExpired", "path": "library/subprocess#subprocess.TimeoutExpired", "type": "Concurrent Execution", "text": "\nSubclass of `SubprocessError`, raised when a timeout expires while waiting for\na child process.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.TimeoutExpired.cmd", "path": "library/subprocess#subprocess.TimeoutExpired.cmd", "type": "Concurrent Execution", "text": "\nCommand that was used to spawn the child process.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.TimeoutExpired.output", "path": "library/subprocess#subprocess.TimeoutExpired.output", "type": "Concurrent Execution", "text": "\nOutput of the child process if it was captured by `run()` or `check_output()`.\nOtherwise, `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.TimeoutExpired.stderr", "path": "library/subprocess#subprocess.TimeoutExpired.stderr", "type": "Concurrent Execution", "text": "\nStderr output of the child process if it was captured by `run()`. Otherwise,\n`None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.TimeoutExpired.stdout", "path": "library/subprocess#subprocess.TimeoutExpired.stdout", "type": "Concurrent Execution", "text": "\nAlias for output, for symmetry with `stderr`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "subprocess.TimeoutExpired.timeout", "path": "library/subprocess#subprocess.TimeoutExpired.timeout", "type": "Concurrent Execution", "text": "\nTimeout in seconds.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Subprocesses", "path": "library/asyncio-subprocess", "type": "Asynchronous I/O", "text": "\nSource code: Lib/asyncio/subprocess.py, Lib/asyncio/base_subprocess.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sum()", "path": "library/functions#sum", "type": "Built-in Functions", "text": "\nSums start and the items of an iterable from left to right and returns the\ntotal. The iterable\u2019s items are normally numbers, and the start value is not\nallowed to be a string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "super()", "path": "library/functions#super", "type": "Built-in Functions", "text": "\nReturn a proxy object that delegates method calls to a parent or sibling class\nof type. This is useful for accessing inherited methods that have been\noverridden in a class.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "symbol", "path": "library/symbol", "type": "Language", "text": "\nSource code: Lib/symbol.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "symbol.sym_name", "path": "library/symbol#symbol.sym_name", "type": "Language", "text": "\nDictionary mapping the numeric values of the constants defined in this module\nback to name strings, allowing more human-readable representation of parse\ntrees to be generated.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "symtable", "path": "library/symtable", "type": "Language", "text": "\nSource code: Lib/symtable.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "symtable.Class", "path": "library/symtable#symtable.Class", "type": "Language", "text": "\nA namespace of a class. This class inherits `SymbolTable`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "symtable.Class.get_methods()", "path": "library/symtable#symtable.Class.get_methods", "type": "Language", "text": "\nReturn a tuple containing the names of methods declared in the class.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "symtable.Function", "path": "library/symtable#symtable.Function", "type": "Language", "text": "\nA namespace for a function or method. This class inherits `SymbolTable`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "symtable.Function.get_frees()", "path": "library/symtable#symtable.Function.get_frees", "type": "Language", "text": "\nReturn a tuple containing names of free variables in this function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "symtable.Function.get_globals()", "path": "library/symtable#symtable.Function.get_globals", "type": "Language", "text": "\nReturn a tuple containing names of globals in this function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "symtable.Function.get_locals()", "path": "library/symtable#symtable.Function.get_locals", "type": "Language", "text": "\nReturn a tuple containing names of locals in this function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "symtable.Function.get_nonlocals()", "path": "library/symtable#symtable.Function.get_nonlocals", "type": "Language", "text": "\nReturn a tuple containing names of nonlocals in this function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "symtable.Function.get_parameters()", "path": "library/symtable#symtable.Function.get_parameters", "type": "Language", "text": "\nReturn a tuple containing names of parameters to this function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "symtable.Symbol", "path": "library/symtable#symtable.Symbol", "type": "Language", "text": "\nAn entry in a `SymbolTable` corresponding to an identifier in the source. The\nconstructor is not public.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "symtable.Symbol.get_name()", "path": "library/symtable#symtable.Symbol.get_name", "type": "Language", "text": "\nReturn the symbol\u2019s name.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "symtable.Symbol.get_namespace()", "path": "library/symtable#symtable.Symbol.get_namespace", "type": "Language", "text": "\nReturn the namespace bound to this name. If more than one namespace is bound,\n`ValueError` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "symtable.Symbol.get_namespaces()", "path": "library/symtable#symtable.Symbol.get_namespaces", "type": "Language", "text": "\nReturn a list of namespaces bound to this name.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "symtable.Symbol.is_annotated()", "path": "library/symtable#symtable.Symbol.is_annotated", "type": "Language", "text": "\nReturn `True` if the symbol is annotated.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "symtable.Symbol.is_assigned()", "path": "library/symtable#symtable.Symbol.is_assigned", "type": "Language", "text": "\nReturn `True` if the symbol is assigned to in its block.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "symtable.Symbol.is_declared_global()", "path": "library/symtable#symtable.Symbol.is_declared_global", "type": "Language", "text": "\nReturn `True` if the symbol is declared global with a global statement.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "symtable.Symbol.is_free()", "path": "library/symtable#symtable.Symbol.is_free", "type": "Language", "text": "\nReturn `True` if the symbol is referenced in its block, but not assigned to.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "symtable.Symbol.is_global()", "path": "library/symtable#symtable.Symbol.is_global", "type": "Language", "text": "\nReturn `True` if the symbol is global.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "symtable.Symbol.is_imported()", "path": "library/symtable#symtable.Symbol.is_imported", "type": "Language", "text": "\nReturn `True` if the symbol is created from an import statement.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "symtable.Symbol.is_local()", "path": "library/symtable#symtable.Symbol.is_local", "type": "Language", "text": "\nReturn `True` if the symbol is local to its block.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "symtable.Symbol.is_namespace()", "path": "library/symtable#symtable.Symbol.is_namespace", "type": "Language", "text": "\nReturn `True` if name binding introduces new namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "symtable.Symbol.is_nonlocal()", "path": "library/symtable#symtable.Symbol.is_nonlocal", "type": "Language", "text": "\nReturn `True` if the symbol is nonlocal.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "symtable.Symbol.is_parameter()", "path": "library/symtable#symtable.Symbol.is_parameter", "type": "Language", "text": "\nReturn `True` if the symbol is a parameter.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "symtable.Symbol.is_referenced()", "path": "library/symtable#symtable.Symbol.is_referenced", "type": "Language", "text": "\nReturn `True` if the symbol is used in its block.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "symtable.SymbolTable", "path": "library/symtable#symtable.SymbolTable", "type": "Language", "text": "\nA namespace table for a block. The constructor is not public.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "symtable.SymbolTable.get_children()", "path": "library/symtable#symtable.SymbolTable.get_children", "type": "Language", "text": "\nReturn a list of the nested symbol tables.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "symtable.SymbolTable.get_id()", "path": "library/symtable#symtable.SymbolTable.get_id", "type": "Language", "text": "\nReturn the table\u2019s identifier.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "symtable.SymbolTable.get_identifiers()", "path": "library/symtable#symtable.SymbolTable.get_identifiers", "type": "Language", "text": "\nReturn a list of names of symbols in this table.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "symtable.SymbolTable.get_lineno()", "path": "library/symtable#symtable.SymbolTable.get_lineno", "type": "Language", "text": "\nReturn the number of the first line in the block this table represents.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "symtable.SymbolTable.get_name()", "path": "library/symtable#symtable.SymbolTable.get_name", "type": "Language", "text": "\nReturn the table\u2019s name. This is the name of the class if the table is for a\nclass, the name of the function if the table is for a function, or `'top'` if\nthe table is global (`get_type()` returns `'module'`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "symtable.SymbolTable.get_symbols()", "path": "library/symtable#symtable.SymbolTable.get_symbols", "type": "Language", "text": "\nReturn a list of `Symbol` instances for names in the table.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "symtable.SymbolTable.get_type()", "path": "library/symtable#symtable.SymbolTable.get_type", "type": "Language", "text": "\nReturn the type of the symbol table. Possible values are `'class'`,\n`'module'`, and `'function'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "symtable.SymbolTable.has_children()", "path": "library/symtable#symtable.SymbolTable.has_children", "type": "Language", "text": "\nReturn `True` if the block has nested namespaces within it. These can be\nobtained with `get_children()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "symtable.SymbolTable.is_nested()", "path": "library/symtable#symtable.SymbolTable.is_nested", "type": "Language", "text": "\nReturn `True` if the block is a nested class or function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "symtable.SymbolTable.is_optimized()", "path": "library/symtable#symtable.SymbolTable.is_optimized", "type": "Language", "text": "\nReturn `True` if the locals in this table can be optimized.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "symtable.SymbolTable.lookup()", "path": "library/symtable#symtable.SymbolTable.lookup", "type": "Language", "text": "\nLookup name in the table and return a `Symbol` instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "symtable.symtable()", "path": "library/symtable#symtable.symtable", "type": "Language", "text": "\nReturn the toplevel `SymbolTable` for the Python source code. filename is the\nname of the file containing the code. compile_type is like the mode argument\nto `compile()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Synchronization Primitives", "path": "library/asyncio-sync", "type": "Asynchronous I/O", "text": "\nSource code: Lib/asyncio/locks.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "SyntaxError", "path": "library/exceptions#SyntaxError", "type": "Built-in Exceptions", "text": "\nRaised when the parser encounters a syntax error. This may occur in an\n`import` statement, in a call to the built-in functions `exec()` or `eval()`,\nor when reading the initial script or standard input (also interactively).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "SyntaxError.filename", "path": "library/exceptions#SyntaxError.filename", "type": "Built-in Exceptions", "text": "\nThe name of the file the syntax error occurred in.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "SyntaxError.lineno", "path": "library/exceptions#SyntaxError.lineno", "type": "Built-in Exceptions", "text": "\nWhich line number in the file the error occurred in. This is 1-indexed: the\nfirst line in the file has a `lineno` of 1.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "SyntaxError.offset", "path": "library/exceptions#SyntaxError.offset", "type": "Built-in Exceptions", "text": "\nThe column in the line where the error occurred. This is 1-indexed: the first\ncharacter in the line has an `offset` of 1.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "SyntaxError.text", "path": "library/exceptions#SyntaxError.text", "type": "Built-in Exceptions", "text": "\nThe source code text involved in the error.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "SyntaxWarning", "path": "library/exceptions#SyntaxWarning", "type": "Built-in Exceptions", "text": "\nBase class for warnings about dubious syntax.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys", "path": "library/sys", "type": "Runtime", "text": "\nThis module provides access to some variables used or maintained by the\ninterpreter and to functions that interact strongly with the interpreter. It\nis always available.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.abiflags", "path": "library/sys#sys.abiflags", "type": "Runtime", "text": "\nOn POSIX systems where Python was built with the standard `configure` script,\nthis contains the ABI flags as specified by PEP 3149.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.addaudithook()", "path": "library/sys#sys.addaudithook", "type": "Runtime", "text": "\nAppend the callable hook to the list of active auditing hooks for the current\n(sub)interpreter.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.api_version", "path": "library/sys#sys.api_version", "type": "Runtime", "text": "\nThe C API version for this interpreter. Programmers may find this useful when\ndebugging version conflicts between Python and extension modules.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.argv", "path": "library/sys#sys.argv", "type": "Runtime", "text": "\nThe list of command line arguments passed to a Python script. `argv[0]` is the\nscript name (it is operating system dependent whether this is a full pathname\nor not). If the command was executed using the `-c` command line option to the\ninterpreter, `argv[0]` is set to the string `'-c'`. If no script name was\npassed to the Python interpreter, `argv[0]` is the empty string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.audit()", "path": "library/sys#sys.audit", "type": "Runtime", "text": "\nRaise an auditing event and trigger any active auditing hooks. event is a\nstring identifying the event, and args may contain optional arguments with\nmore information about the event. The number and types of arguments for a\ngiven event are considered a public and stable API and should not be modified\nbetween releases.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.base_exec_prefix", "path": "library/sys#sys.base_exec_prefix", "type": "Runtime", "text": "\nSet during Python startup, before `site.py` is run, to the same value as\n`exec_prefix`. If not running in a virtual environment, the values will stay\nthe same; if `site.py` finds that a virtual environment is in use, the values\nof `prefix` and `exec_prefix` will be changed to point to the virtual\nenvironment, whereas `base_prefix` and `base_exec_prefix` will remain pointing\nto the base Python installation (the one which the virtual environment was\ncreated from).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.base_prefix", "path": "library/sys#sys.base_prefix", "type": "Runtime", "text": "\nSet during Python startup, before `site.py` is run, to the same value as\n`prefix`. If not running in a virtual environment, the values will stay the\nsame; if `site.py` finds that a virtual environment is in use, the values of\n`prefix` and `exec_prefix` will be changed to point to the virtual\nenvironment, whereas `base_prefix` and `base_exec_prefix` will remain pointing\nto the base Python installation (the one which the virtual environment was\ncreated from).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.breakpointhook()", "path": "library/sys#sys.breakpointhook", "type": "Runtime", "text": "\nThis hook function is called by built-in `breakpoint()`. By default, it drops\nyou into the `pdb` debugger, but it can be set to any other function so that\nyou can choose which debugger gets used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.builtin_module_names", "path": "library/sys#sys.builtin_module_names", "type": "Runtime", "text": "\nA tuple of strings giving the names of all modules that are compiled into this\nPython interpreter. (This information is not available in any other way \u2014\n`modules.keys()` only lists the imported modules.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.byteorder", "path": "library/sys#sys.byteorder", "type": "Runtime", "text": "\nAn indicator of the native byte order. This will have the value `'big'` on\nbig-endian (most-significant byte first) platforms, and `'little'` on little-\nendian (least-significant byte first) platforms.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.call_tracing()", "path": "library/sys#sys.call_tracing", "type": "Runtime", "text": "\nCall `func(*args)`, while tracing is enabled. The tracing state is saved, and\nrestored afterwards. This is intended to be called from a debugger from a\ncheckpoint, to recursively debug some other code.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.copyright", "path": "library/sys#sys.copyright", "type": "Runtime", "text": "\nA string containing the copyright pertaining to the Python interpreter.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.displayhook()", "path": "library/sys#sys.displayhook", "type": "Runtime", "text": "\nIf value is not `None`, this function prints `repr(value)` to `sys.stdout`,\nand saves value in `builtins._`. If `repr(value)` is not encodable to\n`sys.stdout.encoding` with `sys.stdout.errors` error handler (which is\nprobably `'strict'`), encode it to `sys.stdout.encoding` with\n`'backslashreplace'` error handler.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.dllhandle", "path": "library/sys#sys.dllhandle", "type": "Runtime", "text": "\nInteger specifying the handle of the Python DLL.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.dont_write_bytecode", "path": "library/sys#sys.dont_write_bytecode", "type": "Runtime", "text": "\nIf this is true, Python won\u2019t try to write `.pyc` files on the import of\nsource modules. This value is initially set to `True` or `False` depending on\nthe `-B` command line option and the `PYTHONDONTWRITEBYTECODE` environment\nvariable, but you can set it yourself to control bytecode file generation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.excepthook()", "path": "library/sys#sys.excepthook", "type": "Runtime", "text": "\nThis function prints out a given traceback and exception to `sys.stderr`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.exc_info()", "path": "library/sys#sys.exc_info", "type": "Runtime", "text": "\nThis function returns a tuple of three values that give information about the\nexception that is currently being handled. The information returned is\nspecific both to the current thread and to the current stack frame. If the\ncurrent stack frame is not handling an exception, the information is taken\nfrom the calling stack frame, or its caller, and so on until a stack frame is\nfound that is handling an exception. Here, \u201chandling an exception\u201d is defined\nas \u201cexecuting an except clause.\u201d For any stack frame, only information about\nthe exception being currently handled is accessible.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.executable", "path": "library/sys#sys.executable", "type": "Runtime", "text": "\nA string giving the absolute path of the executable binary for the Python\ninterpreter, on systems where this makes sense. If Python is unable to\nretrieve the real path to its executable, `sys.executable` will be an empty\nstring or `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.exec_prefix", "path": "library/sys#sys.exec_prefix", "type": "Runtime", "text": "\nA string giving the site-specific directory prefix where the platform-\ndependent Python files are installed; by default, this is also `'/usr/local'`.\nThis can be set at build time with the `--exec-prefix` argument to the\nconfigure script. Specifically, all configuration files (e.g. the `pyconfig.h`\nheader file) are installed in the directory\n`exec_prefix/lib/pythonX.Y/config`, and shared library modules are installed\nin `exec_prefix/lib/pythonX.Y/lib-dynload`, where X.Y is the version number of\nPython, for example `3.2`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.exit()", "path": "library/sys#sys.exit", "type": "Runtime", "text": "\nExit from Python. This is implemented by raising the `SystemExit` exception,\nso cleanup actions specified by finally clauses of `try` statements are\nhonored, and it is possible to intercept the exit attempt at an outer level.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.flags", "path": "library/sys#sys.flags", "type": "Runtime", "text": "\nThe named tuple flags exposes the status of command line flags. The attributes\nare read only.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.float_info", "path": "library/sys#sys.float_info", "type": "Runtime", "text": "\nA named tuple holding information about the float type. It contains low level\ninformation about the precision and internal representation. The values\ncorrespond to the various floating-point constants defined in the standard\nheader file `float.h` for the \u2018C\u2019 programming language; see section 5.2.4.2.2\nof the 1999 ISO/IEC C standard [C99], \u2018Characteristics of floating types\u2019, for\ndetails.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.float_repr_style", "path": "library/sys#sys.float_repr_style", "type": "Runtime", "text": "\nA string indicating how the `repr()` function behaves for floats. If the\nstring has value `'short'` then for a finite float `x`, `repr(x)` aims to\nproduce a short string with the property that `float(repr(x)) == x`. This is\nthe usual behaviour in Python 3.1 and later. Otherwise, `float_repr_style` has\nvalue `'legacy'` and `repr(x)` behaves in the same way as it did in versions\nof Python prior to 3.1.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.getallocatedblocks()", "path": "library/sys#sys.getallocatedblocks", "type": "Runtime", "text": "\nReturn the number of memory blocks currently allocated by the interpreter,\nregardless of their size. This function is mainly useful for tracking and\ndebugging memory leaks. Because of the interpreter\u2019s internal caches, the\nresult can vary from call to call; you may have to call `_clear_type_cache()`\nand `gc.collect()` to get more predictable results.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.getandroidapilevel()", "path": "library/sys#sys.getandroidapilevel", "type": "Runtime", "text": "\nReturn the build time API version of Android as an integer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.getdefaultencoding()", "path": "library/sys#sys.getdefaultencoding", "type": "Runtime", "text": "\nReturn the name of the current default string encoding used by the Unicode\nimplementation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.getdlopenflags()", "path": "library/sys#sys.getdlopenflags", "type": "Runtime", "text": "\nReturn the current value of the flags that are used for `dlopen()` calls.\nSymbolic names for the flag values can be found in the `os` module (`RTLD_xxx`\nconstants, e.g. `os.RTLD_LAZY`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.getfilesystemencodeerrors()", "path": "library/sys#sys.getfilesystemencodeerrors", "type": "Runtime", "text": "\nReturn the name of the error mode used to convert between Unicode filenames\nand bytes filenames. The encoding name is returned from\n`getfilesystemencoding()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.getfilesystemencoding()", "path": "library/sys#sys.getfilesystemencoding", "type": "Runtime", "text": "\nReturn the name of the encoding used to convert between Unicode filenames and\nbytes filenames. For best compatibility, str should be used for filenames in\nall cases, although representing filenames as bytes is also supported.\nFunctions accepting or returning filenames should support either str or bytes\nand internally convert to the system\u2019s preferred representation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.getprofile()", "path": "library/sys#sys.getprofile", "type": "Runtime", "text": "\nGet the profiler function as set by `setprofile()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.getrecursionlimit()", "path": "library/sys#sys.getrecursionlimit", "type": "Runtime", "text": "\nReturn the current value of the recursion limit, the maximum depth of the\nPython interpreter stack. This limit prevents infinite recursion from causing\nan overflow of the C stack and crashing Python. It can be set by\n`setrecursionlimit()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.getrefcount()", "path": "library/sys#sys.getrefcount", "type": "Runtime", "text": "\nReturn the reference count of the object. The count returned is generally one\nhigher than you might expect, because it includes the (temporary) reference as\nan argument to `getrefcount()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.getsizeof()", "path": "library/sys#sys.getsizeof", "type": "Runtime", "text": "\nReturn the size of an object in bytes. The object can be any type of object.\nAll built-in objects will return correct results, but this does not have to\nhold true for third-party extensions as it is implementation specific.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.getswitchinterval()", "path": "library/sys#sys.getswitchinterval", "type": "Runtime", "text": "\nReturn the interpreter\u2019s \u201cthread switch interval\u201d; see `setswitchinterval()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.gettrace()", "path": "library/sys#sys.gettrace", "type": "Runtime", "text": "\nGet the trace function as set by `settrace()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.getwindowsversion()", "path": "library/sys#sys.getwindowsversion", "type": "Runtime", "text": "\nReturn a named tuple describing the Windows version currently running. The\nnamed elements are major, minor, build, platform, service_pack,\nservice_pack_minor, service_pack_major, suite_mask, product_type and\nplatform_version. service_pack contains a string, platform_version a 3-tuple\nand all other values are integers. The components can also be accessed by\nname, so `sys.getwindowsversion()[0]` is equivalent to\n`sys.getwindowsversion().major`. For compatibility with prior versions, only\nthe first 5 elements are retrievable by indexing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.get_asyncgen_hooks()", "path": "library/sys#sys.get_asyncgen_hooks", "type": "Runtime", "text": "\nReturns an asyncgen_hooks object, which is similar to a `namedtuple` of the\nform `(firstiter, finalizer)`, where firstiter and finalizer are expected to\nbe either `None` or functions which take an asynchronous generator iterator as\nan argument, and are used to schedule finalization of an asynchronous\ngenerator by an event loop.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.get_coroutine_origin_tracking_depth()", "path": "library/sys#sys.get_coroutine_origin_tracking_depth", "type": "Runtime", "text": "\nGet the current coroutine origin tracking depth, as set by\n`set_coroutine_origin_tracking_depth()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.hash_info", "path": "library/sys#sys.hash_info", "type": "Runtime", "text": "\nA named tuple giving parameters of the numeric hash implementation. For more\ndetails about hashing of numeric types, see Hashing of numeric types.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.hexversion", "path": "library/sys#sys.hexversion", "type": "Runtime", "text": "\nThe version number encoded as a single integer. This is guaranteed to increase\nwith each version, including proper support for non-production releases. For\nexample, to test that the Python interpreter is at least version 1.5.2, use:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.implementation", "path": "library/sys#sys.implementation", "type": "Runtime", "text": "\nAn object containing information about the implementation of the currently\nrunning Python interpreter. The following attributes are required to exist in\nall Python implementations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.intern()", "path": "library/sys#sys.intern", "type": "Runtime", "text": "\nEnter string in the table of \u201cinterned\u201d strings and return the interned string\n\u2013 which is string itself or a copy. Interning strings is useful to gain a\nlittle performance on dictionary lookup \u2013 if the keys in a dictionary are\ninterned, and the lookup key is interned, the key comparisons (after hashing)\ncan be done by a pointer compare instead of a string compare. Normally, the\nnames used in Python programs are automatically interned, and the dictionaries\nused to hold module, class or instance attributes have interned keys.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.int_info", "path": "library/sys#sys.int_info", "type": "Runtime", "text": "\nA named tuple that holds information about Python\u2019s internal representation of\nintegers. The attributes are read only.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.is_finalizing()", "path": "library/sys#sys.is_finalizing", "type": "Runtime", "text": "\nReturn `True` if the Python interpreter is shutting down, `False` otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.last_traceback", "path": "library/sys#sys.last_traceback", "type": "Runtime", "text": "\nThese three variables are not always defined; they are set when an exception\nis not handled and the interpreter prints an error message and a stack\ntraceback. Their intended use is to allow an interactive user to import a\ndebugger module and engage in post-mortem debugging without having to re-\nexecute the command that caused the error. (Typical use is `import pdb;\npdb.pm()` to enter the post-mortem debugger; see `pdb` module for more\ninformation.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.last_type", "path": "library/sys#sys.last_type", "type": "Runtime", "text": "\nThese three variables are not always defined; they are set when an exception\nis not handled and the interpreter prints an error message and a stack\ntraceback. Their intended use is to allow an interactive user to import a\ndebugger module and engage in post-mortem debugging without having to re-\nexecute the command that caused the error. (Typical use is `import pdb;\npdb.pm()` to enter the post-mortem debugger; see `pdb` module for more\ninformation.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.last_value", "path": "library/sys#sys.last_value", "type": "Runtime", "text": "\nThese three variables are not always defined; they are set when an exception\nis not handled and the interpreter prints an error message and a stack\ntraceback. Their intended use is to allow an interactive user to import a\ndebugger module and engage in post-mortem debugging without having to re-\nexecute the command that caused the error. (Typical use is `import pdb;\npdb.pm()` to enter the post-mortem debugger; see `pdb` module for more\ninformation.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.maxsize", "path": "library/sys#sys.maxsize", "type": "Runtime", "text": "\nAn integer giving the maximum value a variable of type `Py_ssize_t` can take.\nIt\u2019s usually `2**31 - 1` on a 32-bit platform and `2**63 - 1` on a 64-bit\nplatform.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.maxunicode", "path": "library/sys#sys.maxunicode", "type": "Runtime", "text": "\nAn integer giving the value of the largest Unicode code point, i.e. `1114111`\n(`0x10FFFF` in hexadecimal).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.meta_path", "path": "library/sys#sys.meta_path", "type": "Runtime", "text": "\nA list of meta path finder objects that have their `find_spec()` methods\ncalled to see if one of the objects can find the module to be imported. The\n`find_spec()` method is called with at least the absolute name of the module\nbeing imported. If the module to be imported is contained in a package, then\nthe parent package\u2019s `__path__` attribute is passed in as a second argument.\nThe method returns a module spec, or `None` if the module cannot be found.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.modules", "path": "library/sys#sys.modules", "type": "Runtime", "text": "\nThis is a dictionary that maps module names to modules which have already been\nloaded. This can be manipulated to force reloading of modules and other\ntricks. However, replacing the dictionary will not necessarily work as\nexpected and deleting essential items from the dictionary may cause Python to\nfail.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.path", "path": "library/sys#sys.path", "type": "Runtime", "text": "\nA list of strings that specifies the search path for modules. Initialized from\nthe environment variable `PYTHONPATH`, plus an installation-dependent default.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.path_hooks", "path": "library/sys#sys.path_hooks", "type": "Runtime", "text": "\nA list of callables that take a path argument to try to create a finder for\nthe path. If a finder can be created, it is to be returned by the callable,\nelse raise `ImportError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.path_importer_cache", "path": "library/sys#sys.path_importer_cache", "type": "Runtime", "text": "\nA dictionary acting as a cache for finder objects. The keys are paths that\nhave been passed to `sys.path_hooks` and the values are the finders that are\nfound. If a path is a valid file system path but no finder is found on\n`sys.path_hooks` then `None` is stored.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.platform", "path": "library/sys#sys.platform", "type": "Runtime", "text": "\nThis string contains a platform identifier that can be used to append\nplatform-specific components to `sys.path`, for instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.platlibdir", "path": "library/sys#sys.platlibdir", "type": "Runtime", "text": "\nName of the platform-specific library directory. It is used to build the path\nof standard library and the paths of installed extension modules.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.prefix", "path": "library/sys#sys.prefix", "type": "Runtime", "text": "\nA string giving the site-specific directory prefix where the platform\nindependent Python files are installed; by default, this is the string\n`'/usr/local'`. This can be set at build time with the `--prefix` argument to\nthe configure script. The main collection of Python library modules is\ninstalled in the directory `prefix/lib/pythonX.Y` while the platform\nindependent header files (all except `pyconfig.h`) are stored in\n`prefix/include/pythonX.Y`, where X.Y is the version number of Python, for\nexample `3.2`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.ps1", "path": "library/sys#sys.ps1", "type": "Runtime", "text": "\nStrings specifying the primary and secondary prompt of the interpreter. These\nare only defined if the interpreter is in interactive mode. Their initial\nvalues in this case are `'>>> '` and `'... '`. If a non-string object is\nassigned to either variable, its `str()` is re-evaluated each time the\ninterpreter prepares to read a new interactive command; this can be used to\nimplement a dynamic prompt.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.ps2", "path": "library/sys#sys.ps2", "type": "Runtime", "text": "\nStrings specifying the primary and secondary prompt of the interpreter. These\nare only defined if the interpreter is in interactive mode. Their initial\nvalues in this case are `'>>> '` and `'... '`. If a non-string object is\nassigned to either variable, its `str()` is re-evaluated each time the\ninterpreter prepares to read a new interactive command; this can be used to\nimplement a dynamic prompt.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.pycache_prefix", "path": "library/sys#sys.pycache_prefix", "type": "Runtime", "text": "\nIf this is set (not `None`), Python will write bytecode-cache `.pyc` files to\n(and read them from) a parallel directory tree rooted at this directory,\nrather than from `__pycache__` directories in the source code tree. Any\n`__pycache__` directories in the source code tree will be ignored and new\n`.pyc` files written within the pycache prefix. Thus if you use `compileall`\nas a pre-build step, you must ensure you run it with the same pycache prefix\n(if any) that you will use at runtime.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.setdlopenflags()", "path": "library/sys#sys.setdlopenflags", "type": "Runtime", "text": "\nSet the flags used by the interpreter for `dlopen()` calls, such as when the\ninterpreter loads extension modules. Among other things, this will enable a\nlazy resolving of symbols when importing a module, if called as\n`sys.setdlopenflags(0)`. To share symbols across extension modules, call as\n`sys.setdlopenflags(os.RTLD_GLOBAL)`. Symbolic names for the flag values can\nbe found in the `os` module (`RTLD_xxx` constants, e.g. `os.RTLD_LAZY`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.setprofile()", "path": "library/sys#sys.setprofile", "type": "Runtime", "text": "\nSet the system\u2019s profile function, which allows you to implement a Python\nsource code profiler in Python. See chapter The Python Profilers for more\ninformation on the Python profiler. The system\u2019s profile function is called\nsimilarly to the system\u2019s trace function (see `settrace()`), but it is called\nwith different events, for example it isn\u2019t called for each executed line of\ncode (only on call and return, but the return event is reported even when an\nexception has been set). The function is thread-specific, but there is no way\nfor the profiler to know about context switches between threads, so it does\nnot make sense to use this in the presence of multiple threads. Also, its\nreturn value is not used, so it can simply return `None`. Error in the profile\nfunction will cause itself unset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.setrecursionlimit()", "path": "library/sys#sys.setrecursionlimit", "type": "Runtime", "text": "\nSet the maximum depth of the Python interpreter stack to limit. This limit\nprevents infinite recursion from causing an overflow of the C stack and\ncrashing Python.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.setswitchinterval()", "path": "library/sys#sys.setswitchinterval", "type": "Runtime", "text": "\nSet the interpreter\u2019s thread switch interval (in seconds). This floating-point\nvalue determines the ideal duration of the \u201ctimeslices\u201d allocated to\nconcurrently running Python threads. Please note that the actual value can be\nhigher, especially if long-running internal functions or methods are used.\nAlso, which thread becomes scheduled at the end of the interval is the\noperating system\u2019s decision. The interpreter doesn\u2019t have its own scheduler.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.settrace()", "path": "library/sys#sys.settrace", "type": "Runtime", "text": "\nSet the system\u2019s trace function, which allows you to implement a Python source\ncode debugger in Python. The function is thread-specific; for a debugger to\nsupport multiple threads, it must register a trace function using `settrace()`\nfor each thread being debugged or use `threading.settrace()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.set_asyncgen_hooks()", "path": "library/sys#sys.set_asyncgen_hooks", "type": "Runtime", "text": "\nAccepts two optional keyword arguments which are callables that accept an\nasynchronous generator iterator as an argument. The firstiter callable will be\ncalled when an asynchronous generator is iterated for the first time. The\nfinalizer will be called when an asynchronous generator is about to be garbage\ncollected.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.set_coroutine_origin_tracking_depth()", "path": "library/sys#sys.set_coroutine_origin_tracking_depth", "type": "Runtime", "text": "\nAllows enabling or disabling coroutine origin tracking. When enabled, the\n`cr_origin` attribute on coroutine objects will contain a tuple of (filename,\nline number, function name) tuples describing the traceback where the\ncoroutine object was created, with the most recent call first. When disabled,\n`cr_origin` will be None.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.stderr", "path": "library/sys#sys.stderr", "type": "Runtime", "text": "\nFile objects used by the interpreter for standard input, output and errors:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.stdin", "path": "library/sys#sys.stdin", "type": "Runtime", "text": "\nFile objects used by the interpreter for standard input, output and errors:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.stdout", "path": "library/sys#sys.stdout", "type": "Runtime", "text": "\nFile objects used by the interpreter for standard input, output and errors:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.thread_info", "path": "library/sys#sys.thread_info", "type": "Runtime", "text": "\nA named tuple holding information about the thread implementation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.tracebacklimit", "path": "library/sys#sys.tracebacklimit", "type": "Runtime", "text": "\nWhen this variable is set to an integer value, it determines the maximum\nnumber of levels of traceback information printed when an unhandled exception\noccurs. The default is `1000`. When set to `0` or less, all traceback\ninformation is suppressed and only the exception type and value are printed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.unraisablehook()", "path": "library/sys#sys.unraisablehook", "type": "Runtime", "text": "\nHandle an unraisable exception.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.version", "path": "library/sys#sys.version", "type": "Runtime", "text": "\nA string containing the version number of the Python interpreter plus\nadditional information on the build number and compiler used. This string is\ndisplayed when the interactive interpreter is started. Do not extract version\ninformation out of it, rather, use `version_info` and the functions provided\nby the `platform` module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.version_info", "path": "library/sys#sys.version_info", "type": "Runtime", "text": "\nA tuple containing the five components of the version number: major, minor,\nmicro, releaselevel, and serial. All values except releaselevel are integers;\nthe release level is `'alpha'`, `'beta'`, `'candidate'`, or `'final'`. The\n`version_info` value corresponding to the Python version 2.0 is `(2, 0, 0,\n'final', 0)`. The components can also be accessed by name, so\n`sys.version_info[0]` is equivalent to `sys.version_info.major` and so on.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.warnoptions", "path": "library/sys#sys.warnoptions", "type": "Runtime", "text": "\nThis is an implementation detail of the warnings framework; do not modify this\nvalue. Refer to the `warnings` module for more information on the warnings\nframework.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.winver", "path": "library/sys#sys.winver", "type": "Runtime", "text": "\nThe version number used to form registry keys on Windows platforms. This is\nstored as string resource 1000 in the Python DLL. The value is normally the\nfirst three characters of `version`. It is provided in the `sys` module for\ninformational purposes; modifying this value has no effect on the registry\nkeys used by Python.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys._clear_type_cache()", "path": "library/sys#sys._clear_type_cache", "type": "Runtime", "text": "\nClear the internal type cache. The type cache is used to speed up attribute\nand method lookups. Use the function only to drop unnecessary references\nduring reference leak debugging.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys._current_frames()", "path": "library/sys#sys._current_frames", "type": "Runtime", "text": "\nReturn a dictionary mapping each thread\u2019s identifier to the topmost stack\nframe currently active in that thread at the time the function is called. Note\nthat functions in the `traceback` module can build the call stack given such a\nframe.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys._debugmallocstats()", "path": "library/sys#sys._debugmallocstats", "type": "Runtime", "text": "\nPrint low-level information to stderr about the state of CPython\u2019s memory\nallocator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys._enablelegacywindowsfsencoding()", "path": "library/sys#sys._enablelegacywindowsfsencoding", "type": "Runtime", "text": "\nChanges the default filesystem encoding and errors mode to \u2018mbcs\u2019 and\n\u2018replace\u2019 respectively, for consistency with versions of Python prior to 3.6.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys._getframe()", "path": "library/sys#sys._getframe", "type": "Runtime", "text": "\nReturn a frame object from the call stack. If optional integer depth is given,\nreturn the frame object that many calls below the top of the stack. If that is\ndeeper than the call stack, `ValueError` is raised. The default for depth is\nzero, returning the frame at the top of the call stack.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys._xoptions", "path": "library/sys#sys._xoptions", "type": "Runtime", "text": "\nA dictionary of the various implementation-specific flags passed through the\n`-X` command-line option. Option names are either mapped to their values, if\ngiven explicitly, or to `True`. Example:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.__breakpointhook__", "path": "library/sys#sys.__breakpointhook__", "type": "Runtime", "text": "\nThese objects contain the original values of `breakpointhook`, `displayhook`,\n`excepthook`, and `unraisablehook` at the start of the program. They are saved\nso that `breakpointhook`, `displayhook` and `excepthook`, `unraisablehook` can\nbe restored in case they happen to get replaced with broken or alternative\nobjects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.__displayhook__", "path": "library/sys#sys.__displayhook__", "type": "Runtime", "text": "\nThese objects contain the original values of `breakpointhook`, `displayhook`,\n`excepthook`, and `unraisablehook` at the start of the program. They are saved\nso that `breakpointhook`, `displayhook` and `excepthook`, `unraisablehook` can\nbe restored in case they happen to get replaced with broken or alternative\nobjects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.__excepthook__", "path": "library/sys#sys.__excepthook__", "type": "Runtime", "text": "\nThese objects contain the original values of `breakpointhook`, `displayhook`,\n`excepthook`, and `unraisablehook` at the start of the program. They are saved\nso that `breakpointhook`, `displayhook` and `excepthook`, `unraisablehook` can\nbe restored in case they happen to get replaced with broken or alternative\nobjects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.__interactivehook__", "path": "library/sys#sys.__interactivehook__", "type": "Runtime", "text": "\nWhen this attribute exists, its value is automatically called (with no\narguments) when the interpreter is launched in interactive mode. This is done\nafter the `PYTHONSTARTUP` file is read, so that you can set this hook there.\nThe `site` module sets this.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.__stderr__", "path": "library/sys#sys.__stderr__", "type": "Runtime", "text": "\nThese objects contain the original values of `stdin`, `stderr` and `stdout` at\nthe start of the program. They are used during finalization, and could be\nuseful to print to the actual standard stream no matter if the `sys.std*`\nobject has been redirected.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.__stdin__", "path": "library/sys#sys.__stdin__", "type": "Runtime", "text": "\nThese objects contain the original values of `stdin`, `stderr` and `stdout` at\nthe start of the program. They are used during finalization, and could be\nuseful to print to the actual standard stream no matter if the `sys.std*`\nobject has been redirected.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.__stdout__", "path": "library/sys#sys.__stdout__", "type": "Runtime", "text": "\nThese objects contain the original values of `stdin`, `stderr` and `stdout` at\nthe start of the program. They are used during finalization, and could be\nuseful to print to the actual standard stream no matter if the `sys.std*`\nobject has been redirected.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sys.__unraisablehook__", "path": "library/sys#sys.__unraisablehook__", "type": "Runtime", "text": "\nThese objects contain the original values of `breakpointhook`, `displayhook`,\n`excepthook`, and `unraisablehook` at the start of the program. They are saved\nso that `breakpointhook`, `displayhook` and `excepthook`, `unraisablehook` can\nbe restored in case they happen to get replaced with broken or alternative\nobjects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sysconfig", "path": "library/sysconfig", "type": "Runtime", "text": "\nNew in version 3.2.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sysconfig.get_config_h_filename()", "path": "library/sysconfig#sysconfig.get_config_h_filename", "type": "Runtime", "text": "\nReturn the path of `pyconfig.h`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sysconfig.get_config_var()", "path": "library/sysconfig#sysconfig.get_config_var", "type": "Runtime", "text": "\nReturn the value of a single variable name. Equivalent to\n`get_config_vars().get(name)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sysconfig.get_config_vars()", "path": "library/sysconfig#sysconfig.get_config_vars", "type": "Runtime", "text": "\nWith no arguments, return a dictionary of all configuration variables relevant\nfor the current platform.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sysconfig.get_makefile_filename()", "path": "library/sysconfig#sysconfig.get_makefile_filename", "type": "Runtime", "text": "\nReturn the path of `Makefile`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sysconfig.get_path()", "path": "library/sysconfig#sysconfig.get_path", "type": "Runtime", "text": "\nReturn an installation path corresponding to the path name, from the install\nscheme named scheme.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sysconfig.get_paths()", "path": "library/sysconfig#sysconfig.get_paths", "type": "Runtime", "text": "\nReturn a dictionary containing all installation paths corresponding to an\ninstallation scheme. See `get_path()` for more information.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sysconfig.get_path_names()", "path": "library/sysconfig#sysconfig.get_path_names", "type": "Runtime", "text": "\nReturn a tuple containing all path names currently supported in `sysconfig`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sysconfig.get_platform()", "path": "library/sysconfig#sysconfig.get_platform", "type": "Runtime", "text": "\nReturn a string that identifies the current platform.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sysconfig.get_python_version()", "path": "library/sysconfig#sysconfig.get_python_version", "type": "Runtime", "text": "\nReturn the `MAJOR.MINOR` Python version number as a string. Similar to\n`'%d.%d' % sys.version_info[:2]`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sysconfig.get_scheme_names()", "path": "library/sysconfig#sysconfig.get_scheme_names", "type": "Runtime", "text": "\nReturn a tuple containing all schemes currently supported in `sysconfig`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sysconfig.is_python_build()", "path": "library/sysconfig#sysconfig.is_python_build", "type": "Runtime", "text": "\nReturn `True` if the running Python interpreter was built from source and is\nbeing run from its built location, and not from a location resulting from e.g.\nrunning `make install` or installing via a binary installer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "sysconfig.parse_config_h()", "path": "library/sysconfig#sysconfig.parse_config_h", "type": "Runtime", "text": "\nParse a `config.h`-style file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "syslog", "path": "library/syslog", "type": "Unix", "text": "\nThis module provides an interface to the Unix `syslog` library routines. Refer\nto the Unix manual pages for a detailed description of the `syslog` facility.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "syslog.closelog()", "path": "library/syslog#syslog.closelog", "type": "Unix", "text": "\nReset the syslog module values and call the system library `closelog()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "syslog.openlog()", "path": "library/syslog#syslog.openlog", "type": "Unix", "text": "\nLogging options of subsequent `syslog()` calls can be set by calling\n`openlog()`. `syslog()` will call `openlog()` with no arguments if the log is\nnot currently open.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "syslog.setlogmask()", "path": "library/syslog#syslog.setlogmask", "type": "Unix", "text": "\nSet the priority mask to maskpri and return the previous mask value. Calls to\n`syslog()` with a priority level not set in maskpri are ignored. The default\nis to log all priorities. The function `LOG_MASK(pri)` calculates the mask for\nthe individual priority pri. The function `LOG_UPTO(pri)` calculates the mask\nfor all priorities up to and including pri.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "syslog.syslog()", "path": "library/syslog#syslog.syslog", "type": "Unix", "text": "\nSend the string message to the system logger. A trailing newline is added if\nnecessary. Each message is tagged with a priority composed of a facility and a\nlevel. The optional priority argument, which defaults to `LOG_INFO`,\ndetermines the message priority. If the facility is not encoded in priority\nusing logical-or (`LOG_INFO | LOG_USER`), the value given in the `openlog()`\ncall is used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "SystemError", "path": "library/exceptions#SystemError", "type": "Built-in Exceptions", "text": "\nRaised when the interpreter finds an internal error, but the situation does\nnot look so serious to cause it to abandon all hope. The associated value is a\nstring indicating what went wrong (in low-level terms).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "SystemExit", "path": "library/exceptions#SystemExit", "type": "Built-in Exceptions", "text": "\nThis exception is raised by the `sys.exit()` function. It inherits from\n`BaseException` instead of `Exception` so that it is not accidentally caught\nby code that catches `Exception`. This allows the exception to properly\npropagate up and cause the interpreter to exit. When it is not handled, the\nPython interpreter exits; no stack traceback is printed. The constructor\naccepts the same optional argument passed to `sys.exit()`. If the value is an\ninteger, it specifies the system exit status (passed to C\u2019s `exit()`\nfunction); if it is `None`, the exit status is zero; if it has another type\n(such as a string), the object\u2019s value is printed and the exit status is one.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "SystemExit.code", "path": "library/exceptions#SystemExit.code", "type": "Built-in Exceptions", "text": "\nThe exit status or error message that is passed to the constructor. (Defaults\nto `None`.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "TabError", "path": "library/exceptions#TabError", "type": "Built-in Exceptions", "text": "\nRaised when indentation contains an inconsistent use of tabs and spaces. This\nis a subclass of `IndentationError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tabnanny", "path": "library/tabnanny", "type": "Language", "text": "\nSource code: Lib/tabnanny.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tabnanny.check()", "path": "library/tabnanny#tabnanny.check", "type": "Language", "text": "\nIf file_or_dir is a directory and not a symbolic link, then recursively\ndescend the directory tree named by file_or_dir, checking all `.py` files\nalong the way. If file_or_dir is an ordinary Python source file, it is checked\nfor whitespace related problems. The diagnostic messages are written to\nstandard output using the `print()` function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tabnanny.filename_only", "path": "library/tabnanny#tabnanny.filename_only", "type": "Language", "text": "\nFlag indicating whether to print only the filenames of files containing\nwhitespace related problems. This is set to true by the `-q` option if called\nas a script.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tabnanny.NannyNag", "path": "library/tabnanny#tabnanny.NannyNag", "type": "Language", "text": "\nRaised by `process_tokens()` if detecting an ambiguous indent. Captured and\nhandled in `check()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tabnanny.process_tokens()", "path": "library/tabnanny#tabnanny.process_tokens", "type": "Language", "text": "\nThis function is used by `check()` to process tokens generated by the\n`tokenize` module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tabnanny.verbose", "path": "library/tabnanny#tabnanny.verbose", "type": "Language", "text": "\nFlag indicating whether to print verbose messages. This is incremented by the\n`-v` option if called as a script.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile", "path": "library/tarfile", "type": "Data Compression", "text": "\nSource code: Lib/tarfile.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.CompressionError", "path": "library/tarfile#tarfile.CompressionError", "type": "Data Compression", "text": "\nIs raised when a compression method is not supported or when the data cannot\nbe decoded properly.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.DEFAULT_FORMAT", "path": "library/tarfile#tarfile.DEFAULT_FORMAT", "type": "Data Compression", "text": "\nThe default format for creating archives. This is currently `PAX_FORMAT`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.ENCODING", "path": "library/tarfile#tarfile.ENCODING", "type": "Data Compression", "text": "\nThe default character encoding: `'utf-8'` on Windows, the value returned by\n`sys.getfilesystemencoding()` otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.ExtractError", "path": "library/tarfile#tarfile.ExtractError", "type": "Data Compression", "text": "\nIs raised for non-fatal errors when using `TarFile.extract()`, but only if\n`TarFile.errorlevel``== 2`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.GNU_FORMAT", "path": "library/tarfile#tarfile.GNU_FORMAT", "type": "Data Compression", "text": "\nGNU tar format.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.HeaderError", "path": "library/tarfile#tarfile.HeaderError", "type": "Data Compression", "text": "\nIs raised by `TarInfo.frombuf()` if the buffer it gets is invalid.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.is_tarfile()", "path": "library/tarfile#tarfile.is_tarfile", "type": "Data Compression", "text": "\nReturn `True` if name is a tar archive file, that the `tarfile` module can\nread. name may be a `str`, file, or file-like object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.open()", "path": "library/tarfile#tarfile.open", "type": "Data Compression", "text": "\nReturn a `TarFile` object for the pathname name. For detailed information on\n`TarFile` objects and the keyword arguments that are allowed, see TarFile\nObjects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.PAX_FORMAT", "path": "library/tarfile#tarfile.PAX_FORMAT", "type": "Data Compression", "text": "\nPOSIX.1-2001 (pax) format.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.ReadError", "path": "library/tarfile#tarfile.ReadError", "type": "Data Compression", "text": "\nIs raised when a tar archive is opened, that either cannot be handled by the\n`tarfile` module or is somehow invalid.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.StreamError", "path": "library/tarfile#tarfile.StreamError", "type": "Data Compression", "text": "\nIs raised for the limitations that are typical for stream-like `TarFile`\nobjects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.TarError", "path": "library/tarfile#tarfile.TarError", "type": "Data Compression", "text": "\nBase class for all `tarfile` exceptions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.TarFile", "path": "library/tarfile#tarfile.TarFile", "type": "Data Compression", "text": "\nAll following arguments are optional and can be accessed as instance\nattributes as well.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.TarFile.add()", "path": "library/tarfile#tarfile.TarFile.add", "type": "Data Compression", "text": "\nAdd the file name to the archive. name may be any type of file (directory,\nfifo, symbolic link, etc.). If given, arcname specifies an alternative name\nfor the file in the archive. Directories are added recursively by default.\nThis can be avoided by setting recursive to `False`. Recursion adds entries in\nsorted order. If filter is given, it should be a function that takes a\n`TarInfo` object argument and returns the changed `TarInfo` object. If it\ninstead returns `None` the `TarInfo` object will be excluded from the archive.\nSee Examples for an example.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.TarFile.addfile()", "path": "library/tarfile#tarfile.TarFile.addfile", "type": "Data Compression", "text": "\nAdd the `TarInfo` object tarinfo to the archive. If fileobj is given, it\nshould be a binary file, and `tarinfo.size` bytes are read from it and added\nto the archive. You can create `TarInfo` objects directly, or by using\n`gettarinfo()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.TarFile.close()", "path": "library/tarfile#tarfile.TarFile.close", "type": "Data Compression", "text": "\nClose the `TarFile`. In write mode, two finishing zero blocks are appended to\nthe archive.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.TarFile.extract()", "path": "library/tarfile#tarfile.TarFile.extract", "type": "Data Compression", "text": "\nExtract a member from the archive to the current working directory, using its\nfull name. Its file information is extracted as accurately as possible. member\nmay be a filename or a `TarInfo` object. You can specify a different directory\nusing path. path may be a path-like object. File attributes (owner, mtime,\nmode) are set unless set_attrs is false.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.TarFile.extractall()", "path": "library/tarfile#tarfile.TarFile.extractall", "type": "Data Compression", "text": "\nExtract all members from the archive to the current working directory or\ndirectory path. If optional members is given, it must be a subset of the list\nreturned by `getmembers()`. Directory information like owner, modification\ntime and permissions are set after all members have been extracted. This is\ndone to work around two problems: A directory\u2019s modification time is reset\neach time a file is created in it. And, if a directory\u2019s permissions do not\nallow writing, extracting files to it will fail.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.TarFile.extractfile()", "path": "library/tarfile#tarfile.TarFile.extractfile", "type": "Data Compression", "text": "\nExtract a member from the archive as a file object. member may be a filename\nor a `TarInfo` object. If member is a regular file or a link, an\n`io.BufferedReader` object is returned. For all other existing members, `None`\nis returned. If member does not appear in the archive, `KeyError` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.TarFile.getmember()", "path": "library/tarfile#tarfile.TarFile.getmember", "type": "Data Compression", "text": "\nReturn a `TarInfo` object for member name. If name can not be found in the\narchive, `KeyError` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.TarFile.getmembers()", "path": "library/tarfile#tarfile.TarFile.getmembers", "type": "Data Compression", "text": "\nReturn the members of the archive as a list of `TarInfo` objects. The list has\nthe same order as the members in the archive.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.TarFile.getnames()", "path": "library/tarfile#tarfile.TarFile.getnames", "type": "Data Compression", "text": "\nReturn the members as a list of their names. It has the same order as the list\nreturned by `getmembers()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.TarFile.gettarinfo()", "path": "library/tarfile#tarfile.TarFile.gettarinfo", "type": "Data Compression", "text": "\nCreate a `TarInfo` object from the result of `os.stat()` or equivalent on an\nexisting file. The file is either named by name, or specified as a file object\nfileobj with a file descriptor. name may be a path-like object. If given,\narcname specifies an alternative name for the file in the archive, otherwise,\nthe name is taken from fileobj\u2019s `name` attribute, or the name argument. The\nname should be a text string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.TarFile.list()", "path": "library/tarfile#tarfile.TarFile.list", "type": "Data Compression", "text": "\nPrint a table of contents to `sys.stdout`. If verbose is `False`, only the\nnames of the members are printed. If it is `True`, output similar to that of\nls -l is produced. If optional members is given, it must be a subset of the\nlist returned by `getmembers()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.TarFile.next()", "path": "library/tarfile#tarfile.TarFile.next", "type": "Data Compression", "text": "\nReturn the next member of the archive as a `TarInfo` object, when `TarFile` is\nopened for reading. Return `None` if there is no more available.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.TarFile.open()", "path": "library/tarfile#tarfile.TarFile.open", "type": "Data Compression", "text": "\nAlternative constructor. The `tarfile.open()` function is actually a shortcut\nto this classmethod.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.TarFile.pax_headers", "path": "library/tarfile#tarfile.TarFile.pax_headers", "type": "Data Compression", "text": "\nA dictionary containing key-value pairs of pax global headers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.TarInfo", "path": "library/tarfile#tarfile.TarInfo", "type": "Data Compression", "text": "\nCreate a `TarInfo` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.TarInfo.frombuf()", "path": "library/tarfile#tarfile.TarInfo.frombuf", "type": "Data Compression", "text": "\nCreate and return a `TarInfo` object from string buffer buf.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.TarInfo.fromtarfile()", "path": "library/tarfile#tarfile.TarInfo.fromtarfile", "type": "Data Compression", "text": "\nRead the next member from the `TarFile` object tarfile and return it as a\n`TarInfo` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.TarInfo.gid", "path": "library/tarfile#tarfile.TarInfo.gid", "type": "Data Compression", "text": "\nGroup ID of the user who originally stored this member.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.TarInfo.gname", "path": "library/tarfile#tarfile.TarInfo.gname", "type": "Data Compression", "text": "\nGroup name.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.TarInfo.isblk()", "path": "library/tarfile#tarfile.TarInfo.isblk", "type": "Data Compression", "text": "\nReturn `True` if it is a block device.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.TarInfo.ischr()", "path": "library/tarfile#tarfile.TarInfo.ischr", "type": "Data Compression", "text": "\nReturn `True` if it is a character device.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.TarInfo.isdev()", "path": "library/tarfile#tarfile.TarInfo.isdev", "type": "Data Compression", "text": "\nReturn `True` if it is one of character device, block device or FIFO.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.TarInfo.isdir()", "path": "library/tarfile#tarfile.TarInfo.isdir", "type": "Data Compression", "text": "\nReturn `True` if it is a directory.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.TarInfo.isfifo()", "path": "library/tarfile#tarfile.TarInfo.isfifo", "type": "Data Compression", "text": "\nReturn `True` if it is a FIFO.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.TarInfo.isfile()", "path": "library/tarfile#tarfile.TarInfo.isfile", "type": "Data Compression", "text": "\nReturn `True` if the `Tarinfo` object is a regular file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.TarInfo.islnk()", "path": "library/tarfile#tarfile.TarInfo.islnk", "type": "Data Compression", "text": "\nReturn `True` if it is a hard link.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.TarInfo.isreg()", "path": "library/tarfile#tarfile.TarInfo.isreg", "type": "Data Compression", "text": "\nSame as `isfile()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.TarInfo.issym()", "path": "library/tarfile#tarfile.TarInfo.issym", "type": "Data Compression", "text": "\nReturn `True` if it is a symbolic link.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.TarInfo.linkname", "path": "library/tarfile#tarfile.TarInfo.linkname", "type": "Data Compression", "text": "\nName of the target file name, which is only present in `TarInfo` objects of\ntype `LNKTYPE` and `SYMTYPE`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.TarInfo.mode", "path": "library/tarfile#tarfile.TarInfo.mode", "type": "Data Compression", "text": "\nPermission bits.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.TarInfo.mtime", "path": "library/tarfile#tarfile.TarInfo.mtime", "type": "Data Compression", "text": "\nTime of last modification.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.TarInfo.name", "path": "library/tarfile#tarfile.TarInfo.name", "type": "Data Compression", "text": "\nName of the archive member.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.TarInfo.pax_headers", "path": "library/tarfile#tarfile.TarInfo.pax_headers", "type": "Data Compression", "text": "\nA dictionary containing key-value pairs of an associated pax extended header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.TarInfo.size", "path": "library/tarfile#tarfile.TarInfo.size", "type": "Data Compression", "text": "\nSize in bytes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.TarInfo.tobuf()", "path": "library/tarfile#tarfile.TarInfo.tobuf", "type": "Data Compression", "text": "\nCreate a string buffer from a `TarInfo` object. For information on the\narguments see the constructor of the `TarFile` class.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.TarInfo.type", "path": "library/tarfile#tarfile.TarInfo.type", "type": "Data Compression", "text": "\nFile type. type is usually one of these constants: `REGTYPE`, `AREGTYPE`,\n`LNKTYPE`, `SYMTYPE`, `DIRTYPE`, `FIFOTYPE`, `CONTTYPE`, `CHRTYPE`, `BLKTYPE`,\n`GNUTYPE_SPARSE`. To determine the type of a `TarInfo` object more\nconveniently, use the `is*()` methods below.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.TarInfo.uid", "path": "library/tarfile#tarfile.TarInfo.uid", "type": "Data Compression", "text": "\nUser ID of the user who originally stored this member.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.TarInfo.uname", "path": "library/tarfile#tarfile.TarInfo.uname", "type": "Data Compression", "text": "\nUser name.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tarfile.USTAR_FORMAT", "path": "library/tarfile#tarfile.USTAR_FORMAT", "type": "Data Compression", "text": "\nPOSIX.1-1988 (ustar) format.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "telnetlib", "path": "library/telnetlib", "type": "Internet", "text": "\nSource code: Lib/telnetlib.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "telnetlib.Telnet", "path": "library/telnetlib#telnetlib.Telnet", "type": "Internet", "text": "\n`Telnet` represents a connection to a Telnet server. The instance is initially\nnot connected by default; the `open()` method must be used to establish a\nconnection. Alternatively, the host name and optional port number can be\npassed to the constructor too, in which case the connection to the server will\nbe established before the constructor returns. The optional timeout parameter\nspecifies a timeout in seconds for blocking operations like the connection\nattempt (if not specified, the global default timeout setting will be used).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "telnetlib.Telnet.close()", "path": "library/telnetlib#telnetlib.Telnet.close", "type": "Internet", "text": "\nClose the connection.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "telnetlib.Telnet.expect()", "path": "library/telnetlib#telnetlib.Telnet.expect", "type": "Internet", "text": "\nRead until one from a list of a regular expressions matches.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "telnetlib.Telnet.fileno()", "path": "library/telnetlib#telnetlib.Telnet.fileno", "type": "Internet", "text": "\nReturn the file descriptor of the socket object used internally.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "telnetlib.Telnet.get_socket()", "path": "library/telnetlib#telnetlib.Telnet.get_socket", "type": "Internet", "text": "\nReturn the socket object used internally.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "telnetlib.Telnet.interact()", "path": "library/telnetlib#telnetlib.Telnet.interact", "type": "Internet", "text": "\nInteraction function, emulates a very dumb Telnet client.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "telnetlib.Telnet.msg()", "path": "library/telnetlib#telnetlib.Telnet.msg", "type": "Internet", "text": "\nPrint a debug message when the debug level is `>` 0\\. If extra arguments are\npresent, they are substituted in the message using the standard string\nformatting operator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "telnetlib.Telnet.mt_interact()", "path": "library/telnetlib#telnetlib.Telnet.mt_interact", "type": "Internet", "text": "\nMultithreaded version of `interact()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "telnetlib.Telnet.open()", "path": "library/telnetlib#telnetlib.Telnet.open", "type": "Internet", "text": "\nConnect to a host. The optional second argument is the port number, which\ndefaults to the standard Telnet port (23). The optional timeout parameter\nspecifies a timeout in seconds for blocking operations like the connection\nattempt (if not specified, the global default timeout setting will be used).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "telnetlib.Telnet.read_all()", "path": "library/telnetlib#telnetlib.Telnet.read_all", "type": "Internet", "text": "\nRead all data until EOF as bytes; block until connection closed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "telnetlib.Telnet.read_eager()", "path": "library/telnetlib#telnetlib.Telnet.read_eager", "type": "Internet", "text": "\nRead readily available data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "telnetlib.Telnet.read_lazy()", "path": "library/telnetlib#telnetlib.Telnet.read_lazy", "type": "Internet", "text": "\nProcess and return data already in the queues (lazy).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "telnetlib.Telnet.read_sb_data()", "path": "library/telnetlib#telnetlib.Telnet.read_sb_data", "type": "Internet", "text": "\nReturn the data collected between a SB/SE pair (suboption begin/end). The\ncallback should access these data when it was invoked with a `SE` command.\nThis method never blocks.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "telnetlib.Telnet.read_some()", "path": "library/telnetlib#telnetlib.Telnet.read_some", "type": "Internet", "text": "\nRead at least one byte of cooked data unless EOF is hit. Return `b''` if EOF\nis hit. Block if no data is immediately available.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "telnetlib.Telnet.read_until()", "path": "library/telnetlib#telnetlib.Telnet.read_until", "type": "Internet", "text": "\nRead until a given byte string, expected, is encountered or until timeout\nseconds have passed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "telnetlib.Telnet.read_very_eager()", "path": "library/telnetlib#telnetlib.Telnet.read_very_eager", "type": "Internet", "text": "\nRead everything that can be without blocking in I/O (eager).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "telnetlib.Telnet.read_very_lazy()", "path": "library/telnetlib#telnetlib.Telnet.read_very_lazy", "type": "Internet", "text": "\nReturn any data available in the cooked queue (very lazy).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "telnetlib.Telnet.set_debuglevel()", "path": "library/telnetlib#telnetlib.Telnet.set_debuglevel", "type": "Internet", "text": "\nSet the debug level. The higher the value of debuglevel, the more debug output\nyou get (on `sys.stdout`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "telnetlib.Telnet.set_option_negotiation_callback()", "path": "library/telnetlib#telnetlib.Telnet.set_option_negotiation_callback", "type": "Internet", "text": "\nEach time a telnet option is read on the input flow, this callback (if set) is\ncalled with the following parameters: callback(telnet socket, command\n(DO/DONT/WILL/WONT), option). No other action is done afterwards by telnetlib.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "telnetlib.Telnet.write()", "path": "library/telnetlib#telnetlib.Telnet.write", "type": "Internet", "text": "\nWrite a byte string to the socket, doubling any IAC characters. This can block\nif the connection is blocked. May raise `OSError` if the connection is closed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tempfile", "path": "library/tempfile", "type": "File & Directory Access", "text": "\nSource code: Lib/tempfile.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tempfile.gettempdir()", "path": "library/tempfile#tempfile.gettempdir", "type": "File & Directory Access", "text": "\nReturn the name of the directory used for temporary files. This defines the\ndefault value for the dir argument to all functions in this module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tempfile.gettempdirb()", "path": "library/tempfile#tempfile.gettempdirb", "type": "File & Directory Access", "text": "\nSame as `gettempdir()` but the return value is in bytes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tempfile.gettempprefix()", "path": "library/tempfile#tempfile.gettempprefix", "type": "File & Directory Access", "text": "\nReturn the filename prefix used to create temporary files. This does not\ncontain the directory component.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tempfile.gettempprefixb()", "path": "library/tempfile#tempfile.gettempprefixb", "type": "File & Directory Access", "text": "\nSame as `gettempprefix()` but the return value is in bytes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tempfile.mkdtemp()", "path": "library/tempfile#tempfile.mkdtemp", "type": "File & Directory Access", "text": "\nCreates a temporary directory in the most secure manner possible. There are no\nrace conditions in the directory\u2019s creation. The directory is readable,\nwritable, and searchable only by the creating user ID.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tempfile.mkstemp()", "path": "library/tempfile#tempfile.mkstemp", "type": "File & Directory Access", "text": "\nCreates a temporary file in the most secure manner possible. There are no race\nconditions in the file\u2019s creation, assuming that the platform properly\nimplements the `os.O_EXCL` flag for `os.open()`. The file is readable and\nwritable only by the creating user ID. If the platform uses permission bits to\nindicate whether a file is executable, the file is executable by no one. The\nfile descriptor is not inherited by child processes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tempfile.mktemp()", "path": "library/tempfile#tempfile.mktemp", "type": "File & Directory Access", "text": "\nDeprecated since version 2.3: Use `mkstemp()` instead.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tempfile.NamedTemporaryFile()", "path": "library/tempfile#tempfile.NamedTemporaryFile", "type": "File & Directory Access", "text": "\nThis function operates exactly as `TemporaryFile()` does, except that the file\nis guaranteed to have a visible name in the file system (on Unix, the\ndirectory entry is not unlinked). That name can be retrieved from the `name`\nattribute of the returned file-like object. Whether the name can be used to\nopen the file a second time, while the named temporary file is still open,\nvaries across platforms (it can be so used on Unix; it cannot on Windows NT or\nlater). If delete is true (the default), the file is deleted as soon as it is\nclosed. The returned object is always a file-like object whose `file`\nattribute is the underlying true file object. This file-like object can be\nused in a `with` statement, just like a normal file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tempfile.SpooledTemporaryFile()", "path": "library/tempfile#tempfile.SpooledTemporaryFile", "type": "File & Directory Access", "text": "\nThis function operates exactly as `TemporaryFile()` does, except that data is\nspooled in memory until the file size exceeds max_size, or until the file\u2019s\n`fileno()` method is called, at which point the contents are written to disk\nand operation proceeds as with `TemporaryFile()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tempfile.tempdir", "path": "library/tempfile#tempfile.tempdir", "type": "File & Directory Access", "text": "\nWhen set to a value other than `None`, this variable defines the default value\nfor the dir argument to the functions defined in this module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tempfile.TemporaryDirectory()", "path": "library/tempfile#tempfile.TemporaryDirectory", "type": "File & Directory Access", "text": "\nThis function securely creates a temporary directory using the same rules as\n`mkdtemp()`. The resulting object can be used as a context manager (see\nExamples). On completion of the context or destruction of the temporary\ndirectory object the newly created temporary directory and all its contents\nare removed from the filesystem.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tempfile.TemporaryFile()", "path": "library/tempfile#tempfile.TemporaryFile", "type": "File & Directory Access", "text": "\nReturn a file-like object that can be used as a temporary storage area. The\nfile is created securely, using the same rules as `mkstemp()`. It will be\ndestroyed as soon as it is closed (including an implicit close when the object\nis garbage collected). Under Unix, the directory entry for the file is either\nnot created at all or is removed immediately after the file is created. Other\nplatforms do not support this; your code should not rely on a temporary file\ncreated using this function having or not having a visible name in the file\nsystem.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "termios", "path": "library/termios", "type": "Unix", "text": "\nThis module provides an interface to the POSIX calls for tty I/O control. For\na complete description of these calls, see termios(3) Unix manual page. It is\nonly available for those Unix versions that support POSIX termios style tty\nI/O control configured during installation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "termios.tcdrain()", "path": "library/termios#termios.tcdrain", "type": "Unix", "text": "\nWait until all output written to file descriptor fd has been transmitted.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "termios.tcflow()", "path": "library/termios#termios.tcflow", "type": "Unix", "text": "\nSuspend or resume input or output on file descriptor fd. The action argument\ncan be `TCOOFF` to suspend output, `TCOON` to restart output, `TCIOFF` to\nsuspend input, or `TCION` to restart input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "termios.tcflush()", "path": "library/termios#termios.tcflush", "type": "Unix", "text": "\nDiscard queued data on file descriptor fd. The queue selector specifies which\nqueue: `TCIFLUSH` for the input queue, `TCOFLUSH` for the output queue, or\n`TCIOFLUSH` for both queues.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "termios.tcgetattr()", "path": "library/termios#termios.tcgetattr", "type": "Unix", "text": "\nReturn a list containing the tty attributes for file descriptor fd, as\nfollows: `[iflag, oflag, cflag, lflag, ispeed, ospeed, cc]` where cc is a list\nof the tty special characters (each a string of length 1, except the items\nwith indices `VMIN` and `VTIME`, which are integers when these fields are\ndefined). The interpretation of the flags and the speeds as well as the\nindexing in the cc array must be done using the symbolic constants defined in\nthe `termios` module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "termios.tcsendbreak()", "path": "library/termios#termios.tcsendbreak", "type": "Unix", "text": "\nSend a break on file descriptor fd. A zero duration sends a break for 0.25\u20130.5\nseconds; a nonzero duration has a system dependent meaning.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "termios.tcsetattr()", "path": "library/termios#termios.tcsetattr", "type": "Unix", "text": "\nSet the tty attributes for file descriptor fd from the attributes, which is a\nlist like the one returned by `tcgetattr()`. The when argument determines when\nthe attributes are changed: `TCSANOW` to change immediately, `TCSADRAIN` to\nchange after transmitting all queued output, or `TCSAFLUSH` to change after\ntransmitting all queued output and discarding all queued input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test", "path": "library/test", "type": "Development Tools", "text": "\nNote\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.ALWAYS_EQ", "path": "library/test#test.support.ALWAYS_EQ", "type": "Development Tools", "text": "\nObject that is equal to anything. Used to test mixed type comparison.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.anticipate_failure()", "path": "library/test#test.support.anticipate_failure", "type": "Development Tools", "text": "\nA decorator to conditionally mark tests with `unittest.expectedFailure()`. Any\nuse of this decorator should have an associated comment identifying the\nrelevant tracker issue.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.args_from_interpreter_flags()", "path": "library/test#test.support.args_from_interpreter_flags", "type": "Development Tools", "text": "\nReturn a list of command line arguments reproducing the current settings in\n`sys.flags` and `sys.warnoptions`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.BasicTestRunner", "path": "library/test#test.support.BasicTestRunner", "type": "Development Tools", "text": "\nRun test and return the result.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.BasicTestRunner.run()", "path": "library/test#test.support.BasicTestRunner.run", "type": "Development Tools", "text": "\nRun test and return the result.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.bigaddrspacetest()", "path": "library/test#test.support.bigaddrspacetest", "type": "Development Tools", "text": "\nDecorator for tests that fill the address space. f is the function to wrap.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.bigmemtest()", "path": "library/test#test.support.bigmemtest", "type": "Development Tools", "text": "\nDecorator for bigmem tests.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.bytecode_helper.BytecodeTestCase", "path": "library/test#test.support.bytecode_helper.BytecodeTestCase", "type": "Development Tools", "text": "\nThis class has custom assertion methods for inspecting bytecode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.bytecode_helper.BytecodeTestCase.assertInBytecode()", "path": "library/test#test.support.bytecode_helper.BytecodeTestCase.assertInBytecode", "type": "Development Tools", "text": "\nReturn instr if opname is found, otherwise throws `AssertionError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.bytecode_helper.BytecodeTestCase.assertNotInBytecode()", "path": "library/test#test.support.bytecode_helper.BytecodeTestCase.assertNotInBytecode", "type": "Development Tools", "text": "\nThrows `AssertionError` if opname is found.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.bytecode_helper.BytecodeTestCase.get_disassembly_as_string()", "path": "library/test#test.support.bytecode_helper.BytecodeTestCase.get_disassembly_as_string", "type": "Development Tools", "text": "\nReturn the disassembly of co as string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.calcobjsize()", "path": "library/test#test.support.calcobjsize", "type": "Development Tools", "text": "\nReturn `struct.calcsize()` for `nP{fmt}0n` or, if `gettotalrefcount` exists,\n`2PnP{fmt}0P`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.calcvobjsize()", "path": "library/test#test.support.calcvobjsize", "type": "Development Tools", "text": "\nReturn `struct.calcsize()` for `nPn{fmt}0n` or, if `gettotalrefcount` exists,\n`2PnPn{fmt}0P`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.can_symlink()", "path": "library/test#test.support.can_symlink", "type": "Development Tools", "text": "\nReturn `True` if the OS supports symbolic links, `False` otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.can_xattr()", "path": "library/test#test.support.can_xattr", "type": "Development Tools", "text": "\nReturn `True` if the OS supports xattr, `False` otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.captured_stderr()", "path": "library/test#test.support.captured_stderr", "type": "Development Tools", "text": "\nA context managers that temporarily replaces the named stream with\n`io.StringIO` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.captured_stdin()", "path": "library/test#test.support.captured_stdin", "type": "Development Tools", "text": "\nA context managers that temporarily replaces the named stream with\n`io.StringIO` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.captured_stdout()", "path": "library/test#test.support.captured_stdout", "type": "Development Tools", "text": "\nA context managers that temporarily replaces the named stream with\n`io.StringIO` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.catch_threading_exception()", "path": "library/test#test.support.catch_threading_exception", "type": "Development Tools", "text": "\nContext manager catching `threading.Thread` exception using\n`threading.excepthook()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.catch_unraisable_exception()", "path": "library/test#test.support.catch_unraisable_exception", "type": "Development Tools", "text": "\nContext manager catching unraisable exception using `sys.unraisablehook()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.change_cwd()", "path": "library/test#test.support.change_cwd", "type": "Development Tools", "text": "\nA context manager that temporarily changes the current working directory to\npath and yields the directory.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.checksizeof()", "path": "library/test#test.support.checksizeof", "type": "Development Tools", "text": "\nFor testcase test, assert that the `sys.getsizeof` for o plus the GC header\nsize equals size.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.check_free_after_iterating()", "path": "library/test#test.support.check_free_after_iterating", "type": "Development Tools", "text": "\nAssert that iter is deallocated after iterating.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.check_impl_detail()", "path": "library/test#test.support.check_impl_detail", "type": "Development Tools", "text": "\nUse this check to guard CPython\u2019s implementation-specific tests or to run them\nonly on the implementations guarded by the arguments:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.check_no_resource_warning()", "path": "library/test#test.support.check_no_resource_warning", "type": "Development Tools", "text": "\nContext manager to check that no `ResourceWarning` was raised. You must remove\nthe object which may emit `ResourceWarning` before the end of the context\nmanager.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.check_syntax_error()", "path": "library/test#test.support.check_syntax_error", "type": "Development Tools", "text": "\nTest for syntax errors in statement by attempting to compile statement.\ntestcase is the `unittest` instance for the test. errtext is the regular\nexpression which should match the string representation of the raised\n`SyntaxError`. If lineno is not `None`, compares to the line of the exception.\nIf offset is not `None`, compares to the offset of the exception.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.check_syntax_warning()", "path": "library/test#test.support.check_syntax_warning", "type": "Development Tools", "text": "\nTest for syntax warning in statement by attempting to compile statement. Test\nalso that the `SyntaxWarning` is emitted only once, and that it will be\nconverted to a `SyntaxError` when turned into error. testcase is the\n`unittest` instance for the test. errtext is the regular expression which\nshould match the string representation of the emitted `SyntaxWarning` and\nraised `SyntaxError`. If lineno is not `None`, compares to the line of the\nwarning and exception. If offset is not `None`, compares to the offset of the\nexception.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.check_warnings()", "path": "library/test#test.support.check_warnings", "type": "Development Tools", "text": "\nA convenience wrapper for `warnings.catch_warnings()` that makes it easier to\ntest that a warning was correctly raised. It is approximately equivalent to\ncalling `warnings.catch_warnings(record=True)` with `warnings.simplefilter()`\nset to `always` and with the option to automatically validate the results that\nare recorded.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.check__all__()", "path": "library/test#test.support.check__all__", "type": "Development Tools", "text": "\nAssert that the `__all__` variable of module contains all public names.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.CleanImport", "path": "library/test#test.support.CleanImport", "type": "Development Tools", "text": "\nA context manager to force import to return a new module reference. This is\nuseful for testing module-level behaviors, such as the emission of a\nDeprecationWarning on import. Example usage:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.cpython_only()", "path": "library/test#test.support.cpython_only", "type": "Development Tools", "text": "\nDecorator for tests only applicable to CPython.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.create_empty_file()", "path": "library/test#test.support.create_empty_file", "type": "Development Tools", "text": "\nCreate an empty file with filename. If it already exists, truncate it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.detect_api_mismatch()", "path": "library/test#test.support.detect_api_mismatch", "type": "Development Tools", "text": "\nReturns the set of attributes, functions or methods of ref_api not found on\nother_api, except for a defined list of items to be ignored in this check\nspecified in ignore.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.DirsOnSysPath", "path": "library/test#test.support.DirsOnSysPath", "type": "Development Tools", "text": "\nA context manager to temporarily add directories to sys.path.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.disable_faulthandler()", "path": "library/test#test.support.disable_faulthandler", "type": "Development Tools", "text": "\nA context manager that replaces `sys.stderr` with `sys.__stderr__`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.disable_gc()", "path": "library/test#test.support.disable_gc", "type": "Development Tools", "text": "\nA context manager that disables the garbage collector upon entry and reenables\nit upon exit.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.EnvironmentVarGuard", "path": "library/test#test.support.EnvironmentVarGuard", "type": "Development Tools", "text": "\nClass used to temporarily set or unset environment variables. Instances can be\nused as a context manager and have a complete dictionary interface for\nquerying/modifying the underlying `os.environ`. After exit from the context\nmanager all changes to environment variables done through this instance will\nbe rolled back.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.EnvironmentVarGuard.set()", "path": "library/test#test.support.EnvironmentVarGuard.set", "type": "Development Tools", "text": "\nTemporarily set the environment variable `envvar` to the value of `value`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.EnvironmentVarGuard.unset()", "path": "library/test#test.support.EnvironmentVarGuard.unset", "type": "Development Tools", "text": "\nTemporarily unset the environment variable `envvar`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.FakePath", "path": "library/test#test.support.FakePath", "type": "Development Tools", "text": "\nSimple path-like object. It implements the `__fspath__()` method which just\nreturns the path argument. If path is an exception, it will be raised in\n`__fspath__()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.fd_count()", "path": "library/test#test.support.fd_count", "type": "Development Tools", "text": "\nCount the number of open file descriptors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.findfile()", "path": "library/test#test.support.findfile", "type": "Development Tools", "text": "\nReturn the path to the file named filename. If no match is found filename is\nreturned. This does not equal a failure since it could be the path to the\nfile.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.forget()", "path": "library/test#test.support.forget", "type": "Development Tools", "text": "\nRemove the module named module_name from `sys.modules` and delete any byte-\ncompiled files of the module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.fs_is_case_insensitive()", "path": "library/test#test.support.fs_is_case_insensitive", "type": "Development Tools", "text": "\nReturn `True` if the file system for directory is case-insensitive.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.FS_NONASCII", "path": "library/test#test.support.FS_NONASCII", "type": "Development Tools", "text": "\nA non-ASCII character encodable by `os.fsencode()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.gc_collect()", "path": "library/test#test.support.gc_collect", "type": "Development Tools", "text": "\nForce as many objects as possible to be collected. This is needed because\ntimely deallocation is not guaranteed by the garbage collector. This means\nthat `__del__` methods may be called later than expected and weakrefs may\nremain alive for longer than expected.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.get_attribute()", "path": "library/test#test.support.get_attribute", "type": "Development Tools", "text": "\nGet an attribute, raising `unittest.SkipTest` if `AttributeError` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.get_original_stdout()", "path": "library/test#test.support.get_original_stdout", "type": "Development Tools", "text": "\nReturn the original stdout set by `record_original_stdout()` or `sys.stdout`\nif it\u2019s not set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.HAVE_DOCSTRINGS", "path": "library/test#test.support.HAVE_DOCSTRINGS", "type": "Development Tools", "text": "\nCheck for presence of docstrings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.impl_detail()", "path": "library/test#test.support.impl_detail", "type": "Development Tools", "text": "\nDecorator for invoking `check_impl_detail()` on guards. If that returns\n`False`, then uses msg as the reason for skipping the test.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.import_fresh_module()", "path": "library/test#test.support.import_fresh_module", "type": "Development Tools", "text": "\nThis function imports and returns a fresh copy of the named Python module by\nremoving the named module from `sys.modules` before doing the import. Note\nthat unlike `reload()`, the original module is not affected by this operation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.import_module()", "path": "library/test#test.support.import_module", "type": "Development Tools", "text": "\nThis function imports and returns the named module. Unlike a normal import,\nthis function raises `unittest.SkipTest` if the module cannot be imported.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.INTERNET_TIMEOUT", "path": "library/test#test.support.INTERNET_TIMEOUT", "type": "Development Tools", "text": "\nTimeout in seconds for network requests going to the Internet.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.is_android", "path": "library/test#test.support.is_android", "type": "Development Tools", "text": "\n`True` if the system is Android.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.is_jython", "path": "library/test#test.support.is_jython", "type": "Development Tools", "text": "\n`True` if the running interpreter is Jython.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.is_resource_enabled()", "path": "library/test#test.support.is_resource_enabled", "type": "Development Tools", "text": "\nReturn `True` if resource is enabled and available. The list of available\nresources is only set when `test.regrtest` is executing the tests.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.join_thread()", "path": "library/test#test.support.join_thread", "type": "Development Tools", "text": "\nJoin a thread within timeout. Raise an `AssertionError` if thread is still\nalive after timeout seconds.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.LARGEST", "path": "library/test#test.support.LARGEST", "type": "Development Tools", "text": "\nObject that is greater than anything (except itself). Used to test mixed type\ncomparison.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.load_package_tests()", "path": "library/test#test.support.load_package_tests", "type": "Development Tools", "text": "\nGeneric implementation of the `unittest` `load_tests` protocol for use in test\npackages. pkg_dir is the root directory of the package; loader,\nstandard_tests, and pattern are the arguments expected by `load_tests`. In\nsimple cases, the test package\u2019s `__init__.py` can be the following:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.LONG_TIMEOUT", "path": "library/test#test.support.LONG_TIMEOUT", "type": "Development Tools", "text": "\nTimeout in seconds to detect when a test hangs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.LOOPBACK_TIMEOUT", "path": "library/test#test.support.LOOPBACK_TIMEOUT", "type": "Development Tools", "text": "\nTimeout in seconds for tests using a network server listening on the network\nlocal loopback interface like `127.0.0.1`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.make_bad_fd()", "path": "library/test#test.support.make_bad_fd", "type": "Development Tools", "text": "\nCreate an invalid file descriptor by opening and closing a temporary file, and\nreturning its descriptor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.make_legacy_pyc()", "path": "library/test#test.support.make_legacy_pyc", "type": "Development Tools", "text": "\nMove a PEP 3147/PEP 488 pyc file to its legacy pyc location and return the\nfile system path to the legacy pyc file. The source value is the file system\npath to the source file. It does not need to exist, however the PEP 3147/488\npyc file must exist.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.Matcher", "path": "library/test#test.support.Matcher", "type": "Development Tools", "text": "\nTry to match a single dict with the supplied arguments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.Matcher.matches()", "path": "library/test#test.support.Matcher.matches", "type": "Development Tools", "text": "\nTry to match a single dict with the supplied arguments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.Matcher.match_value()", "path": "library/test#test.support.Matcher.match_value", "type": "Development Tools", "text": "\nTry to match a single stored value (dv) with a supplied value (v).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.match_test()", "path": "library/test#test.support.match_test", "type": "Development Tools", "text": "\nMatch test to patterns set in `set_match_tests()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.max_memuse", "path": "library/test#test.support.max_memuse", "type": "Development Tools", "text": "\nSet by `set_memlimit()` as the memory limit for big memory tests. Limited by\n`MAX_Py_ssize_t`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.MAX_Py_ssize_t", "path": "library/test#test.support.MAX_Py_ssize_t", "type": "Development Tools", "text": "\nSet to `sys.maxsize` for big memory tests.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.missing_compiler_executable()", "path": "library/test#test.support.missing_compiler_executable", "type": "Development Tools", "text": "\nCheck for the existence of the compiler executables whose names are listed in\ncmd_names or all the compiler executables when cmd_names is empty and return\nthe first missing executable or `None` when none is found missing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.MISSING_C_DOCSTRINGS", "path": "library/test#test.support.MISSING_C_DOCSTRINGS", "type": "Development Tools", "text": "\nReturn `True` if running on CPython, not on Windows, and configuration not set\nwith `WITH_DOC_STRINGS`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.modules_cleanup()", "path": "library/test#test.support.modules_cleanup", "type": "Development Tools", "text": "\nRemove modules except for oldmodules and `encodings` in order to preserve\ninternal cache.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.modules_setup()", "path": "library/test#test.support.modules_setup", "type": "Development Tools", "text": "\nReturn a copy of `sys.modules`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.NEVER_EQ", "path": "library/test#test.support.NEVER_EQ", "type": "Development Tools", "text": "\nObject that is not equal to anything (even to `ALWAYS_EQ`). Used to test mixed\ntype comparison.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.no_tracing()", "path": "library/test#test.support.no_tracing", "type": "Development Tools", "text": "\nDecorator to temporarily turn off tracing for the duration of the test.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.open_urlresource()", "path": "library/test#test.support.open_urlresource", "type": "Development Tools", "text": "\nOpen url. If open fails, raises `TestFailed`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.optim_args_from_interpreter_flags()", "path": "library/test#test.support.optim_args_from_interpreter_flags", "type": "Development Tools", "text": "\nReturn a list of command line arguments reproducing the current optimization\nsettings in `sys.flags`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.patch()", "path": "library/test#test.support.patch", "type": "Development Tools", "text": "\nOverride object_to_patch.attr_name with new_value. Also add cleanup procedure\nto test_instance to restore object_to_patch for attr_name. The attr_name\nshould be a valid attribute for object_to_patch.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.PGO", "path": "library/test#test.support.PGO", "type": "Development Tools", "text": "\nSet when tests can be skipped when they are not useful for PGO.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.PIPE_MAX_SIZE", "path": "library/test#test.support.PIPE_MAX_SIZE", "type": "Development Tools", "text": "\nA constant that is likely larger than the underlying OS pipe buffer size, to\nmake writes blocking.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.print_warning()", "path": "library/test#test.support.print_warning", "type": "Development Tools", "text": "\nPrint a warning into `sys.__stderr__`. Format the message as: `f\"Warning --\n{msg}\"`. If msg is made of multiple lines, add `\"Warning -- \"` prefix to each\nline.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.python_is_optimized()", "path": "library/test#test.support.python_is_optimized", "type": "Development Tools", "text": "\nReturn `True` if Python was not built with `-O0` or `-Og`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.real_max_memuse", "path": "library/test#test.support.real_max_memuse", "type": "Development Tools", "text": "\nSet by `set_memlimit()` as the memory limit for big memory tests. Not limited\nby `MAX_Py_ssize_t`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.reap_children()", "path": "library/test#test.support.reap_children", "type": "Development Tools", "text": "\nUse this at the end of `test_main` whenever sub-processes are started. This\nwill help ensure that no extra children (zombies) stick around to hog\nresources and create problems when looking for refleaks.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.reap_threads()", "path": "library/test#test.support.reap_threads", "type": "Development Tools", "text": "\nDecorator to ensure the threads are cleaned up even if the test fails.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.record_original_stdout()", "path": "library/test#test.support.record_original_stdout", "type": "Development Tools", "text": "\nStore the value from stdout. It is meant to hold the stdout at the time the\nregrtest began.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.refcount_test()", "path": "library/test#test.support.refcount_test", "type": "Development Tools", "text": "\nDecorator for tests which involve reference counting. The decorator does not\nrun the test if it is not run by CPython. Any trace function is unset for the\nduration of the test to prevent unexpected refcounts caused by the trace\nfunction.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.requires()", "path": "library/test#test.support.requires", "type": "Development Tools", "text": "\nRaise `ResourceDenied` if resource is not available. msg is the argument to\n`ResourceDenied` if it is raised. Always returns `True` if called by a\nfunction whose `__name__` is `'__main__'`. Used when tests are executed by\n`test.regrtest`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.requires_bz2()", "path": "library/test#test.support.requires_bz2", "type": "Development Tools", "text": "\nDecorator for skipping tests if `bz2` doesn\u2019t exist.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.requires_docstrings()", "path": "library/test#test.support.requires_docstrings", "type": "Development Tools", "text": "\nDecorator for only running the test if `HAVE_DOCSTRINGS`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.requires_freebsd_version()", "path": "library/test#test.support.requires_freebsd_version", "type": "Development Tools", "text": "\nDecorator for the minimum version when running test on FreeBSD. If the FreeBSD\nversion is less than the minimum, raise `unittest.SkipTest`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.requires_gzip()", "path": "library/test#test.support.requires_gzip", "type": "Development Tools", "text": "\nDecorator for skipping tests if `gzip` doesn\u2019t exist.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.requires_IEEE_754()", "path": "library/test#test.support.requires_IEEE_754", "type": "Development Tools", "text": "\nDecorator for skipping tests on non-IEEE 754 platforms.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.requires_linux_version()", "path": "library/test#test.support.requires_linux_version", "type": "Development Tools", "text": "\nDecorator for the minimum version when running test on Linux. If the Linux\nversion is less than the minimum, raise `unittest.SkipTest`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.requires_lzma()", "path": "library/test#test.support.requires_lzma", "type": "Development Tools", "text": "\nDecorator for skipping tests if `lzma` doesn\u2019t exist.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.requires_mac_version()", "path": "library/test#test.support.requires_mac_version", "type": "Development Tools", "text": "\nDecorator for the minimum version when running test on Mac OS X. If the MAC OS\nX version is less than the minimum, raise `unittest.SkipTest`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.requires_resource()", "path": "library/test#test.support.requires_resource", "type": "Development Tools", "text": "\nDecorator for skipping tests if resource is not available.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.requires_zlib()", "path": "library/test#test.support.requires_zlib", "type": "Development Tools", "text": "\nDecorator for skipping tests if `zlib` doesn\u2019t exist.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.ResourceDenied", "path": "library/test#test.support.ResourceDenied", "type": "Development Tools", "text": "\nSubclass of `unittest.SkipTest`. Raised when a resource (such as a network\nconnection) is not available. Raised by the `requires()` function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.rmdir()", "path": "library/test#test.support.rmdir", "type": "Development Tools", "text": "\nCall `os.rmdir()` on filename. On Windows platforms, this is wrapped with a\nwait loop that checks for the existence of the file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.rmtree()", "path": "library/test#test.support.rmtree", "type": "Development Tools", "text": "\nCall `shutil.rmtree()` on path or call `os.lstat()` and `os.rmdir()` to remove\na path and its contents. On Windows platforms, this is wrapped with a wait\nloop that checks for the existence of the files.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.run_doctest()", "path": "library/test#test.support.run_doctest", "type": "Development Tools", "text": "\nRun `doctest.testmod()` on the given module. Return `(failure_count,\ntest_count)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.run_in_subinterp()", "path": "library/test#test.support.run_in_subinterp", "type": "Development Tools", "text": "\nRun code in subinterpreter. Raise `unittest.SkipTest` if `tracemalloc` is\nenabled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.run_unittest()", "path": "library/test#test.support.run_unittest", "type": "Development Tools", "text": "\nExecute `unittest.TestCase` subclasses passed to the function. The function\nscans the classes for methods starting with the prefix `test_` and executes\nthe tests individually.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.run_with_locale()", "path": "library/test#test.support.run_with_locale", "type": "Development Tools", "text": "\nA decorator for running a function in a different locale, correctly resetting\nit after it has finished. catstr is the locale category as a string (for\nexample `\"LC_ALL\"`). The locales passed will be tried sequentially, and the\nfirst valid locale will be used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.run_with_tz()", "path": "library/test#test.support.run_with_tz", "type": "Development Tools", "text": "\nA decorator for running a function in a specific timezone, correctly resetting\nit after it has finished.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.SAVEDCWD", "path": "library/test#test.support.SAVEDCWD", "type": "Development Tools", "text": "\nSet to `os.getcwd()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.SaveSignals", "path": "library/test#test.support.SaveSignals", "type": "Development Tools", "text": "\nClass to save and restore signal handlers registered by the Python signal\nhandler.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.script_helper.assert_python_failure()", "path": "library/test#test.support.script_helper.assert_python_failure", "type": "Development Tools", "text": "\nAssert that running the interpreter with args and optional environment\nvariables env_vars fails (`rc != 0`) and return a `(return code, stdout,\nstderr)` tuple.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.script_helper.assert_python_ok()", "path": "library/test#test.support.script_helper.assert_python_ok", "type": "Development Tools", "text": "\nAssert that running the interpreter with args and optional environment\nvariables env_vars succeeds (`rc == 0`) and return a `(return code, stdout,\nstderr)` tuple.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.script_helper.interpreter_requires_environment()", "path": "library/test#test.support.script_helper.interpreter_requires_environment", "type": "Development Tools", "text": "\nReturn `True` if `sys.executable interpreter` requires environment variables\nin order to be able to run at all.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.script_helper.kill_python()", "path": "library/test#test.support.script_helper.kill_python", "type": "Development Tools", "text": "\nRun the given `subprocess.Popen` process until completion and return stdout.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.script_helper.make_pkg()", "path": "library/test#test.support.script_helper.make_pkg", "type": "Development Tools", "text": "\nCreate a directory named pkg_dir containing an `__init__` file with\ninit_source as its contents.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.script_helper.make_script()", "path": "library/test#test.support.script_helper.make_script", "type": "Development Tools", "text": "\nCreate script containing source in path script_dir and script_basename. If\nomit_suffix is `False`, append `.py` to the name. Return the full script path.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.script_helper.make_zip_pkg()", "path": "library/test#test.support.script_helper.make_zip_pkg", "type": "Development Tools", "text": "\nCreate a zip package directory with a path of zip_dir and zip_basename\ncontaining an empty `__init__` file and a file script_basename containing the\nsource. If compiled is `True`, both source files will be compiled and added to\nthe zip package. Return a tuple of the full zip path and the archive name for\nthe zip file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.script_helper.make_zip_script()", "path": "library/test#test.support.script_helper.make_zip_script", "type": "Development Tools", "text": "\nCreate zip file at zip_dir and zip_basename with extension `zip` which\ncontains the files in script_name. name_in_zip is the archive name. Return a\ntuple containing `(full path, full path of archive name)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.script_helper.run_python_until_end()", "path": "library/test#test.support.script_helper.run_python_until_end", "type": "Development Tools", "text": "\nSet up the environment based on env_vars for running the interpreter in a\nsubprocess. The values can include `__isolated`, `__cleanenv`, `__cwd`, and\n`TERM`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.script_helper.spawn_python()", "path": "library/test#test.support.script_helper.spawn_python", "type": "Development Tools", "text": "\nRun a Python subprocess with the given arguments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.setswitchinterval()", "path": "library/test#test.support.setswitchinterval", "type": "Development Tools", "text": "\nSet the `sys.setswitchinterval()` to the given interval. Defines a minimum\ninterval for Android systems to prevent the system from hanging.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.set_match_tests()", "path": "library/test#test.support.set_match_tests", "type": "Development Tools", "text": "\nDefine match test with regular expression patterns.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.set_memlimit()", "path": "library/test#test.support.set_memlimit", "type": "Development Tools", "text": "\nSet the values for `max_memuse` and `real_max_memuse` for big memory tests.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.SHORT_TIMEOUT", "path": "library/test#test.support.SHORT_TIMEOUT", "type": "Development Tools", "text": "\nTimeout in seconds to mark a test as failed if the test takes \u201ctoo long\u201d.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.skip_unless_symlink()", "path": "library/test#test.support.skip_unless_symlink", "type": "Development Tools", "text": "\nA decorator for running tests that require support for symbolic links.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.skip_unless_xattr()", "path": "library/test#test.support.skip_unless_xattr", "type": "Development Tools", "text": "\nA decorator for running tests that require support for xattr.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.SMALLEST", "path": "library/test#test.support.SMALLEST", "type": "Development Tools", "text": "\nObject that is less than anything (except itself). Used to test mixed type\ncomparison.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.socket_helper.bind_port()", "path": "library/test#test.support.socket_helper.bind_port", "type": "Development Tools", "text": "\nBind the socket to a free port and return the port number. Relies on ephemeral\nports in order to ensure we are using an unbound port. This is important as\nmany tests may be running simultaneously, especially in a buildbot\nenvironment. This method raises an exception if the `sock.family` is `AF_INET`\nand `sock.type` is `SOCK_STREAM`, and the socket has `SO_REUSEADDR` or\n`SO_REUSEPORT` set on it. Tests should never set these socket options for\nTCP/IP sockets. The only case for setting these options is testing\nmulticasting via multiple UDP sockets.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.socket_helper.bind_unix_socket()", "path": "library/test#test.support.socket_helper.bind_unix_socket", "type": "Development Tools", "text": "\nBind a unix socket, raising `unittest.SkipTest` if `PermissionError` is\nraised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.socket_helper.find_unused_port()", "path": "library/test#test.support.socket_helper.find_unused_port", "type": "Development Tools", "text": "\nReturns an unused port that should be suitable for binding. This is achieved\nby creating a temporary socket with the same family and type as the `sock`\nparameter (default is `AF_INET`, `SOCK_STREAM`), and binding it to the\nspecified host address (defaults to `0.0.0.0`) with the port set to 0,\neliciting an unused ephemeral port from the OS. The temporary socket is then\nclosed and deleted, and the ephemeral port is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.socket_helper.IPV6_ENABLED", "path": "library/test#test.support.socket_helper.IPV6_ENABLED", "type": "Development Tools", "text": "\nSet to `True` if IPv6 is enabled on this host, `False` otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.socket_helper.skip_unless_bind_unix_socket()", "path": "library/test#test.support.socket_helper.skip_unless_bind_unix_socket", "type": "Development Tools", "text": "\nA decorator for running tests that require a functional `bind()` for Unix\nsockets.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.socket_helper.transient_internet()", "path": "library/test#test.support.socket_helper.transient_internet", "type": "Development Tools", "text": "\nA context manager that raises `ResourceDenied` when various issues with the\ninternet connection manifest themselves as exceptions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.SOCK_MAX_SIZE", "path": "library/test#test.support.SOCK_MAX_SIZE", "type": "Development Tools", "text": "\nA constant that is likely larger than the underlying OS socket buffer size, to\nmake writes blocking.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.sortdict()", "path": "library/test#test.support.sortdict", "type": "Development Tools", "text": "\nReturn a repr of dict with keys sorted.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.start_threads()", "path": "library/test#test.support.start_threads", "type": "Development Tools", "text": "\nContext manager to start threads. It attempts to join the threads upon exit.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.SuppressCrashReport", "path": "library/test#test.support.SuppressCrashReport", "type": "Development Tools", "text": "\nA context manager used to try to prevent crash dialog popups on tests that are\nexpected to crash a subprocess.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.swap_attr()", "path": "library/test#test.support.swap_attr", "type": "Development Tools", "text": "\nContext manager to swap out an attribute with a new object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.swap_item()", "path": "library/test#test.support.swap_item", "type": "Development Tools", "text": "\nContext manager to swap out an item with a new object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.system_must_validate_cert()", "path": "library/test#test.support.system_must_validate_cert", "type": "Development Tools", "text": "\nRaise `unittest.SkipTest` on TLS certification validation failures.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.temp_cwd()", "path": "library/test#test.support.temp_cwd", "type": "Development Tools", "text": "\nA context manager that temporarily creates a new directory and changes the\ncurrent working directory (CWD).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.temp_dir()", "path": "library/test#test.support.temp_dir", "type": "Development Tools", "text": "\nA context manager that creates a temporary directory at path and yields the\ndirectory.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.temp_umask()", "path": "library/test#test.support.temp_umask", "type": "Development Tools", "text": "\nA context manager that temporarily sets the process umask.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.TestFailed", "path": "library/test#test.support.TestFailed", "type": "Development Tools", "text": "\nException to be raised when a test fails. This is deprecated in favor of\n`unittest`-based tests and `unittest.TestCase`\u2019s assertion methods.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.TESTFN", "path": "library/test#test.support.TESTFN", "type": "Development Tools", "text": "\nSet to a name that is safe to use as the name of a temporary file. Any\ntemporary file that is created should be closed and unlinked (removed).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.TESTFN_ENCODING", "path": "library/test#test.support.TESTFN_ENCODING", "type": "Development Tools", "text": "\nSet to `sys.getfilesystemencoding()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.TESTFN_NONASCII", "path": "library/test#test.support.TESTFN_NONASCII", "type": "Development Tools", "text": "\nSet to a filename containing the `FS_NONASCII` character.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.TESTFN_UNDECODABLE", "path": "library/test#test.support.TESTFN_UNDECODABLE", "type": "Development Tools", "text": "\nSet to a filename (bytes type) that should not be able to be decoded by file\nsystem encoding in strict mode. It may be `None` if it\u2019s not possible to\ngenerate such a filename.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.TESTFN_UNENCODABLE", "path": "library/test#test.support.TESTFN_UNENCODABLE", "type": "Development Tools", "text": "\nSet to a filename (str type) that should not be able to be encoded by file\nsystem encoding in strict mode. It may be `None` if it\u2019s not possible to\ngenerate such a filename.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.TESTFN_UNICODE", "path": "library/test#test.support.TESTFN_UNICODE", "type": "Development Tools", "text": "\nSet to a non-ASCII name for a temporary file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.TEST_DATA_DIR", "path": "library/test#test.support.TEST_DATA_DIR", "type": "Development Tools", "text": "\nSet to the `data` directory within the test package.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.TEST_HOME_DIR", "path": "library/test#test.support.TEST_HOME_DIR", "type": "Development Tools", "text": "\nSet to the top level directory for the test package.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.TEST_HTTP_URL", "path": "library/test#test.support.TEST_HTTP_URL", "type": "Development Tools", "text": "\nDefine the URL of a dedicated HTTP server for the network tests.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.TEST_SUPPORT_DIR", "path": "library/test#test.support.TEST_SUPPORT_DIR", "type": "Development Tools", "text": "\nSet to the top level directory that contains `test.support`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.threading_cleanup()", "path": "library/test#test.support.threading_cleanup", "type": "Development Tools", "text": "\nCleanup up threads not specified in original_values. Designed to emit a\nwarning if a test leaves running threads in the background.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.threading_setup()", "path": "library/test#test.support.threading_setup", "type": "Development Tools", "text": "\nReturn current thread count and copy of dangling threads.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.TransientResource", "path": "library/test#test.support.TransientResource", "type": "Development Tools", "text": "\nInstances are a context manager that raises `ResourceDenied` if the specified\nexception type is raised. Any keyword arguments are treated as attribute/value\npairs to be compared against any exception raised within the `with` statement.\nOnly if all pairs match properly against attributes on the exception is\n`ResourceDenied` raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.unix_shell", "path": "library/test#test.support.unix_shell", "type": "Development Tools", "text": "\nPath for shell if not on Windows; otherwise `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.unlink()", "path": "library/test#test.support.unlink", "type": "Development Tools", "text": "\nCall `os.unlink()` on filename. On Windows platforms, this is wrapped with a\nwait loop that checks for the existence fo the file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.unload()", "path": "library/test#test.support.unload", "type": "Development Tools", "text": "\nDelete name from `sys.modules`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.verbose", "path": "library/test#test.support.verbose", "type": "Development Tools", "text": "\n`True` when verbose output is enabled. Should be checked when more detailed\ninformation is desired about a running test. verbose is set by\n`test.regrtest`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.wait_process()", "path": "library/test#test.support.wait_process", "type": "Development Tools", "text": "\nWait until process pid completes and check that the process exit code is\nexitcode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.wait_threads_exit()", "path": "library/test#test.support.wait_threads_exit", "type": "Development Tools", "text": "\nContext manager to wait until all threads created in the `with` statement\nexit.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.WarningsRecorder", "path": "library/test#test.support.WarningsRecorder", "type": "Development Tools", "text": "\nClass used to record warnings for unit tests. See documentation of\n`check_warnings()` above for more details.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test.support.with_pymalloc()", "path": "library/test#test.support.with_pymalloc", "type": "Development Tools", "text": "\nReturn `_testcapi.WITH_PYMALLOC`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "textwrap", "path": "library/textwrap", "type": "Text Processing", "text": "\nSource code: Lib/textwrap.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "textwrap.dedent()", "path": "library/textwrap#textwrap.dedent", "type": "Text Processing", "text": "\nRemove any common leading whitespace from every line in text.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "textwrap.fill()", "path": "library/textwrap#textwrap.fill", "type": "Text Processing", "text": "\nWraps the single paragraph in text, and returns a single string containing the\nwrapped paragraph. `fill()` is shorthand for\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "textwrap.indent()", "path": "library/textwrap#textwrap.indent", "type": "Text Processing", "text": "\nAdd prefix to the beginning of selected lines in text.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "textwrap.shorten()", "path": "library/textwrap#textwrap.shorten", "type": "Text Processing", "text": "\nCollapse and truncate the given text to fit in the given width.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "textwrap.TextWrapper", "path": "library/textwrap#textwrap.TextWrapper", "type": "Text Processing", "text": "\nThe `TextWrapper` constructor accepts a number of optional keyword arguments.\nEach keyword argument corresponds to an instance attribute, so for example\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "textwrap.TextWrapper.break_long_words", "path": "library/textwrap#textwrap.TextWrapper.break_long_words", "type": "Text Processing", "text": "\n(default: `True`) If true, then words longer than `width` will be broken in\norder to ensure that no lines are longer than `width`. If it is false, long\nwords will not be broken, and some lines may be longer than `width`. (Long\nwords will be put on a line by themselves, in order to minimize the amount by\nwhich `width` is exceeded.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "textwrap.TextWrapper.break_on_hyphens", "path": "library/textwrap#textwrap.TextWrapper.break_on_hyphens", "type": "Text Processing", "text": "\n(default: `True`) If true, wrapping will occur preferably on whitespaces and\nright after hyphens in compound words, as it is customary in English. If\nfalse, only whitespaces will be considered as potentially good places for line\nbreaks, but you need to set `break_long_words` to false if you want truly\ninsecable words. Default behaviour in previous versions was to always allow\nbreaking hyphenated words.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "textwrap.TextWrapper.drop_whitespace", "path": "library/textwrap#textwrap.TextWrapper.drop_whitespace", "type": "Text Processing", "text": "\n(default: `True`) If true, whitespace at the beginning and ending of every\nline (after wrapping but before indenting) is dropped. Whitespace at the\nbeginning of the paragraph, however, is not dropped if non-whitespace follows\nit. If whitespace being dropped takes up an entire line, the whole line is\ndropped.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "textwrap.TextWrapper.expand_tabs", "path": "library/textwrap#textwrap.TextWrapper.expand_tabs", "type": "Text Processing", "text": "\n(default: `True`) If true, then all tab characters in text will be expanded to\nspaces using the `expandtabs()` method of text.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "textwrap.TextWrapper.fill()", "path": "library/textwrap#textwrap.TextWrapper.fill", "type": "Text Processing", "text": "\nWraps the single paragraph in text, and returns a single string containing the\nwrapped paragraph.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "textwrap.TextWrapper.fix_sentence_endings", "path": "library/textwrap#textwrap.TextWrapper.fix_sentence_endings", "type": "Text Processing", "text": "\n(default: `False`) If true, `TextWrapper` attempts to detect sentence endings\nand ensure that sentences are always separated by exactly two spaces. This is\ngenerally desired for text in a monospaced font. However, the sentence\ndetection algorithm is imperfect: it assumes that a sentence ending consists\nof a lowercase letter followed by one of `'.'`, `'!'`, or `'?'`, possibly\nfollowed by one of `'\"'` or `\"'\"`, followed by a space. One problem with this\nis algorithm is that it is unable to detect the difference between \u201cDr.\u201d in\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "textwrap.TextWrapper.initial_indent", "path": "library/textwrap#textwrap.TextWrapper.initial_indent", "type": "Text Processing", "text": "\n(default: `''`) String that will be prepended to the first line of wrapped\noutput. Counts towards the length of the first line. The empty string is not\nindented.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "textwrap.TextWrapper.max_lines", "path": "library/textwrap#textwrap.TextWrapper.max_lines", "type": "Text Processing", "text": "\n(default: `None`) If not `None`, then the output will contain at most\nmax_lines lines, with placeholder appearing at the end of the output.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "textwrap.TextWrapper.placeholder", "path": "library/textwrap#textwrap.TextWrapper.placeholder", "type": "Text Processing", "text": "\n(default: `' [...]'`) String that will appear at the end of the output text if\nit has been truncated.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "textwrap.TextWrapper.replace_whitespace", "path": "library/textwrap#textwrap.TextWrapper.replace_whitespace", "type": "Text Processing", "text": "\n(default: `True`) If true, after tab expansion but before wrapping, the\n`wrap()` method will replace each whitespace character with a single space.\nThe whitespace characters replaced are as follows: tab, newline, vertical tab,\nformfeed, and carriage return (`'\\t\\n\\v\\f\\r'`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "textwrap.TextWrapper.subsequent_indent", "path": "library/textwrap#textwrap.TextWrapper.subsequent_indent", "type": "Text Processing", "text": "\n(default: `''`) String that will be prepended to all lines of wrapped output\nexcept the first. Counts towards the length of each line except the first.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "textwrap.TextWrapper.tabsize", "path": "library/textwrap#textwrap.TextWrapper.tabsize", "type": "Text Processing", "text": "\n(default: `8`) If `expand_tabs` is true, then all tab characters in text will\nbe expanded to zero or more spaces, depending on the current column and the\ngiven tab size.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "textwrap.TextWrapper.width", "path": "library/textwrap#textwrap.TextWrapper.width", "type": "Text Processing", "text": "\n(default: `70`) The maximum length of wrapped lines. As long as there are no\nindividual words in the input text longer than `width`, `TextWrapper`\nguarantees that no output line will be longer than `width` characters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "textwrap.TextWrapper.wrap()", "path": "library/textwrap#textwrap.TextWrapper.wrap", "type": "Text Processing", "text": "\nWraps the single paragraph in text (a string) so every line is at most `width`\ncharacters long. All wrapping options are taken from instance attributes of\nthe `TextWrapper` instance. Returns a list of output lines, without final\nnewlines. If the wrapped output has no content, the returned list is empty.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "textwrap.wrap()", "path": "library/textwrap#textwrap.wrap", "type": "Text Processing", "text": "\nWraps the single paragraph in text (a string) so every line is at most width\ncharacters long. Returns a list of output lines, without final newlines.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "The concurrent package", "path": "library/concurrent", "type": "Concurrent Execution", "text": "\nCurrently, there is only one module in this package:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "The Python Profilers", "path": "library/profile", "type": "Debugging & Profiling", "text": "\nSource code: Lib/profile.py and Lib/pstats.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading", "path": "library/threading", "type": "Concurrent Execution", "text": "\nSource code: Lib/threading.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.active_count()", "path": "library/threading#threading.active_count", "type": "Concurrent Execution", "text": "\nReturn the number of `Thread` objects currently alive. The returned count is\nequal to the length of the list returned by `enumerate()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.Barrier", "path": "library/threading#threading.Barrier", "type": "Concurrent Execution", "text": "\nCreate a barrier object for parties number of threads. An action, when\nprovided, is a callable to be called by one of the threads when they are\nreleased. timeout is the default timeout value if none is specified for the\n`wait()` method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.Barrier.abort()", "path": "library/threading#threading.Barrier.abort", "type": "Concurrent Execution", "text": "\nPut the barrier into a broken state. This causes any active or future calls to\n`wait()` to fail with the `BrokenBarrierError`. Use this for example if one of\nthe threads needs to abort, to avoid deadlocking the application.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.Barrier.broken", "path": "library/threading#threading.Barrier.broken", "type": "Concurrent Execution", "text": "\nA boolean that is `True` if the barrier is in the broken state.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.Barrier.n_waiting", "path": "library/threading#threading.Barrier.n_waiting", "type": "Concurrent Execution", "text": "\nThe number of threads currently waiting in the barrier.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.Barrier.parties", "path": "library/threading#threading.Barrier.parties", "type": "Concurrent Execution", "text": "\nThe number of threads required to pass the barrier.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.Barrier.reset()", "path": "library/threading#threading.Barrier.reset", "type": "Concurrent Execution", "text": "\nReturn the barrier to the default, empty state. Any threads waiting on it will\nreceive the `BrokenBarrierError` exception.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.Barrier.wait()", "path": "library/threading#threading.Barrier.wait", "type": "Concurrent Execution", "text": "\nPass the barrier. When all the threads party to the barrier have called this\nfunction, they are all released simultaneously. If a timeout is provided, it\nis used in preference to any that was supplied to the class constructor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.BoundedSemaphore", "path": "library/threading#threading.BoundedSemaphore", "type": "Concurrent Execution", "text": "\nClass implementing bounded semaphore objects. A bounded semaphore checks to\nmake sure its current value doesn\u2019t exceed its initial value. If it does,\n`ValueError` is raised. In most situations semaphores are used to guard\nresources with limited capacity. If the semaphore is released too many times\nit\u2019s a sign of a bug. If not given, value defaults to 1.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.BrokenBarrierError", "path": "library/threading#threading.BrokenBarrierError", "type": "Concurrent Execution", "text": "\nThis exception, a subclass of `RuntimeError`, is raised when the `Barrier`\nobject is reset or broken.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.Condition", "path": "library/threading#threading.Condition", "type": "Concurrent Execution", "text": "\nThis class implements condition variable objects. A condition variable allows\none or more threads to wait until they are notified by another thread.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.Condition.acquire()", "path": "library/threading#threading.Condition.acquire", "type": "Concurrent Execution", "text": "\nAcquire the underlying lock. This method calls the corresponding method on the\nunderlying lock; the return value is whatever that method returns.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.Condition.notify()", "path": "library/threading#threading.Condition.notify", "type": "Concurrent Execution", "text": "\nBy default, wake up one thread waiting on this condition, if any. If the\ncalling thread has not acquired the lock when this method is called, a\n`RuntimeError` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.Condition.notify_all()", "path": "library/threading#threading.Condition.notify_all", "type": "Concurrent Execution", "text": "\nWake up all threads waiting on this condition. This method acts like\n`notify()`, but wakes up all waiting threads instead of one. If the calling\nthread has not acquired the lock when this method is called, a `RuntimeError`\nis raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.Condition.release()", "path": "library/threading#threading.Condition.release", "type": "Concurrent Execution", "text": "\nRelease the underlying lock. This method calls the corresponding method on the\nunderlying lock; there is no return value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.Condition.wait()", "path": "library/threading#threading.Condition.wait", "type": "Concurrent Execution", "text": "\nWait until notified or until a timeout occurs. If the calling thread has not\nacquired the lock when this method is called, a `RuntimeError` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.Condition.wait_for()", "path": "library/threading#threading.Condition.wait_for", "type": "Concurrent Execution", "text": "\nWait until a condition evaluates to true. predicate should be a callable which\nresult will be interpreted as a boolean value. A timeout may be provided\ngiving the maximum time to wait.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.current_thread()", "path": "library/threading#threading.current_thread", "type": "Concurrent Execution", "text": "\nReturn the current `Thread` object, corresponding to the caller\u2019s thread of\ncontrol. If the caller\u2019s thread of control was not created through the\n`threading` module, a dummy thread object with limited functionality is\nreturned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.enumerate()", "path": "library/threading#threading.enumerate", "type": "Concurrent Execution", "text": "\nReturn a list of all `Thread` objects currently alive. The list includes\ndaemonic threads, dummy thread objects created by `current_thread()`, and the\nmain thread. It excludes terminated threads and threads that have not yet been\nstarted.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.Event", "path": "library/threading#threading.Event", "type": "Concurrent Execution", "text": "\nClass implementing event objects. An event manages a flag that can be set to\ntrue with the `set()` method and reset to false with the `clear()` method. The\n`wait()` method blocks until the flag is true. The flag is initially false.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.Event.clear()", "path": "library/threading#threading.Event.clear", "type": "Concurrent Execution", "text": "\nReset the internal flag to false. Subsequently, threads calling `wait()` will\nblock until `set()` is called to set the internal flag to true again.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.Event.is_set()", "path": "library/threading#threading.Event.is_set", "type": "Concurrent Execution", "text": "\nReturn `True` if and only if the internal flag is true.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.Event.set()", "path": "library/threading#threading.Event.set", "type": "Concurrent Execution", "text": "\nSet the internal flag to true. All threads waiting for it to become true are\nawakened. Threads that call `wait()` once the flag is true will not block at\nall.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.Event.wait()", "path": "library/threading#threading.Event.wait", "type": "Concurrent Execution", "text": "\nBlock until the internal flag is true. If the internal flag is true on entry,\nreturn immediately. Otherwise, block until another thread calls `set()` to set\nthe flag to true, or until the optional timeout occurs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.excepthook()", "path": "library/threading#threading.excepthook", "type": "Concurrent Execution", "text": "\nHandle uncaught exception raised by `Thread.run()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.get_ident()", "path": "library/threading#threading.get_ident", "type": "Concurrent Execution", "text": "\nReturn the \u2018thread identifier\u2019 of the current thread. This is a nonzero\ninteger. Its value has no direct meaning; it is intended as a magic cookie to\nbe used e.g. to index a dictionary of thread-specific data. Thread identifiers\nmay be recycled when a thread exits and another thread is created.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.get_native_id()", "path": "library/threading#threading.get_native_id", "type": "Concurrent Execution", "text": "\nReturn the native integral Thread ID of the current thread assigned by the\nkernel. This is a non-negative integer. Its value may be used to uniquely\nidentify this particular thread system-wide (until the thread terminates,\nafter which the value may be recycled by the OS).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.local", "path": "library/threading#threading.local", "type": "Concurrent Execution", "text": "\nA class that represents thread-local data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.Lock", "path": "library/threading#threading.Lock", "type": "Concurrent Execution", "text": "\nThe class implementing primitive lock objects. Once a thread has acquired a\nlock, subsequent attempts to acquire it block, until it is released; any\nthread may release it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.Lock.acquire()", "path": "library/threading#threading.Lock.acquire", "type": "Concurrent Execution", "text": "\nAcquire a lock, blocking or non-blocking.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.Lock.locked()", "path": "library/threading#threading.Lock.locked", "type": "Concurrent Execution", "text": "\nReturn true if the lock is acquired.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.Lock.release()", "path": "library/threading#threading.Lock.release", "type": "Concurrent Execution", "text": "\nRelease a lock. This can be called from any thread, not only the thread which\nhas acquired the lock.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.main_thread()", "path": "library/threading#threading.main_thread", "type": "Concurrent Execution", "text": "\nReturn the main `Thread` object. In normal conditions, the main thread is the\nthread from which the Python interpreter was started.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.RLock", "path": "library/threading#threading.RLock", "type": "Concurrent Execution", "text": "\nThis class implements reentrant lock objects. A reentrant lock must be\nreleased by the thread that acquired it. Once a thread has acquired a\nreentrant lock, the same thread may acquire it again without blocking; the\nthread must release it once for each time it has acquired it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.RLock.acquire()", "path": "library/threading#threading.RLock.acquire", "type": "Concurrent Execution", "text": "\nAcquire a lock, blocking or non-blocking.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.RLock.release()", "path": "library/threading#threading.RLock.release", "type": "Concurrent Execution", "text": "\nRelease a lock, decrementing the recursion level. If after the decrement it is\nzero, reset the lock to unlocked (not owned by any thread), and if any other\nthreads are blocked waiting for the lock to become unlocked, allow exactly one\nof them to proceed. If after the decrement the recursion level is still\nnonzero, the lock remains locked and owned by the calling thread.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.Semaphore", "path": "library/threading#threading.Semaphore", "type": "Concurrent Execution", "text": "\nThis class implements semaphore objects. A semaphore manages an atomic counter\nrepresenting the number of `release()` calls minus the number of `acquire()`\ncalls, plus an initial value. The `acquire()` method blocks if necessary until\nit can return without making the counter negative. If not given, value\ndefaults to 1.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.Semaphore.acquire()", "path": "library/threading#threading.Semaphore.acquire", "type": "Concurrent Execution", "text": "\nAcquire a semaphore.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.Semaphore.release()", "path": "library/threading#threading.Semaphore.release", "type": "Concurrent Execution", "text": "\nRelease a semaphore, incrementing the internal counter by n. When it was zero\non entry and other threads are waiting for it to become larger than zero\nagain, wake up n of those threads.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.setprofile()", "path": "library/threading#threading.setprofile", "type": "Concurrent Execution", "text": "\nSet a profile function for all threads started from the `threading` module.\nThe func will be passed to `sys.setprofile()` for each thread, before its\n`run()` method is called.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.settrace()", "path": "library/threading#threading.settrace", "type": "Concurrent Execution", "text": "\nSet a trace function for all threads started from the `threading` module. The\nfunc will be passed to `sys.settrace()` for each thread, before its `run()`\nmethod is called.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.stack_size()", "path": "library/threading#threading.stack_size", "type": "Concurrent Execution", "text": "\nReturn the thread stack size used when creating new threads. The optional size\nargument specifies the stack size to be used for subsequently created threads,\nand must be 0 (use platform or configured default) or a positive integer value\nof at least 32,768 (32 KiB). If size is not specified, 0 is used. If changing\nthe thread stack size is unsupported, a `RuntimeError` is raised. If the\nspecified stack size is invalid, a `ValueError` is raised and the stack size\nis unmodified. 32 KiB is currently the minimum supported stack size value to\nguarantee sufficient stack space for the interpreter itself. Note that some\nplatforms may have particular restrictions on values for the stack size, such\nas requiring a minimum stack size > 32 KiB or requiring allocation in\nmultiples of the system memory page size - platform documentation should be\nreferred to for more information (4 KiB pages are common; using multiples of\n4096 for the stack size is the suggested approach in the absence of more\nspecific information).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.Thread", "path": "library/threading#threading.Thread", "type": "Concurrent Execution", "text": "\nThis constructor should always be called with keyword arguments. Arguments\nare:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.Thread.daemon", "path": "library/threading#threading.Thread.daemon", "type": "Concurrent Execution", "text": "\nA boolean value indicating whether this thread is a daemon thread (True) or\nnot (False). This must be set before `start()` is called, otherwise\n`RuntimeError` is raised. Its initial value is inherited from the creating\nthread; the main thread is not a daemon thread and therefore all threads\ncreated in the main thread default to `daemon` = `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.Thread.getName()", "path": "library/threading#threading.Thread.getName", "type": "Concurrent Execution", "text": "\nOld getter/setter API for `name`; use it directly as a property instead.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.Thread.ident", "path": "library/threading#threading.Thread.ident", "type": "Concurrent Execution", "text": "\nThe \u2018thread identifier\u2019 of this thread or `None` if the thread has not been\nstarted. This is a nonzero integer. See the `get_ident()` function. Thread\nidentifiers may be recycled when a thread exits and another thread is created.\nThe identifier is available even after the thread has exited.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.Thread.isDaemon()", "path": "library/threading#threading.Thread.isDaemon", "type": "Concurrent Execution", "text": "\nOld getter/setter API for `daemon`; use it directly as a property instead.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.Thread.is_alive()", "path": "library/threading#threading.Thread.is_alive", "type": "Concurrent Execution", "text": "\nReturn whether the thread is alive.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.Thread.join()", "path": "library/threading#threading.Thread.join", "type": "Concurrent Execution", "text": "\nWait until the thread terminates. This blocks the calling thread until the\nthread whose `join()` method is called terminates \u2013 either normally or through\nan unhandled exception \u2013 or until the optional timeout occurs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.Thread.name", "path": "library/threading#threading.Thread.name", "type": "Concurrent Execution", "text": "\nA string used for identification purposes only. It has no semantics. Multiple\nthreads may be given the same name. The initial name is set by the\nconstructor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.Thread.native_id", "path": "library/threading#threading.Thread.native_id", "type": "Concurrent Execution", "text": "\nThe native integral thread ID of this thread. This is a non-negative integer,\nor `None` if the thread has not been started. See the `get_native_id()`\nfunction. This represents the Thread ID (`TID`) as assigned to the thread by\nthe OS (kernel). Its value may be used to uniquely identify this particular\nthread system-wide (until the thread terminates, after which the value may be\nrecycled by the OS).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.Thread.run()", "path": "library/threading#threading.Thread.run", "type": "Concurrent Execution", "text": "\nMethod representing the thread\u2019s activity.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.Thread.setDaemon()", "path": "library/threading#threading.Thread.setDaemon", "type": "Concurrent Execution", "text": "\nOld getter/setter API for `daemon`; use it directly as a property instead.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.Thread.setName()", "path": "library/threading#threading.Thread.setName", "type": "Concurrent Execution", "text": "\nOld getter/setter API for `name`; use it directly as a property instead.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.Thread.start()", "path": "library/threading#threading.Thread.start", "type": "Concurrent Execution", "text": "\nStart the thread\u2019s activity.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.TIMEOUT_MAX", "path": "library/threading#threading.TIMEOUT_MAX", "type": "Concurrent Execution", "text": "\nThe maximum value allowed for the timeout parameter of blocking functions\n(`Lock.acquire()`, `RLock.acquire()`, `Condition.wait()`, etc.). Specifying a\ntimeout greater than this value will raise an `OverflowError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.Timer", "path": "library/threading#threading.Timer", "type": "Concurrent Execution", "text": "\nCreate a timer that will run function with arguments args and keyword\narguments kwargs, after interval seconds have passed. If args is `None` (the\ndefault) then an empty list will be used. If kwargs is `None` (the default)\nthen an empty dict will be used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "threading.Timer.cancel()", "path": "library/threading#threading.Timer.cancel", "type": "Concurrent Execution", "text": "\nStop the timer, and cancel the execution of the timer\u2019s action. This will only\nwork if the timer is still in its waiting stage.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "time", "path": "library/time", "type": "Operating System", "text": "\nThis module provides various time-related functions. For related\nfunctionality, see also the `datetime` and `calendar` modules.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "time.altzone", "path": "library/time#time.altzone", "type": "Operating System", "text": "\nThe offset of the local DST timezone, in seconds west of UTC, if one is\ndefined. This is negative if the local DST timezone is east of UTC (as in\nWestern Europe, including the UK). Only use this if `daylight` is nonzero. See\nnote below.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "time.asctime()", "path": "library/time#time.asctime", "type": "Operating System", "text": "\nConvert a tuple or `struct_time` representing a time as returned by `gmtime()`\nor `localtime()` to a string of the following form: `'Sun Jun 20 23:21:05\n1993'`. The day field is two characters long and is space padded if the day is\na single digit, e.g.: `'Wed Jun 9 04:26:40 1993'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "time.CLOCK_BOOTTIME", "path": "library/time#time.CLOCK_BOOTTIME", "type": "Operating System", "text": "\nIdentical to `CLOCK_MONOTONIC`, except it also includes any time that the\nsystem is suspended.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "time.clock_getres()", "path": "library/time#time.clock_getres", "type": "Operating System", "text": "\nReturn the resolution (precision) of the specified clock clk_id. Refer to\nClock ID Constants for a list of accepted values for clk_id.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "time.clock_gettime()", "path": "library/time#time.clock_gettime", "type": "Operating System", "text": "\nReturn the time of the specified clock clk_id. Refer to Clock ID Constants for\na list of accepted values for clk_id.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "time.clock_gettime_ns()", "path": "library/time#time.clock_gettime_ns", "type": "Operating System", "text": "\nSimilar to `clock_gettime()` but return time as nanoseconds.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "time.CLOCK_HIGHRES", "path": "library/time#time.CLOCK_HIGHRES", "type": "Operating System", "text": "\nThe Solaris OS has a `CLOCK_HIGHRES` timer that attempts to use an optimal\nhardware source, and may give close to nanosecond resolution. `CLOCK_HIGHRES`\nis the nonadjustable, high-resolution clock.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "time.CLOCK_MONOTONIC", "path": "library/time#time.CLOCK_MONOTONIC", "type": "Operating System", "text": "\nClock that cannot be set and represents monotonic time since some unspecified\nstarting point.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "time.CLOCK_MONOTONIC_RAW", "path": "library/time#time.CLOCK_MONOTONIC_RAW", "type": "Operating System", "text": "\nSimilar to `CLOCK_MONOTONIC`, but provides access to a raw hardware-based time\nthat is not subject to NTP adjustments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "time.CLOCK_PROCESS_CPUTIME_ID", "path": "library/time#time.CLOCK_PROCESS_CPUTIME_ID", "type": "Operating System", "text": "\nHigh-resolution per-process timer from the CPU.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "time.CLOCK_PROF", "path": "library/time#time.CLOCK_PROF", "type": "Operating System", "text": "\nHigh-resolution per-process timer from the CPU.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "time.CLOCK_REALTIME", "path": "library/time#time.CLOCK_REALTIME", "type": "Operating System", "text": "\nSystem-wide real-time clock. Setting this clock requires appropriate\nprivileges.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "time.clock_settime()", "path": "library/time#time.clock_settime", "type": "Operating System", "text": "\nSet the time of the specified clock clk_id. Currently, `CLOCK_REALTIME` is the\nonly accepted value for clk_id.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "time.clock_settime_ns()", "path": "library/time#time.clock_settime_ns", "type": "Operating System", "text": "\nSimilar to `clock_settime()` but set time with nanoseconds.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "time.CLOCK_TAI", "path": "library/time#time.CLOCK_TAI", "type": "Operating System", "text": "\nInternational Atomic Time\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "time.CLOCK_THREAD_CPUTIME_ID", "path": "library/time#time.CLOCK_THREAD_CPUTIME_ID", "type": "Operating System", "text": "\nThread-specific CPU-time clock.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "time.CLOCK_UPTIME", "path": "library/time#time.CLOCK_UPTIME", "type": "Operating System", "text": "\nTime whose absolute value is the time the system has been running and not\nsuspended, providing accurate uptime measurement, both absolute and interval.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "time.CLOCK_UPTIME_RAW", "path": "library/time#time.CLOCK_UPTIME_RAW", "type": "Operating System", "text": "\nClock that increments monotonically, tracking the time since an arbitrary\npoint, unaffected by frequency or time adjustments and not incremented while\nthe system is asleep.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "time.ctime()", "path": "library/time#time.ctime", "type": "Operating System", "text": "\nConvert a time expressed in seconds since the epoch to a string of a form:\n`'Sun Jun 20 23:21:05 1993'` representing local time. The day field is two\ncharacters long and is space padded if the day is a single digit, e.g.: `'Wed\nJun 9 04:26:40 1993'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "time.daylight", "path": "library/time#time.daylight", "type": "Operating System", "text": "\nNonzero if a DST timezone is defined. See note below.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "time.get_clock_info()", "path": "library/time#time.get_clock_info", "type": "Operating System", "text": "\nGet information on the specified clock as a namespace object. Supported clock\nnames and the corresponding functions to read their value are:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "time.gmtime()", "path": "library/time#time.gmtime", "type": "Operating System", "text": "\nConvert a time expressed in seconds since the epoch to a `struct_time` in UTC\nin which the dst flag is always zero. If secs is not provided or `None`, the\ncurrent time as returned by `time()` is used. Fractions of a second are\nignored. See above for a description of the `struct_time` object. See\n`calendar.timegm()` for the inverse of this function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "time.localtime()", "path": "library/time#time.localtime", "type": "Operating System", "text": "\nLike `gmtime()` but converts to local time. If secs is not provided or `None`,\nthe current time as returned by `time()` is used. The dst flag is set to `1`\nwhen DST applies to the given time.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "time.mktime()", "path": "library/time#time.mktime", "type": "Operating System", "text": "\nThis is the inverse function of `localtime()`. Its argument is the\n`struct_time` or full 9-tuple (since the dst flag is needed; use `-1` as the\ndst flag if it is unknown) which expresses the time in local time, not UTC. It\nreturns a floating point number, for compatibility with `time()`. If the input\nvalue cannot be represented as a valid time, either `OverflowError` or\n`ValueError` will be raised (which depends on whether the invalid value is\ncaught by Python or the underlying C libraries). The earliest date for which\nit can generate a time is platform-dependent.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "time.monotonic()", "path": "library/time#time.monotonic", "type": "Operating System", "text": "\nReturn the value (in fractional seconds) of a monotonic clock, i.e. a clock\nthat cannot go backwards. The clock is not affected by system clock updates.\nThe reference point of the returned value is undefined, so that only the\ndifference between the results of two calls is valid.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "time.monotonic_ns()", "path": "library/time#time.monotonic_ns", "type": "Operating System", "text": "\nSimilar to `monotonic()`, but return time as nanoseconds.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "time.perf_counter()", "path": "library/time#time.perf_counter", "type": "Operating System", "text": "\nReturn the value (in fractional seconds) of a performance counter, i.e. a\nclock with the highest available resolution to measure a short duration. It\ndoes include time elapsed during sleep and is system-wide. The reference point\nof the returned value is undefined, so that only the difference between the\nresults of two calls is valid.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "time.perf_counter_ns()", "path": "library/time#time.perf_counter_ns", "type": "Operating System", "text": "\nSimilar to `perf_counter()`, but return time as nanoseconds.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "time.process_time()", "path": "library/time#time.process_time", "type": "Operating System", "text": "\nReturn the value (in fractional seconds) of the sum of the system and user CPU\ntime of the current process. It does not include time elapsed during sleep. It\nis process-wide by definition. The reference point of the returned value is\nundefined, so that only the difference between the results of two calls is\nvalid.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "time.process_time_ns()", "path": "library/time#time.process_time_ns", "type": "Operating System", "text": "\nSimilar to `process_time()` but return time as nanoseconds.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "time.pthread_getcpuclockid()", "path": "library/time#time.pthread_getcpuclockid", "type": "Operating System", "text": "\nReturn the clk_id of the thread-specific CPU-time clock for the specified\nthread_id.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "time.sleep()", "path": "library/time#time.sleep", "type": "Operating System", "text": "\nSuspend execution of the calling thread for the given number of seconds. The\nargument may be a floating point number to indicate a more precise sleep time.\nThe actual suspension time may be less than that requested because any caught\nsignal will terminate the `sleep()` following execution of that signal\u2019s\ncatching routine. Also, the suspension time may be longer than requested by an\narbitrary amount because of the scheduling of other activity in the system.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "time.strftime()", "path": "library/time#time.strftime", "type": "Operating System", "text": "\nConvert a tuple or `struct_time` representing a time as returned by `gmtime()`\nor `localtime()` to a string as specified by the format argument. If t is not\nprovided, the current time as returned by `localtime()` is used. format must\nbe a string. `ValueError` is raised if any field in t is outside of the\nallowed range.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "time.strptime()", "path": "library/time#time.strptime", "type": "Operating System", "text": "\nParse a string representing a time according to a format. The return value is\na `struct_time` as returned by `gmtime()` or `localtime()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "time.struct_time", "path": "library/time#time.struct_time", "type": "Operating System", "text": "\nThe type of the time value sequence returned by `gmtime()`, `localtime()`, and\n`strptime()`. It is an object with a named tuple interface: values can be\naccessed by index and by attribute name. The following values are present:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "time.thread_time()", "path": "library/time#time.thread_time", "type": "Operating System", "text": "\nReturn the value (in fractional seconds) of the sum of the system and user CPU\ntime of the current thread. It does not include time elapsed during sleep. It\nis thread-specific by definition. The reference point of the returned value is\nundefined, so that only the difference between the results of two calls in the\nsame thread is valid.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "time.thread_time_ns()", "path": "library/time#time.thread_time_ns", "type": "Operating System", "text": "\nSimilar to `thread_time()` but return time as nanoseconds.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "time.time()", "path": "library/time#time.time", "type": "Operating System", "text": "\nReturn the time in seconds since the epoch as a floating point number. The\nspecific date of the epoch and the handling of leap seconds is platform\ndependent. On Windows and most Unix systems, the epoch is January 1, 1970,\n00:00:00 (UTC) and leap seconds are not counted towards the time in seconds\nsince the epoch. This is commonly referred to as Unix time. To find out what\nthe epoch is on a given platform, look at `gmtime(0)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "time.timezone", "path": "library/time#time.timezone", "type": "Operating System", "text": "\nThe offset of the local (non-DST) timezone, in seconds west of UTC (negative\nin most of Western Europe, positive in the US, zero in the UK). See note\nbelow.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "time.time_ns()", "path": "library/time#time.time_ns", "type": "Operating System", "text": "\nSimilar to `time()` but returns time as an integer number of nanoseconds since\nthe epoch.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "time.tzname", "path": "library/time#time.tzname", "type": "Operating System", "text": "\nA tuple of two strings: the first is the name of the local non-DST timezone,\nthe second is the name of the local DST timezone. If no DST timezone is\ndefined, the second string should not be used. See note below.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "time.tzset()", "path": "library/time#time.tzset", "type": "Operating System", "text": "\nReset the time conversion rules used by the library routines. The environment\nvariable `TZ` specifies how this is done. It will also set the variables\n`tzname` (from the `TZ` environment variable), `timezone` (non-DST seconds\nWest of UTC), `altzone` (DST seconds west of UTC) and `daylight` (to 0 if this\ntimezone does not have any daylight saving time rules, or to nonzero if there\nis a time, past, present or future when daylight saving time applies).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "timeit", "path": "library/timeit", "type": "Debugging & Profiling", "text": "\nSource code: Lib/timeit.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "timeit.default_timer()", "path": "library/timeit#timeit.default_timer", "type": "Debugging & Profiling", "text": "\nThe default timer, which is always `time.perf_counter()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "timeit.repeat()", "path": "library/timeit#timeit.repeat", "type": "Debugging & Profiling", "text": "\nCreate a `Timer` instance with the given statement, setup code and timer\nfunction and run its `repeat()` method with the given repeat count and number\nexecutions. The optional globals argument specifies a namespace in which to\nexecute the code.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "timeit.timeit()", "path": "library/timeit#timeit.timeit", "type": "Debugging & Profiling", "text": "\nCreate a `Timer` instance with the given statement, setup code and timer\nfunction and run its `timeit()` method with number executions. The optional\nglobals argument specifies a namespace in which to execute the code.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "timeit.Timer", "path": "library/timeit#timeit.Timer", "type": "Debugging & Profiling", "text": "\nClass for timing execution speed of small code snippets.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "timeit.Timer.autorange()", "path": "library/timeit#timeit.Timer.autorange", "type": "Debugging & Profiling", "text": "\nAutomatically determine how many times to call `timeit()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "timeit.Timer.print_exc()", "path": "library/timeit#timeit.Timer.print_exc", "type": "Debugging & Profiling", "text": "\nHelper to print a traceback from the timed code.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "timeit.Timer.repeat()", "path": "library/timeit#timeit.Timer.repeat", "type": "Debugging & Profiling", "text": "\nCall `timeit()` a few times.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "timeit.Timer.timeit()", "path": "library/timeit#timeit.Timer.timeit", "type": "Debugging & Profiling", "text": "\nTime number executions of the main statement. This executes the setup\nstatement once, and then returns the time it takes to execute the main\nstatement a number of times, measured in seconds as a float. The argument is\nthe number of times through the loop, defaulting to one million. The main\nstatement, the setup statement and the timer function to be used are passed to\nthe constructor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "TimeoutError", "path": "library/exceptions#TimeoutError", "type": "Built-in Exceptions", "text": "\nRaised when a system function timed out at the system level. Corresponds to\n`errno` `ETIMEDOUT`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter", "path": "library/tkinter", "type": "Tk", "text": "\nSource code: Lib/tkinter/__init__.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Tkinter Dialogs", "path": "library/dialog", "type": "Tk", "text": "\nSource code: Lib/tkinter/simpledialog.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.colorchooser", "path": "library/tkinter.colorchooser", "type": "Tk", "text": "\nSource code: Lib/tkinter/colorchooser.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.colorchooser.askcolor()", "path": "library/tkinter.colorchooser#tkinter.colorchooser.askcolor", "type": "Tk", "text": "\nCreate a color choosing dialog. A call to this method will show the window,\nwait for the user to make a selection, and return the selected color (or\n`None`) to the caller.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.colorchooser.Chooser", "path": "library/tkinter.colorchooser#tkinter.colorchooser.Chooser", "type": "Tk", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.commondialog.Dialog", "path": "library/dialog#tkinter.commondialog.Dialog", "type": "Tk", "text": "\nRender the Dialog window.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.commondialog.Dialog.show()", "path": "library/dialog#tkinter.commondialog.Dialog.show", "type": "Tk", "text": "\nRender the Dialog window.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.dnd", "path": "library/tkinter.dnd", "type": "Tk", "text": "\nSource code: Lib/tkinter/dnd.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.dnd.DndHandler", "path": "library/tkinter.dnd#tkinter.dnd.DndHandler", "type": "Tk", "text": "\nThe DndHandler class handles drag-and-drop events tracking Motion and\nButtonRelease events on the root of the event widget.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.dnd.DndHandler.cancel()", "path": "library/tkinter.dnd#tkinter.dnd.DndHandler.cancel", "type": "Tk", "text": "\nCancel the drag-and-drop process.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.dnd.DndHandler.finish()", "path": "library/tkinter.dnd#tkinter.dnd.DndHandler.finish", "type": "Tk", "text": "\nExecute end of drag-and-drop functions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.dnd.DndHandler.on_motion()", "path": "library/tkinter.dnd#tkinter.dnd.DndHandler.on_motion", "type": "Tk", "text": "\nInspect area below mouse for target objects while drag is performed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.dnd.DndHandler.on_release()", "path": "library/tkinter.dnd#tkinter.dnd.DndHandler.on_release", "type": "Tk", "text": "\nSignal end of drag when the release pattern is triggered.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.dnd.dnd_start()", "path": "library/tkinter.dnd#tkinter.dnd.dnd_start", "type": "Tk", "text": "\nFactory function for drag-and-drop process.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.EXCEPTION", "path": "library/tkinter#tkinter.EXCEPTION", "type": "Tk", "text": "\nConstants used in the mask arguments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.filedialog.askdirectory()", "path": "library/dialog#tkinter.filedialog.askdirectory", "type": "Tk", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.filedialog.askopenfile()", "path": "library/dialog#tkinter.filedialog.askopenfile", "type": "Tk", "text": "\nThe above two functions create an `Open` dialog and return the opened file\nobject(s) in read-only mode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.filedialog.askopenfilename()", "path": "library/dialog#tkinter.filedialog.askopenfilename", "type": "Tk", "text": "\nThe above two functions create an `Open` dialog and return the selected\nfilename(s) that correspond to existing file(s).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.filedialog.askopenfilenames()", "path": "library/dialog#tkinter.filedialog.askopenfilenames", "type": "Tk", "text": "\nThe above two functions create an `Open` dialog and return the selected\nfilename(s) that correspond to existing file(s).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.filedialog.askopenfiles()", "path": "library/dialog#tkinter.filedialog.askopenfiles", "type": "Tk", "text": "\nThe above two functions create an `Open` dialog and return the opened file\nobject(s) in read-only mode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.filedialog.asksaveasfile()", "path": "library/dialog#tkinter.filedialog.asksaveasfile", "type": "Tk", "text": "\nCreate a `SaveAs` dialog and return a file object opened in write-only mode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.filedialog.asksaveasfilename()", "path": "library/dialog#tkinter.filedialog.asksaveasfilename", "type": "Tk", "text": "\nCreate a `SaveAs` dialog and return the selected filename.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.filedialog.Directory", "path": "library/dialog#tkinter.filedialog.Directory", "type": "Tk", "text": "\nCreate a dialog prompting the user to select a directory.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.filedialog.FileDialog", "path": "library/dialog#tkinter.filedialog.FileDialog", "type": "Tk", "text": "\nCreate a basic file selection dialog.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.filedialog.FileDialog.cancel_command()", "path": "library/dialog#tkinter.filedialog.FileDialog.cancel_command", "type": "Tk", "text": "\nTrigger the termination of the dialog window.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.filedialog.FileDialog.dirs_double_event()", "path": "library/dialog#tkinter.filedialog.FileDialog.dirs_double_event", "type": "Tk", "text": "\nEvent handler for double-click event on directory.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.filedialog.FileDialog.dirs_select_event()", "path": "library/dialog#tkinter.filedialog.FileDialog.dirs_select_event", "type": "Tk", "text": "\nEvent handler for click event on directory.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.filedialog.FileDialog.files_double_event()", "path": "library/dialog#tkinter.filedialog.FileDialog.files_double_event", "type": "Tk", "text": "\nEvent handler for double-click event on file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.filedialog.FileDialog.files_select_event()", "path": "library/dialog#tkinter.filedialog.FileDialog.files_select_event", "type": "Tk", "text": "\nEvent handler for single-click event on file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.filedialog.FileDialog.filter_command()", "path": "library/dialog#tkinter.filedialog.FileDialog.filter_command", "type": "Tk", "text": "\nFilter the files by directory.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.filedialog.FileDialog.get_filter()", "path": "library/dialog#tkinter.filedialog.FileDialog.get_filter", "type": "Tk", "text": "\nRetrieve the file filter currently in use.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.filedialog.FileDialog.get_selection()", "path": "library/dialog#tkinter.filedialog.FileDialog.get_selection", "type": "Tk", "text": "\nRetrieve the currently selected item.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.filedialog.FileDialog.go()", "path": "library/dialog#tkinter.filedialog.FileDialog.go", "type": "Tk", "text": "\nRender dialog and start event loop.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.filedialog.FileDialog.ok_event()", "path": "library/dialog#tkinter.filedialog.FileDialog.ok_event", "type": "Tk", "text": "\nExit dialog returning current selection.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.filedialog.FileDialog.quit()", "path": "library/dialog#tkinter.filedialog.FileDialog.quit", "type": "Tk", "text": "\nExit dialog returning filename, if any.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.filedialog.FileDialog.set_filter()", "path": "library/dialog#tkinter.filedialog.FileDialog.set_filter", "type": "Tk", "text": "\nSet the file filter.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.filedialog.FileDialog.set_selection()", "path": "library/dialog#tkinter.filedialog.FileDialog.set_selection", "type": "Tk", "text": "\nUpdate the current file selection to file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.filedialog.LoadFileDialog", "path": "library/dialog#tkinter.filedialog.LoadFileDialog", "type": "Tk", "text": "\nA subclass of FileDialog that creates a dialog window for selecting an\nexisting file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.filedialog.LoadFileDialog.ok_command()", "path": "library/dialog#tkinter.filedialog.LoadFileDialog.ok_command", "type": "Tk", "text": "\nTest that a file is provided and that the selection indicates an already\nexisting file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.filedialog.Open", "path": "library/dialog#tkinter.filedialog.Open", "type": "Tk", "text": "\nThe above two classes provide native dialog windows for saving and loading\nfiles.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.filedialog.SaveAs", "path": "library/dialog#tkinter.filedialog.SaveAs", "type": "Tk", "text": "\nThe above two classes provide native dialog windows for saving and loading\nfiles.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.filedialog.SaveFileDialog", "path": "library/dialog#tkinter.filedialog.SaveFileDialog", "type": "Tk", "text": "\nA subclass of FileDialog that creates a dialog window for selecting a\ndestination file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.filedialog.SaveFileDialog.ok_command()", "path": "library/dialog#tkinter.filedialog.SaveFileDialog.ok_command", "type": "Tk", "text": "\nTest whether or not the selection points to a valid file that is not a\ndirectory. Confirmation is required if an already existing file is selected.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.font", "path": "library/tkinter.font", "type": "Tk", "text": "\nSource code: Lib/tkinter/font.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.font.BOLD", "path": "library/tkinter.font#tkinter.font.BOLD", "type": "Tk", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.font.families()", "path": "library/tkinter.font#tkinter.font.families", "type": "Tk", "text": "\nReturn the different font families.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.font.Font", "path": "library/tkinter.font#tkinter.font.Font", "type": "Tk", "text": "\nThe `Font` class represents a named font. Font instances are given unique\nnames and can be specified by their family, size, and style configuration.\nNamed fonts are Tk\u2019s method of creating and identifying fonts as a single\nobject, rather than specifying a font by its attributes with each occurrence.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.font.Font.actual()", "path": "library/tkinter.font#tkinter.font.Font.actual", "type": "Tk", "text": "\nReturn the attributes of the font.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.font.Font.cget()", "path": "library/tkinter.font#tkinter.font.Font.cget", "type": "Tk", "text": "\nRetrieve an attribute of the font.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.font.Font.config()", "path": "library/tkinter.font#tkinter.font.Font.config", "type": "Tk", "text": "\nModify attributes of the font.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.font.Font.copy()", "path": "library/tkinter.font#tkinter.font.Font.copy", "type": "Tk", "text": "\nReturn new instance of the current font.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.font.Font.measure()", "path": "library/tkinter.font#tkinter.font.Font.measure", "type": "Tk", "text": "\nReturn amount of space the text would occupy on the specified display when\nformatted in the current font. If no display is specified then the main\napplication window is assumed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.font.Font.metrics()", "path": "library/tkinter.font#tkinter.font.Font.metrics", "type": "Tk", "text": "\nReturn font-specific data. Options include:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.font.ITALIC", "path": "library/tkinter.font#tkinter.font.ITALIC", "type": "Tk", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.font.names()", "path": "library/tkinter.font#tkinter.font.names", "type": "Tk", "text": "\nReturn the names of defined fonts.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.font.nametofont()", "path": "library/tkinter.font#tkinter.font.nametofont", "type": "Tk", "text": "\nReturn a `Font` representation of a tk named font.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.font.NORMAL", "path": "library/tkinter.font#tkinter.font.NORMAL", "type": "Tk", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.font.ROMAN", "path": "library/tkinter.font#tkinter.font.ROMAN", "type": "Tk", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.messagebox", "path": "library/tkinter.messagebox", "type": "Tk", "text": "\nSource code: Lib/tkinter/messagebox.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.messagebox.askokcancel()", "path": "library/tkinter.messagebox#tkinter.messagebox.askokcancel", "type": "Tk", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.messagebox.askquestion()", "path": "library/tkinter.messagebox#tkinter.messagebox.askquestion", "type": "Tk", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.messagebox.askretrycancel()", "path": "library/tkinter.messagebox#tkinter.messagebox.askretrycancel", "type": "Tk", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.messagebox.askyesno()", "path": "library/tkinter.messagebox#tkinter.messagebox.askyesno", "type": "Tk", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.messagebox.askyesnocancel()", "path": "library/tkinter.messagebox#tkinter.messagebox.askyesnocancel", "type": "Tk", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.messagebox.Message", "path": "library/tkinter.messagebox#tkinter.messagebox.Message", "type": "Tk", "text": "\nCreate a default information message box.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.messagebox.showerror()", "path": "library/tkinter.messagebox#tkinter.messagebox.showerror", "type": "Tk", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.messagebox.showinfo()", "path": "library/tkinter.messagebox#tkinter.messagebox.showinfo", "type": "Tk", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.messagebox.showwarning()", "path": "library/tkinter.messagebox#tkinter.messagebox.showwarning", "type": "Tk", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.READABLE", "path": "library/tkinter#tkinter.READABLE", "type": "Tk", "text": "\nConstants used in the mask arguments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.scrolledtext", "path": "library/tkinter.scrolledtext", "type": "Tk", "text": "\nSource code: Lib/tkinter/scrolledtext.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.scrolledtext.ScrolledText", "path": "library/tkinter.scrolledtext#tkinter.scrolledtext.ScrolledText", "type": "Tk", "text": "\nThe frame which surrounds the text and scroll bar widgets.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.scrolledtext.ScrolledText.frame", "path": "library/tkinter.scrolledtext#tkinter.scrolledtext.ScrolledText.frame", "type": "Tk", "text": "\nThe frame which surrounds the text and scroll bar widgets.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.scrolledtext.ScrolledText.vbar", "path": "library/tkinter.scrolledtext#tkinter.scrolledtext.ScrolledText.vbar", "type": "Tk", "text": "\nThe scroll bar widget.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.simpledialog.askfloat()", "path": "library/dialog#tkinter.simpledialog.askfloat", "type": "Tk", "text": "\nThe above three functions provide dialogs that prompt the user to enter a\nvalue of the desired type.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.simpledialog.askinteger()", "path": "library/dialog#tkinter.simpledialog.askinteger", "type": "Tk", "text": "\nThe above three functions provide dialogs that prompt the user to enter a\nvalue of the desired type.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.simpledialog.askstring()", "path": "library/dialog#tkinter.simpledialog.askstring", "type": "Tk", "text": "\nThe above three functions provide dialogs that prompt the user to enter a\nvalue of the desired type.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.simpledialog.Dialog", "path": "library/dialog#tkinter.simpledialog.Dialog", "type": "Tk", "text": "\nThe base class for custom dialogs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.simpledialog.Dialog.body()", "path": "library/dialog#tkinter.simpledialog.Dialog.body", "type": "Tk", "text": "\nOverride to construct the dialog\u2019s interface and return the widget that should\nhave initial focus.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.simpledialog.Dialog.buttonbox()", "path": "library/dialog#tkinter.simpledialog.Dialog.buttonbox", "type": "Tk", "text": "\nDefault behaviour adds OK and Cancel buttons. Override for custom button\nlayouts.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.Tcl()", "path": "library/tkinter#tkinter.Tcl", "type": "Tk", "text": "\nThe `Tcl()` function is a factory function which creates an object much like\nthat created by the `Tk` class, except that it does not initialize the Tk\nsubsystem. This is most often useful when driving the Tcl interpreter in an\nenvironment where one doesn\u2019t want to create extraneous toplevel windows, or\nwhere one cannot (such as Unix/Linux systems without an X server). An object\ncreated by the `Tcl()` object can have a Toplevel window created (and the Tk\nsubsystem initialized) by calling its `loadtk()` method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.tix", "path": "library/tkinter.tix", "type": "Tk", "text": "\nSource code: Lib/tkinter/tix.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.tix.Balloon", "path": "library/tkinter.tix#tkinter.tix.Balloon", "type": "Tk", "text": "\nA Balloon that pops up over a widget to provide help. When the user moves the\ncursor inside a widget to which a Balloon widget has been bound, a small pop-\nup window with a descriptive message will be shown on the screen.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.tix.ButtonBox", "path": "library/tkinter.tix#tkinter.tix.ButtonBox", "type": "Tk", "text": "\nThe ButtonBox widget creates a box of buttons, such as is commonly used for\n`Ok Cancel`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.tix.CheckList", "path": "library/tkinter.tix#tkinter.tix.CheckList", "type": "Tk", "text": "\nThe CheckList widget displays a list of items to be selected by the user.\nCheckList acts similarly to the Tk checkbutton or radiobutton widgets, except\nit is capable of handling many more items than checkbuttons or radiobuttons.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.tix.ComboBox", "path": "library/tkinter.tix#tkinter.tix.ComboBox", "type": "Tk", "text": "\nThe ComboBox widget is similar to the combo box control in MS Windows. The\nuser can select a choice by either typing in the entry subwidget or selecting\nfrom the listbox subwidget.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.tix.Control", "path": "library/tkinter.tix#tkinter.tix.Control", "type": "Tk", "text": "\nThe Control widget is also known as the `SpinBox` widget. The user can adjust\nthe value by pressing the two arrow buttons or by entering the value directly\ninto the entry. The new value will be checked against the user-defined upper\nand lower limits.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.tix.DirList", "path": "library/tkinter.tix#tkinter.tix.DirList", "type": "Tk", "text": "\nThe DirList widget displays a list view of a directory, its previous\ndirectories and its sub-directories. The user can choose one of the\ndirectories displayed in the list or change to another directory.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.tix.DirSelectBox", "path": "library/tkinter.tix#tkinter.tix.DirSelectBox", "type": "Tk", "text": "\nThe `DirSelectBox` is similar to the standard Motif(TM) directory-selection\nbox. It is generally used for the user to choose a directory. DirSelectBox\nstores the directories mostly recently selected into a ComboBox widget so that\nthey can be quickly selected again.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.tix.DirSelectDialog", "path": "library/tkinter.tix#tkinter.tix.DirSelectDialog", "type": "Tk", "text": "\nThe DirSelectDialog widget presents the directories in the file system in a\ndialog window. The user can use this dialog window to navigate through the\nfile system to select the desired directory.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.tix.DirTree", "path": "library/tkinter.tix#tkinter.tix.DirTree", "type": "Tk", "text": "\nThe DirTree widget displays a tree view of a directory, its previous\ndirectories and its sub-directories. The user can choose one of the\ndirectories displayed in the list or change to another directory.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.tix.ExFileSelectBox", "path": "library/tkinter.tix#tkinter.tix.ExFileSelectBox", "type": "Tk", "text": "\nThe ExFileSelectBox widget is usually embedded in a tixExFileSelectDialog\nwidget. It provides a convenient method for the user to select files. The\nstyle of the `ExFileSelectBox` widget is very similar to the standard file\ndialog on MS Windows 3.1.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.tix.FileEntry", "path": "library/tkinter.tix#tkinter.tix.FileEntry", "type": "Tk", "text": "\nThe FileEntry widget can be used to input a filename. The user can type in the\nfilename manually. Alternatively, the user can press the button widget that\nsits next to the entry, which will bring up a file selection dialog.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.tix.FileSelectBox", "path": "library/tkinter.tix#tkinter.tix.FileSelectBox", "type": "Tk", "text": "\nThe FileSelectBox is similar to the standard Motif(TM) file-selection box. It\nis generally used for the user to choose a file. FileSelectBox stores the\nfiles mostly recently selected into a `ComboBox` widget so that they can be\nquickly selected again.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.tix.Form", "path": "library/tkinter.tix#tkinter.tix.Form", "type": "Tk", "text": "\nThe Form geometry manager based on attachment rules for all Tk widgets.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.tix.HList", "path": "library/tkinter.tix#tkinter.tix.HList", "type": "Tk", "text": "\nThe HList widget can be used to display any data that have a hierarchical\nstructure, for example, file system directory trees. The list entries are\nindented and connected by branch lines according to their places in the\nhierarchy.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.tix.InputOnly", "path": "library/tkinter.tix#tkinter.tix.InputOnly", "type": "Tk", "text": "\nThe InputOnly widgets are to accept inputs from the user, which can be done\nwith the `bind` command (Unix only).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.tix.LabelEntry", "path": "library/tkinter.tix#tkinter.tix.LabelEntry", "type": "Tk", "text": "\nThe LabelEntry widget packages an entry widget and a label into one mega\nwidget. It can be used to simplify the creation of \u201centry-form\u201d type of\ninterface.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.tix.LabelFrame", "path": "library/tkinter.tix#tkinter.tix.LabelFrame", "type": "Tk", "text": "\nThe LabelFrame widget packages a frame widget and a label into one mega\nwidget. To create widgets inside a LabelFrame widget, one creates the new\nwidgets relative to the `frame` subwidget and manage them inside the `frame`\nsubwidget.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.tix.ListNoteBook", "path": "library/tkinter.tix#tkinter.tix.ListNoteBook", "type": "Tk", "text": "\nThe ListNoteBook widget is very similar to the `TixNoteBook` widget: it can be\nused to display many windows in a limited space using a notebook metaphor. The\nnotebook is divided into a stack of pages (windows). At one time only one of\nthese pages can be shown. The user can navigate through these pages by\nchoosing the name of the desired page in the `hlist` subwidget.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.tix.Meter", "path": "library/tkinter.tix#tkinter.tix.Meter", "type": "Tk", "text": "\nThe Meter widget can be used to show the progress of a background job which\nmay take a long time to execute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.tix.NoteBook", "path": "library/tkinter.tix#tkinter.tix.NoteBook", "type": "Tk", "text": "\nThe NoteBook widget can be used to display many windows in a limited space\nusing a notebook metaphor. The notebook is divided into a stack of pages. At\none time only one of these pages can be shown. The user can navigate through\nthese pages by choosing the visual \u201ctabs\u201d at the top of the NoteBook widget.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.tix.OptionMenu", "path": "library/tkinter.tix#tkinter.tix.OptionMenu", "type": "Tk", "text": "\nThe OptionMenu creates a menu button of options.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.tix.PanedWindow", "path": "library/tkinter.tix#tkinter.tix.PanedWindow", "type": "Tk", "text": "\nThe PanedWindow widget allows the user to interactively manipulate the sizes\nof several panes. The panes can be arranged either vertically or horizontally.\nThe user changes the sizes of the panes by dragging the resize handle between\ntwo panes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.tix.PopupMenu", "path": "library/tkinter.tix#tkinter.tix.PopupMenu", "type": "Tk", "text": "\nThe PopupMenu widget can be used as a replacement of the `tk_popup` command.\nThe advantage of the `Tix` `PopupMenu` widget is it requires less application\ncode to manipulate.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.tix.Select", "path": "library/tkinter.tix#tkinter.tix.Select", "type": "Tk", "text": "\nThe Select widget is a container of button subwidgets. It can be used to\nprovide radio-box or check-box style of selection options for the user.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.tix.StdButtonBox", "path": "library/tkinter.tix#tkinter.tix.StdButtonBox", "type": "Tk", "text": "\nThe StdButtonBox widget is a group of standard buttons for Motif-like dialog\nboxes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.tix.tixCommand", "path": "library/tkinter.tix#tkinter.tix.tixCommand", "type": "Tk", "text": "\nThe tix commands provide access to miscellaneous elements of `Tix`\u2019s internal\nstate and the `Tix` application context. Most of the information manipulated\nby these methods pertains to the application as a whole, or to a screen or\ndisplay, rather than to a particular window.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.tix.tixCommand.tix_addbitmapdir()", "path": "library/tkinter.tix#tkinter.tix.tixCommand.tix_addbitmapdir", "type": "Tk", "text": "\nTix maintains a list of directories under which the `tix_getimage()` and\n`tix_getbitmap()` methods will search for image files. The standard bitmap\ndirectory is `$TIX_LIBRARY/bitmaps`. The `tix_addbitmapdir()` method adds\ndirectory into this list. By using this method, the image files of an\napplications can also be located using the `tix_getimage()` or\n`tix_getbitmap()` method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.tix.tixCommand.tix_cget()", "path": "library/tkinter.tix#tkinter.tix.tixCommand.tix_cget", "type": "Tk", "text": "\nReturns the current value of the configuration option given by option. Option\nmay be any of the configuration options.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.tix.tixCommand.tix_configure()", "path": "library/tkinter.tix#tkinter.tix.tixCommand.tix_configure", "type": "Tk", "text": "\nQuery or modify the configuration options of the Tix application context. If\nno option is specified, returns a dictionary all of the available options. If\noption is specified with no value, then the method returns a list describing\nthe one named option (this list will be identical to the corresponding sublist\nof the value returned if no option is specified). If one or more option-value\npairs are specified, then the method modifies the given option(s) to have the\ngiven value(s); in this case the method returns an empty string. Option may be\nany of the configuration options.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.tix.tixCommand.tix_filedialog()", "path": "library/tkinter.tix#tkinter.tix.tixCommand.tix_filedialog", "type": "Tk", "text": "\nReturns the file selection dialog that may be shared among different calls\nfrom this application. This method will create a file selection dialog widget\nwhen it is called the first time. This dialog will be returned by all\nsubsequent calls to `tix_filedialog()`. An optional dlgclass parameter can be\npassed as a string to specified what type of file selection dialog widget is\ndesired. Possible options are `tix`, `FileSelectDialog` or\n`tixExFileSelectDialog`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.tix.tixCommand.tix_getbitmap()", "path": "library/tkinter.tix#tkinter.tix.tixCommand.tix_getbitmap", "type": "Tk", "text": "\nLocates a bitmap file of the name `name.xpm` or `name` in one of the bitmap\ndirectories (see the `tix_addbitmapdir()` method). By using `tix_getbitmap()`,\nyou can avoid hard coding the pathnames of the bitmap files in your\napplication. When successful, it returns the complete pathname of the bitmap\nfile, prefixed with the character `@`. The returned value can be used to\nconfigure the `bitmap` option of the Tk and Tix widgets.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.tix.tixCommand.tix_getimage()", "path": "library/tkinter.tix#tkinter.tix.tixCommand.tix_getimage", "type": "Tk", "text": "\nLocates an image file of the name `name.xpm`, `name.xbm` or `name.ppm` in one\nof the bitmap directories (see the `tix_addbitmapdir()` method above). If more\nthan one file with the same name (but different extensions) exist, then the\nimage type is chosen according to the depth of the X display: xbm images are\nchosen on monochrome displays and color images are chosen on color displays.\nBy using `tix_getimage()`, you can avoid hard coding the pathnames of the\nimage files in your application. When successful, this method returns the name\nof the newly created image, which can be used to configure the `image` option\nof the Tk and Tix widgets.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.tix.tixCommand.tix_option_get()", "path": "library/tkinter.tix#tkinter.tix.tixCommand.tix_option_get", "type": "Tk", "text": "\nGets the options maintained by the Tix scheme mechanism.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.tix.tixCommand.tix_resetoptions()", "path": "library/tkinter.tix#tkinter.tix.tixCommand.tix_resetoptions", "type": "Tk", "text": "\nResets the scheme and fontset of the Tix application to newScheme and\nnewFontSet, respectively. This affects only those widgets created after this\ncall. Therefore, it is best to call the resetoptions method before the\ncreation of any widgets in a Tix application.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.tix.Tk", "path": "library/tkinter.tix#tkinter.tix.Tk", "type": "Tk", "text": "\nToplevel widget of Tix which represents mostly the main window of an\napplication. It has an associated Tcl interpreter.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.tix.TList", "path": "library/tkinter.tix#tkinter.tix.TList", "type": "Tk", "text": "\nThe TList widget can be used to display data in a tabular format. The list\nentries of a `TList` widget are similar to the entries in the Tk listbox\nwidget. The main differences are (1) the `TList` widget can display the list\nentries in a two dimensional format and (2) you can use graphical images as\nwell as multiple colors and fonts for the list entries.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.tix.Tree", "path": "library/tkinter.tix#tkinter.tix.Tree", "type": "Tk", "text": "\nThe Tree widget can be used to display hierarchical data in a tree form. The\nuser can adjust the view of the tree by opening or closing parts of the tree.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.Tk", "path": "library/tkinter#tkinter.Tk", "type": "Tk", "text": "\nThe `Tk` class is instantiated without arguments. This creates a toplevel\nwidget of Tk which usually is the main window of an application. Each instance\nhas its own associated Tcl interpreter.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk", "path": "library/tkinter.ttk", "type": "Tk", "text": "\nSource code: Lib/tkinter/ttk.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Combobox", "path": "library/tkinter.ttk#tkinter.ttk.Combobox", "type": "Tk", "text": "\nIf newindex is specified, sets the combobox value to the element position\nnewindex. Otherwise, returns the index of the current value or -1 if the\ncurrent value is not in the values list.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Combobox.current()", "path": "library/tkinter.ttk#tkinter.ttk.Combobox.current", "type": "Tk", "text": "\nIf newindex is specified, sets the combobox value to the element position\nnewindex. Otherwise, returns the index of the current value or -1 if the\ncurrent value is not in the values list.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Combobox.get()", "path": "library/tkinter.ttk#tkinter.ttk.Combobox.get", "type": "Tk", "text": "\nReturns the current value of the combobox.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Combobox.set()", "path": "library/tkinter.ttk#tkinter.ttk.Combobox.set", "type": "Tk", "text": "\nSets the value of the combobox to value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Notebook", "path": "library/tkinter.ttk#tkinter.ttk.Notebook", "type": "Tk", "text": "\nAdds a new tab to the notebook.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Notebook.add()", "path": "library/tkinter.ttk#tkinter.ttk.Notebook.add", "type": "Tk", "text": "\nAdds a new tab to the notebook.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Notebook.enable_traversal()", "path": "library/tkinter.ttk#tkinter.ttk.Notebook.enable_traversal", "type": "Tk", "text": "\nEnable keyboard traversal for a toplevel window containing this notebook.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Notebook.forget()", "path": "library/tkinter.ttk#tkinter.ttk.Notebook.forget", "type": "Tk", "text": "\nRemoves the tab specified by tab_id, unmaps and unmanages the associated\nwindow.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Notebook.hide()", "path": "library/tkinter.ttk#tkinter.ttk.Notebook.hide", "type": "Tk", "text": "\nHides the tab specified by tab_id.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Notebook.identify()", "path": "library/tkinter.ttk#tkinter.ttk.Notebook.identify", "type": "Tk", "text": "\nReturns the name of the tab element at position x, y, or the empty string if\nnone.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Notebook.index()", "path": "library/tkinter.ttk#tkinter.ttk.Notebook.index", "type": "Tk", "text": "\nReturns the numeric index of the tab specified by tab_id, or the total number\nof tabs if tab_id is the string \u201cend\u201d.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Notebook.insert()", "path": "library/tkinter.ttk#tkinter.ttk.Notebook.insert", "type": "Tk", "text": "\nInserts a pane at the specified position.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Notebook.select()", "path": "library/tkinter.ttk#tkinter.ttk.Notebook.select", "type": "Tk", "text": "\nSelects the specified tab_id.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Notebook.tab()", "path": "library/tkinter.ttk#tkinter.ttk.Notebook.tab", "type": "Tk", "text": "\nQuery or modify the options of the specific tab_id.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Notebook.tabs()", "path": "library/tkinter.ttk#tkinter.ttk.Notebook.tabs", "type": "Tk", "text": "\nReturns a list of windows managed by the notebook.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Progressbar", "path": "library/tkinter.ttk#tkinter.ttk.Progressbar", "type": "Tk", "text": "\nBegin autoincrement mode: schedules a recurring timer event that calls\n`Progressbar.step()` every interval milliseconds. If omitted, interval\ndefaults to 50 milliseconds.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Progressbar.start()", "path": "library/tkinter.ttk#tkinter.ttk.Progressbar.start", "type": "Tk", "text": "\nBegin autoincrement mode: schedules a recurring timer event that calls\n`Progressbar.step()` every interval milliseconds. If omitted, interval\ndefaults to 50 milliseconds.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Progressbar.step()", "path": "library/tkinter.ttk#tkinter.ttk.Progressbar.step", "type": "Tk", "text": "\nIncrements the progress bar\u2019s value by amount.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Progressbar.stop()", "path": "library/tkinter.ttk#tkinter.ttk.Progressbar.stop", "type": "Tk", "text": "\nStop autoincrement mode: cancels any recurring timer event initiated by\n`Progressbar.start()` for this progress bar.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Spinbox", "path": "library/tkinter.ttk#tkinter.ttk.Spinbox", "type": "Tk", "text": "\nReturns the current value of the spinbox.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Spinbox.get()", "path": "library/tkinter.ttk#tkinter.ttk.Spinbox.get", "type": "Tk", "text": "\nReturns the current value of the spinbox.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Spinbox.set()", "path": "library/tkinter.ttk#tkinter.ttk.Spinbox.set", "type": "Tk", "text": "\nSets the value of the spinbox to value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Style", "path": "library/tkinter.ttk#tkinter.ttk.Style", "type": "Tk", "text": "\nThis class is used to manipulate the style database.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Style.configure()", "path": "library/tkinter.ttk#tkinter.ttk.Style.configure", "type": "Tk", "text": "\nQuery or set the default value of the specified option(s) in style.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Style.element_create()", "path": "library/tkinter.ttk#tkinter.ttk.Style.element_create", "type": "Tk", "text": "\nCreate a new element in the current theme, of the given etype which is\nexpected to be either \u201cimage\u201d, \u201cfrom\u201d or \u201cvsapi\u201d. The latter is only available\nin Tk 8.6a for Windows XP and Vista and is not described here.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Style.element_names()", "path": "library/tkinter.ttk#tkinter.ttk.Style.element_names", "type": "Tk", "text": "\nReturns the list of elements defined in the current theme.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Style.element_options()", "path": "library/tkinter.ttk#tkinter.ttk.Style.element_options", "type": "Tk", "text": "\nReturns the list of elementname\u2019s options.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Style.layout()", "path": "library/tkinter.ttk#tkinter.ttk.Style.layout", "type": "Tk", "text": "\nDefine the widget layout for given style. If layoutspec is omitted, return the\nlayout specification for given style.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Style.lookup()", "path": "library/tkinter.ttk#tkinter.ttk.Style.lookup", "type": "Tk", "text": "\nReturns the value specified for option in style.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Style.map()", "path": "library/tkinter.ttk#tkinter.ttk.Style.map", "type": "Tk", "text": "\nQuery or sets dynamic values of the specified option(s) in style.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Style.theme_create()", "path": "library/tkinter.ttk#tkinter.ttk.Style.theme_create", "type": "Tk", "text": "\nCreate a new theme.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Style.theme_names()", "path": "library/tkinter.ttk#tkinter.ttk.Style.theme_names", "type": "Tk", "text": "\nReturns a list of all known themes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Style.theme_settings()", "path": "library/tkinter.ttk#tkinter.ttk.Style.theme_settings", "type": "Tk", "text": "\nTemporarily sets the current theme to themename, apply specified settings and\nthen restore the previous theme.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Style.theme_use()", "path": "library/tkinter.ttk#tkinter.ttk.Style.theme_use", "type": "Tk", "text": "\nIf themename is not given, returns the theme in use. Otherwise, sets the\ncurrent theme to themename, refreshes all widgets and emits a <<ThemeChanged>>\nevent.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Treeview", "path": "library/tkinter.ttk#tkinter.ttk.Treeview", "type": "Tk", "text": "\nReturns the bounding box (relative to the treeview widget\u2019s window) of the\nspecified item in the form (x, y, width, height).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Treeview.bbox()", "path": "library/tkinter.ttk#tkinter.ttk.Treeview.bbox", "type": "Tk", "text": "\nReturns the bounding box (relative to the treeview widget\u2019s window) of the\nspecified item in the form (x, y, width, height).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Treeview.column()", "path": "library/tkinter.ttk#tkinter.ttk.Treeview.column", "type": "Tk", "text": "\nQuery or modify the options for the specified column.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Treeview.delete()", "path": "library/tkinter.ttk#tkinter.ttk.Treeview.delete", "type": "Tk", "text": "\nDelete all specified items and all their descendants.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Treeview.detach()", "path": "library/tkinter.ttk#tkinter.ttk.Treeview.detach", "type": "Tk", "text": "\nUnlinks all of the specified items from the tree.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Treeview.exists()", "path": "library/tkinter.ttk#tkinter.ttk.Treeview.exists", "type": "Tk", "text": "\nReturns `True` if the specified item is present in the tree.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Treeview.focus()", "path": "library/tkinter.ttk#tkinter.ttk.Treeview.focus", "type": "Tk", "text": "\nIf item is specified, sets the focus item to item. Otherwise, returns the\ncurrent focus item, or \u2018\u2019 if there is none.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Treeview.get_children()", "path": "library/tkinter.ttk#tkinter.ttk.Treeview.get_children", "type": "Tk", "text": "\nReturns the list of children belonging to item.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Treeview.heading()", "path": "library/tkinter.ttk#tkinter.ttk.Treeview.heading", "type": "Tk", "text": "\nQuery or modify the heading options for the specified column.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Treeview.identify()", "path": "library/tkinter.ttk#tkinter.ttk.Treeview.identify", "type": "Tk", "text": "\nReturns a description of the specified component under the point given by x\nand y, or the empty string if no such component is present at that position.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Treeview.identify_column()", "path": "library/tkinter.ttk#tkinter.ttk.Treeview.identify_column", "type": "Tk", "text": "\nReturns the data column identifier of the cell at position x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Treeview.identify_element()", "path": "library/tkinter.ttk#tkinter.ttk.Treeview.identify_element", "type": "Tk", "text": "\nReturns the element at position x, y.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Treeview.identify_region()", "path": "library/tkinter.ttk#tkinter.ttk.Treeview.identify_region", "type": "Tk", "text": "\nReturns one of:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Treeview.identify_row()", "path": "library/tkinter.ttk#tkinter.ttk.Treeview.identify_row", "type": "Tk", "text": "\nReturns the item ID of the item at position y.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Treeview.index()", "path": "library/tkinter.ttk#tkinter.ttk.Treeview.index", "type": "Tk", "text": "\nReturns the integer index of item within its parent\u2019s list of children.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Treeview.insert()", "path": "library/tkinter.ttk#tkinter.ttk.Treeview.insert", "type": "Tk", "text": "\nCreates a new item and returns the item identifier of the newly created item.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Treeview.item()", "path": "library/tkinter.ttk#tkinter.ttk.Treeview.item", "type": "Tk", "text": "\nQuery or modify the options for the specified item.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Treeview.move()", "path": "library/tkinter.ttk#tkinter.ttk.Treeview.move", "type": "Tk", "text": "\nMoves item to position index in parent\u2019s list of children.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Treeview.next()", "path": "library/tkinter.ttk#tkinter.ttk.Treeview.next", "type": "Tk", "text": "\nReturns the identifier of item\u2019s next sibling, or \u2018\u2019 if item is the last child\nof its parent.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Treeview.parent()", "path": "library/tkinter.ttk#tkinter.ttk.Treeview.parent", "type": "Tk", "text": "\nReturns the ID of the parent of item, or \u2018\u2019 if item is at the top level of the\nhierarchy.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Treeview.prev()", "path": "library/tkinter.ttk#tkinter.ttk.Treeview.prev", "type": "Tk", "text": "\nReturns the identifier of item\u2019s previous sibling, or \u2018\u2019 if item is the first\nchild of its parent.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Treeview.reattach()", "path": "library/tkinter.ttk#tkinter.ttk.Treeview.reattach", "type": "Tk", "text": "\nAn alias for `Treeview.move()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Treeview.see()", "path": "library/tkinter.ttk#tkinter.ttk.Treeview.see", "type": "Tk", "text": "\nEnsure that item is visible.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Treeview.selection()", "path": "library/tkinter.ttk#tkinter.ttk.Treeview.selection", "type": "Tk", "text": "\nReturns a tuple of selected items.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Treeview.selection_add()", "path": "library/tkinter.ttk#tkinter.ttk.Treeview.selection_add", "type": "Tk", "text": "\nAdd items to the selection.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Treeview.selection_remove()", "path": "library/tkinter.ttk#tkinter.ttk.Treeview.selection_remove", "type": "Tk", "text": "\nRemove items from the selection.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Treeview.selection_set()", "path": "library/tkinter.ttk#tkinter.ttk.Treeview.selection_set", "type": "Tk", "text": "\nitems becomes the new selection.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Treeview.selection_toggle()", "path": "library/tkinter.ttk#tkinter.ttk.Treeview.selection_toggle", "type": "Tk", "text": "\nToggle the selection state of each item in items.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Treeview.set()", "path": "library/tkinter.ttk#tkinter.ttk.Treeview.set", "type": "Tk", "text": "\nWith one argument, returns a dictionary of column/value pairs for the\nspecified item. With two arguments, returns the current value of the specified\ncolumn. With three arguments, sets the value of given column in given item to\nthe specified value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Treeview.set_children()", "path": "library/tkinter.ttk#tkinter.ttk.Treeview.set_children", "type": "Tk", "text": "\nReplaces item\u2019s child with newchildren.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Treeview.tag_bind()", "path": "library/tkinter.ttk#tkinter.ttk.Treeview.tag_bind", "type": "Tk", "text": "\nBind a callback for the given event sequence to the tag tagname. When an event\nis delivered to an item, the callbacks for each of the item\u2019s tags option are\ncalled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Treeview.tag_configure()", "path": "library/tkinter.ttk#tkinter.ttk.Treeview.tag_configure", "type": "Tk", "text": "\nQuery or modify the options for the specified tagname.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Treeview.tag_has()", "path": "library/tkinter.ttk#tkinter.ttk.Treeview.tag_has", "type": "Tk", "text": "\nIf item is specified, returns 1 or 0 depending on whether the specified item\nhas the given tagname. Otherwise, returns a list of all items that have the\nspecified tag.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Treeview.xview()", "path": "library/tkinter.ttk#tkinter.ttk.Treeview.xview", "type": "Tk", "text": "\nQuery or modify horizontal position of the treeview.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Treeview.yview()", "path": "library/tkinter.ttk#tkinter.ttk.Treeview.yview", "type": "Tk", "text": "\nQuery or modify vertical position of the treeview.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Widget", "path": "library/tkinter.ttk#tkinter.ttk.Widget", "type": "Tk", "text": "\nReturns the name of the element at position x y, or the empty string if the\npoint does not lie within any element.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Widget.identify()", "path": "library/tkinter.ttk#tkinter.ttk.Widget.identify", "type": "Tk", "text": "\nReturns the name of the element at position x y, or the empty string if the\npoint does not lie within any element.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Widget.instate()", "path": "library/tkinter.ttk#tkinter.ttk.Widget.instate", "type": "Tk", "text": "\nTest the widget\u2019s state. If a callback is not specified, returns `True` if the\nwidget state matches statespec and `False` otherwise. If callback is specified\nthen it is called with args if widget state matches statespec.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.ttk.Widget.state()", "path": "library/tkinter.ttk#tkinter.ttk.Widget.state", "type": "Tk", "text": "\nModify or inquire widget state. If statespec is specified, sets the widget\nstate according to it and return a new statespec indicating which flags were\nchanged. If statespec is not specified, returns the currently-enabled state\nflags.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.Widget.tk.createfilehandler()", "path": "library/tkinter#tkinter.Widget.tk.createfilehandler", "type": "Tk", "text": "\nRegisters the file handler callback function func. The file argument may\neither be an object with a `fileno()` method (such as a file or socket\nobject), or an integer file descriptor. The mask argument is an ORed\ncombination of any of the three constants below. The callback is called as\nfollows:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.Widget.tk.deletefilehandler()", "path": "library/tkinter#tkinter.Widget.tk.deletefilehandler", "type": "Tk", "text": "\nUnregisters a file handler.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tkinter.WRITABLE", "path": "library/tkinter#tkinter.WRITABLE", "type": "Tk", "text": "\nConstants used in the mask arguments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token", "path": "library/token", "type": "Language", "text": "\nSource code: Lib/token.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.AMPER", "path": "library/token#token.AMPER", "type": "Language", "text": "\nToken value for `\"&\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.AMPEREQUAL", "path": "library/token#token.AMPEREQUAL", "type": "Language", "text": "\nToken value for `\"&=\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.ASYNC", "path": "library/token#token.ASYNC", "type": "Language", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.AT", "path": "library/token#token.AT", "type": "Language", "text": "\nToken value for `\"@\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.ATEQUAL", "path": "library/token#token.ATEQUAL", "type": "Language", "text": "\nToken value for `\"@=\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.AWAIT", "path": "library/token#token.AWAIT", "type": "Language", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.CIRCUMFLEX", "path": "library/token#token.CIRCUMFLEX", "type": "Language", "text": "\nToken value for `\"^\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.CIRCUMFLEXEQUAL", "path": "library/token#token.CIRCUMFLEXEQUAL", "type": "Language", "text": "\nToken value for `\"^=\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.COLON", "path": "library/token#token.COLON", "type": "Language", "text": "\nToken value for `\":\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.COLONEQUAL", "path": "library/token#token.COLONEQUAL", "type": "Language", "text": "\nToken value for `\":=\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.COMMA", "path": "library/token#token.COMMA", "type": "Language", "text": "\nToken value for `\",\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.COMMENT", "path": "library/token#token.COMMENT", "type": "Language", "text": "\nToken value used to indicate a comment.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.DEDENT", "path": "library/token#token.DEDENT", "type": "Language", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.DOT", "path": "library/token#token.DOT", "type": "Language", "text": "\nToken value for `\".\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.DOUBLESLASH", "path": "library/token#token.DOUBLESLASH", "type": "Language", "text": "\nToken value for `\"//\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.DOUBLESLASHEQUAL", "path": "library/token#token.DOUBLESLASHEQUAL", "type": "Language", "text": "\nToken value for `\"//=\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.DOUBLESTAR", "path": "library/token#token.DOUBLESTAR", "type": "Language", "text": "\nToken value for `\"**\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.DOUBLESTAREQUAL", "path": "library/token#token.DOUBLESTAREQUAL", "type": "Language", "text": "\nToken value for `\"**=\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.ELLIPSIS", "path": "library/token#token.ELLIPSIS", "type": "Language", "text": "\nToken value for `\"...\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.ENCODING", "path": "library/token#token.ENCODING", "type": "Language", "text": "\nToken value that indicates the encoding used to decode the source bytes into\ntext. The first token returned by `tokenize.tokenize()` will always be an\n`ENCODING` token.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.ENDMARKER", "path": "library/token#token.ENDMARKER", "type": "Language", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.EQEQUAL", "path": "library/token#token.EQEQUAL", "type": "Language", "text": "\nToken value for `\"==\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.EQUAL", "path": "library/token#token.EQUAL", "type": "Language", "text": "\nToken value for `\"=\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.ERRORTOKEN", "path": "library/token#token.ERRORTOKEN", "type": "Language", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.GREATER", "path": "library/token#token.GREATER", "type": "Language", "text": "\nToken value for `\">\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.GREATEREQUAL", "path": "library/token#token.GREATEREQUAL", "type": "Language", "text": "\nToken value for `\">=\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.INDENT", "path": "library/token#token.INDENT", "type": "Language", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.ISEOF()", "path": "library/token#token.ISEOF", "type": "Language", "text": "\nReturn `True` if x is the marker indicating the end of input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.ISNONTERMINAL()", "path": "library/token#token.ISNONTERMINAL", "type": "Language", "text": "\nReturn `True` for non-terminal token values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.ISTERMINAL()", "path": "library/token#token.ISTERMINAL", "type": "Language", "text": "\nReturn `True` for terminal token values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.LBRACE", "path": "library/token#token.LBRACE", "type": "Language", "text": "\nToken value for `\"{\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.LEFTSHIFT", "path": "library/token#token.LEFTSHIFT", "type": "Language", "text": "\nToken value for `\"<<\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.LEFTSHIFTEQUAL", "path": "library/token#token.LEFTSHIFTEQUAL", "type": "Language", "text": "\nToken value for `\"<<=\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.LESS", "path": "library/token#token.LESS", "type": "Language", "text": "\nToken value for `\"<\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.LESSEQUAL", "path": "library/token#token.LESSEQUAL", "type": "Language", "text": "\nToken value for `\"<=\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.LPAR", "path": "library/token#token.LPAR", "type": "Language", "text": "\nToken value for `\"(\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.LSQB", "path": "library/token#token.LSQB", "type": "Language", "text": "\nToken value for `\"[\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.MINEQUAL", "path": "library/token#token.MINEQUAL", "type": "Language", "text": "\nToken value for `\"-=\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.MINUS", "path": "library/token#token.MINUS", "type": "Language", "text": "\nToken value for `\"-\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.NAME", "path": "library/token#token.NAME", "type": "Language", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.NEWLINE", "path": "library/token#token.NEWLINE", "type": "Language", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.NL", "path": "library/token#token.NL", "type": "Language", "text": "\nToken value used to indicate a non-terminating newline. The `NEWLINE` token\nindicates the end of a logical line of Python code; `NL` tokens are generated\nwhen a logical line of code is continued over multiple physical lines.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.NOTEQUAL", "path": "library/token#token.NOTEQUAL", "type": "Language", "text": "\nToken value for `\"!=\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.NT_OFFSET", "path": "library/token#token.NT_OFFSET", "type": "Language", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.NUMBER", "path": "library/token#token.NUMBER", "type": "Language", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.N_TOKENS", "path": "library/token#token.N_TOKENS", "type": "Language", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.OP", "path": "library/token#token.OP", "type": "Language", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.PERCENT", "path": "library/token#token.PERCENT", "type": "Language", "text": "\nToken value for `\"%\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.PERCENTEQUAL", "path": "library/token#token.PERCENTEQUAL", "type": "Language", "text": "\nToken value for `\"%=\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.PLUS", "path": "library/token#token.PLUS", "type": "Language", "text": "\nToken value for `\"+\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.PLUSEQUAL", "path": "library/token#token.PLUSEQUAL", "type": "Language", "text": "\nToken value for `\"+=\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.RARROW", "path": "library/token#token.RARROW", "type": "Language", "text": "\nToken value for `\"->\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.RBRACE", "path": "library/token#token.RBRACE", "type": "Language", "text": "\nToken value for `\"}\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.RIGHTSHIFT", "path": "library/token#token.RIGHTSHIFT", "type": "Language", "text": "\nToken value for `\">>\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.RIGHTSHIFTEQUAL", "path": "library/token#token.RIGHTSHIFTEQUAL", "type": "Language", "text": "\nToken value for `\">>=\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.RPAR", "path": "library/token#token.RPAR", "type": "Language", "text": "\nToken value for `\")\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.RSQB", "path": "library/token#token.RSQB", "type": "Language", "text": "\nToken value for `\"]\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.SEMI", "path": "library/token#token.SEMI", "type": "Language", "text": "\nToken value for `\";\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.SLASH", "path": "library/token#token.SLASH", "type": "Language", "text": "\nToken value for `\"/\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.SLASHEQUAL", "path": "library/token#token.SLASHEQUAL", "type": "Language", "text": "\nToken value for `\"/=\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.STAR", "path": "library/token#token.STAR", "type": "Language", "text": "\nToken value for `\"*\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.STAREQUAL", "path": "library/token#token.STAREQUAL", "type": "Language", "text": "\nToken value for `\"*=\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.STRING", "path": "library/token#token.STRING", "type": "Language", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.TILDE", "path": "library/token#token.TILDE", "type": "Language", "text": "\nToken value for `\"~\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.tok_name", "path": "library/token#token.tok_name", "type": "Language", "text": "\nDictionary mapping the numeric values of the constants defined in this module\nback to name strings, allowing more human-readable representation of parse\ntrees to be generated.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.TYPE_COMMENT", "path": "library/token#token.TYPE_COMMENT", "type": "Language", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.TYPE_IGNORE", "path": "library/token#token.TYPE_IGNORE", "type": "Language", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.VBAR", "path": "library/token#token.VBAR", "type": "Language", "text": "\nToken value for `\"|\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "token.VBAREQUAL", "path": "library/token#token.VBAREQUAL", "type": "Language", "text": "\nToken value for `\"|=\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tokenize", "path": "library/tokenize", "type": "Language", "text": "\nSource code: Lib/tokenize.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tokenize.detect_encoding()", "path": "library/tokenize#tokenize.detect_encoding", "type": "Language", "text": "\nThe `detect_encoding()` function is used to detect the encoding that should be\nused to decode a Python source file. It requires one argument, readline, in\nthe same way as the `tokenize()` generator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tokenize.generate_tokens()", "path": "library/tokenize#tokenize.generate_tokens", "type": "Language", "text": "\nTokenize a source reading unicode strings instead of bytes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tokenize.open()", "path": "library/tokenize#tokenize.open", "type": "Language", "text": "\nOpen a file in read only mode using the encoding detected by\n`detect_encoding()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tokenize.TokenError", "path": "library/tokenize#tokenize.TokenError", "type": "Language", "text": "\nRaised when either a docstring or expression that may be split over several\nlines is not completed anywhere in the file, for example:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tokenize.tokenize()", "path": "library/tokenize#tokenize.tokenize", "type": "Language", "text": "\nThe `tokenize()` generator requires one argument, readline, which must be a\ncallable object which provides the same interface as the\n`io.IOBase.readline()` method of file objects. Each call to the function\nshould return one line of input as bytes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tokenize.untokenize()", "path": "library/tokenize#tokenize.untokenize", "type": "Language", "text": "\nConverts tokens back into Python source code. The iterable must return\nsequences with at least two elements, the token type and the token string. Any\nadditional sequence elements are ignored.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "trace", "path": "library/trace", "type": "Debugging & Profiling", "text": "\nSource code: Lib/trace.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "trace.CoverageResults", "path": "library/trace#trace.CoverageResults", "type": "Debugging & Profiling", "text": "\nA container for coverage results, created by `Trace.results()`. Should not be\ncreated directly by the user.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "trace.CoverageResults.update()", "path": "library/trace#trace.CoverageResults.update", "type": "Debugging & Profiling", "text": "\nMerge in data from another `CoverageResults` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "trace.CoverageResults.write_results()", "path": "library/trace#trace.CoverageResults.write_results", "type": "Debugging & Profiling", "text": "\nWrite coverage results. Set show_missing to show lines that had no hits. Set\nsummary to include in the output the coverage summary per module. coverdir\nspecifies the directory into which the coverage result files will be output.\nIf `None`, the results for each source file are placed in its directory.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "trace.Trace", "path": "library/trace#trace.Trace", "type": "Debugging & Profiling", "text": "\nCreate an object to trace execution of a single statement or expression. All\nparameters are optional. count enables counting of line numbers. trace enables\nline execution tracing. countfuncs enables listing of the functions called\nduring the run. countcallers enables call relationship tracking. ignoremods is\na list of modules or packages to ignore. ignoredirs is a list of directories\nwhose modules or packages should be ignored. infile is the name of the file\nfrom which to read stored count information. outfile is the name of the file\nin which to write updated count information. timing enables a timestamp\nrelative to when tracing was started to be displayed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "trace.Trace.results()", "path": "library/trace#trace.Trace.results", "type": "Debugging & Profiling", "text": "\nReturn a `CoverageResults` object that contains the cumulative results of all\nprevious calls to `run`, `runctx` and `runfunc` for the given `Trace`\ninstance. Does not reset the accumulated trace results.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "trace.Trace.run()", "path": "library/trace#trace.Trace.run", "type": "Debugging & Profiling", "text": "\nExecute the command and gather statistics from the execution with the current\ntracing parameters. cmd must be a string or code object, suitable for passing\ninto `exec()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "trace.Trace.runctx()", "path": "library/trace#trace.Trace.runctx", "type": "Debugging & Profiling", "text": "\nExecute the command and gather statistics from the execution with the current\ntracing parameters, in the defined global and local environments. If not\ndefined, globals and locals default to empty dictionaries.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "trace.Trace.runfunc()", "path": "library/trace#trace.Trace.runfunc", "type": "Debugging & Profiling", "text": "\nCall func with the given arguments under control of the `Trace` object with\nthe current tracing parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "traceback", "path": "library/traceback", "type": "Runtime", "text": "\nSource code: Lib/traceback.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "traceback.clear_frames()", "path": "library/traceback#traceback.clear_frames", "type": "Runtime", "text": "\nClears the local variables of all the stack frames in a traceback tb by\ncalling the `clear()` method of each frame object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "traceback.extract_stack()", "path": "library/traceback#traceback.extract_stack", "type": "Runtime", "text": "\nExtract the raw traceback from the current stack frame. The return value has\nthe same format as for `extract_tb()`. The optional f and limit arguments have\nthe same meaning as for `print_stack()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "traceback.extract_tb()", "path": "library/traceback#traceback.extract_tb", "type": "Runtime", "text": "\nReturn a `StackSummary` object representing a list of \u201cpre-processed\u201d stack\ntrace entries extracted from the traceback object tb. It is useful for\nalternate formatting of stack traces. The optional limit argument has the same\nmeaning as for `print_tb()`. A \u201cpre-processed\u201d stack trace entry is a\n`FrameSummary` object containing attributes `filename`, `lineno`, `name`, and\n`line` representing the information that is usually printed for a stack trace.\nThe `line` is a string with leading and trailing whitespace stripped; if the\nsource is not available it is `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "traceback.format_exc()", "path": "library/traceback#traceback.format_exc", "type": "Runtime", "text": "\nThis is like `print_exc(limit)` but returns a string instead of printing to a\nfile.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "traceback.format_exception()", "path": "library/traceback#traceback.format_exception", "type": "Runtime", "text": "\nFormat a stack trace and the exception information. The arguments have the\nsame meaning as the corresponding arguments to `print_exception()`. The return\nvalue is a list of strings, each ending in a newline and some containing\ninternal newlines. When these lines are concatenated and printed, exactly the\nsame text is printed as does `print_exception()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "traceback.format_exception_only()", "path": "library/traceback#traceback.format_exception_only", "type": "Runtime", "text": "\nFormat the exception part of a traceback. The arguments are the exception type\nand value such as given by `sys.last_type` and `sys.last_value`. The return\nvalue is a list of strings, each ending in a newline. Normally, the list\ncontains a single string; however, for `SyntaxError` exceptions, it contains\nseveral lines that (when printed) display detailed information about where the\nsyntax error occurred. The message indicating which exception occurred is the\nalways last string in the list.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "traceback.format_list()", "path": "library/traceback#traceback.format_list", "type": "Runtime", "text": "\nGiven a list of tuples or `FrameSummary` objects as returned by `extract_tb()`\nor `extract_stack()`, return a list of strings ready for printing. Each string\nin the resulting list corresponds to the item with the same index in the\nargument list. Each string ends in a newline; the strings may contain internal\nnewlines as well, for those items whose source text line is not `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "traceback.format_stack()", "path": "library/traceback#traceback.format_stack", "type": "Runtime", "text": "\nA shorthand for `format_list(extract_stack(f, limit))`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "traceback.format_tb()", "path": "library/traceback#traceback.format_tb", "type": "Runtime", "text": "\nA shorthand for `format_list(extract_tb(tb, limit))`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "traceback.FrameSummary", "path": "library/traceback#traceback.FrameSummary", "type": "Runtime", "text": "\nRepresent a single frame in the traceback or stack that is being formatted or\nprinted. It may optionally have a stringified version of the frames locals\nincluded in it. If lookup_line is `False`, the source code is not looked up\nuntil the `FrameSummary` has the `line` attribute accessed (which also happens\nwhen casting it to a tuple). `line` may be directly provided, and will prevent\nline lookups happening at all. locals is an optional local variable\ndictionary, and if supplied the variable representations are stored in the\nsummary for later display.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "traceback.print_exc()", "path": "library/traceback#traceback.print_exc", "type": "Runtime", "text": "\nThis is a shorthand for `print_exception(*sys.exc_info(), limit, file,\nchain)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "traceback.print_exception()", "path": "library/traceback#traceback.print_exception", "type": "Runtime", "text": "\nPrint exception information and stack trace entries from traceback object tb\nto file. This differs from `print_tb()` in the following ways:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "traceback.print_last()", "path": "library/traceback#traceback.print_last", "type": "Runtime", "text": "\nThis is a shorthand for `print_exception(sys.last_type, sys.last_value,\nsys.last_traceback, limit, file, chain)`. In general it will work only after\nan exception has reached an interactive prompt (see `sys.last_type`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "traceback.print_stack()", "path": "library/traceback#traceback.print_stack", "type": "Runtime", "text": "\nPrint up to limit stack trace entries (starting from the invocation point) if\nlimit is positive. Otherwise, print the last `abs(limit)` entries. If limit is\nomitted or `None`, all entries are printed. The optional f argument can be\nused to specify an alternate stack frame to start. The optional file argument\nhas the same meaning as for `print_tb()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "traceback.print_tb()", "path": "library/traceback#traceback.print_tb", "type": "Runtime", "text": "\nPrint up to limit stack trace entries from traceback object tb (starting from\nthe caller\u2019s frame) if limit is positive. Otherwise, print the last\n`abs(limit)` entries. If limit is omitted or `None`, all entries are printed.\nIf file is omitted or `None`, the output goes to `sys.stderr`; otherwise it\nshould be an open file or file-like object to receive the output.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "traceback.StackSummary", "path": "library/traceback#traceback.StackSummary", "type": "Runtime", "text": "\nConstruct a `StackSummary` object from a frame generator (such as is returned\nby `walk_stack()` or `walk_tb()`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "traceback.StackSummary.extract()", "path": "library/traceback#traceback.StackSummary.extract", "type": "Runtime", "text": "\nConstruct a `StackSummary` object from a frame generator (such as is returned\nby `walk_stack()` or `walk_tb()`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "traceback.StackSummary.format()", "path": "library/traceback#traceback.StackSummary.format", "type": "Runtime", "text": "\nReturns a list of strings ready for printing. Each string in the resulting\nlist corresponds to a single frame from the stack. Each string ends in a\nnewline; the strings may contain internal newlines as well, for those items\nwith source text lines.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "traceback.StackSummary.from_list()", "path": "library/traceback#traceback.StackSummary.from_list", "type": "Runtime", "text": "\nConstruct a `StackSummary` object from a supplied list of `FrameSummary`\nobjects or old-style list of tuples. Each tuple should be a 4-tuple with\nfilename, lineno, name, line as the elements.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "traceback.TracebackException", "path": "library/traceback#traceback.TracebackException", "type": "Runtime", "text": "\nCapture an exception for later rendering. limit, lookup_lines and\ncapture_locals are as for the `StackSummary` class.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "traceback.TracebackException.exc_type", "path": "library/traceback#traceback.TracebackException.exc_type", "type": "Runtime", "text": "\nThe class of the original traceback.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "traceback.TracebackException.filename", "path": "library/traceback#traceback.TracebackException.filename", "type": "Runtime", "text": "\nFor syntax errors - the file name where the error occurred.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "traceback.TracebackException.format()", "path": "library/traceback#traceback.TracebackException.format", "type": "Runtime", "text": "\nFormat the exception.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "traceback.TracebackException.format_exception_only()", "path": "library/traceback#traceback.TracebackException.format_exception_only", "type": "Runtime", "text": "\nFormat the exception part of the traceback.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "traceback.TracebackException.from_exception()", "path": "library/traceback#traceback.TracebackException.from_exception", "type": "Runtime", "text": "\nCapture an exception for later rendering. limit, lookup_lines and\ncapture_locals are as for the `StackSummary` class.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "traceback.TracebackException.lineno", "path": "library/traceback#traceback.TracebackException.lineno", "type": "Runtime", "text": "\nFor syntax errors - the line number where the error occurred.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "traceback.TracebackException.msg", "path": "library/traceback#traceback.TracebackException.msg", "type": "Runtime", "text": "\nFor syntax errors - the compiler error message.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "traceback.TracebackException.offset", "path": "library/traceback#traceback.TracebackException.offset", "type": "Runtime", "text": "\nFor syntax errors - the offset into the text where the error occurred.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "traceback.TracebackException.stack", "path": "library/traceback#traceback.TracebackException.stack", "type": "Runtime", "text": "\nA `StackSummary` representing the traceback.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "traceback.TracebackException.text", "path": "library/traceback#traceback.TracebackException.text", "type": "Runtime", "text": "\nFor syntax errors - the text where the error occurred.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "traceback.TracebackException.__cause__", "path": "library/traceback#traceback.TracebackException.__cause__", "type": "Runtime", "text": "\nA `TracebackException` of the original `__cause__`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "traceback.TracebackException.__context__", "path": "library/traceback#traceback.TracebackException.__context__", "type": "Runtime", "text": "\nA `TracebackException` of the original `__context__`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "traceback.TracebackException.__suppress_context__", "path": "library/traceback#traceback.TracebackException.__suppress_context__", "type": "Runtime", "text": "\nThe `__suppress_context__` value from the original exception.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "traceback.walk_stack()", "path": "library/traceback#traceback.walk_stack", "type": "Runtime", "text": "\nWalk a stack following `f.f_back` from the given frame, yielding the frame and\nline number for each frame. If f is `None`, the current stack is used. This\nhelper is used with `StackSummary.extract()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "traceback.walk_tb()", "path": "library/traceback#traceback.walk_tb", "type": "Runtime", "text": "\nWalk a traceback following `tb_next` yielding the frame and line number for\neach frame. This helper is used with `StackSummary.extract()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc", "path": "library/tracemalloc", "type": "Debugging & Profiling", "text": "\nNew in version 3.4.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.clear_traces()", "path": "library/tracemalloc#tracemalloc.clear_traces", "type": "Debugging & Profiling", "text": "\nClear traces of memory blocks allocated by Python.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.DomainFilter", "path": "library/tracemalloc#tracemalloc.DomainFilter", "type": "Debugging & Profiling", "text": "\nFilter traces of memory blocks by their address space (domain).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.DomainFilter.domain", "path": "library/tracemalloc#tracemalloc.DomainFilter.domain", "type": "Debugging & Profiling", "text": "\nAddress space of a memory block (`int`). Read-only property.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.DomainFilter.inclusive", "path": "library/tracemalloc#tracemalloc.DomainFilter.inclusive", "type": "Debugging & Profiling", "text": "\nIf inclusive is `True` (include), match memory blocks allocated in the address\nspace `domain`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.Filter", "path": "library/tracemalloc#tracemalloc.Filter", "type": "Debugging & Profiling", "text": "\nFilter on traces of memory blocks.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.Filter.all_frames", "path": "library/tracemalloc#tracemalloc.Filter.all_frames", "type": "Debugging & Profiling", "text": "\nIf all_frames is `True`, all frames of the traceback are checked. If\nall_frames is `False`, only the most recent frame is checked.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.Filter.domain", "path": "library/tracemalloc#tracemalloc.Filter.domain", "type": "Debugging & Profiling", "text": "\nAddress space of a memory block (`int` or `None`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.Filter.filename_pattern", "path": "library/tracemalloc#tracemalloc.Filter.filename_pattern", "type": "Debugging & Profiling", "text": "\nFilename pattern of the filter (`str`). Read-only property.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.Filter.inclusive", "path": "library/tracemalloc#tracemalloc.Filter.inclusive", "type": "Debugging & Profiling", "text": "\nIf inclusive is `True` (include), only match memory blocks allocated in a file\nwith a name matching `filename_pattern` at line number `lineno`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.Filter.lineno", "path": "library/tracemalloc#tracemalloc.Filter.lineno", "type": "Debugging & Profiling", "text": "\nLine number (`int`) of the filter. If lineno is `None`, the filter matches any\nline number.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.Frame", "path": "library/tracemalloc#tracemalloc.Frame", "type": "Debugging & Profiling", "text": "\nFrame of a traceback.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.Frame.filename", "path": "library/tracemalloc#tracemalloc.Frame.filename", "type": "Debugging & Profiling", "text": "\nFilename (`str`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.Frame.lineno", "path": "library/tracemalloc#tracemalloc.Frame.lineno", "type": "Debugging & Profiling", "text": "\nLine number (`int`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.get_object_traceback()", "path": "library/tracemalloc#tracemalloc.get_object_traceback", "type": "Debugging & Profiling", "text": "\nGet the traceback where the Python object obj was allocated. Return a\n`Traceback` instance, or `None` if the `tracemalloc` module is not tracing\nmemory allocations or did not trace the allocation of the object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.get_traceback_limit()", "path": "library/tracemalloc#tracemalloc.get_traceback_limit", "type": "Debugging & Profiling", "text": "\nGet the maximum number of frames stored in the traceback of a trace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.get_traced_memory()", "path": "library/tracemalloc#tracemalloc.get_traced_memory", "type": "Debugging & Profiling", "text": "\nGet the current size and peak size of memory blocks traced by the\n`tracemalloc` module as a tuple: `(current: int, peak: int)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.get_tracemalloc_memory()", "path": "library/tracemalloc#tracemalloc.get_tracemalloc_memory", "type": "Debugging & Profiling", "text": "\nGet the memory usage in bytes of the `tracemalloc` module used to store traces\nof memory blocks. Return an `int`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.is_tracing()", "path": "library/tracemalloc#tracemalloc.is_tracing", "type": "Debugging & Profiling", "text": "\n`True` if the `tracemalloc` module is tracing Python memory allocations,\n`False` otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.reset_peak()", "path": "library/tracemalloc#tracemalloc.reset_peak", "type": "Debugging & Profiling", "text": "\nSet the peak size of memory blocks traced by the `tracemalloc` module to the\ncurrent size.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.Snapshot", "path": "library/tracemalloc#tracemalloc.Snapshot", "type": "Debugging & Profiling", "text": "\nSnapshot of traces of memory blocks allocated by Python.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.Snapshot.compare_to()", "path": "library/tracemalloc#tracemalloc.Snapshot.compare_to", "type": "Debugging & Profiling", "text": "\nCompute the differences with an old snapshot. Get statistics as a sorted list\nof `StatisticDiff` instances grouped by key_type.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.Snapshot.dump()", "path": "library/tracemalloc#tracemalloc.Snapshot.dump", "type": "Debugging & Profiling", "text": "\nWrite the snapshot into a file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.Snapshot.filter_traces()", "path": "library/tracemalloc#tracemalloc.Snapshot.filter_traces", "type": "Debugging & Profiling", "text": "\nCreate a new `Snapshot` instance with a filtered `traces` sequence, filters is\na list of `DomainFilter` and `Filter` instances. If filters is an empty list,\nreturn a new `Snapshot` instance with a copy of the traces.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.Snapshot.load()", "path": "library/tracemalloc#tracemalloc.Snapshot.load", "type": "Debugging & Profiling", "text": "\nLoad a snapshot from a file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.Snapshot.statistics()", "path": "library/tracemalloc#tracemalloc.Snapshot.statistics", "type": "Debugging & Profiling", "text": "\nGet statistics as a sorted list of `Statistic` instances grouped by key_type:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.Snapshot.traceback_limit", "path": "library/tracemalloc#tracemalloc.Snapshot.traceback_limit", "type": "Debugging & Profiling", "text": "\nMaximum number of frames stored in the traceback of `traces`: result of the\n`get_traceback_limit()` when the snapshot was taken.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.Snapshot.traces", "path": "library/tracemalloc#tracemalloc.Snapshot.traces", "type": "Debugging & Profiling", "text": "\nTraces of all memory blocks allocated by Python: sequence of `Trace`\ninstances.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.start()", "path": "library/tracemalloc#tracemalloc.start", "type": "Debugging & Profiling", "text": "\nStart tracing Python memory allocations: install hooks on Python memory\nallocators. Collected tracebacks of traces will be limited to nframe frames.\nBy default, a trace of a memory block only stores the most recent frame: the\nlimit is `1`. nframe must be greater or equal to `1`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.Statistic", "path": "library/tracemalloc#tracemalloc.Statistic", "type": "Debugging & Profiling", "text": "\nStatistic on memory allocations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.Statistic.count", "path": "library/tracemalloc#tracemalloc.Statistic.count", "type": "Debugging & Profiling", "text": "\nNumber of memory blocks (`int`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.Statistic.size", "path": "library/tracemalloc#tracemalloc.Statistic.size", "type": "Debugging & Profiling", "text": "\nTotal size of memory blocks in bytes (`int`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.Statistic.traceback", "path": "library/tracemalloc#tracemalloc.Statistic.traceback", "type": "Debugging & Profiling", "text": "\nTraceback where the memory block was allocated, `Traceback` instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.StatisticDiff", "path": "library/tracemalloc#tracemalloc.StatisticDiff", "type": "Debugging & Profiling", "text": "\nStatistic difference on memory allocations between an old and a new `Snapshot`\ninstance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.StatisticDiff.count", "path": "library/tracemalloc#tracemalloc.StatisticDiff.count", "type": "Debugging & Profiling", "text": "\nNumber of memory blocks in the new snapshot (`int`): `0` if the memory blocks\nhave been released in the new snapshot.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.StatisticDiff.count_diff", "path": "library/tracemalloc#tracemalloc.StatisticDiff.count_diff", "type": "Debugging & Profiling", "text": "\nDifference of number of memory blocks between the old and the new snapshots\n(`int`): `0` if the memory blocks have been allocated in the new snapshot.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.StatisticDiff.size", "path": "library/tracemalloc#tracemalloc.StatisticDiff.size", "type": "Debugging & Profiling", "text": "\nTotal size of memory blocks in bytes in the new snapshot (`int`): `0` if the\nmemory blocks have been released in the new snapshot.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.StatisticDiff.size_diff", "path": "library/tracemalloc#tracemalloc.StatisticDiff.size_diff", "type": "Debugging & Profiling", "text": "\nDifference of total size of memory blocks in bytes between the old and the new\nsnapshots (`int`): `0` if the memory blocks have been allocated in the new\nsnapshot.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.StatisticDiff.traceback", "path": "library/tracemalloc#tracemalloc.StatisticDiff.traceback", "type": "Debugging & Profiling", "text": "\nTraceback where the memory blocks were allocated, `Traceback` instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.stop()", "path": "library/tracemalloc#tracemalloc.stop", "type": "Debugging & Profiling", "text": "\nStop tracing Python memory allocations: uninstall hooks on Python memory\nallocators. Also clears all previously collected traces of memory blocks\nallocated by Python.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.take_snapshot()", "path": "library/tracemalloc#tracemalloc.take_snapshot", "type": "Debugging & Profiling", "text": "\nTake a snapshot of traces of memory blocks allocated by Python. Return a new\n`Snapshot` instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.Trace", "path": "library/tracemalloc#tracemalloc.Trace", "type": "Debugging & Profiling", "text": "\nTrace of a memory block.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.Trace.domain", "path": "library/tracemalloc#tracemalloc.Trace.domain", "type": "Debugging & Profiling", "text": "\nAddress space of a memory block (`int`). Read-only property.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.Trace.size", "path": "library/tracemalloc#tracemalloc.Trace.size", "type": "Debugging & Profiling", "text": "\nSize of the memory block in bytes (`int`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.Trace.traceback", "path": "library/tracemalloc#tracemalloc.Trace.traceback", "type": "Debugging & Profiling", "text": "\nTraceback where the memory block was allocated, `Traceback` instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.Traceback", "path": "library/tracemalloc#tracemalloc.Traceback", "type": "Debugging & Profiling", "text": "\nSequence of `Frame` instances sorted from the oldest frame to the most recent\nframe.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.Traceback.format()", "path": "library/tracemalloc#tracemalloc.Traceback.format", "type": "Debugging & Profiling", "text": "\nFormat the traceback as a list of lines with newlines. Use the `linecache`\nmodule to retrieve lines from the source code. If limit is set, format the\nlimit most recent frames if limit is positive. Otherwise, format the\n`abs(limit)` oldest frames. If most_recent_first is `True`, the order of the\nformatted frames is reversed, returning the most recent frame first instead of\nlast.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tracemalloc.Traceback.total_nframe", "path": "library/tracemalloc#tracemalloc.Traceback.total_nframe", "type": "Debugging & Profiling", "text": "\nTotal number of frames that composed the traceback before truncation. This\nattribute can be set to `None` if the information is not available.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Transports and Protocols", "path": "library/asyncio-protocol", "type": "Asynchronous I/O", "text": "\nTransports and Protocols are used by the low-level event loop APIs such as\n`loop.create_connection()`. They use callback-based programming style and\nenable high-performance implementations of network or IPC protocols (e.g.\nHTTP).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "True", "path": "library/constants#True", "type": "Built-in Constants", "text": "\nThe true value of the `bool` type. Assignments to `True` are illegal and raise\na `SyntaxError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tty", "path": "library/tty", "type": "Unix", "text": "\nSource code: Lib/tty.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tty.setcbreak()", "path": "library/tty#tty.setcbreak", "type": "Unix", "text": "\nChange the mode of file descriptor fd to cbreak. If when is omitted, it\ndefaults to `termios.TCSAFLUSH`, and is passed to `termios.tcsetattr()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tty.setraw()", "path": "library/tty#tty.setraw", "type": "Unix", "text": "\nChange the mode of the file descriptor fd to raw. If when is omitted, it\ndefaults to `termios.TCSAFLUSH`, and is passed to `termios.tcsetattr()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tuple", "path": "library/stdtypes#tuple", "type": "Built-in Types", "text": "\nTuples may be constructed in a number of ways:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tuple", "path": "library/functions#tuple", "type": "Built-in Functions", "text": "\nRather than being a function, `tuple` is actually an immutable sequence type,\nas documented in Tuples and Sequence Types \u2014 list, tuple, range.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle", "path": "library/turtle", "type": "Frameworks", "text": "\nSource code: Lib/turtle.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.addshape()", "path": "library/turtle#turtle.addshape", "type": "Frameworks", "text": "\nThere are three different ways to call this function:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.back()", "path": "library/turtle#turtle.back", "type": "Frameworks", "text": "\ndistance \u2013 a number\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.backward()", "path": "library/turtle#turtle.backward", "type": "Frameworks", "text": "\ndistance \u2013 a number\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.begin_fill()", "path": "library/turtle#turtle.begin_fill", "type": "Frameworks", "text": "\nTo be called just before drawing a shape to be filled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.begin_poly()", "path": "library/turtle#turtle.begin_poly", "type": "Frameworks", "text": "\nStart recording the vertices of a polygon. Current turtle position is first\nvertex of polygon.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.bgcolor()", "path": "library/turtle#turtle.bgcolor", "type": "Frameworks", "text": "\nargs \u2013 a color string or three numbers in the range 0..colormode or a 3-tuple\nof such numbers\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.bgpic()", "path": "library/turtle#turtle.bgpic", "type": "Frameworks", "text": "\npicname \u2013 a string, name of a gif-file or `\"nopic\"`, or `None`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.bk()", "path": "library/turtle#turtle.bk", "type": "Frameworks", "text": "\ndistance \u2013 a number\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.bye()", "path": "library/turtle#turtle.bye", "type": "Frameworks", "text": "\nShut the turtlegraphics window.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.circle()", "path": "library/turtle#turtle.circle", "type": "Frameworks", "text": "\nDraw a circle with given radius. The center is radius units left of the\nturtle; extent \u2013 an angle \u2013 determines which part of the circle is drawn. If\nextent is not given, draw the entire circle. If extent is not a full circle,\none endpoint of the arc is the current pen position. Draw the arc in\ncounterclockwise direction if radius is positive, otherwise in clockwise\ndirection. Finally the direction of the turtle is changed by the amount of\nextent.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.clear()", "path": "library/turtle#turtle.clear", "type": "Frameworks", "text": "\nDelete all drawings and all turtles from the TurtleScreen. Reset the now empty\nTurtleScreen to its initial state: white background, no background image, no\nevent bindings and tracing on.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.clearscreen()", "path": "library/turtle#turtle.clearscreen", "type": "Frameworks", "text": "\nDelete all drawings and all turtles from the TurtleScreen. Reset the now empty\nTurtleScreen to its initial state: white background, no background image, no\nevent bindings and tracing on.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.clearstamp()", "path": "library/turtle#turtle.clearstamp", "type": "Frameworks", "text": "\nstampid \u2013 an integer, must be return value of previous `stamp()` call\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.clearstamps()", "path": "library/turtle#turtle.clearstamps", "type": "Frameworks", "text": "\nn \u2013 an integer (or `None`)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.clone()", "path": "library/turtle#turtle.clone", "type": "Frameworks", "text": "\nCreate and return a clone of the turtle with same position, heading and turtle\nproperties.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.color()", "path": "library/turtle#turtle.color", "type": "Frameworks", "text": "\nReturn or set pencolor and fillcolor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.colormode()", "path": "library/turtle#turtle.colormode", "type": "Frameworks", "text": "\ncmode \u2013 one of the values 1.0 or 255\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.degrees()", "path": "library/turtle#turtle.degrees", "type": "Frameworks", "text": "\nfullcircle \u2013 a number\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.delay()", "path": "library/turtle#turtle.delay", "type": "Frameworks", "text": "\ndelay \u2013 positive integer\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.distance()", "path": "library/turtle#turtle.distance", "type": "Frameworks", "text": "\nReturn the distance from the turtle to (x,y), the given vector, or the given\nother turtle, in turtle step units.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.done()", "path": "library/turtle#turtle.done", "type": "Frameworks", "text": "\nStarts event loop - calling Tkinter\u2019s mainloop function. Must be the last\nstatement in a turtle graphics program. Must not be used if a script is run\nfrom within IDLE in -n mode (No subprocess) - for interactive use of turtle\ngraphics.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.dot()", "path": "library/turtle#turtle.dot", "type": "Frameworks", "text": "\nDraw a circular dot with diameter size, using color. If size is not given, the\nmaximum of pensize+4 and 2*pensize is used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.down()", "path": "library/turtle#turtle.down", "type": "Frameworks", "text": "\nPull the pen down \u2013 drawing when moving.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.end_fill()", "path": "library/turtle#turtle.end_fill", "type": "Frameworks", "text": "\nFill the shape drawn after the last call to `begin_fill()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.end_poly()", "path": "library/turtle#turtle.end_poly", "type": "Frameworks", "text": "\nStop recording the vertices of a polygon. Current turtle position is last\nvertex of polygon. This will be connected with the first vertex.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.exitonclick()", "path": "library/turtle#turtle.exitonclick", "type": "Frameworks", "text": "\nBind `bye()` method to mouse clicks on the Screen.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.fd()", "path": "library/turtle#turtle.fd", "type": "Frameworks", "text": "\ndistance \u2013 a number (integer or float)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.fillcolor()", "path": "library/turtle#turtle.fillcolor", "type": "Frameworks", "text": "\nReturn or set the fillcolor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.filling()", "path": "library/turtle#turtle.filling", "type": "Frameworks", "text": "\nReturn fillstate (`True` if filling, `False` else).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.forward()", "path": "library/turtle#turtle.forward", "type": "Frameworks", "text": "\ndistance \u2013 a number (integer or float)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.getcanvas()", "path": "library/turtle#turtle.getcanvas", "type": "Frameworks", "text": "\nReturn the Canvas of this TurtleScreen. Useful for insiders who know what to\ndo with a Tkinter Canvas.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.getpen()", "path": "library/turtle#turtle.getpen", "type": "Frameworks", "text": "\nReturn the Turtle object itself. Only reasonable use: as a function to return\nthe \u201canonymous turtle\u201d:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.getscreen()", "path": "library/turtle#turtle.getscreen", "type": "Frameworks", "text": "\nReturn the `TurtleScreen` object the turtle is drawing on. TurtleScreen\nmethods can then be called for that object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.getshapes()", "path": "library/turtle#turtle.getshapes", "type": "Frameworks", "text": "\nReturn a list of names of all currently available turtle shapes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.getturtle()", "path": "library/turtle#turtle.getturtle", "type": "Frameworks", "text": "\nReturn the Turtle object itself. Only reasonable use: as a function to return\nthe \u201canonymous turtle\u201d:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.get_poly()", "path": "library/turtle#turtle.get_poly", "type": "Frameworks", "text": "\nReturn the last recorded polygon.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.get_shapepoly()", "path": "library/turtle#turtle.get_shapepoly", "type": "Frameworks", "text": "\nReturn the current shape polygon as tuple of coordinate pairs. This can be\nused to define a new shape or components of a compound shape.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.goto()", "path": "library/turtle#turtle.goto", "type": "Frameworks", "text": "\nIf y is `None`, x must be a pair of coordinates or a `Vec2D` (e.g. as returned\nby `pos()`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.heading()", "path": "library/turtle#turtle.heading", "type": "Frameworks", "text": "\nReturn the turtle\u2019s current heading (value depends on the turtle mode, see\n`mode()`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.hideturtle()", "path": "library/turtle#turtle.hideturtle", "type": "Frameworks", "text": "\nMake the turtle invisible. It\u2019s a good idea to do this while you\u2019re in the\nmiddle of doing some complex drawing, because hiding the turtle speeds up the\ndrawing observably.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.home()", "path": "library/turtle#turtle.home", "type": "Frameworks", "text": "\nMove turtle to the origin \u2013 coordinates (0,0) \u2013 and set its heading to its\nstart-orientation (which depends on the mode, see `mode()`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.ht()", "path": "library/turtle#turtle.ht", "type": "Frameworks", "text": "\nMake the turtle invisible. It\u2019s a good idea to do this while you\u2019re in the\nmiddle of doing some complex drawing, because hiding the turtle speeds up the\ndrawing observably.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.isdown()", "path": "library/turtle#turtle.isdown", "type": "Frameworks", "text": "\nReturn `True` if pen is down, `False` if it\u2019s up.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.isvisible()", "path": "library/turtle#turtle.isvisible", "type": "Frameworks", "text": "\nReturn `True` if the Turtle is shown, `False` if it\u2019s hidden.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.left()", "path": "library/turtle#turtle.left", "type": "Frameworks", "text": "\nangle \u2013 a number (integer or float)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.listen()", "path": "library/turtle#turtle.listen", "type": "Frameworks", "text": "\nSet focus on TurtleScreen (in order to collect key-events). Dummy arguments\nare provided in order to be able to pass `listen()` to the onclick method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.lt()", "path": "library/turtle#turtle.lt", "type": "Frameworks", "text": "\nangle \u2013 a number (integer or float)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.mainloop()", "path": "library/turtle#turtle.mainloop", "type": "Frameworks", "text": "\nStarts event loop - calling Tkinter\u2019s mainloop function. Must be the last\nstatement in a turtle graphics program. Must not be used if a script is run\nfrom within IDLE in -n mode (No subprocess) - for interactive use of turtle\ngraphics.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.mode()", "path": "library/turtle#turtle.mode", "type": "Frameworks", "text": "\nmode \u2013 one of the strings \u201cstandard\u201d, \u201clogo\u201d or \u201cworld\u201d\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.numinput()", "path": "library/turtle#turtle.numinput", "type": "Frameworks", "text": "\nPop up a dialog window for input of a number. title is the title of the dialog\nwindow, prompt is a text mostly describing what numerical information to\ninput. default: default value, minval: minimum value for input, maxval:\nmaximum value for input The number input must be in the range minval .. maxval\nif these are given. If not, a hint is issued and the dialog remains open for\ncorrection. Return the number input. If the dialog is canceled, return `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.onclick()", "path": "library/turtle#turtle.onclick", "type": "Frameworks", "text": "\nBind fun to mouse-click events on this screen. If fun is `None`, existing\nbindings are removed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.ondrag()", "path": "library/turtle#turtle.ondrag", "type": "Frameworks", "text": "\nBind fun to mouse-move events on this turtle. If fun is `None`, existing\nbindings are removed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.onkey()", "path": "library/turtle#turtle.onkey", "type": "Frameworks", "text": "\nBind fun to key-release event of key. If fun is `None`, event bindings are\nremoved. Remark: in order to be able to register key-events, TurtleScreen must\nhave the focus. (See method `listen()`.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.onkeypress()", "path": "library/turtle#turtle.onkeypress", "type": "Frameworks", "text": "\nBind fun to key-press event of key if key is given, or to any key-press-event\nif no key is given. Remark: in order to be able to register key-events,\nTurtleScreen must have focus. (See method `listen()`.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.onkeyrelease()", "path": "library/turtle#turtle.onkeyrelease", "type": "Frameworks", "text": "\nBind fun to key-release event of key. If fun is `None`, event bindings are\nremoved. Remark: in order to be able to register key-events, TurtleScreen must\nhave the focus. (See method `listen()`.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.onrelease()", "path": "library/turtle#turtle.onrelease", "type": "Frameworks", "text": "\nBind fun to mouse-button-release events on this turtle. If fun is `None`,\nexisting bindings are removed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.onscreenclick()", "path": "library/turtle#turtle.onscreenclick", "type": "Frameworks", "text": "\nBind fun to mouse-click events on this screen. If fun is `None`, existing\nbindings are removed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.ontimer()", "path": "library/turtle#turtle.ontimer", "type": "Frameworks", "text": "\nInstall a timer that calls fun after t milliseconds.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.pd()", "path": "library/turtle#turtle.pd", "type": "Frameworks", "text": "\nPull the pen down \u2013 drawing when moving.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.pen()", "path": "library/turtle#turtle.pen", "type": "Frameworks", "text": "\nReturn or set the pen\u2019s attributes in a \u201cpen-dictionary\u201d with the following\nkey/value pairs:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.pencolor()", "path": "library/turtle#turtle.pencolor", "type": "Frameworks", "text": "\nReturn or set the pencolor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.pendown()", "path": "library/turtle#turtle.pendown", "type": "Frameworks", "text": "\nPull the pen down \u2013 drawing when moving.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.pensize()", "path": "library/turtle#turtle.pensize", "type": "Frameworks", "text": "\nwidth \u2013 a positive number\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.penup()", "path": "library/turtle#turtle.penup", "type": "Frameworks", "text": "\nPull the pen up \u2013 no drawing when moving.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.pos()", "path": "library/turtle#turtle.pos", "type": "Frameworks", "text": "\nReturn the turtle\u2019s current location (x,y) (as a `Vec2D` vector).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.position()", "path": "library/turtle#turtle.position", "type": "Frameworks", "text": "\nReturn the turtle\u2019s current location (x,y) (as a `Vec2D` vector).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.pu()", "path": "library/turtle#turtle.pu", "type": "Frameworks", "text": "\nPull the pen up \u2013 no drawing when moving.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.radians()", "path": "library/turtle#turtle.radians", "type": "Frameworks", "text": "\nSet the angle measurement units to radians. Equivalent to\n`degrees(2*math.pi)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.RawPen", "path": "library/turtle#turtle.RawPen", "type": "Frameworks", "text": "\ncanvas \u2013 a `tkinter.Canvas`, a `ScrolledCanvas` or a `TurtleScreen`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.RawTurtle", "path": "library/turtle#turtle.RawTurtle", "type": "Frameworks", "text": "\ncanvas \u2013 a `tkinter.Canvas`, a `ScrolledCanvas` or a `TurtleScreen`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.register_shape()", "path": "library/turtle#turtle.register_shape", "type": "Frameworks", "text": "\nThere are three different ways to call this function:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.reset()", "path": "library/turtle#turtle.reset", "type": "Frameworks", "text": "\nReset all Turtles on the Screen to their initial state.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.resetscreen()", "path": "library/turtle#turtle.resetscreen", "type": "Frameworks", "text": "\nReset all Turtles on the Screen to their initial state.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.resizemode()", "path": "library/turtle#turtle.resizemode", "type": "Frameworks", "text": "\nrmode \u2013 one of the strings \u201cauto\u201d, \u201cuser\u201d, \u201cnoresize\u201d\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.right()", "path": "library/turtle#turtle.right", "type": "Frameworks", "text": "\nangle \u2013 a number (integer or float)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.rt()", "path": "library/turtle#turtle.rt", "type": "Frameworks", "text": "\nangle \u2013 a number (integer or float)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.Screen", "path": "library/turtle#turtle.Screen", "type": "Frameworks", "text": "\nSubclass of TurtleScreen, with four methods added.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.screensize()", "path": "library/turtle#turtle.screensize", "type": "Frameworks", "text": "\nIf no arguments are given, return current (canvaswidth, canvasheight). Else\nresize the canvas the turtles are drawing on. Do not alter the drawing window.\nTo observe hidden parts of the canvas, use the scrollbars. With this method,\none can make visible those parts of a drawing which were outside the canvas\nbefore.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.ScrolledCanvas", "path": "library/turtle#turtle.ScrolledCanvas", "type": "Frameworks", "text": "\nmaster \u2013 some Tkinter widget to contain the ScrolledCanvas, i.e. a Tkinter-\ncanvas with scrollbars added\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.seth()", "path": "library/turtle#turtle.seth", "type": "Frameworks", "text": "\nto_angle \u2013 a number (integer or float)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.setheading()", "path": "library/turtle#turtle.setheading", "type": "Frameworks", "text": "\nto_angle \u2013 a number (integer or float)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.setpos()", "path": "library/turtle#turtle.setpos", "type": "Frameworks", "text": "\nIf y is `None`, x must be a pair of coordinates or a `Vec2D` (e.g. as returned\nby `pos()`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.setposition()", "path": "library/turtle#turtle.setposition", "type": "Frameworks", "text": "\nIf y is `None`, x must be a pair of coordinates or a `Vec2D` (e.g. as returned\nby `pos()`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.settiltangle()", "path": "library/turtle#turtle.settiltangle", "type": "Frameworks", "text": "\nangle \u2013 a number\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.setundobuffer()", "path": "library/turtle#turtle.setundobuffer", "type": "Frameworks", "text": "\nsize \u2013 an integer or `None`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.setup()", "path": "library/turtle#turtle.setup", "type": "Frameworks", "text": "\nSet the size and position of the main window. Default values of arguments are\nstored in the configuration dictionary and can be changed via a `turtle.cfg`\nfile.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.setworldcoordinates()", "path": "library/turtle#turtle.setworldcoordinates", "type": "Frameworks", "text": "\nSet up user-defined coordinate system and switch to mode \u201cworld\u201d if necessary.\nThis performs a `screen.reset()`. If mode \u201cworld\u201d is already active, all\ndrawings are redrawn according to the new coordinates.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.setx()", "path": "library/turtle#turtle.setx", "type": "Frameworks", "text": "\nx \u2013 a number (integer or float)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.sety()", "path": "library/turtle#turtle.sety", "type": "Frameworks", "text": "\ny \u2013 a number (integer or float)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.Shape", "path": "library/turtle#turtle.Shape", "type": "Frameworks", "text": "\ntype_ \u2013 one of the strings \u201cpolygon\u201d, \u201cimage\u201d, \u201ccompound\u201d\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.shape()", "path": "library/turtle#turtle.shape", "type": "Frameworks", "text": "\nname \u2013 a string which is a valid shapename\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.Shape.addcomponent()", "path": "library/turtle#turtle.Shape.addcomponent", "type": "Frameworks", "text": "\nExample:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.shapesize()", "path": "library/turtle#turtle.shapesize", "type": "Frameworks", "text": "\nReturn or set the pen\u2019s attributes x/y-stretchfactors and/or outline. Set\nresizemode to \u201cuser\u201d. If and only if resizemode is set to \u201cuser\u201d, the turtle\nwill be displayed stretched according to its stretchfactors: stretch_wid is\nstretchfactor perpendicular to its orientation, stretch_len is stretchfactor\nin direction of its orientation, outline determines the width of the shapes\u2019s\noutline.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.shapetransform()", "path": "library/turtle#turtle.shapetransform", "type": "Frameworks", "text": "\nSet or return the current transformation matrix of the turtle shape.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.shearfactor()", "path": "library/turtle#turtle.shearfactor", "type": "Frameworks", "text": "\nshear \u2013 number (optional)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.showturtle()", "path": "library/turtle#turtle.showturtle", "type": "Frameworks", "text": "\nMake the turtle visible.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.speed()", "path": "library/turtle#turtle.speed", "type": "Frameworks", "text": "\nspeed \u2013 an integer in the range 0..10 or a speedstring (see below)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.st()", "path": "library/turtle#turtle.st", "type": "Frameworks", "text": "\nMake the turtle visible.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.stamp()", "path": "library/turtle#turtle.stamp", "type": "Frameworks", "text": "\nStamp a copy of the turtle shape onto the canvas at the current turtle\nposition. Return a stamp_id for that stamp, which can be used to delete it by\ncalling `clearstamp(stamp_id)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.textinput()", "path": "library/turtle#turtle.textinput", "type": "Frameworks", "text": "\nPop up a dialog window for input of a string. Parameter title is the title of\nthe dialog window, prompt is a text mostly describing what information to\ninput. Return the string input. If the dialog is canceled, return `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.tilt()", "path": "library/turtle#turtle.tilt", "type": "Frameworks", "text": "\nangle \u2013 a number\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.tiltangle()", "path": "library/turtle#turtle.tiltangle", "type": "Frameworks", "text": "\nangle \u2013 a number (optional)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.title()", "path": "library/turtle#turtle.title", "type": "Frameworks", "text": "\ntitlestring \u2013 a string that is shown in the titlebar of the turtle graphics\nwindow\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.towards()", "path": "library/turtle#turtle.towards", "type": "Frameworks", "text": "\nReturn the angle between the line from turtle position to position specified\nby (x,y), the vector or the other turtle. This depends on the turtle\u2019s start\norientation which depends on the mode - \u201cstandard\u201d/\u201dworld\u201d or \u201clogo\u201d.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.tracer()", "path": "library/turtle#turtle.tracer", "type": "Frameworks", "text": "\nTurn turtle animation on/off and set delay for update drawings. If n is given,\nonly each n-th regular screen update is really performed. (Can be used to\naccelerate the drawing of complex graphics.) When called without arguments,\nreturns the currently stored value of n. Second argument sets delay value (see\n`delay()`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.Turtle", "path": "library/turtle#turtle.Turtle", "type": "Frameworks", "text": "\nSubclass of RawTurtle, has the same interface but draws on a default `Screen`\nobject created automatically when needed for the first time.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.turtles()", "path": "library/turtle#turtle.turtles", "type": "Frameworks", "text": "\nReturn the list of turtles on the screen.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.TurtleScreen", "path": "library/turtle#turtle.TurtleScreen", "type": "Frameworks", "text": "\ncv \u2013 a `tkinter.Canvas`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.turtlesize()", "path": "library/turtle#turtle.turtlesize", "type": "Frameworks", "text": "\nReturn or set the pen\u2019s attributes x/y-stretchfactors and/or outline. Set\nresizemode to \u201cuser\u201d. If and only if resizemode is set to \u201cuser\u201d, the turtle\nwill be displayed stretched according to its stretchfactors: stretch_wid is\nstretchfactor perpendicular to its orientation, stretch_len is stretchfactor\nin direction of its orientation, outline determines the width of the shapes\u2019s\noutline.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.undo()", "path": "library/turtle#turtle.undo", "type": "Frameworks", "text": "\nUndo (repeatedly) the last turtle action(s). Number of available undo actions\nis determined by the size of the undobuffer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.undobufferentries()", "path": "library/turtle#turtle.undobufferentries", "type": "Frameworks", "text": "\nReturn number of entries in the undobuffer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.up()", "path": "library/turtle#turtle.up", "type": "Frameworks", "text": "\nPull the pen up \u2013 no drawing when moving.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.update()", "path": "library/turtle#turtle.update", "type": "Frameworks", "text": "\nPerform a TurtleScreen update. To be used when tracer is turned off.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.Vec2D", "path": "library/turtle#turtle.Vec2D", "type": "Frameworks", "text": "\nA two-dimensional vector class, used as a helper class for implementing turtle\ngraphics. May be useful for turtle graphics programs too. Derived from tuple,\nso a vector is a tuple!\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.width()", "path": "library/turtle#turtle.width", "type": "Frameworks", "text": "\nwidth \u2013 a positive number\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.window_height()", "path": "library/turtle#turtle.window_height", "type": "Frameworks", "text": "\nReturn the height of the turtle window.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.window_width()", "path": "library/turtle#turtle.window_width", "type": "Frameworks", "text": "\nReturn the width of the turtle window.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.write()", "path": "library/turtle#turtle.write", "type": "Frameworks", "text": "\nWrite text - the string representation of arg \\- at the current turtle\nposition according to align (\u201cleft\u201d, \u201ccenter\u201d or \u201cright\u201d) and with the given\nfont. If move is true, the pen is moved to the bottom-right corner of the\ntext. By default, move is `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.write_docstringdict()", "path": "library/turtle#turtle.write_docstringdict", "type": "Frameworks", "text": "\nfilename \u2013 a string, used as filename\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.xcor()", "path": "library/turtle#turtle.xcor", "type": "Frameworks", "text": "\nReturn the turtle\u2019s x coordinate.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "turtle.ycor()", "path": "library/turtle#turtle.ycor", "type": "Frameworks", "text": "\nReturn the turtle\u2019s y coordinate.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "type", "path": "library/functions#type", "type": "Built-in Functions", "text": "\nWith one argument, return the type of an object. The return value is a type\nobject and generally the same object as returned by `object.__class__`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "TypeError", "path": "library/exceptions#TypeError", "type": "Built-in Exceptions", "text": "\nRaised when an operation or function is applied to an object of inappropriate\ntype. The associated value is a string giving details about the type mismatch.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Types", "path": "library/stdtypes", "type": "Built-in Types", "text": "\nThe following sections describe the standard types that are built into the\ninterpreter.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "types", "path": "library/types", "type": "Data Types", "text": "\nSource code: Lib/types.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "types.AsyncGeneratorType", "path": "library/types#types.AsyncGeneratorType", "type": "Data Types", "text": "\nThe type of asynchronous generator-iterator objects, created by asynchronous\ngenerator functions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "types.BuiltinFunctionType", "path": "library/types#types.BuiltinFunctionType", "type": "Data Types", "text": "\nThe type of built-in functions like `len()` or `sys.exit()`, and methods of\nbuilt-in classes. (Here, the term \u201cbuilt-in\u201d means \u201cwritten in C\u201d.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "types.BuiltinMethodType", "path": "library/types#types.BuiltinMethodType", "type": "Data Types", "text": "\nThe type of built-in functions like `len()` or `sys.exit()`, and methods of\nbuilt-in classes. (Here, the term \u201cbuilt-in\u201d means \u201cwritten in C\u201d.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "types.CellType", "path": "library/types#types.CellType", "type": "Data Types", "text": "\nThe type for cell objects: such objects are used as containers for a\nfunction\u2019s free variables.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "types.ClassMethodDescriptorType", "path": "library/types#types.ClassMethodDescriptorType", "type": "Data Types", "text": "\nThe type of unbound class methods of some built-in data types such as\n`dict.__dict__['fromkeys']`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "types.CodeType", "path": "library/types#types.CodeType", "type": "Data Types", "text": "\nThe type for code objects such as returned by `compile()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "types.CodeType.replace()", "path": "library/types#types.CodeType.replace", "type": "Data Types", "text": "\nReturn a copy of the code object with new values for the specified fields.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "types.coroutine()", "path": "library/types#types.coroutine", "type": "Data Types", "text": "\nThis function transforms a generator function into a coroutine function which\nreturns a generator-based coroutine. The generator-based coroutine is still a\ngenerator iterator, but is also considered to be a coroutine object and is\nawaitable. However, it may not necessarily implement the `__await__()` method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "types.CoroutineType", "path": "library/types#types.CoroutineType", "type": "Data Types", "text": "\nThe type of coroutine objects, created by `async def` functions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "types.DynamicClassAttribute()", "path": "library/types#types.DynamicClassAttribute", "type": "Data Types", "text": "\nRoute attribute access on a class to __getattr__.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "types.FrameType", "path": "library/types#types.FrameType", "type": "Data Types", "text": "\nThe type of frame objects such as found in `tb.tb_frame` if `tb` is a\ntraceback object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "types.FunctionType", "path": "library/types#types.FunctionType", "type": "Data Types", "text": "\nThe type of user-defined functions and functions created by `lambda`\nexpressions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "types.GeneratorType", "path": "library/types#types.GeneratorType", "type": "Data Types", "text": "\nThe type of generator-iterator objects, created by generator functions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "types.GenericAlias", "path": "library/types#types.GenericAlias", "type": "Data Types", "text": "\nThe type of parameterized generics such as `list[int]`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "types.GetSetDescriptorType", "path": "library/types#types.GetSetDescriptorType", "type": "Data Types", "text": "\nThe type of objects defined in extension modules with `PyGetSetDef`, such as\n`FrameType.f_locals` or `array.array.typecode`. This type is used as\ndescriptor for object attributes; it has the same purpose as the `property`\ntype, but for classes defined in extension modules.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "types.LambdaType", "path": "library/types#types.LambdaType", "type": "Data Types", "text": "\nThe type of user-defined functions and functions created by `lambda`\nexpressions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "types.MappingProxyType", "path": "library/types#types.MappingProxyType", "type": "Data Types", "text": "\nRead-only proxy of a mapping. It provides a dynamic view on the mapping\u2019s\nentries, which means that when the mapping changes, the view reflects these\nchanges.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "types.MappingProxyType.copy()", "path": "library/types#types.MappingProxyType.copy", "type": "Data Types", "text": "\nReturn a shallow copy of the underlying mapping.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "types.MappingProxyType.get()", "path": "library/types#types.MappingProxyType.get", "type": "Data Types", "text": "\nReturn the value for key if key is in the underlying mapping, else default. If\ndefault is not given, it defaults to `None`, so that this method never raises\na `KeyError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "types.MappingProxyType.items()", "path": "library/types#types.MappingProxyType.items", "type": "Data Types", "text": "\nReturn a new view of the underlying mapping\u2019s items (`(key, value)` pairs).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "types.MappingProxyType.keys()", "path": "library/types#types.MappingProxyType.keys", "type": "Data Types", "text": "\nReturn a new view of the underlying mapping\u2019s keys.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "types.MappingProxyType.values()", "path": "library/types#types.MappingProxyType.values", "type": "Data Types", "text": "\nReturn a new view of the underlying mapping\u2019s values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "types.MemberDescriptorType", "path": "library/types#types.MemberDescriptorType", "type": "Data Types", "text": "\nThe type of objects defined in extension modules with `PyMemberDef`, such as\n`datetime.timedelta.days`. This type is used as descriptor for simple C data\nmembers which use standard conversion functions; it has the same purpose as\nthe `property` type, but for classes defined in extension modules.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "types.MethodDescriptorType", "path": "library/types#types.MethodDescriptorType", "type": "Data Types", "text": "\nThe type of methods of some built-in data types such as `str.join()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "types.MethodType", "path": "library/types#types.MethodType", "type": "Data Types", "text": "\nThe type of methods of user-defined class instances.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "types.MethodWrapperType", "path": "library/types#types.MethodWrapperType", "type": "Data Types", "text": "\nThe type of bound methods of some built-in data types and base classes. For\nexample it is the type of `object().__str__`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "types.ModuleType", "path": "library/types#types.ModuleType", "type": "Data Types", "text": "\nThe type of modules. The constructor takes the name of the module to be\ncreated and optionally its docstring.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "types.ModuleType.__doc__", "path": "library/types#types.ModuleType.__doc__", "type": "Data Types", "text": "\nThe docstring of the module. Defaults to `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "types.ModuleType.__loader__", "path": "library/types#types.ModuleType.__loader__", "type": "Data Types", "text": "\nThe loader which loaded the module. Defaults to `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "types.ModuleType.__name__", "path": "library/types#types.ModuleType.__name__", "type": "Data Types", "text": "\nThe name of the module. Expected to match\n`importlib.machinery.ModuleSpec.name`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "types.ModuleType.__package__", "path": "library/types#types.ModuleType.__package__", "type": "Data Types", "text": "\nWhich package a module belongs to. If the module is top-level (i.e. not a part\nof any specific package) then the attribute should be set to `''`, else it\nshould be set to the name of the package (which can be `__name__` if the\nmodule is a package itself). Defaults to `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "types.ModuleType.__spec__", "path": "library/types#types.ModuleType.__spec__", "type": "Data Types", "text": "\nA record of the the module\u2019s import-system-related state. Expected to be an\ninstance of `importlib.machinery.ModuleSpec`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "types.new_class()", "path": "library/types#types.new_class", "type": "Data Types", "text": "\nCreates a class object dynamically using the appropriate metaclass.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "types.prepare_class()", "path": "library/types#types.prepare_class", "type": "Data Types", "text": "\nCalculates the appropriate metaclass and creates the class namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "types.resolve_bases()", "path": "library/types#types.resolve_bases", "type": "Data Types", "text": "\nResolve MRO entries dynamically as specified by PEP 560.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "types.SimpleNamespace", "path": "library/types#types.SimpleNamespace", "type": "Data Types", "text": "\nA simple `object` subclass that provides attribute access to its namespace, as\nwell as a meaningful repr.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "types.TracebackType", "path": "library/types#types.TracebackType", "type": "Data Types", "text": "\nThe type of traceback objects such as found in `sys.exc_info()[2]`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "types.WrapperDescriptorType", "path": "library/types#types.WrapperDescriptorType", "type": "Data Types", "text": "\nThe type of methods of some built-in data types and base classes such as\n`object.__init__()` or `object.__lt__()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing", "path": "library/typing", "type": "Development Tools", "text": "\nNew in version 3.5.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.AbstractSet", "path": "library/typing#typing.AbstractSet", "type": "Development Tools", "text": "\nA generic version of `collections.abc.Set`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.Annotated", "path": "library/typing#typing.Annotated", "type": "Development Tools", "text": "\nA type, introduced in PEP 593 (`Flexible function and variable annotations`),\nto decorate existing types with context-specific metadata (possibly multiple\npieces of it, as `Annotated` is variadic). Specifically, a type `T` can be\nannotated with metadata `x` via the typehint `Annotated[T, x]`. This metadata\ncan be used for either static analysis or at runtime. If a library (or tool)\nencounters a typehint `Annotated[T, x]` and has no special logic for metadata\n`x`, it should ignore it and simply treat the type as `T`. Unlike the\n`no_type_check` functionality that currently exists in the `typing` module\nwhich completely disables typechecking annotations on a function or a class,\nthe `Annotated` type allows for both static typechecking of `T` (e.g., via\nmypy or Pyre, which can safely ignore `x`) together with runtime access to `x`\nwithin a specific application.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.Any", "path": "library/typing#typing.Any", "type": "Development Tools", "text": "\nSpecial type indicating an unconstrained type.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.AnyStr", "path": "library/typing#typing.AnyStr", "type": "Development Tools", "text": "\n`AnyStr` is a type variable defined as `AnyStr = TypeVar('AnyStr', str,\nbytes)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.AsyncContextManager", "path": "library/typing#typing.AsyncContextManager", "type": "Development Tools", "text": "\nA generic version of `contextlib.AbstractAsyncContextManager`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.AsyncGenerator", "path": "library/typing#typing.AsyncGenerator", "type": "Development Tools", "text": "\nAn async generator can be annotated by the generic type\n`AsyncGenerator[YieldType, SendType]`. For example:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.AsyncIterable", "path": "library/typing#typing.AsyncIterable", "type": "Development Tools", "text": "\nA generic version of `collections.abc.AsyncIterable`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.AsyncIterator", "path": "library/typing#typing.AsyncIterator", "type": "Development Tools", "text": "\nA generic version of `collections.abc.AsyncIterator`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.Awaitable", "path": "library/typing#typing.Awaitable", "type": "Development Tools", "text": "\nA generic version of `collections.abc.Awaitable`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.BinaryIO", "path": "library/typing#typing.BinaryIO", "type": "Development Tools", "text": "\nGeneric type `IO[AnyStr]` and its subclasses `TextIO(IO[str])` and\n`BinaryIO(IO[bytes])` represent the types of I/O streams such as returned by\n`open()`. These types are also in the `typing.io` namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.ByteString", "path": "library/typing#typing.ByteString", "type": "Development Tools", "text": "\nA generic version of `collections.abc.ByteString`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.Callable", "path": "library/typing#typing.Callable", "type": "Development Tools", "text": "\nCallable type; `Callable[[int], str]` is a function of (int) -> str.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.cast()", "path": "library/typing#typing.cast", "type": "Development Tools", "text": "\nCast a value to a type.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.ChainMap", "path": "library/typing#typing.ChainMap", "type": "Development Tools", "text": "\nA generic version of `collections.ChainMap`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.ClassVar", "path": "library/typing#typing.ClassVar", "type": "Development Tools", "text": "\nSpecial type construct to mark class variables.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.Collection", "path": "library/typing#typing.Collection", "type": "Development Tools", "text": "\nA generic version of `collections.abc.Collection`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.Container", "path": "library/typing#typing.Container", "type": "Development Tools", "text": "\nA generic version of `collections.abc.Container`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.ContextManager", "path": "library/typing#typing.ContextManager", "type": "Development Tools", "text": "\nA generic version of `contextlib.AbstractContextManager`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.Coroutine", "path": "library/typing#typing.Coroutine", "type": "Development Tools", "text": "\nA generic version of `collections.abc.Coroutine`. The variance and order of\ntype variables correspond to those of `Generator`, for example:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.Counter", "path": "library/typing#typing.Counter", "type": "Development Tools", "text": "\nA generic version of `collections.Counter`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.DefaultDict", "path": "library/typing#typing.DefaultDict", "type": "Development Tools", "text": "\nA generic version of `collections.defaultdict`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.Deque", "path": "library/typing#typing.Deque", "type": "Development Tools", "text": "\nA generic version of `collections.deque`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.Dict", "path": "library/typing#typing.Dict", "type": "Development Tools", "text": "\nA generic version of `dict`. Useful for annotating return types. To annotate\narguments it is preferred to use an abstract collection type such as\n`Mapping`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.Final", "path": "library/typing#typing.Final", "type": "Development Tools", "text": "\nA special typing construct to indicate to type checkers that a name cannot be\nre-assigned or overridden in a subclass. For example:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.final()", "path": "library/typing#typing.final", "type": "Development Tools", "text": "\nA decorator to indicate to type checkers that the decorated method cannot be\noverridden, and the decorated class cannot be subclassed. For example:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.ForwardRef", "path": "library/typing#typing.ForwardRef", "type": "Development Tools", "text": "\nA class used for internal typing representation of string forward references.\nFor example, `List[\"SomeClass\"]` is implicitly transformed into\n`List[ForwardRef(\"SomeClass\")]`. This class should not be instantiated by a\nuser, but may be used by introspection tools.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.FrozenSet", "path": "library/typing#typing.FrozenSet", "type": "Development Tools", "text": "\nA generic version of `builtins.frozenset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.Generator", "path": "library/typing#typing.Generator", "type": "Development Tools", "text": "\nA generator can be annotated by the generic type `Generator[YieldType,\nSendType, ReturnType]`. For example:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.Generic", "path": "library/typing#typing.Generic", "type": "Development Tools", "text": "\nAbstract base class for generic types.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.get_args()", "path": "library/typing#typing.get_args", "type": "Development Tools", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.get_origin()", "path": "library/typing#typing.get_origin", "type": "Development Tools", "text": "\nProvide basic introspection for generic types and special typing forms.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.get_type_hints()", "path": "library/typing#typing.get_type_hints", "type": "Development Tools", "text": "\nReturn a dictionary containing type hints for a function, method, module or\nclass object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.Hashable", "path": "library/typing#typing.Hashable", "type": "Development Tools", "text": "\nAn alias to `collections.abc.Hashable`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.IO", "path": "library/typing#typing.IO", "type": "Development Tools", "text": "\nGeneric type `IO[AnyStr]` and its subclasses `TextIO(IO[str])` and\n`BinaryIO(IO[bytes])` represent the types of I/O streams such as returned by\n`open()`. These types are also in the `typing.io` namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.ItemsView", "path": "library/typing#typing.ItemsView", "type": "Development Tools", "text": "\nA generic version of `collections.abc.ItemsView`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.Iterable", "path": "library/typing#typing.Iterable", "type": "Development Tools", "text": "\nA generic version of `collections.abc.Iterable`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.Iterator", "path": "library/typing#typing.Iterator", "type": "Development Tools", "text": "\nA generic version of `collections.abc.Iterator`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.KeysView", "path": "library/typing#typing.KeysView", "type": "Development Tools", "text": "\nA generic version of `collections.abc.KeysView`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.List", "path": "library/typing#typing.List", "type": "Development Tools", "text": "\nGeneric version of `list`. Useful for annotating return types. To annotate\narguments it is preferred to use an abstract collection type such as\n`Sequence` or `Iterable`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.Literal", "path": "library/typing#typing.Literal", "type": "Development Tools", "text": "\nA type that can be used to indicate to type checkers that the corresponding\nvariable or function parameter has a value equivalent to the provided literal\n(or one of several literals). For example:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.Mapping", "path": "library/typing#typing.Mapping", "type": "Development Tools", "text": "\nA generic version of `collections.abc.Mapping`. This type can be used as\nfollows:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.MappingView", "path": "library/typing#typing.MappingView", "type": "Development Tools", "text": "\nA generic version of `collections.abc.MappingView`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.Match", "path": "library/typing#typing.Match", "type": "Development Tools", "text": "\nThese type aliases correspond to the return types from `re.compile()` and\n`re.match()`. These types (and the corresponding functions) are generic in\n`AnyStr` and can be made specific by writing `Pattern[str]`, `Pattern[bytes]`,\n`Match[str]`, or `Match[bytes]`. These types are also in the `typing.re`\nnamespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.MutableMapping", "path": "library/typing#typing.MutableMapping", "type": "Development Tools", "text": "\nA generic version of `collections.abc.MutableMapping`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.MutableSequence", "path": "library/typing#typing.MutableSequence", "type": "Development Tools", "text": "\nA generic version of `collections.abc.MutableSequence`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.MutableSet", "path": "library/typing#typing.MutableSet", "type": "Development Tools", "text": "\nA generic version of `collections.abc.MutableSet`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.NamedTuple", "path": "library/typing#typing.NamedTuple", "type": "Development Tools", "text": "\nTyped version of `collections.namedtuple()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.NewType()", "path": "library/typing#typing.NewType", "type": "Development Tools", "text": "\nA helper function to indicate a distinct type to a typechecker, see NewType.\nAt runtime it returns a function that returns its argument. Usage:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.NoReturn", "path": "library/typing#typing.NoReturn", "type": "Development Tools", "text": "\nSpecial type indicating that a function never returns. For example:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.no_type_check()", "path": "library/typing#typing.no_type_check", "type": "Development Tools", "text": "\nDecorator to indicate that annotations are not type hints.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.no_type_check_decorator()", "path": "library/typing#typing.no_type_check_decorator", "type": "Development Tools", "text": "\nDecorator to give another decorator the `no_type_check()` effect.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.Optional", "path": "library/typing#typing.Optional", "type": "Development Tools", "text": "\nOptional type.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.OrderedDict", "path": "library/typing#typing.OrderedDict", "type": "Development Tools", "text": "\nA generic version of `collections.OrderedDict`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.overload()", "path": "library/typing#typing.overload", "type": "Development Tools", "text": "\nThe `@overload` decorator allows describing functions and methods that support\nmultiple different combinations of argument types. A series of\n`@overload`-decorated definitions must be followed by exactly one\nnon-`@overload`-decorated definition (for the same function/method). The\n`@overload`-decorated definitions are for the benefit of the type checker\nonly, since they will be overwritten by the non-`@overload`-decorated\ndefinition, while the latter is used at runtime but should be ignored by a\ntype checker. At runtime, calling a `@overload`-decorated function directly\nwill raise `NotImplementedError`. An example of overload that gives a more\nprecise type than can be expressed using a union or a type variable:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.Pattern", "path": "library/typing#typing.Pattern", "type": "Development Tools", "text": "\nThese type aliases correspond to the return types from `re.compile()` and\n`re.match()`. These types (and the corresponding functions) are generic in\n`AnyStr` and can be made specific by writing `Pattern[str]`, `Pattern[bytes]`,\n`Match[str]`, or `Match[bytes]`. These types are also in the `typing.re`\nnamespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.Protocol", "path": "library/typing#typing.Protocol", "type": "Development Tools", "text": "\nBase class for protocol classes. Protocol classes are defined like this:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.Reversible", "path": "library/typing#typing.Reversible", "type": "Development Tools", "text": "\nA generic version of `collections.abc.Reversible`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.runtime_checkable()", "path": "library/typing#typing.runtime_checkable", "type": "Development Tools", "text": "\nMark a protocol class as a runtime protocol.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.Sequence", "path": "library/typing#typing.Sequence", "type": "Development Tools", "text": "\nA generic version of `collections.abc.Sequence`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.Set", "path": "library/typing#typing.Set", "type": "Development Tools", "text": "\nA generic version of `builtins.set`. Useful for annotating return types. To\nannotate arguments it is preferred to use an abstract collection type such as\n`AbstractSet`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.Sized", "path": "library/typing#typing.Sized", "type": "Development Tools", "text": "\nAn alias to `collections.abc.Sized`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.SupportsAbs", "path": "library/typing#typing.SupportsAbs", "type": "Development Tools", "text": "\nAn ABC with one abstract method `__abs__` that is covariant in its return\ntype.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.SupportsBytes", "path": "library/typing#typing.SupportsBytes", "type": "Development Tools", "text": "\nAn ABC with one abstract method `__bytes__`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.SupportsComplex", "path": "library/typing#typing.SupportsComplex", "type": "Development Tools", "text": "\nAn ABC with one abstract method `__complex__`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.SupportsFloat", "path": "library/typing#typing.SupportsFloat", "type": "Development Tools", "text": "\nAn ABC with one abstract method `__float__`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.SupportsIndex", "path": "library/typing#typing.SupportsIndex", "type": "Development Tools", "text": "\nAn ABC with one abstract method `__index__`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.SupportsInt", "path": "library/typing#typing.SupportsInt", "type": "Development Tools", "text": "\nAn ABC with one abstract method `__int__`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.SupportsRound", "path": "library/typing#typing.SupportsRound", "type": "Development Tools", "text": "\nAn ABC with one abstract method `__round__` that is covariant in its return\ntype.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.Text", "path": "library/typing#typing.Text", "type": "Development Tools", "text": "\n`Text` is an alias for `str`. It is provided to supply a forward compatible\npath for Python 2 code: in Python 2, `Text` is an alias for `unicode`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.TextIO", "path": "library/typing#typing.TextIO", "type": "Development Tools", "text": "\nGeneric type `IO[AnyStr]` and its subclasses `TextIO(IO[str])` and\n`BinaryIO(IO[bytes])` represent the types of I/O streams such as returned by\n`open()`. These types are also in the `typing.io` namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.Tuple", "path": "library/typing#typing.Tuple", "type": "Development Tools", "text": "\nTuple type; `Tuple[X, Y]` is the type of a tuple of two items with the first\nitem of type X and the second of type Y. The type of the empty tuple can be\nwritten as `Tuple[()]`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.Type", "path": "library/typing#typing.Type", "type": "Development Tools", "text": "\nA variable annotated with `C` may accept a value of type `C`. In contrast, a\nvariable annotated with `Type[C]` may accept values that are classes\nthemselves \u2013 specifically, it will accept the class object of `C`. For\nexample:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.TypedDict", "path": "library/typing#typing.TypedDict", "type": "Development Tools", "text": "\nSpecial construct to add type hints to a dictionary. At runtime it is a plain\n`dict`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.TypeVar", "path": "library/typing#typing.TypeVar", "type": "Development Tools", "text": "\nType variable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.TYPE_CHECKING", "path": "library/typing#typing.TYPE_CHECKING", "type": "Development Tools", "text": "\nA special constant that is assumed to be `True` by 3rd party static type\ncheckers. It is `False` at runtime. Usage:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.type_check_only()", "path": "library/typing#typing.type_check_only", "type": "Development Tools", "text": "\nDecorator to mark a class or function to be unavailable at runtime.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.Union", "path": "library/typing#typing.Union", "type": "Development Tools", "text": "\nUnion type; `Union[X, Y]` means either X or Y.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "typing.ValuesView", "path": "library/typing#typing.ValuesView", "type": "Development Tools", "text": "\nA generic version of `collections.abc.ValuesView`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "UnboundLocalError", "path": "library/exceptions#UnboundLocalError", "type": "Built-in Exceptions", "text": "\nRaised when a reference is made to a local variable in a function or method,\nbut no value has been bound to that variable. This is a subclass of\n`NameError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unicodedata", "path": "library/unicodedata", "type": "Text Processing", "text": "\nThis module provides access to the Unicode Character Database (UCD) which\ndefines character properties for all Unicode characters. The data contained in\nthis database is compiled from the UCD version 13.0.0.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unicodedata.bidirectional()", "path": "library/unicodedata#unicodedata.bidirectional", "type": "Text Processing", "text": "\nReturns the bidirectional class assigned to the character chr as string. If no\nsuch value is defined, an empty string is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unicodedata.category()", "path": "library/unicodedata#unicodedata.category", "type": "Text Processing", "text": "\nReturns the general category assigned to the character chr as string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unicodedata.combining()", "path": "library/unicodedata#unicodedata.combining", "type": "Text Processing", "text": "\nReturns the canonical combining class assigned to the character chr as\ninteger. Returns `0` if no combining class is defined.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unicodedata.decimal()", "path": "library/unicodedata#unicodedata.decimal", "type": "Text Processing", "text": "\nReturns the decimal value assigned to the character chr as integer. If no such\nvalue is defined, default is returned, or, if not given, `ValueError` is\nraised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unicodedata.decomposition()", "path": "library/unicodedata#unicodedata.decomposition", "type": "Text Processing", "text": "\nReturns the character decomposition mapping assigned to the character chr as\nstring. An empty string is returned in case no such mapping is defined.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unicodedata.digit()", "path": "library/unicodedata#unicodedata.digit", "type": "Text Processing", "text": "\nReturns the digit value assigned to the character chr as integer. If no such\nvalue is defined, default is returned, or, if not given, `ValueError` is\nraised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unicodedata.east_asian_width()", "path": "library/unicodedata#unicodedata.east_asian_width", "type": "Text Processing", "text": "\nReturns the east asian width assigned to the character chr as string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unicodedata.is_normalized()", "path": "library/unicodedata#unicodedata.is_normalized", "type": "Text Processing", "text": "\nReturn whether the Unicode string unistr is in the normal form form. Valid\nvalues for form are \u2018NFC\u2019, \u2018NFKC\u2019, \u2018NFD\u2019, and \u2018NFKD\u2019.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unicodedata.lookup()", "path": "library/unicodedata#unicodedata.lookup", "type": "Text Processing", "text": "\nLook up character by name. If a character with the given name is found, return\nthe corresponding character. If not found, `KeyError` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unicodedata.mirrored()", "path": "library/unicodedata#unicodedata.mirrored", "type": "Text Processing", "text": "\nReturns the mirrored property assigned to the character chr as integer.\nReturns `1` if the character has been identified as a \u201cmirrored\u201d character in\nbidirectional text, `0` otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unicodedata.name()", "path": "library/unicodedata#unicodedata.name", "type": "Text Processing", "text": "\nReturns the name assigned to the character chr as a string. If no name is\ndefined, default is returned, or, if not given, `ValueError` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unicodedata.normalize()", "path": "library/unicodedata#unicodedata.normalize", "type": "Text Processing", "text": "\nReturn the normal form form for the Unicode string unistr. Valid values for\nform are \u2018NFC\u2019, \u2018NFKC\u2019, \u2018NFD\u2019, and \u2018NFKD\u2019.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unicodedata.numeric()", "path": "library/unicodedata#unicodedata.numeric", "type": "Text Processing", "text": "\nReturns the numeric value assigned to the character chr as float. If no such\nvalue is defined, default is returned, or, if not given, `ValueError` is\nraised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unicodedata.ucd_3_2_0", "path": "library/unicodedata#unicodedata.ucd_3_2_0", "type": "Text Processing", "text": "\nThis is an object that has the same methods as the entire module, but uses the\nUnicode database version 3.2 instead, for applications that require this\nspecific version of the Unicode database (such as IDNA).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unicodedata.unidata_version", "path": "library/unicodedata#unicodedata.unidata_version", "type": "Text Processing", "text": "\nThe version of the Unicode database used in this module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "UnicodeDecodeError", "path": "library/exceptions#UnicodeDecodeError", "type": "Built-in Exceptions", "text": "\nRaised when a Unicode-related error occurs during decoding. It is a subclass\nof `UnicodeError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "UnicodeEncodeError", "path": "library/exceptions#UnicodeEncodeError", "type": "Built-in Exceptions", "text": "\nRaised when a Unicode-related error occurs during encoding. It is a subclass\nof `UnicodeError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "UnicodeError", "path": "library/exceptions#UnicodeError", "type": "Built-in Exceptions", "text": "\nRaised when a Unicode-related encoding or decoding error occurs. It is a\nsubclass of `ValueError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "UnicodeError.encoding", "path": "library/exceptions#UnicodeError.encoding", "type": "Built-in Exceptions", "text": "\nThe name of the encoding that raised the error.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "UnicodeError.end", "path": "library/exceptions#UnicodeError.end", "type": "Built-in Exceptions", "text": "\nThe index after the last invalid data in `object`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "UnicodeError.object", "path": "library/exceptions#UnicodeError.object", "type": "Built-in Exceptions", "text": "\nThe object the codec was attempting to encode or decode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "UnicodeError.reason", "path": "library/exceptions#UnicodeError.reason", "type": "Built-in Exceptions", "text": "\nA string describing the specific codec error.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "UnicodeError.start", "path": "library/exceptions#UnicodeError.start", "type": "Built-in Exceptions", "text": "\nThe first index of invalid data in `object`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "UnicodeTranslateError", "path": "library/exceptions#UnicodeTranslateError", "type": "Built-in Exceptions", "text": "\nRaised when a Unicode-related error occurs during translating. It is a\nsubclass of `UnicodeError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "UnicodeWarning", "path": "library/exceptions#UnicodeWarning", "type": "Built-in Exceptions", "text": "\nBase class for warnings related to Unicode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest", "path": "library/unittest", "type": "Development Tools", "text": "\nSource code: Lib/unittest/__init__.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.addModuleCleanup()", "path": "library/unittest#unittest.addModuleCleanup", "type": "Development Tools", "text": "\nAdd a function to be called after `tearDownModule()` to cleanup resources used\nduring the test class. Functions will be called in reverse order to the order\nthey are added (LIFO). They are called with any arguments and keyword\narguments passed into `addModuleCleanup()` when they are added.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.defaultTestLoader", "path": "library/unittest#unittest.defaultTestLoader", "type": "Development Tools", "text": "\nInstance of the `TestLoader` class intended to be shared. If no customization\nof the `TestLoader` is needed, this instance can be used instead of repeatedly\ncreating new instances.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.doModuleCleanups()", "path": "library/unittest#unittest.doModuleCleanups", "type": "Development Tools", "text": "\nThis function is called unconditionally after `tearDownModule()`, or after\n`setUpModule()` if `setUpModule()` raises an exception.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.expectedFailure()", "path": "library/unittest#unittest.expectedFailure", "type": "Development Tools", "text": "\nMark the test as an expected failure or error. If the test fails or errors it\nwill be considered a success. If the test passes, it will be considered a\nfailure.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.FunctionTestCase", "path": "library/unittest#unittest.FunctionTestCase", "type": "Development Tools", "text": "\nThis class implements the portion of the `TestCase` interface which allows the\ntest runner to drive the test, but does not provide the methods which test\ncode can use to check and report errors. This is used to create test cases\nusing legacy test code, allowing it to be integrated into a `unittest`-based\ntest framework.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.installHandler()", "path": "library/unittest#unittest.installHandler", "type": "Development Tools", "text": "\nInstall the control-c handler. When a `signal.SIGINT` is received (usually in\nresponse to the user pressing control-c) all registered results have `stop()`\ncalled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.IsolatedAsyncioTestCase", "path": "library/unittest#unittest.IsolatedAsyncioTestCase", "type": "Development Tools", "text": "\nThis class provides an API similar to `TestCase` and also accepts coroutines\nas test functions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.IsolatedAsyncioTestCase.addAsyncCleanup()", "path": "library/unittest#unittest.IsolatedAsyncioTestCase.addAsyncCleanup", "type": "Development Tools", "text": "\nThis method accepts a coroutine that can be used as a cleanup function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.IsolatedAsyncioTestCase.asyncSetUp()", "path": "library/unittest#unittest.IsolatedAsyncioTestCase.asyncSetUp", "type": "Development Tools", "text": "\nMethod called to prepare the test fixture. This is called after `setUp()`.\nThis is called immediately before calling the test method; other than\n`AssertionError` or `SkipTest`, any exception raised by this method will be\nconsidered an error rather than a test failure. The default implementation\ndoes nothing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.IsolatedAsyncioTestCase.asyncTearDown()", "path": "library/unittest#unittest.IsolatedAsyncioTestCase.asyncTearDown", "type": "Development Tools", "text": "\nMethod called immediately after the test method has been called and the result\nrecorded. This is called before `tearDown()`. This is called even if the test\nmethod raised an exception, so the implementation in subclasses may need to be\nparticularly careful about checking internal state. Any exception, other than\n`AssertionError` or `SkipTest`, raised by this method will be considered an\nadditional error rather than a test failure (thus increasing the total number\nof reported errors). This method will only be called if the `asyncSetUp()`\nsucceeds, regardless of the outcome of the test method. The default\nimplementation does nothing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.IsolatedAsyncioTestCase.run()", "path": "library/unittest#unittest.IsolatedAsyncioTestCase.run", "type": "Development Tools", "text": "\nSets up a new event loop to run the test, collecting the result into the\n`TestResult` object passed as result. If result is omitted or `None`, a\ntemporary result object is created (by calling the `defaultTestResult()`\nmethod) and used. The result object is returned to `run()`\u2019s caller. At the\nend of the test all the tasks in the event loop are cancelled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.main()", "path": "library/unittest#unittest.main", "type": "Development Tools", "text": "\nA command-line program that loads a set of tests from module and runs them;\nthis is primarily for making test modules conveniently executable. The\nsimplest use for this function is to include the following line at the end of\na test script:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock", "path": "library/unittest.mock", "type": "Development Tools", "text": "\nNew in version 3.3.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.ANY", "path": "library/unittest.mock#unittest.mock.ANY", "type": "Development Tools", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.AsyncMock", "path": "library/unittest.mock#unittest.mock.AsyncMock", "type": "Development Tools", "text": "\nAn asynchronous version of `MagicMock`. The `AsyncMock` object will behave so\nthe object is recognized as an async function, and the result of a call is an\nawaitable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.AsyncMock.assert_any_await()", "path": "library/unittest.mock#unittest.mock.AsyncMock.assert_any_await", "type": "Development Tools", "text": "\nAssert the mock has ever been awaited with the specified arguments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.AsyncMock.assert_awaited()", "path": "library/unittest.mock#unittest.mock.AsyncMock.assert_awaited", "type": "Development Tools", "text": "\nAssert that the mock was awaited at least once. Note that this is separate\nfrom the object having been called, the `await` keyword must be used:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.AsyncMock.assert_awaited_once()", "path": "library/unittest.mock#unittest.mock.AsyncMock.assert_awaited_once", "type": "Development Tools", "text": "\nAssert that the mock was awaited exactly once.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.AsyncMock.assert_awaited_once_with()", "path": "library/unittest.mock#unittest.mock.AsyncMock.assert_awaited_once_with", "type": "Development Tools", "text": "\nAssert that the mock was awaited exactly once and with the specified\narguments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.AsyncMock.assert_awaited_with()", "path": "library/unittest.mock#unittest.mock.AsyncMock.assert_awaited_with", "type": "Development Tools", "text": "\nAssert that the last await was with the specified arguments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.AsyncMock.assert_has_awaits()", "path": "library/unittest.mock#unittest.mock.AsyncMock.assert_has_awaits", "type": "Development Tools", "text": "\nAssert the mock has been awaited with the specified calls. The\n`await_args_list` list is checked for the awaits.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.AsyncMock.assert_not_awaited()", "path": "library/unittest.mock#unittest.mock.AsyncMock.assert_not_awaited", "type": "Development Tools", "text": "\nAssert that the mock was never awaited.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.AsyncMock.await_args", "path": "library/unittest.mock#unittest.mock.AsyncMock.await_args", "type": "Development Tools", "text": "\nThis is either `None` (if the mock hasn\u2019t been awaited), or the arguments that\nthe mock was last awaited with. Functions the same as `Mock.call_args`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.AsyncMock.await_args_list", "path": "library/unittest.mock#unittest.mock.AsyncMock.await_args_list", "type": "Development Tools", "text": "\nThis is a list of all the awaits made to the mock object in sequence (so the\nlength of the list is the number of times it has been awaited). Before any\nawaits have been made it is an empty list.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.AsyncMock.await_count", "path": "library/unittest.mock#unittest.mock.AsyncMock.await_count", "type": "Development Tools", "text": "\nAn integer keeping track of how many times the mock object has been awaited.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.AsyncMock.reset_mock()", "path": "library/unittest.mock#unittest.mock.AsyncMock.reset_mock", "type": "Development Tools", "text": "\nSee `Mock.reset_mock()`. Also sets `await_count` to 0, `await_args` to None,\nand clears the `await_args_list`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.call()", "path": "library/unittest.mock#unittest.mock.call", "type": "Development Tools", "text": "\n`call()` is a helper object for making simpler assertions, for comparing with\n`call_args`, `call_args_list`, `mock_calls` and `method_calls`. `call()` can\nalso be used with `assert_has_calls()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.call.call_list()", "path": "library/unittest.mock#unittest.mock.call.call_list", "type": "Development Tools", "text": "\nFor a call object that represents multiple calls, `call_list()` returns a list\nof all the intermediate calls as well as the final call.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.create_autospec()", "path": "library/unittest.mock#unittest.mock.create_autospec", "type": "Development Tools", "text": "\nCreate a mock object using another object as a spec. Attributes on the mock\nwill use the corresponding attribute on the spec object as their spec.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.DEFAULT", "path": "library/unittest.mock#unittest.mock.DEFAULT", "type": "Development Tools", "text": "\nThe `DEFAULT` object is a pre-created sentinel (actually `sentinel.DEFAULT`).\nIt can be used by `side_effect` functions to indicate that the normal return\nvalue should be used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.FILTER_DIR", "path": "library/unittest.mock#unittest.mock.FILTER_DIR", "type": "Development Tools", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.MagicMock", "path": "library/unittest.mock#unittest.mock.MagicMock", "type": "Development Tools", "text": "\n`MagicMock` is a subclass of `Mock` with default implementations of most of\nthe magic methods. You can use `MagicMock` without having to configure the\nmagic methods yourself.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.Mock", "path": "library/unittest.mock#unittest.mock.Mock", "type": "Development Tools", "text": "\nCreate a new `Mock` object. `Mock` takes several optional arguments that\nspecify the behaviour of the Mock object:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.Mock.assert_any_call()", "path": "library/unittest.mock#unittest.mock.Mock.assert_any_call", "type": "Development Tools", "text": "\nassert the mock has been called with the specified arguments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.Mock.assert_called()", "path": "library/unittest.mock#unittest.mock.Mock.assert_called", "type": "Development Tools", "text": "\nAssert that the mock was called at least once.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.Mock.assert_called_once()", "path": "library/unittest.mock#unittest.mock.Mock.assert_called_once", "type": "Development Tools", "text": "\nAssert that the mock was called exactly once.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.Mock.assert_called_once_with()", "path": "library/unittest.mock#unittest.mock.Mock.assert_called_once_with", "type": "Development Tools", "text": "\nAssert that the mock was called exactly once and that that call was with the\nspecified arguments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.Mock.assert_called_with()", "path": "library/unittest.mock#unittest.mock.Mock.assert_called_with", "type": "Development Tools", "text": "\nThis method is a convenient way of asserting that the last call has been made\nin a particular way:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.Mock.assert_has_calls()", "path": "library/unittest.mock#unittest.mock.Mock.assert_has_calls", "type": "Development Tools", "text": "\nassert the mock has been called with the specified calls. The `mock_calls`\nlist is checked for the calls.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.Mock.assert_not_called()", "path": "library/unittest.mock#unittest.mock.Mock.assert_not_called", "type": "Development Tools", "text": "\nAssert the mock was never called.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.Mock.attach_mock()", "path": "library/unittest.mock#unittest.mock.Mock.attach_mock", "type": "Development Tools", "text": "\nAttach a mock as an attribute of this one, replacing its name and parent.\nCalls to the attached mock will be recorded in the `method_calls` and\n`mock_calls` attributes of this one.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.Mock.called", "path": "library/unittest.mock#unittest.mock.Mock.called", "type": "Development Tools", "text": "\nA boolean representing whether or not the mock object has been called:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.Mock.call_args", "path": "library/unittest.mock#unittest.mock.Mock.call_args", "type": "Development Tools", "text": "\nThis is either `None` (if the mock hasn\u2019t been called), or the arguments that\nthe mock was last called with. This will be in the form of a tuple: the first\nmember, which can also be accessed through the `args` property, is any ordered\narguments the mock was called with (or an empty tuple) and the second member,\nwhich can also be accessed through the `kwargs` property, is any keyword\narguments (or an empty dictionary).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.Mock.call_args_list", "path": "library/unittest.mock#unittest.mock.Mock.call_args_list", "type": "Development Tools", "text": "\nThis is a list of all the calls made to the mock object in sequence (so the\nlength of the list is the number of times it has been called). Before any\ncalls have been made it is an empty list. The `call` object can be used for\nconveniently constructing lists of calls to compare with `call_args_list`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.Mock.call_count", "path": "library/unittest.mock#unittest.mock.Mock.call_count", "type": "Development Tools", "text": "\nAn integer telling you how many times the mock object has been called:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.Mock.configure_mock()", "path": "library/unittest.mock#unittest.mock.Mock.configure_mock", "type": "Development Tools", "text": "\nSet attributes on the mock through keyword arguments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.Mock.method_calls", "path": "library/unittest.mock#unittest.mock.Mock.method_calls", "type": "Development Tools", "text": "\nAs well as tracking calls to themselves, mocks also track calls to methods and\nattributes, and their methods and attributes:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.Mock.mock_add_spec()", "path": "library/unittest.mock#unittest.mock.Mock.mock_add_spec", "type": "Development Tools", "text": "\nAdd a spec to a mock. spec can either be an object or a list of strings. Only\nattributes on the spec can be fetched as attributes from the mock.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.Mock.mock_calls", "path": "library/unittest.mock#unittest.mock.Mock.mock_calls", "type": "Development Tools", "text": "\n`mock_calls` records all calls to the mock object, its methods, magic methods\nand return value mocks.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.Mock.reset_mock()", "path": "library/unittest.mock#unittest.mock.Mock.reset_mock", "type": "Development Tools", "text": "\nThe reset_mock method resets all the call attributes on a mock object:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.Mock.return_value", "path": "library/unittest.mock#unittest.mock.Mock.return_value", "type": "Development Tools", "text": "\nSet this to configure the value returned by calling the mock:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.Mock.side_effect", "path": "library/unittest.mock#unittest.mock.Mock.side_effect", "type": "Development Tools", "text": "\nThis can either be a function to be called when the mock is called, an\niterable or an exception (class or instance) to be raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.Mock._get_child_mock()", "path": "library/unittest.mock#unittest.mock.Mock._get_child_mock", "type": "Development Tools", "text": "\nCreate the child mocks for attributes and return value. By default child mocks\nwill be the same type as the parent. Subclasses of Mock may want to override\nthis to customize the way child mocks are made.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.Mock.__class__", "path": "library/unittest.mock#unittest.mock.Mock.__class__", "type": "Development Tools", "text": "\nNormally the `__class__` attribute of an object will return its type. For a\nmock object with a `spec`, `__class__` returns the spec class instead. This\nallows mock objects to pass `isinstance()` tests for the object they are\nreplacing / masquerading as:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.Mock.__dir__()", "path": "library/unittest.mock#unittest.mock.Mock.__dir__", "type": "Development Tools", "text": "\n`Mock` objects limit the results of `dir(some_mock)` to useful results. For\nmocks with a spec this includes all the permitted attributes for the mock.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.mock_open()", "path": "library/unittest.mock#unittest.mock.mock_open", "type": "Development Tools", "text": "\nA helper function to create a mock to replace the use of `open()`. It works\nfor `open()` called directly or used as a context manager.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.NonCallableMagicMock", "path": "library/unittest.mock#unittest.mock.NonCallableMagicMock", "type": "Development Tools", "text": "\nA non-callable version of `MagicMock`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.NonCallableMock", "path": "library/unittest.mock#unittest.mock.NonCallableMock", "type": "Development Tools", "text": "\nA non-callable version of `Mock`. The constructor parameters have the same\nmeaning of `Mock`, with the exception of return_value and side_effect which\nhave no meaning on a non-callable mock.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.patch()", "path": "library/unittest.mock#unittest.mock.patch", "type": "Development Tools", "text": "\n`patch()` acts as a function decorator, class decorator or a context manager.\nInside the body of the function or with statement, the target is patched with\na new object. When the function/with statement exits the patch is undone.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.patch.dict()", "path": "library/unittest.mock#unittest.mock.patch.dict", "type": "Development Tools", "text": "\nPatch a dictionary, or dictionary like object, and restore the dictionary to\nits original state after the test.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.patch.multiple()", "path": "library/unittest.mock#unittest.mock.patch.multiple", "type": "Development Tools", "text": "\nPerform multiple patches in a single call. It takes the object to be patched\n(either as an object or a string to fetch the object by importing) and keyword\narguments for the patches:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.patch.object()", "path": "library/unittest.mock#unittest.mock.patch.object", "type": "Development Tools", "text": "\npatch the named member (attribute) on an object (target) with a mock object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.patch.stopall()", "path": "library/unittest.mock#unittest.mock.patch.stopall", "type": "Development Tools", "text": "\nStop all active patches. Only stops patches started with `start`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.PropertyMock", "path": "library/unittest.mock#unittest.mock.PropertyMock", "type": "Development Tools", "text": "\nA mock intended to be used as a property, or other descriptor, on a class.\n`PropertyMock` provides `__get__()` and `__set__()` methods so you can specify\na return value when it is fetched.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.seal()", "path": "library/unittest.mock#unittest.mock.seal", "type": "Development Tools", "text": "\nSeal will disable the automatic creation of mocks when accessing an attribute\nof the mock being sealed or any of its attributes that are already mocks\nrecursively.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.mock.sentinel", "path": "library/unittest.mock#unittest.mock.sentinel", "type": "Development Tools", "text": "\nThe `sentinel` object provides a convenient way of providing unique objects\nfor your tests.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.registerResult()", "path": "library/unittest#unittest.registerResult", "type": "Development Tools", "text": "\nRegister a `TestResult` object for control-c handling. Registering a result\nstores a weak reference to it, so it doesn\u2019t prevent the result from being\ngarbage collected.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.removeHandler()", "path": "library/unittest#unittest.removeHandler", "type": "Development Tools", "text": "\nWhen called without arguments this function removes the control-c handler if\nit has been installed. This function can also be used as a test decorator to\ntemporarily remove the handler while the test is being executed:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.removeResult()", "path": "library/unittest#unittest.removeResult", "type": "Development Tools", "text": "\nRemove a registered result. Once a result has been removed then `stop()` will\nno longer be called on that result object in response to a control-c.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.skip()", "path": "library/unittest#unittest.skip", "type": "Development Tools", "text": "\nUnconditionally skip the decorated test. reason should describe why the test\nis being skipped.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.skipIf()", "path": "library/unittest#unittest.skipIf", "type": "Development Tools", "text": "\nSkip the decorated test if condition is true.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.SkipTest", "path": "library/unittest#unittest.SkipTest", "type": "Development Tools", "text": "\nThis exception is raised to skip a test.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.skipUnless()", "path": "library/unittest#unittest.skipUnless", "type": "Development Tools", "text": "\nSkip the decorated test unless condition is true.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase", "path": "library/unittest#unittest.TestCase", "type": "Development Tools", "text": "\nInstances of the `TestCase` class represent the logical test units in the\n`unittest` universe. This class is intended to be used as a base class, with\nspecific tests being implemented by concrete subclasses. This class implements\nthe interface needed by the test runner to allow it to drive the tests, and\nmethods that the test code can use to check for and report various kinds of\nfailure.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.addClassCleanup()", "path": "library/unittest#unittest.TestCase.addClassCleanup", "type": "Development Tools", "text": "\nAdd a function to be called after `tearDownClass()` to cleanup resources used\nduring the test class. Functions will be called in reverse order to the order\nthey are added (LIFO). They are called with any arguments and keyword\narguments passed into `addClassCleanup()` when they are added.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.addCleanup()", "path": "library/unittest#unittest.TestCase.addCleanup", "type": "Development Tools", "text": "\nAdd a function to be called after `tearDown()` to cleanup resources used\nduring the test. Functions will be called in reverse order to the order they\nare added (LIFO). They are called with any arguments and keyword arguments\npassed into `addCleanup()` when they are added.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.addTypeEqualityFunc()", "path": "library/unittest#unittest.TestCase.addTypeEqualityFunc", "type": "Development Tools", "text": "\nRegisters a type-specific method called by `assertEqual()` to check if two\nobjects of exactly the same typeobj (not subclasses) compare equal. function\nmust take two positional arguments and a third msg=None keyword argument just\nas `assertEqual()` does. It must raise `self.failureException(msg)` when\ninequality between the first two parameters is detected \u2013 possibly providing\nuseful information and explaining the inequalities in details in the error\nmessage.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.assertAlmostEqual()", "path": "library/unittest#unittest.TestCase.assertAlmostEqual", "type": "Development Tools", "text": "\nTest that first and second are approximately (or not approximately) equal by\ncomputing the difference, rounding to the given number of decimal places\n(default 7), and comparing to zero. Note that these methods round the values\nto the given number of decimal places (i.e. like the `round()` function) and\nnot significant digits.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.assertCountEqual()", "path": "library/unittest#unittest.TestCase.assertCountEqual", "type": "Development Tools", "text": "\nTest that sequence first contains the same elements as second, regardless of\ntheir order. When they don\u2019t, an error message listing the differences between\nthe sequences will be generated.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.assertDictEqual()", "path": "library/unittest#unittest.TestCase.assertDictEqual", "type": "Development Tools", "text": "\nTest that two dictionaries are equal. If not, an error message is constructed\nthat shows the differences in the dictionaries. This method will be used by\ndefault to compare dictionaries in calls to `assertEqual()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.assertEqual()", "path": "library/unittest#unittest.TestCase.assertEqual", "type": "Development Tools", "text": "\nTest that first and second are equal. If the values do not compare equal, the\ntest will fail.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.assertFalse()", "path": "library/unittest#unittest.TestCase.assertFalse", "type": "Development Tools", "text": "\nTest that expr is true (or false).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.assertGreater()", "path": "library/unittest#unittest.TestCase.assertGreater", "type": "Development Tools", "text": "\nTest that first is respectively >, >=, < or <= than second depending on the\nmethod name. If not, the test will fail:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.assertGreaterEqual()", "path": "library/unittest#unittest.TestCase.assertGreaterEqual", "type": "Development Tools", "text": "\nTest that first is respectively >, >=, < or <= than second depending on the\nmethod name. If not, the test will fail:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.assertIn()", "path": "library/unittest#unittest.TestCase.assertIn", "type": "Development Tools", "text": "\nTest that member is (or is not) in container.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.assertIs()", "path": "library/unittest#unittest.TestCase.assertIs", "type": "Development Tools", "text": "\nTest that first and second are (or are not) the same object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.assertIsInstance()", "path": "library/unittest#unittest.TestCase.assertIsInstance", "type": "Development Tools", "text": "\nTest that obj is (or is not) an instance of cls (which can be a class or a\ntuple of classes, as supported by `isinstance()`). To check for the exact\ntype, use `assertIs(type(obj), cls)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.assertIsNone()", "path": "library/unittest#unittest.TestCase.assertIsNone", "type": "Development Tools", "text": "\nTest that expr is (or is not) `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.assertIsNot()", "path": "library/unittest#unittest.TestCase.assertIsNot", "type": "Development Tools", "text": "\nTest that first and second are (or are not) the same object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.assertIsNotNone()", "path": "library/unittest#unittest.TestCase.assertIsNotNone", "type": "Development Tools", "text": "\nTest that expr is (or is not) `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.assertLess()", "path": "library/unittest#unittest.TestCase.assertLess", "type": "Development Tools", "text": "\nTest that first is respectively >, >=, < or <= than second depending on the\nmethod name. If not, the test will fail:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.assertLessEqual()", "path": "library/unittest#unittest.TestCase.assertLessEqual", "type": "Development Tools", "text": "\nTest that first is respectively >, >=, < or <= than second depending on the\nmethod name. If not, the test will fail:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.assertListEqual()", "path": "library/unittest#unittest.TestCase.assertListEqual", "type": "Development Tools", "text": "\nTests that two lists or tuples are equal. If not, an error message is\nconstructed that shows only the differences between the two. An error is also\nraised if either of the parameters are of the wrong type. These methods are\nused by default when comparing lists or tuples with `assertEqual()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.assertLogs()", "path": "library/unittest#unittest.TestCase.assertLogs", "type": "Development Tools", "text": "\nA context manager to test that at least one message is logged on the logger or\none of its children, with at least the given level.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.assertMultiLineEqual()", "path": "library/unittest#unittest.TestCase.assertMultiLineEqual", "type": "Development Tools", "text": "\nTest that the multiline string first is equal to the string second. When not\nequal a diff of the two strings highlighting the differences will be included\nin the error message. This method is used by default when comparing strings\nwith `assertEqual()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.assertNotAlmostEqual()", "path": "library/unittest#unittest.TestCase.assertNotAlmostEqual", "type": "Development Tools", "text": "\nTest that first and second are approximately (or not approximately) equal by\ncomputing the difference, rounding to the given number of decimal places\n(default 7), and comparing to zero. Note that these methods round the values\nto the given number of decimal places (i.e. like the `round()` function) and\nnot significant digits.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.assertNotEqual()", "path": "library/unittest#unittest.TestCase.assertNotEqual", "type": "Development Tools", "text": "\nTest that first and second are not equal. If the values do compare equal, the\ntest will fail.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.assertNotIn()", "path": "library/unittest#unittest.TestCase.assertNotIn", "type": "Development Tools", "text": "\nTest that member is (or is not) in container.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.assertNotIsInstance()", "path": "library/unittest#unittest.TestCase.assertNotIsInstance", "type": "Development Tools", "text": "\nTest that obj is (or is not) an instance of cls (which can be a class or a\ntuple of classes, as supported by `isinstance()`). To check for the exact\ntype, use `assertIs(type(obj), cls)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.assertNotRegex()", "path": "library/unittest#unittest.TestCase.assertNotRegex", "type": "Development Tools", "text": "\nTest that a regex search matches (or does not match) text. In case of failure,\nthe error message will include the pattern and the text (or the pattern and\nthe part of text that unexpectedly matched). regex may be a regular expression\nobject or a string containing a regular expression suitable for use by\n`re.search()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.assertRaises()", "path": "library/unittest#unittest.TestCase.assertRaises", "type": "Development Tools", "text": "\nTest that an exception is raised when callable is called with any positional\nor keyword arguments that are also passed to `assertRaises()`. The test passes\nif exception is raised, is an error if another exception is raised, or fails\nif no exception is raised. To catch any of a group of exceptions, a tuple\ncontaining the exception classes may be passed as exception.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.assertRaisesRegex()", "path": "library/unittest#unittest.TestCase.assertRaisesRegex", "type": "Development Tools", "text": "\nLike `assertRaises()` but also tests that regex matches on the string\nrepresentation of the raised exception. regex may be a regular expression\nobject or a string containing a regular expression suitable for use by\n`re.search()`. Examples:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.assertRegex()", "path": "library/unittest#unittest.TestCase.assertRegex", "type": "Development Tools", "text": "\nTest that a regex search matches (or does not match) text. In case of failure,\nthe error message will include the pattern and the text (or the pattern and\nthe part of text that unexpectedly matched). regex may be a regular expression\nobject or a string containing a regular expression suitable for use by\n`re.search()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.assertSequenceEqual()", "path": "library/unittest#unittest.TestCase.assertSequenceEqual", "type": "Development Tools", "text": "\nTests that two sequences are equal. If a seq_type is supplied, both first and\nsecond must be instances of seq_type or a failure will be raised. If the\nsequences are different an error message is constructed that shows the\ndifference between the two.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.assertSetEqual()", "path": "library/unittest#unittest.TestCase.assertSetEqual", "type": "Development Tools", "text": "\nTests that two sets are equal. If not, an error message is constructed that\nlists the differences between the sets. This method is used by default when\ncomparing sets or frozensets with `assertEqual()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.assertTrue()", "path": "library/unittest#unittest.TestCase.assertTrue", "type": "Development Tools", "text": "\nTest that expr is true (or false).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.assertTupleEqual()", "path": "library/unittest#unittest.TestCase.assertTupleEqual", "type": "Development Tools", "text": "\nTests that two lists or tuples are equal. If not, an error message is\nconstructed that shows only the differences between the two. An error is also\nraised if either of the parameters are of the wrong type. These methods are\nused by default when comparing lists or tuples with `assertEqual()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.assertWarns()", "path": "library/unittest#unittest.TestCase.assertWarns", "type": "Development Tools", "text": "\nTest that a warning is triggered when callable is called with any positional\nor keyword arguments that are also passed to `assertWarns()`. The test passes\nif warning is triggered and fails if it isn\u2019t. Any exception is an error. To\ncatch any of a group of warnings, a tuple containing the warning classes may\nbe passed as warnings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.assertWarnsRegex()", "path": "library/unittest#unittest.TestCase.assertWarnsRegex", "type": "Development Tools", "text": "\nLike `assertWarns()` but also tests that regex matches on the message of the\ntriggered warning. regex may be a regular expression object or a string\ncontaining a regular expression suitable for use by `re.search()`. Example:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.countTestCases()", "path": "library/unittest#unittest.TestCase.countTestCases", "type": "Development Tools", "text": "\nReturn the number of tests represented by this test object. For `TestCase`\ninstances, this will always be `1`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.debug()", "path": "library/unittest#unittest.TestCase.debug", "type": "Development Tools", "text": "\nRun the test without collecting the result. This allows exceptions raised by\nthe test to be propagated to the caller, and can be used to support running\ntests under a debugger.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.defaultTestResult()", "path": "library/unittest#unittest.TestCase.defaultTestResult", "type": "Development Tools", "text": "\nReturn an instance of the test result class that should be used for this test\ncase class (if no other result instance is provided to the `run()` method).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.doClassCleanups()", "path": "library/unittest#unittest.TestCase.doClassCleanups", "type": "Development Tools", "text": "\nThis method is called unconditionally after `tearDownClass()`, or after\n`setUpClass()` if `setUpClass()` raises an exception.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.doCleanups()", "path": "library/unittest#unittest.TestCase.doCleanups", "type": "Development Tools", "text": "\nThis method is called unconditionally after `tearDown()`, or after `setUp()`\nif `setUp()` raises an exception.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.fail()", "path": "library/unittest#unittest.TestCase.fail", "type": "Development Tools", "text": "\nSignals a test failure unconditionally, with msg or `None` for the error\nmessage.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.failureException", "path": "library/unittest#unittest.TestCase.failureException", "type": "Development Tools", "text": "\nThis class attribute gives the exception raised by the test method. If a test\nframework needs to use a specialized exception, possibly to carry additional\ninformation, it must subclass this exception in order to \u201cplay fair\u201d with the\nframework. The initial value of this attribute is `AssertionError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.id()", "path": "library/unittest#unittest.TestCase.id", "type": "Development Tools", "text": "\nReturn a string identifying the specific test case. This is usually the full\nname of the test method, including the module and class name.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.longMessage", "path": "library/unittest#unittest.TestCase.longMessage", "type": "Development Tools", "text": "\nThis class attribute determines what happens when a custom failure message is\npassed as the msg argument to an assertXYY call that fails. `True` is the\ndefault value. In this case, the custom message is appended to the end of the\nstandard failure message. When set to `False`, the custom message replaces the\nstandard message.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.maxDiff", "path": "library/unittest#unittest.TestCase.maxDiff", "type": "Development Tools", "text": "\nThis attribute controls the maximum length of diffs output by assert methods\nthat report diffs on failure. It defaults to 80*8 characters. Assert methods\naffected by this attribute are `assertSequenceEqual()` (including all the\nsequence comparison methods that delegate to it), `assertDictEqual()` and\n`assertMultiLineEqual()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.output", "path": "library/unittest#unittest.TestCase.output", "type": "Development Tools", "text": "\nA list of `str` objects with the formatted output of matching messages.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.records", "path": "library/unittest#unittest.TestCase.records", "type": "Development Tools", "text": "\nA list of `logging.LogRecord` objects of the matching log messages.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.run()", "path": "library/unittest#unittest.TestCase.run", "type": "Development Tools", "text": "\nRun the test, collecting the result into the `TestResult` object passed as\nresult. If result is omitted or `None`, a temporary result object is created\n(by calling the `defaultTestResult()` method) and used. The result object is\nreturned to `run()`\u2019s caller.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.setUp()", "path": "library/unittest#unittest.TestCase.setUp", "type": "Development Tools", "text": "\nMethod called to prepare the test fixture. This is called immediately before\ncalling the test method; other than `AssertionError` or `SkipTest`, any\nexception raised by this method will be considered an error rather than a test\nfailure. The default implementation does nothing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.setUpClass()", "path": "library/unittest#unittest.TestCase.setUpClass", "type": "Development Tools", "text": "\nA class method called before tests in an individual class are run.\n`setUpClass` is called with the class as the only argument and must be\ndecorated as a `classmethod()`:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.shortDescription()", "path": "library/unittest#unittest.TestCase.shortDescription", "type": "Development Tools", "text": "\nReturns a description of the test, or `None` if no description has been\nprovided. The default implementation of this method returns the first line of\nthe test method\u2019s docstring, if available, or `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.skipTest()", "path": "library/unittest#unittest.TestCase.skipTest", "type": "Development Tools", "text": "\nCalling this during a test method or `setUp()` skips the current test. See\nSkipping tests and expected failures for more information.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.subTest()", "path": "library/unittest#unittest.TestCase.subTest", "type": "Development Tools", "text": "\nReturn a context manager which executes the enclosed code block as a subtest.\nmsg and params are optional, arbitrary values which are displayed whenever a\nsubtest fails, allowing you to identify them clearly.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.tearDown()", "path": "library/unittest#unittest.TestCase.tearDown", "type": "Development Tools", "text": "\nMethod called immediately after the test method has been called and the result\nrecorded. This is called even if the test method raised an exception, so the\nimplementation in subclasses may need to be particularly careful about\nchecking internal state. Any exception, other than `AssertionError` or\n`SkipTest`, raised by this method will be considered an additional error\nrather than a test failure (thus increasing the total number of reported\nerrors). This method will only be called if the `setUp()` succeeds, regardless\nof the outcome of the test method. The default implementation does nothing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestCase.tearDownClass()", "path": "library/unittest#unittest.TestCase.tearDownClass", "type": "Development Tools", "text": "\nA class method called after tests in an individual class have run.\n`tearDownClass` is called with the class as the only argument and must be\ndecorated as a `classmethod()`:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestLoader", "path": "library/unittest#unittest.TestLoader", "type": "Development Tools", "text": "\nThe `TestLoader` class is used to create test suites from classes and modules.\nNormally, there is no need to create an instance of this class; the `unittest`\nmodule provides an instance that can be shared as\n`unittest.defaultTestLoader`. Using a subclass or instance, however, allows\ncustomization of some configurable properties.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestLoader.discover()", "path": "library/unittest#unittest.TestLoader.discover", "type": "Development Tools", "text": "\nFind all the test modules by recursing into subdirectories from the specified\nstart directory, and return a TestSuite object containing them. Only test\nfiles that match pattern will be loaded. (Using shell style pattern matching.)\nOnly module names that are importable (i.e. are valid Python identifiers) will\nbe loaded.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestLoader.errors", "path": "library/unittest#unittest.TestLoader.errors", "type": "Development Tools", "text": "\nA list of the non-fatal errors encountered while loading tests. Not reset by\nthe loader at any point. Fatal errors are signalled by the relevant a method\nraising an exception to the caller. Non-fatal errors are also indicated by a\nsynthetic test that will raise the original error when run.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestLoader.getTestCaseNames()", "path": "library/unittest#unittest.TestLoader.getTestCaseNames", "type": "Development Tools", "text": "\nReturn a sorted sequence of method names found within testCaseClass; this\nshould be a subclass of `TestCase`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestLoader.loadTestsFromModule()", "path": "library/unittest#unittest.TestLoader.loadTestsFromModule", "type": "Development Tools", "text": "\nReturn a suite of all test cases contained in the given module. This method\nsearches module for classes derived from `TestCase` and creates an instance of\nthe class for each test method defined for the class.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestLoader.loadTestsFromName()", "path": "library/unittest#unittest.TestLoader.loadTestsFromName", "type": "Development Tools", "text": "\nReturn a suite of all test cases given a string specifier.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestLoader.loadTestsFromNames()", "path": "library/unittest#unittest.TestLoader.loadTestsFromNames", "type": "Development Tools", "text": "\nSimilar to `loadTestsFromName()`, but takes a sequence of names rather than a\nsingle name. The return value is a test suite which supports all the tests\ndefined for each name.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestLoader.loadTestsFromTestCase()", "path": "library/unittest#unittest.TestLoader.loadTestsFromTestCase", "type": "Development Tools", "text": "\nReturn a suite of all test cases contained in the `TestCase`-derived\n`testCaseClass`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestLoader.sortTestMethodsUsing", "path": "library/unittest#unittest.TestLoader.sortTestMethodsUsing", "type": "Development Tools", "text": "\nFunction to be used to compare method names when sorting them in\n`getTestCaseNames()` and all the `loadTestsFrom*()` methods.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestLoader.suiteClass", "path": "library/unittest#unittest.TestLoader.suiteClass", "type": "Development Tools", "text": "\nCallable object that constructs a test suite from a list of tests. No methods\non the resulting object are needed. The default value is the `TestSuite`\nclass.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestLoader.testMethodPrefix", "path": "library/unittest#unittest.TestLoader.testMethodPrefix", "type": "Development Tools", "text": "\nString giving the prefix of method names which will be interpreted as test\nmethods. The default value is `'test'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestLoader.testNamePatterns", "path": "library/unittest#unittest.TestLoader.testNamePatterns", "type": "Development Tools", "text": "\nList of Unix shell-style wildcard test name patterns that test methods have to\nmatch to be included in test suites (see `-v` option).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestResult", "path": "library/unittest#unittest.TestResult", "type": "Development Tools", "text": "\nThis class is used to compile information about which tests have succeeded and\nwhich have failed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestResult.addError()", "path": "library/unittest#unittest.TestResult.addError", "type": "Development Tools", "text": "\nCalled when the test case test raises an unexpected exception. err is a tuple\nof the form returned by `sys.exc_info()`: `(type, value, traceback)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestResult.addExpectedFailure()", "path": "library/unittest#unittest.TestResult.addExpectedFailure", "type": "Development Tools", "text": "\nCalled when the test case test fails or errors, but was marked with the\n`expectedFailure()` decorator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestResult.addFailure()", "path": "library/unittest#unittest.TestResult.addFailure", "type": "Development Tools", "text": "\nCalled when the test case test signals a failure. err is a tuple of the form\nreturned by `sys.exc_info()`: `(type, value, traceback)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestResult.addSkip()", "path": "library/unittest#unittest.TestResult.addSkip", "type": "Development Tools", "text": "\nCalled when the test case test is skipped. reason is the reason the test gave\nfor skipping.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestResult.addSubTest()", "path": "library/unittest#unittest.TestResult.addSubTest", "type": "Development Tools", "text": "\nCalled when a subtest finishes. test is the test case corresponding to the\ntest method. subtest is a custom `TestCase` instance describing the subtest.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestResult.addSuccess()", "path": "library/unittest#unittest.TestResult.addSuccess", "type": "Development Tools", "text": "\nCalled when the test case test succeeds.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestResult.addUnexpectedSuccess()", "path": "library/unittest#unittest.TestResult.addUnexpectedSuccess", "type": "Development Tools", "text": "\nCalled when the test case test was marked with the `expectedFailure()`\ndecorator, but succeeded.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestResult.buffer", "path": "library/unittest#unittest.TestResult.buffer", "type": "Development Tools", "text": "\nIf set to true, `sys.stdout` and `sys.stderr` will be buffered in between\n`startTest()` and `stopTest()` being called. Collected output will only be\nechoed onto the real `sys.stdout` and `sys.stderr` if the test fails or\nerrors. Any output is also attached to the failure / error message.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestResult.errors", "path": "library/unittest#unittest.TestResult.errors", "type": "Development Tools", "text": "\nA list containing 2-tuples of `TestCase` instances and strings holding\nformatted tracebacks. Each tuple represents a test which raised an unexpected\nexception.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestResult.expectedFailures", "path": "library/unittest#unittest.TestResult.expectedFailures", "type": "Development Tools", "text": "\nA list containing 2-tuples of `TestCase` instances and strings holding\nformatted tracebacks. Each tuple represents an expected failure or error of\nthe test case.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestResult.failfast", "path": "library/unittest#unittest.TestResult.failfast", "type": "Development Tools", "text": "\nIf set to true `stop()` will be called on the first failure or error, halting\nthe test run.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestResult.failures", "path": "library/unittest#unittest.TestResult.failures", "type": "Development Tools", "text": "\nA list containing 2-tuples of `TestCase` instances and strings holding\nformatted tracebacks. Each tuple represents a test where a failure was\nexplicitly signalled using the `TestCase.assert*()` methods.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestResult.shouldStop", "path": "library/unittest#unittest.TestResult.shouldStop", "type": "Development Tools", "text": "\nSet to `True` when the execution of tests should stop by `stop()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestResult.skipped", "path": "library/unittest#unittest.TestResult.skipped", "type": "Development Tools", "text": "\nA list containing 2-tuples of `TestCase` instances and strings holding the\nreason for skipping the test.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestResult.startTest()", "path": "library/unittest#unittest.TestResult.startTest", "type": "Development Tools", "text": "\nCalled when the test case test is about to be run.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestResult.startTestRun()", "path": "library/unittest#unittest.TestResult.startTestRun", "type": "Development Tools", "text": "\nCalled once before any tests are executed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestResult.stop()", "path": "library/unittest#unittest.TestResult.stop", "type": "Development Tools", "text": "\nThis method can be called to signal that the set of tests being run should be\naborted by setting the `shouldStop` attribute to `True`. `TestRunner` objects\nshould respect this flag and return without running any additional tests.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestResult.stopTest()", "path": "library/unittest#unittest.TestResult.stopTest", "type": "Development Tools", "text": "\nCalled after the test case test has been executed, regardless of the outcome.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestResult.stopTestRun()", "path": "library/unittest#unittest.TestResult.stopTestRun", "type": "Development Tools", "text": "\nCalled once after all tests are executed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestResult.tb_locals", "path": "library/unittest#unittest.TestResult.tb_locals", "type": "Development Tools", "text": "\nIf set to true then local variables will be shown in tracebacks.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestResult.testsRun", "path": "library/unittest#unittest.TestResult.testsRun", "type": "Development Tools", "text": "\nThe total number of tests run so far.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestResult.unexpectedSuccesses", "path": "library/unittest#unittest.TestResult.unexpectedSuccesses", "type": "Development Tools", "text": "\nA list containing `TestCase` instances that were marked as expected failures,\nbut succeeded.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestResult.wasSuccessful()", "path": "library/unittest#unittest.TestResult.wasSuccessful", "type": "Development Tools", "text": "\nReturn `True` if all tests run so far have passed, otherwise returns `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestSuite", "path": "library/unittest#unittest.TestSuite", "type": "Development Tools", "text": "\nThis class represents an aggregation of individual test cases and test suites.\nThe class presents the interface needed by the test runner to allow it to be\nrun as any other test case. Running a `TestSuite` instance is the same as\niterating over the suite, running each test individually.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestSuite.addTest()", "path": "library/unittest#unittest.TestSuite.addTest", "type": "Development Tools", "text": "\nAdd a `TestCase` or `TestSuite` to the suite.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestSuite.addTests()", "path": "library/unittest#unittest.TestSuite.addTests", "type": "Development Tools", "text": "\nAdd all the tests from an iterable of `TestCase` and `TestSuite` instances to\nthis test suite.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestSuite.countTestCases()", "path": "library/unittest#unittest.TestSuite.countTestCases", "type": "Development Tools", "text": "\nReturn the number of tests represented by this test object, including all\nindividual tests and sub-suites.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestSuite.debug()", "path": "library/unittest#unittest.TestSuite.debug", "type": "Development Tools", "text": "\nRun the tests associated with this suite without collecting the result. This\nallows exceptions raised by the test to be propagated to the caller and can be\nused to support running tests under a debugger.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestSuite.run()", "path": "library/unittest#unittest.TestSuite.run", "type": "Development Tools", "text": "\nRun the tests associated with this suite, collecting the result into the test\nresult object passed as result. Note that unlike `TestCase.run()`,\n`TestSuite.run()` requires the result object to be passed in.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TestSuite.__iter__()", "path": "library/unittest#unittest.TestSuite.__iter__", "type": "Development Tools", "text": "\nTests grouped by a `TestSuite` are always accessed by iteration. Subclasses\ncan lazily provide tests by overriding `__iter__()`. Note that this method may\nbe called several times on a single suite (for example when counting tests or\ncomparing for equality) so the tests returned by repeated iterations before\n`TestSuite.run()` must be the same for each call iteration. After\n`TestSuite.run()`, callers should not rely on the tests returned by this\nmethod unless the caller uses a subclass that overrides\n`TestSuite._removeTestAtIndex()` to preserve test references.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TextTestResult", "path": "library/unittest#unittest.TextTestResult", "type": "Development Tools", "text": "\nA concrete implementation of `TestResult` used by the `TextTestRunner`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TextTestRunner", "path": "library/unittest#unittest.TextTestRunner", "type": "Development Tools", "text": "\nA basic test runner implementation that outputs results to a stream. If stream\nis `None`, the default, `sys.stderr` is used as the output stream. This class\nhas a few configurable parameters, but is essentially very simple. Graphical\napplications which run test suites should provide alternate implementations.\nSuch implementations should accept `**kwargs` as the interface to construct\nrunners changes when features are added to unittest.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TextTestRunner.run()", "path": "library/unittest#unittest.TextTestRunner.run", "type": "Development Tools", "text": "\nThis method is the main public interface to the `TextTestRunner`. This method\ntakes a `TestSuite` or `TestCase` instance. A `TestResult` is created by\ncalling `_makeResult()` and the test(s) are run and the results printed to\nstdout.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unittest.TextTestRunner._makeResult()", "path": "library/unittest#unittest.TextTestRunner._makeResult", "type": "Development Tools", "text": "\nThis method returns the instance of `TestResult` used by `run()`. It is not\nintended to be called directly, but can be overridden in subclasses to provide\na custom `TestResult`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib", "path": "library/urllib", "type": "Internet", "text": "\nSource code: Lib/urllib/\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.error", "path": "library/urllib.error", "type": "Internet", "text": "\nSource code: Lib/urllib/error.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.error.ContentTooShortError", "path": "library/urllib.error#urllib.error.ContentTooShortError", "type": "Internet", "text": "\nThis exception is raised when the `urlretrieve()` function detects that the\namount of the downloaded data is less than the expected amount (given by the\nContent-Length header). The `content` attribute stores the downloaded (and\nsupposedly truncated) data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.error.HTTPError", "path": "library/urllib.error#urllib.error.HTTPError", "type": "Internet", "text": "\nThough being an exception (a subclass of `URLError`), an `HTTPError` can also\nfunction as a non-exceptional file-like return value (the same thing that\n`urlopen()` returns). This is useful when handling exotic HTTP errors, such as\nrequests for authentication.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.error.HTTPError.code", "path": "library/urllib.error#urllib.error.HTTPError.code", "type": "Internet", "text": "\nAn HTTP status code as defined in RFC 2616. This numeric value corresponds to\na value found in the dictionary of codes as found in\n`http.server.BaseHTTPRequestHandler.responses`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.error.HTTPError.headers", "path": "library/urllib.error#urllib.error.HTTPError.headers", "type": "Internet", "text": "\nThe HTTP response headers for the HTTP request that caused the `HTTPError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.error.HTTPError.reason", "path": "library/urllib.error#urllib.error.HTTPError.reason", "type": "Internet", "text": "\nThis is usually a string explaining the reason for this error.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.error.URLError", "path": "library/urllib.error#urllib.error.URLError", "type": "Internet", "text": "\nThe handlers raise this exception (or derived exceptions) when they run into a\nproblem. It is a subclass of `OSError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.error.URLError.reason", "path": "library/urllib.error#urllib.error.URLError.reason", "type": "Internet", "text": "\nThe reason for this error. It can be a message string or another exception\ninstance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.parse", "path": "library/urllib.parse", "type": "Internet", "text": "\nSource code: Lib/urllib/parse.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.parse.DefragResult", "path": "library/urllib.parse#urllib.parse.DefragResult", "type": "Internet", "text": "\nConcrete class for `urldefrag()` results containing `str` data. The `encode()`\nmethod returns a `DefragResultBytes` instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.parse.DefragResultBytes", "path": "library/urllib.parse#urllib.parse.DefragResultBytes", "type": "Internet", "text": "\nConcrete class for `urldefrag()` results containing `bytes` data. The\n`decode()` method returns a `DefragResult` instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.parse.ParseResult", "path": "library/urllib.parse#urllib.parse.ParseResult", "type": "Internet", "text": "\nConcrete class for `urlparse()` results containing `str` data. The `encode()`\nmethod returns a `ParseResultBytes` instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.parse.ParseResultBytes", "path": "library/urllib.parse#urllib.parse.ParseResultBytes", "type": "Internet", "text": "\nConcrete class for `urlparse()` results containing `bytes` data. The\n`decode()` method returns a `ParseResult` instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.parse.parse_qs()", "path": "library/urllib.parse#urllib.parse.parse_qs", "type": "Internet", "text": "\nParse a query string given as a string argument (data of type\napplication/x-www-form-urlencoded). Data are returned as a dictionary. The\ndictionary keys are the unique query variable names and the values are lists\nof values for each name.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.parse.parse_qsl()", "path": "library/urllib.parse#urllib.parse.parse_qsl", "type": "Internet", "text": "\nParse a query string given as a string argument (data of type\napplication/x-www-form-urlencoded). Data are returned as a list of name, value\npairs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.parse.quote()", "path": "library/urllib.parse#urllib.parse.quote", "type": "Internet", "text": "\nReplace special characters in string using the `%xx` escape. Letters, digits,\nand the characters `'_.-~'` are never quoted. By default, this function is\nintended for quoting the path section of a URL. The optional safe parameter\nspecifies additional ASCII characters that should not be quoted \u2014 its default\nvalue is `'/'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.parse.quote_from_bytes()", "path": "library/urllib.parse#urllib.parse.quote_from_bytes", "type": "Internet", "text": "\nLike `quote()`, but accepts a `bytes` object rather than a `str`, and does not\nperform string-to-bytes encoding.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.parse.quote_plus()", "path": "library/urllib.parse#urllib.parse.quote_plus", "type": "Internet", "text": "\nLike `quote()`, but also replace spaces with plus signs, as required for\nquoting HTML form values when building up a query string to go into a URL.\nPlus signs in the original string are escaped unless they are included in\nsafe. It also does not have safe default to `'/'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.parse.SplitResult", "path": "library/urllib.parse#urllib.parse.SplitResult", "type": "Internet", "text": "\nConcrete class for `urlsplit()` results containing `str` data. The `encode()`\nmethod returns a `SplitResultBytes` instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.parse.SplitResultBytes", "path": "library/urllib.parse#urllib.parse.SplitResultBytes", "type": "Internet", "text": "\nConcrete class for `urlsplit()` results containing `bytes` data. The\n`decode()` method returns a `SplitResult` instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.parse.unquote()", "path": "library/urllib.parse#urllib.parse.unquote", "type": "Internet", "text": "\nReplace `%xx` escapes with their single-character equivalent. The optional\nencoding and errors parameters specify how to decode percent-encoded sequences\ninto Unicode characters, as accepted by the `bytes.decode()` method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.parse.unquote_plus()", "path": "library/urllib.parse#urllib.parse.unquote_plus", "type": "Internet", "text": "\nLike `unquote()`, but also replace plus signs with spaces, as required for\nunquoting HTML form values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.parse.unquote_to_bytes()", "path": "library/urllib.parse#urllib.parse.unquote_to_bytes", "type": "Internet", "text": "\nReplace `%xx` escapes with their single-octet equivalent, and return a `bytes`\nobject.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.parse.unwrap()", "path": "library/urllib.parse#urllib.parse.unwrap", "type": "Internet", "text": "\nExtract the url from a wrapped URL (that is, a string formatted as\n`<URL:scheme://host/path>`, `<scheme://host/path>`, `URL:scheme://host/path`\nor `scheme://host/path`). If url is not a wrapped URL, it is returned without\nchanges.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.parse.urldefrag()", "path": "library/urllib.parse#urllib.parse.urldefrag", "type": "Internet", "text": "\nIf url contains a fragment identifier, return a modified version of url with\nno fragment identifier, and the fragment identifier as a separate string. If\nthere is no fragment identifier in url, return url unmodified and an empty\nstring.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.parse.urlencode()", "path": "library/urllib.parse#urllib.parse.urlencode", "type": "Internet", "text": "\nConvert a mapping object or a sequence of two-element tuples, which may\ncontain `str` or `bytes` objects, to a percent-encoded ASCII text string. If\nthe resultant string is to be used as a data for POST operation with the\n`urlopen()` function, then it should be encoded to bytes, otherwise it would\nresult in a `TypeError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.parse.urljoin()", "path": "library/urllib.parse#urllib.parse.urljoin", "type": "Internet", "text": "\nConstruct a full (\u201cabsolute\u201d) URL by combining a \u201cbase URL\u201d (base) with\nanother URL (url). Informally, this uses components of the base URL, in\nparticular the addressing scheme, the network location and (part of) the path,\nto provide missing components in the relative URL. For example:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.parse.urllib.parse.SplitResult.geturl()", "path": "library/urllib.parse#urllib.parse.urllib.parse.SplitResult.geturl", "type": "Internet", "text": "\nReturn the re-combined version of the original URL as a string. This may\ndiffer from the original URL in that the scheme may be normalized to lower\ncase and empty components may be dropped. Specifically, empty parameters,\nqueries, and fragment identifiers will be removed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.parse.urlparse()", "path": "library/urllib.parse#urllib.parse.urlparse", "type": "Internet", "text": "\nParse a URL into six components, returning a 6-item named tuple. This\ncorresponds to the general structure of a URL:\n`scheme://netloc/path;parameters?query#fragment`. Each tuple item is a string,\npossibly empty. The components are not broken up into smaller parts (for\nexample, the network location is a single string), and % escapes are not\nexpanded. The delimiters as shown above are not part of the result, except for\na leading slash in the path component, which is retained if present. For\nexample:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.parse.urlsplit()", "path": "library/urllib.parse#urllib.parse.urlsplit", "type": "Internet", "text": "\nThis is similar to `urlparse()`, but does not split the params from the URL.\nThis should generally be used instead of `urlparse()` if the more recent URL\nsyntax allowing parameters to be applied to each segment of the path portion\nof the URL (see RFC 2396) is wanted. A separate function is needed to separate\nthe path segments and parameters. This function returns a 5-item named tuple:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.parse.urlunparse()", "path": "library/urllib.parse#urllib.parse.urlunparse", "type": "Internet", "text": "\nConstruct a URL from a tuple as returned by `urlparse()`. The parts argument\ncan be any six-item iterable. This may result in a slightly different, but\nequivalent URL, if the URL that was parsed originally had unnecessary\ndelimiters (for example, a `?` with an empty query; the RFC states that these\nare equivalent).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.parse.urlunsplit()", "path": "library/urllib.parse#urllib.parse.urlunsplit", "type": "Internet", "text": "\nCombine the elements of a tuple as returned by `urlsplit()` into a complete\nURL as a string. The parts argument can be any five-item iterable. This may\nresult in a slightly different, but equivalent URL, if the URL that was parsed\noriginally had unnecessary delimiters (for example, a ? with an empty query;\nthe RFC states that these are equivalent).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request", "path": "library/urllib.request", "type": "Internet", "text": "\nSource code: Lib/urllib/request.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.AbstractBasicAuthHandler", "path": "library/urllib.request#urllib.request.AbstractBasicAuthHandler", "type": "Internet", "text": "\nThis is a mixin class that helps with HTTP authentication, both to the remote\nhost and to a proxy. password_mgr, if given, should be something that is\ncompatible with `HTTPPasswordMgr`; refer to section HTTPPasswordMgr Objects\nfor information on the interface that must be supported. If passwd_mgr also\nprovides `is_authenticated` and `update_authenticated` methods (see\nHTTPPasswordMgrWithPriorAuth Objects), then the handler will use the\n`is_authenticated` result for a given URI to determine whether or not to send\nauthentication credentials with the request. If `is_authenticated` returns\n`True` for the URI, credentials are sent. If `is_authenticated` is `False`,\ncredentials are not sent, and then if a `401` response is received the request\nis re-sent with the authentication credentials. If authentication succeeds,\n`update_authenticated` is called to set `is_authenticated` `True` for the URI,\nso that subsequent requests to the URI or any of its super-URIs will\nautomatically include the authentication credentials.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.AbstractBasicAuthHandler.http_error_auth_reqed()", "path": "library/urllib.request#urllib.request.AbstractBasicAuthHandler.http_error_auth_reqed", "type": "Internet", "text": "\nHandle an authentication request by getting a user/password pair, and re-\ntrying the request. authreq should be the name of the header where the\ninformation about the realm is included in the request, host specifies the URL\nand path to authenticate for, req should be the (failed) `Request` object, and\nheaders should be the error headers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.AbstractDigestAuthHandler", "path": "library/urllib.request#urllib.request.AbstractDigestAuthHandler", "type": "Internet", "text": "\nThis is a mixin class that helps with HTTP authentication, both to the remote\nhost and to a proxy. password_mgr, if given, should be something that is\ncompatible with `HTTPPasswordMgr`; refer to section HTTPPasswordMgr Objects\nfor information on the interface that must be supported.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.AbstractDigestAuthHandler.http_error_auth_reqed()", "path": "library/urllib.request#urllib.request.AbstractDigestAuthHandler.http_error_auth_reqed", "type": "Internet", "text": "\nauthreq should be the name of the header where the information about the realm\nis included in the request, host should be the host to authenticate to, req\nshould be the (failed) `Request` object, and headers should be the error\nheaders.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.BaseHandler", "path": "library/urllib.request#urllib.request.BaseHandler", "type": "Internet", "text": "\nThis is the base class for all registered handlers \u2014 and handles only the\nsimple mechanics of registration.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.BaseHandler.add_parent()", "path": "library/urllib.request#urllib.request.BaseHandler.add_parent", "type": "Internet", "text": "\nAdd a director as parent.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.BaseHandler.close()", "path": "library/urllib.request#urllib.request.BaseHandler.close", "type": "Internet", "text": "\nRemove any parents.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.BaseHandler.default_open()", "path": "library/urllib.request#urllib.request.BaseHandler.default_open", "type": "Internet", "text": "\nThis method is not defined in `BaseHandler`, but subclasses should define it\nif they want to catch all URLs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.BaseHandler.http_error_default()", "path": "library/urllib.request#urllib.request.BaseHandler.http_error_default", "type": "Internet", "text": "\nThis method is not defined in `BaseHandler`, but subclasses should override it\nif they intend to provide a catch-all for otherwise unhandled HTTP errors. It\nwill be called automatically by the `OpenerDirector` getting the error, and\nshould not normally be called in other circumstances.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.BaseHandler.parent", "path": "library/urllib.request#urllib.request.BaseHandler.parent", "type": "Internet", "text": "\nA valid `OpenerDirector`, which can be used to open using a different\nprotocol, or handle errors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.BaseHandler.unknown_open()", "path": "library/urllib.request#urllib.request.BaseHandler.unknown_open", "type": "Internet", "text": "\nThis method is not defined in `BaseHandler`, but subclasses should define it\nif they want to catch all URLs with no specific registered handler to open it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.build_opener()", "path": "library/urllib.request#urllib.request.build_opener", "type": "Internet", "text": "\nReturn an `OpenerDirector` instance, which chains the handlers in the order\ngiven. handlers can be either instances of `BaseHandler`, or subclasses of\n`BaseHandler` (in which case it must be possible to call the constructor\nwithout any parameters). Instances of the following classes will be in front\nof the handlers, unless the handlers contain them, instances of them or\nsubclasses of them: `ProxyHandler` (if proxy settings are detected),\n`UnknownHandler`, `HTTPHandler`, `HTTPDefaultErrorHandler`,\n`HTTPRedirectHandler`, `FTPHandler`, `FileHandler`, `HTTPErrorProcessor`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.CacheFTPHandler", "path": "library/urllib.request#urllib.request.CacheFTPHandler", "type": "Internet", "text": "\nOpen FTP URLs, keeping a cache of open FTP connections to minimize delays.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.CacheFTPHandler.setMaxConns()", "path": "library/urllib.request#urllib.request.CacheFTPHandler.setMaxConns", "type": "Internet", "text": "\nSet maximum number of cached connections to m.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.CacheFTPHandler.setTimeout()", "path": "library/urllib.request#urllib.request.CacheFTPHandler.setTimeout", "type": "Internet", "text": "\nSet timeout of connections to t seconds.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.DataHandler", "path": "library/urllib.request#urllib.request.DataHandler", "type": "Internet", "text": "\nOpen data URLs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.DataHandler.data_open()", "path": "library/urllib.request#urllib.request.DataHandler.data_open", "type": "Internet", "text": "\nRead a data URL. This kind of URL contains the content encoded in the URL\nitself. The data URL syntax is specified in RFC 2397. This implementation\nignores white spaces in base64 encoded data URLs so the URL may be wrapped in\nwhatever source file it comes from. But even though some browsers don\u2019t mind\nabout a missing padding at the end of a base64 encoded data URL, this\nimplementation will raise an `ValueError` in that case.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.FancyURLopener", "path": "library/urllib.request#urllib.request.FancyURLopener", "type": "Internet", "text": "\nDeprecated since version 3.3.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.FancyURLopener.prompt_user_passwd()", "path": "library/urllib.request#urllib.request.FancyURLopener.prompt_user_passwd", "type": "Internet", "text": "\nReturn information needed to authenticate the user at the given host in the\nspecified security realm. The return value should be a tuple, `(user,\npassword)`, which can be used for basic authentication.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.FileHandler", "path": "library/urllib.request#urllib.request.FileHandler", "type": "Internet", "text": "\nOpen local files.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.FileHandler.file_open()", "path": "library/urllib.request#urllib.request.FileHandler.file_open", "type": "Internet", "text": "\nOpen the file locally, if there is no host name, or the host name is\n`'localhost'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.FTPHandler", "path": "library/urllib.request#urllib.request.FTPHandler", "type": "Internet", "text": "\nOpen FTP URLs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.FTPHandler.ftp_open()", "path": "library/urllib.request#urllib.request.FTPHandler.ftp_open", "type": "Internet", "text": "\nOpen the FTP file indicated by req. The login is always done with empty\nusername and password.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.getproxies()", "path": "library/urllib.request#urllib.request.getproxies", "type": "Internet", "text": "\nThis helper function returns a dictionary of scheme to proxy server URL\nmappings. It scans the environment for variables named `<scheme>_proxy`, in a\ncase insensitive approach, for all operating systems first, and when it cannot\nfind it, looks for proxy information from Mac OSX System Configuration for Mac\nOS X and Windows Systems Registry for Windows. If both lowercase and uppercase\nenvironment variables exist (and disagree), lowercase is preferred.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.HTTPBasicAuthHandler", "path": "library/urllib.request#urllib.request.HTTPBasicAuthHandler", "type": "Internet", "text": "\nHandle authentication with the remote host. password_mgr, if given, should be\nsomething that is compatible with `HTTPPasswordMgr`; refer to section\nHTTPPasswordMgr Objects for information on the interface that must be\nsupported. HTTPBasicAuthHandler will raise a `ValueError` when presented with\na wrong Authentication scheme.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.HTTPBasicAuthHandler.http_error_401()", "path": "library/urllib.request#urllib.request.HTTPBasicAuthHandler.http_error_401", "type": "Internet", "text": "\nRetry the request with authentication information, if available.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.HTTPCookieProcessor", "path": "library/urllib.request#urllib.request.HTTPCookieProcessor", "type": "Internet", "text": "\nA class to handle HTTP Cookies.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.HTTPCookieProcessor.cookiejar", "path": "library/urllib.request#urllib.request.HTTPCookieProcessor.cookiejar", "type": "Internet", "text": "\nThe `http.cookiejar.CookieJar` in which cookies are stored.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.HTTPDefaultErrorHandler", "path": "library/urllib.request#urllib.request.HTTPDefaultErrorHandler", "type": "Internet", "text": "\nA class which defines a default handler for HTTP error responses; all\nresponses are turned into `HTTPError` exceptions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.HTTPDigestAuthHandler", "path": "library/urllib.request#urllib.request.HTTPDigestAuthHandler", "type": "Internet", "text": "\nHandle authentication with the remote host. password_mgr, if given, should be\nsomething that is compatible with `HTTPPasswordMgr`; refer to section\nHTTPPasswordMgr Objects for information on the interface that must be\nsupported. When both Digest Authentication Handler and Basic Authentication\nHandler are both added, Digest Authentication is always tried first. If the\nDigest Authentication returns a 40x response again, it is sent to Basic\nAuthentication handler to Handle. This Handler method will raise a\n`ValueError` when presented with an authentication scheme other than Digest or\nBasic.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.HTTPDigestAuthHandler.http_error_401()", "path": "library/urllib.request#urllib.request.HTTPDigestAuthHandler.http_error_401", "type": "Internet", "text": "\nRetry the request with authentication information, if available.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.HTTPErrorProcessor", "path": "library/urllib.request#urllib.request.HTTPErrorProcessor", "type": "Internet", "text": "\nProcess HTTP error responses.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.HTTPErrorProcessor.https_response()", "path": "library/urllib.request#urllib.request.HTTPErrorProcessor.https_response", "type": "Internet", "text": "\nProcess HTTPS error responses.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.HTTPErrorProcessor.http_response()", "path": "library/urllib.request#urllib.request.HTTPErrorProcessor.http_response", "type": "Internet", "text": "\nProcess HTTP error responses.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.HTTPHandler", "path": "library/urllib.request#urllib.request.HTTPHandler", "type": "Internet", "text": "\nA class to handle opening of HTTP URLs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.HTTPHandler.http_open()", "path": "library/urllib.request#urllib.request.HTTPHandler.http_open", "type": "Internet", "text": "\nSend an HTTP request, which can be either GET or POST, depending on\n`req.has_data()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.HTTPPasswordMgr", "path": "library/urllib.request#urllib.request.HTTPPasswordMgr", "type": "Internet", "text": "\nKeep a database of `(realm, uri) -> (user, password)` mappings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.HTTPPasswordMgr.add_password()", "path": "library/urllib.request#urllib.request.HTTPPasswordMgr.add_password", "type": "Internet", "text": "\nuri can be either a single URI, or a sequence of URIs. realm, user and passwd\nmust be strings. This causes `(user, passwd)` to be used as authentication\ntokens when authentication for realm and a super-URI of any of the given URIs\nis given.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.HTTPPasswordMgr.find_user_password()", "path": "library/urllib.request#urllib.request.HTTPPasswordMgr.find_user_password", "type": "Internet", "text": "\nGet user/password for given realm and URI, if any. This method will return\n`(None, None)` if there is no matching user/password.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.HTTPPasswordMgrWithDefaultRealm", "path": "library/urllib.request#urllib.request.HTTPPasswordMgrWithDefaultRealm", "type": "Internet", "text": "\nKeep a database of `(realm, uri) -> (user, password)` mappings. A realm of\n`None` is considered a catch-all realm, which is searched if no other realm\nfits.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.HTTPPasswordMgrWithPriorAuth", "path": "library/urllib.request#urllib.request.HTTPPasswordMgrWithPriorAuth", "type": "Internet", "text": "\nA variant of `HTTPPasswordMgrWithDefaultRealm` that also has a database of\n`uri -> is_authenticated` mappings. Can be used by a BasicAuth handler to\ndetermine when to send authentication credentials immediately instead of\nwaiting for a `401` response first.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.HTTPPasswordMgrWithPriorAuth.add_password()", "path": "library/urllib.request#urllib.request.HTTPPasswordMgrWithPriorAuth.add_password", "type": "Internet", "text": "\nrealm, uri, user, passwd are as for `HTTPPasswordMgr.add_password()`.\nis_authenticated sets the initial value of the `is_authenticated` flag for the\ngiven URI or list of URIs. If is_authenticated is specified as `True`, realm\nis ignored.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.HTTPPasswordMgrWithPriorAuth.find_user_password()", "path": "library/urllib.request#urllib.request.HTTPPasswordMgrWithPriorAuth.find_user_password", "type": "Internet", "text": "\nSame as for `HTTPPasswordMgrWithDefaultRealm` objects\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.HTTPPasswordMgrWithPriorAuth.is_authenticated()", "path": "library/urllib.request#urllib.request.HTTPPasswordMgrWithPriorAuth.is_authenticated", "type": "Internet", "text": "\nReturns the current state of the `is_authenticated` flag for the given URI.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.HTTPPasswordMgrWithPriorAuth.update_authenticated()", "path": "library/urllib.request#urllib.request.HTTPPasswordMgrWithPriorAuth.update_authenticated", "type": "Internet", "text": "\nUpdate the `is_authenticated` flag for the given uri or list of URIs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.HTTPRedirectHandler", "path": "library/urllib.request#urllib.request.HTTPRedirectHandler", "type": "Internet", "text": "\nA class to handle redirections.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.HTTPRedirectHandler.http_error_301()", "path": "library/urllib.request#urllib.request.HTTPRedirectHandler.http_error_301", "type": "Internet", "text": "\nRedirect to the `Location:` or `URI:` URL. This method is called by the parent\n`OpenerDirector` when getting an HTTP \u2018moved permanently\u2019 response.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.HTTPRedirectHandler.http_error_302()", "path": "library/urllib.request#urllib.request.HTTPRedirectHandler.http_error_302", "type": "Internet", "text": "\nThe same as `http_error_301()`, but called for the \u2018found\u2019 response.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.HTTPRedirectHandler.http_error_303()", "path": "library/urllib.request#urllib.request.HTTPRedirectHandler.http_error_303", "type": "Internet", "text": "\nThe same as `http_error_301()`, but called for the \u2018see other\u2019 response.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.HTTPRedirectHandler.http_error_307()", "path": "library/urllib.request#urllib.request.HTTPRedirectHandler.http_error_307", "type": "Internet", "text": "\nThe same as `http_error_301()`, but called for the \u2018temporary redirect\u2019\nresponse.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.HTTPRedirectHandler.redirect_request()", "path": "library/urllib.request#urllib.request.HTTPRedirectHandler.redirect_request", "type": "Internet", "text": "\nReturn a `Request` or `None` in response to a redirect. This is called by the\ndefault implementations of the `http_error_30*()` methods when a redirection\nis received from the server. If a redirection should take place, return a new\n`Request` to allow `http_error_30*()` to perform the redirect to newurl.\nOtherwise, raise `HTTPError` if no other handler should try to handle this\nURL, or return `None` if you can\u2019t but another handler might.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.HTTPSHandler", "path": "library/urllib.request#urllib.request.HTTPSHandler", "type": "Internet", "text": "\nA class to handle opening of HTTPS URLs. context and check_hostname have the\nsame meaning as in `http.client.HTTPSConnection`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.HTTPSHandler.https_open()", "path": "library/urllib.request#urllib.request.HTTPSHandler.https_open", "type": "Internet", "text": "\nSend an HTTPS request, which can be either GET or POST, depending on\n`req.has_data()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.install_opener()", "path": "library/urllib.request#urllib.request.install_opener", "type": "Internet", "text": "\nInstall an `OpenerDirector` instance as the default global opener. Installing\nan opener is only necessary if you want urlopen to use that opener; otherwise,\nsimply call `OpenerDirector.open()` instead of `urlopen()`. The code does not\ncheck for a real `OpenerDirector`, and any class with the appropriate\ninterface will work.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.OpenerDirector", "path": "library/urllib.request#urllib.request.OpenerDirector", "type": "Internet", "text": "\nThe `OpenerDirector` class opens URLs via `BaseHandler`s chained together. It\nmanages the chaining of handlers, and recovery from errors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.OpenerDirector.add_handler()", "path": "library/urllib.request#urllib.request.OpenerDirector.add_handler", "type": "Internet", "text": "\nhandler should be an instance of `BaseHandler`. The following methods are\nsearched, and added to the possible chains (note that HTTP errors are a\nspecial case). Note that, in the following, protocol should be replaced with\nthe actual protocol to handle, for example `http_response()` would be the HTTP\nprotocol response handler. Also type should be replaced with the actual HTTP\ncode, for example `http_error_404()` would handle HTTP 404 errors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.OpenerDirector.error()", "path": "library/urllib.request#urllib.request.OpenerDirector.error", "type": "Internet", "text": "\nHandle an error of the given protocol. This will call the registered error\nhandlers for the given protocol with the given arguments (which are protocol\nspecific). The HTTP protocol is a special case which uses the HTTP response\ncode to determine the specific error handler; refer to the\n`http_error_<type>()` methods of the handler classes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.OpenerDirector.open()", "path": "library/urllib.request#urllib.request.OpenerDirector.open", "type": "Internet", "text": "\nOpen the given url (which can be a request object or a string), optionally\npassing the given data. Arguments, return values and exceptions raised are the\nsame as those of `urlopen()` (which simply calls the `open()` method on the\ncurrently installed global `OpenerDirector`). The optional timeout parameter\nspecifies a timeout in seconds for blocking operations like the connection\nattempt (if not specified, the global default timeout setting will be used).\nThe timeout feature actually works only for HTTP, HTTPS and FTP connections).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.pathname2url()", "path": "library/urllib.request#urllib.request.pathname2url", "type": "Internet", "text": "\nConvert the pathname path from the local syntax for a path to the form used in\nthe path component of a URL. This does not produce a complete URL. The return\nvalue will already be quoted using the `quote()` function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.ProxyBasicAuthHandler", "path": "library/urllib.request#urllib.request.ProxyBasicAuthHandler", "type": "Internet", "text": "\nHandle authentication with the proxy. password_mgr, if given, should be\nsomething that is compatible with `HTTPPasswordMgr`; refer to section\nHTTPPasswordMgr Objects for information on the interface that must be\nsupported.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.ProxyBasicAuthHandler.http_error_407()", "path": "library/urllib.request#urllib.request.ProxyBasicAuthHandler.http_error_407", "type": "Internet", "text": "\nRetry the request with authentication information, if available.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.ProxyDigestAuthHandler", "path": "library/urllib.request#urllib.request.ProxyDigestAuthHandler", "type": "Internet", "text": "\nHandle authentication with the proxy. password_mgr, if given, should be\nsomething that is compatible with `HTTPPasswordMgr`; refer to section\nHTTPPasswordMgr Objects for information on the interface that must be\nsupported.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.ProxyDigestAuthHandler.http_error_407()", "path": "library/urllib.request#urllib.request.ProxyDigestAuthHandler.http_error_407", "type": "Internet", "text": "\nRetry the request with authentication information, if available.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.ProxyHandler", "path": "library/urllib.request#urllib.request.ProxyHandler", "type": "Internet", "text": "\nCause requests to go through a proxy. If proxies is given, it must be a\ndictionary mapping protocol names to URLs of proxies. The default is to read\nthe list of proxies from the environment variables `<protocol>_proxy`. If no\nproxy environment variables are set, then in a Windows environment proxy\nsettings are obtained from the registry\u2019s Internet Settings section, and in a\nMac OS X environment proxy information is retrieved from the OS X System\nConfiguration Framework.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.Request", "path": "library/urllib.request#urllib.request.Request", "type": "Internet", "text": "\nThis class is an abstraction of a URL request.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.Request.add_header()", "path": "library/urllib.request#urllib.request.Request.add_header", "type": "Internet", "text": "\nAdd another header to the request. Headers are currently ignored by all\nhandlers except HTTP handlers, where they are added to the list of headers\nsent to the server. Note that there cannot be more than one header with the\nsame name, and later calls will overwrite previous calls in case the key\ncollides. Currently, this is no loss of HTTP functionality, since all headers\nwhich have meaning when used more than once have a (header-specific) way of\ngaining the same functionality using only one header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.Request.add_unredirected_header()", "path": "library/urllib.request#urllib.request.Request.add_unredirected_header", "type": "Internet", "text": "\nAdd a header that will not be added to a redirected request.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.Request.data", "path": "library/urllib.request#urllib.request.Request.data", "type": "Internet", "text": "\nThe entity body for the request, or `None` if not specified.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.Request.full_url", "path": "library/urllib.request#urllib.request.Request.full_url", "type": "Internet", "text": "\nThe original URL passed to the constructor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.Request.get_full_url()", "path": "library/urllib.request#urllib.request.Request.get_full_url", "type": "Internet", "text": "\nReturn the URL given in the constructor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.Request.get_header()", "path": "library/urllib.request#urllib.request.Request.get_header", "type": "Internet", "text": "\nReturn the value of the given header. If the header is not present, return the\ndefault value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.Request.get_method()", "path": "library/urllib.request#urllib.request.Request.get_method", "type": "Internet", "text": "\nReturn a string indicating the HTTP request method. If `Request.method` is not\n`None`, return its value, otherwise return `'GET'` if `Request.data` is\n`None`, or `'POST'` if it\u2019s not. This is only meaningful for HTTP requests.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.Request.has_header()", "path": "library/urllib.request#urllib.request.Request.has_header", "type": "Internet", "text": "\nReturn whether the instance has the named header (checks both regular and\nunredirected).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.Request.header_items()", "path": "library/urllib.request#urllib.request.Request.header_items", "type": "Internet", "text": "\nReturn a list of tuples (header_name, header_value) of the Request headers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.Request.host", "path": "library/urllib.request#urllib.request.Request.host", "type": "Internet", "text": "\nThe URI authority, typically a host, but may also contain a port separated by\na colon.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.Request.method", "path": "library/urllib.request#urllib.request.Request.method", "type": "Internet", "text": "\nThe HTTP request method to use. By default its value is `None`, which means\nthat `get_method()` will do its normal computation of the method to be used.\nIts value can be set (thus overriding the default computation in\n`get_method()`) either by providing a default value by setting it at the class\nlevel in a `Request` subclass, or by passing a value in to the `Request`\nconstructor via the method argument.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.Request.origin_req_host", "path": "library/urllib.request#urllib.request.Request.origin_req_host", "type": "Internet", "text": "\nThe original host for the request, without port.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.Request.remove_header()", "path": "library/urllib.request#urllib.request.Request.remove_header", "type": "Internet", "text": "\nRemove named header from the request instance (both from regular and\nunredirected headers).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.Request.selector", "path": "library/urllib.request#urllib.request.Request.selector", "type": "Internet", "text": "\nThe URI path. If the `Request` uses a proxy, then selector will be the full\nURL that is passed to the proxy.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.Request.set_proxy()", "path": "library/urllib.request#urllib.request.Request.set_proxy", "type": "Internet", "text": "\nPrepare the request by connecting to a proxy server. The host and type will\nreplace those of the instance, and the instance\u2019s selector will be the\noriginal URL given in the constructor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.Request.type", "path": "library/urllib.request#urllib.request.Request.type", "type": "Internet", "text": "\nThe URI scheme.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.Request.unverifiable", "path": "library/urllib.request#urllib.request.Request.unverifiable", "type": "Internet", "text": "\nboolean, indicates whether the request is unverifiable as defined by RFC 2965.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.UnknownHandler", "path": "library/urllib.request#urllib.request.UnknownHandler", "type": "Internet", "text": "\nA catch-all class to handle unknown URLs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.UnknownHandler.unknown_open()", "path": "library/urllib.request#urllib.request.UnknownHandler.unknown_open", "type": "Internet", "text": "\nRaise a `URLError` exception.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.url2pathname()", "path": "library/urllib.request#urllib.request.url2pathname", "type": "Internet", "text": "\nConvert the path component path from a percent-encoded URL to the local syntax\nfor a path. This does not accept a complete URL. This function uses\n`unquote()` to decode path.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.urlcleanup()", "path": "library/urllib.request#urllib.request.urlcleanup", "type": "Internet", "text": "\nCleans up temporary files that may have been left behind by previous calls to\n`urlretrieve()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.urlopen()", "path": "library/urllib.request#urllib.request.urlopen", "type": "Internet", "text": "\nOpen the URL url, which can be either a string or a `Request` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.URLopener", "path": "library/urllib.request#urllib.request.URLopener", "type": "Internet", "text": "\nDeprecated since version 3.3.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.URLopener.open()", "path": "library/urllib.request#urllib.request.URLopener.open", "type": "Internet", "text": "\nOpen fullurl using the appropriate protocol. This method sets up cache and\nproxy information, then calls the appropriate open method with its input\narguments. If the scheme is not recognized, `open_unknown()` is called. The\ndata argument has the same meaning as the data argument of `urlopen()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.URLopener.open_unknown()", "path": "library/urllib.request#urllib.request.URLopener.open_unknown", "type": "Internet", "text": "\nOverridable interface to open unknown URL types.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.URLopener.retrieve()", "path": "library/urllib.request#urllib.request.URLopener.retrieve", "type": "Internet", "text": "\nRetrieves the contents of url and places it in filename. The return value is a\ntuple consisting of a local filename and either an `email.message.Message`\nobject containing the response headers (for remote URLs) or `None` (for local\nURLs). The caller must then open and read the contents of filename. If\nfilename is not given and the URL refers to a local file, the input filename\nis returned. If the URL is non-local and filename is not given, the filename\nis the output of `tempfile.mktemp()` with a suffix that matches the suffix of\nthe last path component of the input URL. If reporthook is given, it must be a\nfunction accepting three numeric parameters: A chunk number, the maximum size\nchunks are read in and the total size of the download (-1 if unknown). It will\nbe called once at the start and after each chunk of data is read from the\nnetwork. reporthook is ignored for local URLs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.URLopener.version", "path": "library/urllib.request#urllib.request.URLopener.version", "type": "Internet", "text": "\nVariable that specifies the user agent of the opener object. To get `urllib`\nto tell servers that it is a particular user agent, set this in a subclass as\na class variable or in the constructor before calling the base constructor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.request.urlretrieve()", "path": "library/urllib.request#urllib.request.urlretrieve", "type": "Internet", "text": "\nCopy a network object denoted by a URL to a local file. If the URL points to a\nlocal file, the object will not be copied unless filename is supplied. Return\na tuple `(filename, headers)` where filename is the local file name under\nwhich the object can be found, and headers is whatever the `info()` method of\nthe object returned by `urlopen()` returned (for a remote object). Exceptions\nare the same as for `urlopen()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.response.addinfourl", "path": "library/urllib.request#urllib.response.addinfourl", "type": "Internet", "text": "\nURL of the resource retrieved, commonly used to determine if a redirect was\nfollowed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.response.addinfourl.code", "path": "library/urllib.request#urllib.response.addinfourl.code", "type": "Internet", "text": "\nDeprecated since version 3.9: Deprecated in favor of `status`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.response.addinfourl.getstatus()", "path": "library/urllib.request#urllib.response.addinfourl.getstatus", "type": "Internet", "text": "\nDeprecated since version 3.9: Deprecated in favor of `status`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.response.addinfourl.geturl()", "path": "library/urllib.request#urllib.response.addinfourl.geturl", "type": "Internet", "text": "\nDeprecated since version 3.9: Deprecated in favor of `url`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.response.addinfourl.headers", "path": "library/urllib.request#urllib.response.addinfourl.headers", "type": "Internet", "text": "\nReturns the headers of the response in the form of an `EmailMessage` instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.response.addinfourl.info()", "path": "library/urllib.request#urllib.response.addinfourl.info", "type": "Internet", "text": "\nDeprecated since version 3.9: Deprecated in favor of `headers`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.response.addinfourl.status", "path": "library/urllib.request#urllib.response.addinfourl.status", "type": "Internet", "text": "\nNew in version 3.9.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.response.addinfourl.url", "path": "library/urllib.request#urllib.response.addinfourl.url", "type": "Internet", "text": "\nURL of the resource retrieved, commonly used to determine if a redirect was\nfollowed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.robotparser", "path": "library/urllib.robotparser", "type": "Internet", "text": "\nSource code: Lib/urllib/robotparser.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.robotparser.RobotFileParser", "path": "library/urllib.robotparser#urllib.robotparser.RobotFileParser", "type": "Internet", "text": "\nThis class provides methods to read, parse and answer questions about the\n`robots.txt` file at url.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.robotparser.RobotFileParser.can_fetch()", "path": "library/urllib.robotparser#urllib.robotparser.RobotFileParser.can_fetch", "type": "Internet", "text": "\nReturns `True` if the useragent is allowed to fetch the url according to the\nrules contained in the parsed `robots.txt` file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.robotparser.RobotFileParser.crawl_delay()", "path": "library/urllib.robotparser#urllib.robotparser.RobotFileParser.crawl_delay", "type": "Internet", "text": "\nReturns the value of the `Crawl-delay` parameter from `robots.txt` for the\nuseragent in question. If there is no such parameter or it doesn\u2019t apply to\nthe useragent specified or the `robots.txt` entry for this parameter has\ninvalid syntax, return `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.robotparser.RobotFileParser.modified()", "path": "library/urllib.robotparser#urllib.robotparser.RobotFileParser.modified", "type": "Internet", "text": "\nSets the time the `robots.txt` file was last fetched to the current time.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.robotparser.RobotFileParser.mtime()", "path": "library/urllib.robotparser#urllib.robotparser.RobotFileParser.mtime", "type": "Internet", "text": "\nReturns the time the `robots.txt` file was last fetched. This is useful for\nlong-running web spiders that need to check for new `robots.txt` files\nperiodically.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.robotparser.RobotFileParser.parse()", "path": "library/urllib.robotparser#urllib.robotparser.RobotFileParser.parse", "type": "Internet", "text": "\nParses the lines argument.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.robotparser.RobotFileParser.read()", "path": "library/urllib.robotparser#urllib.robotparser.RobotFileParser.read", "type": "Internet", "text": "\nReads the `robots.txt` URL and feeds it to the parser.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.robotparser.RobotFileParser.request_rate()", "path": "library/urllib.robotparser#urllib.robotparser.RobotFileParser.request_rate", "type": "Internet", "text": "\nReturns the contents of the `Request-rate` parameter from `robots.txt` as a\nnamed tuple `RequestRate(requests, seconds)`. If there is no such parameter or\nit doesn\u2019t apply to the useragent specified or the `robots.txt` entry for this\nparameter has invalid syntax, return `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.robotparser.RobotFileParser.set_url()", "path": "library/urllib.robotparser#urllib.robotparser.RobotFileParser.set_url", "type": "Internet", "text": "\nSets the URL referring to a `robots.txt` file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "urllib.robotparser.RobotFileParser.site_maps()", "path": "library/urllib.robotparser#urllib.robotparser.RobotFileParser.site_maps", "type": "Internet", "text": "\nReturns the contents of the `Sitemap` parameter from `robots.txt` in the form\nof a `list()`. If there is no such parameter or the `robots.txt` entry for\nthis parameter has invalid syntax, return `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "UserWarning", "path": "library/exceptions#UserWarning", "type": "Built-in Exceptions", "text": "\nBase class for warnings generated by user code.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Using importlib.metadata", "path": "library/importlib.metadata", "type": "Importing", "text": "\nNew in version 3.8.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "uu", "path": "library/uu", "type": "Internet Data", "text": "\nSource code: Lib/uu.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "uu.decode()", "path": "library/uu#uu.decode", "type": "Internet Data", "text": "\nThis call decodes uuencoded file in_file placing the result on file out_file.\nIf out_file is a pathname, mode is used to set the permission bits if the file\nmust be created. Defaults for out_file and mode are taken from the uuencode\nheader. However, if the file specified in the header already exists, a\n`uu.Error` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "uu.encode()", "path": "library/uu#uu.encode", "type": "Internet Data", "text": "\nUuencode file in_file into file out_file. The uuencoded file will have the\nheader specifying name and mode as the defaults for the results of decoding\nthe file. The default defaults are taken from in_file, or `'-'` and `0o666`\nrespectively. If backtick is true, zeros are represented by `'`'` instead of\nspaces.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "uu.Error", "path": "library/uu#uu.Error", "type": "Internet Data", "text": "\nSubclass of `Exception`, this can be raised by `uu.decode()` under various\nsituations, such as described above, but also including a badly formatted\nheader, or truncated input file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "uuid", "path": "library/uuid", "type": "Internet", "text": "\nSource code: Lib/uuid.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "uuid.getnode()", "path": "library/uuid#uuid.getnode", "type": "Internet", "text": "\nGet the hardware address as a 48-bit positive integer. The first time this\nruns, it may launch a separate program, which could be quite slow. If all\nattempts to obtain the hardware address fail, we choose a random 48-bit number\nwith the multicast bit (least significant bit of the first octet) set to 1 as\nrecommended in RFC 4122. \u201cHardware address\u201d means the MAC address of a network\ninterface. On a machine with multiple network interfaces, universally\nadministered MAC addresses (i.e. where the second least significant bit of the\nfirst octet is unset) will be preferred over locally administered MAC\naddresses, but with no other ordering guarantees.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "uuid.NAMESPACE_DNS", "path": "library/uuid#uuid.NAMESPACE_DNS", "type": "Internet", "text": "\nWhen this namespace is specified, the name string is a fully-qualified domain\nname.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "uuid.NAMESPACE_OID", "path": "library/uuid#uuid.NAMESPACE_OID", "type": "Internet", "text": "\nWhen this namespace is specified, the name string is an ISO OID.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "uuid.NAMESPACE_URL", "path": "library/uuid#uuid.NAMESPACE_URL", "type": "Internet", "text": "\nWhen this namespace is specified, the name string is a URL.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "uuid.NAMESPACE_X500", "path": "library/uuid#uuid.NAMESPACE_X500", "type": "Internet", "text": "\nWhen this namespace is specified, the name string is an X.500 DN in DER or a\ntext output format.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "uuid.RESERVED_FUTURE", "path": "library/uuid#uuid.RESERVED_FUTURE", "type": "Internet", "text": "\nReserved for future definition.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "uuid.RESERVED_MICROSOFT", "path": "library/uuid#uuid.RESERVED_MICROSOFT", "type": "Internet", "text": "\nReserved for Microsoft compatibility.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "uuid.RESERVED_NCS", "path": "library/uuid#uuid.RESERVED_NCS", "type": "Internet", "text": "\nReserved for NCS compatibility.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "uuid.RFC_4122", "path": "library/uuid#uuid.RFC_4122", "type": "Internet", "text": "\nSpecifies the UUID layout given in RFC 4122.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "uuid.SafeUUID", "path": "library/uuid#uuid.SafeUUID", "type": "Internet", "text": "\nNew in version 3.7.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "uuid.SafeUUID.safe", "path": "library/uuid#uuid.SafeUUID.safe", "type": "Internet", "text": "\nThe UUID was generated by the platform in a multiprocessing-safe way.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "uuid.SafeUUID.unknown", "path": "library/uuid#uuid.SafeUUID.unknown", "type": "Internet", "text": "\nThe platform does not provide information on whether the UUID was generated\nsafely or not.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "uuid.SafeUUID.unsafe", "path": "library/uuid#uuid.SafeUUID.unsafe", "type": "Internet", "text": "\nThe UUID was not generated in a multiprocessing-safe way.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "uuid.UUID", "path": "library/uuid#uuid.UUID", "type": "Internet", "text": "\nCreate a UUID from either a string of 32 hexadecimal digits, a string of 16\nbytes in big-endian order as the bytes argument, a string of 16 bytes in\nlittle-endian order as the bytes_le argument, a tuple of six integers (32-bit\ntime_low, 16-bit time_mid, 16-bit time_hi_version, 8-bit clock_seq_hi_variant,\n8-bit clock_seq_low, 48-bit node) as the fields argument, or a single 128-bit\ninteger as the int argument. When a string of hex digits is given, curly\nbraces, hyphens, and a URN prefix are all optional. For example, these\nexpressions all yield the same UUID:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "uuid.UUID.bytes", "path": "library/uuid#uuid.UUID.bytes", "type": "Internet", "text": "\nThe UUID as a 16-byte string (containing the six integer fields in big-endian\nbyte order).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "uuid.UUID.bytes_le", "path": "library/uuid#uuid.UUID.bytes_le", "type": "Internet", "text": "\nThe UUID as a 16-byte string (with time_low, time_mid, and time_hi_version in\nlittle-endian byte order).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "uuid.UUID.fields", "path": "library/uuid#uuid.UUID.fields", "type": "Internet", "text": "\nA tuple of the six integer fields of the UUID, which are also available as six\nindividual attributes and two derived attributes:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "uuid.UUID.hex", "path": "library/uuid#uuid.UUID.hex", "type": "Internet", "text": "\nThe UUID as a 32-character hexadecimal string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "uuid.UUID.int", "path": "library/uuid#uuid.UUID.int", "type": "Internet", "text": "\nThe UUID as a 128-bit integer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "uuid.UUID.is_safe", "path": "library/uuid#uuid.UUID.is_safe", "type": "Internet", "text": "\nAn enumeration of `SafeUUID` which indicates whether the platform generated\nthe UUID in a multiprocessing-safe way.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "uuid.UUID.urn", "path": "library/uuid#uuid.UUID.urn", "type": "Internet", "text": "\nThe UUID as a URN as specified in RFC 4122.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "uuid.UUID.variant", "path": "library/uuid#uuid.UUID.variant", "type": "Internet", "text": "\nThe UUID variant, which determines the internal layout of the UUID. This will\nbe one of the constants `RESERVED_NCS`, `RFC_4122`, `RESERVED_MICROSOFT`, or\n`RESERVED_FUTURE`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "uuid.UUID.version", "path": "library/uuid#uuid.UUID.version", "type": "Internet", "text": "\nThe UUID version number (1 through 5, meaningful only when the variant is\n`RFC_4122`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "uuid.uuid1()", "path": "library/uuid#uuid.uuid1", "type": "Internet", "text": "\nGenerate a UUID from a host ID, sequence number, and the current time. If node\nis not given, `getnode()` is used to obtain the hardware address. If clock_seq\nis given, it is used as the sequence number; otherwise a random 14-bit\nsequence number is chosen.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "uuid.uuid3()", "path": "library/uuid#uuid.uuid3", "type": "Internet", "text": "\nGenerate a UUID based on the MD5 hash of a namespace identifier (which is a\nUUID) and a name (which is a string).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "uuid.uuid4()", "path": "library/uuid#uuid.uuid4", "type": "Internet", "text": "\nGenerate a random UUID.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "uuid.uuid5()", "path": "library/uuid#uuid.uuid5", "type": "Internet", "text": "\nGenerate a UUID based on the SHA-1 hash of a namespace identifier (which is a\nUUID) and a name (which is a string).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ValueError", "path": "library/exceptions#ValueError", "type": "Built-in Exceptions", "text": "\nRaised when an operation or function receives an argument that has the right\ntype but an inappropriate value, and the situation is not described by a more\nprecise exception such as `IndexError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "vars()", "path": "library/functions#vars", "type": "Built-in Functions", "text": "\nReturn the `__dict__` attribute for a module, class, instance, or any other\nobject with a `__dict__` attribute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "venv", "path": "library/venv", "type": "Software Packaging & Distribution", "text": "\nNew in version 3.3.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "venv.create()", "path": "library/venv#venv.create", "type": "Software Packaging & Distribution", "text": "\nCreate an `EnvBuilder` with the given keyword arguments, and call its\n`create()` method with the env_dir argument.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "venv.EnvBuilder", "path": "library/venv#venv.EnvBuilder", "type": "Software Packaging & Distribution", "text": "\nThe `EnvBuilder` class accepts the following keyword arguments on\ninstantiation:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "venv.EnvBuilder.create()", "path": "library/venv#venv.EnvBuilder.create", "type": "Software Packaging & Distribution", "text": "\nCreate a virtual environment by specifying the target directory (absolute or\nrelative to the current directory) which is to contain the virtual\nenvironment. The `create` method will either create the environment in the\nspecified directory, or raise an appropriate exception.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "venv.EnvBuilder.create_configuration()", "path": "library/venv#venv.EnvBuilder.create_configuration", "type": "Software Packaging & Distribution", "text": "\nCreates the `pyvenv.cfg` configuration file in the environment.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "venv.EnvBuilder.ensure_directories()", "path": "library/venv#venv.EnvBuilder.ensure_directories", "type": "Software Packaging & Distribution", "text": "\nCreates the environment directory and all necessary directories, and returns a\ncontext object. This is just a holder for attributes (such as paths), for use\nby the other methods. The directories are allowed to exist already, as long as\neither `clear` or `upgrade` were specified to allow operating on an existing\nenvironment directory.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "venv.EnvBuilder.install_scripts()", "path": "library/venv#venv.EnvBuilder.install_scripts", "type": "Software Packaging & Distribution", "text": "\npath is the path to a directory that should contain subdirectories \u201ccommon\u201d,\n\u201cposix\u201d, \u201cnt\u201d, each containing scripts destined for the bin directory in the\nenvironment. The contents of \u201ccommon\u201d and the directory corresponding to\n`os.name` are copied after some text replacement of placeholders:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "venv.EnvBuilder.post_setup()", "path": "library/venv#venv.EnvBuilder.post_setup", "type": "Software Packaging & Distribution", "text": "\nA placeholder method which can be overridden in third party implementations to\npre-install packages in the virtual environment or perform other post-creation\nsteps.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "venv.EnvBuilder.setup_python()", "path": "library/venv#venv.EnvBuilder.setup_python", "type": "Software Packaging & Distribution", "text": "\nCreates a copy or symlink to the Python executable in the environment. On\nPOSIX systems, if a specific executable `python3.x` was used, symlinks to\n`python` and `python3` will be created pointing to that executable, unless\nfiles with those names already exist.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "venv.EnvBuilder.setup_scripts()", "path": "library/venv#venv.EnvBuilder.setup_scripts", "type": "Software Packaging & Distribution", "text": "\nInstalls activation scripts appropriate to the platform into the virtual\nenvironment.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "venv.EnvBuilder.upgrade_dependencies()", "path": "library/venv#venv.EnvBuilder.upgrade_dependencies", "type": "Software Packaging & Distribution", "text": "\nUpgrades the core venv dependency packages (currently `pip` and `setuptools`)\nin the environment. This is done by shelling out to the `pip` executable in\nthe environment.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Warning", "path": "library/exceptions#Warning", "type": "Built-in Exceptions", "text": "\nBase class for warning categories.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "warnings", "path": "library/warnings", "type": "Runtime", "text": "\nSource code: Lib/warnings.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "warnings.catch_warnings", "path": "library/warnings#warnings.catch_warnings", "type": "Runtime", "text": "\nA context manager that copies and, upon exit, restores the warnings filter and\nthe `showwarning()` function. If the record argument is `False` (the default)\nthe context manager returns `None` on entry. If record is `True`, a list is\nreturned that is progressively populated with objects as seen by a custom\n`showwarning()` function (which also suppresses output to `sys.stdout`). Each\nobject in the list has attributes with the same names as the arguments to\n`showwarning()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "warnings.filterwarnings()", "path": "library/warnings#warnings.filterwarnings", "type": "Runtime", "text": "\nInsert an entry into the list of warnings filter specifications. The entry is\ninserted at the front by default; if append is true, it is inserted at the\nend. This checks the types of the arguments, compiles the message and module\nregular expressions, and inserts them as a tuple in the list of warnings\nfilters. Entries closer to the front of the list override entries later in the\nlist, if both match a particular warning. Omitted arguments default to a value\nthat matches everything.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "warnings.formatwarning()", "path": "library/warnings#warnings.formatwarning", "type": "Runtime", "text": "\nFormat a warning the standard way. This returns a string which may contain\nembedded newlines and ends in a newline. line is a line of source code to be\nincluded in the warning message; if line is not supplied, `formatwarning()`\nwill try to read the line specified by filename and lineno.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "warnings.resetwarnings()", "path": "library/warnings#warnings.resetwarnings", "type": "Runtime", "text": "\nReset the warnings filter. This discards the effect of all previous calls to\n`filterwarnings()`, including that of the `-W` command line options and calls\nto `simplefilter()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "warnings.showwarning()", "path": "library/warnings#warnings.showwarning", "type": "Runtime", "text": "\nWrite a warning to a file. The default implementation calls\n`formatwarning(message, category, filename, lineno, line)` and writes the\nresulting string to file, which defaults to `sys.stderr`. You may replace this\nfunction with any callable by assigning to `warnings.showwarning`. line is a\nline of source code to be included in the warning message; if line is not\nsupplied, `showwarning()` will try to read the line specified by filename and\nlineno.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "warnings.simplefilter()", "path": "library/warnings#warnings.simplefilter", "type": "Runtime", "text": "\nInsert a simple entry into the list of warnings filter specifications. The\nmeaning of the function parameters is as for `filterwarnings()`, but regular\nexpressions are not needed as the filter inserted always matches any message\nin any module as long as the category and line number match.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "warnings.warn()", "path": "library/warnings#warnings.warn", "type": "Runtime", "text": "\nIssue a warning, or maybe ignore it or raise an exception. The category\nargument, if given, must be a warning category class; it defaults to\n`UserWarning`. Alternatively, message can be a `Warning` instance, in which\ncase category will be ignored and `message.__class__` will be used. In this\ncase, the message text will be `str(message)`. This function raises an\nexception if the particular warning issued is changed into an error by the\nwarnings filter. The stacklevel argument can be used by wrapper functions\nwritten in Python, like this:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "warnings.warn_explicit()", "path": "library/warnings#warnings.warn_explicit", "type": "Runtime", "text": "\nThis is a low-level interface to the functionality of `warn()`, passing in\nexplicitly the message, category, filename and line number, and optionally the\nmodule name and the registry (which should be the `__warningregistry__`\ndictionary of the module). The module name defaults to the filename with `.py`\nstripped; if no registry is passed, the warning is never suppressed. message\nmust be a string and category a subclass of `Warning` or message may be a\n`Warning` instance, in which case category will be ignored.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wave", "path": "library/wave", "type": "Multimedia", "text": "\nSource code: Lib/wave.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wave.Error", "path": "library/wave#wave.Error", "type": "Multimedia", "text": "\nAn error raised when something is impossible because it violates the WAV\nspecification or hits an implementation deficiency.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wave.open()", "path": "library/wave#wave.open", "type": "Multimedia", "text": "\nIf file is a string, open the file by that name, otherwise treat it as a file-\nlike object. mode can be:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wave.Wave_read.close()", "path": "library/wave#wave.Wave_read.close", "type": "Multimedia", "text": "\nClose the stream if it was opened by `wave`, and make the instance unusable.\nThis is called automatically on object collection.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wave.Wave_read.getcompname()", "path": "library/wave#wave.Wave_read.getcompname", "type": "Multimedia", "text": "\nHuman-readable version of `getcomptype()`. Usually `'not compressed'`\nparallels `'NONE'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wave.Wave_read.getcomptype()", "path": "library/wave#wave.Wave_read.getcomptype", "type": "Multimedia", "text": "\nReturns compression type (`'NONE'` is the only supported type).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wave.Wave_read.getframerate()", "path": "library/wave#wave.Wave_read.getframerate", "type": "Multimedia", "text": "\nReturns sampling frequency.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wave.Wave_read.getmark()", "path": "library/wave#wave.Wave_read.getmark", "type": "Multimedia", "text": "\nRaise an error.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wave.Wave_read.getmarkers()", "path": "library/wave#wave.Wave_read.getmarkers", "type": "Multimedia", "text": "\nReturns `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wave.Wave_read.getnchannels()", "path": "library/wave#wave.Wave_read.getnchannels", "type": "Multimedia", "text": "\nReturns number of audio channels (`1` for mono, `2` for stereo).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wave.Wave_read.getnframes()", "path": "library/wave#wave.Wave_read.getnframes", "type": "Multimedia", "text": "\nReturns number of audio frames.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wave.Wave_read.getparams()", "path": "library/wave#wave.Wave_read.getparams", "type": "Multimedia", "text": "\nReturns a `namedtuple()` `(nchannels, sampwidth, framerate, nframes, comptype,\ncompname)`, equivalent to output of the `get*()` methods.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wave.Wave_read.getsampwidth()", "path": "library/wave#wave.Wave_read.getsampwidth", "type": "Multimedia", "text": "\nReturns sample width in bytes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wave.Wave_read.readframes()", "path": "library/wave#wave.Wave_read.readframes", "type": "Multimedia", "text": "\nReads and returns at most n frames of audio, as a `bytes` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wave.Wave_read.rewind()", "path": "library/wave#wave.Wave_read.rewind", "type": "Multimedia", "text": "\nRewind the file pointer to the beginning of the audio stream.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wave.Wave_read.setpos()", "path": "library/wave#wave.Wave_read.setpos", "type": "Multimedia", "text": "\nSet the file pointer to the specified position.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wave.Wave_read.tell()", "path": "library/wave#wave.Wave_read.tell", "type": "Multimedia", "text": "\nReturn current file pointer position.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wave.Wave_write.close()", "path": "library/wave#wave.Wave_write.close", "type": "Multimedia", "text": "\nMake sure nframes is correct, and close the file if it was opened by `wave`.\nThis method is called upon object collection. It will raise an exception if\nthe output stream is not seekable and nframes does not match the number of\nframes actually written.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wave.Wave_write.setcomptype()", "path": "library/wave#wave.Wave_write.setcomptype", "type": "Multimedia", "text": "\nSet the compression type and description. At the moment, only compression type\n`NONE` is supported, meaning no compression.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wave.Wave_write.setframerate()", "path": "library/wave#wave.Wave_write.setframerate", "type": "Multimedia", "text": "\nSet the frame rate to n.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wave.Wave_write.setnchannels()", "path": "library/wave#wave.Wave_write.setnchannels", "type": "Multimedia", "text": "\nSet the number of channels.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wave.Wave_write.setnframes()", "path": "library/wave#wave.Wave_write.setnframes", "type": "Multimedia", "text": "\nSet the number of frames to n. This will be changed later if the number of\nframes actually written is different (this update attempt will raise an error\nif the output stream is not seekable).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wave.Wave_write.setparams()", "path": "library/wave#wave.Wave_write.setparams", "type": "Multimedia", "text": "\nThe tuple should be `(nchannels, sampwidth, framerate, nframes, comptype,\ncompname)`, with values valid for the `set*()` methods. Sets all parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wave.Wave_write.setsampwidth()", "path": "library/wave#wave.Wave_write.setsampwidth", "type": "Multimedia", "text": "\nSet the sample width to n bytes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wave.Wave_write.tell()", "path": "library/wave#wave.Wave_write.tell", "type": "Multimedia", "text": "\nReturn current position in the file, with the same disclaimer for the\n`Wave_read.tell()` and `Wave_read.setpos()` methods.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wave.Wave_write.writeframes()", "path": "library/wave#wave.Wave_write.writeframes", "type": "Multimedia", "text": "\nWrite audio frames and make sure nframes is correct. It will raise an error if\nthe output stream is not seekable and the total number of frames that have\nbeen written after data has been written does not match the previously set\nvalue for nframes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wave.Wave_write.writeframesraw()", "path": "library/wave#wave.Wave_write.writeframesraw", "type": "Multimedia", "text": "\nWrite audio frames, without correcting nframes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "weakref", "path": "library/weakref", "type": "Data Types", "text": "\nSource code: Lib/weakref.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "weakref.CallableProxyType", "path": "library/weakref#weakref.CallableProxyType", "type": "Data Types", "text": "\nThe type object for proxies of callable objects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "weakref.finalize", "path": "library/weakref#weakref.finalize", "type": "Data Types", "text": "\nReturn a callable finalizer object which will be called when obj is garbage\ncollected. Unlike an ordinary weak reference, a finalizer will always survive\nuntil the reference object is collected, greatly simplifying lifecycle\nmanagement.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "weakref.finalize.alive", "path": "library/weakref#weakref.finalize.alive", "type": "Data Types", "text": "\nProperty which is true if the finalizer is alive, false otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "weakref.finalize.atexit", "path": "library/weakref#weakref.finalize.atexit", "type": "Data Types", "text": "\nA writable boolean property which by default is true. When the program exits,\nit calls all remaining live finalizers for which `atexit` is true. They are\ncalled in reverse order of creation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "weakref.finalize.detach()", "path": "library/weakref#weakref.finalize.detach", "type": "Data Types", "text": "\nIf self is alive then mark it as dead and return the tuple `(obj, func, args,\nkwargs)`. If self is dead then return `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "weakref.finalize.peek()", "path": "library/weakref#weakref.finalize.peek", "type": "Data Types", "text": "\nIf self is alive then return the tuple `(obj, func, args, kwargs)`. If self is\ndead then return `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "weakref.finalize.__call__()", "path": "library/weakref#weakref.finalize.__call__", "type": "Data Types", "text": "\nIf self is alive then mark it as dead and return the result of calling\n`func(*args, **kwargs)`. If self is dead then return `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "weakref.getweakrefcount()", "path": "library/weakref#weakref.getweakrefcount", "type": "Data Types", "text": "\nReturn the number of weak references and proxies which refer to object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "weakref.getweakrefs()", "path": "library/weakref#weakref.getweakrefs", "type": "Data Types", "text": "\nReturn a list of all weak reference and proxy objects which refer to object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "weakref.proxy()", "path": "library/weakref#weakref.proxy", "type": "Data Types", "text": "\nReturn a proxy to object which uses a weak reference. This supports use of the\nproxy in most contexts instead of requiring the explicit dereferencing used\nwith weak reference objects. The returned object will have a type of either\n`ProxyType` or `CallableProxyType`, depending on whether object is callable.\nProxy objects are not hashable regardless of the referent; this avoids a\nnumber of problems related to their fundamentally mutable nature, and prevent\ntheir use as dictionary keys. callback is the same as the parameter of the\nsame name to the `ref()` function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "weakref.ProxyType", "path": "library/weakref#weakref.ProxyType", "type": "Data Types", "text": "\nThe type object for proxies of objects which are not callable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "weakref.ProxyTypes", "path": "library/weakref#weakref.ProxyTypes", "type": "Data Types", "text": "\nSequence containing all the type objects for proxies. This can make it simpler\nto test if an object is a proxy without being dependent on naming both proxy\ntypes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "weakref.ref", "path": "library/weakref#weakref.ref", "type": "Data Types", "text": "\nReturn a weak reference to object. The original object can be retrieved by\ncalling the reference object if the referent is still alive; if the referent\nis no longer alive, calling the reference object will cause `None` to be\nreturned. If callback is provided and not `None`, and the returned weakref\nobject is still alive, the callback will be called when the object is about to\nbe finalized; the weak reference object will be passed as the only parameter\nto the callback; the referent will no longer be available.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "weakref.ref.__callback__", "path": "library/weakref#weakref.ref.__callback__", "type": "Data Types", "text": "\nThis read-only attribute returns the callback currently associated to the\nweakref. If there is no callback or if the referent of the weakref is no\nlonger alive then this attribute will have value `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "weakref.ReferenceType", "path": "library/weakref#weakref.ReferenceType", "type": "Data Types", "text": "\nThe type object for weak references objects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "weakref.WeakKeyDictionary", "path": "library/weakref#weakref.WeakKeyDictionary", "type": "Data Types", "text": "\nMapping class that references keys weakly. Entries in the dictionary will be\ndiscarded when there is no longer a strong reference to the key. This can be\nused to associate additional data with an object owned by other parts of an\napplication without adding attributes to those objects. This can be especially\nuseful with objects that override attribute accesses.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "weakref.WeakKeyDictionary.keyrefs()", "path": "library/weakref#weakref.WeakKeyDictionary.keyrefs", "type": "Data Types", "text": "\nReturn an iterable of the weak references to the keys.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "weakref.WeakMethod", "path": "library/weakref#weakref.WeakMethod", "type": "Data Types", "text": "\nA custom `ref` subclass which simulates a weak reference to a bound method\n(i.e., a method defined on a class and looked up on an instance). Since a\nbound method is ephemeral, a standard weak reference cannot keep hold of it.\n`WeakMethod` has special code to recreate the bound method until either the\nobject or the original function dies:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "weakref.WeakSet", "path": "library/weakref#weakref.WeakSet", "type": "Data Types", "text": "\nSet class that keeps weak references to its elements. An element will be\ndiscarded when no strong reference to it exists any more.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "weakref.WeakValueDictionary", "path": "library/weakref#weakref.WeakValueDictionary", "type": "Data Types", "text": "\nMapping class that references values weakly. Entries in the dictionary will be\ndiscarded when no strong reference to the value exists any more.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "weakref.WeakValueDictionary.valuerefs()", "path": "library/weakref#weakref.WeakValueDictionary.valuerefs", "type": "Data Types", "text": "\nReturn an iterable of the weak references to the values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "webbrowser", "path": "library/webbrowser", "type": "Internet", "text": "\nSource code: Lib/webbrowser.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "webbrowser.controller.open()", "path": "library/webbrowser#webbrowser.controller.open", "type": "Internet", "text": "\nDisplay url using the browser handled by this controller. If new is 1, a new\nbrowser window is opened if possible. If new is 2, a new browser page (\u201ctab\u201d)\nis opened if possible.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "webbrowser.controller.open_new()", "path": "library/webbrowser#webbrowser.controller.open_new", "type": "Internet", "text": "\nOpen url in a new window of the browser handled by this controller, if\npossible, otherwise, open url in the only browser window. Alias `open_new()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "webbrowser.controller.open_new_tab()", "path": "library/webbrowser#webbrowser.controller.open_new_tab", "type": "Internet", "text": "\nOpen url in a new page (\u201ctab\u201d) of the browser handled by this controller, if\npossible, otherwise equivalent to `open_new()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "webbrowser.Error", "path": "library/webbrowser#webbrowser.Error", "type": "Internet", "text": "\nException raised when a browser control error occurs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "webbrowser.get()", "path": "library/webbrowser#webbrowser.get", "type": "Internet", "text": "\nReturn a controller object for the browser type using. If using is `None`,\nreturn a controller for a default browser appropriate to the caller\u2019s\nenvironment.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "webbrowser.open()", "path": "library/webbrowser#webbrowser.open", "type": "Internet", "text": "\nDisplay url using the default browser. If new is 0, the url is opened in the\nsame browser window if possible. If new is 1, a new browser window is opened\nif possible. If new is 2, a new browser page (\u201ctab\u201d) is opened if possible. If\nautoraise is `True`, the window is raised if possible (note that under many\nwindow managers this will occur regardless of the setting of this variable).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "webbrowser.open_new()", "path": "library/webbrowser#webbrowser.open_new", "type": "Internet", "text": "\nOpen url in a new window of the default browser, if possible, otherwise, open\nurl in the only browser window.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "webbrowser.open_new_tab()", "path": "library/webbrowser#webbrowser.open_new_tab", "type": "Internet", "text": "\nOpen url in a new page (\u201ctab\u201d) of the default browser, if possible, otherwise\nequivalent to `open_new()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "webbrowser.register()", "path": "library/webbrowser#webbrowser.register", "type": "Internet", "text": "\nRegister the browser type name. Once a browser type is registered, the `get()`\nfunction can return a controller for that browser type. If instance is not\nprovided, or is `None`, constructor will be called without parameters to\ncreate an instance when needed. If instance is provided, constructor will\nnever be called, and may be `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "WindowsError", "path": "library/exceptions#WindowsError", "type": "Built-in Exceptions", "text": "\nOnly available on Windows.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg", "path": "library/winreg", "type": "MS Windows", "text": "\nThese functions expose the Windows registry API to Python. Instead of using an\ninteger as the registry handle, a handle object is used to ensure that the\nhandles are closed correctly, even if the programmer neglects to explicitly\nclose them.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.CloseKey()", "path": "library/winreg#winreg.CloseKey", "type": "MS Windows", "text": "\nCloses a previously opened registry key. The hkey argument specifies a\npreviously opened key.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.ConnectRegistry()", "path": "library/winreg#winreg.ConnectRegistry", "type": "MS Windows", "text": "\nEstablishes a connection to a predefined registry handle on another computer,\nand returns a handle object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.CreateKey()", "path": "library/winreg#winreg.CreateKey", "type": "MS Windows", "text": "\nCreates or opens the specified key, returning a handle object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.CreateKeyEx()", "path": "library/winreg#winreg.CreateKeyEx", "type": "MS Windows", "text": "\nCreates or opens the specified key, returning a handle object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.DeleteKey()", "path": "library/winreg#winreg.DeleteKey", "type": "MS Windows", "text": "\nDeletes the specified key.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.DeleteKeyEx()", "path": "library/winreg#winreg.DeleteKeyEx", "type": "MS Windows", "text": "\nDeletes the specified key.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.DeleteValue()", "path": "library/winreg#winreg.DeleteValue", "type": "MS Windows", "text": "\nRemoves a named value from a registry key.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.DisableReflectionKey()", "path": "library/winreg#winreg.DisableReflectionKey", "type": "MS Windows", "text": "\nDisables registry reflection for 32-bit processes running on a 64-bit\noperating system.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.EnableReflectionKey()", "path": "library/winreg#winreg.EnableReflectionKey", "type": "MS Windows", "text": "\nRestores registry reflection for the specified disabled key.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.EnumKey()", "path": "library/winreg#winreg.EnumKey", "type": "MS Windows", "text": "\nEnumerates subkeys of an open registry key, returning a string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.EnumValue()", "path": "library/winreg#winreg.EnumValue", "type": "MS Windows", "text": "\nEnumerates values of an open registry key, returning a tuple.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.ExpandEnvironmentStrings()", "path": "library/winreg#winreg.ExpandEnvironmentStrings", "type": "MS Windows", "text": "\nExpands environment variable placeholders `%NAME%` in strings like\n`REG_EXPAND_SZ`:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.FlushKey()", "path": "library/winreg#winreg.FlushKey", "type": "MS Windows", "text": "\nWrites all the attributes of a key to the registry.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.HKEY_CLASSES_ROOT", "path": "library/winreg#winreg.HKEY_CLASSES_ROOT", "type": "MS Windows", "text": "\nRegistry entries subordinate to this key define types (or classes) of\ndocuments and the properties associated with those types. Shell and COM\napplications use the information stored under this key.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.HKEY_CURRENT_CONFIG", "path": "library/winreg#winreg.HKEY_CURRENT_CONFIG", "type": "MS Windows", "text": "\nContains information about the current hardware profile of the local computer\nsystem.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.HKEY_CURRENT_USER", "path": "library/winreg#winreg.HKEY_CURRENT_USER", "type": "MS Windows", "text": "\nRegistry entries subordinate to this key define the preferences of the current\nuser. These preferences include the settings of environment variables, data\nabout program groups, colors, printers, network connections, and application\npreferences.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.HKEY_DYN_DATA", "path": "library/winreg#winreg.HKEY_DYN_DATA", "type": "MS Windows", "text": "\nThis key is not used in versions of Windows after 98.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.HKEY_LOCAL_MACHINE", "path": "library/winreg#winreg.HKEY_LOCAL_MACHINE", "type": "MS Windows", "text": "\nRegistry entries subordinate to this key define the physical state of the\ncomputer, including data about the bus type, system memory, and installed\nhardware and software.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.HKEY_PERFORMANCE_DATA", "path": "library/winreg#winreg.HKEY_PERFORMANCE_DATA", "type": "MS Windows", "text": "\nRegistry entries subordinate to this key allow you to access performance data.\nThe data is not actually stored in the registry; the registry functions cause\nthe system to collect the data from its source.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.HKEY_USERS", "path": "library/winreg#winreg.HKEY_USERS", "type": "MS Windows", "text": "\nRegistry entries subordinate to this key define the default user configuration\nfor new users on the local computer and the user configuration for the current\nuser.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.KEY_ALL_ACCESS", "path": "library/winreg#winreg.KEY_ALL_ACCESS", "type": "MS Windows", "text": "\nCombines the STANDARD_RIGHTS_REQUIRED, `KEY_QUERY_VALUE`, `KEY_SET_VALUE`,\n`KEY_CREATE_SUB_KEY`, `KEY_ENUMERATE_SUB_KEYS`, `KEY_NOTIFY`, and\n`KEY_CREATE_LINK` access rights.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.KEY_CREATE_LINK", "path": "library/winreg#winreg.KEY_CREATE_LINK", "type": "MS Windows", "text": "\nReserved for system use.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.KEY_CREATE_SUB_KEY", "path": "library/winreg#winreg.KEY_CREATE_SUB_KEY", "type": "MS Windows", "text": "\nRequired to create a subkey of a registry key.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.KEY_ENUMERATE_SUB_KEYS", "path": "library/winreg#winreg.KEY_ENUMERATE_SUB_KEYS", "type": "MS Windows", "text": "\nRequired to enumerate the subkeys of a registry key.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.KEY_EXECUTE", "path": "library/winreg#winreg.KEY_EXECUTE", "type": "MS Windows", "text": "\nEquivalent to `KEY_READ`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.KEY_NOTIFY", "path": "library/winreg#winreg.KEY_NOTIFY", "type": "MS Windows", "text": "\nRequired to request change notifications for a registry key or for subkeys of\na registry key.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.KEY_QUERY_VALUE", "path": "library/winreg#winreg.KEY_QUERY_VALUE", "type": "MS Windows", "text": "\nRequired to query the values of a registry key.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.KEY_READ", "path": "library/winreg#winreg.KEY_READ", "type": "MS Windows", "text": "\nCombines the STANDARD_RIGHTS_READ, `KEY_QUERY_VALUE`,\n`KEY_ENUMERATE_SUB_KEYS`, and `KEY_NOTIFY` values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.KEY_SET_VALUE", "path": "library/winreg#winreg.KEY_SET_VALUE", "type": "MS Windows", "text": "\nRequired to create, delete, or set a registry value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.KEY_WOW64_32KEY", "path": "library/winreg#winreg.KEY_WOW64_32KEY", "type": "MS Windows", "text": "\nIndicates that an application on 64-bit Windows should operate on the 32-bit\nregistry view.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.KEY_WOW64_64KEY", "path": "library/winreg#winreg.KEY_WOW64_64KEY", "type": "MS Windows", "text": "\nIndicates that an application on 64-bit Windows should operate on the 64-bit\nregistry view.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.KEY_WRITE", "path": "library/winreg#winreg.KEY_WRITE", "type": "MS Windows", "text": "\nCombines the STANDARD_RIGHTS_WRITE, `KEY_SET_VALUE`, and `KEY_CREATE_SUB_KEY`\naccess rights.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.LoadKey()", "path": "library/winreg#winreg.LoadKey", "type": "MS Windows", "text": "\nCreates a subkey under the specified key and stores registration information\nfrom a specified file into that subkey.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.OpenKey()", "path": "library/winreg#winreg.OpenKey", "type": "MS Windows", "text": "\nOpens the specified key, returning a handle object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.OpenKeyEx()", "path": "library/winreg#winreg.OpenKeyEx", "type": "MS Windows", "text": "\nOpens the specified key, returning a handle object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.PyHKEY.Close()", "path": "library/winreg#winreg.PyHKEY.Close", "type": "MS Windows", "text": "\nCloses the underlying Windows handle.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.PyHKEY.Detach()", "path": "library/winreg#winreg.PyHKEY.Detach", "type": "MS Windows", "text": "\nDetaches the Windows handle from the handle object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.PyHKEY.__enter__()", "path": "library/winreg#winreg.PyHKEY.__enter__", "type": "MS Windows", "text": "\nThe HKEY object implements `__enter__()` and `__exit__()` and thus supports\nthe context protocol for the `with` statement:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.PyHKEY.__exit__()", "path": "library/winreg#winreg.PyHKEY.__exit__", "type": "MS Windows", "text": "\nThe HKEY object implements `__enter__()` and `__exit__()` and thus supports\nthe context protocol for the `with` statement:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.QueryInfoKey()", "path": "library/winreg#winreg.QueryInfoKey", "type": "MS Windows", "text": "\nReturns information about a key, as a tuple.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.QueryReflectionKey()", "path": "library/winreg#winreg.QueryReflectionKey", "type": "MS Windows", "text": "\nDetermines the reflection state for the specified key.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.QueryValue()", "path": "library/winreg#winreg.QueryValue", "type": "MS Windows", "text": "\nRetrieves the unnamed value for a key, as a string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.QueryValueEx()", "path": "library/winreg#winreg.QueryValueEx", "type": "MS Windows", "text": "\nRetrieves the type and data for a specified value name associated with an open\nregistry key.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.REG_BINARY", "path": "library/winreg#winreg.REG_BINARY", "type": "MS Windows", "text": "\nBinary data in any form.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.REG_DWORD", "path": "library/winreg#winreg.REG_DWORD", "type": "MS Windows", "text": "\n32-bit number.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.REG_DWORD_BIG_ENDIAN", "path": "library/winreg#winreg.REG_DWORD_BIG_ENDIAN", "type": "MS Windows", "text": "\nA 32-bit number in big-endian format.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.REG_DWORD_LITTLE_ENDIAN", "path": "library/winreg#winreg.REG_DWORD_LITTLE_ENDIAN", "type": "MS Windows", "text": "\nA 32-bit number in little-endian format. Equivalent to `REG_DWORD`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.REG_EXPAND_SZ", "path": "library/winreg#winreg.REG_EXPAND_SZ", "type": "MS Windows", "text": "\nNull-terminated string containing references to environment variables\n(`%PATH%`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.REG_FULL_RESOURCE_DESCRIPTOR", "path": "library/winreg#winreg.REG_FULL_RESOURCE_DESCRIPTOR", "type": "MS Windows", "text": "\nA hardware setting.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.REG_LINK", "path": "library/winreg#winreg.REG_LINK", "type": "MS Windows", "text": "\nA Unicode symbolic link.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.REG_MULTI_SZ", "path": "library/winreg#winreg.REG_MULTI_SZ", "type": "MS Windows", "text": "\nA sequence of null-terminated strings, terminated by two null characters.\n(Python handles this termination automatically.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.REG_NONE", "path": "library/winreg#winreg.REG_NONE", "type": "MS Windows", "text": "\nNo defined value type.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.REG_QWORD", "path": "library/winreg#winreg.REG_QWORD", "type": "MS Windows", "text": "\nA 64-bit number.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.REG_QWORD_LITTLE_ENDIAN", "path": "library/winreg#winreg.REG_QWORD_LITTLE_ENDIAN", "type": "MS Windows", "text": "\nA 64-bit number in little-endian format. Equivalent to `REG_QWORD`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.REG_RESOURCE_LIST", "path": "library/winreg#winreg.REG_RESOURCE_LIST", "type": "MS Windows", "text": "\nA device-driver resource list.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.REG_RESOURCE_REQUIREMENTS_LIST", "path": "library/winreg#winreg.REG_RESOURCE_REQUIREMENTS_LIST", "type": "MS Windows", "text": "\nA hardware resource list.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.REG_SZ", "path": "library/winreg#winreg.REG_SZ", "type": "MS Windows", "text": "\nA null-terminated string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.SaveKey()", "path": "library/winreg#winreg.SaveKey", "type": "MS Windows", "text": "\nSaves the specified key, and all its subkeys to the specified file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.SetValue()", "path": "library/winreg#winreg.SetValue", "type": "MS Windows", "text": "\nAssociates a value with a specified key.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winreg.SetValueEx()", "path": "library/winreg#winreg.SetValueEx", "type": "MS Windows", "text": "\nStores data in the value field of an open registry key.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winsound", "path": "library/winsound", "type": "MS Windows", "text": "\nThe `winsound` module provides access to the basic sound-playing machinery\nprovided by Windows platforms. It includes functions and several constants.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winsound.Beep()", "path": "library/winsound#winsound.Beep", "type": "MS Windows", "text": "\nBeep the PC\u2019s speaker. The frequency parameter specifies frequency, in hertz,\nof the sound, and must be in the range 37 through 32,767. The duration\nparameter specifies the number of milliseconds the sound should last. If the\nsystem is not able to beep the speaker, `RuntimeError` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winsound.MB_ICONASTERISK", "path": "library/winsound#winsound.MB_ICONASTERISK", "type": "MS Windows", "text": "\nPlay the `SystemDefault` sound.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winsound.MB_ICONEXCLAMATION", "path": "library/winsound#winsound.MB_ICONEXCLAMATION", "type": "MS Windows", "text": "\nPlay the `SystemExclamation` sound.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winsound.MB_ICONHAND", "path": "library/winsound#winsound.MB_ICONHAND", "type": "MS Windows", "text": "\nPlay the `SystemHand` sound.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winsound.MB_ICONQUESTION", "path": "library/winsound#winsound.MB_ICONQUESTION", "type": "MS Windows", "text": "\nPlay the `SystemQuestion` sound.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winsound.MB_OK", "path": "library/winsound#winsound.MB_OK", "type": "MS Windows", "text": "\nPlay the `SystemDefault` sound.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winsound.MessageBeep()", "path": "library/winsound#winsound.MessageBeep", "type": "MS Windows", "text": "\nCall the underlying `MessageBeep()` function from the Platform API. This plays\na sound as specified in the registry. The type argument specifies which sound\nto play; possible values are `-1`, `MB_ICONASTERISK`, `MB_ICONEXCLAMATION`,\n`MB_ICONHAND`, `MB_ICONQUESTION`, and `MB_OK`, all described below. The value\n`-1` produces a \u201csimple beep\u201d; this is the final fallback if a sound cannot be\nplayed otherwise. If the system indicates an error, `RuntimeError` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winsound.PlaySound()", "path": "library/winsound#winsound.PlaySound", "type": "MS Windows", "text": "\nCall the underlying `PlaySound()` function from the Platform API. The sound\nparameter may be a filename, a system sound alias, audio data as a bytes-like\nobject, or `None`. Its interpretation depends on the value of flags, which can\nbe a bitwise ORed combination of the constants described below. If the sound\nparameter is `None`, any currently playing waveform sound is stopped. If the\nsystem indicates an error, `RuntimeError` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winsound.SND_ALIAS", "path": "library/winsound#winsound.SND_ALIAS", "type": "MS Windows", "text": "\nThe sound parameter is a sound association name from the registry. If the\nregistry contains no such name, play the system default sound unless\n`SND_NODEFAULT` is also specified. If no default sound is registered, raise\n`RuntimeError`. Do not use with `SND_FILENAME`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winsound.SND_ASYNC", "path": "library/winsound#winsound.SND_ASYNC", "type": "MS Windows", "text": "\nReturn immediately, allowing sounds to play asynchronously.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winsound.SND_FILENAME", "path": "library/winsound#winsound.SND_FILENAME", "type": "MS Windows", "text": "\nThe sound parameter is the name of a WAV file. Do not use with `SND_ALIAS`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winsound.SND_LOOP", "path": "library/winsound#winsound.SND_LOOP", "type": "MS Windows", "text": "\nPlay the sound repeatedly. The `SND_ASYNC` flag must also be used to avoid\nblocking. Cannot be used with `SND_MEMORY`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winsound.SND_MEMORY", "path": "library/winsound#winsound.SND_MEMORY", "type": "MS Windows", "text": "\nThe sound parameter to `PlaySound()` is a memory image of a WAV file, as a\nbytes-like object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winsound.SND_NODEFAULT", "path": "library/winsound#winsound.SND_NODEFAULT", "type": "MS Windows", "text": "\nIf the specified sound cannot be found, do not play the system default sound.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winsound.SND_NOSTOP", "path": "library/winsound#winsound.SND_NOSTOP", "type": "MS Windows", "text": "\nDo not interrupt sounds currently playing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winsound.SND_NOWAIT", "path": "library/winsound#winsound.SND_NOWAIT", "type": "MS Windows", "text": "\nReturn immediately if the sound driver is busy.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "winsound.SND_PURGE", "path": "library/winsound#winsound.SND_PURGE", "type": "MS Windows", "text": "\nStop playing all instances of the specified sound.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref", "path": "library/wsgiref", "type": "Internet", "text": "\nThe Web Server Gateway Interface (WSGI) is a standard interface between web\nserver software and web applications written in Python. Having a standard\ninterface makes it easy to use an application that supports WSGI with a number\nof different web servers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.handlers.BaseCGIHandler", "path": "library/wsgiref#wsgiref.handlers.BaseCGIHandler", "type": "Internet", "text": "\nSimilar to `CGIHandler`, but instead of using the `sys` and `os` modules, the\nCGI environment and I/O streams are specified explicitly. The multithread and\nmultiprocess values are used to set the `wsgi.multithread` and\n`wsgi.multiprocess` flags for any applications run by the handler instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.handlers.BaseHandler", "path": "library/wsgiref#wsgiref.handlers.BaseHandler", "type": "Internet", "text": "\nThis is an abstract base class for running WSGI applications. Each instance\nwill handle a single HTTP request, although in principle you could create a\nsubclass that was reusable for multiple requests.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.handlers.BaseHandler.add_cgi_vars()", "path": "library/wsgiref#wsgiref.handlers.BaseHandler.add_cgi_vars", "type": "Internet", "text": "\nInsert CGI variables for the current request into the `environ` attribute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.handlers.BaseHandler.error_body", "path": "library/wsgiref#wsgiref.handlers.BaseHandler.error_body", "type": "Internet", "text": "\nThe error response body. This should be an HTTP response body bytestring. It\ndefaults to the plain text, \u201cA server error occurred. Please contact the\nadministrator.\u201d\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.handlers.BaseHandler.error_headers", "path": "library/wsgiref#wsgiref.handlers.BaseHandler.error_headers", "type": "Internet", "text": "\nThe HTTP headers used for error responses. This should be a list of WSGI\nresponse headers (`(name, value)` tuples), as described in PEP 3333. The\ndefault list just sets the content type to `text/plain`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.handlers.BaseHandler.error_output()", "path": "library/wsgiref#wsgiref.handlers.BaseHandler.error_output", "type": "Internet", "text": "\nThis method is a WSGI application to generate an error page for the user. It\nis only invoked if an error occurs before headers are sent to the client.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.handlers.BaseHandler.error_status", "path": "library/wsgiref#wsgiref.handlers.BaseHandler.error_status", "type": "Internet", "text": "\nThe HTTP status used for error responses. This should be a status string as\ndefined in PEP 3333; it defaults to a 500 code and message.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.handlers.BaseHandler.get_scheme()", "path": "library/wsgiref#wsgiref.handlers.BaseHandler.get_scheme", "type": "Internet", "text": "\nReturn the URL scheme being used for the current request. The default\nimplementation uses the `guess_scheme()` function from `wsgiref.util` to guess\nwhether the scheme should be \u201chttp\u201d or \u201chttps\u201d, based on the current request\u2019s\n`environ` variables.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.handlers.BaseHandler.get_stderr()", "path": "library/wsgiref#wsgiref.handlers.BaseHandler.get_stderr", "type": "Internet", "text": "\nReturn an output stream object suitable for use as the `wsgi.errors` of the\nrequest currently being processed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.handlers.BaseHandler.get_stdin()", "path": "library/wsgiref#wsgiref.handlers.BaseHandler.get_stdin", "type": "Internet", "text": "\nReturn an input stream object suitable for use as the `wsgi.input` of the\nrequest currently being processed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.handlers.BaseHandler.http_version", "path": "library/wsgiref#wsgiref.handlers.BaseHandler.http_version", "type": "Internet", "text": "\nIf `origin_server` is true, this string attribute is used to set the HTTP\nversion of the response set to the client. It defaults to `\"1.0\"`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.handlers.BaseHandler.log_exception()", "path": "library/wsgiref#wsgiref.handlers.BaseHandler.log_exception", "type": "Internet", "text": "\nLog the exc_info tuple in the server log. exc_info is a `(type, value,\ntraceback)` tuple. The default implementation simply writes the traceback to\nthe request\u2019s `wsgi.errors` stream and flushes it. Subclasses can override\nthis method to change the format or retarget the output, mail the traceback to\nan administrator, or whatever other action may be deemed suitable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.handlers.BaseHandler.origin_server", "path": "library/wsgiref#wsgiref.handlers.BaseHandler.origin_server", "type": "Internet", "text": "\nThis attribute should be set to a true value if the handler\u2019s `_write()` and\n`_flush()` are being used to communicate directly to the client, rather than\nvia a CGI-like gateway protocol that wants the HTTP status in a special\n`Status:` header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.handlers.BaseHandler.os_environ", "path": "library/wsgiref#wsgiref.handlers.BaseHandler.os_environ", "type": "Internet", "text": "\nThe default environment variables to be included in every request\u2019s WSGI\nenvironment. By default, this is a copy of `os.environ` at the time that\n`wsgiref.handlers` was imported, but subclasses can either create their own at\nthe class or instance level. Note that the dictionary should be considered\nread-only, since the default value is shared between multiple classes and\ninstances.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.handlers.BaseHandler.run()", "path": "library/wsgiref#wsgiref.handlers.BaseHandler.run", "type": "Internet", "text": "\nRun the specified WSGI application, app.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.handlers.BaseHandler.sendfile()", "path": "library/wsgiref#wsgiref.handlers.BaseHandler.sendfile", "type": "Internet", "text": "\nOverride to implement platform-specific file transmission. This method is\ncalled only if the application\u2019s return value is an instance of the class\nspecified by the `wsgi_file_wrapper` attribute. It should return a true value\nif it was able to successfully transmit the file, so that the default\ntransmission code will not be executed. The default implementation of this\nmethod just returns a false value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.handlers.BaseHandler.server_software", "path": "library/wsgiref#wsgiref.handlers.BaseHandler.server_software", "type": "Internet", "text": "\nIf the `origin_server` attribute is set, this attribute\u2019s value is used to set\nthe default `SERVER_SOFTWARE` WSGI environment variable, and also to set a\ndefault `Server:` header in HTTP responses. It is ignored for handlers (such\nas `BaseCGIHandler` and `CGIHandler`) that are not HTTP origin servers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.handlers.BaseHandler.setup_environ()", "path": "library/wsgiref#wsgiref.handlers.BaseHandler.setup_environ", "type": "Internet", "text": "\nSet the `environ` attribute to a fully-populated WSGI environment. The default\nimplementation uses all of the above methods and attributes, plus the\n`get_stdin()`, `get_stderr()`, and `add_cgi_vars()` methods and the\n`wsgi_file_wrapper` attribute. It also inserts a `SERVER_SOFTWARE` key if not\npresent, as long as the `origin_server` attribute is a true value and the\n`server_software` attribute is set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.handlers.BaseHandler.traceback_limit", "path": "library/wsgiref#wsgiref.handlers.BaseHandler.traceback_limit", "type": "Internet", "text": "\nThe maximum number of frames to include in tracebacks output by the default\n`log_exception()` method. If `None`, all frames are included.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.handlers.BaseHandler.wsgi_file_wrapper", "path": "library/wsgiref#wsgiref.handlers.BaseHandler.wsgi_file_wrapper", "type": "Internet", "text": "\nA `wsgi.file_wrapper` factory, or `None`. The default value of this attribute\nis the `wsgiref.util.FileWrapper` class.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.handlers.BaseHandler.wsgi_multiprocess", "path": "library/wsgiref#wsgiref.handlers.BaseHandler.wsgi_multiprocess", "type": "Internet", "text": "\nThe value to be used for the `wsgi.multiprocess` environment variable. It\ndefaults to true in `BaseHandler`, but may have a different default (or be set\nby the constructor) in the other subclasses.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.handlers.BaseHandler.wsgi_multithread", "path": "library/wsgiref#wsgiref.handlers.BaseHandler.wsgi_multithread", "type": "Internet", "text": "\nThe value to be used for the `wsgi.multithread` environment variable. It\ndefaults to true in `BaseHandler`, but may have a different default (or be set\nby the constructor) in the other subclasses.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.handlers.BaseHandler.wsgi_run_once", "path": "library/wsgiref#wsgiref.handlers.BaseHandler.wsgi_run_once", "type": "Internet", "text": "\nThe value to be used for the `wsgi.run_once` environment variable. It defaults\nto false in `BaseHandler`, but `CGIHandler` sets it to true by default.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.handlers.BaseHandler._flush()", "path": "library/wsgiref#wsgiref.handlers.BaseHandler._flush", "type": "Internet", "text": "\nForce buffered data to be transmitted to the client. It\u2019s okay if this method\nis a no-op (i.e., if `_write()` actually sends the data).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.handlers.BaseHandler._write()", "path": "library/wsgiref#wsgiref.handlers.BaseHandler._write", "type": "Internet", "text": "\nBuffer the bytes data for transmission to the client. It\u2019s okay if this method\nactually transmits the data; `BaseHandler` just separates write and flush\noperations for greater efficiency when the underlying system actually has such\na distinction.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.handlers.CGIHandler", "path": "library/wsgiref#wsgiref.handlers.CGIHandler", "type": "Internet", "text": "\nCGI-based invocation via `sys.stdin`, `sys.stdout`, `sys.stderr` and\n`os.environ`. This is useful when you have a WSGI application and want to run\nit as a CGI script. Simply invoke `CGIHandler().run(app)`, where `app` is the\nWSGI application object you wish to invoke.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.handlers.IISCGIHandler", "path": "library/wsgiref#wsgiref.handlers.IISCGIHandler", "type": "Internet", "text": "\nA specialized alternative to `CGIHandler`, for use when deploying on\nMicrosoft\u2019s IIS web server, without having set the config allowPathInfo option\n(IIS>=7) or metabase allowPathInfoForScriptMappings (IIS<7).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.handlers.read_environ()", "path": "library/wsgiref#wsgiref.handlers.read_environ", "type": "Internet", "text": "\nTranscode CGI variables from `os.environ` to PEP 3333 \u201cbytes in unicode\u201d\nstrings, returning a new dictionary. This function is used by `CGIHandler` and\n`IISCGIHandler` in place of directly using `os.environ`, which is not\nnecessarily WSGI-compliant on all platforms and web servers using Python 3 \u2013\nspecifically, ones where the OS\u2019s actual environment is Unicode (i.e.\nWindows), or ones where the environment is bytes, but the system encoding used\nby Python to decode it is anything other than ISO-8859-1 (e.g. Unix systems\nusing UTF-8).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.handlers.SimpleHandler", "path": "library/wsgiref#wsgiref.handlers.SimpleHandler", "type": "Internet", "text": "\nSimilar to `BaseCGIHandler`, but designed for use with HTTP origin servers. If\nyou are writing an HTTP server implementation, you will probably want to\nsubclass this instead of `BaseCGIHandler`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.headers.Headers", "path": "library/wsgiref#wsgiref.headers.Headers", "type": "Internet", "text": "\nCreate a mapping-like object wrapping headers, which must be a list of header\nname/value tuples as described in PEP 3333. The default value of headers is an\nempty list.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.headers.Headers.add_header()", "path": "library/wsgiref#wsgiref.headers.Headers.add_header", "type": "Internet", "text": "\nAdd a (possibly multi-valued) header, with optional MIME parameters specified\nvia keyword arguments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.headers.Headers.get_all()", "path": "library/wsgiref#wsgiref.headers.Headers.get_all", "type": "Internet", "text": "\nReturn a list of all the values for the named header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.simple_server.demo_app()", "path": "library/wsgiref#wsgiref.simple_server.demo_app", "type": "Internet", "text": "\nThis function is a small but complete WSGI application that returns a text\npage containing the message \u201cHello world!\u201d and a list of the key/value pairs\nprovided in the environ parameter. It\u2019s useful for verifying that a WSGI\nserver (such as `wsgiref.simple_server`) is able to run a simple WSGI\napplication correctly.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.simple_server.make_server()", "path": "library/wsgiref#wsgiref.simple_server.make_server", "type": "Internet", "text": "\nCreate a new WSGI server listening on host and port, accepting connections for\napp. The return value is an instance of the supplied server_class, and will\nprocess requests using the specified handler_class. app must be a WSGI\napplication object, as defined by PEP 3333.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.simple_server.WSGIRequestHandler", "path": "library/wsgiref#wsgiref.simple_server.WSGIRequestHandler", "type": "Internet", "text": "\nCreate an HTTP handler for the given request (i.e. a socket), client_address\n(a `(host,port)` tuple), and server (`WSGIServer` instance).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.simple_server.WSGIRequestHandler.get_environ()", "path": "library/wsgiref#wsgiref.simple_server.WSGIRequestHandler.get_environ", "type": "Internet", "text": "\nReturns a dictionary containing the WSGI environment for a request. The\ndefault implementation copies the contents of the `WSGIServer` object\u2019s\n`base_environ` dictionary attribute and then adds various headers derived from\nthe HTTP request. Each call to this method should return a new dictionary\ncontaining all of the relevant CGI environment variables as specified in PEP\n3333.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.simple_server.WSGIRequestHandler.get_stderr()", "path": "library/wsgiref#wsgiref.simple_server.WSGIRequestHandler.get_stderr", "type": "Internet", "text": "\nReturn the object that should be used as the `wsgi.errors` stream. The default\nimplementation just returns `sys.stderr`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.simple_server.WSGIRequestHandler.handle()", "path": "library/wsgiref#wsgiref.simple_server.WSGIRequestHandler.handle", "type": "Internet", "text": "\nProcess the HTTP request. The default implementation creates a handler\ninstance using a `wsgiref.handlers` class to implement the actual WSGI\napplication interface.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.simple_server.WSGIServer", "path": "library/wsgiref#wsgiref.simple_server.WSGIServer", "type": "Internet", "text": "\nCreate a `WSGIServer` instance. server_address should be a `(host,port)`\ntuple, and RequestHandlerClass should be the subclass of\n`http.server.BaseHTTPRequestHandler` that will be used to process requests.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.simple_server.WSGIServer.get_app()", "path": "library/wsgiref#wsgiref.simple_server.WSGIServer.get_app", "type": "Internet", "text": "\nReturns the currently-set application callable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.simple_server.WSGIServer.set_app()", "path": "library/wsgiref#wsgiref.simple_server.WSGIServer.set_app", "type": "Internet", "text": "\nSets the callable application as the WSGI application that will receive\nrequests.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.util.application_uri()", "path": "library/wsgiref#wsgiref.util.application_uri", "type": "Internet", "text": "\nSimilar to `request_uri()`, except that the `PATH_INFO` and `QUERY_STRING`\nvariables are ignored. The result is the base URI of the application object\naddressed by the request.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.util.FileWrapper", "path": "library/wsgiref#wsgiref.util.FileWrapper", "type": "Internet", "text": "\nA wrapper to convert a file-like object to an iterator. The resulting objects\nsupport both `__getitem__()` and `__iter__()` iteration styles, for\ncompatibility with Python 2.1 and Jython. As the object is iterated over, the\noptional blksize parameter will be repeatedly passed to the filelike object\u2019s\n`read()` method to obtain bytestrings to yield. When `read()` returns an empty\nbytestring, iteration is ended and is not resumable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.util.guess_scheme()", "path": "library/wsgiref#wsgiref.util.guess_scheme", "type": "Internet", "text": "\nReturn a guess for whether `wsgi.url_scheme` should be \u201chttp\u201d or \u201chttps\u201d, by\nchecking for a `HTTPS` environment variable in the environ dictionary. The\nreturn value is a string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.util.is_hop_by_hop()", "path": "library/wsgiref#wsgiref.util.is_hop_by_hop", "type": "Internet", "text": "\nReturn `True` if \u2018header_name\u2019 is an HTTP/1.1 \u201cHop-by-Hop\u201d header, as defined\nby RFC 2616.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.util.request_uri()", "path": "library/wsgiref#wsgiref.util.request_uri", "type": "Internet", "text": "\nReturn the full request URI, optionally including the query string, using the\nalgorithm found in the \u201cURL Reconstruction\u201d section of PEP 3333. If\ninclude_query is false, the query string is not included in the resulting URI.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.util.setup_testing_defaults()", "path": "library/wsgiref#wsgiref.util.setup_testing_defaults", "type": "Internet", "text": "\nUpdate environ with trivial defaults for testing purposes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.util.shift_path_info()", "path": "library/wsgiref#wsgiref.util.shift_path_info", "type": "Internet", "text": "\nShift a single name from `PATH_INFO` to `SCRIPT_NAME` and return the name. The\nenviron dictionary is modified in-place; use a copy if you need to keep the\noriginal `PATH_INFO` or `SCRIPT_NAME` intact.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wsgiref.validate.validator()", "path": "library/wsgiref#wsgiref.validate.validator", "type": "Internet", "text": "\nWrap application and return a new WSGI application object. The returned\napplication will forward all requests to the original application, and will\ncheck that both the application and the server invoking it are conforming to\nthe WSGI specification and to RFC 2616.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xdrlib", "path": "library/xdrlib", "type": "File Formats", "text": "\nSource code: Lib/xdrlib.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xdrlib.ConversionError", "path": "library/xdrlib#xdrlib.ConversionError", "type": "File Formats", "text": "\nClass derived from `Error`. Contains no additional instance variables.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xdrlib.Error", "path": "library/xdrlib#xdrlib.Error", "type": "File Formats", "text": "\nThe base exception class. `Error` has a single public attribute `msg`\ncontaining the description of the error.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xdrlib.Packer", "path": "library/xdrlib#xdrlib.Packer", "type": "File Formats", "text": "\n`Packer` is the class for packing data into XDR representation. The `Packer`\nclass is instantiated with no arguments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xdrlib.Packer.get_buffer()", "path": "library/xdrlib#xdrlib.Packer.get_buffer", "type": "File Formats", "text": "\nReturns the current pack buffer as a string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xdrlib.Packer.pack_array()", "path": "library/xdrlib#xdrlib.Packer.pack_array", "type": "File Formats", "text": "\nPacks a variable length list of homogeneous items. First, the length of the\nlist is packed as an unsigned integer, then each element is packed as in\n`pack_farray()` above.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xdrlib.Packer.pack_bytes()", "path": "library/xdrlib#xdrlib.Packer.pack_bytes", "type": "File Formats", "text": "\nPacks a variable length byte stream, similarly to `pack_string()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xdrlib.Packer.pack_double()", "path": "library/xdrlib#xdrlib.Packer.pack_double", "type": "File Formats", "text": "\nPacks the double-precision floating point number value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xdrlib.Packer.pack_farray()", "path": "library/xdrlib#xdrlib.Packer.pack_farray", "type": "File Formats", "text": "\nPacks a fixed length list (array) of homogeneous items. n is the length of the\nlist; it is not packed into the buffer, but a `ValueError` exception is raised\nif `len(array)` is not equal to n. As above, pack_item is the function used to\npack each element.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xdrlib.Packer.pack_float()", "path": "library/xdrlib#xdrlib.Packer.pack_float", "type": "File Formats", "text": "\nPacks the single-precision floating point number value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xdrlib.Packer.pack_fopaque()", "path": "library/xdrlib#xdrlib.Packer.pack_fopaque", "type": "File Formats", "text": "\nPacks a fixed length opaque data stream, similarly to `pack_fstring()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xdrlib.Packer.pack_fstring()", "path": "library/xdrlib#xdrlib.Packer.pack_fstring", "type": "File Formats", "text": "\nPacks a fixed length string, s. n is the length of the string but it is not\npacked into the data buffer. The string is padded with null bytes if necessary\nto guaranteed 4 byte alignment.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xdrlib.Packer.pack_list()", "path": "library/xdrlib#xdrlib.Packer.pack_list", "type": "File Formats", "text": "\nPacks a list of homogeneous items. This method is useful for lists with an\nindeterminate size; i.e. the size is not available until the entire list has\nbeen walked. For each item in the list, an unsigned integer `1` is packed\nfirst, followed by the data value from the list. pack_item is the function\nthat is called to pack the individual item. At the end of the list, an\nunsigned integer `0` is packed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xdrlib.Packer.pack_opaque()", "path": "library/xdrlib#xdrlib.Packer.pack_opaque", "type": "File Formats", "text": "\nPacks a variable length opaque data string, similarly to `pack_string()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xdrlib.Packer.pack_string()", "path": "library/xdrlib#xdrlib.Packer.pack_string", "type": "File Formats", "text": "\nPacks a variable length string, s. The length of the string is first packed as\nan unsigned integer, then the string data is packed with `pack_fstring()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xdrlib.Packer.reset()", "path": "library/xdrlib#xdrlib.Packer.reset", "type": "File Formats", "text": "\nResets the pack buffer to the empty string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xdrlib.Unpacker", "path": "library/xdrlib#xdrlib.Unpacker", "type": "File Formats", "text": "\n`Unpacker` is the complementary class which unpacks XDR data values from a\nstring buffer. The input buffer is given as data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xdrlib.Unpacker.done()", "path": "library/xdrlib#xdrlib.Unpacker.done", "type": "File Formats", "text": "\nIndicates unpack completion. Raises an `Error` exception if all of the data\nhas not been unpacked.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xdrlib.Unpacker.get_buffer()", "path": "library/xdrlib#xdrlib.Unpacker.get_buffer", "type": "File Formats", "text": "\nReturns the current unpack data buffer as a string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xdrlib.Unpacker.get_position()", "path": "library/xdrlib#xdrlib.Unpacker.get_position", "type": "File Formats", "text": "\nReturns the current unpack position in the data buffer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xdrlib.Unpacker.reset()", "path": "library/xdrlib#xdrlib.Unpacker.reset", "type": "File Formats", "text": "\nResets the string buffer with the given data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xdrlib.Unpacker.set_position()", "path": "library/xdrlib#xdrlib.Unpacker.set_position", "type": "File Formats", "text": "\nSets the data buffer unpack position to position. You should be careful about\nusing `get_position()` and `set_position()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xdrlib.Unpacker.unpack_array()", "path": "library/xdrlib#xdrlib.Unpacker.unpack_array", "type": "File Formats", "text": "\nUnpacks and returns a variable length list of homogeneous items. First, the\nlength of the list is unpacked as an unsigned integer, then each element is\nunpacked as in `unpack_farray()` above.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xdrlib.Unpacker.unpack_bytes()", "path": "library/xdrlib#xdrlib.Unpacker.unpack_bytes", "type": "File Formats", "text": "\nUnpacks and returns a variable length byte stream, similarly to\n`unpack_string()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xdrlib.Unpacker.unpack_double()", "path": "library/xdrlib#xdrlib.Unpacker.unpack_double", "type": "File Formats", "text": "\nUnpacks a double-precision floating point number, similarly to\n`unpack_float()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xdrlib.Unpacker.unpack_farray()", "path": "library/xdrlib#xdrlib.Unpacker.unpack_farray", "type": "File Formats", "text": "\nUnpacks and returns (as a list) a fixed length array of homogeneous items. n\nis number of list elements to expect in the buffer. As above, unpack_item is\nthe function used to unpack each element.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xdrlib.Unpacker.unpack_float()", "path": "library/xdrlib#xdrlib.Unpacker.unpack_float", "type": "File Formats", "text": "\nUnpacks a single-precision floating point number.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xdrlib.Unpacker.unpack_fopaque()", "path": "library/xdrlib#xdrlib.Unpacker.unpack_fopaque", "type": "File Formats", "text": "\nUnpacks and returns a fixed length opaque data stream, similarly to\n`unpack_fstring()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xdrlib.Unpacker.unpack_fstring()", "path": "library/xdrlib#xdrlib.Unpacker.unpack_fstring", "type": "File Formats", "text": "\nUnpacks and returns a fixed length string. n is the number of characters\nexpected. Padding with null bytes to guaranteed 4 byte alignment is assumed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xdrlib.Unpacker.unpack_list()", "path": "library/xdrlib#xdrlib.Unpacker.unpack_list", "type": "File Formats", "text": "\nUnpacks and returns a list of homogeneous items. The list is unpacked one\nelement at a time by first unpacking an unsigned integer flag. If the flag is\n`1`, then the item is unpacked and appended to the list. A flag of `0`\nindicates the end of the list. unpack_item is the function that is called to\nunpack the items.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xdrlib.Unpacker.unpack_opaque()", "path": "library/xdrlib#xdrlib.Unpacker.unpack_opaque", "type": "File Formats", "text": "\nUnpacks and returns a variable length opaque data string, similarly to\n`unpack_string()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xdrlib.Unpacker.unpack_string()", "path": "library/xdrlib#xdrlib.Unpacker.unpack_string", "type": "File Formats", "text": "\nUnpacks and returns a variable length string. The length of the string is\nfirst unpacked as an unsigned integer, then the string data is unpacked with\n`unpack_fstring()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "XML Processing Modules", "path": "library/xml", "type": "Structured Markup", "text": "\nSource code: Lib/xml/\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom", "path": "library/xml.dom", "type": "Structured Markup", "text": "\nSource code: Lib/xml/dom/__init__.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Attr.localName", "path": "library/xml.dom#xml.dom.Attr.localName", "type": "Structured Markup", "text": "\nThe part of the name following the colon if there is one, else the entire\nname. This is a read-only attribute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Attr.name", "path": "library/xml.dom#xml.dom.Attr.name", "type": "Structured Markup", "text": "\nThe attribute name. In a namespace-using document it may include a colon.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Attr.prefix", "path": "library/xml.dom#xml.dom.Attr.prefix", "type": "Structured Markup", "text": "\nThe part of the name preceding the colon if there is one, else the empty\nstring.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Attr.value", "path": "library/xml.dom#xml.dom.Attr.value", "type": "Structured Markup", "text": "\nThe text value of the attribute. This is a synonym for the `nodeValue`\nattribute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Comment.data", "path": "library/xml.dom#xml.dom.Comment.data", "type": "Structured Markup", "text": "\nThe content of the comment as a string. The attribute contains all characters\nbetween the leading `<!-``-` and trailing `-``->`, but does not include them.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Document.createAttribute()", "path": "library/xml.dom#xml.dom.Document.createAttribute", "type": "Structured Markup", "text": "\nCreate and return an attribute node. This method does not associate the\nattribute node with any particular element. You must use `setAttributeNode()`\non the appropriate `Element` object to use the newly created attribute\ninstance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Document.createAttributeNS()", "path": "library/xml.dom#xml.dom.Document.createAttributeNS", "type": "Structured Markup", "text": "\nCreate and return an attribute node with a namespace. The tagName may have a\nprefix. This method does not associate the attribute node with any particular\nelement. You must use `setAttributeNode()` on the appropriate `Element` object\nto use the newly created attribute instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Document.createComment()", "path": "library/xml.dom#xml.dom.Document.createComment", "type": "Structured Markup", "text": "\nCreate and return a comment node containing the data passed as a parameter. As\nwith the other creation methods, this one does not insert the node into the\ntree.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Document.createElement()", "path": "library/xml.dom#xml.dom.Document.createElement", "type": "Structured Markup", "text": "\nCreate and return a new element node. The element is not inserted into the\ndocument when it is created. You need to explicitly insert it with one of the\nother methods such as `insertBefore()` or `appendChild()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Document.createElementNS()", "path": "library/xml.dom#xml.dom.Document.createElementNS", "type": "Structured Markup", "text": "\nCreate and return a new element with a namespace. The tagName may have a\nprefix. The element is not inserted into the document when it is created. You\nneed to explicitly insert it with one of the other methods such as\n`insertBefore()` or `appendChild()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Document.createProcessingInstruction()", "path": "library/xml.dom#xml.dom.Document.createProcessingInstruction", "type": "Structured Markup", "text": "\nCreate and return a processing instruction node containing the target and data\npassed as parameters. As with the other creation methods, this one does not\ninsert the node into the tree.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Document.createTextNode()", "path": "library/xml.dom#xml.dom.Document.createTextNode", "type": "Structured Markup", "text": "\nCreate and return a text node containing the data passed as a parameter. As\nwith the other creation methods, this one does not insert the node into the\ntree.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Document.documentElement", "path": "library/xml.dom#xml.dom.Document.documentElement", "type": "Structured Markup", "text": "\nThe one and only root element of the document.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Document.getElementsByTagName()", "path": "library/xml.dom#xml.dom.Document.getElementsByTagName", "type": "Structured Markup", "text": "\nSearch for all descendants (direct children, children\u2019s children, etc.) with a\nparticular element type name.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Document.getElementsByTagNameNS()", "path": "library/xml.dom#xml.dom.Document.getElementsByTagNameNS", "type": "Structured Markup", "text": "\nSearch for all descendants (direct children, children\u2019s children, etc.) with a\nparticular namespace URI and localname. The localname is the part of the\nnamespace after the prefix.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.DocumentType.entities", "path": "library/xml.dom#xml.dom.DocumentType.entities", "type": "Structured Markup", "text": "\nThis is a `NamedNodeMap` giving the definitions of external entities. For\nentity names defined more than once, only the first definition is provided\n(others are ignored as required by the XML recommendation). This may be `None`\nif the information is not provided by the parser, or if no entities are\ndefined.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.DocumentType.internalSubset", "path": "library/xml.dom#xml.dom.DocumentType.internalSubset", "type": "Structured Markup", "text": "\nA string giving the complete internal subset from the document. This does not\ninclude the brackets which enclose the subset. If the document has no internal\nsubset, this should be `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.DocumentType.name", "path": "library/xml.dom#xml.dom.DocumentType.name", "type": "Structured Markup", "text": "\nThe name of the root element as given in the `DOCTYPE` declaration, if\npresent.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.DocumentType.notations", "path": "library/xml.dom#xml.dom.DocumentType.notations", "type": "Structured Markup", "text": "\nThis is a `NamedNodeMap` giving the definitions of notations. For notation\nnames defined more than once, only the first definition is provided (others\nare ignored as required by the XML recommendation). This may be `None` if the\ninformation is not provided by the parser, or if no notations are defined.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.DocumentType.publicId", "path": "library/xml.dom#xml.dom.DocumentType.publicId", "type": "Structured Markup", "text": "\nThe public identifier for the external subset of the document type definition.\nThis will be a string or `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.DocumentType.systemId", "path": "library/xml.dom#xml.dom.DocumentType.systemId", "type": "Structured Markup", "text": "\nThe system identifier for the external subset of the document type definition.\nThis will be a URI as a string, or `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.DOMException", "path": "library/xml.dom#xml.dom.DOMException", "type": "Structured Markup", "text": "\nBase exception class used for all specific DOM exceptions. This exception\nclass cannot be directly instantiated.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.DOMImplementation.createDocument()", "path": "library/xml.dom#xml.dom.DOMImplementation.createDocument", "type": "Structured Markup", "text": "\nReturn a new `Document` object (the root of the DOM), with a child `Element`\nobject having the given namespaceUri and qualifiedName. The doctype must be a\n`DocumentType` object created by `createDocumentType()`, or `None`. In the\nPython DOM API, the first two arguments can also be `None` in order to\nindicate that no `Element` child is to be created.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.DOMImplementation.createDocumentType()", "path": "library/xml.dom#xml.dom.DOMImplementation.createDocumentType", "type": "Structured Markup", "text": "\nReturn a new `DocumentType` object that encapsulates the given qualifiedName,\npublicId, and systemId strings, representing the information contained in an\nXML document type declaration.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.DOMImplementation.hasFeature()", "path": "library/xml.dom#xml.dom.DOMImplementation.hasFeature", "type": "Structured Markup", "text": "\nReturn `True` if the feature identified by the pair of strings feature and\nversion is implemented.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.DomstringSizeErr", "path": "library/xml.dom#xml.dom.DomstringSizeErr", "type": "Structured Markup", "text": "\nRaised when a specified range of text does not fit into a string. This is not\nknown to be used in the Python DOM implementations, but may be received from\nDOM implementations not written in Python.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Element.getAttribute()", "path": "library/xml.dom#xml.dom.Element.getAttribute", "type": "Structured Markup", "text": "\nReturn the value of the attribute named by name as a string. If no such\nattribute exists, an empty string is returned, as if the attribute had no\nvalue.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Element.getAttributeNode()", "path": "library/xml.dom#xml.dom.Element.getAttributeNode", "type": "Structured Markup", "text": "\nReturn the `Attr` node for the attribute named by attrname.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Element.getAttributeNodeNS()", "path": "library/xml.dom#xml.dom.Element.getAttributeNodeNS", "type": "Structured Markup", "text": "\nReturn an attribute value as a node, given a namespaceURI and localName.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Element.getAttributeNS()", "path": "library/xml.dom#xml.dom.Element.getAttributeNS", "type": "Structured Markup", "text": "\nReturn the value of the attribute named by namespaceURI and localName as a\nstring. If no such attribute exists, an empty string is returned, as if the\nattribute had no value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Element.getElementsByTagName()", "path": "library/xml.dom#xml.dom.Element.getElementsByTagName", "type": "Structured Markup", "text": "\nSame as equivalent method in the `Document` class.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Element.getElementsByTagNameNS()", "path": "library/xml.dom#xml.dom.Element.getElementsByTagNameNS", "type": "Structured Markup", "text": "\nSame as equivalent method in the `Document` class.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Element.hasAttribute()", "path": "library/xml.dom#xml.dom.Element.hasAttribute", "type": "Structured Markup", "text": "\nReturn `True` if the element has an attribute named by name.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Element.hasAttributeNS()", "path": "library/xml.dom#xml.dom.Element.hasAttributeNS", "type": "Structured Markup", "text": "\nReturn `True` if the element has an attribute named by namespaceURI and\nlocalName.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Element.removeAttribute()", "path": "library/xml.dom#xml.dom.Element.removeAttribute", "type": "Structured Markup", "text": "\nRemove an attribute by name. If there is no matching attribute, a\n`NotFoundErr` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Element.removeAttributeNode()", "path": "library/xml.dom#xml.dom.Element.removeAttributeNode", "type": "Structured Markup", "text": "\nRemove and return oldAttr from the attribute list, if present. If oldAttr is\nnot present, `NotFoundErr` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Element.removeAttributeNS()", "path": "library/xml.dom#xml.dom.Element.removeAttributeNS", "type": "Structured Markup", "text": "\nRemove an attribute by name. Note that it uses a localName, not a qname. No\nexception is raised if there is no matching attribute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Element.setAttribute()", "path": "library/xml.dom#xml.dom.Element.setAttribute", "type": "Structured Markup", "text": "\nSet an attribute value from a string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Element.setAttributeNode()", "path": "library/xml.dom#xml.dom.Element.setAttributeNode", "type": "Structured Markup", "text": "\nAdd a new attribute node to the element, replacing an existing attribute if\nnecessary if the `name` attribute matches. If a replacement occurs, the old\nattribute node will be returned. If newAttr is already in use,\n`InuseAttributeErr` will be raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Element.setAttributeNodeNS()", "path": "library/xml.dom#xml.dom.Element.setAttributeNodeNS", "type": "Structured Markup", "text": "\nAdd a new attribute node to the element, replacing an existing attribute if\nnecessary if the `namespaceURI` and `localName` attributes match. If a\nreplacement occurs, the old attribute node will be returned. If newAttr is\nalready in use, `InuseAttributeErr` will be raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Element.setAttributeNS()", "path": "library/xml.dom#xml.dom.Element.setAttributeNS", "type": "Structured Markup", "text": "\nSet an attribute value from a string, given a namespaceURI and a qname. Note\nthat a qname is the whole attribute name. This is different than above.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Element.tagName", "path": "library/xml.dom#xml.dom.Element.tagName", "type": "Structured Markup", "text": "\nThe element type name. In a namespace-using document it may have colons in it.\nThe value is a string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.EMPTY_NAMESPACE", "path": "library/xml.dom#xml.dom.EMPTY_NAMESPACE", "type": "Structured Markup", "text": "\nThe value used to indicate that no namespace is associated with a node in the\nDOM. This is typically found as the `namespaceURI` of a node, or used as the\nnamespaceURI parameter to a namespaces-specific method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.getDOMImplementation()", "path": "library/xml.dom#xml.dom.getDOMImplementation", "type": "Structured Markup", "text": "\nReturn a suitable DOM implementation. The name is either well-known, the\nmodule name of a DOM implementation, or `None`. If it is not `None`, imports\nthe corresponding module and returns a `DOMImplementation` object if the\nimport succeeds. If no name is given, and if the environment variable\n`PYTHON_DOM` is set, this variable is used to find the implementation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.HierarchyRequestErr", "path": "library/xml.dom#xml.dom.HierarchyRequestErr", "type": "Structured Markup", "text": "\nRaised when an attempt is made to insert a node where the node type is not\nallowed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.IndexSizeErr", "path": "library/xml.dom#xml.dom.IndexSizeErr", "type": "Structured Markup", "text": "\nRaised when an index or size parameter to a method is negative or exceeds the\nallowed values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.InuseAttributeErr", "path": "library/xml.dom#xml.dom.InuseAttributeErr", "type": "Structured Markup", "text": "\nRaised when an attempt is made to insert an `Attr` node that is already\npresent elsewhere in the document.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.InvalidAccessErr", "path": "library/xml.dom#xml.dom.InvalidAccessErr", "type": "Structured Markup", "text": "\nRaised if a parameter or an operation is not supported on the underlying\nobject.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.InvalidCharacterErr", "path": "library/xml.dom#xml.dom.InvalidCharacterErr", "type": "Structured Markup", "text": "\nThis exception is raised when a string parameter contains a character that is\nnot permitted in the context it\u2019s being used in by the XML 1.0 recommendation.\nFor example, attempting to create an `Element` node with a space in the\nelement type name will cause this error to be raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.InvalidModificationErr", "path": "library/xml.dom#xml.dom.InvalidModificationErr", "type": "Structured Markup", "text": "\nRaised when an attempt is made to modify the type of a node.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.InvalidStateErr", "path": "library/xml.dom#xml.dom.InvalidStateErr", "type": "Structured Markup", "text": "\nRaised when an attempt is made to use an object that is not defined or is no\nlonger usable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.minidom", "path": "library/xml.dom.minidom", "type": "Structured Markup", "text": "\nSource code: Lib/xml/dom/minidom.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.minidom.Node.toprettyxml()", "path": "library/xml.dom.minidom#xml.dom.minidom.Node.toprettyxml", "type": "Structured Markup", "text": "\nReturn a pretty-printed version of the document. indent specifies the\nindentation string and defaults to a tabulator; newl specifies the string\nemitted at the end of each line and defaults to `\\n`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.minidom.Node.toxml()", "path": "library/xml.dom.minidom#xml.dom.minidom.Node.toxml", "type": "Structured Markup", "text": "\nReturn a string or byte string containing the XML represented by the DOM node.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.minidom.Node.unlink()", "path": "library/xml.dom.minidom#xml.dom.minidom.Node.unlink", "type": "Structured Markup", "text": "\nBreak internal references within the DOM so that it will be garbage collected\non versions of Python without cyclic GC. Even when cyclic GC is available,\nusing this can make large amounts of memory available sooner, so calling this\non DOM objects as soon as they are no longer needed is good practice. This\nonly needs to be called on the `Document` object, but may be called on child\nnodes to discard children of that node.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.minidom.Node.writexml()", "path": "library/xml.dom.minidom#xml.dom.minidom.Node.writexml", "type": "Structured Markup", "text": "\nWrite XML to the writer object. The writer receives texts but not bytes as\ninput, it should have a `write()` method which matches that of the file object\ninterface. The indent parameter is the indentation of the current node. The\naddindent parameter is the incremental indentation to use for subnodes of the\ncurrent one. The newl parameter specifies the string to use to terminate\nnewlines.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.minidom.parse()", "path": "library/xml.dom.minidom#xml.dom.minidom.parse", "type": "Structured Markup", "text": "\nReturn a `Document` from the given input. filename_or_file may be either a\nfile name, or a file-like object. parser, if given, must be a SAX2 parser\nobject. This function will change the document handler of the parser and\nactivate namespace support; other parser configuration (like setting an entity\nresolver) must have been done in advance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.minidom.parseString()", "path": "library/xml.dom.minidom#xml.dom.minidom.parseString", "type": "Structured Markup", "text": "\nReturn a `Document` that represents the string. This method creates an\n`io.StringIO` object for the string and passes that on to `parse()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.NamedNodeMap.item()", "path": "library/xml.dom#xml.dom.NamedNodeMap.item", "type": "Structured Markup", "text": "\nReturn an attribute with a particular index. The order you get the attributes\nin is arbitrary but will be consistent for the life of a DOM. Each item is an\nattribute node. Get its value with the `value` attribute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.NamedNodeMap.length", "path": "library/xml.dom#xml.dom.NamedNodeMap.length", "type": "Structured Markup", "text": "\nThe length of the attribute list.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.NamespaceErr", "path": "library/xml.dom#xml.dom.NamespaceErr", "type": "Structured Markup", "text": "\nIf an attempt is made to change any object in a way that is not permitted with\nregard to the Namespaces in XML recommendation, this exception is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.NoDataAllowedErr", "path": "library/xml.dom#xml.dom.NoDataAllowedErr", "type": "Structured Markup", "text": "\nThis is raised if data is specified for a node which does not support data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Node.appendChild()", "path": "library/xml.dom#xml.dom.Node.appendChild", "type": "Structured Markup", "text": "\nAdd a new child node to this node at the end of the list of children,\nreturning newChild. If the node was already in the tree, it is removed first.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Node.attributes", "path": "library/xml.dom#xml.dom.Node.attributes", "type": "Structured Markup", "text": "\nA `NamedNodeMap` of attribute objects. Only elements have actual values for\nthis; others provide `None` for this attribute. This is a read-only attribute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Node.childNodes", "path": "library/xml.dom#xml.dom.Node.childNodes", "type": "Structured Markup", "text": "\nA list of nodes contained within this node. This is a read-only attribute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Node.cloneNode()", "path": "library/xml.dom#xml.dom.Node.cloneNode", "type": "Structured Markup", "text": "\nClone this node. Setting deep means to clone all child nodes as well. This\nreturns the clone.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Node.firstChild", "path": "library/xml.dom#xml.dom.Node.firstChild", "type": "Structured Markup", "text": "\nThe first child of the node, if there are any, or `None`. This is a read-only\nattribute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Node.hasAttributes()", "path": "library/xml.dom#xml.dom.Node.hasAttributes", "type": "Structured Markup", "text": "\nReturn `True` if the node has any attributes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Node.hasChildNodes()", "path": "library/xml.dom#xml.dom.Node.hasChildNodes", "type": "Structured Markup", "text": "\nReturn `True` if the node has any child nodes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Node.insertBefore()", "path": "library/xml.dom#xml.dom.Node.insertBefore", "type": "Structured Markup", "text": "\nInsert a new child node before an existing child. It must be the case that\nrefChild is a child of this node; if not, `ValueError` is raised. newChild is\nreturned. If refChild is `None`, it inserts newChild at the end of the\nchildren\u2019s list.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Node.isSameNode()", "path": "library/xml.dom#xml.dom.Node.isSameNode", "type": "Structured Markup", "text": "\nReturn `True` if other refers to the same node as this node. This is\nespecially useful for DOM implementations which use any sort of proxy\narchitecture (because more than one object can refer to the same node).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Node.lastChild", "path": "library/xml.dom#xml.dom.Node.lastChild", "type": "Structured Markup", "text": "\nThe last child of the node, if there are any, or `None`. This is a read-only\nattribute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Node.localName", "path": "library/xml.dom#xml.dom.Node.localName", "type": "Structured Markup", "text": "\nThe part of the `tagName` following the colon if there is one, else the entire\n`tagName`. The value is a string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Node.namespaceURI", "path": "library/xml.dom#xml.dom.Node.namespaceURI", "type": "Structured Markup", "text": "\nThe namespace associated with the element name. This will be a string or\n`None`. This is a read-only attribute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Node.nextSibling", "path": "library/xml.dom#xml.dom.Node.nextSibling", "type": "Structured Markup", "text": "\nThe node that immediately follows this one with the same parent. See also\n`previousSibling`. If this is the last child of the parent, this attribute\nwill be `None`. This is a read-only attribute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Node.nodeName", "path": "library/xml.dom#xml.dom.Node.nodeName", "type": "Structured Markup", "text": "\nThis has a different meaning for each node type; see the DOM specification for\ndetails. You can always get the information you would get here from another\nproperty such as the `tagName` property for elements or the `name` property\nfor attributes. For all node types, the value of this attribute will be either\na string or `None`. This is a read-only attribute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Node.nodeType", "path": "library/xml.dom#xml.dom.Node.nodeType", "type": "Structured Markup", "text": "\nAn integer representing the node type. Symbolic constants for the types are on\nthe `Node` object: `ELEMENT_NODE`, `ATTRIBUTE_NODE`, `TEXT_NODE`,\n`CDATA_SECTION_NODE`, `ENTITY_NODE`, `PROCESSING_INSTRUCTION_NODE`,\n`COMMENT_NODE`, `DOCUMENT_NODE`, `DOCUMENT_TYPE_NODE`, `NOTATION_NODE`. This\nis a read-only attribute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Node.nodeValue", "path": "library/xml.dom#xml.dom.Node.nodeValue", "type": "Structured Markup", "text": "\nThis has a different meaning for each node type; see the DOM specification for\ndetails. The situation is similar to that with `nodeName`. The value is a\nstring or `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Node.normalize()", "path": "library/xml.dom#xml.dom.Node.normalize", "type": "Structured Markup", "text": "\nJoin adjacent text nodes so that all stretches of text are stored as single\n`Text` instances. This simplifies processing text from a DOM tree for many\napplications.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Node.parentNode", "path": "library/xml.dom#xml.dom.Node.parentNode", "type": "Structured Markup", "text": "\nThe parent of the current node, or `None` for the document node. The value is\nalways a `Node` object or `None`. For `Element` nodes, this will be the parent\nelement, except for the root element, in which case it will be the `Document`\nobject. For `Attr` nodes, this is always `None`. This is a read-only\nattribute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Node.prefix", "path": "library/xml.dom#xml.dom.Node.prefix", "type": "Structured Markup", "text": "\nThe part of the `tagName` preceding the colon if there is one, else the empty\nstring. The value is a string, or `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Node.previousSibling", "path": "library/xml.dom#xml.dom.Node.previousSibling", "type": "Structured Markup", "text": "\nThe node that immediately precedes this one with the same parent. For instance\nthe element with an end-tag that comes just before the self element\u2019s start-\ntag. Of course, XML documents are made up of more than just elements so the\nprevious sibling could be text, a comment, or something else. If this node is\nthe first child of the parent, this attribute will be `None`. This is a read-\nonly attribute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Node.removeChild()", "path": "library/xml.dom#xml.dom.Node.removeChild", "type": "Structured Markup", "text": "\nRemove a child node. oldChild must be a child of this node; if not,\n`ValueError` is raised. oldChild is returned on success. If oldChild will not\nbe used further, its `unlink()` method should be called.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Node.replaceChild()", "path": "library/xml.dom#xml.dom.Node.replaceChild", "type": "Structured Markup", "text": "\nReplace an existing node with a new node. It must be the case that oldChild is\na child of this node; if not, `ValueError` is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.NodeList.item()", "path": "library/xml.dom#xml.dom.NodeList.item", "type": "Structured Markup", "text": "\nReturn the i\u2019th item from the sequence, if there is one, or `None`. The index\ni is not allowed to be less than zero or greater than or equal to the length\nof the sequence.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.NodeList.length", "path": "library/xml.dom#xml.dom.NodeList.length", "type": "Structured Markup", "text": "\nThe number of nodes in the sequence.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.NoModificationAllowedErr", "path": "library/xml.dom#xml.dom.NoModificationAllowedErr", "type": "Structured Markup", "text": "\nRaised on attempts to modify an object where modifications are not allowed\n(such as for read-only nodes).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.NotFoundErr", "path": "library/xml.dom#xml.dom.NotFoundErr", "type": "Structured Markup", "text": "\nException when a node does not exist in the referenced context. For example,\n`NamedNodeMap.removeNamedItem()` will raise this if the node passed in does\nnot exist in the map.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.NotSupportedErr", "path": "library/xml.dom#xml.dom.NotSupportedErr", "type": "Structured Markup", "text": "\nRaised when the implementation does not support the requested type of object\nor operation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.ProcessingInstruction.data", "path": "library/xml.dom#xml.dom.ProcessingInstruction.data", "type": "Structured Markup", "text": "\nThe content of the processing instruction following the first whitespace\ncharacter.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.ProcessingInstruction.target", "path": "library/xml.dom#xml.dom.ProcessingInstruction.target", "type": "Structured Markup", "text": "\nThe content of the processing instruction up to the first whitespace\ncharacter. This is a read-only attribute.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.pulldom", "path": "library/xml.dom.pulldom", "type": "Structured Markup", "text": "\nSource code: Lib/xml/dom/pulldom.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.pulldom.default_bufsize", "path": "library/xml.dom.pulldom#xml.dom.pulldom.default_bufsize", "type": "Structured Markup", "text": "\nDefault value for the bufsize parameter to `parse()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.pulldom.DOMEventStream", "path": "library/xml.dom.pulldom#xml.dom.pulldom.DOMEventStream", "type": "Structured Markup", "text": "\nDeprecated since version 3.8: Support for `sequence protocol` is deprecated.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.pulldom.DOMEventStream.expandNode()", "path": "library/xml.dom.pulldom#xml.dom.pulldom.DOMEventStream.expandNode", "type": "Structured Markup", "text": "\nExpands all children of node into node. Example:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.pulldom.DOMEventStream.getEvent()", "path": "library/xml.dom.pulldom#xml.dom.pulldom.DOMEventStream.getEvent", "type": "Structured Markup", "text": "\nReturn a tuple containing event and the current node as\n`xml.dom.minidom.Document` if event equals `START_DOCUMENT`,\n`xml.dom.minidom.Element` if event equals `START_ELEMENT` or `END_ELEMENT` or\n`xml.dom.minidom.Text` if event equals `CHARACTERS`. The current node does not\ncontain information about its children, unless `expandNode()` is called.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.pulldom.DOMEventStream.reset()", "path": "library/xml.dom.pulldom#xml.dom.pulldom.DOMEventStream.reset", "type": "Structured Markup", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.pulldom.parse()", "path": "library/xml.dom.pulldom#xml.dom.pulldom.parse", "type": "Structured Markup", "text": "\nReturn a `DOMEventStream` from the given input. stream_or_string may be either\na file name, or a file-like object. parser, if given, must be an `XMLReader`\nobject. This function will change the document handler of the parser and\nactivate namespace support; other parser configuration (like setting an entity\nresolver) must have been done in advance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.pulldom.parseString()", "path": "library/xml.dom.pulldom#xml.dom.pulldom.parseString", "type": "Structured Markup", "text": "\nReturn a `DOMEventStream` that represents the (Unicode) string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.pulldom.PullDom", "path": "library/xml.dom.pulldom#xml.dom.pulldom.PullDom", "type": "Structured Markup", "text": "\nSubclass of `xml.sax.handler.ContentHandler`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.pulldom.SAX2DOM", "path": "library/xml.dom.pulldom#xml.dom.pulldom.SAX2DOM", "type": "Structured Markup", "text": "\nSubclass of `xml.sax.handler.ContentHandler`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.registerDOMImplementation()", "path": "library/xml.dom#xml.dom.registerDOMImplementation", "type": "Structured Markup", "text": "\nRegister the factory function with the name name. The factory function should\nreturn an object which implements the `DOMImplementation` interface. The\nfactory function can return the same object every time, or a new one for each\ncall, as appropriate for the specific implementation (e.g. if that\nimplementation supports some customization).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.SyntaxErr", "path": "library/xml.dom#xml.dom.SyntaxErr", "type": "Structured Markup", "text": "\nRaised when an invalid or illegal string is specified.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.Text.data", "path": "library/xml.dom#xml.dom.Text.data", "type": "Structured Markup", "text": "\nThe content of the text node as a string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.WrongDocumentErr", "path": "library/xml.dom#xml.dom.WrongDocumentErr", "type": "Structured Markup", "text": "\nRaised when a node is inserted in a different document than it currently\nbelongs to, and the implementation does not support migrating the node from\none document to the other.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.XHTML_NAMESPACE", "path": "library/xml.dom#xml.dom.XHTML_NAMESPACE", "type": "Structured Markup", "text": "\nThe URI of the XHTML namespace as defined by XHTML 1.0: The Extensible\nHyperText Markup Language (section 3.1.1).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.XMLNS_NAMESPACE", "path": "library/xml.dom#xml.dom.XMLNS_NAMESPACE", "type": "Structured Markup", "text": "\nThe namespace URI for namespace declarations, as defined by Document Object\nModel (DOM) Level 2 Core Specification (section 1.1.8).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.dom.XML_NAMESPACE", "path": "library/xml.dom#xml.dom.XML_NAMESPACE", "type": "Structured Markup", "text": "\nThe namespace URI associated with the reserved prefix `xml`, as defined by\nNamespaces in XML (section 4).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree", "path": "library/xml.etree.elementtree", "type": "Structured Markup", "text": "\nSource code: Lib/xml/etree/ElementTree.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.C14NWriterTarget", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.C14NWriterTarget", "type": "Structured Markup", "text": "\nA C14N 2.0 writer. Arguments are the same as for the `canonicalize()`\nfunction. This class does not build a tree but translates the callback events\ndirectly into a serialised form using the write function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.canonicalize()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.canonicalize", "type": "Structured Markup", "text": "\nC14N 2.0 transformation function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.Comment()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.Comment", "type": "Structured Markup", "text": "\nComment element factory. This factory function creates a special element that\nwill be serialized as an XML comment by the standard serializer. The comment\nstring can be either a bytestring or a Unicode string. text is a string\ncontaining the comment string. Returns an element instance representing a\ncomment.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.dump()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.dump", "type": "Structured Markup", "text": "\nWrites an element tree or element structure to sys.stdout. This function\nshould be used for debugging only.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.Element", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.Element", "type": "Structured Markup", "text": "\nElement class. This class defines the Element interface, and provides a\nreference implementation of this interface.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.Element.append()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.Element.append", "type": "Structured Markup", "text": "\nAdds the element subelement to the end of this element\u2019s internal list of\nsubelements. Raises `TypeError` if subelement is not an `Element`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.Element.attrib", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.Element.attrib", "type": "Structured Markup", "text": "\nA dictionary containing the element\u2019s attributes. Note that while the attrib\nvalue is always a real mutable Python dictionary, an ElementTree\nimplementation may choose to use another internal representation, and create\nthe dictionary only if someone asks for it. To take advantage of such\nimplementations, use the dictionary methods below whenever possible.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.Element.clear()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.Element.clear", "type": "Structured Markup", "text": "\nResets an element. This function removes all subelements, clears all\nattributes, and sets the text and tail attributes to `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.Element.extend()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.Element.extend", "type": "Structured Markup", "text": "\nAppends subelements from a sequence object with zero or more elements. Raises\n`TypeError` if a subelement is not an `Element`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.Element.find()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.Element.find", "type": "Structured Markup", "text": "\nFinds the first subelement matching match. match may be a tag name or a path.\nReturns an element instance or `None`. namespaces is an optional mapping from\nnamespace prefix to full name. Pass `''` as prefix to move all unprefixed tag\nnames in the expression into the given namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.Element.findall()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.Element.findall", "type": "Structured Markup", "text": "\nFinds all matching subelements, by tag name or path. Returns a list containing\nall matching elements in document order. namespaces is an optional mapping\nfrom namespace prefix to full name. Pass `''` as prefix to move all unprefixed\ntag names in the expression into the given namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.Element.findtext()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.Element.findtext", "type": "Structured Markup", "text": "\nFinds text for the first subelement matching match. match may be a tag name or\na path. Returns the text content of the first matching element, or default if\nno element was found. Note that if the matching element has no text content an\nempty string is returned. namespaces is an optional mapping from namespace\nprefix to full name. Pass `''` as prefix to move all unprefixed tag names in\nthe expression into the given namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.Element.get()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.Element.get", "type": "Structured Markup", "text": "\nGets the element attribute named key.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.Element.insert()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.Element.insert", "type": "Structured Markup", "text": "\nInserts subelement at the given position in this element. Raises `TypeError`\nif subelement is not an `Element`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.Element.items()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.Element.items", "type": "Structured Markup", "text": "\nReturns the element attributes as a sequence of (name, value) pairs. The\nattributes are returned in an arbitrary order.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.Element.iter()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.Element.iter", "type": "Structured Markup", "text": "\nCreates a tree iterator with the current element as the root. The iterator\niterates over this element and all elements below it, in document (depth\nfirst) order. If tag is not `None` or `'*'`, only elements whose tag equals\ntag are returned from the iterator. If the tree structure is modified during\niteration, the result is undefined.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.Element.iterfind()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.Element.iterfind", "type": "Structured Markup", "text": "\nFinds all matching subelements, by tag name or path. Returns an iterable\nyielding all matching elements in document order. namespaces is an optional\nmapping from namespace prefix to full name.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.Element.itertext()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.Element.itertext", "type": "Structured Markup", "text": "\nCreates a text iterator. The iterator loops over this element and all\nsubelements, in document order, and returns all inner text.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.Element.keys()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.Element.keys", "type": "Structured Markup", "text": "\nReturns the elements attribute names as a list. The names are returned in an\narbitrary order.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.Element.makeelement()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.Element.makeelement", "type": "Structured Markup", "text": "\nCreates a new element object of the same type as this element. Do not call\nthis method, use the `SubElement()` factory function instead.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.Element.remove()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.Element.remove", "type": "Structured Markup", "text": "\nRemoves subelement from the element. Unlike the find* methods this method\ncompares elements based on the instance identity, not on tag value or\ncontents.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.Element.set()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.Element.set", "type": "Structured Markup", "text": "\nSet the attribute key on the element to value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.Element.tag", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.Element.tag", "type": "Structured Markup", "text": "\nA string identifying what kind of data this element represents (the element\ntype, in other words).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.Element.tail", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.Element.tail", "type": "Structured Markup", "text": "\nThese attributes can be used to hold additional data associated with the\nelement. Their values are usually strings but may be any application-specific\nobject. If the element is created from an XML file, the text attribute holds\neither the text between the element\u2019s start tag and its first child or end\ntag, or `None`, and the tail attribute holds either the text between the\nelement\u2019s end tag and the next tag, or `None`. For the XML data\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.Element.text", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.Element.text", "type": "Structured Markup", "text": "\nThese attributes can be used to hold additional data associated with the\nelement. Their values are usually strings but may be any application-specific\nobject. If the element is created from an XML file, the text attribute holds\neither the text between the element\u2019s start tag and its first child or end\ntag, or `None`, and the tail attribute holds either the text between the\nelement\u2019s end tag and the next tag, or `None`. For the XML data\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.ElementTree", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.ElementTree", "type": "Structured Markup", "text": "\nElementTree wrapper class. This class represents an entire element hierarchy,\nand adds some extra support for serialization to and from standard XML.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.ElementTree.find()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.ElementTree.find", "type": "Structured Markup", "text": "\nSame as `Element.find()`, starting at the root of the tree.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.ElementTree.findall()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.ElementTree.findall", "type": "Structured Markup", "text": "\nSame as `Element.findall()`, starting at the root of the tree.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.ElementTree.findtext()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.ElementTree.findtext", "type": "Structured Markup", "text": "\nSame as `Element.findtext()`, starting at the root of the tree.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.ElementTree.getroot()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.ElementTree.getroot", "type": "Structured Markup", "text": "\nReturns the root element for this tree.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.ElementTree.iter()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.ElementTree.iter", "type": "Structured Markup", "text": "\nCreates and returns a tree iterator for the root element. The iterator loops\nover all elements in this tree, in section order. tag is the tag to look for\n(default is to return all elements).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.ElementTree.iterfind()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.ElementTree.iterfind", "type": "Structured Markup", "text": "\nSame as `Element.iterfind()`, starting at the root of the tree.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.ElementTree.parse()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.ElementTree.parse", "type": "Structured Markup", "text": "\nLoads an external XML section into this element tree. source is a file name or\nfile object. parser is an optional parser instance. If not given, the standard\n`XMLParser` parser is used. Returns the section root element.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.ElementTree.write()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.ElementTree.write", "type": "Structured Markup", "text": "\nWrites the element tree to a file, as XML. file is a file name, or a file\nobject opened for writing. encoding 1 is the output encoding (default is US-\nASCII). xml_declaration controls if an XML declaration should be added to the\nfile. Use `False` for never, `True` for always, `None` for only if not US-\nASCII or UTF-8 or Unicode (default is `None`). default_namespace sets the\ndefault XML namespace (for \u201cxmlns\u201d). method is either `\"xml\"`, `\"html\"` or\n`\"text\"` (default is `\"xml\"`). The keyword-only short_empty_elements parameter\ncontrols the formatting of elements that contain no content. If `True` (the\ndefault), they are emitted as a single self-closed tag, otherwise they are\nemitted as a pair of start/end tags.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.ElementTree._setroot()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.ElementTree._setroot", "type": "Structured Markup", "text": "\nReplaces the root element for this tree. This discards the current contents of\nthe tree, and replaces it with the given element. Use with care. element is an\nelement instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.fromstring()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.fromstring", "type": "Structured Markup", "text": "\nParses an XML section from a string constant. Same as `XML()`. text is a\nstring containing XML data. parser is an optional parser instance. If not\ngiven, the standard `XMLParser` parser is used. Returns an `Element` instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.fromstringlist()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.fromstringlist", "type": "Structured Markup", "text": "\nParses an XML document from a sequence of string fragments. sequence is a list\nor other sequence containing XML data fragments. parser is an optional parser\ninstance. If not given, the standard `XMLParser` parser is used. Returns an\n`Element` instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.indent()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.indent", "type": "Structured Markup", "text": "\nAppends whitespace to the subtree to indent the tree visually. This can be\nused to generate pretty-printed XML output. tree can be an Element or\nElementTree. space is the whitespace string that will be inserted for each\nindentation level, two space characters by default. For indenting partial\nsubtrees inside of an already indented tree, pass the initial indentation\nlevel as level.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.iselement()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.iselement", "type": "Structured Markup", "text": "\nCheck if an object appears to be a valid element object. element is an element\ninstance. Return `True` if this is an element object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.iterparse()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.iterparse", "type": "Structured Markup", "text": "\nParses an XML section into an element tree incrementally, and reports what\u2019s\ngoing on to the user. source is a filename or file object containing XML data.\nevents is a sequence of events to report back. The supported events are the\nstrings `\"start\"`, `\"end\"`, `\"comment\"`, `\"pi\"`, `\"start-ns\"` and `\"end-ns\"`\n(the \u201cns\u201d events are used to get detailed namespace information). If events is\nomitted, only `\"end\"` events are reported. parser is an optional parser\ninstance. If not given, the standard `XMLParser` parser is used. parser must\nbe a subclass of `XMLParser` and can only use the default `TreeBuilder` as a\ntarget. Returns an iterator providing `(event, elem)` pairs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.parse()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.parse", "type": "Structured Markup", "text": "\nParses an XML section into an element tree. source is a filename or file\nobject containing XML data. parser is an optional parser instance. If not\ngiven, the standard `XMLParser` parser is used. Returns an `ElementTree`\ninstance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.ParseError", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.ParseError", "type": "Structured Markup", "text": "\nXML parse error, raised by the various parsing methods in this module when\nparsing fails. The string representation of an instance of this exception will\ncontain a user-friendly error message. In addition, it will have the following\nattributes available:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.ParseError.code", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.ParseError.code", "type": "Structured Markup", "text": "\nA numeric error code from the expat parser. See the documentation of\n`xml.parsers.expat` for the list of error codes and their meanings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.ParseError.position", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.ParseError.position", "type": "Structured Markup", "text": "\nA tuple of line, column numbers, specifying where the error occurred.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.ProcessingInstruction()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.ProcessingInstruction", "type": "Structured Markup", "text": "\nPI element factory. This factory function creates a special element that will\nbe serialized as an XML processing instruction. target is a string containing\nthe PI target. text is a string containing the PI contents, if given. Returns\nan element instance, representing a processing instruction.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.QName", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.QName", "type": "Structured Markup", "text": "\nQName wrapper. This can be used to wrap a QName attribute value, in order to\nget proper namespace handling on output. text_or_uri is a string containing\nthe QName value, in the form {uri}local, or, if the tag argument is given, the\nURI part of a QName. If tag is given, the first argument is interpreted as a\nURI, and this argument is interpreted as a local name. `QName` instances are\nopaque.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.register_namespace()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.register_namespace", "type": "Structured Markup", "text": "\nRegisters a namespace prefix. The registry is global, and any existing mapping\nfor either the given prefix or the namespace URI will be removed. prefix is a\nnamespace prefix. uri is a namespace uri. Tags and attributes in this\nnamespace will be serialized with the given prefix, if at all possible.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.SubElement()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.SubElement", "type": "Structured Markup", "text": "\nSubelement factory. This function creates an element instance, and appends it\nto an existing element.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.tostring()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.tostring", "type": "Structured Markup", "text": "\nGenerates a string representation of an XML element, including all\nsubelements. element is an `Element` instance. encoding 1 is the output\nencoding (default is US-ASCII). Use `encoding=\"unicode\"` to generate a Unicode\nstring (otherwise, a bytestring is generated). method is either `\"xml\"`,\n`\"html\"` or `\"text\"` (default is `\"xml\"`). xml_declaration, default_namespace\nand short_empty_elements has the same meaning as in `ElementTree.write()`.\nReturns an (optionally) encoded string containing the XML data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.tostringlist()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.tostringlist", "type": "Structured Markup", "text": "\nGenerates a string representation of an XML element, including all\nsubelements. element is an `Element` instance. encoding 1 is the output\nencoding (default is US-ASCII). Use `encoding=\"unicode\"` to generate a Unicode\nstring (otherwise, a bytestring is generated). method is either `\"xml\"`,\n`\"html\"` or `\"text\"` (default is `\"xml\"`). xml_declaration, default_namespace\nand short_empty_elements has the same meaning as in `ElementTree.write()`.\nReturns a list of (optionally) encoded strings containing the XML data. It\ndoes not guarantee any specific sequence, except that\n`b\"\".join(tostringlist(element)) == tostring(element)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.TreeBuilder", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.TreeBuilder", "type": "Structured Markup", "text": "\nGeneric element structure builder. This builder converts a sequence of start,\ndata, end, comment and pi method calls to a well-formed element structure. You\ncan use this class to build an element structure using a custom XML parser, or\na parser for some other XML-like format.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.TreeBuilder.close()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.TreeBuilder.close", "type": "Structured Markup", "text": "\nFlushes the builder buffers, and returns the toplevel document element.\nReturns an `Element` instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.TreeBuilder.comment()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.TreeBuilder.comment", "type": "Structured Markup", "text": "\nCreates a comment with the given text. If `insert_comments` is true, this will\nalso add it to the tree.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.TreeBuilder.data()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.TreeBuilder.data", "type": "Structured Markup", "text": "\nAdds text to the current element. data is a string. This should be either a\nbytestring, or a Unicode string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.TreeBuilder.doctype()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.TreeBuilder.doctype", "type": "Structured Markup", "text": "\nHandles a doctype declaration. name is the doctype name. pubid is the public\nidentifier. system is the system identifier. This method does not exist on the\ndefault `TreeBuilder` class.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.TreeBuilder.end()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.TreeBuilder.end", "type": "Structured Markup", "text": "\nCloses the current element. tag is the element name. Returns the closed\nelement.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.TreeBuilder.end_ns()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.TreeBuilder.end_ns", "type": "Structured Markup", "text": "\nIs called after the `end()` callback of an element that declared a namespace\nprefix mapping, with the name of the prefix that went out of scope.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.TreeBuilder.pi()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.TreeBuilder.pi", "type": "Structured Markup", "text": "\nCreates a comment with the given target name and text. If `insert_pis` is\ntrue, this will also add it to the tree.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.TreeBuilder.start()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.TreeBuilder.start", "type": "Structured Markup", "text": "\nOpens a new element. tag is the element name. attrs is a dictionary containing\nelement attributes. Returns the opened element.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.TreeBuilder.start_ns()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.TreeBuilder.start_ns", "type": "Structured Markup", "text": "\nIs called whenever the parser encounters a new namespace declaration, before\nthe `start()` callback for the opening element that defines it. prefix is `''`\nfor the default namespace and the declared namespace prefix name otherwise.\nuri is the namespace URI.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.XML()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.XML", "type": "Structured Markup", "text": "\nParses an XML section from a string constant. This function can be used to\nembed \u201cXML literals\u201d in Python code. text is a string containing XML data.\nparser is an optional parser instance. If not given, the standard `XMLParser`\nparser is used. Returns an `Element` instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.xml.etree.ElementInclude.default_loader()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.xml.etree.ElementInclude.default_loader", "type": "Structured Markup", "text": "\nDefault loader. This default loader reads an included resource from disk. href\nis a URL. parse is for parse mode either \u201cxml\u201d or \u201ctext\u201d. encoding is an\noptional text encoding. If not given, encoding is `utf-8`. Returns the\nexpanded resource. If the parse mode is `\"xml\"`, this is an ElementTree\ninstance. If the parse mode is \u201ctext\u201d, this is a Unicode string. If the loader\nfails, it can return None or raise an exception.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.xml.etree.ElementInclude.include()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.xml.etree.ElementInclude.include", "type": "Structured Markup", "text": "\nThis function expands XInclude directives. elem is the root element. loader is\nan optional resource loader. If omitted, it defaults to `default_loader()`. If\ngiven, it should be a callable that implements the same interface as\n`default_loader()`. base_url is base URL of the original file, to resolve\nrelative include file references. max_depth is the maximum number of recursive\ninclusions. Limited to reduce the risk of malicious content explosion. Pass a\nnegative value to disable the limitation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.XMLID()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.XMLID", "type": "Structured Markup", "text": "\nParses an XML section from a string constant, and also returns a dictionary\nwhich maps from element id:s to elements. text is a string containing XML\ndata. parser is an optional parser instance. If not given, the standard\n`XMLParser` parser is used. Returns a tuple containing an `Element` instance\nand a dictionary.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.XMLParser", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.XMLParser", "type": "Structured Markup", "text": "\nThis class is the low-level building block of the module. It uses\n`xml.parsers.expat` for efficient, event-based parsing of XML. It can be fed\nXML data incrementally with the `feed()` method, and parsing events are\ntranslated to a push API - by invoking callbacks on the target object. If\ntarget is omitted, the standard `TreeBuilder` is used. If encoding 1 is given,\nthe value overrides the encoding specified in the XML file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.XMLParser.close()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.XMLParser.close", "type": "Structured Markup", "text": "\nFinishes feeding data to the parser. Returns the result of calling the\n`close()` method of the target passed during construction; by default, this is\nthe toplevel document element.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.XMLParser.feed()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.XMLParser.feed", "type": "Structured Markup", "text": "\nFeeds data to the parser. data is encoded data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.XMLPullParser", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.XMLPullParser", "type": "Structured Markup", "text": "\nA pull parser suitable for non-blocking applications. Its input-side API is\nsimilar to that of `XMLParser`, but instead of pushing calls to a callback\ntarget, `XMLPullParser` collects an internal list of parsing events and lets\nthe user read from it. events is a sequence of events to report back. The\nsupported events are the strings `\"start\"`, `\"end\"`, `\"comment\"`, `\"pi\"`,\n`\"start-ns\"` and `\"end-ns\"` (the \u201cns\u201d events are used to get detailed\nnamespace information). If events is omitted, only `\"end\"` events are\nreported.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.XMLPullParser.close()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.XMLPullParser.close", "type": "Structured Markup", "text": "\nSignal the parser that the data stream is terminated. Unlike\n`XMLParser.close()`, this method always returns `None`. Any events not yet\nretrieved when the parser is closed can still be read with `read_events()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.XMLPullParser.feed()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.XMLPullParser.feed", "type": "Structured Markup", "text": "\nFeed the given bytes data to the parser.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.etree.ElementTree.XMLPullParser.read_events()", "path": "library/xml.etree.elementtree#xml.etree.ElementTree.XMLPullParser.read_events", "type": "Structured Markup", "text": "\nReturn an iterator over the events which have been encountered in the data fed\nto the parser. The iterator yields `(event, elem)` pairs, where event is a\nstring representing the type of event (e.g. `\"end\"`) and elem is the\nencountered `Element` object, or other context value as follows.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat", "path": "library/pyexpat", "type": "Structured Markup", "text": "\nWarning\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.error", "path": "library/pyexpat#xml.parsers.expat.error", "type": "Structured Markup", "text": "\nAlias for `ExpatError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.errors.codes", "path": "library/pyexpat#xml.parsers.expat.errors.codes", "type": "Structured Markup", "text": "\nA dictionary mapping string descriptions to their error codes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.errors.messages", "path": "library/pyexpat#xml.parsers.expat.errors.messages", "type": "Structured Markup", "text": "\nA dictionary mapping numeric error codes to their string descriptions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.errors.XML_ERROR_ABORTED", "path": "library/pyexpat#xml.parsers.expat.errors.XML_ERROR_ABORTED", "type": "Structured Markup", "text": "\nThis should not be reported to Python applications.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.errors.XML_ERROR_ASYNC_ENTITY", "path": "library/pyexpat#xml.parsers.expat.errors.XML_ERROR_ASYNC_ENTITY", "type": "Structured Markup", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.errors.XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF", "path": "library/pyexpat#xml.parsers.expat.errors.XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF", "type": "Structured Markup", "text": "\nAn entity reference in an attribute value referred to an external entity\ninstead of an internal entity.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.errors.XML_ERROR_BAD_CHAR_REF", "path": "library/pyexpat#xml.parsers.expat.errors.XML_ERROR_BAD_CHAR_REF", "type": "Structured Markup", "text": "\nA character reference referred to a character which is illegal in XML (for\nexample, character `0`, or \u2018`&#0;`\u2019).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.errors.XML_ERROR_BINARY_ENTITY_REF", "path": "library/pyexpat#xml.parsers.expat.errors.XML_ERROR_BINARY_ENTITY_REF", "type": "Structured Markup", "text": "\nAn entity reference referred to an entity which was declared with a notation,\nso cannot be parsed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.errors.XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING", "path": "library/pyexpat#xml.parsers.expat.errors.XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING", "type": "Structured Markup", "text": "\nA behavioral change was requested after parsing started that can only be\nchanged before parsing has started. This is (currently) only raised by\n`UseForeignDTD()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.errors.XML_ERROR_DUPLICATE_ATTRIBUTE", "path": "library/pyexpat#xml.parsers.expat.errors.XML_ERROR_DUPLICATE_ATTRIBUTE", "type": "Structured Markup", "text": "\nAn attribute was used more than once in a start tag.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.errors.XML_ERROR_ENTITY_DECLARED_IN_PE", "path": "library/pyexpat#xml.parsers.expat.errors.XML_ERROR_ENTITY_DECLARED_IN_PE", "type": "Structured Markup", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.errors.XML_ERROR_EXTERNAL_ENTITY_HANDLING", "path": "library/pyexpat#xml.parsers.expat.errors.XML_ERROR_EXTERNAL_ENTITY_HANDLING", "type": "Structured Markup", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.errors.XML_ERROR_FEATURE_REQUIRES_XML_DTD", "path": "library/pyexpat#xml.parsers.expat.errors.XML_ERROR_FEATURE_REQUIRES_XML_DTD", "type": "Structured Markup", "text": "\nAn operation was requested that requires DTD support to be compiled in, but\nExpat was configured without DTD support. This should never be reported by a\nstandard build of the `xml.parsers.expat` module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.errors.XML_ERROR_FINISHED", "path": "library/pyexpat#xml.parsers.expat.errors.XML_ERROR_FINISHED", "type": "Structured Markup", "text": "\nThe requested operation was made on a parser which was finished parsing input,\nbut isn\u2019t allowed. This includes attempts to provide additional input or to\nstop the parser.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.errors.XML_ERROR_INCOMPLETE_PE", "path": "library/pyexpat#xml.parsers.expat.errors.XML_ERROR_INCOMPLETE_PE", "type": "Structured Markup", "text": "\nA parameter entity contained incomplete markup.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.errors.XML_ERROR_INCORRECT_ENCODING", "path": "library/pyexpat#xml.parsers.expat.errors.XML_ERROR_INCORRECT_ENCODING", "type": "Structured Markup", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.errors.XML_ERROR_INVALID_TOKEN", "path": "library/pyexpat#xml.parsers.expat.errors.XML_ERROR_INVALID_TOKEN", "type": "Structured Markup", "text": "\nRaised when an input byte could not properly be assigned to a character; for\nexample, a NUL byte (value `0`) in a UTF-8 input stream.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.errors.XML_ERROR_JUNK_AFTER_DOC_ELEMENT", "path": "library/pyexpat#xml.parsers.expat.errors.XML_ERROR_JUNK_AFTER_DOC_ELEMENT", "type": "Structured Markup", "text": "\nSomething other than whitespace occurred after the document element.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.errors.XML_ERROR_MISPLACED_XML_PI", "path": "library/pyexpat#xml.parsers.expat.errors.XML_ERROR_MISPLACED_XML_PI", "type": "Structured Markup", "text": "\nAn XML declaration was found somewhere other than the start of the input data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.errors.XML_ERROR_NOT_STANDALONE", "path": "library/pyexpat#xml.parsers.expat.errors.XML_ERROR_NOT_STANDALONE", "type": "Structured Markup", "text": "\nThe parser determined that the document was not \u201cstandalone\u201d though it\ndeclared itself to be in the XML declaration, and the `NotStandaloneHandler`\nwas set and returned `0`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.errors.XML_ERROR_NOT_SUSPENDED", "path": "library/pyexpat#xml.parsers.expat.errors.XML_ERROR_NOT_SUSPENDED", "type": "Structured Markup", "text": "\nAn attempt to resume the parser was made when the parser had not been\nsuspended.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.errors.XML_ERROR_NO_ELEMENTS", "path": "library/pyexpat#xml.parsers.expat.errors.XML_ERROR_NO_ELEMENTS", "type": "Structured Markup", "text": "\nThe document contains no elements (XML requires all documents to contain\nexactly one top-level element)..\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.errors.XML_ERROR_NO_MEMORY", "path": "library/pyexpat#xml.parsers.expat.errors.XML_ERROR_NO_MEMORY", "type": "Structured Markup", "text": "\nExpat was not able to allocate memory internally.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.errors.XML_ERROR_PARAM_ENTITY_REF", "path": "library/pyexpat#xml.parsers.expat.errors.XML_ERROR_PARAM_ENTITY_REF", "type": "Structured Markup", "text": "\nA parameter entity reference was found where it was not allowed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.errors.XML_ERROR_PARTIAL_CHAR", "path": "library/pyexpat#xml.parsers.expat.errors.XML_ERROR_PARTIAL_CHAR", "type": "Structured Markup", "text": "\nAn incomplete character was found in the input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.errors.XML_ERROR_PUBLICID", "path": "library/pyexpat#xml.parsers.expat.errors.XML_ERROR_PUBLICID", "type": "Structured Markup", "text": "\nCharacters were found in the public id that are not allowed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.errors.XML_ERROR_RECURSIVE_ENTITY_REF", "path": "library/pyexpat#xml.parsers.expat.errors.XML_ERROR_RECURSIVE_ENTITY_REF", "type": "Structured Markup", "text": "\nAn entity reference contained another reference to the same entity; possibly\nvia a different name, and possibly indirectly.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.errors.XML_ERROR_SUSPENDED", "path": "library/pyexpat#xml.parsers.expat.errors.XML_ERROR_SUSPENDED", "type": "Structured Markup", "text": "\nThe requested operation was made on a suspended parser, but isn\u2019t allowed.\nThis includes attempts to provide additional input or to stop the parser.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.errors.XML_ERROR_SUSPEND_PE", "path": "library/pyexpat#xml.parsers.expat.errors.XML_ERROR_SUSPEND_PE", "type": "Structured Markup", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.errors.XML_ERROR_SYNTAX", "path": "library/pyexpat#xml.parsers.expat.errors.XML_ERROR_SYNTAX", "type": "Structured Markup", "text": "\nSome unspecified syntax error was encountered.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.errors.XML_ERROR_TAG_MISMATCH", "path": "library/pyexpat#xml.parsers.expat.errors.XML_ERROR_TAG_MISMATCH", "type": "Structured Markup", "text": "\nAn end tag did not match the innermost open start tag.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.errors.XML_ERROR_TEXT_DECL", "path": "library/pyexpat#xml.parsers.expat.errors.XML_ERROR_TEXT_DECL", "type": "Structured Markup", "text": "\nThere was an error parsing a text declaration in an external entity.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.errors.XML_ERROR_UNBOUND_PREFIX", "path": "library/pyexpat#xml.parsers.expat.errors.XML_ERROR_UNBOUND_PREFIX", "type": "Structured Markup", "text": "\nAn undeclared prefix was found when namespace processing was enabled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.errors.XML_ERROR_UNCLOSED_CDATA_SECTION", "path": "library/pyexpat#xml.parsers.expat.errors.XML_ERROR_UNCLOSED_CDATA_SECTION", "type": "Structured Markup", "text": "\nA CDATA marked section was not closed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.errors.XML_ERROR_UNCLOSED_TOKEN", "path": "library/pyexpat#xml.parsers.expat.errors.XML_ERROR_UNCLOSED_TOKEN", "type": "Structured Markup", "text": "\nSome token (such as a start tag) was not closed before the end of the stream\nor the next token was encountered.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.errors.XML_ERROR_UNDECLARING_PREFIX", "path": "library/pyexpat#xml.parsers.expat.errors.XML_ERROR_UNDECLARING_PREFIX", "type": "Structured Markup", "text": "\nThe document attempted to remove the namespace declaration associated with a\nprefix.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.errors.XML_ERROR_UNDEFINED_ENTITY", "path": "library/pyexpat#xml.parsers.expat.errors.XML_ERROR_UNDEFINED_ENTITY", "type": "Structured Markup", "text": "\nA reference was made to an entity which was not defined.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.errors.XML_ERROR_UNEXPECTED_STATE", "path": "library/pyexpat#xml.parsers.expat.errors.XML_ERROR_UNEXPECTED_STATE", "type": "Structured Markup", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.errors.XML_ERROR_UNKNOWN_ENCODING", "path": "library/pyexpat#xml.parsers.expat.errors.XML_ERROR_UNKNOWN_ENCODING", "type": "Structured Markup", "text": "\nThe document encoding is not supported by Expat.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.errors.XML_ERROR_XML_DECL", "path": "library/pyexpat#xml.parsers.expat.errors.XML_ERROR_XML_DECL", "type": "Structured Markup", "text": "\nThe document contained no document element at all.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.ErrorString()", "path": "library/pyexpat#xml.parsers.expat.ErrorString", "type": "Structured Markup", "text": "\nReturns an explanatory string for a given error number errno.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.ExpatError", "path": "library/pyexpat#xml.parsers.expat.ExpatError", "type": "Structured Markup", "text": "\nThe exception raised when Expat reports an error. See section ExpatError\nExceptions for more information on interpreting Expat errors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.ExpatError.code", "path": "library/pyexpat#xml.parsers.expat.ExpatError.code", "type": "Structured Markup", "text": "\nExpat\u2019s internal error number for the specific error. The `errors.messages`\ndictionary maps these error numbers to Expat\u2019s error messages. For example:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.ExpatError.lineno", "path": "library/pyexpat#xml.parsers.expat.ExpatError.lineno", "type": "Structured Markup", "text": "\nLine number on which the error was detected. The first line is numbered `1`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.ExpatError.offset", "path": "library/pyexpat#xml.parsers.expat.ExpatError.offset", "type": "Structured Markup", "text": "\nCharacter offset into the line where the error occurred. The first column is\nnumbered `0`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.ParserCreate()", "path": "library/pyexpat#xml.parsers.expat.ParserCreate", "type": "Structured Markup", "text": "\nCreates and returns a new `xmlparser` object. encoding, if specified, must be\na string naming the encoding used by the XML data. Expat doesn\u2019t support as\nmany encodings as Python does, and its repertoire of encodings can\u2019t be\nextended; it supports UTF-8, UTF-16, ISO-8859-1 (Latin1), and ASCII. If\nencoding 1 is given it will override the implicit or explicit encoding of the\ndocument.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.xmlparser.AttlistDeclHandler()", "path": "library/pyexpat#xml.parsers.expat.xmlparser.AttlistDeclHandler", "type": "Structured Markup", "text": "\nCalled for each declared attribute for an element type. If an attribute list\ndeclaration declares three attributes, this handler is called three times,\nonce for each attribute. elname is the name of the element to which the\ndeclaration applies and attname is the name of the attribute declared. The\nattribute type is a string passed as type; the possible values are `'CDATA'`,\n`'ID'`, `'IDREF'`, \u2026 default gives the default value for the attribute used\nwhen the attribute is not specified by the document instance, or `None` if\nthere is no default value (`#IMPLIED` values). If the attribute is required to\nbe given in the document instance, required will be true. This requires Expat\nversion 1.95.0 or newer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.xmlparser.buffer_size", "path": "library/pyexpat#xml.parsers.expat.xmlparser.buffer_size", "type": "Structured Markup", "text": "\nThe size of the buffer used when `buffer_text` is true. A new buffer size can\nbe set by assigning a new integer value to this attribute. When the size is\nchanged, the buffer will be flushed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.xmlparser.buffer_text", "path": "library/pyexpat#xml.parsers.expat.xmlparser.buffer_text", "type": "Structured Markup", "text": "\nSetting this to true causes the `xmlparser` object to buffer textual content\nreturned by Expat to avoid multiple calls to the `CharacterDataHandler()`\ncallback whenever possible. This can improve performance substantially since\nExpat normally breaks character data into chunks at every line ending. This\nattribute is false by default, and may be changed at any time.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.xmlparser.buffer_used", "path": "library/pyexpat#xml.parsers.expat.xmlparser.buffer_used", "type": "Structured Markup", "text": "\nIf `buffer_text` is enabled, the number of bytes stored in the buffer. These\nbytes represent UTF-8 encoded text. This attribute has no meaningful\ninterpretation when `buffer_text` is false.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.xmlparser.CharacterDataHandler()", "path": "library/pyexpat#xml.parsers.expat.xmlparser.CharacterDataHandler", "type": "Structured Markup", "text": "\nCalled for character data. This will be called for normal character data,\nCDATA marked content, and ignorable whitespace. Applications which must\ndistinguish these cases can use the `StartCdataSectionHandler`,\n`EndCdataSectionHandler`, and `ElementDeclHandler` callbacks to collect the\nrequired information.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.xmlparser.CommentHandler()", "path": "library/pyexpat#xml.parsers.expat.xmlparser.CommentHandler", "type": "Structured Markup", "text": "\nCalled for comments. data is the text of the comment, excluding the leading\n`'<!-``-'` and trailing `'-``->'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.xmlparser.CurrentByteIndex", "path": "library/pyexpat#xml.parsers.expat.xmlparser.CurrentByteIndex", "type": "Structured Markup", "text": "\nCurrent byte index in the parser input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.xmlparser.CurrentColumnNumber", "path": "library/pyexpat#xml.parsers.expat.xmlparser.CurrentColumnNumber", "type": "Structured Markup", "text": "\nCurrent column number in the parser input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.xmlparser.CurrentLineNumber", "path": "library/pyexpat#xml.parsers.expat.xmlparser.CurrentLineNumber", "type": "Structured Markup", "text": "\nCurrent line number in the parser input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.xmlparser.DefaultHandler()", "path": "library/pyexpat#xml.parsers.expat.xmlparser.DefaultHandler", "type": "Structured Markup", "text": "\nCalled for any characters in the XML document for which no applicable handler\nhas been specified. This means characters that are part of a construct which\ncould be reported, but for which no handler has been supplied.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.xmlparser.DefaultHandlerExpand()", "path": "library/pyexpat#xml.parsers.expat.xmlparser.DefaultHandlerExpand", "type": "Structured Markup", "text": "\nThis is the same as the `DefaultHandler()`, but doesn\u2019t inhibit expansion of\ninternal entities. The entity reference will not be passed to the default\nhandler.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.xmlparser.ElementDeclHandler()", "path": "library/pyexpat#xml.parsers.expat.xmlparser.ElementDeclHandler", "type": "Structured Markup", "text": "\nCalled once for each element type declaration. name is the name of the element\ntype, and model is a representation of the content model.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.xmlparser.EndCdataSectionHandler()", "path": "library/pyexpat#xml.parsers.expat.xmlparser.EndCdataSectionHandler", "type": "Structured Markup", "text": "\nCalled at the end of a CDATA section.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.xmlparser.EndDoctypeDeclHandler()", "path": "library/pyexpat#xml.parsers.expat.xmlparser.EndDoctypeDeclHandler", "type": "Structured Markup", "text": "\nCalled when Expat is done parsing the document type declaration. This requires\nExpat version 1.2 or newer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.xmlparser.EndElementHandler()", "path": "library/pyexpat#xml.parsers.expat.xmlparser.EndElementHandler", "type": "Structured Markup", "text": "\nCalled for the end of every element.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.xmlparser.EndNamespaceDeclHandler()", "path": "library/pyexpat#xml.parsers.expat.xmlparser.EndNamespaceDeclHandler", "type": "Structured Markup", "text": "\nCalled when the closing tag is reached for an element that contained a\nnamespace declaration. This is called once for each namespace declaration on\nthe element in the reverse of the order for which the\n`StartNamespaceDeclHandler` was called to indicate the start of each namespace\ndeclaration\u2019s scope. Calls to this handler are made after the corresponding\n`EndElementHandler` for the end of the element.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.xmlparser.EntityDeclHandler()", "path": "library/pyexpat#xml.parsers.expat.xmlparser.EntityDeclHandler", "type": "Structured Markup", "text": "\nCalled for all entity declarations. For parameter and internal entities, value\nwill be a string giving the declared contents of the entity; this will be\n`None` for external entities. The notationName parameter will be `None` for\nparsed entities, and the name of the notation for unparsed entities.\nis_parameter_entity will be true if the entity is a parameter entity or false\nfor general entities (most applications only need to be concerned with general\nentities). This is only available starting with version 1.95.0 of the Expat\nlibrary.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.xmlparser.ErrorByteIndex", "path": "library/pyexpat#xml.parsers.expat.xmlparser.ErrorByteIndex", "type": "Structured Markup", "text": "\nByte index at which an error occurred.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.xmlparser.ErrorCode", "path": "library/pyexpat#xml.parsers.expat.xmlparser.ErrorCode", "type": "Structured Markup", "text": "\nNumeric code specifying the problem. This value can be passed to the\n`ErrorString()` function, or compared to one of the constants defined in the\n`errors` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.xmlparser.ErrorColumnNumber", "path": "library/pyexpat#xml.parsers.expat.xmlparser.ErrorColumnNumber", "type": "Structured Markup", "text": "\nColumn number at which an error occurred.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.xmlparser.ErrorLineNumber", "path": "library/pyexpat#xml.parsers.expat.xmlparser.ErrorLineNumber", "type": "Structured Markup", "text": "\nLine number at which an error occurred.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.xmlparser.ExternalEntityParserCreate()", "path": "library/pyexpat#xml.parsers.expat.xmlparser.ExternalEntityParserCreate", "type": "Structured Markup", "text": "\nCreate a \u201cchild\u201d parser which can be used to parse an external parsed entity\nreferred to by content parsed by the parent parser. The context parameter\nshould be the string passed to the `ExternalEntityRefHandler()` handler\nfunction, described below. The child parser is created with the\n`ordered_attributes` and `specified_attributes` set to the values of this\nparser.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.xmlparser.ExternalEntityRefHandler()", "path": "library/pyexpat#xml.parsers.expat.xmlparser.ExternalEntityRefHandler", "type": "Structured Markup", "text": "\nCalled for references to external entities. base is the current base, as set\nby a previous call to `SetBase()`. The public and system identifiers, systemId\nand publicId, are strings if given; if the public identifier is not given,\npublicId will be `None`. The context value is opaque and should only be used\nas described below.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.xmlparser.GetBase()", "path": "library/pyexpat#xml.parsers.expat.xmlparser.GetBase", "type": "Structured Markup", "text": "\nReturns a string containing the base set by a previous call to `SetBase()`, or\n`None` if `SetBase()` hasn\u2019t been called.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.xmlparser.GetInputContext()", "path": "library/pyexpat#xml.parsers.expat.xmlparser.GetInputContext", "type": "Structured Markup", "text": "\nReturns the input data that generated the current event as a string. The data\nis in the encoding of the entity which contains the text. When called while an\nevent handler is not active, the return value is `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.xmlparser.NotationDeclHandler()", "path": "library/pyexpat#xml.parsers.expat.xmlparser.NotationDeclHandler", "type": "Structured Markup", "text": "\nCalled for notation declarations. notationName, base, and systemId, and\npublicId are strings if given. If the public identifier is omitted, publicId\nwill be `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.xmlparser.NotStandaloneHandler()", "path": "library/pyexpat#xml.parsers.expat.xmlparser.NotStandaloneHandler", "type": "Structured Markup", "text": "\nCalled if the XML document hasn\u2019t been declared as being a standalone\ndocument. This happens when there is an external subset or a reference to a\nparameter entity, but the XML declaration does not set standalone to `yes` in\nan XML declaration. If this handler returns `0`, then the parser will raise an\n`XML_ERROR_NOT_STANDALONE` error. If this handler is not set, no exception is\nraised by the parser for this condition.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.xmlparser.ordered_attributes", "path": "library/pyexpat#xml.parsers.expat.xmlparser.ordered_attributes", "type": "Structured Markup", "text": "\nSetting this attribute to a non-zero integer causes the attributes to be\nreported as a list rather than a dictionary. The attributes are presented in\nthe order found in the document text. For each attribute, two list entries are\npresented: the attribute name and the attribute value. (Older versions of this\nmodule also used this format.) By default, this attribute is false; it may be\nchanged at any time.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.xmlparser.Parse()", "path": "library/pyexpat#xml.parsers.expat.xmlparser.Parse", "type": "Structured Markup", "text": "\nParses the contents of the string data, calling the appropriate handler\nfunctions to process the parsed data. isfinal must be true on the final call\nto this method; it allows the parsing of a single file in fragments, not the\nsubmission of multiple files. data can be the empty string at any time.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.xmlparser.ParseFile()", "path": "library/pyexpat#xml.parsers.expat.xmlparser.ParseFile", "type": "Structured Markup", "text": "\nParse XML data reading from the object file. file only needs to provide the\n`read(nbytes)` method, returning the empty string when there\u2019s no more data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.xmlparser.ProcessingInstructionHandler()", "path": "library/pyexpat#xml.parsers.expat.xmlparser.ProcessingInstructionHandler", "type": "Structured Markup", "text": "\nCalled for every processing instruction.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.xmlparser.SetBase()", "path": "library/pyexpat#xml.parsers.expat.xmlparser.SetBase", "type": "Structured Markup", "text": "\nSets the base to be used for resolving relative URIs in system identifiers in\ndeclarations. Resolving relative identifiers is left to the application: this\nvalue will be passed through as the base argument to the\n`ExternalEntityRefHandler()`, `NotationDeclHandler()`, and\n`UnparsedEntityDeclHandler()` functions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.xmlparser.SetParamEntityParsing()", "path": "library/pyexpat#xml.parsers.expat.xmlparser.SetParamEntityParsing", "type": "Structured Markup", "text": "\nControl parsing of parameter entities (including the external DTD subset).\nPossible flag values are `XML_PARAM_ENTITY_PARSING_NEVER`,\n`XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE` and\n`XML_PARAM_ENTITY_PARSING_ALWAYS`. Return true if setting the flag was\nsuccessful.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.xmlparser.specified_attributes", "path": "library/pyexpat#xml.parsers.expat.xmlparser.specified_attributes", "type": "Structured Markup", "text": "\nIf set to a non-zero integer, the parser will report only those attributes\nwhich were specified in the document instance and not those which were derived\nfrom attribute declarations. Applications which set this need to be especially\ncareful to use what additional information is available from the declarations\nas needed to comply with the standards for the behavior of XML processors. By\ndefault, this attribute is false; it may be changed at any time.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.xmlparser.StartCdataSectionHandler()", "path": "library/pyexpat#xml.parsers.expat.xmlparser.StartCdataSectionHandler", "type": "Structured Markup", "text": "\nCalled at the start of a CDATA section. This and `EndCdataSectionHandler` are\nneeded to be able to identify the syntactical start and end for CDATA\nsections.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.xmlparser.StartDoctypeDeclHandler()", "path": "library/pyexpat#xml.parsers.expat.xmlparser.StartDoctypeDeclHandler", "type": "Structured Markup", "text": "\nCalled when Expat begins parsing the document type declaration (`<!DOCTYPE\n...`). The doctypeName is provided exactly as presented. The systemId and\npublicId parameters give the system and public identifiers if specified, or\n`None` if omitted. has_internal_subset will be true if the document contains\nand internal document declaration subset. This requires Expat version 1.2 or\nnewer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.xmlparser.StartElementHandler()", "path": "library/pyexpat#xml.parsers.expat.xmlparser.StartElementHandler", "type": "Structured Markup", "text": "\nCalled for the start of every element. name is a string containing the element\nname, and attributes is the element attributes. If `ordered_attributes` is\ntrue, this is a list (see `ordered_attributes` for a full description).\nOtherwise it\u2019s a dictionary mapping names to values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.xmlparser.StartNamespaceDeclHandler()", "path": "library/pyexpat#xml.parsers.expat.xmlparser.StartNamespaceDeclHandler", "type": "Structured Markup", "text": "\nCalled when an element contains a namespace declaration. Namespace\ndeclarations are processed before the `StartElementHandler` is called for the\nelement on which declarations are placed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.xmlparser.UnparsedEntityDeclHandler()", "path": "library/pyexpat#xml.parsers.expat.xmlparser.UnparsedEntityDeclHandler", "type": "Structured Markup", "text": "\nCalled for unparsed (NDATA) entity declarations. This is only present for\nversion 1.2 of the Expat library; for more recent versions, use\n`EntityDeclHandler` instead. (The underlying function in the Expat library has\nbeen declared obsolete.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.xmlparser.UseForeignDTD()", "path": "library/pyexpat#xml.parsers.expat.xmlparser.UseForeignDTD", "type": "Structured Markup", "text": "\nCalling this with a true value for flag (the default) will cause Expat to call\nthe `ExternalEntityRefHandler` with `None` for all arguments to allow an\nalternate DTD to be loaded. If the document does not contain a document type\ndeclaration, the `ExternalEntityRefHandler` will still be called, but the\n`StartDoctypeDeclHandler` and `EndDoctypeDeclHandler` will not be called.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.xmlparser.XmlDeclHandler()", "path": "library/pyexpat#xml.parsers.expat.xmlparser.XmlDeclHandler", "type": "Structured Markup", "text": "\nCalled when the XML declaration is parsed. The XML declaration is the\n(optional) declaration of the applicable version of the XML recommendation,\nthe encoding of the document text, and an optional \u201cstandalone\u201d declaration.\nversion and encoding will be strings, and standalone will be `1` if the\ndocument is declared standalone, `0` if it is declared not to be standalone,\nor `-1` if the standalone clause was omitted. This is only available with\nExpat version 1.95.0 or newer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.parsers.expat.XMLParserType", "path": "library/pyexpat#xml.parsers.expat.XMLParserType", "type": "Structured Markup", "text": "\nThe type of the return values from the `ParserCreate()` function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax", "path": "library/xml.sax", "type": "Structured Markup", "text": "\nSource code: Lib/xml/sax/__init__.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.handler", "path": "library/xml.sax.handler", "type": "Structured Markup", "text": "\nSource code: Lib/xml/sax/handler.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.handler.all_features", "path": "library/xml.sax.handler#xml.sax.handler.all_features", "type": "Structured Markup", "text": "\nList of all features.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.handler.all_properties", "path": "library/xml.sax.handler#xml.sax.handler.all_properties", "type": "Structured Markup", "text": "\nList of all known property names.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.handler.ContentHandler", "path": "library/xml.sax.handler#xml.sax.handler.ContentHandler", "type": "Structured Markup", "text": "\nThis is the main callback interface in SAX, and the one most important to\napplications. The order of events in this interface mirrors the order of the\ninformation in the document.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.handler.ContentHandler.characters()", "path": "library/xml.sax.handler#xml.sax.handler.ContentHandler.characters", "type": "Structured Markup", "text": "\nReceive notification of character data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.handler.ContentHandler.endDocument()", "path": "library/xml.sax.handler#xml.sax.handler.ContentHandler.endDocument", "type": "Structured Markup", "text": "\nReceive notification of the end of a document.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.handler.ContentHandler.endElement()", "path": "library/xml.sax.handler#xml.sax.handler.ContentHandler.endElement", "type": "Structured Markup", "text": "\nSignals the end of an element in non-namespace mode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.handler.ContentHandler.endElementNS()", "path": "library/xml.sax.handler#xml.sax.handler.ContentHandler.endElementNS", "type": "Structured Markup", "text": "\nSignals the end of an element in namespace mode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.handler.ContentHandler.endPrefixMapping()", "path": "library/xml.sax.handler#xml.sax.handler.ContentHandler.endPrefixMapping", "type": "Structured Markup", "text": "\nEnd the scope of a prefix-URI mapping.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.handler.ContentHandler.ignorableWhitespace()", "path": "library/xml.sax.handler#xml.sax.handler.ContentHandler.ignorableWhitespace", "type": "Structured Markup", "text": "\nReceive notification of ignorable whitespace in element content.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.handler.ContentHandler.processingInstruction()", "path": "library/xml.sax.handler#xml.sax.handler.ContentHandler.processingInstruction", "type": "Structured Markup", "text": "\nReceive notification of a processing instruction.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.handler.ContentHandler.setDocumentLocator()", "path": "library/xml.sax.handler#xml.sax.handler.ContentHandler.setDocumentLocator", "type": "Structured Markup", "text": "\nCalled by the parser to give the application a locator for locating the origin\nof document events.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.handler.ContentHandler.skippedEntity()", "path": "library/xml.sax.handler#xml.sax.handler.ContentHandler.skippedEntity", "type": "Structured Markup", "text": "\nReceive notification of a skipped entity.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.handler.ContentHandler.startDocument()", "path": "library/xml.sax.handler#xml.sax.handler.ContentHandler.startDocument", "type": "Structured Markup", "text": "\nReceive notification of the beginning of a document.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.handler.ContentHandler.startElement()", "path": "library/xml.sax.handler#xml.sax.handler.ContentHandler.startElement", "type": "Structured Markup", "text": "\nSignals the start of an element in non-namespace mode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.handler.ContentHandler.startElementNS()", "path": "library/xml.sax.handler#xml.sax.handler.ContentHandler.startElementNS", "type": "Structured Markup", "text": "\nSignals the start of an element in namespace mode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.handler.ContentHandler.startPrefixMapping()", "path": "library/xml.sax.handler#xml.sax.handler.ContentHandler.startPrefixMapping", "type": "Structured Markup", "text": "\nBegin the scope of a prefix-URI Namespace mapping.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.handler.DTDHandler", "path": "library/xml.sax.handler#xml.sax.handler.DTDHandler", "type": "Structured Markup", "text": "\nHandle DTD events.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.handler.DTDHandler.notationDecl()", "path": "library/xml.sax.handler#xml.sax.handler.DTDHandler.notationDecl", "type": "Structured Markup", "text": "\nHandle a notation declaration event.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.handler.DTDHandler.unparsedEntityDecl()", "path": "library/xml.sax.handler#xml.sax.handler.DTDHandler.unparsedEntityDecl", "type": "Structured Markup", "text": "\nHandle an unparsed entity declaration event.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.handler.EntityResolver", "path": "library/xml.sax.handler#xml.sax.handler.EntityResolver", "type": "Structured Markup", "text": "\nBasic interface for resolving entities. If you create an object implementing\nthis interface, then register the object with your Parser, the parser will\ncall the method in your object to resolve all external entities.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.handler.EntityResolver.resolveEntity()", "path": "library/xml.sax.handler#xml.sax.handler.EntityResolver.resolveEntity", "type": "Structured Markup", "text": "\nResolve the system identifier of an entity and return either the system\nidentifier to read from as a string, or an InputSource to read from. The\ndefault implementation returns systemId.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.handler.ErrorHandler", "path": "library/xml.sax.handler#xml.sax.handler.ErrorHandler", "type": "Structured Markup", "text": "\nInterface used by the parser to present error and warning messages to the\napplication. The methods of this object control whether errors are immediately\nconverted to exceptions or are handled in some other way.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.handler.ErrorHandler.error()", "path": "library/xml.sax.handler#xml.sax.handler.ErrorHandler.error", "type": "Structured Markup", "text": "\nCalled when the parser encounters a recoverable error. If this method does not\nraise an exception, parsing may continue, but further document information\nshould not be expected by the application. Allowing the parser to continue may\nallow additional errors to be discovered in the input document.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.handler.ErrorHandler.fatalError()", "path": "library/xml.sax.handler#xml.sax.handler.ErrorHandler.fatalError", "type": "Structured Markup", "text": "\nCalled when the parser encounters an error it cannot recover from; parsing is\nexpected to terminate when this method returns.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.handler.ErrorHandler.warning()", "path": "library/xml.sax.handler#xml.sax.handler.ErrorHandler.warning", "type": "Structured Markup", "text": "\nCalled when the parser presents minor warning information to the application.\nParsing is expected to continue when this method returns, and document\ninformation will continue to be passed to the application. Raising an\nexception in this method will cause parsing to end.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.handler.feature_external_ges", "path": "library/xml.sax.handler#xml.sax.handler.feature_external_ges", "type": "Structured Markup", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.handler.feature_external_pes", "path": "library/xml.sax.handler#xml.sax.handler.feature_external_pes", "type": "Structured Markup", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.handler.feature_namespaces", "path": "library/xml.sax.handler#xml.sax.handler.feature_namespaces", "type": "Structured Markup", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.handler.feature_namespace_prefixes", "path": "library/xml.sax.handler#xml.sax.handler.feature_namespace_prefixes", "type": "Structured Markup", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.handler.feature_string_interning", "path": "library/xml.sax.handler#xml.sax.handler.feature_string_interning", "type": "Structured Markup", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.handler.feature_validation", "path": "library/xml.sax.handler#xml.sax.handler.feature_validation", "type": "Structured Markup", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.handler.property_declaration_handler", "path": "library/xml.sax.handler#xml.sax.handler.property_declaration_handler", "type": "Structured Markup", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.handler.property_dom_node", "path": "library/xml.sax.handler#xml.sax.handler.property_dom_node", "type": "Structured Markup", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.handler.property_lexical_handler", "path": "library/xml.sax.handler#xml.sax.handler.property_lexical_handler", "type": "Structured Markup", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.handler.property_xml_string", "path": "library/xml.sax.handler#xml.sax.handler.property_xml_string", "type": "Structured Markup", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.make_parser()", "path": "library/xml.sax#xml.sax.make_parser", "type": "Structured Markup", "text": "\nCreate and return a SAX `XMLReader` object. The first parser found will be\nused. If parser_list is provided, it must be an iterable of strings which name\nmodules that have a function named `create_parser()`. Modules listed in\nparser_list will be used before modules in the default list of parsers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.parse()", "path": "library/xml.sax#xml.sax.parse", "type": "Structured Markup", "text": "\nCreate a SAX parser and use it to parse a document. The document, passed in as\nfilename_or_stream, can be a filename or a file object. The handler parameter\nneeds to be a SAX `ContentHandler` instance. If error_handler is given, it\nmust be a SAX `ErrorHandler` instance; if omitted, `SAXParseException` will be\nraised on all errors. There is no return value; all work must be done by the\nhandler passed in.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.parseString()", "path": "library/xml.sax#xml.sax.parseString", "type": "Structured Markup", "text": "\nSimilar to `parse()`, but parses from a buffer string received as a parameter.\nstring must be a `str` instance or a bytes-like object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.SAXException", "path": "library/xml.sax#xml.sax.SAXException", "type": "Structured Markup", "text": "\nEncapsulate an XML error or warning. This class can contain basic error or\nwarning information from either the XML parser or the application: it can be\nsubclassed to provide additional functionality or to add localization. Note\nthat although the handlers defined in the `ErrorHandler` interface receive\ninstances of this exception, it is not required to actually raise the\nexception \u2014 it is also useful as a container for information.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.SAXException.getException()", "path": "library/xml.sax#xml.sax.SAXException.getException", "type": "Structured Markup", "text": "\nReturn an encapsulated exception object, or `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.SAXException.getMessage()", "path": "library/xml.sax#xml.sax.SAXException.getMessage", "type": "Structured Markup", "text": "\nReturn a human-readable message describing the error condition.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.SAXNotRecognizedException", "path": "library/xml.sax#xml.sax.SAXNotRecognizedException", "type": "Structured Markup", "text": "\nSubclass of `SAXException` raised when a SAX `XMLReader` is confronted with an\nunrecognized feature or property. SAX applications and extensions may use this\nclass for similar purposes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.SAXNotSupportedException", "path": "library/xml.sax#xml.sax.SAXNotSupportedException", "type": "Structured Markup", "text": "\nSubclass of `SAXException` raised when a SAX `XMLReader` is asked to enable a\nfeature that is not supported, or to set a property to a value that the\nimplementation does not support. SAX applications and extensions may use this\nclass for similar purposes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.SAXParseException", "path": "library/xml.sax#xml.sax.SAXParseException", "type": "Structured Markup", "text": "\nSubclass of `SAXException` raised on parse errors. Instances of this class are\npassed to the methods of the SAX `ErrorHandler` interface to provide\ninformation about the parse error. This class supports the SAX `Locator`\ninterface as well as the `SAXException` interface.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.saxutils", "path": "library/xml.sax.utils", "type": "Structured Markup", "text": "\nSource code: Lib/xml/sax/saxutils.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.saxutils.escape()", "path": "library/xml.sax.utils#xml.sax.saxutils.escape", "type": "Structured Markup", "text": "\nEscape `'&'`, `'<'`, and `'>'` in a string of data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.saxutils.prepare_input_source()", "path": "library/xml.sax.utils#xml.sax.saxutils.prepare_input_source", "type": "Structured Markup", "text": "\nThis function takes an input source and an optional base URL and returns a\nfully resolved `InputSource` object ready for reading. The input source can be\ngiven as a string, a file-like object, or an `InputSource` object; parsers\nwill use this function to implement the polymorphic source argument to their\n`parse()` method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.saxutils.quoteattr()", "path": "library/xml.sax.utils#xml.sax.saxutils.quoteattr", "type": "Structured Markup", "text": "\nSimilar to `escape()`, but also prepares data to be used as an attribute\nvalue. The return value is a quoted version of data with any additional\nrequired replacements. `quoteattr()` will select a quote character based on\nthe content of data, attempting to avoid encoding any quote characters in the\nstring. If both single- and double-quote characters are already in data, the\ndouble-quote characters will be encoded and data will be wrapped in double-\nquotes. The resulting string can be used directly as an attribute value:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.saxutils.unescape()", "path": "library/xml.sax.utils#xml.sax.saxutils.unescape", "type": "Structured Markup", "text": "\nUnescape `'&amp;'`, `'&lt;'`, and `'&gt;'` in a string of data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.saxutils.XMLFilterBase", "path": "library/xml.sax.utils#xml.sax.saxutils.XMLFilterBase", "type": "Structured Markup", "text": "\nThis class is designed to sit between an `XMLReader` and the client\napplication\u2019s event handlers. By default, it does nothing but pass requests up\nto the reader and events on to the handlers unmodified, but subclasses can\noverride specific methods to modify the event stream or the configuration\nrequests as they pass through.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.saxutils.XMLGenerator", "path": "library/xml.sax.utils#xml.sax.saxutils.XMLGenerator", "type": "Structured Markup", "text": "\nThis class implements the `ContentHandler` interface by writing SAX events\nback into an XML document. In other words, using an `XMLGenerator` as the\ncontent handler will reproduce the original document being parsed. out should\nbe a file-like object which will default to sys.stdout. encoding is the\nencoding of the output stream which defaults to `'iso-8859-1'`.\nshort_empty_elements controls the formatting of elements that contain no\ncontent: if `False` (the default) they are emitted as a pair of start/end\ntags, if set to `True` they are emitted as a single self-closed tag.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader", "path": "library/xml.sax.reader", "type": "Structured Markup", "text": "\nSource code: Lib/xml/sax/xmlreader.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.Attributes.getLength()", "path": "library/xml.sax.reader#xml.sax.xmlreader.Attributes.getLength", "type": "Structured Markup", "text": "\nReturn the number of attributes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.Attributes.getNames()", "path": "library/xml.sax.reader#xml.sax.xmlreader.Attributes.getNames", "type": "Structured Markup", "text": "\nReturn the names of the attributes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.Attributes.getType()", "path": "library/xml.sax.reader#xml.sax.xmlreader.Attributes.getType", "type": "Structured Markup", "text": "\nReturns the type of the attribute name, which is normally `'CDATA'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.Attributes.getValue()", "path": "library/xml.sax.reader#xml.sax.xmlreader.Attributes.getValue", "type": "Structured Markup", "text": "\nReturn the value of attribute name.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.AttributesImpl", "path": "library/xml.sax.reader#xml.sax.xmlreader.AttributesImpl", "type": "Structured Markup", "text": "\nThis is an implementation of the `Attributes` interface (see section The\nAttributes Interface). This is a dictionary-like object which represents the\nelement attributes in a `startElement()` call. In addition to the most useful\ndictionary operations, it supports a number of other methods as described by\nthe interface. Objects of this class should be instantiated by readers; attrs\nmust be a dictionary-like object containing a mapping from attribute names to\nattribute values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.AttributesNS.getNameByQName()", "path": "library/xml.sax.reader#xml.sax.xmlreader.AttributesNS.getNameByQName", "type": "Structured Markup", "text": "\nReturn the `(namespace, localname)` pair for a qualified name.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.AttributesNS.getQNameByName()", "path": "library/xml.sax.reader#xml.sax.xmlreader.AttributesNS.getQNameByName", "type": "Structured Markup", "text": "\nReturn the qualified name for a `(namespace, localname)` pair.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.AttributesNS.getQNames()", "path": "library/xml.sax.reader#xml.sax.xmlreader.AttributesNS.getQNames", "type": "Structured Markup", "text": "\nReturn the qualified names of all attributes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.AttributesNS.getValueByQName()", "path": "library/xml.sax.reader#xml.sax.xmlreader.AttributesNS.getValueByQName", "type": "Structured Markup", "text": "\nReturn the value for a qualified name.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.AttributesNSImpl", "path": "library/xml.sax.reader#xml.sax.xmlreader.AttributesNSImpl", "type": "Structured Markup", "text": "\nNamespace-aware variant of `AttributesImpl`, which will be passed to\n`startElementNS()`. It is derived from `AttributesImpl`, but understands\nattribute names as two-tuples of namespaceURI and localname. In addition, it\nprovides a number of methods expecting qualified names as they appear in the\noriginal document. This class implements the `AttributesNS` interface (see\nsection The AttributesNS Interface).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.IncrementalParser", "path": "library/xml.sax.reader#xml.sax.xmlreader.IncrementalParser", "type": "Structured Markup", "text": "\nIn some cases, it is desirable not to parse an input source at once, but to\nfeed chunks of the document as they get available. Note that the reader will\nnormally not read the entire file, but read it in chunks as well; still\n`parse()` won\u2019t return until the entire document is processed. So these\ninterfaces should be used if the blocking behaviour of `parse()` is not\ndesirable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.IncrementalParser.close()", "path": "library/xml.sax.reader#xml.sax.xmlreader.IncrementalParser.close", "type": "Structured Markup", "text": "\nAssume the end of the document. That will check well-formedness conditions\nthat can be checked only at the end, invoke handlers, and may clean up\nresources allocated during parsing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.IncrementalParser.feed()", "path": "library/xml.sax.reader#xml.sax.xmlreader.IncrementalParser.feed", "type": "Structured Markup", "text": "\nProcess a chunk of data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.IncrementalParser.reset()", "path": "library/xml.sax.reader#xml.sax.xmlreader.IncrementalParser.reset", "type": "Structured Markup", "text": "\nThis method is called after close has been called to reset the parser so that\nit is ready to parse new documents. The results of calling parse or feed after\nclose without calling reset are undefined.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.InputSource", "path": "library/xml.sax.reader#xml.sax.xmlreader.InputSource", "type": "Structured Markup", "text": "\nEncapsulation of the information needed by the `XMLReader` to read entities.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.InputSource.getByteStream()", "path": "library/xml.sax.reader#xml.sax.xmlreader.InputSource.getByteStream", "type": "Structured Markup", "text": "\nGet the byte stream for this input source.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.InputSource.getCharacterStream()", "path": "library/xml.sax.reader#xml.sax.xmlreader.InputSource.getCharacterStream", "type": "Structured Markup", "text": "\nGet the character stream for this input source.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.InputSource.getEncoding()", "path": "library/xml.sax.reader#xml.sax.xmlreader.InputSource.getEncoding", "type": "Structured Markup", "text": "\nGet the character encoding of this InputSource.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.InputSource.getPublicId()", "path": "library/xml.sax.reader#xml.sax.xmlreader.InputSource.getPublicId", "type": "Structured Markup", "text": "\nReturns the public identifier of this `InputSource`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.InputSource.getSystemId()", "path": "library/xml.sax.reader#xml.sax.xmlreader.InputSource.getSystemId", "type": "Structured Markup", "text": "\nReturns the system identifier of this `InputSource`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.InputSource.setByteStream()", "path": "library/xml.sax.reader#xml.sax.xmlreader.InputSource.setByteStream", "type": "Structured Markup", "text": "\nSet the byte stream (a binary file) for this input source.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.InputSource.setCharacterStream()", "path": "library/xml.sax.reader#xml.sax.xmlreader.InputSource.setCharacterStream", "type": "Structured Markup", "text": "\nSet the character stream (a text file) for this input source.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.InputSource.setEncoding()", "path": "library/xml.sax.reader#xml.sax.xmlreader.InputSource.setEncoding", "type": "Structured Markup", "text": "\nSets the character encoding of this `InputSource`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.InputSource.setPublicId()", "path": "library/xml.sax.reader#xml.sax.xmlreader.InputSource.setPublicId", "type": "Structured Markup", "text": "\nSets the public identifier of this `InputSource`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.InputSource.setSystemId()", "path": "library/xml.sax.reader#xml.sax.xmlreader.InputSource.setSystemId", "type": "Structured Markup", "text": "\nSets the system identifier of this `InputSource`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.Locator", "path": "library/xml.sax.reader#xml.sax.xmlreader.Locator", "type": "Structured Markup", "text": "\nInterface for associating a SAX event with a document location. A locator\nobject will return valid results only during calls to DocumentHandler methods;\nat any other time, the results are unpredictable. If information is not\navailable, methods may return `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.Locator.getColumnNumber()", "path": "library/xml.sax.reader#xml.sax.xmlreader.Locator.getColumnNumber", "type": "Structured Markup", "text": "\nReturn the column number where the current event begins.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.Locator.getLineNumber()", "path": "library/xml.sax.reader#xml.sax.xmlreader.Locator.getLineNumber", "type": "Structured Markup", "text": "\nReturn the line number where the current event begins.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.Locator.getPublicId()", "path": "library/xml.sax.reader#xml.sax.xmlreader.Locator.getPublicId", "type": "Structured Markup", "text": "\nReturn the public identifier for the current event.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.Locator.getSystemId()", "path": "library/xml.sax.reader#xml.sax.xmlreader.Locator.getSystemId", "type": "Structured Markup", "text": "\nReturn the system identifier for the current event.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.XMLReader", "path": "library/xml.sax.reader#xml.sax.xmlreader.XMLReader", "type": "Structured Markup", "text": "\nBase class which can be inherited by SAX parsers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.XMLReader.getContentHandler()", "path": "library/xml.sax.reader#xml.sax.xmlreader.XMLReader.getContentHandler", "type": "Structured Markup", "text": "\nReturn the current `ContentHandler`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.XMLReader.getDTDHandler()", "path": "library/xml.sax.reader#xml.sax.xmlreader.XMLReader.getDTDHandler", "type": "Structured Markup", "text": "\nReturn the current `DTDHandler`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.XMLReader.getEntityResolver()", "path": "library/xml.sax.reader#xml.sax.xmlreader.XMLReader.getEntityResolver", "type": "Structured Markup", "text": "\nReturn the current `EntityResolver`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.XMLReader.getErrorHandler()", "path": "library/xml.sax.reader#xml.sax.xmlreader.XMLReader.getErrorHandler", "type": "Structured Markup", "text": "\nReturn the current `ErrorHandler`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.XMLReader.getFeature()", "path": "library/xml.sax.reader#xml.sax.xmlreader.XMLReader.getFeature", "type": "Structured Markup", "text": "\nReturn the current setting for feature featurename. If the feature is not\nrecognized, `SAXNotRecognizedException` is raised. The well-known featurenames\nare listed in the module `xml.sax.handler`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.XMLReader.getProperty()", "path": "library/xml.sax.reader#xml.sax.xmlreader.XMLReader.getProperty", "type": "Structured Markup", "text": "\nReturn the current setting for property propertyname. If the property is not\nrecognized, a `SAXNotRecognizedException` is raised. The well-known\npropertynames are listed in the module `xml.sax.handler`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.XMLReader.parse()", "path": "library/xml.sax.reader#xml.sax.xmlreader.XMLReader.parse", "type": "Structured Markup", "text": "\nProcess an input source, producing SAX events. The source object can be a\nsystem identifier (a string identifying the input source \u2013 typically a file\nname or a URL), a `pathlib.Path` or path-like object, or an `InputSource`\nobject. When `parse()` returns, the input is completely processed, and the\nparser object can be discarded or reset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.XMLReader.setContentHandler()", "path": "library/xml.sax.reader#xml.sax.xmlreader.XMLReader.setContentHandler", "type": "Structured Markup", "text": "\nSet the current `ContentHandler`. If no `ContentHandler` is set, content\nevents will be discarded.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.XMLReader.setDTDHandler()", "path": "library/xml.sax.reader#xml.sax.xmlreader.XMLReader.setDTDHandler", "type": "Structured Markup", "text": "\nSet the current `DTDHandler`. If no `DTDHandler` is set, DTD events will be\ndiscarded.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.XMLReader.setEntityResolver()", "path": "library/xml.sax.reader#xml.sax.xmlreader.XMLReader.setEntityResolver", "type": "Structured Markup", "text": "\nSet the current `EntityResolver`. If no `EntityResolver` is set, attempts to\nresolve an external entity will result in opening the system identifier for\nthe entity, and fail if it is not available.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.XMLReader.setErrorHandler()", "path": "library/xml.sax.reader#xml.sax.xmlreader.XMLReader.setErrorHandler", "type": "Structured Markup", "text": "\nSet the current error handler. If no `ErrorHandler` is set, errors will be\nraised as exceptions, and warnings will be printed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.XMLReader.setFeature()", "path": "library/xml.sax.reader#xml.sax.xmlreader.XMLReader.setFeature", "type": "Structured Markup", "text": "\nSet the featurename to value. If the feature is not recognized,\n`SAXNotRecognizedException` is raised. If the feature or its setting is not\nsupported by the parser, SAXNotSupportedException is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.XMLReader.setLocale()", "path": "library/xml.sax.reader#xml.sax.xmlreader.XMLReader.setLocale", "type": "Structured Markup", "text": "\nAllow an application to set the locale for errors and warnings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xml.sax.xmlreader.XMLReader.setProperty()", "path": "library/xml.sax.reader#xml.sax.xmlreader.XMLReader.setProperty", "type": "Structured Markup", "text": "\nSet the propertyname to value. If the property is not recognized,\n`SAXNotRecognizedException` is raised. If the property or its setting is not\nsupported by the parser, SAXNotSupportedException is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc", "path": "library/xmlrpc", "type": "Internet", "text": "\nXML-RPC is a Remote Procedure Call method that uses XML passed via HTTP as a\ntransport. With it, a client can call methods with parameters on a remote\nserver (the server is named by a URI) and get back structured data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.client", "path": "library/xmlrpc.client", "type": "Internet", "text": "\nSource code: Lib/xmlrpc/client.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.client.Binary", "path": "library/xmlrpc.client#xmlrpc.client.Binary", "type": "Internet", "text": "\nThis class may be initialized from bytes data (which may include NULs). The\nprimary access to the content of a `Binary` object is provided by an\nattribute:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.client.Binary.data", "path": "library/xmlrpc.client#xmlrpc.client.Binary.data", "type": "Internet", "text": "\nThe binary data encapsulated by the `Binary` instance. The data is provided as\na `bytes` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.client.Binary.decode()", "path": "library/xmlrpc.client#xmlrpc.client.Binary.decode", "type": "Internet", "text": "\nAccept a base64 `bytes` object and decode it as the instance\u2019s new data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.client.Binary.encode()", "path": "library/xmlrpc.client#xmlrpc.client.Binary.encode", "type": "Internet", "text": "\nWrite the XML-RPC base 64 encoding of this binary item to the out stream\nobject.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.client.DateTime", "path": "library/xmlrpc.client#xmlrpc.client.DateTime", "type": "Internet", "text": "\nThis class may be initialized with seconds since the epoch, a time tuple, an\nISO 8601 time/date string, or a `datetime.datetime` instance. It has the\nfollowing methods, supported mainly for internal use by the\nmarshalling/unmarshalling code:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.client.DateTime.decode()", "path": "library/xmlrpc.client#xmlrpc.client.DateTime.decode", "type": "Internet", "text": "\nAccept a string as the instance\u2019s new time value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.client.DateTime.encode()", "path": "library/xmlrpc.client#xmlrpc.client.DateTime.encode", "type": "Internet", "text": "\nWrite the XML-RPC encoding of this `DateTime` item to the out stream object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.client.dumps()", "path": "library/xmlrpc.client#xmlrpc.client.dumps", "type": "Internet", "text": "\nConvert params into an XML-RPC request. or into a response if methodresponse\nis true. params can be either a tuple of arguments or an instance of the\n`Fault` exception class. If methodresponse is true, only a single value can be\nreturned, meaning that params must be of length 1. encoding, if supplied, is\nthe encoding to use in the generated XML; the default is UTF-8. Python\u2019s\n`None` value cannot be used in standard XML-RPC; to allow using it via an\nextension, provide a true value for allow_none.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.client.Fault", "path": "library/xmlrpc.client#xmlrpc.client.Fault", "type": "Internet", "text": "\nA `Fault` object encapsulates the content of an XML-RPC fault tag. Fault\nobjects have the following attributes:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.client.Fault.faultCode", "path": "library/xmlrpc.client#xmlrpc.client.Fault.faultCode", "type": "Internet", "text": "\nA string indicating the fault type.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.client.Fault.faultString", "path": "library/xmlrpc.client#xmlrpc.client.Fault.faultString", "type": "Internet", "text": "\nA string containing a diagnostic message associated with the fault.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.client.loads()", "path": "library/xmlrpc.client#xmlrpc.client.loads", "type": "Internet", "text": "\nConvert an XML-RPC request or response into Python objects, a `(params,\nmethodname)`. params is a tuple of argument; methodname is a string, or `None`\nif no method name is present in the packet. If the XML-RPC packet represents a\nfault condition, this function will raise a `Fault` exception. The\nuse_builtin_types flag can be used to cause date/time values to be presented\nas `datetime.datetime` objects and binary data to be presented as `bytes`\nobjects; this flag is false by default.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.client.MultiCall", "path": "library/xmlrpc.client#xmlrpc.client.MultiCall", "type": "Internet", "text": "\nCreate an object used to boxcar method calls. server is the eventual target of\nthe call. Calls can be made to the result object, but they will immediately\nreturn `None`, and only store the call name and parameters in the `MultiCall`\nobject. Calling the object itself causes all stored calls to be transmitted as\na single `system.multicall` request. The result of this call is a generator;\niterating over this generator yields the individual results.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.client.ProtocolError", "path": "library/xmlrpc.client#xmlrpc.client.ProtocolError", "type": "Internet", "text": "\nA `ProtocolError` object describes a protocol error in the underlying\ntransport layer (such as a 404 \u2018not found\u2019 error if the server named by the\nURI does not exist). It has the following attributes:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.client.ProtocolError.errcode", "path": "library/xmlrpc.client#xmlrpc.client.ProtocolError.errcode", "type": "Internet", "text": "\nThe error code.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.client.ProtocolError.errmsg", "path": "library/xmlrpc.client#xmlrpc.client.ProtocolError.errmsg", "type": "Internet", "text": "\nThe error message or diagnostic string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.client.ProtocolError.headers", "path": "library/xmlrpc.client#xmlrpc.client.ProtocolError.headers", "type": "Internet", "text": "\nA dict containing the headers of the HTTP/HTTPS request that triggered the\nerror.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.client.ProtocolError.url", "path": "library/xmlrpc.client#xmlrpc.client.ProtocolError.url", "type": "Internet", "text": "\nThe URI or URL that triggered the error.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.client.ServerProxy", "path": "library/xmlrpc.client#xmlrpc.client.ServerProxy", "type": "Internet", "text": "\nA `ServerProxy` instance is an object that manages communication with a remote\nXML-RPC server. The required first argument is a URI (Uniform Resource\nIndicator), and will normally be the URL of the server. The optional second\nargument is a transport factory instance; by default it is an internal\n`SafeTransport` instance for https: URLs and an internal HTTP `Transport`\ninstance otherwise. The optional third argument is an encoding, by default\nUTF-8. The optional fourth argument is a debugging flag.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.client.ServerProxy.system.listMethods()", "path": "library/xmlrpc.client#xmlrpc.client.ServerProxy.system.listMethods", "type": "Internet", "text": "\nThis method returns a list of strings, one for each (non-system) method\nsupported by the XML-RPC server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.client.ServerProxy.system.methodHelp()", "path": "library/xmlrpc.client#xmlrpc.client.ServerProxy.system.methodHelp", "type": "Internet", "text": "\nThis method takes one parameter, the name of a method implemented by the XML-\nRPC server. It returns a documentation string describing the use of that\nmethod. If no such string is available, an empty string is returned. The\ndocumentation string may contain HTML markup.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.client.ServerProxy.system.methodSignature()", "path": "library/xmlrpc.client#xmlrpc.client.ServerProxy.system.methodSignature", "type": "Internet", "text": "\nThis method takes one parameter, the name of a method implemented by the XML-\nRPC server. It returns an array of possible signatures for this method. A\nsignature is an array of types. The first of these types is the return type of\nthe method, the rest are parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.server", "path": "library/xmlrpc.server", "type": "Internet", "text": "\nSource code: Lib/xmlrpc/server.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.server.CGIXMLRPCRequestHandler", "path": "library/xmlrpc.server#xmlrpc.server.CGIXMLRPCRequestHandler", "type": "Internet", "text": "\nCreate a new instance to handle XML-RPC requests in a CGI environment. The\nallow_none and encoding parameters are passed on to `xmlrpc.client` and\ncontrol the XML-RPC responses that will be returned from the server. The\nuse_builtin_types parameter is passed to the `loads()` function and controls\nwhich types are processed when date/times values or binary data are received;\nit defaults to false.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.server.CGIXMLRPCRequestHandler.handle_request()", "path": "library/xmlrpc.server#xmlrpc.server.CGIXMLRPCRequestHandler.handle_request", "type": "Internet", "text": "\nHandle an XML-RPC request. If request_text is given, it should be the POST\ndata provided by the HTTP server, otherwise the contents of stdin will be\nused.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.server.CGIXMLRPCRequestHandler.register_function()", "path": "library/xmlrpc.server#xmlrpc.server.CGIXMLRPCRequestHandler.register_function", "type": "Internet", "text": "\nRegister a function that can respond to XML-RPC requests. If name is given, it\nwill be the method name associated with function, otherwise\n`function.__name__` will be used. name is a string, and may contain characters\nnot legal in Python identifiers, including the period character.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.server.CGIXMLRPCRequestHandler.register_instance()", "path": "library/xmlrpc.server#xmlrpc.server.CGIXMLRPCRequestHandler.register_instance", "type": "Internet", "text": "\nRegister an object which is used to expose method names which have not been\nregistered using `register_function()`. If instance contains a `_dispatch()`\nmethod, it is called with the requested method name and the parameters from\nthe request; the return value is returned to the client as the result. If\ninstance does not have a `_dispatch()` method, it is searched for an attribute\nmatching the name of the requested method; if the requested method name\ncontains periods, each component of the method name is searched for\nindividually, with the effect that a simple hierarchical search is performed.\nThe value found from this search is then called with the parameters from the\nrequest, and the return value is passed back to the client.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.server.CGIXMLRPCRequestHandler.register_introspection_functions()", "path": "library/xmlrpc.server#xmlrpc.server.CGIXMLRPCRequestHandler.register_introspection_functions", "type": "Internet", "text": "\nRegister the XML-RPC introspection functions `system.listMethods`,\n`system.methodHelp` and `system.methodSignature`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.server.CGIXMLRPCRequestHandler.register_multicall_functions()", "path": "library/xmlrpc.server#xmlrpc.server.CGIXMLRPCRequestHandler.register_multicall_functions", "type": "Internet", "text": "\nRegister the XML-RPC multicall function `system.multicall`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.server.DocCGIXMLRPCRequestHandler", "path": "library/xmlrpc.server#xmlrpc.server.DocCGIXMLRPCRequestHandler", "type": "Internet", "text": "\nCreate a new instance to handle XML-RPC requests in a CGI environment.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.server.DocCGIXMLRPCRequestHandler.set_server_documentation()", "path": "library/xmlrpc.server#xmlrpc.server.DocCGIXMLRPCRequestHandler.set_server_documentation", "type": "Internet", "text": "\nSet the description used in the generated HTML documentation. This description\nwill appear as a paragraph, below the server name, in the documentation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.server.DocCGIXMLRPCRequestHandler.set_server_name()", "path": "library/xmlrpc.server#xmlrpc.server.DocCGIXMLRPCRequestHandler.set_server_name", "type": "Internet", "text": "\nSet the name used in the generated HTML documentation. This name will appear\nat the top of the generated documentation inside a \u201ch1\u201d element.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.server.DocCGIXMLRPCRequestHandler.set_server_title()", "path": "library/xmlrpc.server#xmlrpc.server.DocCGIXMLRPCRequestHandler.set_server_title", "type": "Internet", "text": "\nSet the title used in the generated HTML documentation. This title will be\nused inside the HTML \u201ctitle\u201d element.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.server.DocXMLRPCRequestHandler", "path": "library/xmlrpc.server#xmlrpc.server.DocXMLRPCRequestHandler", "type": "Internet", "text": "\nCreate a new request handler instance. This request handler supports XML-RPC\nPOST requests, documentation GET requests, and modifies logging so that the\nlogRequests parameter to the `DocXMLRPCServer` constructor parameter is\nhonored.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.server.DocXMLRPCServer", "path": "library/xmlrpc.server#xmlrpc.server.DocXMLRPCServer", "type": "Internet", "text": "\nCreate a new server instance. All parameters have the same meaning as for\n`SimpleXMLRPCServer`; requestHandler defaults to `DocXMLRPCRequestHandler`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.server.DocXMLRPCServer.set_server_documentation()", "path": "library/xmlrpc.server#xmlrpc.server.DocXMLRPCServer.set_server_documentation", "type": "Internet", "text": "\nSet the description used in the generated HTML documentation. This description\nwill appear as a paragraph, below the server name, in the documentation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.server.DocXMLRPCServer.set_server_name()", "path": "library/xmlrpc.server#xmlrpc.server.DocXMLRPCServer.set_server_name", "type": "Internet", "text": "\nSet the name used in the generated HTML documentation. This name will appear\nat the top of the generated documentation inside a \u201ch1\u201d element.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.server.DocXMLRPCServer.set_server_title()", "path": "library/xmlrpc.server#xmlrpc.server.DocXMLRPCServer.set_server_title", "type": "Internet", "text": "\nSet the title used in the generated HTML documentation. This title will be\nused inside the HTML \u201ctitle\u201d element.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.server.SimpleXMLRPCRequestHandler", "path": "library/xmlrpc.server#xmlrpc.server.SimpleXMLRPCRequestHandler", "type": "Internet", "text": "\nCreate a new request handler instance. This request handler supports `POST`\nrequests and modifies logging so that the logRequests parameter to the\n`SimpleXMLRPCServer` constructor parameter is honored.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.server.SimpleXMLRPCRequestHandler.rpc_paths", "path": "library/xmlrpc.server#xmlrpc.server.SimpleXMLRPCRequestHandler.rpc_paths", "type": "Internet", "text": "\nAn attribute value that must be a tuple listing valid path portions of the URL\nfor receiving XML-RPC requests. Requests posted to other paths will result in\na 404 \u201cno such page\u201d HTTP error. If this tuple is empty, all paths will be\nconsidered valid. The default value is `('/', '/RPC2')`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.server.SimpleXMLRPCServer", "path": "library/xmlrpc.server#xmlrpc.server.SimpleXMLRPCServer", "type": "Internet", "text": "\nCreate a new server instance. This class provides methods for registration of\nfunctions that can be called by the XML-RPC protocol. The requestHandler\nparameter should be a factory for request handler instances; it defaults to\n`SimpleXMLRPCRequestHandler`. The addr and requestHandler parameters are\npassed to the `socketserver.TCPServer` constructor. If logRequests is true\n(the default), requests will be logged; setting this parameter to false will\nturn off logging. The allow_none and encoding parameters are passed on to\n`xmlrpc.client` and control the XML-RPC responses that will be returned from\nthe server. The bind_and_activate parameter controls whether `server_bind()`\nand `server_activate()` are called immediately by the constructor; it defaults\nto true. Setting it to false allows code to manipulate the allow_reuse_address\nclass variable before the address is bound. The use_builtin_types parameter is\npassed to the `loads()` function and controls which types are processed when\ndate/times values or binary data are received; it defaults to false.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.server.SimpleXMLRPCServer.register_function()", "path": "library/xmlrpc.server#xmlrpc.server.SimpleXMLRPCServer.register_function", "type": "Internet", "text": "\nRegister a function that can respond to XML-RPC requests. If name is given, it\nwill be the method name associated with function, otherwise\n`function.__name__` will be used. name is a string, and may contain characters\nnot legal in Python identifiers, including the period character.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.server.SimpleXMLRPCServer.register_instance()", "path": "library/xmlrpc.server#xmlrpc.server.SimpleXMLRPCServer.register_instance", "type": "Internet", "text": "\nRegister an object which is used to expose method names which have not been\nregistered using `register_function()`. If instance contains a `_dispatch()`\nmethod, it is called with the requested method name and the parameters from\nthe request. Its API is `def _dispatch(self, method, params)` (note that\nparams does not represent a variable argument list). If it calls an underlying\nfunction to perform its task, that function is called as `func(*params)`,\nexpanding the parameter list. The return value from `_dispatch()` is returned\nto the client as the result. If instance does not have a `_dispatch()` method,\nit is searched for an attribute matching the name of the requested method.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.server.SimpleXMLRPCServer.register_introspection_functions()", "path": "library/xmlrpc.server#xmlrpc.server.SimpleXMLRPCServer.register_introspection_functions", "type": "Internet", "text": "\nRegisters the XML-RPC introspection functions `system.listMethods`,\n`system.methodHelp` and `system.methodSignature`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "xmlrpc.server.SimpleXMLRPCServer.register_multicall_functions()", "path": "library/xmlrpc.server#xmlrpc.server.SimpleXMLRPCServer.register_multicall_functions", "type": "Internet", "text": "\nRegisters the XML-RPC multicall function system.multicall.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ZeroDivisionError", "path": "library/exceptions#ZeroDivisionError", "type": "Built-in Exceptions", "text": "\nRaised when the second argument of a division or modulo operation is zero. The\nassociated value is a string indicating the type of the operands and the\noperation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zip()", "path": "library/functions#zip", "type": "Built-in Functions", "text": "\nMake an iterator that aggregates elements from each of the iterables.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipapp", "path": "library/zipapp", "type": "Software Packaging & Distribution", "text": "\nNew in version 3.5.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipapp.create_archive()", "path": "library/zipapp#zipapp.create_archive", "type": "Software Packaging & Distribution", "text": "\nCreate an application archive from source. The source can be any of the\nfollowing:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipapp.get_interpreter()", "path": "library/zipapp#zipapp.get_interpreter", "type": "Software Packaging & Distribution", "text": "\nReturn the interpreter specified in the `#!` line at the start of the archive.\nIf there is no `#!` line, return `None`. The archive argument can be a\nfilename or a file-like object open for reading in bytes mode. It is assumed\nto be at the start of the archive.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile", "path": "library/zipfile", "type": "Data Compression", "text": "\nSource code: Lib/zipfile.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.BadZipfile", "path": "library/zipfile#zipfile.BadZipfile", "type": "Data Compression", "text": "\nAlias of `BadZipFile`, for compatibility with older Python versions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.BadZipFile", "path": "library/zipfile#zipfile.BadZipFile", "type": "Data Compression", "text": "\nThe error raised for bad ZIP files.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.is_zipfile()", "path": "library/zipfile#zipfile.is_zipfile", "type": "Data Compression", "text": "\nReturns `True` if filename is a valid ZIP file based on its magic number,\notherwise returns `False`. filename may be a file or file-like object too.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.LargeZipFile", "path": "library/zipfile#zipfile.LargeZipFile", "type": "Data Compression", "text": "\nThe error raised when a ZIP file would require ZIP64 functionality but that\nhas not been enabled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.Path", "path": "library/zipfile#zipfile.Path", "type": "Data Compression", "text": "\nConstruct a Path object from a `root` zipfile (which may be a `ZipFile`\ninstance or `file` suitable for passing to the `ZipFile` constructor).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.Path.exists()", "path": "library/zipfile#zipfile.Path.exists", "type": "Data Compression", "text": "\nReturn `True` if the current context references a file or directory in the zip\nfile.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.Path.is_dir()", "path": "library/zipfile#zipfile.Path.is_dir", "type": "Data Compression", "text": "\nReturn `True` if the current context references a directory.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.Path.is_file()", "path": "library/zipfile#zipfile.Path.is_file", "type": "Data Compression", "text": "\nReturn `True` if the current context references a file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.Path.iterdir()", "path": "library/zipfile#zipfile.Path.iterdir", "type": "Data Compression", "text": "\nEnumerate the children of the current directory.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.Path.name", "path": "library/zipfile#zipfile.Path.name", "type": "Data Compression", "text": "\nThe final path component.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.Path.open()", "path": "library/zipfile#zipfile.Path.open", "type": "Data Compression", "text": "\nInvoke `ZipFile.open()` on the current path. Allows opening for read or write,\ntext or binary through supported modes: \u2018r\u2019, \u2018w\u2019, \u2018rb\u2019, \u2018wb\u2019. Positional and\nkeyword arguments are passed through to `io.TextIOWrapper` when opened as text\nand ignored otherwise. `pwd` is the `pwd` parameter to `ZipFile.open()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.Path.read_bytes()", "path": "library/zipfile#zipfile.Path.read_bytes", "type": "Data Compression", "text": "\nRead the current file as bytes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.Path.read_text()", "path": "library/zipfile#zipfile.Path.read_text", "type": "Data Compression", "text": "\nRead the current file as unicode text. Positional and keyword arguments are\npassed through to `io.TextIOWrapper` (except `buffer`, which is implied by the\ncontext).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.PyZipFile", "path": "library/zipfile#zipfile.PyZipFile", "type": "Data Compression", "text": "\nNew in version 3.2: The optimize parameter.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.PyZipFile.writepy()", "path": "library/zipfile#zipfile.PyZipFile.writepy", "type": "Data Compression", "text": "\nSearch for files `*.py` and add the corresponding file to the archive.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.ZipFile", "path": "library/zipfile#zipfile.ZipFile", "type": "Data Compression", "text": "\nOpen a ZIP file, where file can be a path to a file (a string), a file-like\nobject or a path-like object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.ZipFile.close()", "path": "library/zipfile#zipfile.ZipFile.close", "type": "Data Compression", "text": "\nClose the archive file. You must call `close()` before exiting your program or\nessential records will not be written.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.ZipFile.comment", "path": "library/zipfile#zipfile.ZipFile.comment", "type": "Data Compression", "text": "\nThe comment associated with the ZIP file as a `bytes` object. If assigning a\ncomment to a `ZipFile` instance created with mode `'w'`, `'x'` or `'a'`, it\nshould be no longer than 65535 bytes. Comments longer than this will be\ntruncated.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.ZipFile.debug", "path": "library/zipfile#zipfile.ZipFile.debug", "type": "Data Compression", "text": "\nThe level of debug output to use. This may be set from `0` (the default, no\noutput) to `3` (the most output). Debugging information is written to\n`sys.stdout`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.ZipFile.extract()", "path": "library/zipfile#zipfile.ZipFile.extract", "type": "Data Compression", "text": "\nExtract a member from the archive to the current working directory; member\nmust be its full name or a `ZipInfo` object. Its file information is extracted\nas accurately as possible. path specifies a different directory to extract to.\nmember can be a filename or a `ZipInfo` object. pwd is the password used for\nencrypted files.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.ZipFile.extractall()", "path": "library/zipfile#zipfile.ZipFile.extractall", "type": "Data Compression", "text": "\nExtract all members from the archive to the current working directory. path\nspecifies a different directory to extract to. members is optional and must be\na subset of the list returned by `namelist()`. pwd is the password used for\nencrypted files.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.ZipFile.filename", "path": "library/zipfile#zipfile.ZipFile.filename", "type": "Data Compression", "text": "\nName of the ZIP file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.ZipFile.getinfo()", "path": "library/zipfile#zipfile.ZipFile.getinfo", "type": "Data Compression", "text": "\nReturn a `ZipInfo` object with information about the archive member name.\nCalling `getinfo()` for a name not currently contained in the archive will\nraise a `KeyError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.ZipFile.infolist()", "path": "library/zipfile#zipfile.ZipFile.infolist", "type": "Data Compression", "text": "\nReturn a list containing a `ZipInfo` object for each member of the archive.\nThe objects are in the same order as their entries in the actual ZIP file on\ndisk if an existing archive was opened.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.ZipFile.namelist()", "path": "library/zipfile#zipfile.ZipFile.namelist", "type": "Data Compression", "text": "\nReturn a list of archive members by name.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.ZipFile.open()", "path": "library/zipfile#zipfile.ZipFile.open", "type": "Data Compression", "text": "\nAccess a member of the archive as a binary file-like object. name can be\neither the name of a file within the archive or a `ZipInfo` object. The mode\nparameter, if included, must be `'r'` (the default) or `'w'`. pwd is the\npassword used to decrypt encrypted ZIP files.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.ZipFile.printdir()", "path": "library/zipfile#zipfile.ZipFile.printdir", "type": "Data Compression", "text": "\nPrint a table of contents for the archive to `sys.stdout`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.ZipFile.read()", "path": "library/zipfile#zipfile.ZipFile.read", "type": "Data Compression", "text": "\nReturn the bytes of the file name in the archive. name is the name of the file\nin the archive, or a `ZipInfo` object. The archive must be open for read or\nappend. pwd is the password used for encrypted files and, if specified, it\nwill override the default password set with `setpassword()`. Calling `read()`\non a ZipFile that uses a compression method other than `ZIP_STORED`,\n`ZIP_DEFLATED`, `ZIP_BZIP2` or `ZIP_LZMA` will raise a `NotImplementedError`.\nAn error will also be raised if the corresponding compression module is not\navailable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.ZipFile.setpassword()", "path": "library/zipfile#zipfile.ZipFile.setpassword", "type": "Data Compression", "text": "\nSet pwd as default password to extract encrypted files.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.ZipFile.testzip()", "path": "library/zipfile#zipfile.ZipFile.testzip", "type": "Data Compression", "text": "\nRead all the files in the archive and check their CRC\u2019s and file headers.\nReturn the name of the first bad file, or else return `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.ZipFile.write()", "path": "library/zipfile#zipfile.ZipFile.write", "type": "Data Compression", "text": "\nWrite the file named filename to the archive, giving it the archive name\narcname (by default, this will be the same as filename, but without a drive\nletter and with leading path separators removed). If given, compress_type\noverrides the value given for the compression parameter to the constructor for\nthe new entry. Similarly, compresslevel will override the constructor if\ngiven. The archive must be open with mode `'w'`, `'x'` or `'a'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.ZipFile.writestr()", "path": "library/zipfile#zipfile.ZipFile.writestr", "type": "Data Compression", "text": "\nWrite a file into the archive. The contents is data, which may be either a\n`str` or a `bytes` instance; if it is a `str`, it is encoded as UTF-8 first.\nzinfo_or_arcname is either the file name it will be given in the archive, or a\n`ZipInfo` instance. If it\u2019s an instance, at least the filename, date, and time\nmust be given. If it\u2019s a name, the date and time is set to the current date\nand time. The archive must be opened with mode `'w'`, `'x'` or `'a'`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.ZipInfo", "path": "library/zipfile#zipfile.ZipInfo", "type": "Data Compression", "text": "\nClass used to represent information about a member of an archive. Instances of\nthis class are returned by the `getinfo()` and `infolist()` methods of\n`ZipFile` objects. Most users of the `zipfile` module will not need to create\nthese, but only use those created by this module. filename should be the full\nname of the archive member, and date_time should be a tuple containing six\nfields which describe the time of the last modification to the file; the\nfields are described in section ZipInfo Objects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.ZipInfo.comment", "path": "library/zipfile#zipfile.ZipInfo.comment", "type": "Data Compression", "text": "\nComment for the individual archive member as a `bytes` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.ZipInfo.compress_size", "path": "library/zipfile#zipfile.ZipInfo.compress_size", "type": "Data Compression", "text": "\nSize of the compressed data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.ZipInfo.compress_type", "path": "library/zipfile#zipfile.ZipInfo.compress_type", "type": "Data Compression", "text": "\nType of compression for the archive member.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.ZipInfo.CRC", "path": "library/zipfile#zipfile.ZipInfo.CRC", "type": "Data Compression", "text": "\nCRC-32 of the uncompressed file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.ZipInfo.create_system", "path": "library/zipfile#zipfile.ZipInfo.create_system", "type": "Data Compression", "text": "\nSystem which created ZIP archive.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.ZipInfo.create_version", "path": "library/zipfile#zipfile.ZipInfo.create_version", "type": "Data Compression", "text": "\nPKZIP version which created ZIP archive.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.ZipInfo.date_time", "path": "library/zipfile#zipfile.ZipInfo.date_time", "type": "Data Compression", "text": "\nThe time and date of the last modification to the archive member. This is a\ntuple of six values:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.ZipInfo.external_attr", "path": "library/zipfile#zipfile.ZipInfo.external_attr", "type": "Data Compression", "text": "\nExternal file attributes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.ZipInfo.extra", "path": "library/zipfile#zipfile.ZipInfo.extra", "type": "Data Compression", "text": "\nExpansion field data. The PKZIP Application Note contains some comments on the\ninternal structure of the data contained in this `bytes` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.ZipInfo.extract_version", "path": "library/zipfile#zipfile.ZipInfo.extract_version", "type": "Data Compression", "text": "\nPKZIP version needed to extract archive.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.ZipInfo.filename", "path": "library/zipfile#zipfile.ZipInfo.filename", "type": "Data Compression", "text": "\nName of the file in the archive.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.ZipInfo.file_size", "path": "library/zipfile#zipfile.ZipInfo.file_size", "type": "Data Compression", "text": "\nSize of the uncompressed file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.ZipInfo.flag_bits", "path": "library/zipfile#zipfile.ZipInfo.flag_bits", "type": "Data Compression", "text": "\nZIP flag bits.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.ZipInfo.from_file()", "path": "library/zipfile#zipfile.ZipInfo.from_file", "type": "Data Compression", "text": "\nConstruct a `ZipInfo` instance for a file on the filesystem, in preparation\nfor adding it to a zip file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.ZipInfo.header_offset", "path": "library/zipfile#zipfile.ZipInfo.header_offset", "type": "Data Compression", "text": "\nByte offset to the file header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.ZipInfo.internal_attr", "path": "library/zipfile#zipfile.ZipInfo.internal_attr", "type": "Data Compression", "text": "\nInternal attributes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.ZipInfo.is_dir()", "path": "library/zipfile#zipfile.ZipInfo.is_dir", "type": "Data Compression", "text": "\nReturn `True` if this archive member is a directory.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.ZipInfo.reserved", "path": "library/zipfile#zipfile.ZipInfo.reserved", "type": "Data Compression", "text": "\nMust be zero.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.ZipInfo.volume", "path": "library/zipfile#zipfile.ZipInfo.volume", "type": "Data Compression", "text": "\nVolume number of file header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.ZIP_BZIP2", "path": "library/zipfile#zipfile.ZIP_BZIP2", "type": "Data Compression", "text": "\nThe numeric constant for the BZIP2 compression method. This requires the `bz2`\nmodule.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.ZIP_DEFLATED", "path": "library/zipfile#zipfile.ZIP_DEFLATED", "type": "Data Compression", "text": "\nThe numeric constant for the usual ZIP compression method. This requires the\n`zlib` module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.ZIP_LZMA", "path": "library/zipfile#zipfile.ZIP_LZMA", "type": "Data Compression", "text": "\nThe numeric constant for the LZMA compression method. This requires the `lzma`\nmodule.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipfile.ZIP_STORED", "path": "library/zipfile#zipfile.ZIP_STORED", "type": "Data Compression", "text": "\nThe numeric constant for an uncompressed archive member.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipimport", "path": "library/zipimport", "type": "Importing", "text": "\nSource code: Lib/zipimport.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipimport.zipimporter", "path": "library/zipimport#zipimport.zipimporter", "type": "Importing", "text": "\nCreate a new zipimporter instance. archivepath must be a path to a ZIP file,\nor to a specific path within a ZIP file. For example, an archivepath of\n`foo/bar.zip/lib` will look for modules in the `lib` directory inside the ZIP\nfile `foo/bar.zip` (provided that it exists).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipimport.zipimporter.archive", "path": "library/zipimport#zipimport.zipimporter.archive", "type": "Importing", "text": "\nThe file name of the importer\u2019s associated ZIP file, without a possible\nsubpath.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipimport.zipimporter.find_module()", "path": "library/zipimport#zipimport.zipimporter.find_module", "type": "Importing", "text": "\nSearch for a module specified by fullname. fullname must be the fully\nqualified (dotted) module name. It returns the zipimporter instance itself if\nthe module was found, or `None` if it wasn\u2019t. The optional path argument is\nignored\u2014it\u2019s there for compatibility with the importer protocol.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipimport.zipimporter.get_code()", "path": "library/zipimport#zipimport.zipimporter.get_code", "type": "Importing", "text": "\nReturn the code object for the specified module. Raise `ZipImportError` if the\nmodule couldn\u2019t be found.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipimport.zipimporter.get_data()", "path": "library/zipimport#zipimport.zipimporter.get_data", "type": "Importing", "text": "\nReturn the data associated with pathname. Raise `OSError` if the file wasn\u2019t\nfound.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipimport.zipimporter.get_filename()", "path": "library/zipimport#zipimport.zipimporter.get_filename", "type": "Importing", "text": "\nReturn the value `__file__` would be set to if the specified module was\nimported. Raise `ZipImportError` if the module couldn\u2019t be found.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipimport.zipimporter.get_source()", "path": "library/zipimport#zipimport.zipimporter.get_source", "type": "Importing", "text": "\nReturn the source code for the specified module. Raise `ZipImportError` if the\nmodule couldn\u2019t be found, return `None` if the archive does contain the\nmodule, but has no source for it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipimport.zipimporter.is_package()", "path": "library/zipimport#zipimport.zipimporter.is_package", "type": "Importing", "text": "\nReturn `True` if the module specified by fullname is a package. Raise\n`ZipImportError` if the module couldn\u2019t be found.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipimport.zipimporter.load_module()", "path": "library/zipimport#zipimport.zipimporter.load_module", "type": "Importing", "text": "\nLoad the module specified by fullname. fullname must be the fully qualified\n(dotted) module name. It returns the imported module, or raises\n`ZipImportError` if it wasn\u2019t found.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipimport.zipimporter.prefix", "path": "library/zipimport#zipimport.zipimporter.prefix", "type": "Importing", "text": "\nThe subpath within the ZIP file where modules are searched. This is the empty\nstring for zipimporter objects which point to the root of the ZIP file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zipimport.ZipImportError", "path": "library/zipimport#zipimport.ZipImportError", "type": "Importing", "text": "\nException raised by zipimporter objects. It\u2019s a subclass of `ImportError`, so\nit can be caught as `ImportError`, too.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zlib", "path": "library/zlib", "type": "Data Compression", "text": "\nFor applications that require data compression, the functions in this module\nallow compression and decompression, using the zlib library. The zlib library\nhas its own home page at https://www.zlib.net. There are known\nincompatibilities between the Python module and versions of the zlib library\nearlier than 1.1.3; 1.1.3 has a security vulnerability, so we recommend using\n1.1.4 or later.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zlib.adler32()", "path": "library/zlib#zlib.adler32", "type": "Data Compression", "text": "\nComputes an Adler-32 checksum of data. (An Adler-32 checksum is almost as\nreliable as a CRC32 but can be computed much more quickly.) The result is an\nunsigned 32-bit integer. If value is present, it is used as the starting value\nof the checksum; otherwise, a default value of 1 is used. Passing in value\nallows computing a running checksum over the concatenation of several inputs.\nThe algorithm is not cryptographically strong, and should not be used for\nauthentication or digital signatures. Since the algorithm is designed for use\nas a checksum algorithm, it is not suitable for use as a general hash\nalgorithm.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zlib.compress()", "path": "library/zlib#zlib.compress", "type": "Data Compression", "text": "\nCompresses the bytes in data, returning a bytes object containing compressed\ndata. level is an integer from `0` to `9` or `-1` controlling the level of\ncompression; `1` (Z_BEST_SPEED) is fastest and produces the least compression,\n`9` (Z_BEST_COMPRESSION) is slowest and produces the most. `0`\n(Z_NO_COMPRESSION) is no compression. The default value is `-1`\n(Z_DEFAULT_COMPRESSION). Z_DEFAULT_COMPRESSION represents a default compromise\nbetween speed and compression (currently equivalent to level 6). Raises the\n`error` exception if any error occurs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zlib.Compress.compress()", "path": "library/zlib#zlib.Compress.compress", "type": "Data Compression", "text": "\nCompress data, returning a bytes object containing compressed data for at\nleast part of the data in data. This data should be concatenated to the output\nproduced by any preceding calls to the `compress()` method. Some input may be\nkept in internal buffers for later processing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zlib.Compress.copy()", "path": "library/zlib#zlib.Compress.copy", "type": "Data Compression", "text": "\nReturns a copy of the compression object. This can be used to efficiently\ncompress a set of data that share a common initial prefix.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zlib.Compress.flush()", "path": "library/zlib#zlib.Compress.flush", "type": "Data Compression", "text": "\nAll pending input is processed, and a bytes object containing the remaining\ncompressed output is returned. mode can be selected from the constants\n`Z_NO_FLUSH`, `Z_PARTIAL_FLUSH`, `Z_SYNC_FLUSH`, `Z_FULL_FLUSH`, `Z_BLOCK`\n(zlib 1.2.3.4), or `Z_FINISH`, defaulting to `Z_FINISH`. Except `Z_FINISH`,\nall constants allow compressing further bytestrings of data, while `Z_FINISH`\nfinishes the compressed stream and prevents compressing any more data. After\ncalling `flush()` with mode set to `Z_FINISH`, the `compress()` method cannot\nbe called again; the only realistic action is to delete the object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zlib.compressobj()", "path": "library/zlib#zlib.compressobj", "type": "Data Compression", "text": "\nReturns a compression object, to be used for compressing data streams that\nwon\u2019t fit into memory at once.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zlib.crc32()", "path": "library/zlib#zlib.crc32", "type": "Data Compression", "text": "\nComputes a CRC (Cyclic Redundancy Check) checksum of data. The result is an\nunsigned 32-bit integer. If value is present, it is used as the starting value\nof the checksum; otherwise, a default value of 0 is used. Passing in value\nallows computing a running checksum over the concatenation of several inputs.\nThe algorithm is not cryptographically strong, and should not be used for\nauthentication or digital signatures. Since the algorithm is designed for use\nas a checksum algorithm, it is not suitable for use as a general hash\nalgorithm.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zlib.decompress()", "path": "library/zlib#zlib.decompress", "type": "Data Compression", "text": "\nDecompresses the bytes in data, returning a bytes object containing the\nuncompressed data. The wbits parameter depends on the format of data, and is\ndiscussed further below. If bufsize is given, it is used as the initial size\nof the output buffer. Raises the `error` exception if any error occurs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zlib.Decompress.copy()", "path": "library/zlib#zlib.Decompress.copy", "type": "Data Compression", "text": "\nReturns a copy of the decompression object. This can be used to save the state\nof the decompressor midway through the data stream in order to speed up random\nseeks into the stream at a future point.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zlib.Decompress.decompress()", "path": "library/zlib#zlib.Decompress.decompress", "type": "Data Compression", "text": "\nDecompress data, returning a bytes object containing the uncompressed data\ncorresponding to at least part of the data in string. This data should be\nconcatenated to the output produced by any preceding calls to the\n`decompress()` method. Some of the input data may be preserved in internal\nbuffers for later processing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zlib.Decompress.eof", "path": "library/zlib#zlib.Decompress.eof", "type": "Data Compression", "text": "\nA boolean indicating whether the end of the compressed data stream has been\nreached.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zlib.Decompress.flush()", "path": "library/zlib#zlib.Decompress.flush", "type": "Data Compression", "text": "\nAll pending input is processed, and a bytes object containing the remaining\nuncompressed output is returned. After calling `flush()`, the `decompress()`\nmethod cannot be called again; the only realistic action is to delete the\nobject.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zlib.Decompress.unconsumed_tail", "path": "library/zlib#zlib.Decompress.unconsumed_tail", "type": "Data Compression", "text": "\nA bytes object that contains any data that was not consumed by the last\n`decompress()` call because it exceeded the limit for the uncompressed data\nbuffer. This data has not yet been seen by the zlib machinery, so you must\nfeed it (possibly with further data concatenated to it) back to a subsequent\n`decompress()` method call in order to get correct output.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zlib.Decompress.unused_data", "path": "library/zlib#zlib.Decompress.unused_data", "type": "Data Compression", "text": "\nA bytes object which contains any bytes past the end of the compressed data.\nThat is, this remains `b\"\"` until the last byte that contains compression data\nis available. If the whole bytestring turned out to contain compressed data,\nthis is `b\"\"`, an empty bytes object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zlib.decompressobj()", "path": "library/zlib#zlib.decompressobj", "type": "Data Compression", "text": "\nReturns a decompression object, to be used for decompressing data streams that\nwon\u2019t fit into memory at once.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zlib.error", "path": "library/zlib#zlib.error", "type": "Data Compression", "text": "\nException raised on compression and decompression errors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zlib.ZLIB_RUNTIME_VERSION", "path": "library/zlib#zlib.ZLIB_RUNTIME_VERSION", "type": "Data Compression", "text": "\nThe version string of the zlib library actually loaded by the interpreter.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zlib.ZLIB_VERSION", "path": "library/zlib#zlib.ZLIB_VERSION", "type": "Data Compression", "text": "\nThe version string of the zlib library that was used for building the module.\nThis may be different from the zlib library actually used at runtime, which is\navailable as `ZLIB_RUNTIME_VERSION`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zoneinfo", "path": "library/zoneinfo", "type": "Data Types", "text": "\nNew in version 3.9.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zoneinfo.available_timezones()", "path": "library/zoneinfo#zoneinfo.available_timezones", "type": "Data Types", "text": "\nGet a set containing all the valid keys for IANA time zones available anywhere\non the time zone path. This is recalculated on every call to the function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zoneinfo.InvalidTZPathWarning", "path": "library/zoneinfo#zoneinfo.InvalidTZPathWarning", "type": "Data Types", "text": "\nRaised when `PYTHONTZPATH` contains an invalid component that will be filtered\nout, such as a relative path.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zoneinfo.reset_tzpath()", "path": "library/zoneinfo#zoneinfo.reset_tzpath", "type": "Data Types", "text": "\nSets or resets the time zone search path (`TZPATH`) for the module. When\ncalled with no arguments, `TZPATH` is set to the default value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zoneinfo.TZPATH", "path": "library/zoneinfo#zoneinfo.TZPATH", "type": "Data Types", "text": "\nA read-only sequence representing the time zone search path \u2013 when\nconstructing a `ZoneInfo` from a key, the key is joined to each entry in the\n`TZPATH`, and the first file found is used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zoneinfo.ZoneInfo", "path": "library/zoneinfo#zoneinfo.ZoneInfo", "type": "Data Types", "text": "\nA concrete `datetime.tzinfo` subclass that represents an IANA time zone\nspecified by the string `key`. Calls to the primary constructor will always\nreturn objects that compare identically; put another way, barring cache\ninvalidation via `ZoneInfo.clear_cache()`, for all values of `key`, the\nfollowing assertion will always be true:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zoneinfo.ZoneInfo.clear_cache()", "path": "library/zoneinfo#zoneinfo.ZoneInfo.clear_cache", "type": "Data Types", "text": "\nA method for invalidating the cache on the `ZoneInfo` class. If no arguments\nare passed, all caches are invalidated and the next call to the primary\nconstructor for each key will return a new instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zoneinfo.ZoneInfo.from_file()", "path": "library/zoneinfo#zoneinfo.ZoneInfo.from_file", "type": "Data Types", "text": "\nConstructs a `ZoneInfo` object from a file-like object returning bytes (e.g. a\nfile opened in binary mode or an `io.BytesIO` object). Unlike the primary\nconstructor, this always constructs a new object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zoneinfo.ZoneInfo.key", "path": "library/zoneinfo#zoneinfo.ZoneInfo.key", "type": "Data Types", "text": "\nThis is a read-only attribute that returns the value of `key` passed to the\nconstructor, which should be a lookup key in the IANA time zone database (e.g.\n`America/New_York`, `Europe/Paris` or `Asia/Tokyo`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zoneinfo.ZoneInfo.no_cache()", "path": "library/zoneinfo#zoneinfo.ZoneInfo.no_cache", "type": "Data Types", "text": "\nAn alternate constructor that bypasses the constructor\u2019s cache. It is\nidentical to the primary constructor, but returns a new object on each call.\nThis is most likely to be useful for testing or demonstration purposes, but it\ncan also be used to create a system with a different cache invalidation\nstrategy.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "zoneinfo.ZoneInfoNotFoundError", "path": "library/zoneinfo#zoneinfo.ZoneInfoNotFoundError", "type": "Data Types", "text": "\nRaised when construction of a `ZoneInfo` object fails because the specified\nkey could not be found on the system. This is a subclass of `KeyError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "_thread", "path": "library/_thread", "type": "Concurrent Execution", "text": "\nThis module provides low-level primitives for working with multiple threads\n(also called light-weight processes or tasks) \u2014 multiple threads of control\nsharing their global data space. For synchronization, simple locks (also\ncalled mutexes or binary semaphores) are provided. The `threading` module\nprovides an easier to use and higher-level threading API built on top of this\nmodule.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "_thread.allocate_lock()", "path": "library/_thread#_thread.allocate_lock", "type": "Concurrent Execution", "text": "\nReturn a new lock object. Methods of locks are described below. The lock is\ninitially unlocked.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "_thread.error", "path": "library/_thread#_thread.error", "type": "Concurrent Execution", "text": "\nRaised on thread-specific errors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "_thread.exit()", "path": "library/_thread#_thread.exit", "type": "Concurrent Execution", "text": "\nRaise the `SystemExit` exception. When not caught, this will cause the thread\nto exit silently.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "_thread.get_ident()", "path": "library/_thread#_thread.get_ident", "type": "Concurrent Execution", "text": "\nReturn the \u2018thread identifier\u2019 of the current thread. This is a nonzero\ninteger. Its value has no direct meaning; it is intended as a magic cookie to\nbe used e.g. to index a dictionary of thread-specific data. Thread identifiers\nmay be recycled when a thread exits and another thread is created.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "_thread.get_native_id()", "path": "library/_thread#_thread.get_native_id", "type": "Concurrent Execution", "text": "\nReturn the native integral Thread ID of the current thread assigned by the\nkernel. This is a non-negative integer. Its value may be used to uniquely\nidentify this particular thread system-wide (until the thread terminates,\nafter which the value may be recycled by the OS).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "_thread.interrupt_main()", "path": "library/_thread#_thread.interrupt_main", "type": "Concurrent Execution", "text": "\nSimulate the effect of a `signal.SIGINT` signal arriving in the main thread. A\nthread can use this function to interrupt the main thread.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "_thread.lock.acquire()", "path": "library/_thread#_thread.lock.acquire", "type": "Concurrent Execution", "text": "\nWithout any optional argument, this method acquires the lock unconditionally,\nif necessary waiting until it is released by another thread (only one thread\nat a time can acquire a lock \u2014 that\u2019s their reason for existence).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "_thread.lock.locked()", "path": "library/_thread#_thread.lock.locked", "type": "Concurrent Execution", "text": "\nReturn the status of the lock: `True` if it has been acquired by some thread,\n`False` if not.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "_thread.lock.release()", "path": "library/_thread#_thread.lock.release", "type": "Concurrent Execution", "text": "\nReleases the lock. The lock must have been acquired earlier, but not\nnecessarily by the same thread.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "_thread.LockType", "path": "library/_thread#_thread.LockType", "type": "Concurrent Execution", "text": "\nThis is the type of lock objects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "_thread.stack_size()", "path": "library/_thread#_thread.stack_size", "type": "Concurrent Execution", "text": "\nReturn the thread stack size used when creating new threads. The optional size\nargument specifies the stack size to be used for subsequently created threads,\nand must be 0 (use platform or configured default) or a positive integer value\nof at least 32,768 (32 KiB). If size is not specified, 0 is used. If changing\nthe thread stack size is unsupported, a `RuntimeError` is raised. If the\nspecified stack size is invalid, a `ValueError` is raised and the stack size\nis unmodified. 32 KiB is currently the minimum supported stack size value to\nguarantee sufficient stack space for the interpreter itself. Note that some\nplatforms may have particular restrictions on values for the stack size, such\nas requiring a minimum stack size > 32 KiB or requiring allocation in\nmultiples of the system memory page size - platform documentation should be\nreferred to for more information (4 KiB pages are common; using multiples of\n4096 for the stack size is the suggested approach in the absence of more\nspecific information).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "_thread.start_new_thread()", "path": "library/_thread#_thread.start_new_thread", "type": "Concurrent Execution", "text": "\nStart a new thread and return its identifier. The thread executes the function\nfunction with the argument list args (which must be a tuple). The optional\nkwargs argument specifies a dictionary of keyword arguments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "_thread.TIMEOUT_MAX", "path": "library/_thread#_thread.TIMEOUT_MAX", "type": "Concurrent Execution", "text": "\nThe maximum value allowed for the timeout parameter of `Lock.acquire()`.\nSpecifying a timeout greater than this value will raise an `OverflowError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "__debug__", "path": "library/constants#__debug__", "type": "Built-in Constants", "text": "\nThis constant is true if Python was not started with an `-O` option. See also\nthe `assert` statement.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "__future__", "path": "library/__future__", "type": "Runtime", "text": "\nSource code: Lib/__future__.py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "__import__()", "path": "library/functions#__import__", "type": "Built-in Functions", "text": "\nNote\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "__main__", "path": "library/__main__", "type": "Runtime", "text": "\n`'__main__'` is the name of the scope in which top-level code executes. A\nmodule\u2019s __name__ is set equal to `'__main__'` when read from standard input,\na script, or from an interactive prompt.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}]