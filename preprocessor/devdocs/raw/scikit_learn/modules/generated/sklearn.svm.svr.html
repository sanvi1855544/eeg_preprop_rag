<h1>sklearn.svm.SVR</h1> <dl class="py class"> <dt id="sklearn.svm.SVR">
<code>class sklearn.svm.SVR(*, kernel='rbf', degree=3, gamma='scale', coef0=0.0, tol=0.001, C=1.0, epsilon=0.1, shrinking=True, cache_size=200, verbose=False, max_iter=- 1)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/95119c13a/sklearn/svm/_classes.py#L898"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Epsilon-Support Vector Regression.</p> <p>The free parameters in the model are C and epsilon.</p> <p>The implementation is based on libsvm. The fit time complexity is more than quadratic with the number of samples which makes it hard to scale to datasets with more than a couple of 10000 samples. For large datasets consider using <a class="reference internal" href="sklearn.svm.linearsvr#sklearn.svm.LinearSVR" title="sklearn.svm.LinearSVR"><code>LinearSVR</code></a> or <a class="reference internal" href="sklearn.linear_model.sgdregressor#sklearn.linear_model.SGDRegressor" title="sklearn.linear_model.SGDRegressor"><code>SGDRegressor</code></a> instead, possibly after a <a class="reference internal" href="sklearn.kernel_approximation.nystroem#sklearn.kernel_approximation.Nystroem" title="sklearn.kernel_approximation.Nystroem"><code>Nystroem</code></a> transformer.</p> <p>Read more in the <a class="reference internal" href="../svm#svm-regression"><span class="std std-ref">User Guide</span></a>.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<code>kernel{‘linear’, ‘poly’, ‘rbf’, ‘sigmoid’, ‘precomputed’}, default=’rbf’</code> </dt>
<dd>
<p>Specifies the kernel type to be used in the algorithm. It must be one of ‘linear’, ‘poly’, ‘rbf’, ‘sigmoid’, ‘precomputed’ or a callable. If none is given, ‘rbf’ will be used. If a callable is given it is used to precompute the kernel matrix.</p> </dd> <dt>
<code>degreeint, default=3</code> </dt>
<dd>
<p>Degree of the polynomial kernel function (‘poly’). Ignored by all other kernels.</p> </dd> <dt>
<code>gamma{‘scale’, ‘auto’} or float, default=’scale’</code> </dt>
<dd>
<p>Kernel coefficient for ‘rbf’, ‘poly’ and ‘sigmoid’.</p> <ul class="simple"> <li>if <code>gamma='scale'</code> (default) is passed then it uses 1 / (n_features * X.var()) as value of gamma,</li> <li>if ‘auto’, uses 1 / n_features.</li> </ul> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.22: </span>The default value of <code>gamma</code> changed from ‘auto’ to ‘scale’.</p> </div> </dd> <dt>
<code>coef0float, default=0.0</code> </dt>
<dd>
<p>Independent term in kernel function. It is only significant in ‘poly’ and ‘sigmoid’.</p> </dd> <dt>
<code>tolfloat, default=1e-3</code> </dt>
<dd>
<p>Tolerance for stopping criterion.</p> </dd> <dt>
<code>Cfloat, default=1.0</code> </dt>
<dd>
<p>Regularization parameter. The strength of the regularization is inversely proportional to C. Must be strictly positive. The penalty is a squared l2 penalty.</p> </dd> <dt>
<code>epsilonfloat, default=0.1</code> </dt>
<dd>
<p>Epsilon in the epsilon-SVR model. It specifies the epsilon-tube within which no penalty is associated in the training loss function with points predicted within a distance epsilon from the actual value.</p> </dd> <dt>
<code>shrinkingbool, default=True</code> </dt>
<dd>
<p>Whether to use the shrinking heuristic. See the <a class="reference internal" href="../svm#shrinking-svm"><span class="std std-ref">User Guide</span></a>.</p> </dd> <dt>
<code>cache_sizefloat, default=200</code> </dt>
<dd>
<p>Specify the size of the kernel cache (in MB).</p> </dd> <dt>
<code>verbosebool, default=False</code> </dt>
<dd>
<p>Enable verbose output. Note that this setting takes advantage of a per-process runtime setting in libsvm that, if enabled, may not work properly in a multithreaded context.</p> </dd> <dt>
<code>max_iterint, default=-1</code> </dt>
<dd>
<p>Hard limit on iterations within solver, or -1 for no limit.</p> </dd> </dl> </dd> <dt class="field-even">Attributes</dt> <dd class="field-even">
<dl> <dt>
<code>class_weight_ndarray of shape (n_classes,)</code> </dt>
<dd>
<p>Multipliers of parameter C for each class. Computed based on the <code>class_weight</code> parameter.</p> </dd> <dt>
<code>coef_ndarray of shape (1, n_features)</code> </dt>
<dd>
<p>Weights assigned to the features (coefficients in the primal problem). This is only available in the case of a linear kernel.</p> <p><code>coef_</code> is readonly property derived from <code>dual_coef_</code> and <code>support_vectors_</code>.</p> </dd> <dt>
<code>dual_coef_ndarray of shape (1, n_SV)</code> </dt>
<dd>
<p>Coefficients of the support vector in the decision function.</p> </dd> <dt>
<code>fit_status_int</code> </dt>
<dd>
<p>0 if correctly fitted, 1 otherwise (will raise warning)</p> </dd> <dt>
<code>intercept_ndarray of shape (1,)</code> </dt>
<dd>
<p>Constants in decision function.</p> </dd> <dt>
<code>n_support_ndarray of shape (n_classes,), dtype=int32</code> </dt>
<dd>
<p>Number of support vectors for each class.</p> </dd> <dt>
<code>shape_fit_tuple of int of shape (n_dimensions_of_X,)</code> </dt>
<dd>
<p>Array dimensions of training vector <code>X</code>.</p> </dd> <dt>
<code>support_ndarray of shape (n_SV,)</code> </dt>
<dd>
<p>Indices of support vectors.</p> </dd> <dt>
<code>support_vectors_ndarray of shape (n_SV, n_features)</code> </dt>
<dd>
<p>Support vectors.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
 <a class="reference internal" href="sklearn.svm.nusvr#sklearn.svm.NuSVR" title="sklearn.svm.NuSVR"><code>NuSVR</code></a>
</dt>
<dd>
<p>Support Vector Machine for regression implemented using libsvm using a parameter to control the number of support vectors.</p> </dd> <dt>
 <a class="reference internal" href="sklearn.svm.linearsvr#sklearn.svm.LinearSVR" title="sklearn.svm.LinearSVR"><code>LinearSVR</code></a>
</dt>
<dd>
<p>Scalable Linear Support Vector Machine for regression implemented using liblinear.</p> </dd> </dl> </div> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r4ae6a8049c28-1">
<code>1</code> </dt> <dd>
<p><a class="reference external" href="http://www.csie.ntu.edu.tw/~cjlin/papers/libsvm.pdf">LIBSVM: A Library for Support Vector Machines</a></p> </dd> <dt class="label" id="r4ae6a8049c28-2">
<code>2</code> </dt> <dd>
<p><a class="reference external" href="http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.1639">Platt, John (1999). “Probabilistic outputs for support vector machines and comparison to regularizedlikelihood methods.”</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from sklearn.svm import SVR
&gt;&gt;&gt; from sklearn.pipeline import make_pipeline
&gt;&gt;&gt; from sklearn.preprocessing import StandardScaler
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; n_samples, n_features = 10, 5
&gt;&gt;&gt; rng = np.random.RandomState(0)
&gt;&gt;&gt; y = rng.randn(n_samples)
&gt;&gt;&gt; X = rng.randn(n_samples, n_features)
&gt;&gt;&gt; regr = make_pipeline(StandardScaler(), SVR(C=1.0, epsilon=0.2))
&gt;&gt;&gt; regr.fit(X, y)
Pipeline(steps=[('standardscaler', StandardScaler()),
                ('svr', SVR(epsilon=0.2))])
</pre> <h4 class="rubric">Methods</h4> <table class="longtable docutils align-default">   <tr>
<td><p><a class="reference internal" href="#sklearn.svm.SVR.fit" title="sklearn.svm.SVR.fit"><code>fit</code></a>(X, y[, sample_weight])</p></td> <td><p>Fit the SVM model according to the given training data.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.svm.SVR.get_params" title="sklearn.svm.SVR.get_params"><code>get_params</code></a>([deep])</p></td> <td><p>Get parameters for this estimator.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.svm.SVR.predict" title="sklearn.svm.SVR.predict"><code>predict</code></a>(X)</p></td> <td><p>Perform regression on samples in X.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.svm.SVR.score" title="sklearn.svm.SVR.score"><code>score</code></a>(X, y[, sample_weight])</p></td> <td><p>Return the coefficient of determination <span class="math notranslate nohighlight">\(R^2\)</span> of the prediction.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.svm.SVR.set_params" title="sklearn.svm.SVR.set_params"><code>set_params</code></a>(**params)</p></td> <td><p>Set the parameters of this estimator.</p></td> </tr>  </table> <dl class="py method"> <dt id="sklearn.svm.SVR.fit">
<code>fit(X, y, sample_weight=None)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/95119c13a/sklearn/svm/_base.py#L119"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Fit the SVM model according to the given training data.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>X{array-like, sparse matrix} of shape (n_samples, n_features) or (n_samples, n_samples)</code> </dt>
<dd>
<p>Training vectors, where n_samples is the number of samples and n_features is the number of features. For kernel=”precomputed”, the expected shape of X is (n_samples, n_samples).</p> </dd> <dt>
<code>yarray-like of shape (n_samples,)</code> </dt>
<dd>
<p>Target values (class labels in classification, real numbers in regression).</p> </dd> <dt>
<code>sample_weightarray-like of shape (n_samples,), default=None</code> </dt>
<dd>
<p>Per-sample weights. Rescale C per sample. Higher weights force the classifier to put more emphasis on these points.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>selfobject</code> </dt>
 </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>If X and y are not C-ordered and contiguous arrays of np.float64 and X is not a scipy.sparse.csr_matrix, X and/or y may be copied.</p> <p>If X is a dense array, then the other methods will not support sparse matrices as input.</p> </dd>
</dl> <dl class="py method"> <dt id="sklearn.svm.SVR.get_params">
<code>get_params(deep=True)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/95119c13a/sklearn/base.py#L178"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get parameters for this estimator.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>deepbool, default=True</code> </dt>
<dd>
<p>If True, will return the parameters for this estimator and contained subobjects that are estimators.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>paramsdict</code> </dt>
<dd>
<p>Parameter names mapped to their values.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt id="sklearn.svm.SVR.predict">
<code>predict(X)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/95119c13a/sklearn/svm/_base.py#L327"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Perform regression on samples in X.</p> <p>For an one-class model, +1 (inlier) or -1 (outlier) is returned.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>X{array-like, sparse matrix} of shape (n_samples, n_features)</code> </dt>
<dd>
<p>For kernel=”precomputed”, the expected shape of X is (n_samples_test, n_samples_train).</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>y_predndarray of shape (n_samples,)</code> </dt>
 </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt id="sklearn.svm.SVR.score">
<code>score(X, y, sample_weight=None)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/95119c13a/sklearn/base.py#L510"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the coefficient of determination <span class="math notranslate nohighlight">\(R^2\)</span> of the prediction.</p> <p>The coefficient <span class="math notranslate nohighlight">\(R^2\)</span> is defined as <span class="math notranslate nohighlight">\((1 - \frac{u}{v})\)</span>, where <span class="math notranslate nohighlight">\(u\)</span> is the residual sum of squares <code>((y_true - y_pred)
** 2).sum()</code> and <span class="math notranslate nohighlight">\(v\)</span> is the total sum of squares <code>((y_true -
y_true.mean()) ** 2).sum()</code>. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of <code>y</code>, disregarding the input features, would get a <span class="math notranslate nohighlight">\(R^2\)</span> score of 0.0.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>Xarray-like of shape (n_samples, n_features)</code> </dt>
<dd>
<p>Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape <code>(n_samples, n_samples_fitted)</code>, where <code>n_samples_fitted</code> is the number of samples used in the fitting for the estimator.</p> </dd> <dt>
<code>yarray-like of shape (n_samples,) or (n_samples, n_outputs)</code> </dt>
<dd>
<p>True values for <code>X</code>.</p> </dd> <dt>
<code>sample_weightarray-like of shape (n_samples,), default=None</code> </dt>
<dd>
<p>Sample weights.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>scorefloat</code> </dt>
<dd>
<p><span class="math notranslate nohighlight">\(R^2\)</span> of <code>self.predict(X)</code> wrt. <code>y</code>.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>The <span class="math notranslate nohighlight">\(R^2\)</span> score used when calling <code>score</code> on a regressor uses <code>multioutput='uniform_average'</code> from version 0.23 to keep consistent with default value of <a class="reference internal" href="sklearn.metrics.r2_score#sklearn.metrics.r2_score" title="sklearn.metrics.r2_score"><code>r2_score</code></a>. This influences the <code>score</code> method of all the multioutput regressors (except for <a class="reference internal" href="sklearn.multioutput.multioutputregressor#sklearn.multioutput.MultiOutputRegressor" title="sklearn.multioutput.MultiOutputRegressor"><code>MultiOutputRegressor</code></a>).</p> </dd>
</dl> <dl class="py method"> <dt id="sklearn.svm.SVR.set_params">
<code>set_params(**params)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/95119c13a/sklearn/base.py#L202"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the parameters of this estimator.</p> <p>The method works on simple estimators as well as on nested objects (such as <a class="reference internal" href="sklearn.pipeline.pipeline#sklearn.pipeline.Pipeline" title="sklearn.pipeline.Pipeline"><code>Pipeline</code></a>). The latter have parameters of the form <code>&lt;component&gt;__&lt;parameter&gt;</code> so that it’s possible to update each component of a nested object.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>**paramsdict</code> </dt>
<dd>
<p>Estimator parameters.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>selfestimator instance</code> </dt>
<dd>
<p>Estimator instance.</p> </dd> </dl> </dd> </dl> </dd>
</dl> </dd>
</dl>  <h2 id="examples-using-sklearn-svm-svr">Examples using <code>sklearn.svm.SVR</code>
</h2> <div class="sphx-glr-thumbcontainer" tooltip="This is an example showing the prediction latency of various scikit-learn estimators.">
<div class="figure align-default" id="id3"> <img alt="Prediction Latency" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="../../auto_examples/applications/plot_prediction_latency#sphx-glr-auto-examples-applications-plot-prediction-latency-py"><span class="std std-ref">Prediction Latency</span></a></span></p> </div> </div>
<div class="sphx-glr-thumbcontainer" tooltip="Both kernel ridge regression (KRR) and SVR learn a non-linear function by employing the kernel ...">
<div class="figure align-default" id="id4"> <img alt="Comparison of kernel ridge regression and SVR" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZAAAAEYCAMAAABFglBLAAADAFBMVEX///+Tk5Ompqa2traKiorr6+uioqK+vr5paWkAAAD/AAD09PTt7e3w8PDo6Ojy8vLq6ur+///6+/t2d3dycnL+//9YWFj+/f3u7+9ubm78/PyRkZHm5uZra2v5+vrf39/Y2NjLy8uGhoaDg4PV1tZ6enrz8/OcnJzp6elmZmbT09NQUFBhYWFbW1uys7N9fX1kY2OAgIDj5OT3+PiYmJjc3d3j4uKqqqo6Ojq0tbX29vbPz8+1u7tWVVXExcWVlpa8vLzb29uOj4/4+fgjIyNdXV3h4eHJycnQ0dG6urrMzc3/EhKmqamMjY3AwcHGx8ien580NTSvsLDW29v/tbbCw8NTU1OIiIj/9/dGHh4sLCyZmpoZGRjq9OqlpKX/GhxkAQCBAABMTUzmAQHJAAA+Pz9aAgL1AgOurq5ILCwGUQHcAgEJBga4t7f/IyRJSUkODg0AGAB4AACpr69gXl7tAAASixUBeAH/1dUEXgAJhQpCQ0LJ5MrUAQH+LS5bT08VdQQBcQCfAAADaQD/aGmsq6v/VlcADQBHCAiVAwBPDQ1GRkZvAQCNAAD/jI2oAAADNQBHExP8AQBQAwMbkCCepaT/PT25AQCxAABYr1tOPT3/eXocAwLAAAEDQwD/5eYmlytUSkr/SEm7wMD7n59BFRXq7e2k0aVKNTVRREMuBgL/ycnu9fNEYQF8vX0xmjQhbQAOgA7S6dO+LhD/wMBpuG09AgD/8fHmIh7f799MqU9VODkAJQCdMAL8Dg6VzZdpHAAyXQRPjk23WENcUAP9q6vqVk7MGQdFSQC73bzm6+vkPDzqvbo9pUM8LgkfUhpwNDSGRAey2bEyagA3iC3hf3dtR0rqkIyOx45xOgCpHBGChobH48ZCexyHLgCOXV/Fhonq1ddlHR1zlWyCGBIqZy1iaBaHVTckNATL1sARLhHDc2ObKyyDh4eZqXOsi2Jqi0jHQCVmey0tISG2rYjFm4u9wqOIez+XilXViX2AikeVlFypg2yusIehpnemtooYng5LAAAgAElEQVR42uyba2/i2BmAXxMuVhySLPbYGDvY3OIxlwAx11AgQIgxBQLZhuzAbNTSSZtRRbOaTquqaLVSJaRWmXZVVautRtoP1WqrVqoq9VM/9B/0V/UYZqrtaBORndEoyZxH4pLj44veh3POe44dAAwGg8FgMBgMBoPBYDAYDAaDwWAwGAwGg8FgMBjMt6E5HDpqUzf6thsuEIJ9ZdEdS0GAafMbN7ny5vEou0AcAYh5s8i55MKxXoTsSCnT2sgOsJLTabYVjWgL7qmmIDlKf+Mm6hTJAmmvS/RaYPOZRdKEwsFehHrVfD8bARyeA10GsWfGsmDlQLdCmFGznBjqbkhdkvdRcSccZrn8xsaZuQ9PxGNu2E6qRM3jH/L55Akp1ECKqynXzrlsOsh5IaSCLMBmgGyPtFpV7cZtsLXB6zjulzIdkIQI7tMCsArQ1s2TiBOV2nJpYKzrk8PCaCw99De2Ths+2ZZbB39S7DnCs988vfe0BmvFVFCtwkBtFvb8+vmZ1leCT1OeF0LE7WIXOiOgozo/ACGi+/fE8Ug3Jhkc+EsJV/u9CjCBTG4bQr36Q2VWSgvUqTjNtbJFfj/nBvkiNHbZJjZoB5zFjZbpDJjehQSNPXuLvqAmB7CPdB239cFJix+5ZkIyg9hFbgWOihzSHZ5sRgxw5tbJeraFOjLMFVwIUJgEVKShrZ31ts2ig749CtleV7E35MkOajL5GL126oZkHLQOEzEHaL6r5CR5L6V0O9R5AaRTJ7StvoGC/tZetBDb/X58JqSJTkD1l8DdW99g7YpFwkG/DLtSsvdK4D3/CCVEfBsgSnNmntR/mAcx0vVtyXKOgoa9GYq6ItWlXnJF0YenNVSFLEM5p6ttPa+7UMSlnht1aNpTwbfU1OaDem8TggPpaASBoqEOOOXciA/Eo/6SnnXjwF+Gz0+HSuhzHEdZ0JkDIO2f5adLDMq2pGOmnbFV0VAdYNrrIIcE+5iq0gF5lp8hg/ahk2ACDY7IgK29A8YS2KqMP+ghVs2ByIoOoXSkIWgCbSl7OXtoeLoOpRCt4IzrJiAKKTbA4TjcGDTjxIF9YDDvTBfswFyN7e0KEaJVK+ZyqsWTtyuE2MW9xJW0LG9ZyBKO+dVz3HdIiIu64XjeLSE7kniz2d733gkh7y1Yb/3Grz2JzjsgRGL+/cl3FhPivNaB1ymQCpn1b31htQxUFr1vCWu2l1d424WIf/3dx5//5vA1hbgJmhBTqAVNfQoTOjKLKH5dZLsHFensRR2bP2mut4tJmlFgPxlYhYw/Wbn8dNusZsza5OrLEFMCXUAfXJa2igBevwNglxbMNWeQ6dodEVJ9sry8/Oi55/WEhKyyIap5oCLh4sHBhXkzxQhAfLIblqq51Gw/D1NuRdEvXqukyWNv1JLivaplnKBERRHnTXXXfghuY1pyd0/WQEpl67WjNTAIPdsrz+7OwHHc6K+g3EKXFZKDVo6A3Q294XXaUxVg9DsiZONPSMjPH+wsJuSX33uVD2ab4qGmF8YkbPEca7H0zJYQOOSEvpy0WEYOit5HDaToBHb2NATV35ZioLH7/UwtJ5Opw/mNqrOBJZFN7yk6YynTTlZhRlwx3VWnjvy54Q6geGtsBnjDbCJHx21otlNl4GM84U368wVQhDsipPwMCfniz9xiQn7/3Vf46b/mXZayEQvuFCV+F4rJOmMW8R3Un4A/6+MBChTqeNhNiIbNLUhcOMFxbKYV4weNJGN450J40MlKEcI9mh+hOpW+px6uywBhFb3QGLHZd0PI7AC1blRx1kuBOMXS9xOGop5RkE3eESF/ef6DR59+9eWCY4jng1f5n8mkH9pMjHLF7tdIc2QInIHBICE6P9/uLIq1vsih+uQWZPpeW58CLdPfhwYpzIWo0NmoJKAQyayulBLQiHB1OYEGjXB0fgRPvQDRAzDPKPbTcWZymqHtELCDHGdgSNwRIfCfwCeJg9fNspSkwB6B/PAYtL4EFgYNSUYSlngULimiOGnUKXEplQlwwynIEQo4P0+iEcBKEp4yQVqc5gBw2LMWDbnOeWlaUCg1rp5zRWnMts/EInE/MKsRC/EuQ6gdE/wx0lIWQI/5n2ZOBMZ6d8aQ6+Sxlwu53zHQ8OAprAAX1EALo3BpoXV3GvZXITymwubNWk7v1EDahhXUC4H3qMRBZtxE+RF626LNcNNHTaBkDmpHhoRGd1nm5B20dxrS4xV5lm81djdhtcI1x81ZM0HJQMVYBck48EpxFxby5qrLZp61dfwa1+a+bfOQ91xvXch18Wpv5ApvhRDus+ePE+/fcCFvqA3fBiH3un989MNfP97GQm6IEO/jj9Fk4wnxloWgVIvSXqMf4sDrXbiu5xYJuff3P/wYCfmUvvae263P3l9ISDoNYse5ZR9rIFlOZk9hQz4LQzU/9fheVgpbZhN1eZrfAa6TRQO5bJGvODstl0qzL4WXT9RJlsbssqZTEWT7SXYfSmfzW+haQLxFLcTzty+QkO9f+9nmLx8/e/KgtYgQobwfOwxPpkwIiHqWNf85x0tmMpNDtyjljPlalY8ViuZ8pDyM09yQL6trQVQiQ0Wfb/dkpIIXMtsNTtLRmYLBaMO9Amu+oPu8O19cyRSrrDnd8A3L7Era0uo5PNZTA5UfSGC/TRPDe52vfvv5M/a6T266Hz9aXv7JA+lrQnY+fJX5TH1IJhwQfuo+uYCU1ZkImO2BhM7Ab5CNQbww3jXXu07AmpofOFKLNiGaJ1KQqpai/vljCVSOSQS4SFTZYvyMc8rGB2ki5U4wgXBuwxE2wzz0QzY0aw9pFkmU2B2A0BjCdf/QI0VrtyjLutdgEsNrP0nb/BFqV8vPfvY1If/456/+n198OJ+pf4QcBHPkwA6p0/rAXDoxUA8Zc4fVHVYDh7kgT/6XvXMPaiq74/hBTEi4JDDJzb15ci8JCSTkQjBBSEJCQEIIS3gECYO4yEvERdBVxN1a0FVhERUX0fWx67PW1a74Qlu147rortOus+2sa7t1um2n0xn/aDvbdqeddtp/ek+CO3HFyssI6f3N8Jg5NzlwPvd3fuf7u79zYge1Sv98nxYBypyecnZ6JPCm93QkBJbkmh0ZOJZLlQCbMGljj4GU7sjNYfdAANpEkAgfEFSVARcHXprpgzXH82HKRdgGKlMqLYBFicNdGIoKhyCQuuwgINe++20LDKZJbWADnQG0VYGcnHglTMlWokCKyQu1iG3sThB6QQQcQtwDsegSOG15bMBW4m416o/dvJQYoC/UE3hDkruEoOQAI3PYbLi1y6Ab+9/zgDkQCHFDCUBSYEhSOwDuUml5LEoT9kp90abtK/YcOB0zkRgSEYOxrU6AO62mPED66Ls1Wb8IT5FbnVKqRdwGCTkory9RDrckunR4buW8Do0LS8VcRW6vzciikSDlsjI9YssAMmGpOU6V3pKfKzMRvtRUIyrj6+C0lujzOt2IzGh3m1NI4DXgNIsUVQHhjfLJS9GQxhCH0hQTciAiwtY3dMY6kaCe4ALJptxUAFylVjrswhUUqHKAHg3fC4rSi0r92ctIlR3wM3GTSmUyElUy+hqHygFIz3wSoWiNFOsrUxKgRQykmSo2oomomcdKSAAuZU18hspNpMJ3KFWZAVK7yKX00KutqCJ6IZCTnu5g5SldQFUZSiB4mVsmCTzUM4UylyWoqLBMWYfwCyeucIpxOGVZpuHNpdIQr7JyKXq2NpZWStrmSnJx0ovzRMFM/IUhAsIzwLU9ryYvxR2uQOZU6iQWfVS7EcIp63uepE8YIOMb1dDjFoQ2qAuE/dvXrixkgIxr5szatvjQAskeWhEdvXuTdGJAkkl5fByMzBoWmfHMlKB4nCtipHMJyOR0iOXsDHSUtoVWhSsGT40HJLZMmHMq+OI2vVBIUom0qHZTCgXqT/EiFhynlQL9ZZECHBghBAT+Fo8Y7EZ/MtifEIaejxiNlM4IBAjM8SIgXiMIIyAxwupqjnzaHXnqaSCN1cg4QE6d2bl77emCoIsNLQCXyjyAxHgUC8ki6XFNMqAZeW6QXmTGJPpkK4ZihbiM0mfIbUJZua+HFiFVIAM1RigkpFHVkW7Px7yknsoBSk6amcPpCR8gAn19Y+Ou45bpdlRRvX9FY92vx4shSljtuAsN9hCbxBufaxN4ZMBHrV5NUzSmmMUCtRdI7GxbrKnKtZwVydFhvBaUyMqVaqHalGOWJFMUVqKSeBUaHuLMAFqvGEtEVdIqoRwJGyCixL499HA1V067J/uZ/up0y3hAjjfRPbSeDq6at1RitYDjpQgc05WoYZ2tHVUkpqfSQGqVwCqpVAC+06sGhEHnpCc2f3JK2KYlaho8SnMVm/YoqgDH+EDtFkYBfpWWjYeNh5TWPZ6jnYb6XXBqfB1i2A2rHTcFp05IHhoBIpdw8EW2AqCeB2VenDAiSVVQXjpvNaGKSMgiy1AiJcOUloEBXNsGY0RJFgeUdMjlhMNZQCDOEhytyfUREjcgFrinptpnpYfIq1ujo9cPVky/K5HoKcLQ3nd4fVOfOagpVcGp4gEe5QbxKj4gVfEA93DS+CxUjZLFFCpE7D41hwCZemGcXAlAVEcmgLW6qQDP1Eqi6HijQtwdLcmo3gsirMDBUTjCx0NE+wa3b+nLe65KPftM9aHMib6sBtZbORThpUMms8oSJaSpS55z6kR6duLrUit8ME60/f8CYXJZDBAGCAOEAfIsIC6CAfICgcQ+0Sr0PyCw+DdfMkBCDIR0lvseO81anJZOmc2oSuzK15ZYhUIdAySUQGLLuVxuPj+oSaW0ZqWSiUqVpoG0ELoeZzwDJIRAHFxoQcoQd2YA1JvEwfQIFgu8Ws5yMQMkhEBK/EBagpoUqRafrIFVSyE+FmhI0G1MZoCEEAiykeZRHnxym9WGNqQKtRwOUDrtEZS6gcUAmYiJpDMCBCyUbOSQj7XFxhilAr7RAqR8BCQjFpwB8myz5J1eifJnZtlrBLPR5hYQXF3X1Vp/HJkRIIxSnzYQ0QL/Pqrm7Cl3nTzrgSTPKQ8p9G/3qN835a41RBxrVlsyYZxLHnIKPkrc058w9b6N4tltPJi2mUNBfV/flgPNQikIb5tDQEQlCkNx2H9KGps5t5cB8lwNZ4DMJiCIDENJBsisAYJzuFzukoUMkNkCJHcNzOOaGCCzBYjVD0TGAHnRQI6+v/jkwDvbenv3H9i9ZfudgY8vH2WAvBAglmtf3vvq318/HB4eHR0dHh5++NGDGyNXr3Z3t3f3Drx/lAHytHEzdRTONBDjtXvnrp/fvHnr1lfuX7l169bP3zpy68r917e+0Xns/P2//uUXd7qXdfeePMoAGXc1ase8Mwrk5feufHrxwvDD//x95SouNx9bs2rV2qb9/Q3Nh5vqqJ/ePHf9WOexg1/96W77st6TP2KAjGNqb0C1yWYAyKWb1zsv/OSz219c/r1DvYobMJgLbn23EeYfrQBIX7508/zW71y89Y87y9rfeY0B8oQJIRCWkJPlmOYbXbv5aefog5E7A6/h9h35j3BwuXCP557mVngW4NiZZRzuq2+9fvH86Idd7b2XcQbItzwE7o/BjYs80/IQ472DnRcejLw9AO/5gqWPYEAscONV4w9oD4keChysJ14Cm2gmGzb/8+5LvZeNIgbINxZfU55innYMufar8xc/Gmnf9kXgmQh7DMdSfZSW/lHfdbg5q66pa2dHoBrUmDXW/uqRi51fj3xw93f7ppwqLsqLqAgrILiuKIGYJpBLV/Ze+Oxq6+0eztI1q+GZby1jA95DD35U7TzFj48Xa8rOHKp6VLfrpVViwIn23aOnuRtdu365TjOlrnMGd9VXmxkdEkz0y4Odv7lx9cSf+9cOwSH2Sek5CbrAmqWqp973Cco8nY2+JosH+H88suHzG011WLZ78iVXFd+nZ8KulWIGyDcGcYy8dGLxuqH10dH1cJqCx+MVqDFl6TOOGIhRYuqFAJBruG8eeePzG7t/yF1SNNne18F97dHNRQyQgIku0Tj+9sGJy1JggJ+n0/gurTziAo4zEeeC3wSwWBEi+e3OVcsn2382XDDs6atggARC+ZW9928ve3sxHFjtAb/a4HLnT/ZdyNVLA0iGPxz0FkdOqt5OfGjL+vX1HQIGCG1nz9E42rs/DvhC5FBj9IqdWVTmFEodyCSoWt48smH4Z7SH6YsnUaVVYRsc5ISo/np2AFlQ4xn/U4veO3bsX93tA4+yH3hedV2/RDxFlcdypUEveWXzKMzSL5nE6R1S+SfhJgz/J5CilWu396dJnwwe1/f+4U77tqAE4X/ZO/OoprI7jj/aOsMDF0hCQgAVEVQ2A0YGhyIoBEUjiyMKQZxAg0kJiAkjhMgQEpKygwiRXZYIgqCAiuCCyCgMoLh1jss4rdvoUWemp+2ZbnNO29N3M0qDRsnRlw3f9x897w/u432493d/v/v7/a7VGr9Nlm8/OtWJFrOT1y8V1wMimmelWunOqTQEILgmxDRwyg+8slqlnf5edPKaK3m96qd5t29j50VaASc97Zb2wzw9Fa4ZPpCLBSBrN/9Pk5+OdTX+V8H8oaW8vbfFD81X2EyD4fZRMZc2CwOiHog1IxVk7fqrPtt2Iq36BlNxj80qY7FjsyzRfAeLDa5w3eAXR1ttMCBqgVhRilicSoZqi7ffN3b9TcG8QeaBq1wq8xLQ3nL6eUbeuC4+fQwDotaomzsxCg6FTZoeJ24lj5yJhutAPD2+Dt0Z8lwRfx2Vn8NhQNQ+PrhMpRB5rLHrHznMC8rAYBziI8fyVmnjVUjpiruGN0kMxTH8/+YJ2VydaEY2V89PO9jF7MJVWnqZPtnIEfk5G2iWt+1aDMhr9HmXvLWW/sOPE0eBQQe0aHubmdd3Vz/bCcM8hzm6//hhzlmesw0biOXttOrxCtbDiaPZLZ9q9fCV1CM6/sej/WCkjeouq5932FJ7gx9o2RMfV3PQgIGQtlWnnWtmnmx/gYMXoPWdaYNiYEhQn4sM5vZqxGRrG6MpTGt/DE2VIAPA1oCBjMm7nsnoJYUvzmYXBuvgjaJqOYMSKR+Go729X0rTDi/PTK1kOGppYKrS/apyNlgguNu7T4xXiDouPjfnxGDdvJJV88AerqAUDEmbFBKwaQNeUDFFS8OSlLcBxv3KUIGcOi1vbaZfegCZ05Srla3OOldZjovirwi4YNkqnDflnzB6+jivMjP/5RtlDQbImPzyM9nAIxqN4BMOkhF1WPpGsmrISb0glyK2naZ6cG7pDjoux4ZrbWr6Zp0hexnmLsvmdtqJccT5AHMjEgr1tF2j07eyIpXQ74Bla4vP4qysicpSl4S4PbHu5tqcnAbqh4DdFfJJ6pS2I0MvXfYimFVPBVxffOz+ynLy81YoVmtC8Bt0/DZaARKG+A5hOM2BHOtqBLES3s/G3FU/Qdj0Cta/L8uvIItUavsGSG/SAhDSEqKX3XwiVWMgrWnVzckV6cTnvscqPX2KPhnzVrXkehliNvRYpqgFIDZkmvsuor+mSxauc3dn7YCsz2qnkoebHqNKJfRLT8VDLE4vnLHWfPoAgRaFfjR/kYY2xGrbafl/FMxh5L/+ylCJXjtZ9STHD0q/GkRsWdLG4OkDBFrgSrGzJWkE5PPGrp+YCmUBR2BkdDTBGtKrGhSJsc+dxELc9AFCXkfAmWpkQ1rl57+kl0S9mFp6xgGRQCCluFTpJNKWkKYNEMIq/HyPeVMDCexM+6dINA4ZlCKS918Bsa0YZ3cT6jQBstZ9xcp1U9uQedVHLwzkFzCcvQyKSEMOZ1AoUS5bRLvpAQSaEWyngVEP/NeI6GExixUXPduQgJCiSujH/5JWr4w2ms6YDkAciM7ubg6zpgISlSPzLgCZ/r3ohYuoy9CwQx0VyU8kQj5AousWvtoBEuASTqYETDaXamzI8oSCXlCsGYtHa2TfmgJGJArBjj7ZQJxQojxJJNoYPxCPJVCghyNZxVdcHESY8QqQT/IyOZl5VWasus0oDRzcEs9hsf1Rse2i+FEBWLZ4jsYP5BcrKUG2jird7tcT7UIiXwGStV+ZBZefR0ArgOeUD+pH0Emra5Bx7gqEuXCSi/EDWbfgt2snVTeB2zI9kIlibe2gct1ZDTiQy/yRcgC1gU1BQU8qA6XdaoSo8isJ33UaLFn4l2NzH0RCwW4QNNOJrNo4wBPU7qVoVAylYe7HBnaZmVm2G2obYBlrSNBJmgZAthPwkaq/h58bNfzno2l/lSXLoik2PzZr5tQ/bw3hTJZGVcmBc9n5RW2rUfQSK86Kq7cpf7QxA1n/YWjopKAt1TPITU2dus9nIZ9psLzMbivOrMzT6HZckm/IvoNo/ip9tce/6PocsqYUBi0wXiDQ2k+8J3vqpNk+ara9GsofLG3xNXrKi+74ciit1R04ifONFshy4vYtblN76pqKAHINUvce1pPnHtX8RMwFHomHnbECMXXB2xCoqAHZWgSu2z6kv/Kahj93C8H5Ms3ZzjiBOASbUpxtUANifSglfk+LL6Q/kQ5xxVdACgbROIHsoHqZhKMHBDr4TZaHH6RPfZxUKhhlJ8ExLtbGBwQkOVjYBaG3ZBmASCa076RH8tlJtGg3O2MDYkOmEYOIJtB0AgJB5ltzueKzVb0wvNLolqxFH86cpWmSg+HJyz9AvcfxQcbj3UOJ2e1Jzr80MiBvkiED8dm8dBPky4gr3muiNlRDtfhW2H2HVVwHB2BAdKBlTewixjdt8cDneU3I3Z5WLxiNT0ypC8CAaF2WpsWgjWY5OMJMed3VY7+ee1UiHMzMfPSRmjm0LAC/zwcDgpYOK6tBsnvLwBHm0td/sFyuoDQlUXQj5OVMuk0gVz5rDgYEXSC84lTOnrbXexs4J7hUIIyJS9z/8HeT++B4gNPoIn8MCFoixJWZJe71JewtWPmmU1uSJ48vFpTW5aeODKseMeASQNPgyl0YELRksas8loEYj4t2U0TNvPy8HkuE/PZsjqJHxQbVxIMZRsCAoOfRBvspvXANWnKRc4WCUvi+LDmnY+LZBlCz2xKMAUFNVpp3R5u9Ai6VCsfCHmZzJpCQ9rUxmkKxXZZ+NMNhJaU67SoM91YNTCBBo+8DBuRtRYJsvpVK++Gk+wq6DL0LMTAg76BP4XoBl+8IRVQwUUOCAXkH2UXDfKGg8zBEGkYNCQbkXeTiloG/3djYagNF3RKhgwQD8m6iQtC2zrTLra402rWTaCDBgKCgY9USLmgn9BOycHVgQAxAq7/jItYddoKGweVKGBD9W/cYuF8o4P7GM2HvtUtMRUQUBkTPcoJhBMlR7h1Wds24LLni7S+0xICgInMCD07KuHJEfOR47FLfa/ks0dtenogBQUn23sGO7LKRIXH344KqorpHJ5k5w1EYEL1qTkKmmdlIvbR7tD0/ruVJTnJybYcNBkR/slraUpzN3l70tVB85Gx+0tz0EhG9oiR9ynkShQHRloI98QfC2HHZI193i7n9ARDUUVtBr6iNeMP9yH09tYp0DIgWFbirrtjMjHOWKxWcbj1ltePenZPJTEVJhJqZ0tBTgqxrFbUNGBBtyhrfvp+TmlJUd7VaLu/i8nM3jkfUipKTRQpZyXBPulIdEc21OeDZpe934PRgQ6gzqO8PEAgKXZHX3t4OL4cOt3KFAgn3fCtl5837AAGTPkBnMpkDdDrA0/z3yITYAmdr3QOxXeH/PgGBzPe5Ne0EBRmIC5/bXy8WSITcx61/OBX1gHLz5r37N884PbCnkE02JvWyzMziKLoHMtPkRfGz/3sBBBFOueHFKdum43n8Uq7waKO8Uc6tLy0t5fP5GRtzEfEfjRw/e/fqKd0BwXnZ29uvDoTCQ5T2zsUFvwN6r2SfwYtZGKa87MHk2Nh5hItUIhFIJFLkH0RiRN3iY7oDYr2QTCbjLaDFSiDWIZ6F694vIBDOcRkUCG7ijflfe+e20kYUheFRkjg4pkmNZjKZxERtTI1xMrE5iyaeTUhNKyQFlVCltS0lWDR3RYRCoPRAqUUohV6U3vQJetM36Lv0HZpEe6D0omsXnR34vwvRi8Ua15fZexaZvfdyc8A+3Xi1eWuc8fnh8fH2gAGTuho9m9VjHT1ksb5U4tNvTrTW5BV+novy45fP+7szly5eyObOnsnd8ZN6a6t21rXqp+9gy9WNra2Uc+vRRjK2uLWT7iquaLMLBjz2yj83zOpgIVr7MIP/XGEo+eeGhKlCRhCspxvC/PlyHhrDf/5Qtd/d3b5+zmkg5F/JnJ4mIkIIHwzKH1r7re13QQgv/PVQNQgxkNL40ei5H3QPIZwBIRACIARCIARCIARCIARCIARCOGSwH0I4YiH76YEyBSG8IH/bPXz48p0VQjjha/t7kNsHEMLJ/BF/09rS7KUKIZzQXvVx/OYjhPDCwesnb3e9/RDCDbOKfnJhx9xDCBpDACEQAiEQAiEQAiEQAiEQAiEQAiEAQiDkNzI3HDEJQvgRYm5MB86WgsUghI8hyxJt/pBqmp5HzY0U4oqIojhwVVidbK0nHivecEKIoUL6E3Gfz+f2h+MChix+hiz7TT2Yw6TOj5CxtXx6FULQh0AIhEAIhEAIhEAIhFwMlyGEJzyOLx8OZAjhBde77cP3T08ghBdOXvT29h4+uAYhnBBtnb9+79lXCOGE4u2mkDufcIdwwqDtaP/Oq6cHmEP4mdVNR/WPeOxFYwghEAIhENKxQmqoOVdC5qsu8y+sZjrWPnpMH1MiswGJXKrlYoVodfEX4ZRIxnt3kh40eddLD0qF6Rc385wlkf7bH0trBt6eHi9DkCNEjwk5GBJ5GXYAWrvFkGh8jJfxckphCAqwCAkwJFISDEJMDIlEKy9CMtMMQSGGy7cySBSmM/QYu58hUWEIzzIAdABD1RHyHb6wPjpHfnaIjcySL84VHL/Fex4AAAFkSURBVNVkhgE1KxEjEiOj1yU+hGwqSaeZGCPd32mQJwNLvkKerez5Ul0j/0s2MUU9pCpXWQ31c+FDXgoJA/TGPdJgyOXNkUOkgkIOkufv61Qhpb2BqsyFELdzWYjSqxtgENIQ6YPCnKNyhdz2OnzkIFtijpdFM+FhQaR/cqPr5JC0l2mQtkTI4sPhxSg9kUnlQ0ijbtKpTao7/VgvEWN6FtXkMnl2Vi2TaYaOp0Lt72fVLP1WPCfKSTt5nKsVu1eIMfFkt4V8QmffepGlm3QPX6M+AzYaywIAAIDOQpZkFIEnzOPtM7UTBZSCB2y5tSX7cN4jzE/kJH/Nj4oYy4LiUPb8wS7dfut5t8eyqa+gJobidwrxHbM2nyrnmv14Wa2MoCaGEloSPDNZZWUmXQsIq5VyJICaGEqmno08VkVtQwtVyqWJdMWBmhjLVKzWY0tWcz5BC7p6guVhlAQAAAAAAACe+Q5Y0squIUE3vwAAAABJRU5ErkJggg=="> <p class="caption"><span class="caption-text"><a class="reference internal" href="../../auto_examples/miscellaneous/plot_kernel_ridge_regression#sphx-glr-auto-examples-miscellaneous-plot-kernel-ridge-regression-py"><span class="std std-ref">Comparison of kernel ridge regression and SVR</span></a></span></p> </div> </div>
<div class="sphx-glr-thumbcontainer" tooltip="Toy example of 1D regression using linear, polynomial and RBF kernels.">
<div class="figure align-default" id="id5"> <img alt="Support Vector Regression (SVR) using linear and non-linear kernels" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="../../auto_examples/svm/plot_svm_regression#sphx-glr-auto-examples-svm-plot-svm-regression-py"><span class="std std-ref">Support Vector Regression (SVR) using linear and non-linear kernels</span></a></span></p> </div> </div>
<div class="_attribution">
  <p class="_attribution-p">
    &copy; 2007&ndash;2020 The scikit-learn developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://scikit-learn.org/0.24/modules/generated/sklearn.svm.SVR.html" class="_attribution-link">https://scikit-learn.org/0.24/modules/generated/sklearn.svm.SVR.html</a>
  </p>
</div>
