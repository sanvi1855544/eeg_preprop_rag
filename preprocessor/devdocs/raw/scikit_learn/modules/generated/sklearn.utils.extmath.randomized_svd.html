<h1>sklearn.utils.extmath.randomized_svd</h1> <dl class="py function"> <dt id="sklearn.utils.extmath.randomized_svd">
<code>sklearn.utils.extmath.randomized_svd(M, n_components, *, n_oversamples=10, n_iter='auto', power_iteration_normalizer='auto', transpose='auto', flip_sign=True, random_state=0)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/95119c13a/sklearn/utils/extmath.py#L245"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Computes a truncated randomized SVD.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<code>M{ndarray, sparse matrix}</code> </dt>
<dd>
<p>Matrix to decompose.</p> </dd> <dt>
<code>n_componentsint</code> </dt>
<dd>
<p>Number of singular values and vectors to extract.</p> </dd> <dt>
<code>n_oversamplesint, default=10</code> </dt>
<dd>
<p>Additional number of random vectors to sample the range of M so as to ensure proper conditioning. The total number of random vectors used to find the range of M is n_components + n_oversamples. Smaller number can improve speed but can negatively impact the quality of approximation of singular vectors and singular values.</p> </dd> <dt>
<code>n_iterint or ‘auto’, default=’auto’</code> </dt>
<dd>
<p>Number of power iterations. It can be used to deal with very noisy problems. When ‘auto’, it is set to 4, unless <code>n_components</code> is small (&lt; .1 * min(X.shape)) <code>n_iter</code> in which case is set to 7. This improves precision with few components.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.18.</span></p> </div> </dd> <dt>
<code>power_iteration_normalizer{‘auto’, ‘QR’, ‘LU’, ‘none’}, default=’auto’</code> </dt>
<dd>
<p>Whether the power iterations are normalized with step-by-step QR factorization (the slowest but most accurate), ‘none’ (the fastest but numerically unstable when <code>n_iter</code> is large, e.g. typically 5 or larger), or ‘LU’ factorization (numerically stable but can lose slightly in accuracy). The ‘auto’ mode applies no normalization if <code>n_iter</code> &lt;= 2 and switches to LU otherwise.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.18.</span></p> </div> </dd> <dt>
<code>transposebool or ‘auto’, default=’auto’</code> </dt>
<dd>
<p>Whether the algorithm should be applied to M.T instead of M. The result should approximately be the same. The ‘auto’ mode will trigger the transposition if M.shape[1] &gt; M.shape[0] since this implementation of randomized SVD tend to be a little faster in that case.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.18.</span></p> </div> </dd> <dt>
<code>flip_signbool, default=True</code> </dt>
<dd>
<p>The output of a singular value decomposition is only unique up to a permutation of the signs of the singular vectors. If <code>flip_sign</code> is set to <code>True</code>, the sign ambiguity is resolved by making the largest loadings for each component in the left singular vectors positive.</p> </dd> <dt>
<code>random_stateint, RandomState instance or None, default=0</code> </dt>
<dd>
<p>The seed of the pseudo random number generator to use when shuffling the data, i.e. getting the random vectors to initialize the algorithm. Pass an int for reproducible results across multiple function calls. See <a class="reference internal" href="https://scikit-learn.org/0.24/glossary.html#term-random_state"><span class="xref std std-term">Glossary</span></a>.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>This algorithm finds a (usually very good) approximate truncated singular value decomposition using randomization to speed up the computations. It is particularly fast on large matrices on which you wish to extract only a small number of components. In order to obtain further speed up, <code>n_iter</code> can be set &lt;=2 (at the cost of loss of precision).</p> <h4 class="rubric">References</h4> <ul class="simple"> <li>Finding structure with randomness: Stochastic algorithms for constructing approximate matrix decompositions Halko, et al., 2009 <a class="reference external" href="https://arxiv.org/abs/0909.4061">https://arxiv.org/abs/0909.4061</a>
</li> <li>A randomized algorithm for the decomposition of matrices Per-Gunnar Martinsson, Vladimir Rokhlin and Mark Tygert</li> <li>An implementation of a randomized algorithm for principal component analysis A. Szlam et al. 2014</li> </ul> </dd>
</dl> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2007&ndash;2020 The scikit-learn developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://scikit-learn.org/0.24/modules/generated/sklearn.utils.extmath.randomized_svd.html" class="_attribution-link">https://scikit-learn.org/0.24/modules/generated/sklearn.utils.extmath.randomized_svd.html</a>
  </p>
</div>
