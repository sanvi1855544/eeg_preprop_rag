<h1>sklearn.svm.NuSVR</h1> <dl class="py class"> <dt id="sklearn.svm.NuSVR">
<code>class sklearn.svm.NuSVR(*, nu=0.5, C=1.0, kernel='rbf', degree=3, gamma='scale', coef0=0.0, shrinking=True, tol=0.001, cache_size=200, verbose=False, max_iter=- 1)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/95119c13a/sklearn/svm/_classes.py#L1073"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Nu Support Vector Regression.</p> <p>Similar to NuSVC, for regression, uses a parameter nu to control the number of support vectors. However, unlike NuSVC, where nu replaces C, here nu replaces the parameter epsilon of epsilon-SVR.</p> <p>The implementation is based on libsvm.</p> <p>Read more in the <a class="reference internal" href="../svm#svm-regression"><span class="std std-ref">User Guide</span></a>.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<code>nufloat, default=0.5</code> </dt>
<dd>
<p>An upper bound on the fraction of training errors and a lower bound of the fraction of support vectors. Should be in the interval (0, 1]. By default 0.5 will be taken.</p> </dd> <dt>
<code>Cfloat, default=1.0</code> </dt>
<dd>
<p>Penalty parameter C of the error term.</p> </dd> <dt>
<code>kernel{‘linear’, ‘poly’, ‘rbf’, ‘sigmoid’, ‘precomputed’}, default=’rbf’</code> </dt>
<dd>
<p>Specifies the kernel type to be used in the algorithm. It must be one of ‘linear’, ‘poly’, ‘rbf’, ‘sigmoid’, ‘precomputed’ or a callable. If none is given, ‘rbf’ will be used. If a callable is given it is used to precompute the kernel matrix.</p> </dd> <dt>
<code>degreeint, default=3</code> </dt>
<dd>
<p>Degree of the polynomial kernel function (‘poly’). Ignored by all other kernels.</p> </dd> <dt>
<code>gamma{‘scale’, ‘auto’} or float, default=’scale’</code> </dt>
<dd>
<p>Kernel coefficient for ‘rbf’, ‘poly’ and ‘sigmoid’.</p> <ul class="simple"> <li>if <code>gamma='scale'</code> (default) is passed then it uses 1 / (n_features * X.var()) as value of gamma,</li> <li>if ‘auto’, uses 1 / n_features.</li> </ul> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.22: </span>The default value of <code>gamma</code> changed from ‘auto’ to ‘scale’.</p> </div> </dd> <dt>
<code>coef0float, default=0.0</code> </dt>
<dd>
<p>Independent term in kernel function. It is only significant in ‘poly’ and ‘sigmoid’.</p> </dd> <dt>
<code>shrinkingbool, default=True</code> </dt>
<dd>
<p>Whether to use the shrinking heuristic. See the <a class="reference internal" href="../svm#shrinking-svm"><span class="std std-ref">User Guide</span></a>.</p> </dd> <dt>
<code>tolfloat, default=1e-3</code> </dt>
<dd>
<p>Tolerance for stopping criterion.</p> </dd> <dt>
<code>cache_sizefloat, default=200</code> </dt>
<dd>
<p>Specify the size of the kernel cache (in MB).</p> </dd> <dt>
<code>verbosebool, default=False</code> </dt>
<dd>
<p>Enable verbose output. Note that this setting takes advantage of a per-process runtime setting in libsvm that, if enabled, may not work properly in a multithreaded context.</p> </dd> <dt>
<code>max_iterint, default=-1</code> </dt>
<dd>
<p>Hard limit on iterations within solver, or -1 for no limit.</p> </dd> </dl> </dd> <dt class="field-even">Attributes</dt> <dd class="field-even">
<dl> <dt>
<code>class_weight_ndarray of shape (n_classes,)</code> </dt>
<dd>
<p>Multipliers of parameter C for each class. Computed based on the <code>class_weight</code> parameter.</p> </dd> <dt>
<code>coef_ndarray of shape (1, n_features)</code> </dt>
<dd>
<p>Weights assigned to the features (coefficients in the primal problem). This is only available in the case of a linear kernel.</p> <p><code>coef_</code> is readonly property derived from <code>dual_coef_</code> and <code>support_vectors_</code>.</p> </dd> <dt>
<code>dual_coef_ndarray of shape (1, n_SV)</code> </dt>
<dd>
<p>Coefficients of the support vector in the decision function.</p> </dd> <dt>
<code>fit_status_int</code> </dt>
<dd>
<p>0 if correctly fitted, 1 otherwise (will raise warning)</p> </dd> <dt>
<code>intercept_ndarray of shape (1,)</code> </dt>
<dd>
<p>Constants in decision function.</p> </dd> <dt>
<code>n_support_ndarray of shape (n_classes,), dtype=int32</code> </dt>
<dd>
<p>Number of support vectors for each class.</p> </dd> <dt>
<code>shape_fit_tuple of int of shape (n_dimensions_of_X,)</code> </dt>
<dd>
<p>Array dimensions of training vector <code>X</code>.</p> </dd> <dt>
<code>support_ndarray of shape (n_SV,)</code> </dt>
<dd>
<p>Indices of support vectors.</p> </dd> <dt>
<code>support_vectors_ndarray of shape (n_SV, n_features)</code> </dt>
<dd>
<p>Support vectors.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
 <a class="reference internal" href="sklearn.svm.nusvc#sklearn.svm.NuSVC" title="sklearn.svm.NuSVC"><code>NuSVC</code></a>
</dt>
<dd>
<p>Support Vector Machine for classification implemented with libsvm with a parameter to control the number of support vectors.</p> </dd> <dt>
 <a class="reference internal" href="sklearn.svm.svr#sklearn.svm.SVR" title="sklearn.svm.SVR"><code>SVR</code></a>
</dt>
<dd>
<p>Epsilon Support Vector Machine for regression implemented with libsvm.</p> </dd> </dl> </div> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r495acb08bb55-1">
<code>1</code> </dt> <dd>
<p><a class="reference external" href="http://www.csie.ntu.edu.tw/~cjlin/papers/libsvm.pdf">LIBSVM: A Library for Support Vector Machines</a></p> </dd> <dt class="label" id="r495acb08bb55-2">
<code>2</code> </dt> <dd>
<p><a class="reference external" href="http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.1639">Platt, John (1999). “Probabilistic outputs for support vector machines and comparison to regularizedlikelihood methods.”</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from sklearn.svm import NuSVR
&gt;&gt;&gt; from sklearn.pipeline import make_pipeline
&gt;&gt;&gt; from sklearn.preprocessing import StandardScaler
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; n_samples, n_features = 10, 5
&gt;&gt;&gt; np.random.seed(0)
&gt;&gt;&gt; y = np.random.randn(n_samples)
&gt;&gt;&gt; X = np.random.randn(n_samples, n_features)
&gt;&gt;&gt; regr = make_pipeline(StandardScaler(), NuSVR(C=1.0, nu=0.1))
&gt;&gt;&gt; regr.fit(X, y)
Pipeline(steps=[('standardscaler', StandardScaler()),
                ('nusvr', NuSVR(nu=0.1))])
</pre> <h4 class="rubric">Methods</h4> <table class="longtable docutils align-default">   <tr>
<td><p><a class="reference internal" href="#sklearn.svm.NuSVR.fit" title="sklearn.svm.NuSVR.fit"><code>fit</code></a>(X, y[, sample_weight])</p></td> <td><p>Fit the SVM model according to the given training data.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.svm.NuSVR.get_params" title="sklearn.svm.NuSVR.get_params"><code>get_params</code></a>([deep])</p></td> <td><p>Get parameters for this estimator.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.svm.NuSVR.predict" title="sklearn.svm.NuSVR.predict"><code>predict</code></a>(X)</p></td> <td><p>Perform regression on samples in X.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.svm.NuSVR.score" title="sklearn.svm.NuSVR.score"><code>score</code></a>(X, y[, sample_weight])</p></td> <td><p>Return the coefficient of determination <span class="math notranslate nohighlight">\(R^2\)</span> of the prediction.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#sklearn.svm.NuSVR.set_params" title="sklearn.svm.NuSVR.set_params"><code>set_params</code></a>(**params)</p></td> <td><p>Set the parameters of this estimator.</p></td> </tr>  </table> <dl class="py method"> <dt id="sklearn.svm.NuSVR.fit">
<code>fit(X, y, sample_weight=None)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/95119c13a/sklearn/svm/_base.py#L119"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Fit the SVM model according to the given training data.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>X{array-like, sparse matrix} of shape (n_samples, n_features) or (n_samples, n_samples)</code> </dt>
<dd>
<p>Training vectors, where n_samples is the number of samples and n_features is the number of features. For kernel=”precomputed”, the expected shape of X is (n_samples, n_samples).</p> </dd> <dt>
<code>yarray-like of shape (n_samples,)</code> </dt>
<dd>
<p>Target values (class labels in classification, real numbers in regression).</p> </dd> <dt>
<code>sample_weightarray-like of shape (n_samples,), default=None</code> </dt>
<dd>
<p>Per-sample weights. Rescale C per sample. Higher weights force the classifier to put more emphasis on these points.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>selfobject</code> </dt>
 </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>If X and y are not C-ordered and contiguous arrays of np.float64 and X is not a scipy.sparse.csr_matrix, X and/or y may be copied.</p> <p>If X is a dense array, then the other methods will not support sparse matrices as input.</p> </dd>
</dl> <dl class="py method"> <dt id="sklearn.svm.NuSVR.get_params">
<code>get_params(deep=True)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/95119c13a/sklearn/base.py#L178"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Get parameters for this estimator.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>deepbool, default=True</code> </dt>
<dd>
<p>If True, will return the parameters for this estimator and contained subobjects that are estimators.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>paramsdict</code> </dt>
<dd>
<p>Parameter names mapped to their values.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt id="sklearn.svm.NuSVR.predict">
<code>predict(X)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/95119c13a/sklearn/svm/_base.py#L327"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Perform regression on samples in X.</p> <p>For an one-class model, +1 (inlier) or -1 (outlier) is returned.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>X{array-like, sparse matrix} of shape (n_samples, n_features)</code> </dt>
<dd>
<p>For kernel=”precomputed”, the expected shape of X is (n_samples_test, n_samples_train).</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>y_predndarray of shape (n_samples,)</code> </dt>
 </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt id="sklearn.svm.NuSVR.score">
<code>score(X, y, sample_weight=None)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/95119c13a/sklearn/base.py#L510"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the coefficient of determination <span class="math notranslate nohighlight">\(R^2\)</span> of the prediction.</p> <p>The coefficient <span class="math notranslate nohighlight">\(R^2\)</span> is defined as <span class="math notranslate nohighlight">\((1 - \frac{u}{v})\)</span>, where <span class="math notranslate nohighlight">\(u\)</span> is the residual sum of squares <code>((y_true - y_pred)
** 2).sum()</code> and <span class="math notranslate nohighlight">\(v\)</span> is the total sum of squares <code>((y_true -
y_true.mean()) ** 2).sum()</code>. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of <code>y</code>, disregarding the input features, would get a <span class="math notranslate nohighlight">\(R^2\)</span> score of 0.0.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>Xarray-like of shape (n_samples, n_features)</code> </dt>
<dd>
<p>Test samples. For some estimators this may be a precomputed kernel matrix or a list of generic objects instead with shape <code>(n_samples, n_samples_fitted)</code>, where <code>n_samples_fitted</code> is the number of samples used in the fitting for the estimator.</p> </dd> <dt>
<code>yarray-like of shape (n_samples,) or (n_samples, n_outputs)</code> </dt>
<dd>
<p>True values for <code>X</code>.</p> </dd> <dt>
<code>sample_weightarray-like of shape (n_samples,), default=None</code> </dt>
<dd>
<p>Sample weights.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>scorefloat</code> </dt>
<dd>
<p><span class="math notranslate nohighlight">\(R^2\)</span> of <code>self.predict(X)</code> wrt. <code>y</code>.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>The <span class="math notranslate nohighlight">\(R^2\)</span> score used when calling <code>score</code> on a regressor uses <code>multioutput='uniform_average'</code> from version 0.23 to keep consistent with default value of <a class="reference internal" href="sklearn.metrics.r2_score#sklearn.metrics.r2_score" title="sklearn.metrics.r2_score"><code>r2_score</code></a>. This influences the <code>score</code> method of all the multioutput regressors (except for <a class="reference internal" href="sklearn.multioutput.multioutputregressor#sklearn.multioutput.MultiOutputRegressor" title="sklearn.multioutput.MultiOutputRegressor"><code>MultiOutputRegressor</code></a>).</p> </dd>
</dl> <dl class="py method"> <dt id="sklearn.svm.NuSVR.set_params">
<code>set_params(**params)</code> <a class="reference external" href="https://github.com/scikit-learn/scikit-learn/blob/95119c13a/sklearn/base.py#L202"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set the parameters of this estimator.</p> <p>The method works on simple estimators as well as on nested objects (such as <a class="reference internal" href="sklearn.pipeline.pipeline#sklearn.pipeline.Pipeline" title="sklearn.pipeline.Pipeline"><code>Pipeline</code></a>). The latter have parameters of the form <code>&lt;component&gt;__&lt;parameter&gt;</code> so that it’s possible to update each component of a nested object.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>**paramsdict</code> </dt>
<dd>
<p>Estimator parameters.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>selfestimator instance</code> </dt>
<dd>
<p>Estimator instance.</p> </dd> </dl> </dd> </dl> </dd>
</dl> </dd>
</dl>  <h2 id="examples-using-sklearn-svm-nusvr">Examples using <code>sklearn.svm.NuSVR</code>
</h2> <div class="sphx-glr-thumbcontainer" tooltip="Demonstrate how model complexity influences both prediction accuracy and computational performa...">
<div class="figure align-default" id="id3"> <img alt="Model Complexity Influence" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="../../auto_examples/applications/plot_model_complexity_influence#sphx-glr-auto-examples-applications-plot-model-complexity-influence-py"><span class="std std-ref">Model Complexity Influence</span></a></span></p> </div> </div>
<div class="_attribution">
  <p class="_attribution-p">
    &copy; 2007&ndash;2020 The scikit-learn developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://scikit-learn.org/0.24/modules/generated/sklearn.svm.NuSVR.html" class="_attribution-link">https://scikit-learn.org/0.24/modules/generated/sklearn.svm.NuSVR.html</a>
  </p>
</div>
