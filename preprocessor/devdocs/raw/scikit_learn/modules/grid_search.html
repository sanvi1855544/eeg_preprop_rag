<h1 id="grid-search">3.2. Tuning the hyper-parameters of an estimator</h1> <p>Hyper-parameters are parameters that are not directly learnt within estimators. In scikit-learn they are passed as arguments to the constructor of the estimator classes. Typical examples include <code>C</code>, <code>kernel</code> and <code>gamma</code> for Support Vector Classifier, <code>alpha</code> for Lasso, etc.</p> <p>It is possible and recommended to search the hyper-parameter space for the best <a class="reference internal" href="cross_validation#cross-validation"><span class="std std-ref">cross validation</span></a> score.</p> <p>Any parameter provided when constructing an estimator may be optimized in this manner. Specifically, to find the names and current values for all parameters for a given estimator, use:</p> <pre data-language="python">estimator.get_params()
</pre> <p>A search consists of:</p> <ul class="simple"> <li>an estimator (regressor or classifier such as <code>sklearn.svm.SVC()</code>);</li> <li>a parameter space;</li> <li>a method for searching or sampling candidates;</li> <li>a cross-validation scheme; and</li> <li>a <a class="reference internal" href="#gridsearch-scoring"><span class="std std-ref">score function</span></a>.</li> </ul> <p>Two generic approaches to parameter search are provided in scikit-learn: for given values, <a class="reference internal" href="generated/sklearn.model_selection.gridsearchcv#sklearn.model_selection.GridSearchCV" title="sklearn.model_selection.GridSearchCV"><code>GridSearchCV</code></a> exhaustively considers all parameter combinations, while <a class="reference internal" href="generated/sklearn.model_selection.randomizedsearchcv#sklearn.model_selection.RandomizedSearchCV" title="sklearn.model_selection.RandomizedSearchCV"><code>RandomizedSearchCV</code></a> can sample a given number of candidates from a parameter space with a specified distribution. Both these tools have successive halving counterparts <a class="reference internal" href="generated/sklearn.model_selection.halvinggridsearchcv#sklearn.model_selection.HalvingGridSearchCV" title="sklearn.model_selection.HalvingGridSearchCV"><code>HalvingGridSearchCV</code></a> and <a class="reference internal" href="generated/sklearn.model_selection.halvingrandomsearchcv#sklearn.model_selection.HalvingRandomSearchCV" title="sklearn.model_selection.HalvingRandomSearchCV"><code>HalvingRandomSearchCV</code></a>, which can be much faster at finding a good parameter combination.</p> <p>After describing these tools we detail <a class="reference internal" href="#grid-search-tips"><span class="std std-ref">best practices</span></a> applicable to these approaches. Some models allow for specialized, efficient parameter search strategies, outlined in <a class="reference internal" href="#alternative-cv"><span class="std std-ref">Alternatives to brute force parameter search</span></a>.</p> <p>Note that it is common that a small subset of those parameters can have a large impact on the predictive or computation performance of the model while others can be left to their default values. It is recommended to read the docstring of the estimator class to get a finer understanding of their expected behavior, possibly by reading the enclosed reference to the literature.</p>  <h2 id="exhaustive-grid-search">
<span class="section-number">3.2.1. </span>Exhaustive Grid Search</h2> <p>The grid search provided by <a class="reference internal" href="generated/sklearn.model_selection.gridsearchcv#sklearn.model_selection.GridSearchCV" title="sklearn.model_selection.GridSearchCV"><code>GridSearchCV</code></a> exhaustively generates candidates from a grid of parameter values specified with the <code>param_grid</code> parameter. For instance, the following <code>param_grid</code>:</p> <pre data-language="python">param_grid = [
  {'C': [1, 10, 100, 1000], 'kernel': ['linear']},
  {'C': [1, 10, 100, 1000], 'gamma': [0.001, 0.0001], 'kernel': ['rbf']},
 ]
</pre> <p>specifies that two grids should be explored: one with a linear kernel and C values in [1, 10, 100, 1000], and the second one with an RBF kernel, and the cross-product of C values ranging in [1, 10, 100, 1000] and gamma values in [0.001, 0.0001].</p> <p>The <a class="reference internal" href="generated/sklearn.model_selection.gridsearchcv#sklearn.model_selection.GridSearchCV" title="sklearn.model_selection.GridSearchCV"><code>GridSearchCV</code></a> instance implements the usual estimator API: when “fitting” it on a dataset all the possible combinations of parameter values are evaluated and the best combination is retained.</p> <div class="topic"> <p class="topic-title">Examples:</p> <ul class="simple"> <li>See <a class="reference internal" href="../auto_examples/model_selection/plot_grid_search_digits#sphx-glr-auto-examples-model-selection-plot-grid-search-digits-py"><span class="std std-ref">Parameter estimation using grid search with cross-validation</span></a> for an example of Grid Search computation on the digits dataset.</li> <li>See <a class="reference internal" href="../auto_examples/model_selection/grid_search_text_feature_extraction#sphx-glr-auto-examples-model-selection-grid-search-text-feature-extraction-py"><span class="std std-ref">Sample pipeline for text feature extraction and evaluation</span></a> for an example of Grid Search coupling parameters from a text documents feature extractor (n-gram count vectorizer and TF-IDF transformer) with a classifier (here a linear SVM trained with SGD with either elastic net or L2 penalty) using a <code>pipeline.Pipeline</code> instance.</li> <li>See <a class="reference internal" href="../auto_examples/model_selection/plot_nested_cross_validation_iris#sphx-glr-auto-examples-model-selection-plot-nested-cross-validation-iris-py"><span class="std std-ref">Nested versus non-nested cross-validation</span></a> for an example of Grid Search within a cross validation loop on the iris dataset. This is the best practice for evaluating the performance of a model with grid search.</li> <li>See <a class="reference internal" href="../auto_examples/model_selection/plot_multi_metric_evaluation#sphx-glr-auto-examples-model-selection-plot-multi-metric-evaluation-py"><span class="std std-ref">Demonstration of multi-metric evaluation on cross_val_score and GridSearchCV</span></a> for an example of <a class="reference internal" href="generated/sklearn.model_selection.gridsearchcv#sklearn.model_selection.GridSearchCV" title="sklearn.model_selection.GridSearchCV"><code>GridSearchCV</code></a> being used to evaluate multiple metrics simultaneously.</li> <li>See <a class="reference internal" href="../auto_examples/model_selection/plot_grid_search_refit_callable#sphx-glr-auto-examples-model-selection-plot-grid-search-refit-callable-py"><span class="std std-ref">Balance model complexity and cross-validated score</span></a> for an example of using <code>refit=callable</code> interface in <a class="reference internal" href="generated/sklearn.model_selection.gridsearchcv#sklearn.model_selection.GridSearchCV" title="sklearn.model_selection.GridSearchCV"><code>GridSearchCV</code></a>. The example shows how this interface adds certain amount of flexibility in identifying the “best” estimator. This interface can also be used in multiple metrics evaluation.</li> <li>See <a class="reference internal" href="../auto_examples/model_selection/plot_grid_search_stats#sphx-glr-auto-examples-model-selection-plot-grid-search-stats-py"><span class="std std-ref">Statistical comparison of models using grid search</span></a> for an example of how to do a statistical comparison on the outputs of <a class="reference internal" href="generated/sklearn.model_selection.gridsearchcv#sklearn.model_selection.GridSearchCV" title="sklearn.model_selection.GridSearchCV"><code>GridSearchCV</code></a>.</li> </ul> </div>   <h2 id="randomized-parameter-search">
<span class="section-number">3.2.2. </span>Randomized Parameter Optimization</h2> <p id="randomized-parameter-optimization">While using a grid of parameter settings is currently the most widely used method for parameter optimization, other search methods have more favourable properties. <a class="reference internal" href="generated/sklearn.model_selection.randomizedsearchcv#sklearn.model_selection.RandomizedSearchCV" title="sklearn.model_selection.RandomizedSearchCV"><code>RandomizedSearchCV</code></a> implements a randomized search over parameters, where each setting is sampled from a distribution over possible parameter values. This has two main benefits over an exhaustive search:</p> <ul class="simple"> <li>A budget can be chosen independent of the number of parameters and possible values.</li> <li>Adding parameters that do not influence the performance does not decrease efficiency.</li> </ul> <p>Specifying how parameters should be sampled is done using a dictionary, very similar to specifying parameters for <a class="reference internal" href="generated/sklearn.model_selection.gridsearchcv#sklearn.model_selection.GridSearchCV" title="sklearn.model_selection.GridSearchCV"><code>GridSearchCV</code></a>. Additionally, a computation budget, being the number of sampled candidates or sampling iterations, is specified using the <code>n_iter</code> parameter. For each parameter, either a distribution over possible values or a list of discrete choices (which will be sampled uniformly) can be specified:</p> <pre data-language="python">{'C': scipy.stats.expon(scale=100), 'gamma': scipy.stats.expon(scale=.1),
  'kernel': ['rbf'], 'class_weight':['balanced', None]}
</pre> <p>This example uses the <code>scipy.stats</code> module, which contains many useful distributions for sampling parameters, such as <code>expon</code>, <code>gamma</code>, <code>uniform</code> or <code>randint</code>.</p> <p>In principle, any function can be passed that provides a <code>rvs</code> (random variate sample) method to sample a value. A call to the <code>rvs</code> function should provide independent random samples from possible parameter values on consecutive calls.</p>  <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>The distributions in <code>scipy.stats</code> prior to version scipy 0.16 do not allow specifying a random state. Instead, they use the global numpy random state, that can be seeded via <code>np.random.seed</code> or set using <code>np.random.set_state</code>. However, beginning scikit-learn 0.18, the <a class="reference internal" href="classes#module-sklearn.model_selection" title="sklearn.model_selection"><code>sklearn.model_selection</code></a> module sets the random state provided by the user if scipy &gt;= 0.16 is also available.</p> </div>  <p>For continuous parameters, such as <code>C</code> above, it is important to specify a continuous distribution to take full advantage of the randomization. This way, increasing <code>n_iter</code> will always lead to a finer search.</p> <p>A continuous log-uniform random variable is available through <code>loguniform</code>. This is a continuous version of log-spaced parameters. For example to specify <code>C</code> above, <code>loguniform(1,
100)</code> can be used instead of <code>[1, 10, 100]</code> or <code>np.logspace(0, 2,
num=1000)</code>. This is an alias to SciPy’s <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.reciprocal.html">stats.reciprocal</a>.</p> <p>Mirroring the example above in grid search, we can specify a continuous random variable that is log-uniformly distributed between <code>1e0</code> and <code>1e3</code>:</p> <pre data-language="python">from sklearn.utils.fixes import loguniform
{'C': loguniform(1e0, 1e3),
 'gamma': loguniform(1e-4, 1e-3),
 'kernel': ['rbf'],
 'class_weight':['balanced', None]}
</pre> <div class="topic"> <p class="topic-title">Examples:</p> <ul class="simple"> <li>
<a class="reference internal" href="../auto_examples/model_selection/plot_randomized_search#sphx-glr-auto-examples-model-selection-plot-randomized-search-py"><span class="std std-ref">Comparing randomized search and grid search for hyperparameter estimation</span></a> compares the usage and efficiency of randomized search and grid search.</li> </ul> </div> <div class="topic"> <p class="topic-title">References:</p> <ul class="simple"> <li>Bergstra, J. and Bengio, Y., Random search for hyper-parameter optimization, The Journal of Machine Learning Research (2012)</li> </ul> </div>   <h2 id="successive-halving-user-guide">
<span class="section-number">3.2.3. </span>Searching for optimal parameters with successive halving</h2> <p id="searching-for-optimal-parameters-with-successive-halving">Scikit-learn also provides the <a class="reference internal" href="generated/sklearn.model_selection.halvinggridsearchcv#sklearn.model_selection.HalvingGridSearchCV" title="sklearn.model_selection.HalvingGridSearchCV"><code>HalvingGridSearchCV</code></a> and <a class="reference internal" href="generated/sklearn.model_selection.halvingrandomsearchcv#sklearn.model_selection.HalvingRandomSearchCV" title="sklearn.model_selection.HalvingRandomSearchCV"><code>HalvingRandomSearchCV</code></a> estimators that can be used to search a parameter space using successive halving <a class="footnote-reference brackets" href="#id3" id="id1">1</a> <a class="footnote-reference brackets" href="#id4" id="id2">2</a>. Successive halving (SH) is like a tournament among candidate parameter combinations. SH is an iterative selection process where all candidates (the parameter combinations) are evaluated with a small amount of resources at the first iteration. Only some of these candidates are selected for the next iteration, which will be allocated more resources. For parameter tuning, the resource is typically the number of training samples, but it can also be an arbitrary numeric parameter such as <code>n_estimators</code> in a random forest.</p> <p>As illustrated in the figure below, only a subset of candidates ‘survive’ until the last iteration. These are the candidates that have consistently ranked among the top-scoring candidates across all iterations. Each iteration is allocated an increasing amount of resources per candidate, here the number of samples.</p> <div class="figure align-center"> <a class="reference external image-reference" href="../auto_examples/model_selection/plot_successive_halving_iterations"><img alt="../_images/sphx_glr_plot_successive_halving_iterations_0012.png" src="data:image/png;base64,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"></a> </div> <p>We here briefly describe the main parameters, but each parameter and their interactions are described in more details in the sections below. The <code>factor</code> (&gt; 1) parameter controls the rate at which the resources grow, and the rate at which the number of candidates decreases. In each iteration, the number of resources per candidate is multiplied by <code>factor</code> and the number of candidates is divided by the same factor. Along with <code>resource</code> and <code>min_resources</code>, <code>factor</code> is the most important parameter to control the search in our implementation, though a value of 3 usually works well. <code>factor</code> effectively controls the number of iterations in <a class="reference internal" href="generated/sklearn.model_selection.halvinggridsearchcv#sklearn.model_selection.HalvingGridSearchCV" title="sklearn.model_selection.HalvingGridSearchCV"><code>HalvingGridSearchCV</code></a> and the number of candidates (by default) and iterations in <a class="reference internal" href="generated/sklearn.model_selection.halvingrandomsearchcv#sklearn.model_selection.HalvingRandomSearchCV" title="sklearn.model_selection.HalvingRandomSearchCV"><code>HalvingRandomSearchCV</code></a>. <code>aggressive_elimination=True</code> can also be used if the number of available resources is small. More control is available through tuning the <code>min_resources</code> parameter.</p> <p>These estimators are still <strong>experimental</strong>: their predictions and their API might change without any deprecation cycle. To use them, you need to explicitly import <code>enable_halving_search_cv</code>:</p> <pre data-language="python">&gt;&gt;&gt; # explicitly require this experimental feature
&gt;&gt;&gt; from sklearn.experimental import enable_halving_search_cv  # noqa
&gt;&gt;&gt; # now you can import normally from model_selection
&gt;&gt;&gt; from sklearn.model_selection import HalvingGridSearchCV
&gt;&gt;&gt; from sklearn.model_selection import HalvingRandomSearchCV
</pre> <div class="topic"> <p class="topic-title">Examples:</p> <ul class="simple"> <li><a class="reference internal" href="../auto_examples/model_selection/plot_successive_halving_heatmap#sphx-glr-auto-examples-model-selection-plot-successive-halving-heatmap-py"><span class="std std-ref">Comparison between grid search and successive halving</span></a></li> <li><a class="reference internal" href="../auto_examples/model_selection/plot_successive_halving_iterations#sphx-glr-auto-examples-model-selection-plot-successive-halving-iterations-py"><span class="std std-ref">Successive Halving Iterations</span></a></li> </ul> </div>  <h3 id="choosing-min-resources-and-the-number-of-candidates">
<span class="section-number">3.2.3.1. </span>Choosing <code>min_resources</code> and the number of candidates</h3> <p>Beside <code>factor</code>, the two main parameters that influence the behaviour of a successive halving search are the <code>min_resources</code> parameter, and the number of candidates (or parameter combinations) that are evaluated. <code>min_resources</code> is the amount of resources allocated at the first iteration for each candidate. The number of candidates is specified directly in <a class="reference internal" href="generated/sklearn.model_selection.halvingrandomsearchcv#sklearn.model_selection.HalvingRandomSearchCV" title="sklearn.model_selection.HalvingRandomSearchCV"><code>HalvingRandomSearchCV</code></a>, and is determined from the <code>param_grid</code> parameter of <a class="reference internal" href="generated/sklearn.model_selection.halvinggridsearchcv#sklearn.model_selection.HalvingGridSearchCV" title="sklearn.model_selection.HalvingGridSearchCV"><code>HalvingGridSearchCV</code></a>.</p> <p>Consider a case where the resource is the number of samples, and where we have 1000 samples. In theory, with <code>min_resources=10</code> and <code>factor=2</code>, we are able to run <strong>at most</strong> 7 iterations with the following number of samples: <code>[10, 20, 40, 80, 160, 320, 640]</code>.</p> <p>But depending on the number of candidates, we might run less than 7 iterations: if we start with a <strong>small</strong> number of candidates, the last iteration might use less than 640 samples, which means not using all the available resources (samples). For example if we start with 5 candidates, we only need 2 iterations: 5 candidates for the first iteration, then <code>5 // 2 = 2</code> candidates at the second iteration, after which we know which candidate performs the best (so we don’t need a third one). We would only be using at most 20 samples which is a waste since we have 1000 samples at our disposal. On the other hand, if we start with a <strong>high</strong> number of candidates, we might end up with a lot of candidates at the last iteration, which may not always be ideal: it means that many candidates will run with the full resources, basically reducing the procedure to standard search.</p> <p>In the case of <a class="reference internal" href="generated/sklearn.model_selection.halvingrandomsearchcv#sklearn.model_selection.HalvingRandomSearchCV" title="sklearn.model_selection.HalvingRandomSearchCV"><code>HalvingRandomSearchCV</code></a>, the number of candidates is set by default such that the last iteration uses as much of the available resources as possible. For <a class="reference internal" href="generated/sklearn.model_selection.halvinggridsearchcv#sklearn.model_selection.HalvingGridSearchCV" title="sklearn.model_selection.HalvingGridSearchCV"><code>HalvingGridSearchCV</code></a>, the number of candidates is determined by the <code>param_grid</code> parameter. Changing the value of <code>min_resources</code> will impact the number of possible iterations, and as a result will also have an effect on the ideal number of candidates.</p> <p>Another consideration when choosing <code>min_resources</code> is whether or not it is easy to discriminate between good and bad candidates with a small amount of resources. For example, if you need a lot of samples to distinguish between good and bad parameters, a high <code>min_resources</code> is recommended. On the other hand if the distinction is clear even with a small amount of samples, then a small <code>min_resources</code> may be preferable since it would speed up the computation.</p> <p>Notice in the example above that the last iteration does not use the maximum amount of resources available: 1000 samples are available, yet only 640 are used, at most. By default, both <a class="reference internal" href="generated/sklearn.model_selection.halvingrandomsearchcv#sklearn.model_selection.HalvingRandomSearchCV" title="sklearn.model_selection.HalvingRandomSearchCV"><code>HalvingRandomSearchCV</code></a> and <a class="reference internal" href="generated/sklearn.model_selection.halvinggridsearchcv#sklearn.model_selection.HalvingGridSearchCV" title="sklearn.model_selection.HalvingGridSearchCV"><code>HalvingGridSearchCV</code></a> try to use as many resources as possible in the last iteration, with the constraint that this amount of resources must be a multiple of both <code>min_resources</code> and <code>factor</code> (this constraint will be clear in the next section). <a class="reference internal" href="generated/sklearn.model_selection.halvingrandomsearchcv#sklearn.model_selection.HalvingRandomSearchCV" title="sklearn.model_selection.HalvingRandomSearchCV"><code>HalvingRandomSearchCV</code></a> achieves this by sampling the right amount of candidates, while <a class="reference internal" href="generated/sklearn.model_selection.halvinggridsearchcv#sklearn.model_selection.HalvingGridSearchCV" title="sklearn.model_selection.HalvingGridSearchCV"><code>HalvingGridSearchCV</code></a> achieves this by properly setting <code>min_resources</code>. Please see <a class="reference internal" href="#exhausting-the-resources"><span class="std std-ref">Exhausting the available resources</span></a> for details.</p>   <h3 id="amount-of-resource-and-number-of-candidates">
<span class="section-number">3.2.3.2. </span>Amount of resource and number of candidates at each iteration</h3> <p id="amount-of-resource-and-number-of-candidates-at-each-iteration">At any iteration <code>i</code>, each candidate is allocated a given amount of resources which we denote <code>n_resources_i</code>. This quantity is controlled by the parameters <code>factor</code> and <code>min_resources</code> as follows (<code>factor</code> is strictly greater than 1):</p> <pre data-language="python">n_resources_i = factor**i * min_resources,
</pre> <p>or equivalently:</p> <pre data-language="python">n_resources_{i+1} = n_resources_i * factor
</pre> <p>where <code>min_resources == n_resources_0</code> is the amount of resources used at the first iteration. <code>factor</code> also defines the proportions of candidates that will be selected for the next iteration:</p> <pre data-language="python">n_candidates_i = n_candidates // (factor ** i)
</pre> <p>or equivalently:</p> <pre data-language="python">n_candidates_0 = n_candidates
n_candidates_{i+1} = n_candidates_i // factor
</pre> <p>So in the first iteration, we use <code>min_resources</code> resources <code>n_candidates</code> times. In the second iteration, we use <code>min_resources *
factor</code> resources <code>n_candidates // factor</code> times. The third again multiplies the resources per candidate and divides the number of candidates. This process stops when the maximum amount of resource per candidate is reached, or when we have identified the best candidate. The best candidate is identified at the iteration that is evaluating <code>factor</code> or less candidates (see just below for an explanation).</p> <p>Here is an example with <code>min_resources=3</code> and <code>factor=2</code>, starting with 70 candidates:</p> <table class="docutils align-default">  <thead> <tr>
<th class="head"><p><code>n_resources_i</code></p></th> <th class="head"><p><code>n_candidates_i</code></p></th> </tr> </thead>  <tr>
<td><p>3 (=min_resources)</p></td> <td><p>70 (=n_candidates)</p></td> </tr> <tr>
<td><p>3 * 2 = 6</p></td> <td><p>70 // 2 = 35</p></td> </tr> <tr>
<td><p>6 * 2 = 12</p></td> <td><p>35 // 2 = 17</p></td> </tr> <tr>
<td><p>12 * 2 = 24</p></td> <td><p>17 // 2 = 8</p></td> </tr> <tr>
<td><p>24 * 2 = 48</p></td> <td><p>8 // 2 = 4</p></td> </tr> <tr>
<td><p>48 * 2 = 96</p></td> <td><p>4 // 2 = 2</p></td> </tr>  </table> <p>We can note that:</p> <ul class="simple"> <li>the process stops at the first iteration which evaluates <code>factor=2</code> candidates: the best candidate is the best out of these 2 candidates. It is not necessary to run an additional iteration, since it would only evaluate one candidate (namely the best one, which we have already identified). For this reason, in general, we want the last iteration to run at most <code>factor</code> candidates. If the last iteration evaluates more than <code>factor</code> candidates, then this last iteration reduces to a regular search (as in <a class="reference internal" href="generated/sklearn.model_selection.randomizedsearchcv#sklearn.model_selection.RandomizedSearchCV" title="sklearn.model_selection.RandomizedSearchCV"><code>RandomizedSearchCV</code></a> or <a class="reference internal" href="generated/sklearn.model_selection.gridsearchcv#sklearn.model_selection.GridSearchCV" title="sklearn.model_selection.GridSearchCV"><code>GridSearchCV</code></a>).</li> <li>each <code>n_resources_i</code> is a multiple of both <code>factor</code> and <code>min_resources</code> (which is confirmed by its definition above).</li> </ul> <p>The amount of resources that is used at each iteration can be found in the <code>n_resources_</code> attribute.</p>   <h3 id="choosing-a-resource">
<span class="section-number">3.2.3.3. </span>Choosing a resource</h3> <p>By default, the resource is defined in terms of number of samples. That is, each iteration will use an increasing amount of samples to train on. You can however manually specify a parameter to use as the resource with the <code>resource</code> parameter. Here is an example where the resource is defined in terms of the number of estimators of a random forest:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.datasets import make_classification
&gt;&gt;&gt; from sklearn.ensemble import RandomForestClassifier
&gt;&gt;&gt; from sklearn.experimental import enable_halving_search_cv  # noqa
&gt;&gt;&gt; from sklearn.model_selection import HalvingGridSearchCV
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt;
&gt;&gt;&gt; param_grid = {'max_depth': [3, 5, 10],
...               'min_samples_split': [2, 5, 10]}
&gt;&gt;&gt; base_estimator = RandomForestClassifier(random_state=0)
&gt;&gt;&gt; X, y = make_classification(n_samples=1000, random_state=0)
&gt;&gt;&gt; sh = HalvingGridSearchCV(base_estimator, param_grid, cv=5,
...                          factor=2, resource='n_estimators',
...                          max_resources=30).fit(X, y)
&gt;&gt;&gt; sh.best_estimator_
RandomForestClassifier(max_depth=5, n_estimators=24, random_state=0)
</pre> <p>Note that it is not possible to budget on a parameter that is part of the parameter grid.</p>   <h3 id="exhausting-the-resources">
<span class="section-number">3.2.3.4. </span>Exhausting the available resources</h3> <p id="exhausting-the-available-resources">As mentioned above, the number of resources that is used at each iteration depends on the <code>min_resources</code> parameter. If you have a lot of resources available but start with a low number of resources, some of them might be wasted (i.e. not used):</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.datasets import make_classification
&gt;&gt;&gt; from sklearn.svm import SVC
&gt;&gt;&gt; from sklearn.experimental import enable_halving_search_cv  # noqa
&gt;&gt;&gt; from sklearn.model_selection import HalvingGridSearchCV
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; param_grid= {'kernel': ('linear', 'rbf'),
...              'C': [1, 10, 100]}
&gt;&gt;&gt; base_estimator = SVC(gamma='scale')
&gt;&gt;&gt; X, y = make_classification(n_samples=1000)
&gt;&gt;&gt; sh = HalvingGridSearchCV(base_estimator, param_grid, cv=5,
...                          factor=2, min_resources=20).fit(X, y)
&gt;&gt;&gt; sh.n_resources_
[20, 40, 80]
</pre> <p>The search process will only use 80 resources at most, while our maximum amount of available resources is <code>n_samples=1000</code>. Here, we have <code>min_resources = r_0 = 20</code>.</p> <p>For <a class="reference internal" href="generated/sklearn.model_selection.halvinggridsearchcv#sklearn.model_selection.HalvingGridSearchCV" title="sklearn.model_selection.HalvingGridSearchCV"><code>HalvingGridSearchCV</code></a>, by default, the <code>min_resources</code> parameter is set to ‘exhaust’. This means that <code>min_resources</code> is automatically set such that the last iteration can use as many resources as possible, within the <code>max_resources</code> limit:</p> <pre data-language="python">&gt;&gt;&gt; sh = HalvingGridSearchCV(base_estimator, param_grid, cv=5,
...                          factor=2, min_resources='exhaust').fit(X, y)
&gt;&gt;&gt; sh.n_resources_
[250, 500, 1000]
</pre> <p><code>min_resources</code> was here automatically set to 250, which results in the last iteration using all the resources. The exact value that is used depends on the number of candidate parameter, on <code>max_resources</code> and on <code>factor</code>.</p> <p>For <a class="reference internal" href="generated/sklearn.model_selection.halvingrandomsearchcv#sklearn.model_selection.HalvingRandomSearchCV" title="sklearn.model_selection.HalvingRandomSearchCV"><code>HalvingRandomSearchCV</code></a>, exhausting the resources can be done in 2 ways:</p> <ul class="simple"> <li>by setting <code>min_resources='exhaust'</code>, just like for <a class="reference internal" href="generated/sklearn.model_selection.halvinggridsearchcv#sklearn.model_selection.HalvingGridSearchCV" title="sklearn.model_selection.HalvingGridSearchCV"><code>HalvingGridSearchCV</code></a>;</li> <li>by setting <code>n_candidates='exhaust'</code>.</li> </ul> <p>Both options are mutally exclusive: using <code>min_resources='exhaust'</code> requires knowing the number of candidates, and symmetrically <code>n_candidates='exhaust'</code> requires knowing <code>min_resources</code>.</p> <p>In general, exhausting the total number of resources leads to a better final candidate parameter, and is slightly more time-intensive.</p>   <h3 id="aggressive-elimination">
<span class="section-number">3.2.3.5. </span>Aggressive elimination of candidates</h3> <p id="aggressive-elimination-of-candidates">Ideally, we want the last iteration to evaluate <code>factor</code> candidates (see <a class="reference internal" href="#amount-of-resource-and-number-of-candidates"><span class="std std-ref">Amount of resource and number of candidates at each iteration</span></a>). We then just have to pick the best one. When the number of available resources is small with respect to the number of candidates, the last iteration may have to evaluate more than <code>factor</code> candidates:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.datasets import make_classification
&gt;&gt;&gt; from sklearn.svm import SVC
&gt;&gt;&gt; from sklearn.experimental import enable_halving_search_cv  # noqa
&gt;&gt;&gt; from sklearn.model_selection import HalvingGridSearchCV
&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; param_grid = {'kernel': ('linear', 'rbf'),
...               'C': [1, 10, 100]}
&gt;&gt;&gt; base_estimator = SVC(gamma='scale')
&gt;&gt;&gt; X, y = make_classification(n_samples=1000)
&gt;&gt;&gt; sh = HalvingGridSearchCV(base_estimator, param_grid, cv=5,
...                          factor=2, max_resources=40,
...                          aggressive_elimination=False).fit(X, y)
&gt;&gt;&gt; sh.n_resources_
[20, 40]
&gt;&gt;&gt; sh.n_candidates_
[6, 3]
</pre> <p>Since we cannot use more than <code>max_resources=40</code> resources, the process has to stop at the second iteration which evaluates more than <code>factor=2</code> candidates.</p> <p>Using the <code>aggressive_elimination</code> parameter, you can force the search process to end up with less than <code>factor</code> candidates at the last iteration. To do this, the process will eliminate as many candidates as necessary using <code>min_resources</code> resources:</p> <pre data-language="python">&gt;&gt;&gt; sh = HalvingGridSearchCV(base_estimator, param_grid, cv=5,
...                            factor=2,
...                            max_resources=40,
...                            aggressive_elimination=True,
...                            ).fit(X, y)
&gt;&gt;&gt; sh.n_resources_
[20, 20,  40]
&gt;&gt;&gt; sh.n_candidates_
[6, 3, 2]
</pre> <p>Notice that we end with 2 candidates at the last iteration since we have eliminated enough candidates during the first iterations, using <code>n_resources =
min_resources = 20</code>.</p>   <h3 id="successive-halving-cv-results">
<span class="section-number">3.2.3.6. </span>Analysing results with the <code>cv_results_</code> attribute</h3> <p id="analysing-results-with-the-cv-results-attribute">The <code>cv_results_</code> attribute contains useful information for analysing the results of a search. It can be converted to a pandas dataframe with <code>df =
pd.DataFrame(est.cv_results_)</code>. The <code>cv_results_</code> attribute of <a class="reference internal" href="generated/sklearn.model_selection.halvinggridsearchcv#sklearn.model_selection.HalvingGridSearchCV" title="sklearn.model_selection.HalvingGridSearchCV"><code>HalvingGridSearchCV</code></a> and <a class="reference internal" href="generated/sklearn.model_selection.halvingrandomsearchcv#sklearn.model_selection.HalvingRandomSearchCV" title="sklearn.model_selection.HalvingRandomSearchCV"><code>HalvingRandomSearchCV</code></a> is similar to that of <a class="reference internal" href="generated/sklearn.model_selection.gridsearchcv#sklearn.model_selection.GridSearchCV" title="sklearn.model_selection.GridSearchCV"><code>GridSearchCV</code></a> and <a class="reference internal" href="generated/sklearn.model_selection.randomizedsearchcv#sklearn.model_selection.RandomizedSearchCV" title="sklearn.model_selection.RandomizedSearchCV"><code>RandomizedSearchCV</code></a>, with additional information related to the successive halving process.</p> <p>Here is an example with some of the columns of a (truncated) dataframe:</p> <table class="docutils align-default">  <thead> <tr>
<th class="head"></th> <th class="head"><p>iter</p></th> <th class="head"><p>n_resources</p></th> <th class="head"><p>mean_test_score</p></th> <th class="head"><p>params</p></th> </tr> </thead>  <tr>
<td><p>0</p></td> <td><p>0</p></td> <td><p>125</p></td> <td><p>0.983667</p></td> <td><p>{‘criterion’: ‘entropy’, ‘max_depth’: None, ‘max_features’: 9, ‘min_samples_split’: 5}</p></td> </tr> <tr>
<td><p>1</p></td> <td><p>0</p></td> <td><p>125</p></td> <td><p>0.983667</p></td> <td><p>{‘criterion’: ‘gini’, ‘max_depth’: None, ‘max_features’: 8, ‘min_samples_split’: 7}</p></td> </tr> <tr>
<td><p>2</p></td> <td><p>0</p></td> <td><p>125</p></td> <td><p>0.983667</p></td> <td><p>{‘criterion’: ‘gini’, ‘max_depth’: None, ‘max_features’: 10, ‘min_samples_split’: 10}</p></td> </tr> <tr>
<td><p>3</p></td> <td><p>0</p></td> <td><p>125</p></td> <td><p>0.983667</p></td> <td><p>{‘criterion’: ‘entropy’, ‘max_depth’: None, ‘max_features’: 6, ‘min_samples_split’: 6}</p></td> </tr> <tr>
<td><p>…</p></td> <td><p>…</p></td> <td><p>…</p></td> <td><p>…</p></td> <td><p>…</p></td> </tr> <tr>
<td><p>15</p></td> <td><p>2</p></td> <td><p>500</p></td> <td><p>0.951958</p></td> <td><p>{‘criterion’: ‘entropy’, ‘max_depth’: None, ‘max_features’: 9, ‘min_samples_split’: 10}</p></td> </tr> <tr>
<td><p>16</p></td> <td><p>2</p></td> <td><p>500</p></td> <td><p>0.947958</p></td> <td><p>{‘criterion’: ‘gini’, ‘max_depth’: None, ‘max_features’: 10, ‘min_samples_split’: 10}</p></td> </tr> <tr>
<td><p>17</p></td> <td><p>2</p></td> <td><p>500</p></td> <td><p>0.951958</p></td> <td><p>{‘criterion’: ‘gini’, ‘max_depth’: None, ‘max_features’: 10, ‘min_samples_split’: 4}</p></td> </tr> <tr>
<td><p>18</p></td> <td><p>3</p></td> <td><p>1000</p></td> <td><p>0.961009</p></td> <td><p>{‘criterion’: ‘entropy’, ‘max_depth’: None, ‘max_features’: 9, ‘min_samples_split’: 10}</p></td> </tr> <tr>
<td><p>19</p></td> <td><p>3</p></td> <td><p>1000</p></td> <td><p>0.955989</p></td> <td><p>{‘criterion’: ‘gini’, ‘max_depth’: None, ‘max_features’: 10, ‘min_samples_split’: 4}</p></td> </tr>  </table> <p>Each row corresponds to a given parameter combination (a candidate) and a given iteration. The iteration is given by the <code>iter</code> column. The <code>n_resources</code> column tells you how many resources were used.</p> <p>In the example above, the best parameter combination is <code>{'criterion':
'entropy', 'max_depth': None, 'max_features': 9, 'min_samples_split': 10}</code> since it has reached the last iteration (3) with the highest score: 0.96.</p> <div class="topic"> <p class="topic-title">References:</p> <dl class="footnote brackets"> <dt class="label" id="id3">
<code>1</code> </dt> <dd>
<p>K. Jamieson, A. Talwalkar, <a class="reference external" href="http://proceedings.mlr.press/v51/jamieson16.html">Non-stochastic Best Arm Identification and Hyperparameter Optimization</a>, in proc. of Machine Learning Research, 2016.</p> </dd> <dt class="label" id="id4">
<code>2</code> </dt> <dd>
<p>L. Li, K. Jamieson, G. DeSalvo, A. Rostamizadeh, A. Talwalkar, <a class="reference external" href="https://arxiv.org/abs/1603.06560">Hyperband: A Novel Bandit-Based Approach to Hyperparameter Optimization</a>, in Machine Learning Research 18, 2018.</p> </dd> </dl> </div>    <h2 id="grid-search-tips">
<span class="section-number">3.2.4. </span>Tips for parameter search</h2>  <h3 id="gridsearch-scoring">
<span class="section-number">3.2.4.1. </span>Specifying an objective metric</h3> <p id="tips-for-parameter-search">By default, parameter search uses the <code>score</code> function of the estimator to evaluate a parameter setting. These are the <a class="reference internal" href="generated/sklearn.metrics.accuracy_score#sklearn.metrics.accuracy_score" title="sklearn.metrics.accuracy_score"><code>sklearn.metrics.accuracy_score</code></a> for classification and <a class="reference internal" href="generated/sklearn.metrics.r2_score#sklearn.metrics.r2_score" title="sklearn.metrics.r2_score"><code>sklearn.metrics.r2_score</code></a> for regression. For some applications, other scoring functions are better suited (for example in unbalanced classification, the accuracy score is often uninformative). An alternative scoring function can be specified via the <code>scoring</code> parameter of most parameter search tools. See <a class="reference internal" href="model_evaluation#scoring-parameter"><span class="std std-ref">The scoring parameter: defining model evaluation rules</span></a> for more details.</p>   <h3 id="multimetric-grid-search">
<span class="section-number">3.2.4.2. </span>Specifying multiple metrics for evaluation</h3> <p id="specifying-multiple-metrics-for-evaluation"><a class="reference internal" href="generated/sklearn.model_selection.gridsearchcv#sklearn.model_selection.GridSearchCV" title="sklearn.model_selection.GridSearchCV"><code>GridSearchCV</code></a> and <a class="reference internal" href="generated/sklearn.model_selection.randomizedsearchcv#sklearn.model_selection.RandomizedSearchCV" title="sklearn.model_selection.RandomizedSearchCV"><code>RandomizedSearchCV</code></a> allow specifying multiple metrics for the <code>scoring</code> parameter.</p> <p>Multimetric scoring can either be specified as a list of strings of predefined scores names or a dict mapping the scorer name to the scorer function and/or the predefined scorer name(s). See <a class="reference internal" href="model_evaluation#multimetric-scoring"><span class="std std-ref">Using multiple metric evaluation</span></a> for more details.</p> <p>When specifying multiple metrics, the <code>refit</code> parameter must be set to the metric (string) for which the <code>best_params_</code> will be found and used to build the <code>best_estimator_</code> on the whole dataset. If the search should not be refit, set <code>refit=False</code>. Leaving refit to the default value <code>None</code> will result in an error when using multiple metrics.</p> <p>See <a class="reference internal" href="../auto_examples/model_selection/plot_multi_metric_evaluation#sphx-glr-auto-examples-model-selection-plot-multi-metric-evaluation-py"><span class="std std-ref">Demonstration of multi-metric evaluation on cross_val_score and GridSearchCV</span></a> for an example usage.</p> <p><a class="reference internal" href="generated/sklearn.model_selection.halvingrandomsearchcv#sklearn.model_selection.HalvingRandomSearchCV" title="sklearn.model_selection.HalvingRandomSearchCV"><code>HalvingRandomSearchCV</code></a> and <a class="reference internal" href="generated/sklearn.model_selection.halvinggridsearchcv#sklearn.model_selection.HalvingGridSearchCV" title="sklearn.model_selection.HalvingGridSearchCV"><code>HalvingGridSearchCV</code></a> do not support multimetric scoring.</p>   <h3 id="composite-grid-search">
<span class="section-number">3.2.4.3. </span>Composite estimators and parameter spaces</h3> <p id="composite-estimators-and-parameter-spaces"><a class="reference internal" href="generated/sklearn.model_selection.gridsearchcv#sklearn.model_selection.GridSearchCV" title="sklearn.model_selection.GridSearchCV"><code>GridSearchCV</code></a> and <a class="reference internal" href="generated/sklearn.model_selection.randomizedsearchcv#sklearn.model_selection.RandomizedSearchCV" title="sklearn.model_selection.RandomizedSearchCV"><code>RandomizedSearchCV</code></a> allow searching over parameters of composite or nested estimators such as <a class="reference internal" href="generated/sklearn.pipeline.pipeline#sklearn.pipeline.Pipeline" title="sklearn.pipeline.Pipeline"><code>Pipeline</code></a>, <a class="reference internal" href="generated/sklearn.compose.columntransformer#sklearn.compose.ColumnTransformer" title="sklearn.compose.ColumnTransformer"><code>ColumnTransformer</code></a>, <a class="reference internal" href="generated/sklearn.ensemble.votingclassifier#sklearn.ensemble.VotingClassifier" title="sklearn.ensemble.VotingClassifier"><code>VotingClassifier</code></a> or <a class="reference internal" href="generated/sklearn.calibration.calibratedclassifiercv#sklearn.calibration.CalibratedClassifierCV" title="sklearn.calibration.CalibratedClassifierCV"><code>CalibratedClassifierCV</code></a> using a dedicated <code>&lt;estimator&gt;__&lt;parameter&gt;</code> syntax:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.model_selection import GridSearchCV
&gt;&gt;&gt; from sklearn.calibration import CalibratedClassifierCV
&gt;&gt;&gt; from sklearn.ensemble import RandomForestClassifier
&gt;&gt;&gt; from sklearn.datasets import make_moons
&gt;&gt;&gt; X, y = make_moons()
&gt;&gt;&gt; calibrated_forest = CalibratedClassifierCV(
...    base_estimator=RandomForestClassifier(n_estimators=10))
&gt;&gt;&gt; param_grid = {
...    'base_estimator__max_depth': [2, 4, 6, 8]}
&gt;&gt;&gt; search = GridSearchCV(calibrated_forest, param_grid, cv=5)
&gt;&gt;&gt; search.fit(X, y)
GridSearchCV(cv=5,
             estimator=CalibratedClassifierCV(...),
             param_grid={'base_estimator__max_depth': [2, 4, 6, 8]})
</pre> <p>Here, <code>&lt;estimator&gt;</code> is the parameter name of the nested estimator, in this case <code>base_estimator</code>. If the meta-estimator is constructed as a collection of estimators as in <code>pipeline.Pipeline</code>, then <code>&lt;estimator&gt;</code> refers to the name of the estimator, see <a class="reference internal" href="compose#pipeline-nested-parameters"><span class="std std-ref">Nested parameters</span></a>. In practice, there can be several levels of nesting:</p> <pre data-language="python">&gt;&gt;&gt; from sklearn.pipeline import Pipeline
&gt;&gt;&gt; from sklearn.feature_selection import SelectKBest
&gt;&gt;&gt; pipe = Pipeline([
...    ('select', SelectKBest()),
...    ('model', calibrated_forest)])
&gt;&gt;&gt; param_grid = {
...    'select__k': [1, 2],
...    'model__base_estimator__max_depth': [2, 4, 6, 8]}
&gt;&gt;&gt; search = GridSearchCV(pipe, param_grid, cv=5).fit(X, y)
</pre> <p>Please refer to <a class="reference internal" href="compose#pipeline"><span class="std std-ref">Pipeline: chaining estimators</span></a> for performing parameter searches over pipelines.</p>   <h3 id="model-selection-development-and-evaluation">
<span class="section-number">3.2.4.4. </span>Model selection: development and evaluation</h3> <p>Model selection by evaluating various parameter settings can be seen as a way to use the labeled data to “train” the parameters of the grid.</p> <p>When evaluating the resulting model it is important to do it on held-out samples that were not seen during the grid search process: it is recommended to split the data into a <strong>development set</strong> (to be fed to the <a class="reference internal" href="generated/sklearn.model_selection.gridsearchcv#sklearn.model_selection.GridSearchCV" title="sklearn.model_selection.GridSearchCV"><code>GridSearchCV</code></a> instance) and an <strong>evaluation set</strong> to compute performance metrics.</p> <p>This can be done by using the <a class="reference internal" href="generated/sklearn.model_selection.train_test_split#sklearn.model_selection.train_test_split" title="sklearn.model_selection.train_test_split"><code>train_test_split</code></a> utility function.</p>   <h3 id="parallelism">
<span class="section-number">3.2.4.5. </span>Parallelism</h3> <p>The parameter search tools evaluate each parameter combination on each data fold independently. Computations can be run in parallel by using the keyword <code>n_jobs=-1</code>. See function signature for more details, and also the Glossary entry for <a class="reference internal" href="https://scikit-learn.org/0.24/glossary.html#term-n_jobs"><span class="xref std std-term">n_jobs</span></a>.</p>   <h3 id="robustness-to-failure">
<span class="section-number">3.2.4.6. </span>Robustness to failure</h3> <p>Some parameter settings may result in a failure to <code>fit</code> one or more folds of the data. By default, this will cause the entire search to fail, even if some parameter settings could be fully evaluated. Setting <code>error_score=0</code> (or <code>=np.NaN</code>) will make the procedure robust to such failure, issuing a warning and setting the score for that fold to 0 (or <code>NaN</code>), but completing the search.</p>    <h2 id="alternative-cv">
<span class="section-number">3.2.5. </span>Alternatives to brute force parameter search</h2>  <h3 id="alternatives-to-brute-force-parameter-search">
<span class="section-number">3.2.5.1. </span>Model specific cross-validation</h3> <p>Some models can fit data for a range of values of some parameter almost as efficiently as fitting the estimator for a single value of the parameter. This feature can be leveraged to perform a more efficient cross-validation used for model selection of this parameter.</p> <p>The most common parameter amenable to this strategy is the parameter encoding the strength of the regularizer. In this case we say that we compute the <strong>regularization path</strong> of the estimator.</p> <p>Here is the list of such models:</p> <table class="longtable docutils align-default">   <tr>
<td><p><a class="reference internal" href="generated/sklearn.linear_model.elasticnetcv#sklearn.linear_model.ElasticNetCV" title="sklearn.linear_model.ElasticNetCV"><code>linear_model.ElasticNetCV</code></a>(*[, l1_ratio, …])</p></td> <td><p>Elastic Net model with iterative fitting along a regularization path.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/sklearn.linear_model.larscv#sklearn.linear_model.LarsCV" title="sklearn.linear_model.LarsCV"><code>linear_model.LarsCV</code></a>(*[, fit_intercept, …])</p></td> <td><p>Cross-validated Least Angle Regression model.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/sklearn.linear_model.lassocv#sklearn.linear_model.LassoCV" title="sklearn.linear_model.LassoCV"><code>linear_model.LassoCV</code></a>(*[, eps, n_alphas, …])</p></td> <td><p>Lasso linear model with iterative fitting along a regularization path.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/sklearn.linear_model.lassolarscv#sklearn.linear_model.LassoLarsCV" title="sklearn.linear_model.LassoLarsCV"><code>linear_model.LassoLarsCV</code></a>(*[, fit_intercept, …])</p></td> <td><p>Cross-validated Lasso, using the LARS algorithm.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/sklearn.linear_model.logisticregressioncv#sklearn.linear_model.LogisticRegressionCV" title="sklearn.linear_model.LogisticRegressionCV"><code>linear_model.LogisticRegressionCV</code></a>(*[, Cs, …])</p></td> <td><p>Logistic Regression CV (aka logit, MaxEnt) classifier.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/sklearn.linear_model.multitaskelasticnetcv#sklearn.linear_model.MultiTaskElasticNetCV" title="sklearn.linear_model.MultiTaskElasticNetCV"><code>linear_model.MultiTaskElasticNetCV</code></a>(*[, …])</p></td> <td><p>Multi-task L1/L2 ElasticNet with built-in cross-validation.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/sklearn.linear_model.multitasklassocv#sklearn.linear_model.MultiTaskLassoCV" title="sklearn.linear_model.MultiTaskLassoCV"><code>linear_model.MultiTaskLassoCV</code></a>(*[, eps, …])</p></td> <td><p>Multi-task Lasso model trained with L1/L2 mixed-norm as regularizer.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/sklearn.linear_model.orthogonalmatchingpursuitcv#sklearn.linear_model.OrthogonalMatchingPursuitCV" title="sklearn.linear_model.OrthogonalMatchingPursuitCV"><code>linear_model.OrthogonalMatchingPursuitCV</code></a>(*)</p></td> <td><p>Cross-validated Orthogonal Matching Pursuit model (OMP).</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/sklearn.linear_model.ridgecv#sklearn.linear_model.RidgeCV" title="sklearn.linear_model.RidgeCV"><code>linear_model.RidgeCV</code></a>([alphas, …])</p></td> <td><p>Ridge regression with built-in cross-validation.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/sklearn.linear_model.ridgeclassifiercv#sklearn.linear_model.RidgeClassifierCV" title="sklearn.linear_model.RidgeClassifierCV"><code>linear_model.RidgeClassifierCV</code></a>([alphas, …])</p></td> <td><p>Ridge classifier with built-in cross-validation.</p></td> </tr>  </table>   <h3 id="information-criterion">
<span class="section-number">3.2.5.2. </span>Information Criterion</h3> <p>Some models can offer an information-theoretic closed-form formula of the optimal estimate of the regularization parameter by computing a single regularization path (instead of several when using cross-validation).</p> <p>Here is the list of models benefiting from the Akaike Information Criterion (AIC) or the Bayesian Information Criterion (BIC) for automated model selection:</p> <table class="longtable docutils align-default">   <tr>
<td><p><a class="reference internal" href="generated/sklearn.linear_model.lassolarsic#sklearn.linear_model.LassoLarsIC" title="sklearn.linear_model.LassoLarsIC"><code>linear_model.LassoLarsIC</code></a>([criterion, …])</p></td> <td><p>Lasso model fit with Lars using BIC or AIC for model selection</p></td> </tr>  </table>   <h3 id="out-of-bag">
<span class="section-number">3.2.5.3. </span>Out of Bag Estimates</h3> <p id="out-of-bag-estimates">When using ensemble methods base upon bagging, i.e. generating new training sets using sampling with replacement, part of the training set remains unused. For each classifier in the ensemble, a different part of the training set is left out.</p> <p>This left out portion can be used to estimate the generalization error without having to rely on a separate validation set. This estimate comes “for free” as no additional data is needed and can be used for model selection.</p> <p>This is currently implemented in the following classes:</p> <table class="longtable docutils align-default">   <tr>
<td><p><a class="reference internal" href="generated/sklearn.ensemble.randomforestclassifier#sklearn.ensemble.RandomForestClassifier" title="sklearn.ensemble.RandomForestClassifier"><code>ensemble.RandomForestClassifier</code></a>([…])</p></td> <td><p>A random forest classifier.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/sklearn.ensemble.randomforestregressor#sklearn.ensemble.RandomForestRegressor" title="sklearn.ensemble.RandomForestRegressor"><code>ensemble.RandomForestRegressor</code></a>([…])</p></td> <td><p>A random forest regressor.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/sklearn.ensemble.extratreesclassifier#sklearn.ensemble.ExtraTreesClassifier" title="sklearn.ensemble.ExtraTreesClassifier"><code>ensemble.ExtraTreesClassifier</code></a>([…])</p></td> <td><p>An extra-trees classifier.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/sklearn.ensemble.extratreesregressor#sklearn.ensemble.ExtraTreesRegressor" title="sklearn.ensemble.ExtraTreesRegressor"><code>ensemble.ExtraTreesRegressor</code></a>([n_estimators, …])</p></td> <td><p>An extra-trees regressor.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/sklearn.ensemble.gradientboostingclassifier#sklearn.ensemble.GradientBoostingClassifier" title="sklearn.ensemble.GradientBoostingClassifier"><code>ensemble.GradientBoostingClassifier</code></a>(*[, …])</p></td> <td><p>Gradient Boosting for classification.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="generated/sklearn.ensemble.gradientboostingregressor#sklearn.ensemble.GradientBoostingRegressor" title="sklearn.ensemble.GradientBoostingRegressor"><code>ensemble.GradientBoostingRegressor</code></a>(*[, …])</p></td> <td><p>Gradient Boosting for regression.</p></td> </tr>  </table><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2007&ndash;2020 The scikit-learn developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://scikit-learn.org/0.24/modules/grid_search.html" class="_attribution-link">https://scikit-learn.org/0.24/modules/grid_search.html</a>
  </p>
</div>
