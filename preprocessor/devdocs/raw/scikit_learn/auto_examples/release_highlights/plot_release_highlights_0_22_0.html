<h1 id="sphx-glr-auto-examples-release-highlights-plot-release-highlights-0-22-0-py">Release Highlights for scikit-learn 0.22</h1> <p>We are pleased to announce the release of scikit-learn 0.22, which comes with many bug fixes and new features! We detail below a few of the major features of this release. For an exhaustive list of all the changes, please refer to the <a class="reference internal" href="https://scikit-learn.org/0.24/whats_new/v0.22.html#changes-0-22"><span class="std std-ref">release notes</span></a>.</p> <p>To install the latest version (with pip):</p> <pre data-language="python">pip install --upgrade scikit-learn
</pre> <p>or with conda:</p> <pre data-language="python">conda install -c conda-forge scikit-learn
</pre>  <h2 id="new-plotting-api">New plotting API</h2> <p>A new plotting API is available for creating visualizations. This new API allows for quickly adjusting the visuals of a plot without involving any recomputation. It is also possible to add different plots to the same figure. The following example illustrates <a class="reference internal" href="../../modules/generated/sklearn.metrics.plot_roc_curve#sklearn.metrics.plot_roc_curve" title="sklearn.metrics.plot_roc_curve"><code>plot_roc_curve</code></a>, but other plots utilities are supported like <a class="reference internal" href="../../modules/generated/sklearn.inspection.plot_partial_dependence#sklearn.inspection.plot_partial_dependence" title="sklearn.inspection.plot_partial_dependence"><code>plot_partial_dependence</code></a>, <a class="reference internal" href="../../modules/generated/sklearn.metrics.plot_precision_recall_curve#sklearn.metrics.plot_precision_recall_curve" title="sklearn.metrics.plot_precision_recall_curve"><code>plot_precision_recall_curve</code></a>, and <a class="reference internal" href="../../modules/generated/sklearn.metrics.plot_confusion_matrix#sklearn.metrics.plot_confusion_matrix" title="sklearn.metrics.plot_confusion_matrix"><code>plot_confusion_matrix</code></a>. Read more about this new API in the <a class="reference internal" href="https://scikit-learn.org/0.24/visualizations.html#visualizations"><span class="std std-ref">User Guide</span></a>.</p> <pre data-language="python">from sklearn.model_selection import train_test_split
from sklearn.svm import SVC
from sklearn.metrics import plot_roc_curve
from sklearn.ensemble import RandomForestClassifier
from sklearn.datasets import make_classification
import matplotlib.pyplot as plt

X, y = make_classification(random_state=0)
X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42)

svc = SVC(random_state=42)
svc.fit(X_train, y_train)
rfc = RandomForestClassifier(random_state=42)
rfc.fit(X_train, y_train)

svc_disp = plot_roc_curve(svc, X_test, y_test)
rfc_disp = plot_roc_curve(rfc, X_test, y_test, ax=svc_disp.ax_)
rfc_disp.figure_.suptitle("ROC curve comparison")

plt.show()
</pre> <img alt="ROC curve comparison" class="sphx-glr-single-img" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAoAAAAHgCAMAAAACDyzWAAAACXBIWXMAAA9hAAAPYQGoP6dpAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjMuMiwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy8vihELAAAAolBMVEX////1+fv/+fQfd7T4+Pj18/DW1tbx8fEAAAD/fw4MDAwGBgbDw8Ovr68fHx/c3NwnJycvLy9fX19vb2/i4uKPj49AQEDn5+efn5/9/f1/f3/R0dFPT08SEhIZGRk2NjaGhoapqal4eHhpaWmWlpbs7OxISEjKysq3t7e9vb08PDybm5tbW1ujo6NkZGRVVVX29vb09PQod6zRgTb/nEZSlsUpNiopAAAdB0lEQVR42uzdi3aiSAKA4epeIxUKELwQEQXBG3iNs7vv/2pboDEmfZtNYsox/z/nMEqPNmf4UlBoVAgiIiIiIiIiIiIiIiL6x9aXumTXqu80pqmt/HxW34k24UiN5m5kbuPCkB10+wD7i3KskgrdPpSTohyPvKa+8ziX68xxt8o1t3HNJjvo9gEu9HIg+3q5lVm9221fj3qTepUQrfgPz/B4qSFyz975MgALORbiQc0P68Ya4unOqagXKDvV46EcVHe9dvXgoj2SmSyrFVOpqS6GIxVkp8c0Br4ahY5WmnsqmVjV4+ZuoHxX9H07rf7qtt0M7dGk0jZdjuxg3KiOvb6Tqt3hEDwNbNvP9Y24eu7qp6KUmzyxQ4bH2wE4lRrWRk6PRz45eb5zai23bjHuvQSYbIuskayrFWmgaahlVrSPY6c2G6q8cPNMRHM1KHp2oHF5SZAVqRosXddPHjVA5Y2LgRrq/7wzLcreqF0BHHnT0qkBZrJTlNNONTB7m2Jd/aSU0lsXmedH7L6bABjti2QZVQNfcTyoyvnznaccmR9vnQOstIiOsiq1WqwfVCiGyZHGRq4ON+oRVlvSdz3V1YOZTPSQ51bs27JXD7rOgWy0kfp0NDwMqhXAyej41+6qB4q5bWmA8/rZFuy+G5kFS98SfwKYy4efAHQPI6aGlauZaMlepJvK49FxraKnB1eTnMje6cel1aFZrsXRbLv+o1YlVB9jq41ZVCPgaRa8kTu3npYn9TlBprerrEfnpszYfbcAcLMoJ/WQ8vtD8FZGPwF4GITSVETJrholjznHyyje04NV/S8vrM4B6+eY1Op61SH4YL4junawcRbTavAL/efLMP1UylT/NMjtYSDeaIBZ/eg+u+9WzgHr+e/vJyHPI6Cqj8X2GUA95BXViNmU+aLO+s0I+BrgaQTsyeoYu3oNUE+H9Tlj98UICMAbAzgbVWf0v70M4xwGPp0/r2eiZwAtle/q8z7/pdqzc8De6RzwB4BP54C9iniU/giwOlsstOaH0zkgAG8MoAawqS5Eq/pCdHJ2IXpyuhB9mgWP5aDs+ecjoFgnh2GxVPON445357PgYnCYBZfHWfAPh+B6FqzXNlVYuHP/FcBtJ3OywJ5VPxenWTAAbw3gY31R4+VLcf36pbhN9Po6YCP3VBifnwPqEU4eXsyLd4lKwtPp4+PPrgO+AmjHoTpcB3QDleTFK4D9UD/jLq6vA9pP1wEBSB9V2+b/AQGQAEhERERERERERERERERERERERERERERERERERERERERERERERERERET0BYq6Fn2lulf2bWJdSV+r7nUBtCRD4JcaAKV1bQAtzkO+UBYAif0NQACyQcT+BiAA2SACIAGQDSIAEgABSLe2v51hIp++Y1yUgfKmAATgJ1bk7glgy+40VyoDIAA/tRPA3NeLSQrAPxV9u/bu/lR0jQCXHb1wVaO+07jGd0dcib///uvK+/f9n7q7RoD+uDoplA/1nUH9/jAA/qRv1+7vr/sbAMgI+DuA1nUfgO/vZ//4QzDngL8D+O2qN/D7/f13JiEABODfaB/Hshd3Rb7mMgwADezvsp5rtEU7FFyIBiAvxQEQgAAEIAABCEAAAhCAAAQgARCAAAQgARCAAAQgAAEIQAACEIAABCAAAQhAAAIQgAAEIAABCEAAAhCAAAQgAAEIQAACEIAABCAAAXhDAKO7r93sr7/uvl91tw0w+vOHf5HpbhngHbv36vuPuG2AD1/8IPz92hM3DvCOmcgtBkACIAABCEACIAABCEACIAABCEACIAABCEACIAABCEACIAHw/37+/jZMhwMHgGQA4MNWebtOPlnafgZA+nSAo058uPG4SXsApM8GODsfDQFITELoawKc9QFIBgHGEoBkAKB1zAEgmQAoTwGQDAC0x2Xp6H9WACQTAMMx54BkEODqePn5YQBAMjgLfu8GARCAACQAEgABSAAkAL6jqaeCp7eobgKVtGcABODnlalVs2N369uO7LUcfwhAAF6qsK0X7fBsTTrRCz+vb/e8apEAEICXql1Jy9vPKxrS1cvO8jACqiJ6WE4ACMBP60FW539j/3g8tpUcNo40LcvqAhCAnwiwmYzjItge/mRQv28GgAD8qHrP/eIQvN7VM5EHRkAAXiDvuV9MQobnADkHBOBn9HQZJl8L0VfTlpOmTEIAeLEazejVmuOF6PraTM9XyboLQABeqP1WypbojN+3QQAE4BvrpI7dEm4AQDIC0FsIDbBlA5CMAFStCmAMQDIDcNmrAE7mACQjAB17ojqhvQAgGQEo4rbvr2MBQDID8EM2CIAAfGtRNhhnEQDJDMDYs4PA9mIAkhGA6XAmxGyYApCMAFTNehxUACQjAIOyWpa8FEcGAFqWVfhZt5sFBQDp8wFKPqCSTAKsP5yyXjgAJCPngB+zQQAE4JvbN2MdAMkIwNmcc0AyCHC9XNjFxmcWTGYAJgthN4W7BCAZAWi3hOeIFq+EkBmAaSGG627uAZCMANz0RTySKgMgGQFY9biYCQCSMYDv3yAAAvAtdZ4DIH0+wPA5ABKHYAIgAAmABEAAEgAJgAAE4GXbLJOu6LkAJCMAp6Oxaok+1wHJDEDfrT+gcgRAMgJQdeuP6OX9gGRyBOzxyQhkBmA/yexsbPN+QDI0C155UiYrAUAyA1CI2cO7NwiAAHxjg9ZHbBAAAfjGAplOZwAkY4fgZu6p+WYPQDJ1DiicyYhvSiJzAONOwoVoMgSwNfZluLIASEYApjIYd5mEkCmAefMjNgiAADS6QQAE4Fvq7AW/mE7mAIaW4BfTiUMwfV2A7fr5920AkhGAsn4rzIwPKScTAC1LtizLmvUTAJIBgKdv6hqfr516Knj66qRG7ilvBUAAXiSnlG5Zls6Lt6RmatXs2MeXR4Zp2Vo4AATghepGP6xKJ3rh5/Xtwp5xCAbgpYojER97XtmQ1cckdA7fHDIJ88TvPAIQgBeaAv/4da0Psjrijv36zlzNF4V3vEjT0POVLgAB+JHH3+6xXwLUf78rD0PgoKYKQABetBeH4Hb1DTZN2WIEBOBl6hdC5Hba/cUkZKX2zyMg54AA/PD8UjhqNRyerXq6DJOvhdgnu6bjb5mEAPBCqRpa88WnYx0vRLert8g0Q5UwCwbgxRrFIuiLFr8VR2YAroOtPROuD0AyAtCaDPU0ZDAGIBkB+DEbBEAAvvlv6G23PQuAZAbgYpQMh8loAUAyAnDZjoSI2ksAkhGAqv7F9CafDUNmACZFtSx4Sz6ZAdhJsm43S/jFdDIDsNFRUqpOA4BkBKAQ+zjev3eDAAjAt+GbJKP17P0b9D/27oS5URwBw7B612VUkrkxmEvctvEZ//8/twhwYmeTzMRHNNP9vVWTw5NOq5OnkMEgABAAb6pkBzc9AiBSBNAoCFnxEACRGoDcO78BQKQAIJXP/5gJgEgRwGWSJFy+AUCkAKDzGgAiBQAfNSAABEAARP86gNXb/m+xB0D00wAjtqxXXmPqpZHFAIh+fAoOclsu98KOa0zBSM1zQC1emeG9AwJAALy58AEDAkAAxF4wAkAEgACIABAB4N/eB2lrjQQnAERKAHoWoyZxKwBESgAmuwkzSWsBIFICMJ3KE1JNrIyAVAKcYWUEpAbg8dABPPk4IRWpARhYFs9SKwBApAQgeVlU1faFACBSAnDWn4sQzgAQKQFI+8m3oQCI1ADsV4aZ4j4hSAXAJOmvDE6MJQAiBQAdhx4dxznkDQAiJVNwdHrEgAAQAJUOCAAB8NaKY2Z3ASBSAnDOKl75rARApASgtZcnI0Q4HxCpAcg9ectgMwVApASgsSJZTdYAiNQAPESk5n56AECkBGAYdjvC7hw3qkFqAI55AIjUAQwqXBOCVADUdqmYhxHP9gCIFACshGvRpd/eOyAABMCbMlpiUvf+AQEgAN4UD7r/YgBEigDK86H//0ZJtcHtt4tEZtQGQAB8EsDleKOkyzslFXw7ddn5wIxmLAEQAJ/Uh3dKyuSZCdb5/JhjFAEgAP5gE6p3b93N8NkiC18BTjRN8wAQAJ9bQOXzv9zqPzHFlLwCjOQtHQAQAJ9aeAkwzGpCsAUEQFVTsEaHWjwHBMAf62InJIy7Kis+ASAA/ljnwzDlbnzqh71gAHxe+43wyFy/fGg8EO34AAiAzwZYpzk3ycK/b0AACIA3ZunytbgY14QgNQC5h0XKkfIt4BwrIyA1ABeiYEXOCgBEavaCtwalYksAEKkBSEgT3D0gAATAG4vMRwwIAAHwxmya1Q0AImVT8LQ0+HKP27UiZc8ByaxKsUo+UgcwdgUORCNFAM3cov5WA0CkBGBG7dy7e0AACIA3Vk4fMSAABEClAwJAALwl90TcMQBEPw/Q14g/BoAIUzD68wA6/fc/OQCIlADEDauRQoCaRk1N05qFAECkACA9lwMgUgBw1lK9bdtZQAAQKXkO6IXYC0aqAMYhiccAEP08wG4X+PwkEADRzwPs5l9vDACRkueAjxkQAALgjS3WhJQswxYQqQFotWTGt1e3aQBA9HMAeb8Q5RSrYyE1ANOY2Ati4qo4pAbgzj6whugWACIlALUq6XZDohwAkRKAjxkQAALgzX/D/HCYawCI1ABcpSJJRLoCQKQE4MYJCQmdDQAiJQB5f2H6FGvDIDUAxVq+XeOUfKQGoCsKzysELkxHagBOXE4pdycAiJQAJOQUx6d7BwSAAHgbvkqku+b+AQEgAN5UyQ5uegRApAigURCy4iEAIjUAuXd+A4BIAUAqn/8xEwCRIoDLJEm4fAOASAFA5zUARAoAPmpAAAiAAIgAEAEgACIARAAIgOhfAXC/ER6Z65cP1Qa3Z8OHup+ybA2AAPis6jTnJllc3qim4Nupy4bX59x8ZZY8BkAAfFKWLl+Kiy/Xhskq+Xh58TURAALgk+KeBGheXJQ0oXI+dt+ukwuNevw/mqZ5AAiAj98Czu23RwIqn//l1usDeTouoh/1i/kCIAA+sIUoWJGz4nOAe9YSbAEB8FltDUrFlnw6BRd8/dcDAkAAvL3m3W1qrnZC9lwnAAiAP9n5MEy5k/7qIAg0AATAJ2WMXT42Hoh2fEL8fr/DAUAAfFJz2S7N7xsQAALgXdU4IxqpBIhFypFSgLkBgEgJQFsm6BYAkRKAkayeEgBEKgCGi+ARAwJAALyxb63LAYAA+Oh8HQCRQoCFUc/iLgBECgA6Gh0DQKQAIA28MQBESgA+ZkAACIC3AWwAEKkEmJ4DQKQC4HwxBoAIzwERAAIgAkD0pwB81IAAEAABEAEgAkAARACIABAALwpf0PcKAfCB/IIp+m5BCICPKpg22KR9s2YaAOCjNoDThqDv1kxDAHxML9MXeLr1pwaAAAiAAAiAAPjPAbjLnzDITAdAAOx3mQ8GF8vZZFwyMU8nZJLbPN0sJsMXxGn/E9hTuZIxWQzrijF5Rm+7TLnlfnJ9VxgJ7p+XQJlEBrfl2tv9jQdE94FuhQAIgF2brPVW+Zq4Ri/CcsnET+vY3NvjtdOHQ//OL9npGmBNndacHdyPv2/O9Pgoxh9eKdZmLW9AFVlBEMid9FCsARAA5b9vvClF3H8wozHJaU9vchq2ZGkvxeRatrgC6PGB3se/sFB0W9QJG2/5I+T7ZNcBfL1Bi7MDwN8YYPjry96mv5C541SbyVVjnYwQe3n53eLhJN7oSOrNFcD59dm9SzY2fGr2ipNxJdpULod3NLpvw4RxNOVDtQGAvzHAX//9sl9vX12kfFNKLHU3xZ5YJ4VfTao6lVpDQycNNy8BVterzHrm2PDprOd5GC3vLDNcc07IuohbXzSv3xcA/3iA5GUdZbSbXTW+JVumvQe4752tu30Tsiy/APiua4BNQqlVjTfoO4m5/I70BQAxBY8d5Hy425CNnDKvp+A1lVP0sV9QR4TnDSLVvzUFd4PywtIaP/bl/nTBCABiJ2RsLi/Ub6k+3DZv2AkJh52QRn7W8EIuKcZ0MqWr7sEVnb7fCXk3BV/vhPQ7NcZ4M6qJkLfDjTYACIAdLX8fm4XoD7VYab+NmmzkYZjifBjG7hDNRb/N3CXdls5uzbbfSNb00HpfHobZycMwu87dSjdnvtF94rbmKulvDu5HAAiAnbbSZsyK+j+R03x4bDgQPc7TtdwxroYdEh4QzbW45fY/lP5AdPnJla7yQPRGGva7abi1eLqTX3gUXCTy8LT33aVqAfB3noK//HbG7AmDLA8EAAHwb9U+42XbPABAAEQACIAACIAIAAEQAAEQAAEQAAEQAAEQAAEQAAFQZswfOTYn+fIvCnzGCP3kwPdm//if1cRYAaBagA6l1KiaGwAa5wuM/tpvuM0Yy+anrwA2J0JKywxIMPnw/4+XMY0vWA/n9g8XFBQdWzv65J8wqVKWnF931lyDZ6vhFXDRvzg99wFQMcBl4K3F8RaA0XiB0eWv++M/vuP5ytR9/SuAsqPzEaHh3bKHR6zhtMILgCUtZ+Y6+WSclWhj3x5PrDhaMzNiHtH8YrrKMsmeTwFQLUBJwk27rdTB4Na8f2Qu0qr7tQcJN/ZSkJcwdgzkb31rsCrMRX8N55lm3f05OTvSOmER0W1uRN3vOzK4cInf3xiyGGbVUOv/tvWGpUtTbpsEN/LzV8pvJ7epTj8Fe8c0TUw5llwMF480tJfSiomYXQFc0WEcH8PReNH9Q+hwCd5L/94ez0tc0cvTwgDwsQD/82XvAJqWkNfursw9635dDqumurw4ZGnPVhv+v/bOtTtVHQjDWWdxICeRm9xEBFSUi3f//587mQAWbeu+CK1t5/2w11bCJHUeZ5KYBI+E9qYobB+2FB1VneeOOoFlqQ2AOl+pHkQimmxNt2QTszSmZMFKt9iSdSLCJJlZ3doWuhnNREzyjJE72rclwdw6PwYaAHi2DpG6sxTRlp1ar0vUWb0kcUmc8RWADrsKu1azMLupspJPZ7On5CVjp357CVy79D8fQPEVttslR5X4Aq++PoD//HdX/3T7gIxT2uavTOTiMewQPh7rxc+quFRCqIBXU9gyksNlS0Qugws/e2QDC6uOuQAQlqZuIDbuE+JZyksKtma3gxBYZ+34EqluSbmEXwC4hf6ewksyTlq6PBkINRaRCFrxAmBuX/317crsptu3lxtR8mbxV+oH4Z7WbJ7S3YvdTwVwwbeqw+oGm8xRtxC1fw6Avhk5OaCwSmPGU+gVQlL2RWiDd2Ov8VE8IVOLNJc3kDOXws8avF+7kUIeZkAlp2fXSA56+CaA5s5gTCTDIrYckRK7JVsAMwpBjK5E69o75xKbFdBmb+8AeKMaQL9eUEvMDaXpTlpSZrb07Db5dADTTPZt5f9lDzdLf1gKlh2hBV9F5sFue4WvAGT72uv1Dc4lBb8ACB09PpfxJyQn3UlSpS50nYKtvFJVKKwtDkxE3E7JC4CptKJ1Bi01KKncHJW2gQu2Pv1BChY6BzJaA3/rDtifCaAiPzin3iMD32zxydd/kqJpmvsjBiEVD0gGwcbvAPhGCn4LwJcUrLevGsEtclhzNQhZw86nUTPZV9YP0IWSVyk41m7nDQsoGdFRFEVwfEPJA2lYux2E3KTgq0FInf2he6vMrGb8vtt9NoBBvRWs/iJA36bZ09qcpPMjAIQs4LFSnbIOgCK5FS+DEOi6vwmgGISY9SAEmCr5VFUXSzLZRuaSr0k+c9ckPPJ54TbTMGG8M6sU9nUuVPWQhG3JLoBnyx+ZleN2AAwTYd5J2zAR2qKEbkDygmkYtzr+ahrGF137sjRLW0TbcJZEQSAnHI39JwMYvg/g+xEw/Pff8FsBuOeuMmZxtuwCGOSvpmHeAPBlGkYGtXLDWbolOsw8CyoLm1Pxea3kRPRJ3lxZ3K4gzNmM+dGlZBdAEoxjbhy6KZgsj6Q9wsuLFVFCVDuVqWqxgYnod8A5ZTGXE9EGdDMMnmQapG4pUesoPj1vCn7KeaG+AfwyCuIh9tEd5+QrDkIQwE+QPsDuPGV++nwA22mY5e63p2EQwG+nJ5iIlnNOvzcRjQAigB8kBBABRAARQATwCwmflPQ3+lpPSnryCQt8Vtx3f1bck4dAfFrmd39a5tMjiCHtez8vGPVdhQCi0N8IIAKIDUKhv+sGuRrq58h9NgBdivpZerLD00P3nS+KO9hXEC1/pmU3/OFdBbT81S0jgGgZAUTLCOCgUqYKWkbLKBQKhUKhUCgUCvXNde8owf5M637M0nKQRsPBI/YglpWlwY3tEJb3Nk/Gfe1zGc2Sl1PQe3bh8Lp7lGB/pp15YS55NIBlQjQjt4doM5mllVmMBrA8op45smY9WS6X+gXAnl34Abp7ikd/pqWs6SCWj9OpPUSbS7Ye6IOWRwF6SX/GLwD27MLhdf8co/5Mg8K+csO15Uka9gbgleXMXyaWcxrA8oiXYbDJBgCwXxd+gN4/ya1f06B5PIRlM1FJbwBeWc55XpTGeIhPY8E4nSkDANivC4dXOByA4S2Ae1YN0OgwXZHeAAxvANRENKGn/i2ryTwq7QMC+JEpeMHLIRqt0cvJjH23eQw9NZWa/VveHXvG5Oum4A8bhOy5Pkijw0gos6Jz/23e8nNvEfDa8mwwAL/cIOT+UYL9md7zVRAE2gCWQVN7iDafk6M6sg4DWJ7wlTlK+8LkHEXUiwZx4Ufo3lGC/ZmWD7ii4yEa3SuAV5ZVnyd9jYKvLXsWT3Z9bdWoms92CBeiUCgUCoVCoVAoFAqFQqFQKBQKhfprTdiflW8fZvnoLx+VFT5Qx9UFevsL9/jNdc6pjt5+Bo3lj0bmrwCciELJ8fUqlPW58fj5vaXK8s6Z+gvI0/0jdfwBgJfdGroVovefAcA8EAp/CSALgsqy3/QZ1e/H1CAofEO5C+CInR6p4w8AvOzWCJMSvf8MANbe8WyWZOcajshnzC4EFRueOOcONHuqXh4cPTXERZkeDRG4DGCghNWicn3dqzt1Gl3qkD/UT4myTOQjpKWc40N1AICFH7NNAQCucm7A4hP3GMcz83UKbggd79D7TwRgZVZWVkNg7VRzEZGIeebIHl9jpPOV6tGKLFjpFlsJx5pOgjUwECZbIv95dad2FFi1dSieiHRnstuMTI83CdeeP1QHAFjtVfWQCDxpvFWnor6zdYjUnaXIP3FCXwG4MtD7T9EHZIwd5X8XcQ0Bm8iXO1h2N2oWf8L7bpooG3jzmBPPUi4DBOlQYMDxRYrj65s7RQWUtkGorYOYcu2n36yNZfuH6mhTcMhEMQrLTNOMbKGTp/BSAqhbrwDUKXYCnwFA3zTNgFR+wjg9Swim3J+LyGRxgSaj6gtGIi/HAKdnENdIDnp4A0choAJvX9/JTHVlAG3dOsgCwGe8Rp/I9Zp/XwdcCDJLvF6JonC74DSTNYh33knBZV8Lq1GPp2CXO4W6pVoNh+rlXCeWY4KUFiMTOlwtHOSkO0mqXMNBLO/EBEo3d8LVzW0dC6qaEn0pSKwP1AEX8rRUzdjrAJjKEtp7AC4Yev9pAFxwEWnmLRyQAWdk578xddKmR5BKCwmHDF8Sjqm9gOHs6zs1kRsvdewl5LR7vkHuPFQHXIAs7lKvk4Jj7e15wAbA6Qa9/zQARtQz90kN4Cmr3JGxJBHPIlPPrgEUAwQTBgiTbWQuRVcM4LCyeoAAHTu5sfGNOx07vNQxotVaDEIM3SzmzVSIlz5UB1ywc7XYcK87CPFHZuW4133AdreG6H9O0ftPNApOeL6vAVSOBk8yEWSKnDE5PO3O3TVTJHrK5CQKwKFb3GjGAWm9F/P1na4IYW0dJIthGgYmWWbN0TRrrj5SB1yIUm4tZLZup2GCccyNg3Y9Cm53a4gWueh9VKvl4fvXiHpiafOPnhOZB/ipo1AoFAqFQqFQKBQKhUKhUCgUCoVCPaH+BykPVkmHKUrHAAAAAElFTkSuQmCC">   <h2 id="stacking-classifier-and-regressor">Stacking Classifier and Regressor</h2> <p><a class="reference internal" href="../../modules/generated/sklearn.ensemble.stackingclassifier#sklearn.ensemble.StackingClassifier" title="sklearn.ensemble.StackingClassifier"><code>StackingClassifier</code></a> and <a class="reference internal" href="../../modules/generated/sklearn.ensemble.stackingregressor#sklearn.ensemble.StackingRegressor" title="sklearn.ensemble.StackingRegressor"><code>StackingRegressor</code></a> allow you to have a stack of estimators with a final classifier or a regressor. Stacked generalization consists in stacking the output of individual estimators and use a classifier to compute the final prediction. Stacking allows to use the strength of each individual estimator by using their output as input of a final estimator. Base estimators are fitted on the full <code>X</code> while the final estimator is trained using cross-validated predictions of the base estimators using <code>cross_val_predict</code>.</p> <p>Read more in the <a class="reference internal" href="../../modules/ensemble#stacking"><span class="std std-ref">User Guide</span></a>.</p> <pre data-language="python">from sklearn.datasets import load_iris
from sklearn.svm import LinearSVC
from sklearn.linear_model import LogisticRegression
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import make_pipeline
from sklearn.ensemble import StackingClassifier
from sklearn.model_selection import train_test_split

X, y = load_iris(return_X_y=True)
estimators = [
    ('rf', RandomForestClassifier(n_estimators=10, random_state=42)),
    ('svr', make_pipeline(StandardScaler(),
                          LinearSVC(random_state=42)))
]
clf = StackingClassifier(
    estimators=estimators, final_estimator=LogisticRegression()
)
X_train, X_test, y_train, y_test = train_test_split(
    X, y, stratify=y, random_state=42
)
clf.fit(X_train, y_train).score(X_test, y_test)
</pre> <p class="sphx-glr-script-out">Out:</p> <pre data-language="none">0.9473684210526315
</pre>   <h2 id="permutation-based-feature-importance">Permutation-based feature importance</h2> <p>The <a class="reference internal" href="../../modules/generated/sklearn.inspection.permutation_importance#sklearn.inspection.permutation_importance" title="sklearn.inspection.permutation_importance"><code>inspection.permutation_importance</code></a> can be used to get an estimate of the importance of each feature, for any fitted estimator:</p> <pre data-language="python">import numpy as np
import matplotlib.pyplot as plt
from sklearn.datasets import make_classification
from sklearn.ensemble import RandomForestClassifier
from sklearn.inspection import permutation_importance

X, y = make_classification(random_state=0, n_features=5, n_informative=3)
feature_names = np.array([f'x_{i}' for i in range(X.shape[1])])

rf = RandomForestClassifier(random_state=0).fit(X, y)
result = permutation_importance(rf, X, y, n_repeats=10, random_state=0,
                                n_jobs=-1)

fig, ax = plt.subplots()
sorted_idx = result.importances_mean.argsort()
ax.boxplot(result.importances[sorted_idx].T,
           vert=False, labels=feature_names[sorted_idx])
ax.set_title("Permutation Importance of each feature")
ax.set_ylabel("Features")
fig.tight_layout()
plt.show()
</pre> <img alt="Permutation Importance of each feature" class="sphx-glr-single-img" src="data:image/png;base64,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">   <h2 id="native-support-for-missing-values-for-gradient-boosting">Native support for missing values for gradient boosting</h2> <p>The <a class="reference internal" href="../../modules/generated/sklearn.ensemble.histgradientboostingclassifier#sklearn.ensemble.HistGradientBoostingClassifier" title="sklearn.ensemble.HistGradientBoostingClassifier"><code>ensemble.HistGradientBoostingClassifier</code></a> and <a class="reference internal" href="../../modules/generated/sklearn.ensemble.histgradientboostingregressor#sklearn.ensemble.HistGradientBoostingRegressor" title="sklearn.ensemble.HistGradientBoostingRegressor"><code>ensemble.HistGradientBoostingRegressor</code></a> now have native support for missing values (NaNs). This means that there is no need for imputing data when training or predicting.</p> <pre data-language="python">from sklearn.experimental import enable_hist_gradient_boosting  # noqa
from sklearn.ensemble import HistGradientBoostingClassifier

X = np.array([0, 1, 2, np.nan]).reshape(-1, 1)
y = [0, 0, 1, 1]

gbdt = HistGradientBoostingClassifier(min_samples_leaf=1).fit(X, y)
print(gbdt.predict(X))
</pre> <p class="sphx-glr-script-out">Out:</p> <pre data-language="none">[0 0 1 1]
</pre>   <h2 id="precomputed-sparse-nearest-neighbors-graph">Precomputed sparse nearest neighbors graph</h2> <p>Most estimators based on nearest neighbors graphs now accept precomputed sparse graphs as input, to reuse the same graph for multiple estimator fits. To use this feature in a pipeline, one can use the <code>memory</code> parameter, along with one of the two new transformers, <a class="reference internal" href="../../modules/generated/sklearn.neighbors.kneighborstransformer#sklearn.neighbors.KNeighborsTransformer" title="sklearn.neighbors.KNeighborsTransformer"><code>neighbors.KNeighborsTransformer</code></a> and <a class="reference internal" href="../../modules/generated/sklearn.neighbors.radiusneighborstransformer#sklearn.neighbors.RadiusNeighborsTransformer" title="sklearn.neighbors.RadiusNeighborsTransformer"><code>neighbors.RadiusNeighborsTransformer</code></a>. The precomputation can also be performed by custom estimators to use alternative implementations, such as approximate nearest neighbors methods. See more details in the <a class="reference internal" href="../../modules/neighbors#neighbors-transformer"><span class="std std-ref">User Guide</span></a>.</p> <pre data-language="python">from tempfile import TemporaryDirectory
from sklearn.neighbors import KNeighborsTransformer
from sklearn.manifold import Isomap
from sklearn.pipeline import make_pipeline

X, y = make_classification(random_state=0)

with TemporaryDirectory(prefix="sklearn_cache_") as tmpdir:
    estimator = make_pipeline(
        KNeighborsTransformer(n_neighbors=10, mode='distance'),
        Isomap(n_neighbors=10, metric='precomputed'),
        memory=tmpdir)
    estimator.fit(X)

    # We can decrease the number of neighbors and the graph will not be
    # recomputed.
    estimator.set_params(isomap__n_neighbors=5)
    estimator.fit(X)
</pre>   <h2 id="knn-based-imputation">KNN Based Imputation</h2> <p>We now support imputation for completing missing values using k-Nearest Neighbors.</p> <p>Each sample’s missing values are imputed using the mean value from <code>n_neighbors</code> nearest neighbors found in the training set. Two samples are close if the features that neither is missing are close. By default, a euclidean distance metric that supports missing values, <code>nan_euclidean_distances</code>, is used to find the nearest neighbors.</p> <p>Read more in the <a class="reference internal" href="../../modules/impute#knnimpute"><span class="std std-ref">User Guide</span></a>.</p> <pre data-language="python">from sklearn.impute import KNNImputer

X = [[1, 2, np.nan], [3, 4, 3], [np.nan, 6, 5], [8, 8, 7]]
imputer = KNNImputer(n_neighbors=2)
print(imputer.fit_transform(X))
</pre> <p class="sphx-glr-script-out">Out:</p> <pre data-language="none">[[1.  2.  4. ]
 [3.  4.  3. ]
 [5.5 6.  5. ]
 [8.  8.  7. ]]
</pre>   <h2 id="tree-pruning">Tree pruning</h2> <p>It is now possible to prune most tree-based estimators once the trees are built. The pruning is based on minimal cost-complexity. Read more in the <a class="reference internal" href="../../modules/tree#minimal-cost-complexity-pruning"><span class="std std-ref">User Guide</span></a> for details.</p> <pre data-language="python">X, y = make_classification(random_state=0)

rf = RandomForestClassifier(random_state=0, ccp_alpha=0).fit(X, y)
print("Average number of nodes without pruning {:.1f}".format(
    np.mean([e.tree_.node_count for e in rf.estimators_])))

rf = RandomForestClassifier(random_state=0, ccp_alpha=0.05).fit(X, y)
print("Average number of nodes with pruning {:.1f}".format(
    np.mean([e.tree_.node_count for e in rf.estimators_])))
</pre> <p class="sphx-glr-script-out">Out:</p> <pre data-language="none">Average number of nodes without pruning 22.3
Average number of nodes with pruning 6.4
</pre>   <h2 id="retrieve-dataframes-from-openml">Retrieve dataframes from OpenML</h2> <p><a class="reference internal" href="../../modules/generated/sklearn.datasets.fetch_openml#sklearn.datasets.fetch_openml" title="sklearn.datasets.fetch_openml"><code>datasets.fetch_openml</code></a> can now return pandas dataframe and thus properly handle datasets with heterogeneous data:</p> <pre data-language="python">from sklearn.datasets import fetch_openml

titanic = fetch_openml('titanic', version=1, as_frame=True)
print(titanic.data.head()[['pclass', 'embarked']])
</pre> <p class="sphx-glr-script-out">Out:</p> <pre data-language="none">   pclass embarked
0     1.0        S
1     1.0        S
2     1.0        S
3     1.0        S
4     1.0        S
</pre>   <h2 id="checking-scikit-learn-compatibility-of-an-estimator">Checking scikit-learn compatibility of an estimator</h2> <p>Developers can check the compatibility of their scikit-learn compatible estimators using <a class="reference internal" href="../../modules/generated/sklearn.utils.estimator_checks.check_estimator#sklearn.utils.estimator_checks.check_estimator" title="sklearn.utils.estimator_checks.check_estimator"><code>check_estimator</code></a>. For instance, the <code>check_estimator(LinearSVC())</code> passes.</p> <p>We now provide a <code>pytest</code> specific decorator which allows <code>pytest</code> to run all checks independently and report the checks that are failing.</p> <dl class="simple"> <dt>..note::</dt>
<dd>
<p>This entry was slightly updated in version 0.24, where passing classes isn’t supported anymore: pass instances instead.</p> </dd> </dl> <pre data-language="python">from sklearn.linear_model import LogisticRegression
from sklearn.tree import DecisionTreeRegressor
from sklearn.utils.estimator_checks import parametrize_with_checks


@parametrize_with_checks([LogisticRegression(), DecisionTreeRegressor()])
def test_sklearn_compatible_estimator(estimator, check):
    check(estimator)
</pre>   <h2 id="roc-auc-now-supports-multiclass-classification">ROC AUC now supports multiclass classification</h2> <p>The <code>roc_auc_score</code> function can also be used in multi-class classification. Two averaging strategies are currently supported: the one-vs-one algorithm computes the average of the pairwise ROC AUC scores, and the one-vs-rest algorithm computes the average of the ROC AUC scores for each class against all other classes. In both cases, the multiclass ROC AUC scores are computed from the probability estimates that a sample belongs to a particular class according to the model. The OvO and OvR algorithms support weighting uniformly (<code>average='macro'</code>) and weighting by the prevalence (<code>average='weighted'</code>).</p> <p>Read more in the <a class="reference internal" href="../../modules/model_evaluation#roc-metrics"><span class="std std-ref">User Guide</span></a>.</p> <pre data-language="python">from sklearn.datasets import make_classification
from sklearn.svm import SVC
from sklearn.metrics import roc_auc_score

X, y = make_classification(n_classes=4, n_informative=16)
clf = SVC(decision_function_shape='ovo', probability=True).fit(X, y)
print(roc_auc_score(y, clf.predict_proba(X), multi_class='ovo'))
</pre> <p class="sphx-glr-script-out">Out:</p> <pre data-language="none">0.9843750000000001
</pre> <p class="sphx-glr-timing"><strong>Total running time of the script:</strong> ( 0 minutes 3.716 seconds)</p> <div class="sphx-glr-footer class sphx-glr-footer-example docutils container" id="sphx-glr-download-auto-examples-release-highlights-plot-release-highlights-0-22-0-py"> <div class="binder-badge docutils container"> <a class="reference external image-reference" href="https://mybinder.org/v2/gh/scikit-learn/scikit-learn/0.24.X?urlpath=lab/tree/notebooks/auto_examples/release_highlights/plot_release_highlights_0_22_0.ipynb"><img alt="Launch binder" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAG0AAAAUCAMAAACwC0NtAAABWVBMVEW7u7vo6OjCwsLMzMzz8/P4+Pju7u68vLzd3d24uLjx8fHm5ubT09PAwMDJycnPz8+urq7Ly8va2tq5ubnq6uqSkpLBwcH09PS6urrypVmvr6/i4uLDw8O0tLSjo6PX19e9u7pYm8qxsbGrq6u+vr7s7OzZ2dng4OCVlZXk5OTIyMiWlpampqaoqKj6+vrGxsagoKC9vb2ZmZn29vb///+Nq8Kzs7PSspNlnshfnsr2o1HnZYHXc46dnZ2Li4vS0tKPj4+3t7fOtJm2urztpmKGqsTarYFcmsnTjZzkaYXOl6Kqtr7lqnHEqrD1olLMmqW+t7jWsIzGt6hrnsbQk6Gis7/IoavgbIfhcoprlcHYaom+oH2Elq50kLzV1dWHh4fDuK2Xr8GZsMDHtqatsLrglH/sfm60pLHKqqDWnJHJcJDtgWzoknG8dJaLqr/0lVqeo7jlbX7owswW4TTQAAACXklEQVRIx+3V52/iMBgH4DcsBwfCCCkhQICMS4G0AQKUXqFpumh7Pa57l9t7//9fzlRHWeXbCemkvpEs+ZWtR/rZVqAKj/WvK7u+v7m/np2RdpjokG9pNthRIrF0dJjYfDWLGM/ed76dAWx31v923NS0tWXvRCtD90bTN9Sy1Ona3u6Hp1939+Cw04/SRU9bizwTLTbUG9OtoRZGU7Hn5xefEz9/Nz9tJt4ONDOGky7Q52AuCbStYRvKOmZcyENjKjWqPYnFdZSiQbd9vhCkyMyDUBQzBbC7WmhMe7Gyk92+vrm9ud7ODjRKLQZoiKmgakBTRcULdKboZlDVXMtERzWvMU915xhgknwag2auRaook2/JlhqKi+EJ7QR+5NqX7XYNBtq8wtIZYFQoUxAtc2ELsORIYbS4AGpgLEnZqetqHpKOIGLVKwnSIqIKrKkVIm6FG09y9+Jj4/Z789fy8rOBlsddd7enBYlGDt0Cyw+CiDwcmGOaDRC808ix+lRysIKFtG4g4IKIe/JK7qycf7kicW7l3txrQS9fYomWAptoqZ6mu8HEvVsyrmkIomxPCxLNwQVgSZKpkkT7I6HJa3Jw0rxq7h3AVu71veaPMfkkNlmc1PuaEs/HOYSJZo9qOo5pRl8D0aI0DRkeBnedhzSAd5fHpxunjfskw0Xg5YV5w9+qiBUeigrASxD5esXgVgGM1shmg68srDkyT7aAfxUUXuFXuTovSxWQSg++gq3c8nE7VxvqcOE6iA6kRRD6LSecfvgNObIwPBOFu/3y1De3UWvkGrWNx9/T/1B/AFudUABdgF9sAAAAAElFTkSuQmCC" style="width: 150px;"></a> </div> <div class="sphx-glr-download sphx-glr-download-python docutils container"> <p><a class="reference download internal" download="" href="https://scikit-learn.org/0.24/_downloads/50040ae12dd16e7d2e79135d7793c17e/plot_release_highlights_0_22_0.py"><code>Download Python source code: plot_release_highlights_0_22_0.py</code></a></p> </div> <div class="sphx-glr-download sphx-glr-download-jupyter docutils container"> <p><a class="reference download internal" download="" href="https://scikit-learn.org/0.24/_downloads/df790541d4c6bdebcc75018a2459467a/plot_release_highlights_0_22_0.ipynb"><code>Download Jupyter notebook: plot_release_highlights_0_22_0.ipynb</code></a></p> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2007&ndash;2020 The scikit-learn developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://scikit-learn.org/0.24/auto_examples/release_highlights/plot_release_highlights_0_22_0.html" class="_attribution-link">https://scikit-learn.org/0.24/auto_examples/release_highlights/plot_release_highlights_0_22_0.html</a>
  </p>
</div>
