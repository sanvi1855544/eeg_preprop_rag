[{"name": "abort()", "path": "api/index#flask.abort", "type": "flask", "text": ["Raises an HTTPException for the given status code or WSGI application.", "If a status code is given, it will be looked up in the list of exceptions and will raise that exception. If passed a WSGI application, it will wrap it in a proxy WSGI exception and raise that:", "NoReturn"]}, {"name": "Adding a favicon", "path": "patterns/favicon/index", "type": "User's Guide: Design Patterns", "text": ["A \u201cfavicon\u201d is an icon used by browsers for tabs and bookmarks. This helps to distinguish your website and to give it a unique brand.", "A common question is how to add a favicon to a Flask application. First, of course, you need an icon. It should be 16 \u00d7 16 pixels and in the ICO file format. This is not a requirement but a de-facto standard supported by all relevant browsers. Put the icon in your static directory as favicon.ico.", "Now, to get browsers to find your icon, the correct way is to add a link tag in your HTML. So, for example:", "That\u2019s all you need for most browsers, however some really old ones do not support this standard. The old de-facto standard is to serve this file, with this name, at the website root. If your application is not mounted at the root path of the domain you either need to configure the web server to serve the icon at the root or if you can\u2019t do that you\u2019re out of luck. If however your application is the root you can simply route a redirect:", "If you want to save the extra redirect request you can also write a view using send_from_directory():", "We can leave out the explicit mimetype and it will be guessed, but we may as well specify it to avoid the extra guessing, as it will always be the same.", "The above will serve the icon via your application and if possible it\u2019s better to configure your dedicated web server to serve it; refer to the web server\u2019s documentation."]}, {"name": "Adding HTTP Method Overrides", "path": "patterns/methodoverrides/index", "type": "User's Guide: Design Patterns", "text": ["Some HTTP proxies do not support arbitrary HTTP methods or newer HTTP methods (such as PATCH). In that case it\u2019s possible to \u201cproxy\u201d HTTP methods through another HTTP method in total violation of the protocol.", "The way this works is by letting the client do an HTTP POST request and set the X-HTTP-Method-Override header. Then the method is replaced with the header value before being passed to Flask.", "This can be accomplished with an HTTP middleware:", "To use this with Flask, wrap the app object with the middleware:"]}, {"name": "after_this_request()", "path": "api/index#flask.after_this_request", "type": "flask", "text": ["Executes a function after this request. This is useful to modify response objects. The function is passed the response object and has to return the same or a new one.", "Example:", "This is more useful if a function other than the view function wants to modify a response. For instance think of a decorator that wants to add some headers without converting the return value into a response object.", "New in version 0.9.", "f (Callable[[Response], Response]) \u2013 ", "Callable[[Response], Response]"]}, {"name": "AJAX with jQuery", "path": "patterns/jquery/index", "type": "User's Guide: Design Patterns", "text": ["jQuery is a small JavaScript library commonly used to simplify working with the DOM and JavaScript in general. It is the perfect tool to make web applications more dynamic by exchanging JSON between server and client.", "JSON itself is a very lightweight transport format, very similar to how Python primitives (numbers, strings, dicts and lists) look like which is widely supported and very easy to parse. It became popular a few years ago and quickly replaced XML as transport format in web applications.", "In order to use jQuery, you have to download it first and place it in the static folder of your application and then ensure it\u2019s loaded. Ideally you have a layout template that is used for all pages where you just have to add a script statement to the bottom of your <body> to load jQuery:", "Another method is using Google\u2019s AJAX Libraries API to load jQuery:", "In this case you have to put jQuery into your static folder as a fallback, but it will first try to load it directly from Google. This has the advantage that your website will probably load faster for users if they went to at least one other website before using the same jQuery version from Google because it will already be in the browser cache.", "Do you know where your application is? If you are developing the answer is quite simple: it\u2019s on localhost port something and directly on the root of that server. But what if you later decide to move your application to a different location? For example to http://example.com/myapp? On the server side this never was a problem because we were using the handy url_for() function that could answer that question for us, but if we are using jQuery we should not hardcode the path to the application but make that dynamic, so how can we do that?", "A simple method would be to add a script tag to our page that sets a global variable to the prefix to the root of the application. Something like this:", "Now let\u2019s create a server side function that accepts two URL arguments of numbers which should be added together and then sent back to the application in a JSON object. This is a really ridiculous example and is something you usually would do on the client side alone, but a simple example that shows how you would use jQuery and Flask nonetheless:", "As you can see I also added an index method here that renders a template. This template will load jQuery as above and have a little form where we can add two numbers and a link to trigger the function on the server side.", "Note that we are using the get() method here which will never fail. If the key is missing a default value (here 0) is returned. Furthermore it can convert values to a specific type (like in our case int). This is especially handy for code that is triggered by a script (APIs, JavaScript etc.) because you don\u2019t need special error reporting in that case.", "Your index.html template either has to extend a layout.html template with jQuery loaded and the $SCRIPT_ROOT variable set, or do that on the top. Here\u2019s the HTML code needed for our little application (index.html). Notice that we also drop the script directly into the HTML here. It is usually a better idea to have that in a separate script file:", "I won\u2019t go into detail here about how jQuery works, just a very quick explanation of the little bit of code above:", "Check out the example source for a full application demonstrating the code on this page, as well as the same thing using XMLHttpRequest and fetch."]}, {"name": "AppContext", "path": "api/index#flask.ctx.AppContext", "type": "flask.ctx", "text": ["The application context binds an application object implicitly to the current thread or greenlet, similar to how the RequestContext binds request information. The application context is also implicitly created if a request context is created but the application is not on top of the individual application context.", "app (Flask) \u2013 ", "None", "Pops the app context.", "exc (Optional[BaseException]) \u2013 ", "None", "Binds the app context to the current context.", "None"]}, {"name": "AppContext.pop()", "path": "api/index#flask.ctx.AppContext.pop", "type": "flask.ctx", "text": ["Pops the app context.", "exc (Optional[BaseException]) \u2013 ", "None"]}, {"name": "AppContext.push()", "path": "api/index#flask.ctx.AppContext.push", "type": "flask.ctx", "text": ["Binds the app context to the current context.", "None"]}, {"name": "AppGroup", "path": "api/index#flask.cli.AppGroup", "type": "flask.cli", "text": ["This works similar to a regular click Group but it changes the behavior of the command() decorator so that it automatically wraps the functions in with_appcontext().", "Not to be confused with FlaskGroup.", "None", "This works exactly like the method of the same name on a regular click.Group but it wraps callbacks in with_appcontext() unless it\u2019s disabled by passing with_appcontext=False.", "This works exactly like the method of the same name on a regular click.Group but it defaults the group class to AppGroup."]}, {"name": "AppGroup.command()", "path": "api/index#flask.cli.AppGroup.command", "type": "flask.cli", "text": ["This works exactly like the method of the same name on a regular click.Group but it wraps callbacks in with_appcontext() unless it\u2019s disabled by passing with_appcontext=False."]}, {"name": "AppGroup.group()", "path": "api/index#flask.cli.AppGroup.group", "type": "flask.cli", "text": ["This works exactly like the method of the same name on a regular click.Group but it defaults the group class to AppGroup."]}, {"name": "Application Dispatching", "path": "patterns/appdispatch/index", "type": "User's Guide: Design Patterns", "text": ["Application dispatching is the process of combining multiple Flask applications on the WSGI level. You can combine not only Flask applications but any WSGI application. This would allow you to run a Django and a Flask application in the same interpreter side by side if you want. The usefulness of this depends on how the applications work internally.", "The fundamental difference from Large Applications as Packages is that in this case you are running the same or different Flask applications that are entirely isolated from each other. They run different configurations and are dispatched on the WSGI level.", "Each of the techniques and examples below results in an application object that can be run with any WSGI server. For production, see Deployment Options. For development, Werkzeug provides a server through werkzeug.serving.run_simple():", "Note that run_simple is not intended for use in production. Use a production WSGI server. See Deployment Options.", "In order to use the interactive debugger, debugging must be enabled both on the application and the simple server. Here is the \u201chello world\u201d example with debugging and run_simple:", "If you have entirely separated applications and you want them to work next to each other in the same Python interpreter process you can take advantage of the werkzeug.wsgi.DispatcherMiddleware. The idea here is that each Flask application is a valid WSGI application and they are combined by the dispatcher middleware into a larger one that is dispatched based on prefix.", "For example you could have your main application run on / and your backend interface on /backend:", "Sometimes you might want to use multiple instances of the same application with different configurations. Assuming the application is created inside a function and you can call that function to instantiate it, that is really easy to implement. In order to develop your application to support creating new instances in functions have a look at the Application Factories pattern.", "A very common example would be creating applications per subdomain. For instance you configure your webserver to dispatch all requests for all subdomains to your application and you then use the subdomain information to create user-specific instances. Once you have your server set up to listen on all subdomains you can use a very simple WSGI application to do the dynamic application creation.", "The perfect level for abstraction in that regard is the WSGI layer. You write your own WSGI application that looks at the request that comes and delegates it to your Flask application. If that application does not exist yet, it is dynamically created and remembered:", "This dispatcher can then be used like this:", "Dispatching by a path on the URL is very similar. Instead of looking at the Host header to figure out the subdomain one simply looks at the request path up to the first slash:", "The big difference between this and the subdomain one is that this one falls back to another application if the creator function returns None:"]}, {"name": "Application Factories", "path": "patterns/appfactories/index", "type": "User's Guide: Design Patterns", "text": ["If you are already using packages and blueprints for your application (Modular Applications with Blueprints) there are a couple of really nice ways to further improve the experience. A common pattern is creating the application object when the blueprint is imported. But if you move the creation of this object into a function, you can then create multiple instances of this app later.", "So why would you want to do this?", "So how would you then actually implement that?", "The idea is to set up the application in a function. Like this:", "The downside is that you cannot use the application object in the blueprints at import time. You can however use it from within a request. How do you get access to the application with the config? Use current_app:", "Here we look up the name of a template in the config.", "It\u2019s preferable to create your extensions and app factories so that the extension object does not initially get bound to the application.", "Using Flask-SQLAlchemy, as an example, you should not do something along those lines:", "But, rather, in model.py (or equivalent):", "and in your application.py (or equivalent):", "Using this design pattern, no application-specific state is stored on the extension object, so one extension object can be used for multiple apps. For more information about the design of extensions refer to Flask Extension Development.", "To run such an application, you can use the flask command:", "Flask will automatically detect the factory (create_app or make_app) in myapp. You can also pass arguments to the factory like this:", "Then the create_app factory in myapp is called with the string 'dev' as the argument. See Command Line Interface for more detail.", "The factory function above is not very clever, but you can improve it. The following changes are straightforward to implement:"]}, {"name": "APPLICATION_ROOT", "path": "config/index#APPLICATION_ROOT", "type": "Configuration", "text": ["Inform the application what path it is mounted under by the application / web server. This is used for generating URLs outside the context of a request (inside a request, the dispatcher is responsible for setting SCRIPT_NAME instead; see Application Dispatching for examples of dispatch configuration).", "Will be used for the session cookie path if SESSION_COOKIE_PATH is not set.", "Default: '/'"]}, {"name": "ASGI", "path": "deploying/asgi/index", "type": "User's Guide: Deploying", "text": ["If you\u2019d like to use an ASGI server you will need to utilise WSGI to ASGI middleware. The asgiref [WsgiToAsgi](https://github.com/django/asgiref#wsgi-to-asgi-adapter) adapter is recommended as it integrates with the event loop used for Flask\u2019s Using async and await support. You can use the adapter by wrapping the Flask app,", "and then serving the asgi_app with the asgi server, e.g. using Hypercorn,"]}, {"name": "Becoming Big", "path": "becomingbig/index", "type": "User\u2019s Guide", "text": ["Here are your options when growing your codebase or scaling your application.", "Flask started in part to demonstrate how to build your own framework on top of existing well-used tools Werkzeug (WSGI) and Jinja (templating), and as it developed, it became useful to a wide audience. As you grow your codebase, don\u2019t just use Flask \u2013 understand it. Read the source. Flask\u2019s code is written to be read; its documentation is published so you can use its internal APIs. Flask sticks to documented APIs in upstream libraries, and documents its internal utilities so that you can find the hook points needed for your project.", "The API docs are full of available overrides, hook points, and Signals. You can provide custom classes for things like the request and response objects. Dig deeper on the APIs you use, and look for the customizations which are available out of the box in a Flask release. Look for ways in which your project can be refactored into a collection of utilities and Flask extensions. Explore the many Extensions in the community, and look for patterns to build your own extensions if you do not find the tools you need.", "The Flask class has many methods designed for subclassing. You can quickly add or customize behavior by subclassing Flask (see the linked method docs) and using that subclass wherever you instantiate an application class. This works well with Application Factories. See Subclassing Flask for an example.", "The Application Dispatching pattern shows in detail how to apply middleware. You can introduce WSGI middleware to wrap your Flask instances and introduce fixes and changes at the layer between your Flask application and your HTTP server. Werkzeug includes several middlewares.", "If none of the above options work, fork Flask. The majority of code of Flask is within Werkzeug and Jinja2. These libraries do the majority of the work. Flask is just the paste that glues those together. For every project there is the point where the underlying framework gets in the way (due to assumptions the original developers had). This is natural because if this would not be the case, the framework would be a very complex system to begin with which causes a steep learning curve and a lot of user frustration.", "This is not unique to Flask. Many people use patched and modified versions of their framework to counter shortcomings. This idea is also reflected in the license of Flask. You don\u2019t have to contribute any changes back if you decide to modify the framework.", "The downside of forking is of course that Flask extensions will most likely break because the new framework has a different import name. Furthermore integrating upstream changes can be a complex process, depending on the number of changes. Because of that, forking should be the very last resort.", "For many web applications the complexity of the code is less an issue than the scaling for the number of users or data entries expected. Flask by itself is only limited in terms of scaling by your application code, the data store you want to use and the Python implementation and webserver you are running on.", "Scaling well means for example that if you double the amount of servers you get about twice the performance. Scaling bad means that if you add a new server the application won\u2019t perform any better or would not even support a second server.", "There is only one limiting factor regarding scaling in Flask which are the context local proxies. They depend on context which in Flask is defined as being either a thread, process or greenlet. If your server uses some kind of concurrency that is not based on threads or greenlets, Flask will no longer be able to support these global proxies. However the majority of servers are using either threads, greenlets or separate processes to achieve concurrency which are all methods well supported by the underlying Werkzeug library.", "The Flask developers keep the framework accessible to users with codebases big and small. If you find an obstacle in your way, caused by Flask, don\u2019t hesitate to contact the developers on the mailing list or Discord server. The best way for the Flask and Flask extension developers to improve the tools for larger applications is getting feedback from users."]}, {"name": "Blueprint", "path": "api/index#flask.Blueprint", "type": "flask", "text": ["Represents a blueprint, a collection of routes and other app-related functions that can be registered on a real application later.", "A blueprint is an object that allows defining application functions without requiring an application object ahead of time. It uses the same decorators as Flask, but defers the need for an application by recording them for later registration.", "Decorating a function with a blueprint creates a deferred function that is called with BlueprintSetupState when the blueprint is registered on an application.", "See Modular Applications with Blueprints for more information.", "Changed in version 1.1.0: Blueprints have a cli group to register nested CLI commands. The cli_group parameter controls the name of the group under the flask command.", "New in version 0.7.", "Register a custom template filter, available application wide. Like Flask.add_template_filter() but for a blueprint. Works exactly like the app_template_filter() decorator.", "None", "Register a custom template global, available application wide. Like Flask.add_template_global() but for a blueprint. Works exactly like the app_template_global() decorator.", "New in version 0.10.", "None", "Register a custom template test, available application wide. Like Flask.add_template_test() but for a blueprint. Works exactly like the app_template_test() decorator.", "New in version 0.10.", "None", "Like Flask.add_url_rule() but for a blueprint. The endpoint for the url_for() function is prefixed with the name of the blueprint.", "None", "Like Flask.after_request() but for a blueprint. Such a function is executed after each request, even if outside of the blueprint.", "f (Callable[[Response], Response]) \u2013 ", "Callable[[Response], Response]", "Register a function to run after each request to this object.", "The function is called with the response object, and must return a response object. This allows the functions to modify or replace the response before it is sent.", "If a function raises an exception, any remaining after_request functions will not be called. Therefore, this should not be used for actions that must execute, such as to close resources. Use teardown_request() for that.", "f (Callable[[Response], Response]) \u2013 ", "Callable[[Response], Response]", "A data structure of functions to call at the end of each request, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests.", "To register a function, use the after_request() decorator.", "This data structure is internal. It should not be modified directly and its format may change at any time.", "Like Flask.context_processor() but for a blueprint. Such a function is executed each request, even if outside of the blueprint.", "f (Callable[[], Dict[str, Any]]) \u2013 ", "Callable[[], Dict[str, Any]]", "Like Flask.errorhandler() but for a blueprint. This handler is used for all requests, even if outside of the blueprint.", "code (Union[Type[Exception], int]) \u2013 ", "Callable", "Register a custom template filter, available application wide. Like Flask.template_filter() but for a blueprint.", "name (Optional[str]) \u2013 the optional name of the filter, otherwise the function name will be used.", "Callable", "Register a custom template global, available application wide. Like Flask.template_global() but for a blueprint.", "New in version 0.10.", "name (Optional[str]) \u2013 the optional name of the global, otherwise the function name will be used.", "Callable", "Register a custom template test, available application wide. Like Flask.template_test() but for a blueprint.", "New in version 0.10.", "name (Optional[str]) \u2013 the optional name of the test, otherwise the function name will be used.", "Callable", "Same as url_defaults() but application wide.", "f (Callable[[str, dict], None]) \u2013 ", "Callable[[str, dict], None]", "Same as url_value_preprocessor() but application wide.", "f (Callable[[Optional[str], Optional[dict]], None]) \u2013 ", "Callable[[Optional[str], Optional[dict]], None]", "Like Flask.before_first_request(). Such a function is executed before the first request to the application.", "f (Callable[[], None]) \u2013 ", "Callable[[], None]", "Like Flask.before_request(). Such a function is executed before each request, even if outside of a blueprint.", "f (Callable[[], None]) \u2013 ", "Callable[[], None]", "Register a function to run before each request.", "For example, this can be used to open a database connection, or to load the logged in user from the session.", "The function will be called without any arguments. If it returns a non-None value, the value is handled as if it was the return value from the view, and further request handling is stopped.", "f (Callable[[], None]) \u2013 ", "Callable[[], None]", "A data structure of functions to call at the beginning of each request, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests.", "To register a function, use the before_request() decorator.", "This data structure is internal. It should not be modified directly and its format may change at any time.", "The Click command group for registering CLI commands for this object. The commands are available from the flask command once the application has been discovered and blueprints have been registered.", "Registers a template context processor function.", "f (Callable[[], Dict[str, Any]]) \u2013 ", "Callable[[], Dict[str, Any]]", "Shortcut for route() with methods=[\"DELETE\"].", "New in version 2.0.", "Callable", "Decorate a view function to register it for the given endpoint. Used if a rule is added without a view_func with add_url_rule().", "endpoint (str) \u2013 The endpoint name to associate with the view function.", "Callable", "A data structure of registered error handlers, in the format {scope: {code: {class: handler}}}`. The scope key is the name of a blueprint the handlers are active for, or None for all requests. The code key is the HTTP status code for HTTPException, or None for other exceptions. The innermost dictionary maps exception classes to handler functions.", "To register an error handler, use the errorhandler() decorator.", "This data structure is internal. It should not be modified directly and its format may change at any time.", "Register a function to handle errors by code or exception class.", "A decorator that is used to register a function given an error code. Example:", "You can also register handlers for arbitrary exceptions:", "New in version 0.7: Use register_error_handler() instead of modifying error_handler_spec directly, for application wide error handlers.", "New in version 0.7: One can now additionally also register custom exception types that do not necessarily have to be a subclass of the HTTPException class.", "code_or_exception (Union[Type[Exception], int]) \u2013 the code as integer for the handler, or an arbitrary exception", "Callable", "Shortcut for route() with methods=[\"GET\"].", "New in version 2.0.", "Callable", "Used by send_file() to determine the max_age cache value for a given file path if it wasn\u2019t passed.", "By default, this returns SEND_FILE_MAX_AGE_DEFAULT from the configuration of current_app. This defaults to None, which tells the browser to use conditional requests instead of a timed cache, which is usually preferable.", "Changed in version 2.0: The default configuration is None instead of 12 hours.", "New in version 0.9.", "filename (str) \u2013 ", "Optional[int]", "True if static_folder is set.", "New in version 0.5.", "The name of the package or module that this object belongs to. Do not change this once it is set by the constructor.", "The Jinja loader for this object\u2019s templates. By default this is a class jinja2.loaders.FileSystemLoader to template_folder if it is set.", "New in version 0.5.", "Blueprint local JSON decoder class to use. Set to None to use the app\u2019s json_decoder.", "Blueprint local JSON encoder class to use. Set to None to use the app\u2019s json_encoder.", "Creates an instance of BlueprintSetupState() object that is later passed to the register callback functions. Subclasses can override this to return a subclass of the setup state.", "flask.blueprints.BlueprintSetupState", "Open a resource file relative to root_path for reading.", "For example, if the file schema.sql is next to the file app.py where the Flask app is defined, it can be opened with:", "IO", "Shortcut for route() with methods=[\"PATCH\"].", "New in version 2.0.", "Callable", "Shortcut for route() with methods=[\"POST\"].", "New in version 2.0.", "Callable", "Shortcut for route() with methods=[\"PUT\"].", "New in version 2.0.", "Callable", "Registers a function that is called when the blueprint is registered on the application. This function is called with the state as argument as returned by the make_setup_state() method.", "func (Callable) \u2013 ", "None", "Works like record() but wraps the function in another function that will ensure the function is only called once. If the blueprint is registered a second time on the application, the function passed is not called.", "func (Callable) \u2013 ", "None", "Called by Flask.register_blueprint() to register all views and callbacks registered on the blueprint with the application. Creates a BlueprintSetupState and calls each record() callbackwith it.", "None", "Register a Blueprint on this blueprint. Keyword arguments passed to this method will override the defaults set on the blueprint.", "New in version 2.0.", "None", "Alternative error attach function to the errorhandler() decorator that is more straightforward to use for non decorator usage.", "New in version 0.7.", "None", "Absolute path to the package on the filesystem. Used to look up resources contained in the package.", "Decorate a view function to register it with the given URL rule and options. Calls add_url_rule(), which has more details about the implementation.", "See URL Route Registrations.", "The endpoint name for the route defaults to the name of the view function if the endpoint parameter isn\u2019t passed.", "The methods parameter defaults to [\"GET\"]. HEAD and OPTIONS are added automatically.", "Callable", "The view function used to serve files from static_folder. A route is automatically registered for this view at static_url_path if static_folder is set.", "New in version 0.5.", "filename (str) \u2013 ", "Response", "The absolute path to the configured static folder. None if no static folder is set.", "The URL prefix that the static route will be accessible from.", "If it was not configured during init, it is derived from static_folder.", "Like Flask.teardown_request() but for a blueprint. Such a function is executed when tearing down each request, even if outside of the blueprint.", "f (Callable[[Optional[BaseException]], Response]) \u2013 ", "Callable[[Optional[BaseException]], Response]", "Register a function to be run at the end of each request, regardless of whether there was an exception or not. These functions are executed when the request context is popped, even if not an actual request was performed.", "Example:", "When ctx.pop() is executed in the above example, the teardown functions are called just before the request context moves from the stack of active contexts. This becomes relevant if you are using such constructs in tests.", "Teardown functions must avoid raising exceptions, since they . If they execute code that might fail they will have to surround the execution of these code by try/except statements and log occurring errors.", "When a teardown function was called because of an exception it will be passed an error object.", "The return values of teardown functions are ignored.", "Debug Note", "In debug mode Flask will not tear down a request on an exception immediately. Instead it will keep it alive so that the interactive debugger can still access it. This behavior can be controlled by the PRESERVE_CONTEXT_ON_EXCEPTION configuration variable.", "f (Callable[[Optional[BaseException]], Response]) \u2013 ", "Callable[[Optional[BaseException]], Response]", "A data structure of functions to call at the end of each request even if an exception is raised, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests.", "To register a function, use the teardown_request() decorator.", "This data structure is internal. It should not be modified directly and its format may change at any time.", "A data structure of functions to call to pass extra context values when rendering templates, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests.", "To register a function, use the context_processor() decorator.", "This data structure is internal. It should not be modified directly and its format may change at any time.", "The path to the templates folder, relative to root_path, to add to the template loader. None if templates should not be added.", "A data structure of functions to call to modify the keyword arguments when generating URLs, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests.", "To register a function, use the url_defaults() decorator.", "This data structure is internal. It should not be modified directly and its format may change at any time.", "Callback function for URL defaults for all view functions of the application. It\u2019s called with the endpoint and values and should update the values passed in place.", "f (Callable[[str, dict], None]) \u2013 ", "Callable[[str, dict], None]", "Register a URL value preprocessor function for all view functions in the application. These functions will be called before the before_request() functions.", "The function can modify the values captured from the matched url before they are passed to the view. For example, this can be used to pop a common language code value and place it in g rather than pass it to every view.", "The function is passed the endpoint name and values dict. The return value is ignored.", "f (Callable[[Optional[str], Optional[dict]], None]) \u2013 ", "Callable[[Optional[str], Optional[dict]], None]", "A data structure of functions to call to modify the keyword arguments passed to the view function, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests.", "To register a function, use the url_value_preprocessor() decorator.", "This data structure is internal. It should not be modified directly and its format may change at any time.", "A dictionary mapping endpoint names to view functions.", "To register a view function, use the route() decorator.", "This data structure is internal. It should not be modified directly and its format may change at any time."]}, {"name": "Blueprint.add_app_template_filter()", "path": "api/index#flask.Blueprint.add_app_template_filter", "type": "flask", "text": ["Register a custom template filter, available application wide. Like Flask.add_template_filter() but for a blueprint. Works exactly like the app_template_filter() decorator.", "None"]}, {"name": "Blueprint.add_app_template_global()", "path": "api/index#flask.Blueprint.add_app_template_global", "type": "flask", "text": ["Register a custom template global, available application wide. Like Flask.add_template_global() but for a blueprint. Works exactly like the app_template_global() decorator.", "New in version 0.10.", "None"]}, {"name": "Blueprint.add_app_template_test()", "path": "api/index#flask.Blueprint.add_app_template_test", "type": "flask", "text": ["Register a custom template test, available application wide. Like Flask.add_template_test() but for a blueprint. Works exactly like the app_template_test() decorator.", "New in version 0.10.", "None"]}, {"name": "Blueprint.add_url_rule()", "path": "api/index#flask.Blueprint.add_url_rule", "type": "flask", "text": ["Like Flask.add_url_rule() but for a blueprint. The endpoint for the url_for() function is prefixed with the name of the blueprint.", "None"]}, {"name": "Blueprint.after_app_request()", "path": "api/index#flask.Blueprint.after_app_request", "type": "flask", "text": ["Like Flask.after_request() but for a blueprint. Such a function is executed after each request, even if outside of the blueprint.", "f (Callable[[Response], Response]) \u2013 ", "Callable[[Response], Response]"]}, {"name": "Blueprint.after_request()", "path": "api/index#flask.Blueprint.after_request", "type": "flask", "text": ["Register a function to run after each request to this object.", "The function is called with the response object, and must return a response object. This allows the functions to modify or replace the response before it is sent.", "If a function raises an exception, any remaining after_request functions will not be called. Therefore, this should not be used for actions that must execute, such as to close resources. Use teardown_request() for that.", "f (Callable[[Response], Response]) \u2013 ", "Callable[[Response], Response]"]}, {"name": "Blueprint.after_request_funcs", "path": "api/index#flask.Blueprint.after_request_funcs", "type": "flask", "text": ["A data structure of functions to call at the end of each request, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests.", "To register a function, use the after_request() decorator.", "This data structure is internal. It should not be modified directly and its format may change at any time."]}, {"name": "Blueprint.app_context_processor()", "path": "api/index#flask.Blueprint.app_context_processor", "type": "flask", "text": ["Like Flask.context_processor() but for a blueprint. Such a function is executed each request, even if outside of the blueprint.", "f (Callable[[], Dict[str, Any]]) \u2013 ", "Callable[[], Dict[str, Any]]"]}, {"name": "Blueprint.app_errorhandler()", "path": "api/index#flask.Blueprint.app_errorhandler", "type": "flask", "text": ["Like Flask.errorhandler() but for a blueprint. This handler is used for all requests, even if outside of the blueprint.", "code (Union[Type[Exception], int]) \u2013 ", "Callable"]}, {"name": "Blueprint.app_template_filter()", "path": "api/index#flask.Blueprint.app_template_filter", "type": "flask", "text": ["Register a custom template filter, available application wide. Like Flask.template_filter() but for a blueprint.", "name (Optional[str]) \u2013 the optional name of the filter, otherwise the function name will be used.", "Callable"]}, {"name": "Blueprint.app_template_global()", "path": "api/index#flask.Blueprint.app_template_global", "type": "flask", "text": ["Register a custom template global, available application wide. Like Flask.template_global() but for a blueprint.", "New in version 0.10.", "name (Optional[str]) \u2013 the optional name of the global, otherwise the function name will be used.", "Callable"]}, {"name": "Blueprint.app_template_test()", "path": "api/index#flask.Blueprint.app_template_test", "type": "flask", "text": ["Register a custom template test, available application wide. Like Flask.template_test() but for a blueprint.", "New in version 0.10.", "name (Optional[str]) \u2013 the optional name of the test, otherwise the function name will be used.", "Callable"]}, {"name": "Blueprint.app_url_defaults()", "path": "api/index#flask.Blueprint.app_url_defaults", "type": "flask", "text": ["Same as url_defaults() but application wide.", "f (Callable[[str, dict], None]) \u2013 ", "Callable[[str, dict], None]"]}, {"name": "Blueprint.app_url_value_preprocessor()", "path": "api/index#flask.Blueprint.app_url_value_preprocessor", "type": "flask", "text": ["Same as url_value_preprocessor() but application wide.", "f (Callable[[Optional[str], Optional[dict]], None]) \u2013 ", "Callable[[Optional[str], Optional[dict]], None]"]}, {"name": "Blueprint.before_app_first_request()", "path": "api/index#flask.Blueprint.before_app_first_request", "type": "flask", "text": ["Like Flask.before_first_request(). Such a function is executed before the first request to the application.", "f (Callable[[], None]) \u2013 ", "Callable[[], None]"]}, {"name": "Blueprint.before_app_request()", "path": "api/index#flask.Blueprint.before_app_request", "type": "flask", "text": ["Like Flask.before_request(). Such a function is executed before each request, even if outside of a blueprint.", "f (Callable[[], None]) \u2013 ", "Callable[[], None]"]}, {"name": "Blueprint.before_request()", "path": "api/index#flask.Blueprint.before_request", "type": "flask", "text": ["Register a function to run before each request.", "For example, this can be used to open a database connection, or to load the logged in user from the session.", "The function will be called without any arguments. If it returns a non-None value, the value is handled as if it was the return value from the view, and further request handling is stopped.", "f (Callable[[], None]) \u2013 ", "Callable[[], None]"]}, {"name": "Blueprint.before_request_funcs", "path": "api/index#flask.Blueprint.before_request_funcs", "type": "flask", "text": ["A data structure of functions to call at the beginning of each request, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests.", "To register a function, use the before_request() decorator.", "This data structure is internal. It should not be modified directly and its format may change at any time."]}, {"name": "Blueprint.cli", "path": "api/index#flask.Blueprint.cli", "type": "flask", "text": ["The Click command group for registering CLI commands for this object. The commands are available from the flask command once the application has been discovered and blueprints have been registered."]}, {"name": "Blueprint.context_processor()", "path": "api/index#flask.Blueprint.context_processor", "type": "flask", "text": ["Registers a template context processor function.", "f (Callable[[], Dict[str, Any]]) \u2013 ", "Callable[[], Dict[str, Any]]"]}, {"name": "Blueprint.delete()", "path": "api/index#flask.Blueprint.delete", "type": "flask", "text": ["Shortcut for route() with methods=[\"DELETE\"].", "New in version 2.0.", "Callable"]}, {"name": "Blueprint.endpoint()", "path": "api/index#flask.Blueprint.endpoint", "type": "flask", "text": ["Decorate a view function to register it for the given endpoint. Used if a rule is added without a view_func with add_url_rule().", "endpoint (str) \u2013 The endpoint name to associate with the view function.", "Callable"]}, {"name": "Blueprint.errorhandler()", "path": "api/index#flask.Blueprint.errorhandler", "type": "flask", "text": ["Register a function to handle errors by code or exception class.", "A decorator that is used to register a function given an error code. Example:", "You can also register handlers for arbitrary exceptions:", "New in version 0.7: Use register_error_handler() instead of modifying error_handler_spec directly, for application wide error handlers.", "New in version 0.7: One can now additionally also register custom exception types that do not necessarily have to be a subclass of the HTTPException class.", "code_or_exception (Union[Type[Exception], int]) \u2013 the code as integer for the handler, or an arbitrary exception", "Callable"]}, {"name": "Blueprint.error_handler_spec", "path": "api/index#flask.Blueprint.error_handler_spec", "type": "flask", "text": ["A data structure of registered error handlers, in the format {scope: {code: {class: handler}}}`. The scope key is the name of a blueprint the handlers are active for, or None for all requests. The code key is the HTTP status code for HTTPException, or None for other exceptions. The innermost dictionary maps exception classes to handler functions.", "To register an error handler, use the errorhandler() decorator.", "This data structure is internal. It should not be modified directly and its format may change at any time."]}, {"name": "Blueprint.get()", "path": "api/index#flask.Blueprint.get", "type": "flask", "text": ["Shortcut for route() with methods=[\"GET\"].", "New in version 2.0.", "Callable"]}, {"name": "Blueprint.get_send_file_max_age()", "path": "api/index#flask.Blueprint.get_send_file_max_age", "type": "flask", "text": ["Used by send_file() to determine the max_age cache value for a given file path if it wasn\u2019t passed.", "By default, this returns SEND_FILE_MAX_AGE_DEFAULT from the configuration of current_app. This defaults to None, which tells the browser to use conditional requests instead of a timed cache, which is usually preferable.", "Changed in version 2.0: The default configuration is None instead of 12 hours.", "New in version 0.9.", "filename (str) \u2013 ", "Optional[int]"]}, {"name": "Blueprint.import_name", "path": "api/index#flask.Blueprint.import_name", "type": "flask", "text": ["The name of the package or module that this object belongs to. Do not change this once it is set by the constructor."]}, {"name": "Blueprint.json_decoder", "path": "api/index#flask.Blueprint.json_decoder", "type": "flask", "text": ["Blueprint local JSON decoder class to use. Set to None to use the app\u2019s json_decoder."]}, {"name": "Blueprint.json_encoder", "path": "api/index#flask.Blueprint.json_encoder", "type": "flask", "text": ["Blueprint local JSON encoder class to use. Set to None to use the app\u2019s json_encoder."]}, {"name": "Blueprint.make_setup_state()", "path": "api/index#flask.Blueprint.make_setup_state", "type": "flask", "text": ["Creates an instance of BlueprintSetupState() object that is later passed to the register callback functions. Subclasses can override this to return a subclass of the setup state.", "flask.blueprints.BlueprintSetupState"]}, {"name": "Blueprint.open_resource()", "path": "api/index#flask.Blueprint.open_resource", "type": "flask", "text": ["Open a resource file relative to root_path for reading.", "For example, if the file schema.sql is next to the file app.py where the Flask app is defined, it can be opened with:", "IO"]}, {"name": "Blueprint.patch()", "path": "api/index#flask.Blueprint.patch", "type": "flask", "text": ["Shortcut for route() with methods=[\"PATCH\"].", "New in version 2.0.", "Callable"]}, {"name": "Blueprint.post()", "path": "api/index#flask.Blueprint.post", "type": "flask", "text": ["Shortcut for route() with methods=[\"POST\"].", "New in version 2.0.", "Callable"]}, {"name": "Blueprint.put()", "path": "api/index#flask.Blueprint.put", "type": "flask", "text": ["Shortcut for route() with methods=[\"PUT\"].", "New in version 2.0.", "Callable"]}, {"name": "Blueprint.record()", "path": "api/index#flask.Blueprint.record", "type": "flask", "text": ["Registers a function that is called when the blueprint is registered on the application. This function is called with the state as argument as returned by the make_setup_state() method.", "func (Callable) \u2013 ", "None"]}, {"name": "Blueprint.record_once()", "path": "api/index#flask.Blueprint.record_once", "type": "flask", "text": ["Works like record() but wraps the function in another function that will ensure the function is only called once. If the blueprint is registered a second time on the application, the function passed is not called.", "func (Callable) \u2013 ", "None"]}, {"name": "Blueprint.register()", "path": "api/index#flask.Blueprint.register", "type": "flask", "text": ["Called by Flask.register_blueprint() to register all views and callbacks registered on the blueprint with the application. Creates a BlueprintSetupState and calls each record() callbackwith it.", "None"]}, {"name": "Blueprint.register_blueprint()", "path": "api/index#flask.Blueprint.register_blueprint", "type": "flask", "text": ["Register a Blueprint on this blueprint. Keyword arguments passed to this method will override the defaults set on the blueprint.", "New in version 2.0.", "None"]}, {"name": "Blueprint.register_error_handler()", "path": "api/index#flask.Blueprint.register_error_handler", "type": "flask", "text": ["Alternative error attach function to the errorhandler() decorator that is more straightforward to use for non decorator usage.", "New in version 0.7.", "None"]}, {"name": "Blueprint.root_path", "path": "api/index#flask.Blueprint.root_path", "type": "flask", "text": ["Absolute path to the package on the filesystem. Used to look up resources contained in the package."]}, {"name": "Blueprint.route()", "path": "api/index#flask.Blueprint.route", "type": "flask", "text": ["Decorate a view function to register it with the given URL rule and options. Calls add_url_rule(), which has more details about the implementation.", "See URL Route Registrations.", "The endpoint name for the route defaults to the name of the view function if the endpoint parameter isn\u2019t passed.", "The methods parameter defaults to [\"GET\"]. HEAD and OPTIONS are added automatically.", "Callable"]}, {"name": "Blueprint.send_static_file()", "path": "api/index#flask.Blueprint.send_static_file", "type": "flask", "text": ["The view function used to serve files from static_folder. A route is automatically registered for this view at static_url_path if static_folder is set.", "New in version 0.5.", "filename (str) \u2013 ", "Response"]}, {"name": "Blueprint.teardown_app_request()", "path": "api/index#flask.Blueprint.teardown_app_request", "type": "flask", "text": ["Like Flask.teardown_request() but for a blueprint. Such a function is executed when tearing down each request, even if outside of the blueprint.", "f (Callable[[Optional[BaseException]], Response]) \u2013 ", "Callable[[Optional[BaseException]], Response]"]}, {"name": "Blueprint.teardown_request()", "path": "api/index#flask.Blueprint.teardown_request", "type": "flask", "text": ["Register a function to be run at the end of each request, regardless of whether there was an exception or not. These functions are executed when the request context is popped, even if not an actual request was performed.", "Example:", "When ctx.pop() is executed in the above example, the teardown functions are called just before the request context moves from the stack of active contexts. This becomes relevant if you are using such constructs in tests.", "Teardown functions must avoid raising exceptions, since they . If they execute code that might fail they will have to surround the execution of these code by try/except statements and log occurring errors.", "When a teardown function was called because of an exception it will be passed an error object.", "The return values of teardown functions are ignored.", "Debug Note", "In debug mode Flask will not tear down a request on an exception immediately. Instead it will keep it alive so that the interactive debugger can still access it. This behavior can be controlled by the PRESERVE_CONTEXT_ON_EXCEPTION configuration variable.", "f (Callable[[Optional[BaseException]], Response]) \u2013 ", "Callable[[Optional[BaseException]], Response]"]}, {"name": "Blueprint.teardown_request_funcs", "path": "api/index#flask.Blueprint.teardown_request_funcs", "type": "flask", "text": ["A data structure of functions to call at the end of each request even if an exception is raised, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests.", "To register a function, use the teardown_request() decorator.", "This data structure is internal. It should not be modified directly and its format may change at any time."]}, {"name": "Blueprint.template_context_processors", "path": "api/index#flask.Blueprint.template_context_processors", "type": "flask", "text": ["A data structure of functions to call to pass extra context values when rendering templates, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests.", "To register a function, use the context_processor() decorator.", "This data structure is internal. It should not be modified directly and its format may change at any time."]}, {"name": "Blueprint.template_folder", "path": "api/index#flask.Blueprint.template_folder", "type": "flask", "text": ["The path to the templates folder, relative to root_path, to add to the template loader. None if templates should not be added."]}, {"name": "Blueprint.url_defaults()", "path": "api/index#flask.Blueprint.url_defaults", "type": "flask", "text": ["Callback function for URL defaults for all view functions of the application. It\u2019s called with the endpoint and values and should update the values passed in place.", "f (Callable[[str, dict], None]) \u2013 ", "Callable[[str, dict], None]"]}, {"name": "Blueprint.url_default_functions", "path": "api/index#flask.Blueprint.url_default_functions", "type": "flask", "text": ["A data structure of functions to call to modify the keyword arguments when generating URLs, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests.", "To register a function, use the url_defaults() decorator.", "This data structure is internal. It should not be modified directly and its format may change at any time."]}, {"name": "Blueprint.url_value_preprocessor()", "path": "api/index#flask.Blueprint.url_value_preprocessor", "type": "flask", "text": ["Register a URL value preprocessor function for all view functions in the application. These functions will be called before the before_request() functions.", "The function can modify the values captured from the matched url before they are passed to the view. For example, this can be used to pop a common language code value and place it in g rather than pass it to every view.", "The function is passed the endpoint name and values dict. The return value is ignored.", "f (Callable[[Optional[str], Optional[dict]], None]) \u2013 ", "Callable[[Optional[str], Optional[dict]], None]"]}, {"name": "Blueprint.url_value_preprocessors", "path": "api/index#flask.Blueprint.url_value_preprocessors", "type": "flask", "text": ["A data structure of functions to call to modify the keyword arguments passed to the view function, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests.", "To register a function, use the url_value_preprocessor() decorator.", "This data structure is internal. It should not be modified directly and its format may change at any time."]}, {"name": "Blueprint.view_functions", "path": "api/index#flask.Blueprint.view_functions", "type": "flask", "text": ["A dictionary mapping endpoint names to view functions.", "To register a view function, use the route() decorator.", "This data structure is internal. It should not be modified directly and its format may change at any time."]}, {"name": "BlueprintSetupState", "path": "api/index#flask.blueprints.BlueprintSetupState", "type": "flask.blueprints", "text": ["Temporary holder object for registering a blueprint with the application. An instance of this class is created by the make_setup_state() method and later passed to all register callback functions.", "None", "A helper method to register a rule (and optionally a view function) to the application. The endpoint is automatically prefixed with the blueprint\u2019s name.", "None", "a reference to the current application", "a reference to the blueprint that created this setup state.", "as blueprints can be registered multiple times with the application and not everything wants to be registered multiple times on it, this attribute can be used to figure out if the blueprint was registered in the past already.", "a dictionary with all options that were passed to the register_blueprint() method.", "The subdomain that the blueprint should be active for, None otherwise.", "A dictionary with URL defaults that is added to each and every URL that was defined with the blueprint.", "The prefix that should be used for all URLs defined on the blueprint."]}, {"name": "BlueprintSetupState.add_url_rule()", "path": "api/index#flask.blueprints.BlueprintSetupState.add_url_rule", "type": "flask.blueprints", "text": ["A helper method to register a rule (and optionally a view function) to the application. The endpoint is automatically prefixed with the blueprint\u2019s name.", "None"]}, {"name": "BlueprintSetupState.app", "path": "api/index#flask.blueprints.BlueprintSetupState.app", "type": "flask.blueprints", "text": ["a reference to the current application"]}, {"name": "BlueprintSetupState.blueprint", "path": "api/index#flask.blueprints.BlueprintSetupState.blueprint", "type": "flask.blueprints", "text": ["a reference to the blueprint that created this setup state."]}, {"name": "BlueprintSetupState.first_registration", "path": "api/index#flask.blueprints.BlueprintSetupState.first_registration", "type": "flask.blueprints", "text": ["as blueprints can be registered multiple times with the application and not everything wants to be registered multiple times on it, this attribute can be used to figure out if the blueprint was registered in the past already."]}, {"name": "BlueprintSetupState.options", "path": "api/index#flask.blueprints.BlueprintSetupState.options", "type": "flask.blueprints", "text": ["a dictionary with all options that were passed to the register_blueprint() method."]}, {"name": "BlueprintSetupState.subdomain", "path": "api/index#flask.blueprints.BlueprintSetupState.subdomain", "type": "flask.blueprints", "text": ["The subdomain that the blueprint should be active for, None otherwise."]}, {"name": "BlueprintSetupState.url_defaults", "path": "api/index#flask.blueprints.BlueprintSetupState.url_defaults", "type": "flask.blueprints", "text": ["A dictionary with URL defaults that is added to each and every URL that was defined with the blueprint."]}, {"name": "BlueprintSetupState.url_prefix", "path": "api/index#flask.blueprints.BlueprintSetupState.url_prefix", "type": "flask.blueprints", "text": ["The prefix that should be used for all URLs defined on the blueprint."]}, {"name": "Caching", "path": "patterns/caching/index", "type": "User's Guide: Design Patterns", "text": ["When your application runs slow, throw some caches in. Well, at least it\u2019s the easiest way to speed up things. What does a cache do? Say you have a function that takes some time to complete but the results would still be good enough if they were 5 minutes old. So then the idea is that you actually put the result of that calculation into a cache for some time.", "Flask itself does not provide caching for you, but Flask-Caching, an extension for Flask does. Flask-Caching supports various backends, and it is even possible to develop your own caching backend."]}, {"name": "Celery Background Tasks", "path": "patterns/celery/index", "type": "User's Guide: Design Patterns", "text": ["If your application has a long running task, such as processing some uploaded data or sending email, you don\u2019t want to wait for it to finish during a request. Instead, use a task queue to send the necessary data to another process that will run the task in the background while the request returns immediately.", "Celery is a powerful task queue that can be used for simple background tasks as well as complex multi-stage programs and schedules. This guide will show you how to configure Celery using Flask, but assumes you\u2019ve already read the First Steps with Celery guide in the Celery documentation.", "Celery is a separate Python package. Install it from PyPI using pip:", "The first thing you need is a Celery instance, this is called the celery application. It serves the same purpose as the Flask object in Flask, just for Celery. Since this instance is used as the entry-point for everything you want to do in Celery, like creating tasks and managing workers, it must be possible for other modules to import it.", "For instance you can place this in a tasks module. While you can use Celery without any reconfiguration with Flask, it becomes a bit nicer by subclassing tasks and adding support for Flask\u2019s application contexts and hooking it up with the Flask configuration.", "This is all that is necessary to properly integrate Celery with Flask:", "The function creates a new Celery object, configures it with the broker from the application config, updates the rest of the Celery config from the Flask config and then creates a subclass of the task that wraps the task execution in an application context.", "Let\u2019s write a task that adds two numbers together and returns the result. We configure Celery\u2019s broker and backend to use Redis, create a celery application using the factor from above, and then use it to define the task.", "This task can now be called in the background:", "If you jumped in and already executed the above code you will be disappointed to learn that .wait() will never actually return. That\u2019s because you also need to run a Celery worker to receive and execute the task.", "The your_application string has to point to your application\u2019s package or module that creates the celery object.", "Now that the worker is running, wait will return the result once the task is finished."]}, {"name": "CGI", "path": "deploying/cgi/index", "type": "User's Guide: Deploying", "text": ["If all other deployment methods do not work, CGI will work for sure. CGI is supported by all major servers but usually has a sub-optimal performance.", "This is also the way you can use a Flask application on Google\u2019s App Engine, where execution happens in a CGI-like environment.", "Watch Out", "Please make sure in advance that any app.run() calls you might have in your application file are inside an if __name__ ==\n'__main__': block or moved to a separate file. Just make sure it\u2019s not called because this will always start a local WSGI server which we do not want if we deploy that application to CGI / app engine.", "With CGI, you will also have to make sure that your code does not contain any print statements, or that sys.stdout is overridden by something that doesn\u2019t write into the HTTP response.", "First you need to create the CGI application file. Let\u2019s call it yourapplication.cgi:", "Usually there are two ways to configure the server. Either just copy the .cgi into a cgi-bin (and use mod_rewrite or something similar to rewrite the URL) or let the server point to the file directly.", "In Apache for example you can put something like this into the config:", "On shared webhosting, though, you might not have access to your Apache config. In this case, a file called .htaccess, sitting in the public directory you want your app to be available, works too but the ScriptAlias directive won\u2019t work in that case:", "For more information consult the documentation of your webserver."]}, {"name": "Changes", "path": "changes/index", "type": "Additional Notes", "text": ["Unreleased", "Released 2021-05-11", "Released 2020-04-03", "Released 2019-07-08", "Released 2019-07-04", "Error handlers for InternalServerError or 500 will always be passed an instance of InternalServerError. If they are invoked due to an unhandled exception, that original exception is now available as e.original_exception rather than being passed directly to the handler. The same is true if the handler is for the base HTTPException. This makes error handler behavior more consistent. #3266", "Released 2019-07-04", "Released 2019-05-17", "Released 2018-05-02", "Released 2018-04-29", "Released 2018-04-26", "The following old deprecated code was removed. #2385", "Released 2020-02-10", "Released 2018-04-29", "Released 2018-04-26", "Released 2017-05-16", "Released 2017-03-31", "Released 2016-12-21, codename Punsch", "Released 2016-06-07", "Released 2016-05-29, codename Absinthe", "Released 2013-06-14", "Released 2013-06-13, codename Limoncello", "Released 2012-07-01, codename Campari", "Released 2012-07-01", "Released 2011-09-29, codename Rakija", "Released 2011-07-06", "Released 2011-06-29", "Released 2011-06-28, codename Grappa", "Released 2010-12-31", "Released 2010-07-27, codename Whisky", "Released 2010-07-15", "Released 2010-07-06", "Released 2010-07-06, codename Calvados", "Released 2010-06-18, codename Rakia", "Released 2010-05-28", "Released 2010-05-28, codename Schnaps", "Released 2010-05-12, codename J?germeister", "Released 2010-04-16"]}, {"name": "Command Line Interface", "path": "cli/index", "type": "User\u2019s Guide", "text": ["Installing Flask installs the flask script, a Click command line interface, in your virtualenv. Executed from the terminal, this script gives access to built-in, extension, and application-defined commands. The --help option will give more information about any commands and options.", "The flask command is installed by Flask, not your application; it must be told where to find your application in order to use it. The FLASK_APP environment variable is used to specify how to load the application.", "While FLASK_APP supports a variety of options for specifying your application, most use cases should be simple. Here are the typical values:", "The name \u201capp\u201d or \u201cwsgi\u201d is imported (as a \u201c.py\u201d file, or package), automatically detecting an app (app or application) or factory (create_app or make_app).", "The given name is imported, automatically detecting an app (app or application) or factory (create_app or make_app).", "FLASK_APP has three parts: an optional path that sets the current working directory, a Python file or dotted import path, and an optional variable name of the instance or factory. If the name is a factory, it can optionally be followed by arguments in parentheses. The following values demonstrate these parts:", "Sets the current working directory to src then imports hello.", "Imports the path hello.web.", "Uses the app2 Flask instance in hello.", "The create_app factory in hello is called with the string 'dev' as the argument.", "If FLASK_APP is not set, the command will try to import \u201capp\u201d or \u201cwsgi\u201d (as a \u201c.py\u201d file, or package) and try to detect an application instance or factory.", "Within the given import, the command looks for an application instance named app or application, then any application instance. If no instance is found, the command looks for a factory function named create_app or make_app that returns an instance.", "If parentheses follow the factory name, their contents are parsed as Python literals and passed as arguments and keyword arguments to the function. This means that strings must still be in quotes.", "The run command will start the development server. It replaces the Flask.run() method in most cases.", "Warning", "Do not use this command to run your application in production. Only use the development server during development. The development server is provided for convenience, but is not designed to be particularly secure, stable, or efficient. See Deployment Options for how to run in production.", "To explore the data in your application, you can start an interactive Python shell with the shell command. An application context will be active, and the app instance will be imported.", "Use shell_context_processor() to add other automatic imports.", "New in version 1.0.", "The environment in which the Flask app runs is set by the FLASK_ENV environment variable. If not set it defaults to production. The other recognized environment is development. Flask and extensions may choose to enable behaviors based on the environment.", "If the env is set to development, the flask command will enable debug mode and flask run will enable the interactive debugger and reloader.", "When using development mode, the reloader will trigger whenever your Python code or imported modules change. The reloader can watch additional files with the --extra-files option, or the FLASK_RUN_EXTRA_FILES environment variable. Multiple paths are separated with :, or ; on Windows.", "Debug mode will be enabled when FLASK_ENV is development, as described above. If you want to control debug mode separately, use FLASK_DEBUG. The value 1 enables it, 0 disables it.", "Rather than setting FLASK_APP each time you open a new terminal, you can use Flask\u2019s dotenv support to set environment variables automatically.", "If python-dotenv is installed, running the flask command will set environment variables defined in the files .env and .flaskenv. This can be used to avoid having to set FLASK_APP manually every time you open a new terminal, and to set configuration using environment variables similar to how some deployment services work.", "Variables set on the command line are used over those set in .env, which are used over those set in .flaskenv. .flaskenv should be used for public variables, such as FLASK_APP, while .env should not be committed to your repository so that it can set private variables.", "Directories are scanned upwards from the directory you call flask from to locate the files. The current working directory will be set to the location of the file, with the assumption that that is the top level project directory.", "The files are only loaded by the flask command or calling run(). If you would like to load these files when running in production, you should call load_dotenv() manually.", "Click is configured to load default values for command options from environment variables. The variables use the pattern FLASK_COMMAND_OPTION. For example, to set the port for the run command, instead of flask run --port 8000:", "These can be added to the .flaskenv file just like FLASK_APP to control default command options.", "The flask command will show a message if it detects dotenv files but python-dotenv is not installed.", "You can tell Flask not to load dotenv files even when python-dotenv is installed by setting the FLASK_SKIP_DOTENV environment variable. This can be useful if you want to load them manually, or if you\u2019re using a project runner that loads them already. Keep in mind that the environment variables must be set before the app loads or it won\u2019t configure as expected.", "If you do not want to install dotenv support, you can still set environment variables by adding them to the end of the virtualenv\u2019s activate script. Activating the virtualenv will set the variables.", "Unix Bash, venv/bin/activate:", "Windows CMD, venv\\Scripts\\activate.bat:", "Windows Powershell, venv\\Scripts\\activate.ps1:", "It is preferred to use dotenv support over this, since .flaskenv can be committed to the repository so that it works automatically wherever the project is checked out.", "The flask command is implemented using Click. See that project\u2019s documentation for full information about writing commands.", "This example adds the command create-user that takes the argument name.", "This example adds the same command, but as user create, a command in a group. This is useful if you want to organize multiple related commands.", "See Testing CLI Commands for an overview of how to test your custom commands.", "If your application uses blueprints, you can optionally register CLI commands directly onto them. When your blueprint is registered onto your application, the associated commands will be available to the flask command. By default, those commands will be nested in a group matching the name of the blueprint.", "You can alter the group name by specifying the cli_group parameter when creating the Blueprint object, or later with app.register_blueprint(bp, cli_group='...'). The following are equivalent:", "Specifying cli_group=None will remove the nesting and merge the commands directly to the application\u2019s level:", "Commands added using the Flask app\u2019s cli command() decorator will be executed with an application context pushed, so your command and extensions have access to the app and its configuration. If you create a command using the Click command() decorator instead of the Flask decorator, you can use with_appcontext() to get the same behavior.", "If you\u2019re sure a command doesn\u2019t need the context, you can disable it:", "Flask will automatically load commands specified in the flask.commands entry point. This is useful for extensions that want to add commands when they are installed. Entry points are specified in setup.py", "Inside flask_my_extension/commands.py you can then export a Click object:", "Once that package is installed in the same virtualenv as your Flask project, you can run flask my-command to invoke the command.", "When you are using the app factory pattern, it may be more convenient to define your own Click script. Instead of using FLASK_APP and letting Flask load your application, you can create your own Click object and export it as a console script entry point.", "Create an instance of FlaskGroup and pass it the factory:", "Define the entry point in setup.py:", "Install the application in the virtualenv in editable mode and the custom script is available. Note that you don\u2019t need to set FLASK_APP.", "Errors in Custom Scripts", "When using a custom script, if you introduce an error in your module-level code, the reloader will fail because it can no longer load the entry point.", "The flask command, being separate from your code, does not have this issue and is recommended in most cases.", "PyCharm Professional provides a special Flask run configuration. For the Community Edition, we need to configure it to call the flask run CLI command with the correct environment variables. These instructions should be similar for any other IDE you might want to use.", "In PyCharm, with your project open, click on Run from the menu bar and go to Edit Configurations. You\u2019ll be greeted by a screen similar to this:", "There\u2019s quite a few options to change, but once we\u2019ve done it for one command, we can easily copy the entire configuration and make a single tweak to give us access to other commands, including any custom ones you may implement yourself.", "Click the + (Add New Configuration) button and select Python. Give the configuration a name such as \u201cflask run\u201d. For the flask run command, check \u201cSingle instance only\u201d since you can\u2019t run the server more than once at the same time.", "Select Module name from the dropdown (A) then input flask.", "The Parameters field (B) is set to the CLI command to execute (with any arguments). In this example we use run, which will run the development server.", "You can skip this next step if you\u2019re using Environment Variables From dotenv. We need to add an environment variable (C) to identify our application. Click on the browse button and add an entry with FLASK_APP on the left and the Python import or file on the right (hello for example). Add an entry with FLASK_ENV and set it to development.", "Next we need to set the working directory (D) to be the folder where our application resides.", "If you have installed your project as a package in your virtualenv, you may untick the PYTHONPATH options (E). This will more accurately match how you deploy the app later.", "Click Apply to save the configuration, or OK to save and close the window. Select the configuration in the main PyCharm window and click the play button next to it to run the server.", "Now that we have a configuration which runs flask run from within PyCharm, we can copy that configuration and alter the Script argument to run a different CLI command, e.g. flask shell."]}, {"name": "Config", "path": "api/index#flask.Config", "type": "flask", "text": ["Works exactly like a dict but provides ways to fill it from files or special dictionaries. There are two common patterns to populate the config.", "Either you can fill the config from a config file:", "Or alternatively you can define the configuration options in the module that calls from_object() or provide an import path to a module that should be loaded. It is also possible to tell it to use the same module and with that provide the configuration values just before the call:", "In both cases (loading from any Python file or loading from modules), only uppercase keys are added to the config. This makes it possible to use lowercase values in the config file for temporary values that are not added to the config or to define the config keys in the same file that implements the application.", "Probably the most interesting way to load configurations is from an environment variable pointing to a file:", "In this case before launching the application you have to set this environment variable to the file you want to use. On Linux and OS X use the export statement:", "On windows use set instead.", "None", "Loads a configuration from an environment variable pointing to a configuration file. This is basically just a shortcut with nicer error messages for this line of code:", "bool. True if able to load config, False otherwise.", "bool", "Update the values in the config from a file that is loaded using the load parameter. The loaded data is passed to the from_mapping() method.", "bool", "New in version 2.0.", "Updates the config like update() ignoring items with non-upper keys.", "New in version 0.11.", "bool", "Updates the values from the given object. An object can be of one of the following two types:", "Objects are usually either modules or classes. from_object() loads only the uppercase attributes of the module/class. A dict object will not work with from_object() because the keys of a dict are not attributes of the dict class.", "Example of module-based configuration:", "Nothing is done to the object before loading. If the object is a class and has @property attributes, it needs to be instantiated before being passed to this method.", "You should not use this function to load the actual configuration but rather configuration defaults. The actual config should be loaded with from_pyfile() and ideally from a location not within the package because the package might be installed system wide.", "See Development / Production for an example of class-based configuration using from_object().", "obj (Union[object, str]) \u2013 an import name or object", "None", "Updates the values in the config from a Python file. This function behaves as if the file was imported as module with the from_object() function.", "bool", "New in version 0.7: silent parameter.", "Returns a dictionary containing a subset of configuration options that match the specified namespace/prefix. Example usage:", "The resulting dictionary image_store_config would look like:", "This is often useful when configuration options map directly to keyword arguments in functions or class constructors.", "Dict[str, Any]", "New in version 0.11."]}, {"name": "Config.from_envvar()", "path": "api/index#flask.Config.from_envvar", "type": "flask", "text": ["Loads a configuration from an environment variable pointing to a configuration file. This is basically just a shortcut with nicer error messages for this line of code:", "bool. True if able to load config, False otherwise.", "bool"]}, {"name": "Config.from_file()", "path": "api/index#flask.Config.from_file", "type": "flask", "text": ["Update the values in the config from a file that is loaded using the load parameter. The loaded data is passed to the from_mapping() method.", "bool", "New in version 2.0."]}, {"name": "Config.from_mapping()", "path": "api/index#flask.Config.from_mapping", "type": "flask", "text": ["Updates the config like update() ignoring items with non-upper keys.", "New in version 0.11.", "bool"]}, {"name": "Config.from_object()", "path": "api/index#flask.Config.from_object", "type": "flask", "text": ["Updates the values from the given object. An object can be of one of the following two types:", "Objects are usually either modules or classes. from_object() loads only the uppercase attributes of the module/class. A dict object will not work with from_object() because the keys of a dict are not attributes of the dict class.", "Example of module-based configuration:", "Nothing is done to the object before loading. If the object is a class and has @property attributes, it needs to be instantiated before being passed to this method.", "You should not use this function to load the actual configuration but rather configuration defaults. The actual config should be loaded with from_pyfile() and ideally from a location not within the package because the package might be installed system wide.", "See Development / Production for an example of class-based configuration using from_object().", "obj (Union[object, str]) \u2013 an import name or object", "None"]}, {"name": "Config.from_pyfile()", "path": "api/index#flask.Config.from_pyfile", "type": "flask", "text": ["Updates the values in the config from a Python file. This function behaves as if the file was imported as module with the from_object() function.", "bool", "New in version 0.7: silent parameter."]}, {"name": "Config.get_namespace()", "path": "api/index#flask.Config.get_namespace", "type": "flask", "text": ["Returns a dictionary containing a subset of configuration options that match the specified namespace/prefix. Example usage:", "The resulting dictionary image_store_config would look like:", "This is often useful when configuration options map directly to keyword arguments in functions or class constructors.", "Dict[str, Any]", "New in version 0.11."]}, {"name": "Configuration Handling", "path": "config/index", "type": "User\u2019s Guide", "text": ["Applications need some kind of configuration. There are different settings you might want to change depending on the application environment like toggling the debug mode, setting the secret key, and other such environment-specific things.", "The way Flask is designed usually requires the configuration to be available when the application starts up. You can hard code the configuration in the code, which for many small applications is not actually that bad, but there are better ways.", "Independent of how you load your config, there is a config object available which holds the loaded configuration values: The config attribute of the Flask object. This is the place where Flask itself puts certain configuration values and also where extensions can put their configuration values. But this is also where you can have your own configuration.", "The config is actually a subclass of a dictionary and can be modified just like any dictionary:", "Certain configuration values are also forwarded to the Flask object so you can read and write them from there:", "To update multiple keys at once you can use the dict.update() method:", "The ENV and DEBUG config values are special because they may behave inconsistently if changed after the app has begun setting up. In order to set the environment and debug mode reliably, Flask uses environment variables.", "The environment is used to indicate to Flask, extensions, and other programs, like Sentry, what context Flask is running in. It is controlled with the FLASK_ENV environment variable and defaults to production.", "Setting FLASK_ENV to development will enable debug mode. flask run will use the interactive debugger and reloader by default in debug mode. To control this separately from the environment, use the FLASK_DEBUG flag.", "Changed in version 1.0: Added FLASK_ENV to control the environment separately from debug mode. The development environment enables debug mode.", "To switch Flask to the development environment and enable debug mode, set FLASK_ENV:", "Using the environment variables as described above is recommended. While it is possible to set ENV and DEBUG in your config or code, this is strongly discouraged. They can\u2019t be read early by the flask command, and some systems or extensions may have already configured themselves based on a previous value.", "The following configuration values are used internally by Flask:", "What environment the app is running in. Flask and extensions may enable behaviors based on the environment, such as enabling debug mode. The env attribute maps to this config key. This is set by the FLASK_ENV environment variable and may not behave as expected if set in code.", "Do not enable development when deploying in production.", "Default: 'production'", "New in version 1.0.", "Whether debug mode is enabled. When using flask run to start the development server, an interactive debugger will be shown for unhandled exceptions, and the server will be reloaded when code changes. The debug attribute maps to this config key. This is enabled when ENV is 'development' and is overridden by the FLASK_DEBUG environment variable. It may not behave as expected if set in code.", "Do not enable debug mode when deploying in production.", "Default: True if ENV is 'development', or False otherwise.", "Enable testing mode. Exceptions are propagated rather than handled by the the app\u2019s error handlers. Extensions may also change their behavior to facilitate easier testing. You should enable this in your own tests.", "Default: False", "Exceptions are re-raised rather than being handled by the app\u2019s error handlers. If not set, this is implicitly true if TESTING or DEBUG is enabled.", "Default: None", "Don\u2019t pop the request context when an exception occurs. If not set, this is true if DEBUG is true. This allows debuggers to introspect the request data on errors, and should normally not need to be set directly.", "Default: None", "If there is no handler for an HTTPException-type exception, re-raise it to be handled by the interactive debugger instead of returning it as a simple error response.", "Default: False", "Trying to access a key that doesn\u2019t exist from request dicts like args and form will return a 400 Bad Request error page. Enable this to treat the error as an unhandled exception instead so that you get the interactive debugger. This is a more specific version of TRAP_HTTP_EXCEPTIONS. If unset, it is enabled in debug mode.", "Default: None", "A secret key that will be used for securely signing the session cookie and can be used for any other security related needs by extensions or your application. It should be a long random bytes or str. For example, copy the output of this to your config:", "Do not reveal the secret key when posting questions or committing code.", "Default: None", "The name of the session cookie. Can be changed in case you already have a cookie with the same name.", "Default: 'session'", "The domain match rule that the session cookie will be valid for. If not set, the cookie will be valid for all subdomains of SERVER_NAME. If False, the cookie\u2019s domain will not be set.", "Default: None", "The path that the session cookie will be valid for. If not set, the cookie will be valid underneath APPLICATION_ROOT or / if that is not set.", "Default: None", "Browsers will not allow JavaScript access to cookies marked as \u201cHTTP only\u201d for security.", "Default: True", "Browsers will only send cookies with requests over HTTPS if the cookie is marked \u201csecure\u201d. The application must be served over HTTPS for this to make sense.", "Default: False", "Restrict how cookies are sent with requests from external sites. Can be set to 'Lax' (recommended) or 'Strict'. See Set-Cookie options.", "Default: None", "New in version 1.0.", "If session.permanent is true, the cookie\u2019s expiration will be set this number of seconds in the future. Can either be a datetime.timedelta or an int.", "Flask\u2019s default cookie implementation validates that the cryptographic signature is not older than this value.", "Default: timedelta(days=31) (2678400 seconds)", "Control whether the cookie is sent with every response when session.permanent is true. Sending the cookie every time (the default) can more reliably keep the session from expiring, but uses more bandwidth. Non-permanent sessions are not affected.", "Default: True", "When serving files, set the X-Sendfile header instead of serving the data with Flask. Some web servers, such as Apache, recognize this and serve the data more efficiently. This only makes sense when using such a server.", "Default: False", "When serving files, set the cache control max age to this number of seconds. Can be a datetime.timedelta or an int. Override this value on a per-file basis using get_send_file_max_age() on the application or blueprint.", "If None, send_file tells the browser to use conditional requests will be used instead of a timed cache, which is usually preferable.", "Default: None", "Inform the application what host and port it is bound to. Required for subdomain route matching support.", "If set, will be used for the session cookie domain if SESSION_COOKIE_DOMAIN is not set. Modern web browsers will not allow setting cookies for domains without a dot. To use a domain locally, add any names that should route to the app to your hosts file.", "If set, url_for can generate external URLs with only an application context instead of a request context.", "Default: None", "Inform the application what path it is mounted under by the application / web server. This is used for generating URLs outside the context of a request (inside a request, the dispatcher is responsible for setting SCRIPT_NAME instead; see Application Dispatching for examples of dispatch configuration).", "Will be used for the session cookie path if SESSION_COOKIE_PATH is not set.", "Default: '/'", "Use this scheme for generating external URLs when not in a request context.", "Default: 'http'", "Don\u2019t read more than this many bytes from the incoming request data. If not set and the request does not specify a CONTENT_LENGTH, no data will be read for security.", "Default: None", "Serialize objects to ASCII-encoded JSON. If this is disabled, the JSON returned from jsonify will contain Unicode characters. This has security implications when rendering the JSON into JavaScript in templates, and should typically remain enabled.", "Default: True", "Sort the keys of JSON objects alphabetically. This is useful for caching because it ensures the data is serialized the same way no matter what Python\u2019s hash seed is. While not recommended, you can disable this for a possible performance improvement at the cost of caching.", "Default: True", "jsonify responses will be output with newlines, spaces, and indentation for easier reading by humans. Always enabled in debug mode.", "Default: False", "The mimetype of jsonify responses.", "Default: 'application/json'", "Reload templates when they are changed. If not set, it will be enabled in debug mode.", "Default: None", "Log debugging information tracing how a template file was loaded. This can be useful to figure out why a template was not loaded or the wrong file appears to be loaded.", "Default: False", "Warn if cookie headers are larger than this many bytes. Defaults to 4093. Larger cookies may be silently ignored by browsers. Set to 0 to disable the warning.", "Changed in version 1.0: LOGGER_NAME and LOGGER_HANDLER_POLICY were removed. See Logging for information about configuration.", "Added ENV to reflect the FLASK_ENV environment variable.", "Added SESSION_COOKIE_SAMESITE to control the session cookie\u2019s SameSite option.", "Added MAX_COOKIE_SIZE to control a warning from Werkzeug.", "New in version 0.11: SESSION_REFRESH_EACH_REQUEST, TEMPLATES_AUTO_RELOAD, LOGGER_HANDLER_POLICY, EXPLAIN_TEMPLATE_LOADING", "New in version 0.10: JSON_AS_ASCII, JSON_SORT_KEYS, JSONIFY_PRETTYPRINT_REGULAR", "New in version 0.9: PREFERRED_URL_SCHEME", "New in version 0.8: TRAP_BAD_REQUEST_ERRORS, TRAP_HTTP_EXCEPTIONS, APPLICATION_ROOT, SESSION_COOKIE_DOMAIN, SESSION_COOKIE_PATH, SESSION_COOKIE_HTTPONLY, SESSION_COOKIE_SECURE", "New in version 0.7: PROPAGATE_EXCEPTIONS, PRESERVE_CONTEXT_ON_EXCEPTION", "New in version 0.6: MAX_CONTENT_LENGTH", "New in version 0.5: SERVER_NAME", "New in version 0.4: LOGGER_NAME", "Configuration becomes more useful if you can store it in a separate file, ideally located outside the actual application package. This makes packaging and distributing your application possible via various package handling tools (Deploying with Setuptools) and finally modifying the configuration file afterwards.", "So a common pattern is this:", "This first loads the configuration from the yourapplication.default_settings module and then overrides the values with the contents of the file the YOURAPPLICATION_SETTINGS environment variable points to. This environment variable can be set in the shell before starting the server:", "The configuration files themselves are actual Python files. Only values in uppercase are actually stored in the config object later on. So make sure to use uppercase letters for your config keys.", "Here is an example of a configuration file:", "Make sure to load the configuration very early on, so that extensions have the ability to access the configuration when starting up. There are other methods on the config object as well to load from individual files. For a complete reference, read the Config object\u2019s documentation.", "It is also possible to load configuration from a file in a format of your choice using from_file(). For example to load from a TOML file:", "Or from a JSON file:", "In addition to pointing to configuration files using environment variables, you may find it useful (or necessary) to control your configuration values directly from the environment.", "Environment variables can be set in the shell before starting the server:", "While this approach is straightforward to use, it is important to remember that environment variables are strings \u2013 they are not automatically deserialized into Python types.", "Here is an example of a configuration file that uses environment variables:", "Notice that any value besides an empty string will be interpreted as a boolean True value in Python, which requires care if an environment explicitly sets values intended to be False.", "Make sure to load the configuration very early on, so that extensions have the ability to access the configuration when starting up. There are other methods on the config object as well to load from individual files. For a complete reference, read the Config class documentation.", "The downside with the approach mentioned earlier is that it makes testing a little harder. There is no single 100% solution for this problem in general, but there are a couple of things you can keep in mind to improve that experience:", "Most applications need more than one configuration. There should be at least separate configurations for the production server and the one used during development. The easiest way to handle this is to use a default configuration that is always loaded and part of the version control, and a separate configuration that overrides the values as necessary as mentioned in the example above:", "Then you just have to add a separate config.py file and export YOURAPPLICATION_SETTINGS=/path/to/config.py and you are done. However there are alternative ways as well. For example you could use imports or subclassing.", "What is very popular in the Django world is to make the import explicit in the config file by adding from yourapplication.default_settings\nimport * to the top of the file and then overriding the changes by hand. You could also inspect an environment variable like YOURAPPLICATION_MODE and set that to production, development etc and import different hard-coded files based on that.", "An interesting pattern is also to use classes and inheritance for configuration:", "To enable such a config you just have to call into from_object():", "Note that from_object() does not instantiate the class object. If you need to instantiate the class, such as to access a property, then you must do so before calling from_object():", "Instantiating the configuration object allows you to use @property in your configuration classes:", "There are many different ways and it\u2019s up to you how you want to manage your configuration files. However here a list of good recommendations:", "New in version 0.8.", "Flask 0.8 introduces instance folders. Flask for a long time made it possible to refer to paths relative to the application\u2019s folder directly (via Flask.root_path). This was also how many developers loaded configurations stored next to the application. Unfortunately however this only works well if applications are not packages in which case the root path refers to the contents of the package.", "With Flask 0.8 a new attribute was introduced: Flask.instance_path. It refers to a new concept called the \u201cinstance folder\u201d. The instance folder is designed to not be under version control and be deployment specific. It\u2019s the perfect place to drop things that either change at runtime or configuration files.", "You can either explicitly provide the path of the instance folder when creating the Flask application or you can let Flask autodetect the instance folder. For explicit configuration use the instance_path parameter:", "Please keep in mind that this path must be absolute when provided.", "If the instance_path parameter is not provided the following default locations are used:", "Uninstalled module:", "Uninstalled package:", "Installed module or package:", "$PREFIX is the prefix of your Python installation. This can be /usr or the path to your virtualenv. You can print the value of sys.prefix to see what the prefix is set to.", "Since the config object provided loading of configuration files from relative filenames we made it possible to change the loading via filenames to be relative to the instance path if wanted. The behavior of relative paths in config files can be flipped between \u201crelative to the application root\u201d (the default) to \u201crelative to instance folder\u201d via the instance_relative_config switch to the application constructor:", "Here is a full example of how to configure Flask to preload the config from a module and then override the config from a file in the instance folder if it exists:", "The path to the instance folder can be found via the Flask.instance_path. Flask also provides a shortcut to open a file from the instance folder with Flask.open_instance_resource().", "Example usage for both:"]}, {"name": "copy_current_request_context()", "path": "api/index#flask.copy_current_request_context", "type": "flask", "text": ["A helper function that decorates a function to retain the current request context. This is useful when working with greenlets. The moment the function is decorated a copy of the request context is created and then pushed when the function is called. The current session is also included in the copied request context.", "Example:", "New in version 0.10.", "f (Callable) \u2013 ", "Callable"]}, {"name": "DEBUG", "path": "config/index#DEBUG", "type": "Configuration", "text": ["Whether debug mode is enabled. When using flask run to start the development server, an interactive debugger will be shown for unhandled exceptions, and the server will be reloaded when code changes. The debug attribute maps to this config key. This is enabled when ENV is 'development' and is overridden by the FLASK_DEBUG environment variable. It may not behave as expected if set in code.", "Do not enable debug mode when deploying in production.", "Default: True if ENV is 'development', or False otherwise."]}, {"name": "Debugging Application Errors", "path": "debugging/index", "type": "User\u2019s Guide", "text": ["Do not run the development server, or enable the built-in debugger, in a production environment. The debugger allows executing arbitrary Python code from the browser. It\u2019s protected by a pin, but that should not be relied on for security.", "Use an error logging tool, such as Sentry, as described in Error Logging Tools, or enable logging and notifications as described in Logging.", "If you have access to the server, you could add some code to start an external debugger if request.remote_addr matches your IP. Some IDE debuggers also have a remote mode so breakpoints on the server can be interacted with locally. Only enable a debugger temporarily.", "The built-in Werkzeug development server provides a debugger which shows an interactive traceback in the browser when an unhandled error occurs during a request. This debugger should only be used during development.", "Warning", "The debugger allows executing arbitrary Python code from the browser. It is protected by a pin, but still represents a major security risk. Do not run the development server or debugger in a production environment.", "To enable the debugger, run the development server with the FLASK_ENV environment variable set to development. This puts Flask in debug mode, which changes how it handles some errors, and enables the debugger and reloader.", "FLASK_ENV can only be set as an environment variable. When running from Python code, passing debug=True enables debug mode, which is mostly equivalent. Debug mode can be controled separately from FLASK_ENV with the FLASK_DEBUG environment variable as well.", "Development Server and Command Line Interface have more information about running the debugger, debug mode, and development mode. More information about the debugger can be found in the Werkzeug documentation.", "External debuggers, such as those provided by IDEs, can offer a more powerful debugging experience than the built-in debugger. They can also be used to step through code during a request before an error is raised, or if no error is raised. Some even have a remote mode so you can debug code running on another machine.", "When using an external debugger, the app should still be in debug mode, but it can be useful to disable the built-in debugger and reloader, which can interfere.", "When running from the command line:", "When running from Python:", "Disabling these isn\u2019t required, an external debugger will continue to work with the following caveats. If the built-in debugger is not disabled, it will catch unhandled exceptions before the external debugger can. If the reloader is not disabled, it could cause an unexpected reload if code changes during debugging."]}, {"name": "Deferred Request Callbacks", "path": "patterns/deferredcallbacks/index", "type": "User's Guide: Design Patterns", "text": ["One of the design principles of Flask is that response objects are created and passed down a chain of potential callbacks that can modify them or replace them. When the request handling starts, there is no response object yet. It is created as necessary either by a view function or by some other component in the system.", "What happens if you want to modify the response at a point where the response does not exist yet? A common example for that would be a before_request() callback that wants to set a cookie on the response object.", "One way is to avoid the situation. Very often that is possible. For instance you can try to move that logic into a after_request() callback instead. However, sometimes moving code there makes it more complicated or awkward to reason about.", "As an alternative, you can use after_this_request() to register callbacks that will execute after only the current request. This way you can defer code execution from anywhere in the application, based on the current request.", "At any time during a request, we can register a function to be called at the end of the request. For example you can remember the current language of the user in a cookie in a before_request() callback:"]}, {"name": "Deploying with Fabric", "path": "patterns/fabric/index", "type": "User's Guide: Design Patterns", "text": ["Fabric is a tool for Python similar to Makefiles but with the ability to execute commands on a remote server. In combination with a properly set up Python package (Large Applications as Packages) and a good concept for configurations (Configuration Handling) it is very easy to deploy Flask applications to external servers.", "Before we get started, here a quick checklist of things we have to ensure upfront:", "A fabfile is what controls what Fabric executes. It is named fabfile.py and executed by the fab command. All the functions defined in that file will show up as fab subcommands. They are executed on one or more hosts. These hosts can be defined either in the fabfile or on the command line. In this case we will add them to the fabfile.", "This is a basic first example that has the ability to upload the current source code to the server and install it into a pre-existing virtual environment:", "Now how do you execute that fabfile? You use the fab command. To deploy the current version of the code on the remote server you would use this command:", "However this requires that our server already has the /var/www/yourapplication folder created and /var/www/yourapplication/env to be a virtual environment. Furthermore are we not creating the configuration or .wsgi file on the server. So how do we bootstrap a new server into our infrastructure?", "This now depends on the number of servers we want to set up. If we just have one application server (which the majority of applications will have), creating a command in the fabfile for this is overkill. But obviously you can do that. In that case you would probably call it setup or bootstrap and then pass the servername explicitly on the command line:", "To setup a new server you would roughly do these steps:", "Create the directory structure in /var/www:", "So now the question is, where do the application.wsgi and application.cfg files come from?", "The WSGI file has to import the application and also to set an environment variable so that the application knows where to look for the config. This is a short example that does exactly that:", "The application itself then has to initialize itself like this to look for the config at that environment variable:", "This approach is explained in detail in the Configuration Handling section of the documentation.", "Now as mentioned above, the application will find the correct configuration file by looking up the YOURAPPLICATION_CONFIG environment variable. So we have to put the configuration in a place where the application will able to find it. Configuration files have the unfriendly quality of being different on all computers, so you do not version them usually.", "A popular approach is to store configuration files for different servers in a separate version control repository and check them out on all servers. Then symlink the file that is active for the server into the location where it\u2019s expected (eg: /var/www/yourapplication).", "Either way, in our case here we only expect one or two servers and we can upload them ahead of time by hand.", "Now we can do our first deployment. We have set up the servers so that they have their virtual environments and activated apache configs. Now we can pack up the application and deploy it:", "Fabric will now connect to all servers and run the commands as written down in the fabfile. First it will execute pack so that we have our tarball ready and then it will execute deploy and upload the source code to all servers and install it there. Thanks to the setup.py file we will automatically pull in the required libraries into our virtual environment.", "From that point onwards there is so much that can be done to make deployment actually fun:", "Working with Fabric is fun and you will notice that it\u2019s quite magical to type fab deploy and see your application being deployed automatically to one or more remote servers."]}, {"name": "Deploying with Setuptools", "path": "patterns/distribute/index", "type": "User's Guide: Design Patterns", "text": ["Setuptools, is an extension library that is commonly used to distribute Python libraries and extensions. It extends distutils, a basic module installation system shipped with Python to also support various more complex constructs that make larger applications easier to distribute:", "Flask itself, and all the libraries you can find on PyPI are distributed with either setuptools or distutils.", "In this case we assume your application is called yourapplication.py and you are not using a module, but a package. If you have not yet converted your application into a package, head over to Large Applications as Packages to see how this can be done.", "A working deployment with setuptools is the first step into more complex and more automated deployment scenarios. If you want to fully automate the process, also read the Deploying with Fabric chapter.", "Because you have Flask installed, you have setuptools available on your system. Flask already depends upon setuptools.", "Standard disclaimer applies: use a virtualenv.", "Your setup code always goes into a file named setup.py next to your application. The name of the file is only convention, but because everybody will look for a file with that name, you better not change it.", "A basic setup.py file for a Flask application looks like this:", "Please keep in mind that you have to list subpackages explicitly. If you want setuptools to lookup the packages for you automatically, you can use the find_packages function:", "Most parameters to the setup function should be self explanatory, include_package_data and zip_safe might not be. include_package_data tells setuptools to look for a MANIFEST.in file and install all the entries that match as package data. We will use this to distribute the static files and templates along with the Python module (see Distributing Resources). The zip_safe flag can be used to force or prevent zip Archive creation. In general you probably don\u2019t want your packages to be installed as zip files because some tools do not support them and they make debugging a lot harder.", "It is useful to distinguish between release and development builds. Add a setup.cfg file to configure these options.", "Running python setup.py sdist will create a development package with \u201c.dev\u201d and the current date appended: flaskr-1.0.dev20160314.tar.gz. Running python setup.py release sdist will create a release package with only the version: flaskr-1.0.tar.gz.", "If you try to install the package you just created, you will notice that folders like static or templates are not installed for you. The reason for this is that setuptools does not know which files to add for you. What you should do, is to create a MANIFEST.in file next to your setup.py file. This file lists all the files that should be added to your tarball:", "Don\u2019t forget that even if you enlist them in your MANIFEST.in file, they won\u2019t be installed for you unless you set the include_package_data parameter of the setup function to True!", "Dependencies are declared in the install_requires parameter as a list. Each item in that list is the name of a package that should be pulled from PyPI on installation. By default it will always use the most recent version, but you can also provide minimum and maximum version requirements. Here some examples:", "As mentioned earlier, dependencies are pulled from PyPI. What if you want to depend on a package that cannot be found on PyPI and won\u2019t be because it is an internal package you don\u2019t want to share with anyone? Just do it as if there was a PyPI entry and provide a list of alternative locations where setuptools should look for tarballs:", "Make sure that page has a directory listing and the links on the page are pointing to the actual tarballs with their correct filenames as this is how setuptools will find the files. If you have an internal company server that contains the packages, provide the URL to that server.", "To install your application (ideally into a virtualenv) just run the setup.py script with the install parameter. It will install your application into the virtualenv\u2019s site-packages folder and also download and install all dependencies:", "If you are developing on the package and also want the requirements to be installed, you can use the develop command instead:", "This has the advantage of just installing a link to the site-packages folder instead of copying the data over. You can then continue to work on the code without having to run install again after each change."]}, {"name": "Deployment Options", "path": "deploying/index", "type": "User's Guide: Deploying", "text": ["While lightweight and easy to use, Flask\u2019s built-in server is not suitable for production as it doesn\u2019t scale well. Some of the options available for properly running Flask in production are documented here.", "If you want to deploy your Flask application to a WSGI server not listed here, look up the server documentation about how to use a WSGI app with it. Just remember that your Flask application object is the actual WSGI application."]}, {"name": "Design Decisions in Flask", "path": "design/index", "type": "Additional Notes", "text": ["If you are curious why Flask does certain things the way it does and not differently, this section is for you. This should give you an idea about some of the design decisions that may appear arbitrary and surprising at first, especially in direct comparison with other frameworks.", "A Python web application based on WSGI has to have one central callable object that implements the actual application. In Flask this is an instance of the Flask class. Each Flask application has to create an instance of this class itself and pass it the name of the module, but why can\u2019t Flask do that itself?", "Without such an explicit application object the following code:", "Would look like this instead:", "There are three major reasons for this. The most important one is that implicit application objects require that there may only be one instance at the time. There are ways to fake multiple applications with a single application object, like maintaining a stack of applications, but this causes some problems I won\u2019t outline here in detail. Now the question is: when does a microframework need more than one application at the same time? A good example for this is unit testing. When you want to test something it can be very helpful to create a minimal application to test specific behavior. When the application object is deleted everything it allocated will be freed again.", "Another thing that becomes possible when you have an explicit object lying around in your code is that you can subclass the base class (Flask) to alter specific behavior. This would not be possible without hacks if the object were created ahead of time for you based on a class that is not exposed to you.", "But there is another very important reason why Flask depends on an explicit instantiation of that class: the package name. Whenever you create a Flask instance you usually pass it __name__ as package name. Flask depends on that information to properly load resources relative to your module. With Python\u2019s outstanding support for reflection it can then access the package to figure out where the templates and static files are stored (see open_resource()). Now obviously there are frameworks around that do not need any configuration and will still be able to load templates relative to your application module. But they have to use the current working directory for that, which is a very unreliable way to determine where the application is. The current working directory is process-wide and if you are running multiple applications in one process (which could happen in a webserver without you knowing) the paths will be off. Worse: many webservers do not set the working directory to the directory of your application but to the document root which does not have to be the same folder.", "The third reason is \u201cexplicit is better than implicit\u201d. That object is your WSGI application, you don\u2019t have to remember anything else. If you want to apply a WSGI middleware, just wrap it and you\u2019re done (though there are better ways to do that so that you do not lose the reference to the application object wsgi_app()).", "Furthermore this design makes it possible to use a factory function to create the application which is very helpful for unit testing and similar things (Application Factories).", "Flask uses the Werkzeug routing system which was designed to automatically order routes by complexity. This means that you can declare routes in arbitrary order and they will still work as expected. This is a requirement if you want to properly implement decorator based routing since decorators could be fired in undefined order when the application is split into multiple modules.", "Another design decision with the Werkzeug routing system is that routes in Werkzeug try to ensure that URLs are unique. Werkzeug will go quite far with that in that it will automatically redirect to a canonical URL if a route is ambiguous.", "Flask decides on one template engine: Jinja2. Why doesn\u2019t Flask have a pluggable template engine interface? You can obviously use a different template engine, but Flask will still configure Jinja2 for you. While that limitation that Jinja2 is always configured will probably go away, the decision to bundle one template engine and use that will not.", "Template engines are like programming languages and each of those engines has a certain understanding about how things work. On the surface they all work the same: you tell the engine to evaluate a template with a set of variables and take the return value as string.", "But that\u2019s about where similarities end. Jinja2 for example has an extensive filter system, a certain way to do template inheritance, support for reusable blocks (macros) that can be used from inside templates and also from Python code, supports iterative template rendering, configurable syntax and more. On the other hand an engine like Genshi is based on XML stream evaluation, template inheritance by taking the availability of XPath into account and more. Mako on the other hand treats templates similar to Python modules.", "When it comes to connecting a template engine with an application or framework there is more than just rendering templates. For instance, Flask uses Jinja2\u2019s extensive autoescaping support. Also it provides ways to access macros from Jinja2 templates.", "A template abstraction layer that would not take the unique features of the template engines away is a science on its own and a too large undertaking for a microframework like Flask.", "Furthermore extensions can then easily depend on one template language being present. You can easily use your own templating language, but an extension could still depend on Jinja itself.", "Why does Flask call itself a microframework and yet it depends on two libraries (namely Werkzeug and Jinja2). Why shouldn\u2019t it? If we look over to the Ruby side of web development there we have a protocol very similar to WSGI. Just that it\u2019s called Rack there, but besides that it looks very much like a WSGI rendition for Ruby. But nearly all applications in Ruby land do not work with Rack directly, but on top of a library with the same name. This Rack library has two equivalents in Python: WebOb (formerly Paste) and Werkzeug. Paste is still around but from my understanding it\u2019s sort of deprecated in favour of WebOb. The development of WebOb and Werkzeug started side by side with similar ideas in mind: be a good implementation of WSGI for other applications to take advantage.", "Flask is a framework that takes advantage of the work already done by Werkzeug to properly interface WSGI (which can be a complex task at times). Thanks to recent developments in the Python package infrastructure, packages with dependencies are no longer an issue and there are very few reasons against having libraries that depend on others.", "Flask uses thread local objects (context local objects in fact, they support greenlet contexts as well) for request, session and an extra object you can put your own things on (g). Why is that and isn\u2019t that a bad idea?", "Yes it is usually not such a bright idea to use thread locals. They cause troubles for servers that are not based on the concept of threads and make large applications harder to maintain. However Flask is just not designed for large applications or asynchronous servers. Flask wants to make it quick and easy to write a traditional web application.", "Also see the Becoming Big section of the documentation for some inspiration for larger applications based on Flask.", "Flask supports async coroutines for view functions by executing the coroutine on a separate thread instead of using an event loop on the main thread as an async-first (ASGI) framework would. This is necessary for Flask to remain backwards compatible with extensions and code built before async was introduced into Python. This compromise introduces a performance cost compared with the ASGI frameworks, due to the overhead of the threads.", "Due to how tied to WSGI Flask\u2019s code is, it\u2019s not clear if it\u2019s possible to make the Flask class support ASGI and WSGI at the same time. Work is currently being done in Werkzeug to work with ASGI, which may eventually enable support in Flask as well.", "See Using async and await for more discussion.", "Flask will never have a database layer. It will not have a form library or anything else in that direction. Flask itself just bridges to Werkzeug to implement a proper WSGI application and to Jinja2 to handle templating. It also binds to a few common standard library packages such as logging. Everything else is up for extensions.", "Why is this the case? Because people have different preferences and requirements and Flask could not meet those if it would force any of this into the core. The majority of web applications will need a template engine in some sort. However not every application needs a SQL database.", "The idea of Flask is to build a good foundation for all applications. Everything else is up to you or extensions."]}, {"name": "Development Server", "path": "server/index", "type": "User\u2019s Guide", "text": ["Flask provides a run command to run the application with a development server. In development mode, this server provides an interactive debugger and will reload when code is changed.", "Warning", "Do not use the development server when deploying to production. It is intended for use only during local development. It is not designed to be particularly efficient, stable, or secure.", "See Deployment Options for deployment options.", "The flask run command line script is the recommended way to run the development server. It requires setting the FLASK_APP environment variable to point to your application, and FLASK_ENV=development to fully enable development mode.", "This enables the development environment, including the interactive debugger and reloader, and then starts the server on http://localhost:5000/. Use flask run --help to see the available options, and Command Line Interface for detailed instructions about configuring and using the CLI.", "Note", "Prior to Flask 1.0 the FLASK_ENV environment variable was not supported and you needed to enable debug mode by exporting FLASK_DEBUG=1. This can still be used to control debug mode, but you should prefer setting the development environment as shown above.", "When using the flask run command with the reloader, the server will continue to run even if you introduce syntax errors or other initialization errors into the code. Accessing the site will show the interactive debugger for the error, rather than crashing the server. This feature is called \u201clazy loading\u201d.", "If a syntax error is already present when calling flask run, it will fail immediately and show the traceback rather than waiting until the site is accessed. This is intended to make errors more visible initially while still allowing the server to handle errors on reload.", "To override this behavior and always fail immediately, even on reload, pass the --eager-loading option. To always keep the server running, even on the initial call, pass --lazy-loading.", "As an alternative to the flask run command, the development server can also be started from Python with the Flask.run() method. This method takes arguments similar to the CLI options to control the server. The main difference from the CLI command is that the server will crash if there are errors when reloading.", "debug=True can be passed to enable the debugger and reloader, but the FLASK_ENV=development environment variable is still required to fully enable development mode.", "Place the call in a main block, otherwise it will interfere when trying to import and run the application with a production server later."]}, {"name": "dump()", "path": "api/index#flask.json.dump", "type": "flask.json", "text": ["Serialize an object to JSON written to a file object.", "Takes the same arguments as the built-in json.dump(), with some defaults from application configuration.", "None", "Changed in version 2.0: Writing to a binary file, and the encoding argument, is deprecated and will be removed in Flask 2.1."]}, {"name": "dumps()", "path": "api/index#flask.json.dumps", "type": "flask.json", "text": ["Serialize an object to a string of JSON.", "Takes the same arguments as the built-in json.dumps(), with some defaults from application configuration.", "str", "Changed in version 2.0: encoding is deprecated and will be removed in Flask 2.1.", "Changed in version 1.0.3: app can be passed directly, rather than requiring an app context for configuration."]}, {"name": "ENV", "path": "config/index#ENV", "type": "Configuration", "text": ["What environment the app is running in. Flask and extensions may enable behaviors based on the environment, such as enabling debug mode. The env attribute maps to this config key. This is set by the FLASK_ENV environment variable and may not behave as expected if set in code.", "Do not enable development when deploying in production.", "Default: 'production'", "New in version 1.0."]}, {"name": "escape()", "path": "api/index#flask.escape", "type": "flask", "text": ["Replace the characters &, <, >, ', and \" in the string with HTML-safe sequences. Use this if you need to display text that might contain such characters in HTML.", "If the object has an __html__ method, it is called and the return value is assumed to already be safe for HTML.", "s \u2013 An object to be converted to a string and escaped.", "A Markup string with the escaped text."]}, {"name": "EXPLAIN_TEMPLATE_LOADING", "path": "config/index#EXPLAIN_TEMPLATE_LOADING", "type": "Configuration", "text": ["Log debugging information tracing how a template file was loaded. This can be useful to figure out why a template was not loaded or the wrong file appears to be loaded.", "Default: False"]}, {"name": "Extensions", "path": "extensions/index", "type": "User\u2019s Guide", "text": ["Extensions are extra packages that add functionality to a Flask application. For example, an extension might add support for sending email or connecting to a database. Some extensions add entire new frameworks to help build certain types of applications, like a REST API.", "Flask extensions are usually named \u201cFlask-Foo\u201d or \u201cFoo-Flask\u201d. You can search PyPI for packages tagged with Framework :: Flask.", "Consult each extension\u2019s documentation for installation, configuration, and usage instructions. Generally, extensions pull their own configuration from app.config and are passed an application instance during initialization. For example, an extension called \u201cFlask-Foo\u201d might be used like this:", "While the PyPI contains many Flask extensions, you may not find an extension that fits your need. If this is the case, you can create your own. Read Flask Extension Development to develop your own Flask extension."]}, {"name": "FastCGI", "path": "deploying/fastcgi/index", "type": "User's Guide: Deploying", "text": ["FastCGI is a deployment option on servers like nginx, lighttpd, and cherokee; see uWSGI and Standalone WSGI Containers for other options. To use your WSGI application with any of them you will need a FastCGI server first. The most popular one is flup which we will use for this guide. Make sure to have it installed to follow along.", "Watch Out", "Please make sure in advance that any app.run() calls you might have in your application file are inside an if __name__ ==\n'__main__': block or moved to a separate file. Just make sure it\u2019s not called because this will always start a local WSGI server which we do not want if we deploy that application to FastCGI.", "First you need to create the FastCGI server file. Let\u2019s call it yourapplication.fcgi:", "This is enough for Apache to work, however nginx and older versions of lighttpd need a socket to be explicitly passed to communicate with the FastCGI server. For that to work you need to pass the path to the socket to the WSGIServer:", "The path has to be the exact same path you define in the server config.", "Save the yourapplication.fcgi file somewhere you will find it again. It makes sense to have that in /var/www/yourapplication or something similar.", "Make sure to set the executable bit on that file so that the servers can execute it:", "The example above is good enough for a basic Apache deployment but your .fcgi file will appear in your application URL e.g. example.com/yourapplication.fcgi/news/. There are few ways to configure your application so that yourapplication.fcgi does not appear in the URL. A preferable way is to use the ScriptAlias and SetHandler configuration directives to route requests to the FastCGI server. The following example uses FastCgiServer to start 5 instances of the application which will handle all incoming requests:", "These processes will be managed by Apache. If you\u2019re using a standalone FastCGI server, you can use the FastCgiExternalServer directive instead. Note that in the following the path is not real, it\u2019s simply used as an identifier to other directives such as AliasMatch:", "If you cannot set ScriptAlias, for example on a shared web host, you can use WSGI middleware to remove yourapplication.fcgi from the URLs. Set .htaccess:", "Set yourapplication.fcgi:", "A basic FastCGI configuration for lighttpd looks like that:", "Remember to enable the FastCGI, alias and rewrite modules. This configuration binds the application to /yourapplication. If you want the application to work in the URL root you have to work around a lighttpd bug with the LighttpdCGIRootFix middleware.", "Make sure to apply it only if you are mounting the application the URL root. Also, see the Lighty docs for more information on FastCGI and Python (note that explicitly passing a socket to run() is no longer necessary).", "Installing FastCGI applications on nginx is a bit different because by default no FastCGI parameters are forwarded.", "A basic Flask FastCGI configuration for nginx looks like this:", "This configuration binds the application to /yourapplication. If you want to have it in the URL root it\u2019s a bit simpler because you don\u2019t have to figure out how to calculate PATH_INFO and SCRIPT_NAME:", "Since nginx and others do not load FastCGI apps, you have to do it by yourself. Supervisor can manage FastCGI processes. You can look around for other FastCGI process managers or write a script to run your .fcgi file at boot, e.g. using a SysV init.d script. For a temporary solution, you can always run the .fcgi script inside GNU screen. See man screen for details, and note that this is a manual solution which does not persist across system restart:", "FastCGI deployments tend to be hard to debug on most web servers. Very often the only thing the server log tells you is something along the lines of \u201cpremature end of headers\u201d. In order to debug the application the only thing that can really give you ideas why it breaks is switching to the correct user and executing the application by hand.", "This example assumes your application is called application.fcgi and that your web server user is www-data:", "In this case the error seems to be \u201cyourapplication\u201d not being on the python path. Common problems are:"]}, {"name": "flash()", "path": "api/index#flask.flash", "type": "flask", "text": ["Flashes a message to the next request. In order to remove the flashed message from the session and to display it to the user, the template has to call get_flashed_messages().", "Changed in version 0.3: category parameter added.", "None"]}, {"name": "Flask", "path": "api/index#flask.Flask", "type": "flask", "text": ["The flask object implements a WSGI application and acts as the central object. It is passed the name of the module or package of the application. Once it is created it will act as a central registry for the view functions, the URL rules, template configuration and much more.", "The name of the package is used to resolve resources from inside the package or the folder the module is contained in depending on if the package parameter resolves to an actual python package (a folder with an __init__.py file inside) or a standard module (just a .py file).", "For more information about resource loading, see open_resource().", "Usually you create a Flask instance in your main module or in the __init__.py file of your package like this:", "About the First Parameter", "The idea of the first parameter is to give Flask an idea of what belongs to your application. This name is used to find resources on the filesystem, can be used by extensions to improve debugging information and a lot more.", "So it\u2019s important what you provide there. If you are using a single module, __name__ is always the correct value. If you however are using a package, it\u2019s usually recommended to hardcode the name of your package there.", "For example if your application is defined in yourapplication/app.py you should create it with one of the two versions below:", "Why is that? The application will work even with __name__, thanks to how resources are looked up. However it will make debugging more painful. Certain extensions can make assumptions based on the import name of your application. For example the Flask-SQLAlchemy extension will look for the code in your application that triggered an SQL query in debug mode. If the import name is not properly set up, that debugging information is lost. (For example it would only pick up SQL queries in yourapplication.app and not yourapplication.views.frontend)", "New in version 1.0: The host_matching and static_host parameters were added.", "New in version 1.0: The subdomain_matching parameter was added. Subdomain matching needs to be enabled manually now. Setting SERVER_NAME does not implicitly enable it.", "New in version 0.11: The root_path parameter was added.", "New in version 0.8: The instance_path and instance_relative_config parameters were added.", "New in version 0.7: The static_url_path, static_folder, and template_folder parameters were added.", "Register a custom template filter. Works exactly like the template_filter() decorator.", "None", "Register a custom template global function. Works exactly like the template_global() decorator.", "New in version 0.10.", "None", "Register a custom template test. Works exactly like the template_test() decorator.", "New in version 0.10.", "None", "Register a rule for routing incoming requests and building URLs. The route() decorator is a shortcut to call this with the view_func argument. These are equivalent:", "See URL Route Registrations.", "The endpoint name for the route defaults to the name of the view function if the endpoint parameter isn\u2019t passed. An error will be raised if a function has already been registered for the endpoint.", "The methods parameter defaults to [\"GET\"]. HEAD is always added automatically, and OPTIONS is added automatically by default.", "view_func does not necessarily need to be passed, but if the rule should participate in routing an endpoint name must be associated with a view function at some point with the endpoint() decorator.", "If view_func has a required_methods attribute, those methods are added to the passed and automatic methods. If it has a provide_automatic_methods attribute, it is used as the default if the parameter is not passed.", "None", "Register a function to run after each request to this object.", "The function is called with the response object, and must return a response object. This allows the functions to modify or replace the response before it is sent.", "If a function raises an exception, any remaining after_request functions will not be called. Therefore, this should not be used for actions that must execute, such as to close resources. Use teardown_request() for that.", "f (Callable[[Response], Response]) \u2013 ", "Callable[[Response], Response]", "A data structure of functions to call at the end of each request, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests.", "To register a function, use the after_request() decorator.", "This data structure is internal. It should not be modified directly and its format may change at any time.", "Create an AppContext. Use as a with block to push the context, which will make current_app point at this application.", "An application context is automatically pushed by RequestContext.push() when handling a request, and when running a CLI command. Use this to manually create a context outside of these situations.", "See The Application Context.", "New in version 0.9.", "flask.ctx.AppContext", "alias of flask.ctx._AppCtxGlobals", "Return a sync function that will run the coroutine function.", "Override this method to change how the app converts async code to be synchronously callable.", "New in version 2.0.", "func (Callable[[...], Coroutine]) \u2013 ", "Callable[[\u2026], Any]", "Tries to locate the instance path if it was not provided to the constructor of the application class. It will basically calculate the path to a folder named instance next to your main file or the package.", "New in version 0.8.", "str", "Registers a function to be run before the first request to this instance of the application.", "The function will be called without any arguments and its return value is ignored.", "New in version 0.8.", "f (Callable[[], None]) \u2013 ", "Callable[[], None]", "A list of functions that will be called at the beginning of the first request to this instance. To register a function, use the before_first_request() decorator.", "New in version 0.8.", "Register a function to run before each request.", "For example, this can be used to open a database connection, or to load the logged in user from the session.", "The function will be called without any arguments. If it returns a non-None value, the value is handled as if it was the return value from the view, and further request handling is stopped.", "f (Callable[[], None]) \u2013 ", "Callable[[], None]", "A data structure of functions to call at the beginning of each request, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests.", "To register a function, use the before_request() decorator.", "This data structure is internal. It should not be modified directly and its format may change at any time.", "Maps registered blueprint names to blueprint objects. The dict retains the order the blueprints were registered in. Blueprints can be registered multiple times, this dict does not track how often they were attached.", "New in version 0.7.", "The Click command group for registering CLI commands for this object. The commands are available from the flask command once the application has been discovered and blueprints have been registered.", "The configuration dictionary as Config. This behaves exactly like a regular dictionary but supports additional methods to load a config from files.", "alias of flask.config.Config", "Registers a template context processor function.", "f (Callable[[], Dict[str, Any]]) \u2013 ", "Callable[[], Dict[str, Any]]", "Creates the loader for the Jinja2 environment. Can be used to override just the loader and keeping the rest unchanged. It\u2019s discouraged to override this function. Instead one should override the jinja_loader() function instead.", "The global loader dispatches between the loaders of the application and the individual blueprints.", "New in version 0.7.", "flask.templating.DispatchingJinjaLoader", "Create the Jinja environment based on jinja_options and the various Jinja-related methods of the app. Changing jinja_options after this will have no effect. Also adds Flask-related globals and filters to the environment.", "Changed in version 0.11: Environment.auto_reload set in accordance with TEMPLATES_AUTO_RELOAD configuration option.", "New in version 0.5.", "flask.templating.Environment", "Creates a URL adapter for the given request. The URL adapter is created at a point where the request context is not yet set up so the request is passed explicitly.", "Changed in version 1.0: SERVER_NAME no longer implicitly enables subdomain matching. Use subdomain_matching instead.", "Changed in version 0.9: This can now also be called without a request object when the URL adapter is created for the application context.", "New in version 0.6.", "request (Optional[flask.wrappers.Request]) \u2013 ", "Optional[werkzeug.routing.MapAdapter]", "Whether debug mode is enabled. When using flask run to start the development server, an interactive debugger will be shown for unhandled exceptions, and the server will be reloaded when code changes. This maps to the DEBUG config key. This is enabled when env is 'development' and is overridden by the FLASK_DEBUG environment variable. It may not behave as expected if set in code.", "Do not enable debug mode when deploying in production.", "Default: True if env is 'development', or False otherwise.", "Default configuration parameters.", "Shortcut for route() with methods=[\"DELETE\"].", "New in version 2.0.", "Callable", "Does the request dispatching. Matches the URL and returns the return value of the view or error handler. This does not have to be a response object. In order to convert the return value to a proper response object, call make_response().", "Changed in version 0.7: This no longer does the exception handling, this code was moved to the new full_dispatch_request().", "Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], WSGIApplication]", "Called right before the application context is popped.", "When handling a request, the application context is popped after the request context. See do_teardown_request().", "This calls all functions decorated with teardown_appcontext(). Then the appcontext_tearing_down signal is sent.", "This is called by AppContext.pop().", "New in version 0.9.", "exc (Optional[BaseException]) \u2013 ", "None", "Called after the request is dispatched and the response is returned, right before the request context is popped.", "This calls all functions decorated with teardown_request(), and Blueprint.teardown_request() if a blueprint handled the request. Finally, the request_tearing_down signal is sent.", "This is called by RequestContext.pop(), which may be delayed during testing to maintain access to resources.", "exc (Optional[BaseException]) \u2013 An unhandled exception raised while dispatching the request. Detected from the current exception information if not passed. Passed to each teardown function.", "None", "Changed in version 0.9: Added the exc argument.", "Decorate a view function to register it for the given endpoint. Used if a rule is added without a view_func with add_url_rule().", "endpoint (str) \u2013 The endpoint name to associate with the view function.", "Callable", "Ensure that the function is synchronous for WSGI workers. Plain def functions are returned as-is. async def functions are wrapped to run and wait for the response.", "Override this method to change how the app runs async views.", "New in version 2.0.", "func (Callable) \u2013 ", "Callable", "What environment the app is running in. Flask and extensions may enable behaviors based on the environment, such as enabling debug mode. This maps to the ENV config key. This is set by the FLASK_ENV environment variable and may not behave as expected if set in code.", "Do not enable development when deploying in production.", "Default: 'production'", "A data structure of registered error handlers, in the format {scope: {code: {class: handler}}}`. The scope key is the name of a blueprint the handlers are active for, or None for all requests. The code key is the HTTP status code for HTTPException, or None for other exceptions. The innermost dictionary maps exception classes to handler functions.", "To register an error handler, use the errorhandler() decorator.", "This data structure is internal. It should not be modified directly and its format may change at any time.", "Register a function to handle errors by code or exception class.", "A decorator that is used to register a function given an error code. Example:", "You can also register handlers for arbitrary exceptions:", "New in version 0.7: Use register_error_handler() instead of modifying error_handler_spec directly, for application wide error handlers.", "New in version 0.7: One can now additionally also register custom exception types that do not necessarily have to be a subclass of the HTTPException class.", "code_or_exception (Union[Type[Exception], int]) \u2013 the code as integer for the handler, or an arbitrary exception", "Callable", "a place where extensions can store application specific state. For example this is where an extension could store database engines and similar things.", "The key must match the name of the extension module. For example in case of a \u201cFlask-Foo\u201d extension in flask_foo, the key would be 'foo'.", "New in version 0.7.", "Dispatches the request and on top of that performs request pre and postprocessing as well as HTTP exception catching and error handling.", "New in version 0.7.", "flask.wrappers.Response", "Shortcut for route() with methods=[\"GET\"].", "New in version 2.0.", "Callable", "Used by send_file() to determine the max_age cache value for a given file path if it wasn\u2019t passed.", "By default, this returns SEND_FILE_MAX_AGE_DEFAULT from the configuration of current_app. This defaults to None, which tells the browser to use conditional requests instead of a timed cache, which is usually preferable.", "Changed in version 2.0: The default configuration is None instead of 12 hours.", "New in version 0.9.", "filename (str) \u2013 ", "Optional[int]", "This attribute is set to True if the application started handling the first request.", "New in version 0.8.", "Handle an exception that did not have an error handler associated with it, or that was raised from an error handler. This always causes a 500 InternalServerError.", "Always sends the got_request_exception signal.", "If propagate_exceptions is True, such as in debug mode, the error will be re-raised so that the debugger can display it. Otherwise, the original exception is logged, and an InternalServerError is returned.", "If an error handler is registered for InternalServerError or 500, it will be used. For consistency, the handler will always receive the InternalServerError. The original unhandled exception is available as e.original_exception.", "Changed in version 1.1.0: Always passes the InternalServerError instance to the handler, setting original_exception to the unhandled error.", "Changed in version 1.1.0: after_request functions and other finalization is done even for the default 500 response when there is no handler.", "New in version 0.3.", "e (Exception) \u2013 ", "flask.wrappers.Response", "Handles an HTTP exception. By default this will invoke the registered error handlers and fall back to returning the exception as response.", "Changed in version 1.0.3: RoutingException, used internally for actions such as slash redirects during routing, is not passed to error handlers.", "Changed in version 1.0: Exceptions are looked up by code and by MRO, so HTTPExcpetion subclasses can be handled with a catch-all handler for the base HTTPException.", "New in version 0.3.", "e (werkzeug.exceptions.HTTPException) \u2013 ", "Union[werkzeug.exceptions.HTTPException, Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], WSGIApplication]", "Handle BuildError on url_for().", "str", "This method is called whenever an exception occurs that should be handled. A special case is HTTPException which is forwarded to the handle_http_exception() method. This function will either return a response value or reraise the exception with the same traceback.", "Changed in version 1.0: Key errors raised from request data like form show the bad key in debug mode rather than a generic bad request message.", "New in version 0.7.", "e (Exception) \u2013 ", "Union[werkzeug.exceptions.HTTPException, Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], WSGIApplication]", "True if static_folder is set.", "New in version 0.5.", "The name of the package or module that this object belongs to. Do not change this once it is set by the constructor.", "Injects the URL defaults for the given endpoint directly into the values dictionary passed. This is used internally and automatically called on URL building.", "New in version 0.7.", "None", "Holds the path to the instance folder.", "New in version 0.8.", "Iterates over all blueprints by the order they were registered.", "New in version 0.11.", "ValuesView[Blueprint]", "The Jinja environment used to load templates.", "The environment is created the first time this property is accessed. Changing jinja_options after that will have no effect.", "alias of flask.templating.Environment", "The Jinja loader for this object\u2019s templates. By default this is a class jinja2.loaders.FileSystemLoader to template_folder if it is set.", "New in version 0.5.", "Options that are passed to the Jinja environment in create_jinja_environment(). Changing these options after the environment is created (accessing jinja_env) will have no effect.", "Changed in version 1.1.0: This is a dict instead of an ImmutableDict to allow easier configuration.", "alias of flask.json.JSONDecoder", "alias of flask.json.JSONEncoder", "Logs an exception. This is called by handle_exception() if debugging is disabled and right before the handler is called. The default implementation logs the exception as error on the logger.", "New in version 0.8.", "exc_info (Union[Tuple[type, BaseException, types.TracebackType], Tuple[None, None, None]]) \u2013 ", "None", "A standard Python Logger for the app, with the same name as name.", "In debug mode, the logger\u2019s level will be set to DEBUG.", "If there are no handlers configured, a default handler will be added. See Logging for more information.", "Changed in version 1.1.0: The logger takes the same name as name rather than hard-coding \"flask.app\".", "Changed in version 1.0.0: Behavior was simplified. The logger is always named \"flask.app\". The level is only set during configuration, it doesn\u2019t check app.debug each time. Only one format is used, not different ones depending on app.debug. No handlers are removed, and a handler is only added if no handlers are already configured.", "New in version 0.3.", "Used to create the config attribute by the Flask constructor. The instance_relative parameter is passed in from the constructor of Flask (there named instance_relative_config) and indicates if the config should be relative to the instance path or the root path of the application.", "New in version 0.8.", "instance_relative (bool) \u2013 ", "flask.config.Config", "This method is called to create the default OPTIONS response. This can be changed through subclassing to change the default behavior of OPTIONS responses.", "New in version 0.7.", "flask.wrappers.Response", "Convert the return value from a view function to an instance of response_class.", "rv (Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], Union[Headers, Dict[str, Union[str, List[str], Tuple[str, ...]]], List[Tuple[str, Union[str, List[str], Tuple[str, ...]]]]]], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, ...]]], List[Tuple[str, Union[str, List[str], Tuple[str, ...]]]]]], WSGIApplication]) \u2013 ", "the return value from the view function. The view function must return a response. Returning None, or the view ending without returning, is not allowed. The following types are allowed for view_rv:", "A response object is created with the string encoded to UTF-8 as the body.", "A response object is created with the bytes as the body.", "A dictionary that will be jsonify\u2019d before being returned.", "Either (body, status, headers), (body, status), or (body, headers), where body is any of the other types allowed here, status is a string or an integer, and headers is a dictionary or a list of (key, value) tuples. If body is a response_class instance, status overwrites the exiting value and headers are extended.", "The object is returned unchanged.", "The object is coerced to response_class.", "The function is called as a WSGI application. The result is used to create a response object.", "flask.wrappers.Response", "Changed in version 0.9: Previously a tuple was interpreted as the arguments for the response object.", "Returns the shell context for an interactive shell for this application. This runs all the registered shell context processors.", "New in version 0.11.", "dict", "The name of the application. This is usually the import name with the difference that it\u2019s guessed from the run file if the import name is main. This name is used as a display name when Flask needs the name of the application. It can be set and overridden to change the value.", "New in version 0.8.", "Opens a resource from the application\u2019s instance folder (instance_path). Otherwise works like open_resource(). Instance resources can also be opened for writing.", "IO", "Open a resource file relative to root_path for reading.", "For example, if the file schema.sql is next to the file app.py where the Flask app is defined, it can be opened with:", "IO", "Shortcut for route() with methods=[\"PATCH\"].", "New in version 2.0.", "Callable", "A timedelta which is used to set the expiration date of a permanent session. The default is 31 days which makes a permanent session survive for roughly one month.", "This attribute can also be configured from the config with the PERMANENT_SESSION_LIFETIME configuration key. Defaults to timedelta(days=31)", "Shortcut for route() with methods=[\"POST\"].", "New in version 2.0.", "Callable", "Called before the request is dispatched. Calls url_value_preprocessors registered with the app and the current blueprint (if any). Then calls before_request_funcs registered with the app and the blueprint.", "If any before_request() handler returns a non-None value, the value is handled as if it was the return value from the view, and further request handling is stopped.", "Optional[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], WSGIApplication]]", "Returns the value of the PRESERVE_CONTEXT_ON_EXCEPTION configuration value in case it\u2019s set, otherwise a sensible default is returned.", "New in version 0.7.", "Can be overridden in order to modify the response object before it\u2019s sent to the WSGI server. By default this will call all the after_request() decorated functions.", "Changed in version 0.5: As of Flask 0.5 the functions registered for after request execution are called in reverse order of registration.", "response (flask.wrappers.Response) \u2013 a response_class object.", "a new response object or the same, has to be an instance of response_class.", "flask.wrappers.Response", "Returns the value of the PROPAGATE_EXCEPTIONS configuration value in case it\u2019s set, otherwise a sensible default is returned.", "New in version 0.7.", "Shortcut for route() with methods=[\"PUT\"].", "New in version 2.0.", "Callable", "Register a Blueprint on the application. Keyword arguments passed to this method will override the defaults set on the blueprint.", "Calls the blueprint\u2019s register() method after recording the blueprint in the application\u2019s blueprints.", "None", "New in version 0.7.", "Alternative error attach function to the errorhandler() decorator that is more straightforward to use for non decorator usage.", "New in version 0.7.", "None", "alias of flask.wrappers.Request", "Create a RequestContext representing a WSGI environment. Use a with block to push the context, which will make request point at this request.", "See The Request Context.", "Typically you should not call this from your own code. A request context is automatically pushed by the wsgi_app() when handling a request. Use test_request_context() to create an environment and context instead of this method.", "environ (dict) \u2013 a WSGI environment", "flask.ctx.RequestContext", "alias of flask.wrappers.Response", "Absolute path to the package on the filesystem. Used to look up resources contained in the package.", "Decorate a view function to register it with the given URL rule and options. Calls add_url_rule(), which has more details about the implementation.", "See URL Route Registrations.", "The endpoint name for the route defaults to the name of the view function if the endpoint parameter isn\u2019t passed.", "The methods parameter defaults to [\"GET\"]. HEAD and OPTIONS are added automatically.", "Callable", "Runs the application on a local development server.", "Do not use run() in a production setting. It is not intended to meet security and performance requirements for a production server. Instead, see Deployment Options for WSGI server recommendations.", "If the debug flag is set the server will automatically reload for code changes and show a debugger in case an exception happened.", "If you want to run the application in debug mode, but disable the code execution on the interactive debugger, you can pass use_evalex=False as parameter. This will keep the debugger\u2019s traceback screen active, but disable code execution.", "It is not recommended to use this function for development with automatic reloading as this is badly supported. Instead you should be using the flask command line script\u2019s run support.", "Keep in Mind", "Flask will suppress any server error with a generic error page unless it is in debug mode. As such to enable just the interactive debugger without the code reloading, you have to invoke run() with debug=True and use_reloader=False. Setting use_debugger to True without being in debug mode won\u2019t catch any exceptions because there won\u2019t be any to catch.", "None", "Changed in version 1.0: If installed, python-dotenv will be used to load environment variables from .env and .flaskenv files.", "If set, the FLASK_ENV and FLASK_DEBUG environment variables will override env and debug.", "Threaded mode is enabled by default.", "Changed in version 0.10: The default port is now picked from the SERVER_NAME variable.", "If a secret key is set, cryptographic components can use this to sign cookies and other things. Set this to a complex random value when you want to use the secure cookie for instance.", "This attribute can also be configured from the config with the SECRET_KEY configuration key. Defaults to None.", "Returns True if autoescaping should be active for the given template name. If no template name is given, returns True.", "New in version 0.5.", "filename (str) \u2013 ", "bool", "A timedelta or number of seconds which is used as the default max_age for send_file(). The default is None, which tells the browser to use conditional requests instead of a timed cache.", "Configured with the SEND_FILE_MAX_AGE_DEFAULT configuration key.", "Changed in version 2.0: Defaults to None instead of 12 hours.", "The view function used to serve files from static_folder. A route is automatically registered for this view at static_url_path if static_folder is set.", "New in version 0.5.", "filename (str) \u2013 ", "Response", "The secure cookie uses this for the name of the session cookie.", "This attribute can also be configured from the config with the SESSION_COOKIE_NAME configuration key. Defaults to 'session'", "the session interface to use. By default an instance of SecureCookieSessionInterface is used here.", "New in version 0.8.", "Registers a shell context processor function.", "New in version 0.11.", "f (Callable) \u2013 ", "Callable", "A list of shell context processor functions that should be run when a shell context is created.", "New in version 0.11.", "This is called to figure out if an error should be ignored or not as far as the teardown system is concerned. If this function returns True then the teardown handlers will not be passed the error.", "New in version 0.10.", "error (Optional[BaseException]) \u2013 ", "bool", "The absolute path to the configured static folder. None if no static folder is set.", "The URL prefix that the static route will be accessible from.", "If it was not configured during init, it is derived from static_folder.", "Registers a function to be called when the application context ends. These functions are typically also called when the request context is popped.", "Example:", "When ctx.pop() is executed in the above example, the teardown functions are called just before the app context moves from the stack of active contexts. This becomes relevant if you are using such constructs in tests.", "Since a request context typically also manages an application context it would also be called when you pop a request context.", "When a teardown function was called because of an unhandled exception it will be passed an error object. If an errorhandler() is registered, it will handle the exception and the teardown will not receive it.", "The return values of teardown functions are ignored.", "New in version 0.9.", "f (Callable[[Optional[BaseException]], flask.wrappers.Response]) \u2013 ", "Callable[[Optional[BaseException]], flask.wrappers.Response]", "A list of functions that are called when the application context is destroyed. Since the application context is also torn down if the request ends this is the place to store code that disconnects from databases.", "New in version 0.9.", "Register a function to be run at the end of each request, regardless of whether there was an exception or not. These functions are executed when the request context is popped, even if not an actual request was performed.", "Example:", "When ctx.pop() is executed in the above example, the teardown functions are called just before the request context moves from the stack of active contexts. This becomes relevant if you are using such constructs in tests.", "Teardown functions must avoid raising exceptions, since they . If they execute code that might fail they will have to surround the execution of these code by try/except statements and log occurring errors.", "When a teardown function was called because of an exception it will be passed an error object.", "The return values of teardown functions are ignored.", "Debug Note", "In debug mode Flask will not tear down a request on an exception immediately. Instead it will keep it alive so that the interactive debugger can still access it. This behavior can be controlled by the PRESERVE_CONTEXT_ON_EXCEPTION configuration variable.", "f (Callable[[Optional[BaseException]], Response]) \u2013 ", "Callable[[Optional[BaseException]], Response]", "A data structure of functions to call at the end of each request even if an exception is raised, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests.", "To register a function, use the teardown_request() decorator.", "This data structure is internal. It should not be modified directly and its format may change at any time.", "A data structure of functions to call to pass extra context values when rendering templates, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests.", "To register a function, use the context_processor() decorator.", "This data structure is internal. It should not be modified directly and its format may change at any time.", "A decorator that is used to register custom template filter. You can specify a name for the filter, otherwise the function name will be used. Example:", "name (Optional[str]) \u2013 the optional name of the filter, otherwise the function name will be used.", "Callable", "The path to the templates folder, relative to root_path, to add to the template loader. None if templates should not be added.", "A decorator that is used to register a custom template global function. You can specify a name for the global function, otherwise the function name will be used. Example:", "New in version 0.10.", "name (Optional[str]) \u2013 the optional name of the global function, otherwise the function name will be used.", "Callable", "A decorator that is used to register custom template test. You can specify a name for the test, otherwise the function name will be used. Example:", "New in version 0.10.", "name (Optional[str]) \u2013 the optional name of the test, otherwise the function name will be used.", "Callable", "Reload templates when they are changed. Used by create_jinja_environment().", "This attribute can be configured with TEMPLATES_AUTO_RELOAD. If not set, it will be enabled in debug mode.", "New in version 1.0: This property was added but the underlying config and behavior already existed.", "Create a CLI runner for testing CLI commands. See Testing CLI Commands.", "Returns an instance of test_cli_runner_class, by default FlaskCliRunner. The Flask app object is passed as the first argument.", "New in version 1.0.", "kwargs (Any) \u2013 ", "FlaskCliRunner", "The CliRunner subclass, by default FlaskCliRunner that is used by test_cli_runner(). Its __init__ method should take a Flask app object as the first argument.", "New in version 1.0.", "Creates a test client for this application. For information about unit testing head over to Testing Flask Applications.", "Note that if you are testing for assertions or exceptions in your application code, you must set app.testing = True in order for the exceptions to propagate to the test client. Otherwise, the exception will be handled by the application (not visible to the test client) and the only indication of an AssertionError or other exception will be a 500 status code response to the test client. See the testing attribute. For example:", "The test client can be used in a with block to defer the closing down of the context until the end of the with block. This is useful if you want to access the context locals for testing:", "Additionally, you may pass optional keyword arguments that will then be passed to the application\u2019s test_client_class constructor. For example:", "See FlaskClient for more information.", "Changed in version 0.11: Added **kwargs to support passing additional keyword arguments to the constructor of test_client_class.", "New in version 0.7: The use_cookies parameter was added as well as the ability to override the client to be used by setting the test_client_class attribute.", "Changed in version 0.4: added support for with block usage for the client.", "FlaskClient", "the test client that is used with when test_client is used.", "New in version 0.7.", "Create a RequestContext for a WSGI environment created from the given values. This is mostly useful during testing, where you may want to run a function that uses request data without dispatching a full request.", "See The Request Context.", "Use a with block to push the context, which will make request point at the request for the created environment.", "When using the shell, it may be easier to push and pop the context manually to avoid indentation.", "Takes the same arguments as Werkzeug\u2019s EnvironBuilder, with some defaults from the application. See the linked Werkzeug docs for most of the available arguments. Flask-specific behavior is listed here.", "flask.ctx.RequestContext", "The testing flag. Set this to True to enable the test mode of Flask extensions (and in the future probably also Flask itself). For example this might activate test helpers that have an additional runtime cost which should not be enabled by default.", "If this is enabled and PROPAGATE_EXCEPTIONS is not changed from the default it\u2019s implicitly enabled.", "This attribute can also be configured from the config with the TESTING configuration key. Defaults to False.", "Checks if an HTTP exception should be trapped or not. By default this will return False for all exceptions except for a bad request key error if TRAP_BAD_REQUEST_ERRORS is set to True. It also returns True if TRAP_HTTP_EXCEPTIONS is set to True.", "This is called for all HTTP exceptions raised by a view function. If it returns True for any exception the error handler for this exception is not called and it shows up as regular exception in the traceback. This is helpful for debugging implicitly raised HTTP exceptions.", "Changed in version 1.0: Bad request errors are not trapped by default in debug mode.", "New in version 0.8.", "e (Exception) \u2013 ", "bool", "Update the template context with some commonly used variables. This injects request, session, config and g into the template context as well as everything template context processors want to inject. Note that the as of Flask 0.6, the original values in the context will not be overridden if a context processor decides to return a value with the same key.", "context (dict) \u2013 the context as a dictionary that is updated in place to add extra variables.", "None", "A list of functions that are called when url_for() raises a BuildError. Each function registered here is called with error, endpoint and values. If a function returns None or raises a BuildError the next function is tried.", "New in version 0.9.", "A data structure of functions to call to modify the keyword arguments when generating URLs, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests.", "To register a function, use the url_defaults() decorator.", "This data structure is internal. It should not be modified directly and its format may change at any time.", "Callback function for URL defaults for all view functions of the application. It\u2019s called with the endpoint and values and should update the values passed in place.", "f (Callable[[str, dict], None]) \u2013 ", "Callable[[str, dict], None]", "The Map for this instance. You can use this to change the routing converters after the class was created but before any routes are connected. Example:", "alias of werkzeug.routing.Map", "alias of werkzeug.routing.Rule", "Register a URL value preprocessor function for all view functions in the application. These functions will be called before the before_request() functions.", "The function can modify the values captured from the matched url before they are passed to the view. For example, this can be used to pop a common language code value and place it in g rather than pass it to every view.", "The function is passed the endpoint name and values dict. The return value is ignored.", "f (Callable[[Optional[str], Optional[dict]], None]) \u2013 ", "Callable[[Optional[str], Optional[dict]], None]", "A data structure of functions to call to modify the keyword arguments passed to the view function, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests.", "To register a function, use the url_value_preprocessor() decorator.", "This data structure is internal. It should not be modified directly and its format may change at any time.", "Enable this if you want to use the X-Sendfile feature. Keep in mind that the server has to support this. This only affects files sent with the send_file() method.", "New in version 0.2.", "This attribute can also be configured from the config with the USE_X_SENDFILE configuration key. Defaults to False.", "A dictionary mapping endpoint names to view functions.", "To register a view function, use the route() decorator.", "This data structure is internal. It should not be modified directly and its format may change at any time.", "The actual WSGI application. This is not implemented in __call__() so that middlewares can be applied without losing a reference to the app object. Instead of doing this:", "It\u2019s a better idea to do this instead:", "Then you still have the original application object around and can continue to call methods on it.", "Changed in version 0.7: Teardown events for the request and app contexts are called even if an unhandled error occurs. Other events may not be called depending on when an error occurs during dispatch. See Callbacks and Errors.", "Any"]}, {"name": "Flask.add_template_filter()", "path": "api/index#flask.Flask.add_template_filter", "type": "flask", "text": ["Register a custom template filter. Works exactly like the template_filter() decorator.", "None"]}, {"name": "Flask.add_template_global()", "path": "api/index#flask.Flask.add_template_global", "type": "flask", "text": ["Register a custom template global function. Works exactly like the template_global() decorator.", "New in version 0.10.", "None"]}, {"name": "Flask.add_template_test()", "path": "api/index#flask.Flask.add_template_test", "type": "flask", "text": ["Register a custom template test. Works exactly like the template_test() decorator.", "New in version 0.10.", "None"]}, {"name": "Flask.add_url_rule()", "path": "api/index#flask.Flask.add_url_rule", "type": "flask", "text": ["Register a rule for routing incoming requests and building URLs. The route() decorator is a shortcut to call this with the view_func argument. These are equivalent:", "See URL Route Registrations.", "The endpoint name for the route defaults to the name of the view function if the endpoint parameter isn\u2019t passed. An error will be raised if a function has already been registered for the endpoint.", "The methods parameter defaults to [\"GET\"]. HEAD is always added automatically, and OPTIONS is added automatically by default.", "view_func does not necessarily need to be passed, but if the rule should participate in routing an endpoint name must be associated with a view function at some point with the endpoint() decorator.", "If view_func has a required_methods attribute, those methods are added to the passed and automatic methods. If it has a provide_automatic_methods attribute, it is used as the default if the parameter is not passed.", "None"]}, {"name": "Flask.after_request()", "path": "api/index#flask.Flask.after_request", "type": "flask", "text": ["Register a function to run after each request to this object.", "The function is called with the response object, and must return a response object. This allows the functions to modify or replace the response before it is sent.", "If a function raises an exception, any remaining after_request functions will not be called. Therefore, this should not be used for actions that must execute, such as to close resources. Use teardown_request() for that.", "f (Callable[[Response], Response]) \u2013 ", "Callable[[Response], Response]"]}, {"name": "Flask.after_request_funcs", "path": "api/index#flask.Flask.after_request_funcs", "type": "flask", "text": ["A data structure of functions to call at the end of each request, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests.", "To register a function, use the after_request() decorator.", "This data structure is internal. It should not be modified directly and its format may change at any time."]}, {"name": "flask.appcontext_popped", "path": "api/index#flask.appcontext_popped", "type": "flask", "text": ["This signal is sent when an application context is popped. The sender is the application. This usually falls in line with the appcontext_tearing_down signal.", "New in version 0.10."]}, {"name": "flask.appcontext_pushed", "path": "api/index#flask.appcontext_pushed", "type": "flask", "text": ["This signal is sent when an application context is pushed. The sender is the application. This is usually useful for unittests in order to temporarily hook in information. For instance it can be used to set a resource early onto the g object.", "Example usage:", "And in the testcode:", "New in version 0.10."]}, {"name": "flask.appcontext_tearing_down", "path": "api/index#flask.appcontext_tearing_down", "type": "flask", "text": ["This signal is sent when the app context is tearing down. This is always called, even if an exception is caused. Currently functions listening to this signal are called after the regular teardown handlers, but this is not something you can rely on.", "Example subscriber:", "This will also be passed an exc keyword argument that has a reference to the exception that caused the teardown if there was one."]}, {"name": "Flask.app_context()", "path": "api/index#flask.Flask.app_context", "type": "flask", "text": ["Create an AppContext. Use as a with block to push the context, which will make current_app point at this application.", "An application context is automatically pushed by RequestContext.push() when handling a request, and when running a CLI command. Use this to manually create a context outside of these situations.", "See The Application Context.", "New in version 0.9.", "flask.ctx.AppContext"]}, {"name": "Flask.app_ctx_globals_class", "path": "api/index#flask.Flask.app_ctx_globals_class", "type": "flask", "text": ["alias of flask.ctx._AppCtxGlobals"]}, {"name": "Flask.async_to_sync()", "path": "api/index#flask.Flask.async_to_sync", "type": "flask", "text": ["Return a sync function that will run the coroutine function.", "Override this method to change how the app converts async code to be synchronously callable.", "New in version 2.0.", "func (Callable[[...], Coroutine]) \u2013 ", "Callable[[\u2026], Any]"]}, {"name": "Flask.auto_find_instance_path()", "path": "api/index#flask.Flask.auto_find_instance_path", "type": "flask", "text": ["Tries to locate the instance path if it was not provided to the constructor of the application class. It will basically calculate the path to a folder named instance next to your main file or the package.", "New in version 0.8.", "str"]}, {"name": "Flask.before_first_request()", "path": "api/index#flask.Flask.before_first_request", "type": "flask", "text": ["Registers a function to be run before the first request to this instance of the application.", "The function will be called without any arguments and its return value is ignored.", "New in version 0.8.", "f (Callable[[], None]) \u2013 ", "Callable[[], None]"]}, {"name": "Flask.before_first_request_funcs", "path": "api/index#flask.Flask.before_first_request_funcs", "type": "flask", "text": ["A list of functions that will be called at the beginning of the first request to this instance. To register a function, use the before_first_request() decorator.", "New in version 0.8."]}, {"name": "Flask.before_request()", "path": "api/index#flask.Flask.before_request", "type": "flask", "text": ["Register a function to run before each request.", "For example, this can be used to open a database connection, or to load the logged in user from the session.", "The function will be called without any arguments. If it returns a non-None value, the value is handled as if it was the return value from the view, and further request handling is stopped.", "f (Callable[[], None]) \u2013 ", "Callable[[], None]"]}, {"name": "Flask.before_request_funcs", "path": "api/index#flask.Flask.before_request_funcs", "type": "flask", "text": ["A data structure of functions to call at the beginning of each request, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests.", "To register a function, use the before_request() decorator.", "This data structure is internal. It should not be modified directly and its format may change at any time."]}, {"name": "Flask.blueprints", "path": "api/index#flask.Flask.blueprints", "type": "flask", "text": ["Maps registered blueprint names to blueprint objects. The dict retains the order the blueprints were registered in. Blueprints can be registered multiple times, this dict does not track how often they were attached.", "New in version 0.7."]}, {"name": "Flask.cli", "path": "api/index#flask.Flask.cli", "type": "flask", "text": ["The Click command group for registering CLI commands for this object. The commands are available from the flask command once the application has been discovered and blueprints have been registered."]}, {"name": "flask.cli.run_command", "path": "api/index#flask.cli.run_command", "type": "flask", "text": ["Run a local development server.", "This server is for development purposes only. It does not provide the stability, security, or performance of production WSGI servers.", "The reloader and debugger are enabled by default if FLASK_ENV=development or FLASK_DEBUG=1.", "Any"]}, {"name": "flask.cli.shell_command", "path": "api/index#flask.cli.shell_command", "type": "flask", "text": ["Run an interactive Python shell in the context of a given Flask application. The application will populate the default namespace of this shell according to its configuration.", "This is useful for executing small snippets of management code without having to manually configure the application.", "Any"]}, {"name": "Flask.config", "path": "api/index#flask.Flask.config", "type": "flask", "text": ["The configuration dictionary as Config. This behaves exactly like a regular dictionary but supports additional methods to load a config from files."]}, {"name": "Flask.config_class", "path": "api/index#flask.Flask.config_class", "type": "flask", "text": ["alias of flask.config.Config"]}, {"name": "Flask.context_processor()", "path": "api/index#flask.Flask.context_processor", "type": "flask", "text": ["Registers a template context processor function.", "f (Callable[[], Dict[str, Any]]) \u2013 ", "Callable[[], Dict[str, Any]]"]}, {"name": "Flask.create_global_jinja_loader()", "path": "api/index#flask.Flask.create_global_jinja_loader", "type": "flask", "text": ["Creates the loader for the Jinja2 environment. Can be used to override just the loader and keeping the rest unchanged. It\u2019s discouraged to override this function. Instead one should override the jinja_loader() function instead.", "The global loader dispatches between the loaders of the application and the individual blueprints.", "New in version 0.7.", "flask.templating.DispatchingJinjaLoader"]}, {"name": "Flask.create_jinja_environment()", "path": "api/index#flask.Flask.create_jinja_environment", "type": "flask", "text": ["Create the Jinja environment based on jinja_options and the various Jinja-related methods of the app. Changing jinja_options after this will have no effect. Also adds Flask-related globals and filters to the environment.", "Changed in version 0.11: Environment.auto_reload set in accordance with TEMPLATES_AUTO_RELOAD configuration option.", "New in version 0.5.", "flask.templating.Environment"]}, {"name": "Flask.create_url_adapter()", "path": "api/index#flask.Flask.create_url_adapter", "type": "flask", "text": ["Creates a URL adapter for the given request. The URL adapter is created at a point where the request context is not yet set up so the request is passed explicitly.", "Changed in version 1.0: SERVER_NAME no longer implicitly enables subdomain matching. Use subdomain_matching instead.", "Changed in version 0.9: This can now also be called without a request object when the URL adapter is created for the application context.", "New in version 0.6.", "request (Optional[flask.wrappers.Request]) \u2013 ", "Optional[werkzeug.routing.MapAdapter]"]}, {"name": "flask.current_app", "path": "api/index#flask.current_app", "type": "flask", "text": ["A proxy to the application handling the current request. This is useful to access the application without needing to import it, or if it can\u2019t be imported, such as when using the application factory pattern or in blueprints and extensions.", "This is only available when an application context is pushed. This happens automatically during requests and CLI commands. It can be controlled manually with app_context().", "This is a proxy. See Notes On Proxies for more information."]}, {"name": "Flask.default_config", "path": "api/index#flask.Flask.default_config", "type": "flask", "text": ["Default configuration parameters."]}, {"name": "Flask.delete()", "path": "api/index#flask.Flask.delete", "type": "flask", "text": ["Shortcut for route() with methods=[\"DELETE\"].", "New in version 2.0.", "Callable"]}, {"name": "Flask.dispatch_request()", "path": "api/index#flask.Flask.dispatch_request", "type": "flask", "text": ["Does the request dispatching. Matches the URL and returns the return value of the view or error handler. This does not have to be a response object. In order to convert the return value to a proper response object, call make_response().", "Changed in version 0.7: This no longer does the exception handling, this code was moved to the new full_dispatch_request().", "Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], WSGIApplication]"]}, {"name": "Flask.do_teardown_appcontext()", "path": "api/index#flask.Flask.do_teardown_appcontext", "type": "flask", "text": ["Called right before the application context is popped.", "When handling a request, the application context is popped after the request context. See do_teardown_request().", "This calls all functions decorated with teardown_appcontext(). Then the appcontext_tearing_down signal is sent.", "This is called by AppContext.pop().", "New in version 0.9.", "exc (Optional[BaseException]) \u2013 ", "None"]}, {"name": "Flask.do_teardown_request()", "path": "api/index#flask.Flask.do_teardown_request", "type": "flask", "text": ["Called after the request is dispatched and the response is returned, right before the request context is popped.", "This calls all functions decorated with teardown_request(), and Blueprint.teardown_request() if a blueprint handled the request. Finally, the request_tearing_down signal is sent.", "This is called by RequestContext.pop(), which may be delayed during testing to maintain access to resources.", "exc (Optional[BaseException]) \u2013 An unhandled exception raised while dispatching the request. Detected from the current exception information if not passed. Passed to each teardown function.", "None", "Changed in version 0.9: Added the exc argument."]}, {"name": "Flask.endpoint()", "path": "api/index#flask.Flask.endpoint", "type": "flask", "text": ["Decorate a view function to register it for the given endpoint. Used if a rule is added without a view_func with add_url_rule().", "endpoint (str) \u2013 The endpoint name to associate with the view function.", "Callable"]}, {"name": "Flask.ensure_sync()", "path": "api/index#flask.Flask.ensure_sync", "type": "flask", "text": ["Ensure that the function is synchronous for WSGI workers. Plain def functions are returned as-is. async def functions are wrapped to run and wait for the response.", "Override this method to change how the app runs async views.", "New in version 2.0.", "func (Callable) \u2013 ", "Callable"]}, {"name": "Flask.env", "path": "api/index#flask.Flask.env", "type": "flask", "text": ["What environment the app is running in. Flask and extensions may enable behaviors based on the environment, such as enabling debug mode. This maps to the ENV config key. This is set by the FLASK_ENV environment variable and may not behave as expected if set in code.", "Do not enable development when deploying in production.", "Default: 'production'"]}, {"name": "Flask.errorhandler()", "path": "api/index#flask.Flask.errorhandler", "type": "flask", "text": ["Register a function to handle errors by code or exception class.", "A decorator that is used to register a function given an error code. Example:", "You can also register handlers for arbitrary exceptions:", "New in version 0.7: Use register_error_handler() instead of modifying error_handler_spec directly, for application wide error handlers.", "New in version 0.7: One can now additionally also register custom exception types that do not necessarily have to be a subclass of the HTTPException class.", "code_or_exception (Union[Type[Exception], int]) \u2013 the code as integer for the handler, or an arbitrary exception", "Callable"]}, {"name": "Flask.error_handler_spec", "path": "api/index#flask.Flask.error_handler_spec", "type": "flask", "text": ["A data structure of registered error handlers, in the format {scope: {code: {class: handler}}}`. The scope key is the name of a blueprint the handlers are active for, or None for all requests. The code key is the HTTP status code for HTTPException, or None for other exceptions. The innermost dictionary maps exception classes to handler functions.", "To register an error handler, use the errorhandler() decorator.", "This data structure is internal. It should not be modified directly and its format may change at any time."]}, {"name": "Flask.extensions", "path": "api/index#flask.Flask.extensions", "type": "flask", "text": ["a place where extensions can store application specific state. For example this is where an extension could store database engines and similar things.", "The key must match the name of the extension module. For example in case of a \u201cFlask-Foo\u201d extension in flask_foo, the key would be 'foo'.", "New in version 0.7."]}, {"name": "Flask.full_dispatch_request()", "path": "api/index#flask.Flask.full_dispatch_request", "type": "flask", "text": ["Dispatches the request and on top of that performs request pre and postprocessing as well as HTTP exception catching and error handling.", "New in version 0.7.", "flask.wrappers.Response"]}, {"name": "flask.g", "path": "api/index#flask.g", "type": "flask", "text": ["A namespace object that can store data during an application context. This is an instance of Flask.app_ctx_globals_class, which defaults to ctx._AppCtxGlobals.", "This is a good place to store resources during a request. During testing, you can use the Faking Resources and Context pattern to pre-configure such resources.", "This is a proxy. See Notes On Proxies for more information.", "Changed in version 0.10: Bound to the application context instead of the request context."]}, {"name": "Flask.get()", "path": "api/index#flask.Flask.get", "type": "flask", "text": ["Shortcut for route() with methods=[\"GET\"].", "New in version 2.0.", "Callable"]}, {"name": "Flask.get_send_file_max_age()", "path": "api/index#flask.Flask.get_send_file_max_age", "type": "flask", "text": ["Used by send_file() to determine the max_age cache value for a given file path if it wasn\u2019t passed.", "By default, this returns SEND_FILE_MAX_AGE_DEFAULT from the configuration of current_app. This defaults to None, which tells the browser to use conditional requests instead of a timed cache, which is usually preferable.", "Changed in version 2.0: The default configuration is None instead of 12 hours.", "New in version 0.9.", "filename (str) \u2013 ", "Optional[int]"]}, {"name": "flask.got_request_exception", "path": "api/index#flask.got_request_exception", "type": "flask", "text": ["This signal is sent when an unhandled exception happens during request processing, including when debugging. The exception is passed to the subscriber as exception.", "This signal is not sent for HTTPException, or other exceptions that have error handlers registered, unless the exception was raised from an error handler.", "This example shows how to do some extra logging if a theoretical SecurityException was raised:"]}, {"name": "Flask.handle_exception()", "path": "api/index#flask.Flask.handle_exception", "type": "flask", "text": ["Handle an exception that did not have an error handler associated with it, or that was raised from an error handler. This always causes a 500 InternalServerError.", "Always sends the got_request_exception signal.", "If propagate_exceptions is True, such as in debug mode, the error will be re-raised so that the debugger can display it. Otherwise, the original exception is logged, and an InternalServerError is returned.", "If an error handler is registered for InternalServerError or 500, it will be used. For consistency, the handler will always receive the InternalServerError. The original unhandled exception is available as e.original_exception.", "Changed in version 1.1.0: Always passes the InternalServerError instance to the handler, setting original_exception to the unhandled error.", "Changed in version 1.1.0: after_request functions and other finalization is done even for the default 500 response when there is no handler.", "New in version 0.3.", "e (Exception) \u2013 ", "flask.wrappers.Response"]}, {"name": "Flask.handle_http_exception()", "path": "api/index#flask.Flask.handle_http_exception", "type": "flask", "text": ["Handles an HTTP exception. By default this will invoke the registered error handlers and fall back to returning the exception as response.", "Changed in version 1.0.3: RoutingException, used internally for actions such as slash redirects during routing, is not passed to error handlers.", "Changed in version 1.0: Exceptions are looked up by code and by MRO, so HTTPExcpetion subclasses can be handled with a catch-all handler for the base HTTPException.", "New in version 0.3.", "e (werkzeug.exceptions.HTTPException) \u2013 ", "Union[werkzeug.exceptions.HTTPException, Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], WSGIApplication]"]}, {"name": "Flask.handle_url_build_error()", "path": "api/index#flask.Flask.handle_url_build_error", "type": "flask", "text": ["Handle BuildError on url_for().", "str"]}, {"name": "Flask.handle_user_exception()", "path": "api/index#flask.Flask.handle_user_exception", "type": "flask", "text": ["This method is called whenever an exception occurs that should be handled. A special case is HTTPException which is forwarded to the handle_http_exception() method. This function will either return a response value or reraise the exception with the same traceback.", "Changed in version 1.0: Key errors raised from request data like form show the bad key in debug mode rather than a generic bad request message.", "New in version 0.7.", "e (Exception) \u2013 ", "Union[werkzeug.exceptions.HTTPException, Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], WSGIApplication]"]}, {"name": "Flask.import_name", "path": "api/index#flask.Flask.import_name", "type": "flask", "text": ["The name of the package or module that this object belongs to. Do not change this once it is set by the constructor."]}, {"name": "Flask.inject_url_defaults()", "path": "api/index#flask.Flask.inject_url_defaults", "type": "flask", "text": ["Injects the URL defaults for the given endpoint directly into the values dictionary passed. This is used internally and automatically called on URL building.", "New in version 0.7.", "None"]}, {"name": "Flask.instance_path", "path": "api/index#flask.Flask.instance_path", "type": "flask", "text": ["Holds the path to the instance folder.", "New in version 0.8."]}, {"name": "Flask.iter_blueprints()", "path": "api/index#flask.Flask.iter_blueprints", "type": "flask", "text": ["Iterates over all blueprints by the order they were registered.", "New in version 0.11.", "ValuesView[Blueprint]"]}, {"name": "Flask.jinja_environment", "path": "api/index#flask.Flask.jinja_environment", "type": "flask", "text": ["alias of flask.templating.Environment"]}, {"name": "Flask.jinja_options", "path": "api/index#flask.Flask.jinja_options", "type": "flask", "text": ["Options that are passed to the Jinja environment in create_jinja_environment(). Changing these options after the environment is created (accessing jinja_env) will have no effect.", "Changed in version 1.1.0: This is a dict instead of an ImmutableDict to allow easier configuration."]}, {"name": "Flask.json_decoder", "path": "api/index#flask.Flask.json_decoder", "type": "flask", "text": ["alias of flask.json.JSONDecoder"]}, {"name": "Flask.json_encoder", "path": "api/index#flask.Flask.json_encoder", "type": "flask", "text": ["alias of flask.json.JSONEncoder"]}, {"name": "Flask.log_exception()", "path": "api/index#flask.Flask.log_exception", "type": "flask", "text": ["Logs an exception. This is called by handle_exception() if debugging is disabled and right before the handler is called. The default implementation logs the exception as error on the logger.", "New in version 0.8.", "exc_info (Union[Tuple[type, BaseException, types.TracebackType], Tuple[None, None, None]]) \u2013 ", "None"]}, {"name": "Flask.make_config()", "path": "api/index#flask.Flask.make_config", "type": "flask", "text": ["Used to create the config attribute by the Flask constructor. The instance_relative parameter is passed in from the constructor of Flask (there named instance_relative_config) and indicates if the config should be relative to the instance path or the root path of the application.", "New in version 0.8.", "instance_relative (bool) \u2013 ", "flask.config.Config"]}, {"name": "Flask.make_default_options_response()", "path": "api/index#flask.Flask.make_default_options_response", "type": "flask", "text": ["This method is called to create the default OPTIONS response. This can be changed through subclassing to change the default behavior of OPTIONS responses.", "New in version 0.7.", "flask.wrappers.Response"]}, {"name": "Flask.make_response()", "path": "api/index#flask.Flask.make_response", "type": "flask", "text": ["Convert the return value from a view function to an instance of response_class.", "rv (Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], Union[Headers, Dict[str, Union[str, List[str], Tuple[str, ...]]], List[Tuple[str, Union[str, List[str], Tuple[str, ...]]]]]], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, ...]]], List[Tuple[str, Union[str, List[str], Tuple[str, ...]]]]]], WSGIApplication]) \u2013 ", "the return value from the view function. The view function must return a response. Returning None, or the view ending without returning, is not allowed. The following types are allowed for view_rv:", "A response object is created with the string encoded to UTF-8 as the body.", "A response object is created with the bytes as the body.", "A dictionary that will be jsonify\u2019d before being returned.", "Either (body, status, headers), (body, status), or (body, headers), where body is any of the other types allowed here, status is a string or an integer, and headers is a dictionary or a list of (key, value) tuples. If body is a response_class instance, status overwrites the exiting value and headers are extended.", "The object is returned unchanged.", "The object is coerced to response_class.", "The function is called as a WSGI application. The result is used to create a response object.", "flask.wrappers.Response", "Changed in version 0.9: Previously a tuple was interpreted as the arguments for the response object."]}, {"name": "Flask.make_shell_context()", "path": "api/index#flask.Flask.make_shell_context", "type": "flask", "text": ["Returns the shell context for an interactive shell for this application. This runs all the registered shell context processors.", "New in version 0.11.", "dict"]}, {"name": "flask.message_flashed", "path": "api/index#flask.message_flashed", "type": "flask", "text": ["This signal is sent when the application is flashing a message. The messages is sent as message keyword argument and the category as category.", "Example subscriber:", "New in version 0.10."]}, {"name": "Flask.open_instance_resource()", "path": "api/index#flask.Flask.open_instance_resource", "type": "flask", "text": ["Opens a resource from the application\u2019s instance folder (instance_path). Otherwise works like open_resource(). Instance resources can also be opened for writing.", "IO"]}, {"name": "Flask.open_resource()", "path": "api/index#flask.Flask.open_resource", "type": "flask", "text": ["Open a resource file relative to root_path for reading.", "For example, if the file schema.sql is next to the file app.py where the Flask app is defined, it can be opened with:", "IO"]}, {"name": "Flask.patch()", "path": "api/index#flask.Flask.patch", "type": "flask", "text": ["Shortcut for route() with methods=[\"PATCH\"].", "New in version 2.0.", "Callable"]}, {"name": "Flask.permanent_session_lifetime", "path": "api/index#flask.Flask.permanent_session_lifetime", "type": "flask", "text": ["A timedelta which is used to set the expiration date of a permanent session. The default is 31 days which makes a permanent session survive for roughly one month.", "This attribute can also be configured from the config with the PERMANENT_SESSION_LIFETIME configuration key. Defaults to timedelta(days=31)"]}, {"name": "Flask.post()", "path": "api/index#flask.Flask.post", "type": "flask", "text": ["Shortcut for route() with methods=[\"POST\"].", "New in version 2.0.", "Callable"]}, {"name": "Flask.preprocess_request()", "path": "api/index#flask.Flask.preprocess_request", "type": "flask", "text": ["Called before the request is dispatched. Calls url_value_preprocessors registered with the app and the current blueprint (if any). Then calls before_request_funcs registered with the app and the blueprint.", "If any before_request() handler returns a non-None value, the value is handled as if it was the return value from the view, and further request handling is stopped.", "Optional[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], WSGIApplication]]"]}, {"name": "Flask.process_response()", "path": "api/index#flask.Flask.process_response", "type": "flask", "text": ["Can be overridden in order to modify the response object before it\u2019s sent to the WSGI server. By default this will call all the after_request() decorated functions.", "Changed in version 0.5: As of Flask 0.5 the functions registered for after request execution are called in reverse order of registration.", "response (flask.wrappers.Response) \u2013 a response_class object.", "a new response object or the same, has to be an instance of response_class.", "flask.wrappers.Response"]}, {"name": "Flask.put()", "path": "api/index#flask.Flask.put", "type": "flask", "text": ["Shortcut for route() with methods=[\"PUT\"].", "New in version 2.0.", "Callable"]}, {"name": "Flask.register_blueprint()", "path": "api/index#flask.Flask.register_blueprint", "type": "flask", "text": ["Register a Blueprint on the application. Keyword arguments passed to this method will override the defaults set on the blueprint.", "Calls the blueprint\u2019s register() method after recording the blueprint in the application\u2019s blueprints.", "None", "New in version 0.7."]}, {"name": "Flask.register_error_handler()", "path": "api/index#flask.Flask.register_error_handler", "type": "flask", "text": ["Alternative error attach function to the errorhandler() decorator that is more straightforward to use for non decorator usage.", "New in version 0.7.", "None"]}, {"name": "flask.request", "path": "api/index#flask.request", "type": "flask", "text": ["To access incoming request data, you can use the global request object. Flask parses incoming request data for you and gives you access to it through that global object. Internally Flask makes sure that you always get the correct data for the active thread if you are in a multithreaded environment.", "This is a proxy. See Notes On Proxies for more information.", "The request object is an instance of a Request."]}, {"name": "Flask.request_class", "path": "api/index#flask.Flask.request_class", "type": "flask", "text": ["alias of flask.wrappers.Request"]}, {"name": "Flask.request_context()", "path": "api/index#flask.Flask.request_context", "type": "flask", "text": ["Create a RequestContext representing a WSGI environment. Use a with block to push the context, which will make request point at this request.", "See The Request Context.", "Typically you should not call this from your own code. A request context is automatically pushed by the wsgi_app() when handling a request. Use test_request_context() to create an environment and context instead of this method.", "environ (dict) \u2013 a WSGI environment", "flask.ctx.RequestContext"]}, {"name": "flask.request_finished", "path": "api/index#flask.request_finished", "type": "flask", "text": ["This signal is sent right before the response is sent to the client. It is passed the response to be sent named response.", "Example subscriber:"]}, {"name": "flask.request_started", "path": "api/index#flask.request_started", "type": "flask", "text": ["This signal is sent when the request context is set up, before any request processing happens. Because the request context is already bound, the subscriber can access the request with the standard global proxies such as request.", "Example subscriber:"]}, {"name": "flask.request_tearing_down", "path": "api/index#flask.request_tearing_down", "type": "flask", "text": ["This signal is sent when the request is tearing down. This is always called, even if an exception is caused. Currently functions listening to this signal are called after the regular teardown handlers, but this is not something you can rely on.", "Example subscriber:", "As of Flask 0.9, this will also be passed an exc keyword argument that has a reference to the exception that caused the teardown if there was one."]}, {"name": "Flask.response_class", "path": "api/index#flask.Flask.response_class", "type": "flask", "text": ["alias of flask.wrappers.Response"]}, {"name": "Flask.root_path", "path": "api/index#flask.Flask.root_path", "type": "flask", "text": ["Absolute path to the package on the filesystem. Used to look up resources contained in the package."]}, {"name": "Flask.route()", "path": "api/index#flask.Flask.route", "type": "flask", "text": ["Decorate a view function to register it with the given URL rule and options. Calls add_url_rule(), which has more details about the implementation.", "See URL Route Registrations.", "The endpoint name for the route defaults to the name of the view function if the endpoint parameter isn\u2019t passed.", "The methods parameter defaults to [\"GET\"]. HEAD and OPTIONS are added automatically.", "Callable"]}, {"name": "Flask.run()", "path": "api/index#flask.Flask.run", "type": "flask", "text": ["Runs the application on a local development server.", "Do not use run() in a production setting. It is not intended to meet security and performance requirements for a production server. Instead, see Deployment Options for WSGI server recommendations.", "If the debug flag is set the server will automatically reload for code changes and show a debugger in case an exception happened.", "If you want to run the application in debug mode, but disable the code execution on the interactive debugger, you can pass use_evalex=False as parameter. This will keep the debugger\u2019s traceback screen active, but disable code execution.", "It is not recommended to use this function for development with automatic reloading as this is badly supported. Instead you should be using the flask command line script\u2019s run support.", "Keep in Mind", "Flask will suppress any server error with a generic error page unless it is in debug mode. As such to enable just the interactive debugger without the code reloading, you have to invoke run() with debug=True and use_reloader=False. Setting use_debugger to True without being in debug mode won\u2019t catch any exceptions because there won\u2019t be any to catch.", "None", "Changed in version 1.0: If installed, python-dotenv will be used to load environment variables from .env and .flaskenv files.", "If set, the FLASK_ENV and FLASK_DEBUG environment variables will override env and debug.", "Threaded mode is enabled by default.", "Changed in version 0.10: The default port is now picked from the SERVER_NAME variable."]}, {"name": "Flask.secret_key", "path": "api/index#flask.Flask.secret_key", "type": "flask", "text": ["If a secret key is set, cryptographic components can use this to sign cookies and other things. Set this to a complex random value when you want to use the secure cookie for instance.", "This attribute can also be configured from the config with the SECRET_KEY configuration key. Defaults to None."]}, {"name": "Flask.select_jinja_autoescape()", "path": "api/index#flask.Flask.select_jinja_autoescape", "type": "flask", "text": ["Returns True if autoescaping should be active for the given template name. If no template name is given, returns True.", "New in version 0.5.", "filename (str) \u2013 ", "bool"]}, {"name": "Flask.send_file_max_age_default", "path": "api/index#flask.Flask.send_file_max_age_default", "type": "flask", "text": ["A timedelta or number of seconds which is used as the default max_age for send_file(). The default is None, which tells the browser to use conditional requests instead of a timed cache.", "Configured with the SEND_FILE_MAX_AGE_DEFAULT configuration key.", "Changed in version 2.0: Defaults to None instead of 12 hours."]}, {"name": "Flask.send_static_file()", "path": "api/index#flask.Flask.send_static_file", "type": "flask", "text": ["The view function used to serve files from static_folder. A route is automatically registered for this view at static_url_path if static_folder is set.", "New in version 0.5.", "filename (str) \u2013 ", "Response"]}, {"name": "Flask.session_cookie_name", "path": "api/index#flask.Flask.session_cookie_name", "type": "flask", "text": ["The secure cookie uses this for the name of the session cookie.", "This attribute can also be configured from the config with the SESSION_COOKIE_NAME configuration key. Defaults to 'session'"]}, {"name": "Flask.session_interface", "path": "api/index#flask.Flask.session_interface", "type": "flask", "text": ["the session interface to use. By default an instance of SecureCookieSessionInterface is used here.", "New in version 0.8."]}, {"name": "Flask.shell_context_processor()", "path": "api/index#flask.Flask.shell_context_processor", "type": "flask", "text": ["Registers a shell context processor function.", "New in version 0.11.", "f (Callable) \u2013 ", "Callable"]}, {"name": "Flask.shell_context_processors", "path": "api/index#flask.Flask.shell_context_processors", "type": "flask", "text": ["A list of shell context processor functions that should be run when a shell context is created.", "New in version 0.11."]}, {"name": "Flask.should_ignore_error()", "path": "api/index#flask.Flask.should_ignore_error", "type": "flask", "text": ["This is called to figure out if an error should be ignored or not as far as the teardown system is concerned. If this function returns True then the teardown handlers will not be passed the error.", "New in version 0.10.", "error (Optional[BaseException]) \u2013 ", "bool"]}, {"name": "flask.signals.signals_available", "path": "api/index#flask.signals.signals_available", "type": "flask", "text": ["True if the signaling system is available. This is the case when blinker is installed."]}, {"name": "Flask.teardown_appcontext()", "path": "api/index#flask.Flask.teardown_appcontext", "type": "flask", "text": ["Registers a function to be called when the application context ends. These functions are typically also called when the request context is popped.", "Example:", "When ctx.pop() is executed in the above example, the teardown functions are called just before the app context moves from the stack of active contexts. This becomes relevant if you are using such constructs in tests.", "Since a request context typically also manages an application context it would also be called when you pop a request context.", "When a teardown function was called because of an unhandled exception it will be passed an error object. If an errorhandler() is registered, it will handle the exception and the teardown will not receive it.", "The return values of teardown functions are ignored.", "New in version 0.9.", "f (Callable[[Optional[BaseException]], flask.wrappers.Response]) \u2013 ", "Callable[[Optional[BaseException]], flask.wrappers.Response]"]}, {"name": "Flask.teardown_appcontext_funcs", "path": "api/index#flask.Flask.teardown_appcontext_funcs", "type": "flask", "text": ["A list of functions that are called when the application context is destroyed. Since the application context is also torn down if the request ends this is the place to store code that disconnects from databases.", "New in version 0.9."]}, {"name": "Flask.teardown_request()", "path": "api/index#flask.Flask.teardown_request", "type": "flask", "text": ["Register a function to be run at the end of each request, regardless of whether there was an exception or not. These functions are executed when the request context is popped, even if not an actual request was performed.", "Example:", "When ctx.pop() is executed in the above example, the teardown functions are called just before the request context moves from the stack of active contexts. This becomes relevant if you are using such constructs in tests.", "Teardown functions must avoid raising exceptions, since they . If they execute code that might fail they will have to surround the execution of these code by try/except statements and log occurring errors.", "When a teardown function was called because of an exception it will be passed an error object.", "The return values of teardown functions are ignored.", "Debug Note", "In debug mode Flask will not tear down a request on an exception immediately. Instead it will keep it alive so that the interactive debugger can still access it. This behavior can be controlled by the PRESERVE_CONTEXT_ON_EXCEPTION configuration variable.", "f (Callable[[Optional[BaseException]], Response]) \u2013 ", "Callable[[Optional[BaseException]], Response]"]}, {"name": "Flask.teardown_request_funcs", "path": "api/index#flask.Flask.teardown_request_funcs", "type": "flask", "text": ["A data structure of functions to call at the end of each request even if an exception is raised, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests.", "To register a function, use the teardown_request() decorator.", "This data structure is internal. It should not be modified directly and its format may change at any time."]}, {"name": "Flask.template_context_processors", "path": "api/index#flask.Flask.template_context_processors", "type": "flask", "text": ["A data structure of functions to call to pass extra context values when rendering templates, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests.", "To register a function, use the context_processor() decorator.", "This data structure is internal. It should not be modified directly and its format may change at any time."]}, {"name": "Flask.template_filter()", "path": "api/index#flask.Flask.template_filter", "type": "flask", "text": ["A decorator that is used to register custom template filter. You can specify a name for the filter, otherwise the function name will be used. Example:", "name (Optional[str]) \u2013 the optional name of the filter, otherwise the function name will be used.", "Callable"]}, {"name": "Flask.template_folder", "path": "api/index#flask.Flask.template_folder", "type": "flask", "text": ["The path to the templates folder, relative to root_path, to add to the template loader. None if templates should not be added."]}, {"name": "Flask.template_global()", "path": "api/index#flask.Flask.template_global", "type": "flask", "text": ["A decorator that is used to register a custom template global function. You can specify a name for the global function, otherwise the function name will be used. Example:", "New in version 0.10.", "name (Optional[str]) \u2013 the optional name of the global function, otherwise the function name will be used.", "Callable"]}, {"name": "flask.template_rendered", "path": "api/index#flask.template_rendered", "type": "flask", "text": ["This signal is sent when a template was successfully rendered. The signal is invoked with the instance of the template as template and the context as dictionary (named context).", "Example subscriber:"]}, {"name": "Flask.template_test()", "path": "api/index#flask.Flask.template_test", "type": "flask", "text": ["A decorator that is used to register custom template test. You can specify a name for the test, otherwise the function name will be used. Example:", "New in version 0.10.", "name (Optional[str]) \u2013 the optional name of the test, otherwise the function name will be used.", "Callable"]}, {"name": "Flask.testing", "path": "api/index#flask.Flask.testing", "type": "flask", "text": ["The testing flag. Set this to True to enable the test mode of Flask extensions (and in the future probably also Flask itself). For example this might activate test helpers that have an additional runtime cost which should not be enabled by default.", "If this is enabled and PROPAGATE_EXCEPTIONS is not changed from the default it\u2019s implicitly enabled.", "This attribute can also be configured from the config with the TESTING configuration key. Defaults to False."]}, {"name": "Flask.test_client()", "path": "api/index#flask.Flask.test_client", "type": "flask", "text": ["Creates a test client for this application. For information about unit testing head over to Testing Flask Applications.", "Note that if you are testing for assertions or exceptions in your application code, you must set app.testing = True in order for the exceptions to propagate to the test client. Otherwise, the exception will be handled by the application (not visible to the test client) and the only indication of an AssertionError or other exception will be a 500 status code response to the test client. See the testing attribute. For example:", "The test client can be used in a with block to defer the closing down of the context until the end of the with block. This is useful if you want to access the context locals for testing:", "Additionally, you may pass optional keyword arguments that will then be passed to the application\u2019s test_client_class constructor. For example:", "See FlaskClient for more information.", "Changed in version 0.11: Added **kwargs to support passing additional keyword arguments to the constructor of test_client_class.", "New in version 0.7: The use_cookies parameter was added as well as the ability to override the client to be used by setting the test_client_class attribute.", "Changed in version 0.4: added support for with block usage for the client.", "FlaskClient"]}, {"name": "Flask.test_client_class", "path": "api/index#flask.Flask.test_client_class", "type": "flask", "text": ["the test client that is used with when test_client is used.", "New in version 0.7."]}, {"name": "Flask.test_cli_runner()", "path": "api/index#flask.Flask.test_cli_runner", "type": "flask", "text": ["Create a CLI runner for testing CLI commands. See Testing CLI Commands.", "Returns an instance of test_cli_runner_class, by default FlaskCliRunner. The Flask app object is passed as the first argument.", "New in version 1.0.", "kwargs (Any) \u2013 ", "FlaskCliRunner"]}, {"name": "Flask.test_cli_runner_class", "path": "api/index#flask.Flask.test_cli_runner_class", "type": "flask", "text": ["The CliRunner subclass, by default FlaskCliRunner that is used by test_cli_runner(). Its __init__ method should take a Flask app object as the first argument.", "New in version 1.0."]}, {"name": "Flask.test_request_context()", "path": "api/index#flask.Flask.test_request_context", "type": "flask", "text": ["Create a RequestContext for a WSGI environment created from the given values. This is mostly useful during testing, where you may want to run a function that uses request data without dispatching a full request.", "See The Request Context.", "Use a with block to push the context, which will make request point at the request for the created environment.", "When using the shell, it may be easier to push and pop the context manually to avoid indentation.", "Takes the same arguments as Werkzeug\u2019s EnvironBuilder, with some defaults from the application. See the linked Werkzeug docs for most of the available arguments. Flask-specific behavior is listed here.", "flask.ctx.RequestContext"]}, {"name": "Flask.trap_http_exception()", "path": "api/index#flask.Flask.trap_http_exception", "type": "flask", "text": ["Checks if an HTTP exception should be trapped or not. By default this will return False for all exceptions except for a bad request key error if TRAP_BAD_REQUEST_ERRORS is set to True. It also returns True if TRAP_HTTP_EXCEPTIONS is set to True.", "This is called for all HTTP exceptions raised by a view function. If it returns True for any exception the error handler for this exception is not called and it shows up as regular exception in the traceback. This is helpful for debugging implicitly raised HTTP exceptions.", "Changed in version 1.0: Bad request errors are not trapped by default in debug mode.", "New in version 0.8.", "e (Exception) \u2013 ", "bool"]}, {"name": "Flask.update_template_context()", "path": "api/index#flask.Flask.update_template_context", "type": "flask", "text": ["Update the template context with some commonly used variables. This injects request, session, config and g into the template context as well as everything template context processors want to inject. Note that the as of Flask 0.6, the original values in the context will not be overridden if a context processor decides to return a value with the same key.", "context (dict) \u2013 the context as a dictionary that is updated in place to add extra variables.", "None"]}, {"name": "Flask.url_build_error_handlers", "path": "api/index#flask.Flask.url_build_error_handlers", "type": "flask", "text": ["A list of functions that are called when url_for() raises a BuildError. Each function registered here is called with error, endpoint and values. If a function returns None or raises a BuildError the next function is tried.", "New in version 0.9."]}, {"name": "Flask.url_defaults()", "path": "api/index#flask.Flask.url_defaults", "type": "flask", "text": ["Callback function for URL defaults for all view functions of the application. It\u2019s called with the endpoint and values and should update the values passed in place.", "f (Callable[[str, dict], None]) \u2013 ", "Callable[[str, dict], None]"]}, {"name": "Flask.url_default_functions", "path": "api/index#flask.Flask.url_default_functions", "type": "flask", "text": ["A data structure of functions to call to modify the keyword arguments when generating URLs, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests.", "To register a function, use the url_defaults() decorator.", "This data structure is internal. It should not be modified directly and its format may change at any time."]}, {"name": "Flask.url_map", "path": "api/index#flask.Flask.url_map", "type": "flask", "text": ["The Map for this instance. You can use this to change the routing converters after the class was created but before any routes are connected. Example:"]}, {"name": "Flask.url_map_class", "path": "api/index#flask.Flask.url_map_class", "type": "flask", "text": ["alias of werkzeug.routing.Map"]}, {"name": "Flask.url_rule_class", "path": "api/index#flask.Flask.url_rule_class", "type": "flask", "text": ["alias of werkzeug.routing.Rule"]}, {"name": "Flask.url_value_preprocessor()", "path": "api/index#flask.Flask.url_value_preprocessor", "type": "flask", "text": ["Register a URL value preprocessor function for all view functions in the application. These functions will be called before the before_request() functions.", "The function can modify the values captured from the matched url before they are passed to the view. For example, this can be used to pop a common language code value and place it in g rather than pass it to every view.", "The function is passed the endpoint name and values dict. The return value is ignored.", "f (Callable[[Optional[str], Optional[dict]], None]) \u2013 ", "Callable[[Optional[str], Optional[dict]], None]"]}, {"name": "Flask.url_value_preprocessors", "path": "api/index#flask.Flask.url_value_preprocessors", "type": "flask", "text": ["A data structure of functions to call to modify the keyword arguments passed to the view function, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests.", "To register a function, use the url_value_preprocessor() decorator.", "This data structure is internal. It should not be modified directly and its format may change at any time."]}, {"name": "Flask.use_x_sendfile", "path": "api/index#flask.Flask.use_x_sendfile", "type": "flask", "text": ["Enable this if you want to use the X-Sendfile feature. Keep in mind that the server has to support this. This only affects files sent with the send_file() method.", "New in version 0.2.", "This attribute can also be configured from the config with the USE_X_SENDFILE configuration key. Defaults to False."]}, {"name": "Flask.view_functions", "path": "api/index#flask.Flask.view_functions", "type": "flask", "text": ["A dictionary mapping endpoint names to view functions.", "To register a view function, use the route() decorator.", "This data structure is internal. It should not be modified directly and its format may change at any time."]}, {"name": "Flask.wsgi_app()", "path": "api/index#flask.Flask.wsgi_app", "type": "flask", "text": ["The actual WSGI application. This is not implemented in __call__() so that middlewares can be applied without losing a reference to the app object. Instead of doing this:", "It\u2019s a better idea to do this instead:", "Then you still have the original application object around and can continue to call methods on it.", "Changed in version 0.7: Teardown events for the request and app contexts are called even if an unhandled error occurs. Other events may not be called depending on when an error occurs during dispatch. See Callbacks and Errors.", "Any"]}, {"name": "flask._app_ctx_stack", "path": "api/index#flask._app_ctx_stack", "type": "flask", "text": ["The internal LocalStack that holds AppContext instances. Typically, the current_app and g proxies should be accessed instead of the stack. Extensions can access the contexts on the stack as a namespace to store data.", "New in version 0.9."]}, {"name": "flask._request_ctx_stack", "path": "api/index#flask._request_ctx_stack", "type": "flask", "text": ["The internal LocalStack that holds RequestContext instances. Typically, the request and session proxies should be accessed instead of the stack. It may be useful to access the stack in extension code.", "The following attributes are always present on each layer of the stack:", "the active Flask application.", "the URL adapter that was used to match the request.", "the current request object.", "the active session object.", "an object with all the attributes of the flask.g object.", "an internal cache for the flashed messages.", "Example usage:"]}, {"name": "FlaskClient", "path": "api/index#flask.testing.FlaskClient", "type": "flask.testing", "text": ["Works like a regular Werkzeug test client but has some knowledge about how Flask works to defer the cleanup of the request context stack to the end of a with body when used in a with statement. For general information about how to use this class refer to werkzeug.test.Client.", "Changed in version 0.12: app.test_client() includes preset default environment, which can be set after instantiation of the app.test_client() object in client.environ_base.", "Basic usage is outlined in the Testing Flask Applications chapter.", "None", "Generate an environ dict from the given arguments, make a request to the application using it, and return the response.", "Response", "Changed in version 2.0: as_tuple is deprecated and will be removed in Werkzeug 2.1. Use TestResponse.request and request.environ instead.", "Changed in version 2.0: The request input stream is closed when calling response.close(). Input streams for redirects are automatically closed.", "Changed in version 0.5: If a dict is provided as file in the dict for the data parameter the content type has to be called content_type instead of mimetype. This change was made for consistency with werkzeug.FileWrapper.", "Changed in version 0.5: Added the follow_redirects parameter.", "When used in combination with a with statement this opens a session transaction. This can be used to modify the session that the test client uses. Once the with block is left the session is stored back.", "Internally this is implemented by going through a temporary test request context and since session handling could depend on request variables this function accepts the same arguments as test_request_context() which are directly passed through.", "Generator[flask.sessions.SessionMixin, None, None]"]}, {"name": "FlaskClient.open()", "path": "api/index#flask.testing.FlaskClient.open", "type": "flask.testing", "text": ["Generate an environ dict from the given arguments, make a request to the application using it, and return the response.", "Response", "Changed in version 2.0: as_tuple is deprecated and will be removed in Werkzeug 2.1. Use TestResponse.request and request.environ instead.", "Changed in version 2.0: The request input stream is closed when calling response.close(). Input streams for redirects are automatically closed.", "Changed in version 0.5: If a dict is provided as file in the dict for the data parameter the content type has to be called content_type instead of mimetype. This change was made for consistency with werkzeug.FileWrapper.", "Changed in version 0.5: Added the follow_redirects parameter."]}, {"name": "FlaskClient.session_transaction()", "path": "api/index#flask.testing.FlaskClient.session_transaction", "type": "flask.testing", "text": ["When used in combination with a with statement this opens a session transaction. This can be used to modify the session that the test client uses. Once the with block is left the session is stored back.", "Internally this is implemented by going through a temporary test request context and since session handling could depend on request variables this function accepts the same arguments as test_request_context() which are directly passed through.", "Generator[flask.sessions.SessionMixin, None, None]"]}, {"name": "FlaskCliRunner", "path": "api/index#flask.testing.FlaskCliRunner", "type": "flask.testing", "text": ["A CliRunner for testing a Flask app\u2019s CLI commands. Typically created using test_cli_runner(). See Testing CLI Commands.", "None", "Invokes a CLI command in an isolated environment. See CliRunner.invoke for full method documentation. See Testing CLI Commands for examples.", "If the obj argument is not given, passes an instance of ScriptInfo that knows how to load the Flask app being tested.", "a Result object.", "Any"]}, {"name": "FlaskCliRunner.invoke()", "path": "api/index#flask.testing.FlaskCliRunner.invoke", "type": "flask.testing", "text": ["Invokes a CLI command in an isolated environment. See CliRunner.invoke for full method documentation. See Testing CLI Commands for examples.", "If the obj argument is not given, passes an instance of ScriptInfo that knows how to load the Flask app being tested.", "a Result object.", "Any"]}, {"name": "FlaskGroup", "path": "api/index#flask.cli.FlaskGroup", "type": "flask.cli", "text": ["Special subclass of the AppGroup group that supports loading more commands from the configured Flask app. Normally a developer does not have to interface with this class but there are some very advanced use cases for which it makes sense to create an instance of this. see Custom Scripts.", "Changed in version 1.0: If installed, python-dotenv will be used to load environment variables from .env and .flaskenv files.", "Given a context and a command name, this returns a Command object if it exists or returns None.", "Returns a list of subcommand names in the order they should appear.", "This is the way to invoke a script with all the bells and whistles as a command line application. This will always terminate the application after a call. If this is not wanted, SystemExit needs to be caught.", "This method is also available by directly calling the instance of a Command.", "Changed in version 8.0: When taking arguments from sys.argv on Windows, glob patterns, user dir, and env vars are expanded.", "Changed in version 3.0: Added the standalone_mode parameter."]}, {"name": "FlaskGroup.get_command()", "path": "api/index#flask.cli.FlaskGroup.get_command", "type": "flask.cli", "text": ["Given a context and a command name, this returns a Command object if it exists or returns None."]}, {"name": "FlaskGroup.list_commands()", "path": "api/index#flask.cli.FlaskGroup.list_commands", "type": "flask.cli", "text": ["Returns a list of subcommand names in the order they should appear."]}, {"name": "FlaskGroup.main()", "path": "api/index#flask.cli.FlaskGroup.main", "type": "flask.cli", "text": ["This is the way to invoke a script with all the bells and whistles as a command line application. This will always terminate the application after a call. If this is not wanted, SystemExit needs to be caught.", "This method is also available by directly calling the instance of a Command.", "Changed in version 8.0: When taking arguments from sys.argv on Windows, glob patterns, user dir, and env vars are expanded.", "Changed in version 3.0: Added the standalone_mode parameter."]}, {"name": "Foreword", "path": "foreword/index", "type": "User\u2019s Guide", "text": ["Read this before you get started with Flask. This hopefully answers some questions about the purpose and goals of the project, and when you should or should not be using it.", "\u201cMicro\u201d does not mean that your whole web application has to fit into a single Python file (although it certainly can), nor does it mean that Flask is lacking in functionality. The \u201cmicro\u201d in microframework means Flask aims to keep the core simple but extensible. Flask won\u2019t make many decisions for you, such as what database to use. Those decisions that it does make, such as what templating engine to use, are easy to change. Everything else is up to you, so that Flask can be everything you need and nothing you don\u2019t.", "By default, Flask does not include a database abstraction layer, form validation or anything else where different libraries already exist that can handle that. Instead, Flask supports extensions to add such functionality to your application as if it was implemented in Flask itself. Numerous extensions provide database integration, form validation, upload handling, various open authentication technologies, and more. Flask may be \u201cmicro\u201d, but it\u2019s ready for production use on a variety of needs.", "Flask has many configuration values, with sensible defaults, and a few conventions when getting started. By convention, templates and static files are stored in subdirectories within the application\u2019s Python source tree, with the names templates and static respectively. While this can be changed, you usually don\u2019t have to, especially when getting started.", "Once you have Flask up and running, you\u2019ll find a variety of extensions available in the community to integrate your project for production.", "As your codebase grows, you are free to make the design decisions appropriate for your project. Flask will continue to provide a very simple glue layer to the best that Python has to offer. You can implement advanced patterns in SQLAlchemy or another database tool, introduce non-relational data persistence as appropriate, and take advantage of framework-agnostic tools built for WSGI, the Python web interface.", "Flask includes many hooks to customize its behavior. Should you need more customization, the Flask class is built for subclassing. If you are interested in that, check out the Becoming Big chapter. If you are curious about the Flask design principles, head over to the section about Design Decisions in Flask."]}, {"name": "Foreword for Experienced Programmers", "path": "advanced_foreword/index", "type": "User\u2019s Guide", "text": ["One of the design decisions in Flask was that simple tasks should be simple; they should not take a lot of code and yet they should not limit you. Because of that, Flask has a few design choices that some people might find surprising or unorthodox. For example, Flask uses thread-local objects internally so that you don\u2019t have to pass objects around from function to function within a request in order to stay threadsafe. This approach is convenient, but requires a valid request context for dependency injection or when attempting to reuse code which uses a value pegged to the request. The Flask project is honest about thread-locals, does not hide them, and calls out in the code and documentation where they are used.", "Always keep security in mind when building web applications.", "If you write a web application, you are probably allowing users to register and leave their data on your server. The users are entrusting you with data. And even if you are the only user that might leave data in your application, you still want that data to be stored securely.", "Unfortunately, there are many ways the security of a web application can be compromised. Flask protects you against one of the most common security problems of modern web applications: cross-site scripting (XSS). Unless you deliberately mark insecure HTML as secure, Flask and the underlying Jinja2 template engine have you covered. But there are many more ways to cause security problems.", "The documentation will warn you about aspects of web development that require attention to security. Some of these security concerns are far more complex than one might think, and we all sometimes underestimate the likelihood that a vulnerability will be exploited - until a clever attacker figures out a way to exploit our applications. And don\u2019t think that your application is not important enough to attract an attacker. Depending on the kind of attack, chances are that automated bots are probing for ways to fill your database with spam, links to malicious software, and the like.", "Flask is no different from any other framework in that you the developer must build with caution, watching for exploits when building to your requirements."]}, {"name": "Form Validation with WTForms", "path": "patterns/wtforms/index", "type": "User's Guide: Design Patterns", "text": ["When you have to work with form data submitted by a browser view, code quickly becomes very hard to read. There are libraries out there designed to make this process easier to manage. One of them is WTForms which we will handle here. If you find yourself in the situation of having many forms, you might want to give it a try.", "When you are working with WTForms you have to define your forms as classes first. I recommend breaking up the application into multiple modules (Large Applications as Packages) for that and adding a separate module for the forms.", "Getting the most out of WTForms with an Extension", "The Flask-WTF extension expands on this pattern and adds a few little helpers that make working with forms and Flask more fun. You can get it from PyPI.", "This is an example form for a typical registration page:", "In the view function, the usage of this form looks like this:", "Notice we\u2019re implying that the view is using SQLAlchemy here (SQLAlchemy in Flask), but that\u2019s not a requirement, of course. Adapt the code as necessary.", "Things to remember:", "Now to the template side. When you pass the form to the templates, you can easily render them there. Look at the following example template to see how easy this is. WTForms does half the form generation for us already. To make it even nicer, we can write a macro that renders a field with label and a list of errors if there are any.", "Here\u2019s an example _formhelpers.html template with such a macro:", "This macro accepts a couple of keyword arguments that are forwarded to WTForm\u2019s field function, which renders the field for us. The keyword arguments will be inserted as HTML attributes. So, for example, you can call render_field(form.username, class='username') to add a class to the input element. Note that WTForms returns standard Python strings, so we have to tell Jinja2 that this data is already HTML-escaped with the |safe filter.", "Here is the register.html template for the function we used above, which takes advantage of the _formhelpers.html template:", "For more information about WTForms, head over to the WTForms website."]}, {"name": "get_flashed_messages()", "path": "api/index#flask.get_flashed_messages", "type": "flask", "text": ["Pulls all flashed messages from the session and returns them. Further calls in the same request to the function will return the same messages. By default just the messages are returned, but when with_categories is set to True, the return value will be a list of tuples in the form (category, message) instead.", "Filter the flashed messages to one or more categories by providing those categories in category_filter. This allows rendering categories in separate html blocks. The with_categories and category_filter arguments are distinct:", "See Message Flashing for examples.", "Changed in version 0.9: category_filter parameter added.", "Changed in version 0.3: with_categories parameter added.", "Union[List[str], List[Tuple[str, str]]]"]}, {"name": "get_template_attribute()", "path": "api/index#flask.get_template_attribute", "type": "flask", "text": ["Loads a macro (or variable) a template exports. This can be used to invoke a macro from within Python code. If you for example have a template named _cider.html with the following contents:", "You can access this from Python code like this:", "New in version 0.2.", "Any"]}, {"name": "Handling Application Errors", "path": "errorhandling/index", "type": "User\u2019s Guide", "text": ["Applications fail, servers fail. Sooner or later you will see an exception in production. Even if your code is 100% correct, you will still see exceptions from time to time. Why? Because everything else involved will fail. Here are some situations where perfectly fine code can lead to server errors:", "And that\u2019s just a small sample of issues you could be facing. So how do we deal with that sort of problem? By default if your application runs in production mode, and an exception is raised Flask will display a very simple page for you and log the exception to the logger.", "But there is more you can do, and we will cover some better setups to deal with errors including custom exceptions and 3rd party tools.", "Sending error mails, even if just for critical ones, can become overwhelming if enough users are hitting the error and log files are typically never looked at. This is why we recommend using Sentry for dealing with application errors. It\u2019s available as a source-available project on GitHub and is also available as a hosted version which you can try for free. Sentry aggregates duplicate errors, captures the full stack trace and local variables for debugging, and sends you mails based on new errors or frequency thresholds.", "To use Sentry you need to install the sentry-sdk client with extra flask dependencies.", "And then add this to your Flask app:", "The YOUR_DSN_HERE value needs to be replaced with the DSN value you get from your Sentry installation.", "After installation, failures leading to an Internal Server Error are automatically reported to Sentry and from there you can receive error notifications.", "See also:", "When an error occurs in Flask, an appropriate HTTP status code will be returned. 400-499 indicate errors with the client\u2019s request data, or about the data requested. 500-599 indicate errors with the server or application itself.", "You might want to show custom error pages to the user when an error occurs. This can be done by registering error handlers.", "An error handler is a function that returns a response when a type of error is raised, similar to how a view is a function that returns a response when a request URL is matched. It is passed the instance of the error being handled, which is most likely a HTTPException.", "The status code of the response will not be set to the handler\u2019s code. Make sure to provide the appropriate HTTP status code when returning a response from a handler.", "Register handlers by decorating a function with errorhandler(). Or use register_error_handler() to register the function later. Remember to set the error code when returning the response.", "werkzeug.exceptions.HTTPException subclasses like BadRequest and their HTTP codes are interchangeable when registering handlers. (BadRequest.code == 400)", "Non-standard HTTP codes cannot be registered by code because they are not known by Werkzeug. Instead, define a subclass of HTTPException with the appropriate code and register and raise that exception class.", "Handlers can be registered for any exception class, not just HTTPException subclasses or HTTP status codes. Handlers can be registered for a specific class, or for all subclasses of a parent class.", "When building a Flask application you will run into exceptions. If some part of your code breaks while handling a request (and you have no error handlers registered), a \u201c500 Internal Server Error\u201d (InternalServerError) will be returned by default. Similarly, \u201c404 Not Found\u201d (NotFound) error will occur if a request is sent to an unregistered route. If a route receives an unallowed request method, a \u201c405 Method Not Allowed\u201d (MethodNotAllowed) will be raised. These are all subclasses of HTTPException and are provided by default in Flask.", "Flask gives you to the ability to raise any HTTP exception registered by Werkzeug. However, the default HTTP exceptions return simple exception pages. You might want to show custom error pages to the user when an error occurs. This can be done by registering error handlers.", "When Flask catches an exception while handling a request, it is first looked up by code. If no handler is registered for the code, Flask looks up the error by its class hierarchy; the most specific handler is chosen. If no handler is registered, HTTPException subclasses show a generic message about their code, while other exceptions are converted to a generic \u201c500 Internal Server Error\u201d.", "For example, if an instance of ConnectionRefusedError is raised, and a handler is registered for ConnectionError and ConnectionRefusedError, the more specific ConnectionRefusedError handler is called with the exception instance to generate the response.", "Handlers registered on the blueprint take precedence over those registered globally on the application, assuming a blueprint is handling the request that raises the exception. However, the blueprint cannot handle 404 routing errors because the 404 occurs at the routing level before the blueprint can be determined.", "It is possible to register error handlers for very generic base classes such as HTTPException or even Exception. However, be aware that these will catch more than you might expect.", "For example, an error handler for HTTPException might be useful for turning the default HTML errors pages into JSON. However, this handler will trigger for things you don\u2019t cause directly, such as 404 and 405 errors during routing. Be sure to craft your handler carefully so you don\u2019t lose information about the HTTP error.", "An error handler for Exception might seem useful for changing how all errors, even unhandled ones, are presented to the user. However, this is similar to doing except Exception: in Python, it will capture all otherwise unhandled errors, including all HTTP status codes.", "In most cases it will be safer to register handlers for more specific exceptions. Since HTTPException instances are valid WSGI responses, you could also pass them through directly.", "Error handlers still respect the exception class hierarchy. If you register handlers for both HTTPException and Exception, the Exception handler will not handle HTTPException subclasses because it the HTTPException handler is more specific.", "When there is no error handler registered for an exception, a 500 Internal Server Error will be returned instead. See flask.Flask.handle_exception() for information about this behavior.", "If there is an error handler registered for InternalServerError, this will be invoked. As of Flask 1.1.0, this error handler will always be passed an instance of InternalServerError, not the original unhandled error.", "The original error is available as e.original_exception.", "An error handler for \u201c500 Internal Server Error\u201d will be passed uncaught exceptions in addition to explicit 500 errors. In debug mode, a handler for \u201c500 Internal Server Error\u201d will not be used. Instead, the interactive debugger will be shown.", "Sometimes when building a Flask application, you might want to raise a HTTPException to signal to the user that something is wrong with the request. Fortunately, Flask comes with a handy abort() function that aborts a request with a HTTP error from werkzeug as desired. It will also provide a plain black and white error page for you with a basic description, but nothing fancy.", "Depending on the error code it is less or more likely for the user to actually see such an error.", "Consider the code below, we might have a user profile route, and if the user fails to pass a username we can raise a \u201c400 Bad Request\u201d. If the user passes a username and we can\u2019t find it, we raise a \u201c404 Not Found\u201d.", "Here is another example implementation for a \u201c404 Page Not Found\u201d exception:", "When using Application Factories:", "An example template might be this:", "The above examples wouldn\u2019t actually be an improvement on the default exception pages. We can create a custom 500.html template like this:", "It can be implemented by rendering the template on \u201c500 Internal Server Error\u201d:", "When using Application Factories:", "When using Modular Applications with Blueprints:", "In Modular Applications with Blueprints, most error handlers will work as expected. However, there is a caveat concerning handlers for 404 and 405 exceptions. These error handlers are only invoked from an appropriate raise statement or a call to abort in another of the blueprint\u2019s view functions; they are not invoked by, e.g., an invalid URL access.", "This is because the blueprint does not \u201cown\u201d a certain URL space, so the application instance has no way of knowing which blueprint error handler it should run if given an invalid URL. If you would like to execute different handling strategies for these errors based on URL prefixes, they may be defined at the application level using the request proxy object.", "When building APIs in Flask, some developers realise that the built-in exceptions are not expressive enough for APIs and that the content type of text/html they are emitting is not very useful for API consumers.", "Using the same techniques as above and jsonify() we can return JSON responses to API errors. abort() is called with a description parameter. The error handler will use that as the JSON error message, and set the status code to 404.", "We can also create custom exception classes. For instance, we can introduce a new custom exception for an API that can take a proper human readable message, a status code for the error and some optional payload to give more context for the error.", "This is a simple example:", "A view can now raise that exception with an error message. Additionally some extra payload can be provided as a dictionary through the payload parameter.", "See Logging for information about how to log exceptions, such as by emailing them to admins.", "See Debugging Application Errors for information about how to debug errors in development and production."]}, {"name": "has_app_context()", "path": "api/index#flask.has_app_context", "type": "flask", "text": ["Works like has_request_context() but for the application context. You can also just do a boolean check on the current_app object instead.", "New in version 0.9.", "bool"]}, {"name": "has_request_context()", "path": "api/index#flask.has_request_context", "type": "flask", "text": ["If you have code that wants to test if a request context is there or not this function can be used. For instance, you may want to take advantage of request information if the request object is available, but fail silently if it is unavailable.", "Alternatively you can also just test any of the context bound objects (such as request or g) for truthness:", "New in version 0.7.", "bool"]}, {"name": "HTML/XHTML FAQ", "path": "htmlfaq/index", "type": "Additional Notes", "text": ["The Flask documentation and example applications are using HTML5. You may notice that in many situations, when end tags are optional they are not used, so that the HTML is cleaner and faster to load. Because there is much confusion about HTML and XHTML among developers, this document tries to answer some of the major questions.", "For a while, it appeared that HTML was about to be replaced by XHTML. However, barely any websites on the Internet are actual XHTML (which is HTML processed using XML rules). There are a couple of major reasons why this is the case. One of them is Internet Explorer\u2019s lack of proper XHTML support. The XHTML spec states that XHTML must be served with the MIME type application/xhtml+xml, but Internet Explorer refuses to read files with that MIME type. While it is relatively easy to configure Web servers to serve XHTML properly, few people do. This is likely because properly using XHTML can be quite painful.", "One of the most important causes of pain is XML\u2019s draconian (strict and ruthless) error handling. When an XML parsing error is encountered, the browser is supposed to show the user an ugly error message, instead of attempting to recover from the error and display what it can. Most of the (X)HTML generation on the web is based on non-XML template engines (such as Jinja, the one used in Flask) which do not protect you from accidentally creating invalid XHTML. There are XML based template engines, such as Kid and the popular Genshi, but they often come with a larger runtime overhead and are not as straightforward to use because they have to obey XML rules.", "The majority of users, however, assumed they were properly using XHTML. They wrote an XHTML doctype at the top of the document and self-closed all the necessary tags (<br> becomes <br/> or <br></br> in XHTML). However, even if the document properly validates as XHTML, what really determines XHTML/HTML processing in browsers is the MIME type, which as said before is often not set properly. So the valid XHTML was being treated as invalid HTML.", "XHTML also changed the way JavaScript is used. To properly work with XHTML, programmers have to use the namespaced DOM interface with the XHTML namespace to query for HTML elements.", "Development of the HTML5 specification was started in 2004 under the name \u201cWeb Applications 1.0\u201d by the Web Hypertext Application Technology Working Group, or WHATWG (which was formed by the major browser vendors Apple, Mozilla, and Opera) with the goal of writing a new and improved HTML specification, based on existing browser behavior instead of unrealistic and backwards-incompatible specifications.", "For example, in HTML4 <title/Hello/ theoretically parses exactly the same as <title>Hello</title>. However, since people were using XHTML-like tags along the lines of <link />, browser vendors implemented the XHTML syntax over the syntax defined by the specification.", "In 2007, the specification was adopted as the basis of a new HTML specification under the umbrella of the W3C, known as HTML5. Currently, it appears that XHTML is losing traction, as the XHTML 2 working group has been disbanded and HTML5 is being implemented by all major browser vendors.", "The following table gives you a quick overview of features available in HTML 4.01, XHTML 1.1 and HTML5. (XHTML 1.0 is not included, as it was superseded by XHTML 1.1 and the barely-used XHTML5.)", "HTML4.01", "XHTML1.1", "HTML5", "<tag/value/ == <tag>value</tag>", " 1", "", "", "<br/> supported", "", "", " 2", "<script/> supported", "", "", "", "should be served as text/html", "", " 3", "", "should be served as application/xhtml+xml", "", "", "", "strict error handling", "", "", "", "inline SVG", "", "", "", "inline MathML", "", "", "", "<video> tag", "", "", "", "<audio> tag", "", "", "", "New semantic tags like <article>", "", "", "", "This is an obscure feature inherited from SGML. It is usually not supported by browsers, for reasons detailed above.", "This is for compatibility with server code that generates XHTML for tags such as <br>. It should not be used in new code.", "XHTML 1.0 is the last XHTML standard that allows to be served as text/html for backwards compatibility reasons.", "HTML5 has strictly defined parsing rules, but it also specifies exactly how a browser should react to parsing errors - unlike XHTML, which simply states parsing should abort. Some people are confused by apparently invalid syntax that still generates the expected results (for example, missing end tags or unquoted attribute values).", "Some of these work because of the lenient error handling most browsers use when they encounter a markup error, others are actually specified. The following constructs are optional in HTML5 by standard, but have to be supported by browsers:", "This means the following page in HTML5 is perfectly valid:", "HTML5 adds many new features that make Web applications easier to write and to use.", "Many other features have been added, as well. A good guide to new features in HTML5 is Mark Pilgrim\u2019s book, Dive Into HTML5. Not all of them are supported in browsers yet, however, so use caution.", "Currently, the answer is HTML5. There are very few reasons to use XHTML considering the latest developments in Web browsers. To summarize the reasons given above:", "For most applications, it is undoubtedly better to use HTML5 than XHTML."]}, {"name": "Installation", "path": "installation/index", "type": "User\u2019s Guide", "text": ["We recommend using the latest version of Python. Flask supports Python 3.6 and newer.", "These distributions will be installed automatically when installing Flask.", "These distributions will not be installed automatically. Flask will detect and use them if you install them.", "Use a virtual environment to manage the dependencies for your project, both in development and in production.", "What problem does a virtual environment solve? The more Python projects you have, the more likely it is that you need to work with different versions of Python libraries, or even Python itself. Newer versions of libraries for one project can break compatibility in another project.", "Virtual environments are independent groups of Python libraries, one for each project. Packages installed for one project will not affect other projects or the operating system\u2019s packages.", "Python comes bundled with the venv module to create virtual environments.", "Create a project folder and a venv folder within:", "Before you work on your project, activate the corresponding environment:", "Your shell prompt will change to show the name of the activated environment.", "Within the activated environment, use the following command to install Flask:", "Flask is now installed. Check out the Quickstart or go to the Documentation Overview."]}, {"name": "JSONDecoder", "path": "api/index#flask.json.JSONDecoder", "type": "flask.json", "text": ["The default JSON decoder.", "This does not change any behavior from the built-in json.JSONDecoder.", "Assign a subclass of this to flask.Flask.json_decoder or flask.Blueprint.json_decoder to override the default."]}, {"name": "JSONEncoder", "path": "api/index#flask.json.JSONEncoder", "type": "flask.json", "text": ["The default JSON encoder. Handles extra types compared to the built-in json.JSONEncoder.", "Assign a subclass of this to flask.Flask.json_encoder or flask.Blueprint.json_encoder to override the default.", "Convert o to a JSON serializable type. See json.JSONEncoder.default(). Python does not support overriding how basic types like str or list are serialized, they are handled before this method.", "o (Any) \u2013 ", "Any"]}, {"name": "JSONEncoder.default()", "path": "api/index#flask.json.JSONEncoder.default", "type": "flask.json", "text": ["Convert o to a JSON serializable type. See json.JSONEncoder.default(). Python does not support overriding how basic types like str or list are serialized, they are handled before this method.", "o (Any) \u2013 ", "Any"]}, {"name": "jsonify()", "path": "api/index#flask.json.jsonify", "type": "flask.json", "text": ["Serialize data to JSON and wrap it in a Response with the application/json mimetype.", "Uses dumps() to serialize the data, but args and kwargs are treated as data rather than arguments to json.dumps().", "Will return a JSON response like this:", "The default output omits indents and spaces after separators. In debug mode or if JSONIFY_PRETTYPRINT_REGULAR is True, the output will be formatted to be easier to read.", "Changed in version 0.11: Added support for serializing top-level arrays. This introduces a security risk in ancient browsers. See JSON Security.", "New in version 0.2.", "Response"]}, {"name": "JSONIFY_MIMETYPE", "path": "config/index#JSONIFY_MIMETYPE", "type": "Configuration", "text": ["The mimetype of jsonify responses.", "Default: 'application/json'"]}, {"name": "JSONIFY_PRETTYPRINT_REGULAR", "path": "config/index#JSONIFY_PRETTYPRINT_REGULAR", "type": "Configuration", "text": ["jsonify responses will be output with newlines, spaces, and indentation for easier reading by humans. Always enabled in debug mode.", "Default: False"]}, {"name": "JSONTag", "path": "api/index#flask.json.tag.JSONTag", "type": "flask.json.tag", "text": ["Base class for defining type tags for TaggedJSONSerializer.", "serializer (TaggedJSONSerializer) \u2013 ", "None", "Check if the given value should be tagged by this tag.", "value (Any) \u2013 ", "bool", "The tag to mark the serialized object with. If None, this tag is only used as an intermediate step during tagging.", "Convert the value to a valid JSON type and add the tag structure around it.", "value (Any) \u2013 ", "Any", "Convert the Python object to an object that is a valid JSON type. The tag will be added later.", "value (Any) \u2013 ", "Any", "Convert the JSON representation back to the correct type. The tag will already be removed.", "value (Any) \u2013 ", "Any"]}, {"name": "JSONTag.check()", "path": "api/index#flask.json.tag.JSONTag.check", "type": "flask.json.tag", "text": ["Check if the given value should be tagged by this tag.", "value (Any) \u2013 ", "bool"]}, {"name": "JSONTag.key", "path": "api/index#flask.json.tag.JSONTag.key", "type": "flask.json.tag", "text": ["The tag to mark the serialized object with. If None, this tag is only used as an intermediate step during tagging."]}, {"name": "JSONTag.tag()", "path": "api/index#flask.json.tag.JSONTag.tag", "type": "flask.json.tag", "text": ["Convert the value to a valid JSON type and add the tag structure around it.", "value (Any) \u2013 ", "Any"]}, {"name": "JSONTag.to_json()", "path": "api/index#flask.json.tag.JSONTag.to_json", "type": "flask.json.tag", "text": ["Convert the Python object to an object that is a valid JSON type. The tag will be added later.", "value (Any) \u2013 ", "Any"]}, {"name": "JSONTag.to_python()", "path": "api/index#flask.json.tag.JSONTag.to_python", "type": "flask.json.tag", "text": ["Convert the JSON representation back to the correct type. The tag will already be removed.", "value (Any) \u2013 ", "Any"]}, {"name": "JSON_AS_ASCII", "path": "config/index#JSON_AS_ASCII", "type": "Configuration", "text": ["Serialize objects to ASCII-encoded JSON. If this is disabled, the JSON returned from jsonify will contain Unicode characters. This has security implications when rendering the JSON into JavaScript in templates, and should typically remain enabled.", "Default: True"]}, {"name": "JSON_SORT_KEYS", "path": "config/index#JSON_SORT_KEYS", "type": "Configuration", "text": ["Sort the keys of JSON objects alphabetically. This is useful for caching because it ensures the data is serialized the same way no matter what Python\u2019s hash seed is. While not recommended, you can disable this for a possible performance improvement at the cost of caching.", "Default: True"]}, {"name": "Large Applications as Packages", "path": "patterns/packages/index", "type": "User's Guide: Design Patterns", "text": ["Imagine a simple flask application structure that looks like this:", "While this is fine for small applications, for larger applications it\u2019s a good idea to use a package instead of a module. The Tutorial is structured to use the package pattern, see the example code.", "To convert that into a larger one, just create a new folder yourapplication inside the existing one and move everything below it. Then rename yourapplication.py to __init__.py. (Make sure to delete all .pyc files first, otherwise things would most likely break)", "You should then end up with something like that:", "But how do you run your application now? The naive python\nyourapplication/__init__.py will not work. Let\u2019s just say that Python does not want modules in packages to be the startup file. But that is not a big problem, just add a new file called setup.py next to the inner yourapplication folder with the following contents:", "In order to run the application you need to export an environment variable that tells Flask where to find the application instance:", "If you are outside of the project directory make sure to provide the exact path to your application directory. Similarly you can turn on the development features like this:", "In order to install and run the application you need to issue the following commands:", "What did we gain from this? Now we can restructure the application a bit into multiple modules. The only thing you have to remember is the following quick checklist:", "Here\u2019s an example __init__.py:", "And this is what views.py would look like:", "You should then end up with something like that:", "Circular Imports", "Every Python programmer hates them, and yet we just added some: circular imports (That\u2019s when two modules depend on each other. In this case views.py depends on __init__.py). Be advised that this is a bad idea in general but here it is actually fine. The reason for this is that we are not actually using the views in __init__.py and just ensuring the module is imported and we are doing that at the bottom of the file.", "There are still some problems with that approach but if you want to use decorators there is no way around that. Check out the Becoming Big section for some inspiration how to deal with that.", "If you have larger applications it\u2019s recommended to divide them into smaller groups where each group is implemented with the help of a blueprint. For a gentle introduction into this topic refer to the Modular Applications with Blueprints chapter of the documentation."]}, {"name": "Lazily Loading Views", "path": "patterns/lazyloading/index", "type": "User's Guide: Design Patterns", "text": ["Flask is usually used with the decorators. Decorators are simple and you have the URL right next to the function that is called for that specific URL. However there is a downside to this approach: it means all your code that uses decorators has to be imported upfront or Flask will never actually find your function.", "This can be a problem if your application has to import quick. It might have to do that on systems like Google\u2019s App Engine or other systems. So if you suddenly notice that your application outgrows this approach you can fall back to a centralized URL mapping.", "The system that enables having a central URL map is the add_url_rule() function. Instead of using decorators, you have a file that sets up the application with all URLs.", "Imagine the current application looks somewhat like this:", "Then, with the centralized approach you would have one file with the views (views.py) but without any decorator:", "And then a file that sets up an application which maps the functions to URLs:", "So far we only split up the views and the routing, but the module is still loaded upfront. The trick is to actually load the view function as needed. This can be accomplished with a helper class that behaves just like a function but internally imports the real function on first use:", "What\u2019s important here is is that __module__ and __name__ are properly set. This is used by Flask internally to figure out how to name the URL rules in case you don\u2019t provide a name for the rule yourself.", "Then you can define your central place to combine the views like this:", "You can further optimize this in terms of amount of keystrokes needed to write this by having a function that calls into add_url_rule() by prefixing a string with the project name and a dot, and by wrapping view_func in a LazyView as needed.", "One thing to keep in mind is that before and after request handlers have to be in a file that is imported upfront to work properly on the first request. The same goes for any kind of remaining decorator."]}, {"name": "load()", "path": "api/index#flask.json.load", "type": "flask.json", "text": ["Deserialize an object from JSON read from a file object.", "Takes the same arguments as the built-in json.load(), with some defaults from application configuration.", "Any", "Changed in version 2.0: encoding is deprecated and will be removed in Flask 2.1. The file must be text mode, or binary mode with UTF-8 bytes."]}, {"name": "loads()", "path": "api/index#flask.json.loads", "type": "flask.json", "text": ["Deserialize an object from a string of JSON.", "Takes the same arguments as the built-in json.loads(), with some defaults from application configuration.", "Any", "Changed in version 2.0: encoding is deprecated and will be removed in Flask 2.1. The data must be a string or UTF-8 bytes.", "Changed in version 1.0.3: app can be passed directly, rather than requiring an app context for configuration."]}, {"name": "load_dotenv()", "path": "api/index#flask.cli.load_dotenv", "type": "flask.cli", "text": ["Load \u201cdotenv\u201d files in order of precedence to set environment variables.", "If an env var is already set it is not overwritten, so earlier files in the list are preferred over later files.", "This is a no-op if python-dotenv is not installed.", "path \u2013 Load the file at this location instead of searching.", "True if a file was loaded.", "Changed in version 2.0: When loading the env files, set the default encoding to UTF-8.", "Changed in version 1.1.0: Returns False when python-dotenv is not installed, or when the given path isn\u2019t a file.", "New in version 1.0."]}, {"name": "Logging", "path": "logging/index", "type": "User\u2019s Guide", "text": ["Flask uses standard Python logging. Messages about your Flask application are logged with app.logger, which takes the same name as app.name. This logger can also be used to log your own messages.", "If you don\u2019t configure logging, Python\u2019s default log level is usually \u2018warning\u2019. Nothing below the configured level will be visible.", "When you want to configure logging for your project, you should do it as soon as possible when the program starts. If app.logger is accessed before logging is configured, it will add a default handler. If possible, configure logging before creating the application object.", "This example uses dictConfig() to create a logging configuration similar to Flask\u2019s default, except for all logs:", "If you do not configure logging yourself, Flask will add a StreamHandler to app.logger automatically. During requests, it will write to the stream specified by the WSGI server in environ['wsgi.errors'] (which is usually sys.stderr). Outside a request, it will log to sys.stderr.", "If you configured logging after accessing app.logger, and need to remove the default handler, you can import and remove it:", "When running the application on a remote server for production, you probably won\u2019t be looking at the log messages very often. The WSGI server will probably send log messages to a file, and you\u2019ll only check that file if a user tells you something went wrong.", "To be proactive about discovering and fixing bugs, you can configure a logging.handlers.SMTPHandler to send an email when errors and higher are logged.", "This requires that you have an SMTP server set up on the same server. See the Python docs for more information about configuring the handler.", "Seeing more information about the request, such as the IP address, may help debugging some errors. You can subclass logging.Formatter to inject your own fields that can be used in messages. You can change the formatter for Flask\u2019s default handler, the mail handler defined above, or any other handler.", "Other libraries may use logging extensively, and you want to see relevant messages from those logs too. The simplest way to do this is to add handlers to the root logger instead of only the app logger.", "Depending on your project, it may be more useful to configure each logger you care about separately, instead of configuring only the root logger.", "Werkzeug logs basic request/response information to the 'werkzeug' logger. If the root logger has no handlers configured, Werkzeug adds a StreamHandler to its logger.", "Depending on the situation, an extension may choose to log to app.logger or its own named logger. Consult each extension\u2019s documentation for details."]}, {"name": "make_response()", "path": "api/index#flask.make_response", "type": "flask", "text": ["Sometimes it is necessary to set additional headers in a view. Because views do not have to return response objects but can return a value that is converted into a response object by Flask itself, it becomes tricky to add headers to it. This function can be called instead of using a return and you will get a response object which you can use to attach headers.", "If view looked like this and you want to add a new header:", "You can now do something like this:", "This function accepts the very same arguments you can return from a view function. This for example creates a response with a 404 error code:", "The other use case of this function is to force the return value of a view function into a response which is helpful with view decorators:", "Internally this function does the following things:", "New in version 0.6.", "args (Any) \u2013 ", "Response"]}, {"name": "Markup", "path": "api/index#flask.Markup", "type": "flask", "text": ["A string that is ready to be safely inserted into an HTML or XML document, either because it was escaped or because it was marked safe.", "Passing an object to the constructor converts it to text and wraps it to mark it safe without escaping. To escape the text, use the escape() class method instead.", "This implements the __html__() interface that some frameworks use. Passing an object that implements __html__() will wrap the output of that method, marking it safe.", "This is a subclass of str. It has the same methods, but escapes their arguments and returns a Markup instance.", "Markup", "Escape a string. Calls escape() and ensures that for subclasses the correct type is returned.", "s (Any) \u2013 ", "markupsafe.Markup", "unescape() the markup, remove tags, and normalize whitespace to single spaces.", "str", "Convert escaped markup back into a text string. This replaces HTML entities with the characters they represent.", "str"]}, {"name": "Markup.escape()", "path": "api/index#flask.Markup.escape", "type": "flask", "text": ["Escape a string. Calls escape() and ensures that for subclasses the correct type is returned.", "s (Any) \u2013 ", "markupsafe.Markup"]}, {"name": "Markup.striptags()", "path": "api/index#flask.Markup.striptags", "type": "flask", "text": ["unescape() the markup, remove tags, and normalize whitespace to single spaces.", "str"]}, {"name": "Markup.unescape()", "path": "api/index#flask.Markup.unescape", "type": "flask", "text": ["Convert escaped markup back into a text string. This replaces HTML entities with the characters they represent.", "str"]}, {"name": "MAX_CONTENT_LENGTH", "path": "config/index#MAX_CONTENT_LENGTH", "type": "Configuration", "text": ["Don\u2019t read more than this many bytes from the incoming request data. If not set and the request does not specify a CONTENT_LENGTH, no data will be read for security.", "Default: None"]}, {"name": "MAX_COOKIE_SIZE", "path": "config/index#MAX_COOKIE_SIZE", "type": "Configuration", "text": ["Warn if cookie headers are larger than this many bytes. Defaults to 4093. Larger cookies may be silently ignored by browsers. Set to 0 to disable the warning."]}, {"name": "Message Flashing", "path": "patterns/flashing/index", "type": "User's Guide: Design Patterns", "text": ["Good applications and user interfaces are all about feedback. If the user does not get enough feedback they will probably end up hating the application. Flask provides a really simple way to give feedback to a user with the flashing system. The flashing system basically makes it possible to record a message at the end of a request and access it next request and only next request. This is usually combined with a layout template that does this. Note that browsers and sometimes web servers enforce a limit on cookie sizes. This means that flashing messages that are too large for session cookies causes message flashing to fail silently.", "So here is a full example:", "And here is the layout.html template which does the magic:", "Here is the index.html template which inherits from layout.html:", "And here is the login.html template which also inherits from layout.html:", "New in version 0.3.", "It is also possible to provide categories when flashing a message. The default category if nothing is provided is 'message'. Alternative categories can be used to give the user better feedback. For example error messages could be displayed with a red background.", "To flash a message with a different category, just use the second argument to the flash() function:", "Inside the template you then have to tell the get_flashed_messages() function to also return the categories. The loop looks slightly different in that situation then:", "This is just one example of how to render these flashed messages. One might also use the category to add a prefix such as <strong>Error:</strong> to the message.", "New in version 0.9.", "Optionally you can pass a list of categories which filters the results of get_flashed_messages(). This is useful if you wish to render each category in a separate block."]}, {"name": "MethodView", "path": "api/index#flask.views.MethodView", "type": "flask.views", "text": ["A class-based view that dispatches request methods to the corresponding class methods. For example, if you implement a get method, it will be used to handle GET requests.", "Subclasses have to override this method to implement the actual view function code. This method is called with all the arguments from the URL rule.", "Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], WSGIApplication]"]}, {"name": "MethodView.dispatch_request()", "path": "api/index#flask.views.MethodView.dispatch_request", "type": "flask.views", "text": ["Subclasses have to override this method to implement the actual view function code. This method is called with all the arguments from the URL rule.", "Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], WSGIApplication]"]}, {"name": "Modular Applications with Blueprints", "path": "blueprints/index", "type": "User\u2019s Guide", "text": ["New in version 0.7.", "Flask uses a concept of blueprints for making application components and supporting common patterns within an application or across applications. Blueprints can greatly simplify how large applications work and provide a central means for Flask extensions to register operations on applications. A Blueprint object works similarly to a Flask application object, but it is not actually an application. Rather it is a blueprint of how to construct or extend an application.", "Blueprints in Flask are intended for these cases:", "A blueprint in Flask is not a pluggable app because it is not actually an application \u2013 it\u2019s a set of operations which can be registered on an application, even multiple times. Why not have multiple application objects? You can do that (see Application Dispatching), but your applications will have separate configs and will be managed at the WSGI layer.", "Blueprints instead provide separation at the Flask level, share application config, and can change an application object as necessary with being registered. The downside is that you cannot unregister a blueprint once an application was created without having to destroy the whole application object.", "The basic concept of blueprints is that they record operations to execute when registered on an application. Flask associates view functions with blueprints when dispatching requests and generating URLs from one endpoint to another.", "This is what a very basic blueprint looks like. In this case we want to implement a blueprint that does simple rendering of static templates:", "When you bind a function with the help of the @simple_page.route decorator, the blueprint will record the intention of registering the function show on the application when it\u2019s later registered. Additionally it will prefix the endpoint of the function with the name of the blueprint which was given to the Blueprint constructor (in this case also simple_page). The blueprint\u2019s name does not modify the URL, only the endpoint.", "So how do you register that blueprint? Like this:", "If you check the rules registered on the application, you will find these:", "The first one is obviously from the application itself for the static files. The other two are for the show function of the simple_page blueprint. As you can see, they are also prefixed with the name of the blueprint and separated by a dot (.).", "Blueprints however can also be mounted at different locations:", "And sure enough, these are the generated rules:", "On top of that you can register blueprints multiple times though not every blueprint might respond properly to that. In fact it depends on how the blueprint is implemented if it can be mounted more than once.", "It is possible to register a blueprint on another blueprint.", "The child blueprint will gain the parent\u2019s name as a prefix to its name, and child URLs will be prefixed with the parent\u2019s URL prefix.", "Blueprint-specific before request functions, etc. registered with the parent will trigger for the child. If a child does not have an error handler that can handle a given exception, the parent\u2019s will be tried.", "Blueprints can provide resources as well. Sometimes you might want to introduce a blueprint only for the resources it provides.", "Like for regular applications, blueprints are considered to be contained in a folder. While multiple blueprints can originate from the same folder, it does not have to be the case and it\u2019s usually not recommended.", "The folder is inferred from the second argument to Blueprint which is usually __name__. This argument specifies what logical Python module or package corresponds to the blueprint. If it points to an actual Python package that package (which is a folder on the filesystem) is the resource folder. If it\u2019s a module, the package the module is contained in will be the resource folder. You can access the Blueprint.root_path property to see what the resource folder is:", "To quickly open sources from this folder you can use the open_resource() function:", "A blueprint can expose a folder with static files by providing the path to the folder on the filesystem with the static_folder argument. It is either an absolute path or relative to the blueprint\u2019s location:", "By default the rightmost part of the path is where it is exposed on the web. This can be changed with the static_url_path argument. Because the folder is called static here it will be available at the url_prefix of the blueprint + /static. If the blueprint has the prefix /admin, the static URL will be /admin/static.", "The endpoint is named blueprint_name.static. You can generate URLs to it with url_for() like you would with the static folder of the application:", "However, if the blueprint does not have a url_prefix, it is not possible to access the blueprint\u2019s static folder. This is because the URL would be /static in this case, and the application\u2019s /static route takes precedence. Unlike template folders, blueprint static folders are not searched if the file does not exist in the application static folder.", "If you want the blueprint to expose templates you can do that by providing the template_folder parameter to the Blueprint constructor:", "For static files, the path can be absolute or relative to the blueprint resource folder.", "The template folder is added to the search path of templates but with a lower priority than the actual application\u2019s template folder. That way you can easily override templates that a blueprint provides in the actual application. This also means that if you don\u2019t want a blueprint template to be accidentally overridden, make sure that no other blueprint or actual application template has the same relative path. When multiple blueprints provide the same relative template path the first blueprint registered takes precedence over the others.", "So if you have a blueprint in the folder yourapplication/admin and you want to render the template 'admin/index.html' and you have provided templates as a template_folder you will have to create a file like this: yourapplication/admin/templates/admin/index.html. The reason for the extra admin folder is to avoid getting our template overridden by a template named index.html in the actual application template folder.", "To further reiterate this: if you have a blueprint named admin and you want to render a template called index.html which is specific to this blueprint, the best idea is to lay out your templates like this:", "And then when you want to render the template, use admin/index.html as the name to look up the template by. If you encounter problems loading the correct templates enable the EXPLAIN_TEMPLATE_LOADING config variable which will instruct Flask to print out the steps it goes through to locate templates on every render_template call.", "If you want to link from one page to another you can use the url_for() function just like you normally would do just that you prefix the URL endpoint with the name of the blueprint and a dot (.):", "Additionally if you are in a view function of a blueprint or a rendered template and you want to link to another endpoint of the same blueprint, you can use relative redirects by prefixing the endpoint with a dot only:", "This will link to admin.index for instance in case the current request was dispatched to any other admin blueprint endpoint.", "Blueprints support the errorhandler decorator just like the Flask application object, so it is easy to make Blueprint-specific custom error pages.", "Here is an example for a \u201c404 Page Not Found\u201d exception:", "Most errorhandlers will simply work as expected; however, there is a caveat concerning handlers for 404 and 405 exceptions. These errorhandlers are only invoked from an appropriate raise statement or a call to abort in another of the blueprint\u2019s view functions; they are not invoked by, e.g., an invalid URL access. This is because the blueprint does not \u201cown\u201d a certain URL space, so the application instance has no way of knowing which blueprint error handler it should run if given an invalid URL. If you would like to execute different handling strategies for these errors based on URL prefixes, they may be defined at the application level using the request proxy object:", "See Handling Application Errors."]}, {"name": "mod_wsgi (Apache)", "path": "deploying/mod_wsgi/index", "type": "User's Guide: Deploying", "text": ["If you are using the Apache webserver, consider using mod_wsgi.", "Watch Out", "Please make sure in advance that any app.run() calls you might have in your application file are inside an if __name__ ==\n'__main__': block or moved to a separate file. Just make sure it\u2019s not called because this will always start a local WSGI server which we do not want if we deploy that application to mod_wsgi.", "If you don\u2019t have mod_wsgi installed yet you have to either install it using a package manager or compile it yourself. The mod_wsgi installation instructions cover source installations on UNIX systems.", "If you are using Ubuntu/Debian you can apt-get it and activate it as follows:", "If you are using a yum based distribution (Fedora, OpenSUSE, etc..) you can install it as follows:", "On FreeBSD install mod_wsgi by compiling the www/mod_wsgi port or by using pkg_add:", "If you are using pkgsrc you can install mod_wsgi by compiling the www/ap2-wsgi package.", "If you encounter segfaulting child processes after the first apache reload you can safely ignore them. Just restart the server.", "To run your application you need a yourapplication.wsgi file. This file contains the code mod_wsgi is executing on startup to get the application object. The object called application in that file is then used as application.", "For most applications the following file should be sufficient:", "If a factory function is used in a __init__.py file, then the function should be imported:", "If you don\u2019t have a factory function for application creation but a singleton instance you can directly import that one as application.", "Store that file somewhere that you will find it again (e.g.: /var/www/yourapplication) and make sure that yourapplication and all the libraries that are in use are on the python load path. If you don\u2019t want to install it system wide consider using a virtual python instance. Keep in mind that you will have to actually install your application into the virtualenv as well. Alternatively there is the option to just patch the path in the .wsgi file before the import:", "The last thing you have to do is to create an Apache configuration file for your application. In this example we are telling mod_wsgi to execute the application under a different user for security reasons:", "Note: WSGIDaemonProcess isn\u2019t implemented in Windows and Apache will refuse to run with the above configuration. On a Windows system, eliminate those lines:", "Note: There have been some changes in access control configuration for Apache 2.4.", "Most notably, the syntax for directory permissions has changed from httpd 2.2", "to httpd 2.4 syntax", "For more information consult the mod_wsgi documentation.", "If your application does not run, follow this guide to troubleshoot:", "You have an app.run() call in your application file that is not guarded by an if __name__ == '__main__': condition. Either remove that run() call from the file and move it into a separate run.py file or put it into such an if block.", "Probably caused by your application running as the wrong user. Make sure the folders the application needs access to have the proper privileges set and the application runs as the correct user (user and group parameter to the WSGIDaemonProcess directive)", "Keep in mind that mod_wsgi disallows doing anything with sys.stdout and sys.stderr. You can disable this protection from the config by setting the WSGIRestrictStdout to off:", "Alternatively you can also replace the standard out in the .wsgi file with a different stream:", "Your application probably is a single .py file you symlinked into the site-packages folder. Please be aware that this does not work, instead you either have to put the folder into the pythonpath the file is stored in, or convert your application into a package.", "The reason for this is that for non-installed packages, the module filename is used to locate the resources and for symlinks the wrong filename is picked up.", "To help deployment tools you can activate support for automatic reloading. Whenever something changes the .wsgi file, mod_wsgi will reload all the daemon processes for us.", "For that, just add the following directive to your Directory section:", "Virtual environments have the advantage that they never install the required dependencies system wide so you have a better control over what is used where. If you want to use a virtual environment with mod_wsgi you have to modify your .wsgi file slightly.", "Add the following lines to the top of your .wsgi file:", "This sets up the load paths according to the settings of the virtual environment. Keep in mind that the path has to be absolute."]}, {"name": "MongoDB with MongoEngine", "path": "patterns/mongoengine/index", "type": "User's Guide: Design Patterns", "text": ["Using a document database like MongoDB is a common alternative to relational SQL databases. This pattern shows how to use MongoEngine, a document mapper library, to integrate with MongoDB.", "A running MongoDB server and Flask-MongoEngine are required.", "Basic setup can be done by defining MONGODB_SETTINGS on app.config and creating a MongoEngine instance.", "To declare a model that represents a Mongo document, create a class that inherits from Document and declare each of the fields.", "If the document has nested fields, use EmbeddedDocument to defined the fields of the embedded document and EmbeddedDocumentField to declare it on the parent document.", "Instantiate your document class with keyword arguments for the fields. You can also assign values to the field attributes after instantiation. Then call doc.save().", "Use the class objects attribute to make queries. A keyword argument looks for an equal value on the field.", "Query operators may be used by concatenating them with the field name using a double-underscore. objects, and queries returned by calling it, are iterable.", "There are many more ways to define and query documents with MongoEngine. For more information, check out the official documentation.", "Flask-MongoEngine adds helpful utilities on top of MongoEngine. Check out their documentation as well."]}, {"name": "Namespace", "path": "api/index#flask.signals.Namespace", "type": "flask.signals", "text": ["An alias for blinker.base.Namespace if blinker is available, otherwise a dummy class that creates fake signals. This class is available for Flask extensions that want to provide the same fallback system as Flask itself.", "Creates a new signal for this namespace if blinker is available, otherwise returns a fake signal that has a send method that will do nothing but will fail with a RuntimeError for all other operations, including connecting."]}, {"name": "Namespace.signal()", "path": "api/index#flask.signals.Namespace.signal", "type": "flask.signals", "text": ["Creates a new signal for this namespace if blinker is available, otherwise returns a fake signal that has a send method that will do nothing but will fail with a RuntimeError for all other operations, including connecting."]}, {"name": "NullSession", "path": "api/index#flask.sessions.NullSession", "type": "flask.sessions", "text": ["Class used to generate nicer error messages if sessions are not available. Will still allow read-only access to the empty session but fail on setting.", "initial (Any) \u2013 ", "None"]}, {"name": "pass_script_info()", "path": "api/index#flask.cli.pass_script_info", "type": "flask.cli", "text": ["Marks a function so that an instance of ScriptInfo is passed as first argument to the click callback.", "f (click.decorators.F) \u2013 ", "click.decorators.F"]}, {"name": "Patterns for Flask", "path": "patterns/index", "type": "User's Guide: Design Patterns", "text": ["Certain features and interactions are common enough that you will find them in most web applications. For example, many applications use a relational database and user authentication. They will open a database connection at the beginning of the request and get the information for the logged in user. At the end of the request, the database connection is closed.", "These types of patterns may be a bit outside the scope of Flask itself, but Flask makes it easy to implement them. Some common patterns are collected in the following pages."]}, {"name": "PERMANENT_SESSION_LIFETIME", "path": "config/index#PERMANENT_SESSION_LIFETIME", "type": "Configuration", "text": ["If session.permanent is true, the cookie\u2019s expiration will be set this number of seconds in the future. Can either be a datetime.timedelta or an int.", "Flask\u2019s default cookie implementation validates that the cryptographic signature is not older than this value.", "Default: timedelta(days=31) (2678400 seconds)"]}, {"name": "Pluggable Views", "path": "views/index", "type": "User\u2019s Guide", "text": ["New in version 0.7.", "Flask 0.7 introduces pluggable views inspired by the generic views from Django which are based on classes instead of functions. The main intention is that you can replace parts of the implementations and this way have customizable pluggable views.", "Consider you have a function that loads a list of objects from the database and renders into a template:", "This is simple and flexible, but if you want to provide this view in a generic fashion that can be adapted to other models and templates as well you might want more flexibility. This is where pluggable class-based views come into place. As the first step to convert this into a class based view you would do this:", "As you can see what you have to do is to create a subclass of flask.views.View and implement dispatch_request(). Then we have to convert that class into an actual view function by using the as_view() class method. The string you pass to that function is the name of the endpoint that view will then have. But this by itself is not helpful, so let\u2019s refactor the code a bit:", "This of course is not that helpful for such a small example, but it\u2019s good enough to explain the basic principle. When you have a class-based view the question comes up what self points to. The way this works is that whenever the request is dispatched a new instance of the class is created and the dispatch_request() method is called with the parameters from the URL rule. The class itself is instantiated with the parameters passed to the as_view() function. For instance you can write a class like this:", "And then you can register it like this:", "Pluggable views are attached to the application like a regular function by either using route() or better add_url_rule(). That however also means that you would have to provide the names of the HTTP methods the view supports when you attach this. In order to move that information to the class you can provide a methods attribute that has this information:", "For RESTful APIs it\u2019s especially helpful to execute a different function for each HTTP method. With the flask.views.MethodView you can easily do that. Each HTTP method maps to a function with the same name (just in lowercase):", "That way you also don\u2019t have to provide the methods attribute. It\u2019s automatically set based on the methods defined in the class.", "Since the view class itself is not the view function that is added to the routing system it does not make much sense to decorate the class itself. Instead you either have to decorate the return value of as_view() by hand:", "Starting with Flask 0.8 there is also an alternative way where you can specify a list of decorators to apply in the class declaration:", "Due to the implicit self from the caller\u2019s perspective you cannot use regular view decorators on the individual methods of the view however, keep this in mind.", "Web APIs are often working very closely with HTTP verbs so it makes a lot of sense to implement such an API based on the MethodView. That said, you will notice that the API will require different URL rules that go to the same method view most of the time. For instance consider that you are exposing a user object on the web:", "URL", "Method", "Description", "/users/", "GET", "Gives a list of all users", "/users/", "POST", "Creates a new user", "/users/<id>", "GET", "Shows a single user", "/users/<id>", "PUT", "Updates a single user", "/users/<id>", "DELETE", "Deletes a single user", "So how would you go about doing that with the MethodView? The trick is to take advantage of the fact that you can provide multiple rules to the same view.", "Let\u2019s assume for the moment the view would look like this:", "So how do we hook this up with the routing system? By adding two rules and explicitly mentioning the methods for each:", "If you have a lot of APIs that look similar you can refactor that registration code:"]}, {"name": "PREFERRED_URL_SCHEME", "path": "config/index#PREFERRED_URL_SCHEME", "type": "Configuration", "text": ["Use this scheme for generating external URLs when not in a request context.", "Default: 'http'"]}, {"name": "PRESERVE_CONTEXT_ON_EXCEPTION", "path": "config/index#PRESERVE_CONTEXT_ON_EXCEPTION", "type": "Configuration", "text": ["Don\u2019t pop the request context when an exception occurs. If not set, this is true if DEBUG is true. This allows debuggers to introspect the request data on errors, and should normally not need to be set directly.", "Default: None"]}, {"name": "PROPAGATE_EXCEPTIONS", "path": "config/index#PROPAGATE_EXCEPTIONS", "type": "Configuration", "text": ["Exceptions are re-raised rather than being handled by the app\u2019s error handlers. If not set, this is implicitly true if TESTING or DEBUG is enabled.", "Default: None"]}, {"name": "Quickstart", "path": "quickstart/index", "type": "User\u2019s Guide", "text": ["Eager to get started? This page gives a good introduction to Flask. Follow Installation to set up a project and install Flask first.", "A minimal Flask application looks something like this:", "So what did that code do?", "Save it as hello.py or something similar. Make sure to not call your application flask.py because this would conflict with Flask itself.", "To run the application, use the flask command or python -m flask. Before you can do that you need to tell your terminal the application to work with by exporting the FLASK_APP environment variable:", "Application Discovery Behavior", "As a shortcut, if the file is named app.py or wsgi.py, you don\u2019t have to set the FLASK_APP environment variable. See Command Line Interface for more details.", "This launches a very simple builtin server, which is good enough for testing but probably not what you want to use in production. For deployment options see Deployment Options.", "Now head over to http://127.0.0.1:5000/, and you should see your hello world greeting.", "Externally Visible Server", "If you run the server you will notice that the server is only accessible from your own computer, not from any other in the network. This is the default because in debugging mode a user of the application can execute arbitrary Python code on your computer.", "If you have the debugger disabled or trust the users on your network, you can make the server publicly available simply by adding --host=0.0.0.0 to the command line:", "This tells your operating system to listen on all public IPs.", "In case the python -m flask fails or flask does not exist, there are multiple reasons this might be the case. First of all you need to look at the error message.", "Versions of Flask older than 0.11 used to have different ways to start the application. In short, the flask command did not exist, and neither did python -m flask. In that case you have two options: either upgrade to newer Flask versions or have a look at Development Server to see the alternative method for running a server.", "The FLASK_APP environment variable is the name of the module to import at flask run. In case that module is incorrectly named you will get an import error upon start (or if debug is enabled when you navigate to the application). It will tell you what it tried to import and why it failed.", "The most common reason is a typo or because you did not actually create an app object.", "The flask run command can do more than just start the development server. By enabling debug mode, the server will automatically reload if code changes, and will show an interactive debugger in the browser if an error occurs during a request.", "Warning", "The debugger allows executing arbitrary Python code from the browser. It is protected by a pin, but still represents a major security risk. Do not run the development server or debugger in a production environment.", "To enable all development features, set the FLASK_ENV environment variable to development before calling flask run.", "See also:", "When returning HTML (the default response type in Flask), any user-provided values rendered in the output must be escaped to protect from injection attacks. HTML templates rendered with Jinja, introduced later, will do this automatically.", "escape(), shown here, can be used manually. It is omitted in most examples for brevity, but you should always be aware of how you\u2019re using untrusted data.", "If a user managed to submit the name <script>alert(\"bad\")</script>, escaping causes it to be rendered as text, rather than running the script in the user\u2019s browser.", "<name> in the route captures a value from the URL and passes it to the view function. These variable rules are explained below.", "Modern web applications use meaningful URLs to help users. Users are more likely to like a page and come back if the page uses a meaningful URL they can remember and use to directly visit a page.", "Use the route() decorator to bind a function to a URL.", "You can do more! You can make parts of the URL dynamic and attach multiple rules to a function.", "You can add variable sections to a URL by marking sections with <variable_name>. Your function then receives the <variable_name> as a keyword argument. Optionally, you can use a converter to specify the type of the argument like <converter:variable_name>.", "Converter types:", "string", "(default) accepts any text without a slash", "int", "accepts positive integers", "float", "accepts positive floating point values", "path", "like string but also accepts slashes", "uuid", "accepts UUID strings", "The following two rules differ in their use of a trailing slash.", "The canonical URL for the projects endpoint has a trailing slash. It\u2019s similar to a folder in a file system. If you access the URL without a trailing slash (/projects), Flask redirects you to the canonical URL with the trailing slash (/projects/).", "The canonical URL for the about endpoint does not have a trailing slash. It\u2019s similar to the pathname of a file. Accessing the URL with a trailing slash (/about/) produces a 404 \u201cNot Found\u201d error. This helps keep URLs unique for these resources, which helps search engines avoid indexing the same page twice.", "To build a URL to a specific function, use the url_for() function. It accepts the name of the function as its first argument and any number of keyword arguments, each corresponding to a variable part of the URL rule. Unknown variable parts are appended to the URL as query parameters.", "Why would you want to build URLs using the URL reversing function url_for() instead of hard-coding them into your templates?", "For example, here we use the test_request_context() method to try out url_for(). test_request_context() tells Flask to behave as though it\u2019s handling a request even while we use a Python shell. See Context Locals.", "Web applications use different HTTP methods when accessing URLs. You should familiarize yourself with the HTTP methods as you work with Flask. By default, a route only answers to GET requests. You can use the methods argument of the route() decorator to handle different HTTP methods.", "If GET is present, Flask automatically adds support for the HEAD method and handles HEAD requests according to the HTTP RFC. Likewise, OPTIONS is automatically implemented for you.", "Dynamic web applications also need static files. That\u2019s usually where the CSS and JavaScript files are coming from. Ideally your web server is configured to serve them for you, but during development Flask can do that as well. Just create a folder called static in your package or next to your module and it will be available at /static on the application.", "To generate URLs for static files, use the special 'static' endpoint name:", "The file has to be stored on the filesystem as static/style.css.", "Generating HTML from within Python is not fun, and actually pretty cumbersome because you have to do the HTML escaping on your own to keep the application secure. Because of that Flask configures the Jinja2 template engine for you automatically.", "To render a template you can use the render_template() method. All you have to do is provide the name of the template and the variables you want to pass to the template engine as keyword arguments. Here\u2019s a simple example of how to render a template:", "Flask will look for templates in the templates folder. So if your application is a module, this folder is next to that module, if it\u2019s a package it\u2019s actually inside your package:", "Case 1: a module:", "Case 2: a package:", "For templates you can use the full power of Jinja2 templates. Head over to the official Jinja2 Template Documentation for more information.", "Here is an example template:", "Inside templates you also have access to the request, session and g 1 objects as well as the get_flashed_messages() function.", "Templates are especially useful if inheritance is used. If you want to know how that works, see Template Inheritance. Basically template inheritance makes it possible to keep certain elements on each page (like header, navigation and footer).", "Automatic escaping is enabled, so if name contains HTML it will be escaped automatically. If you can trust a variable and you know that it will be safe HTML (for example because it came from a module that converts wiki markup to HTML) you can mark it as safe by using the Markup class or by using the |safe filter in the template. Head over to the Jinja 2 documentation for more examples.", "Here is a basic introduction to how the Markup class works:", "Changed in version 0.5: Autoescaping is no longer enabled for all templates. The following extensions for templates trigger autoescaping: .html, .htm, .xml, .xhtml. Templates loaded from a string will have autoescaping disabled.", "Unsure what that g object is? It\u2019s something in which you can store information for your own needs. See the documentation for flask.g and Using SQLite 3 with Flask.", "For web applications it\u2019s crucial to react to the data a client sends to the server. In Flask this information is provided by the global request object. If you have some experience with Python you might be wondering how that object can be global and how Flask manages to still be threadsafe. The answer is context locals:", "Insider Information", "If you want to understand how that works and how you can implement tests with context locals, read this section, otherwise just skip it.", "Certain objects in Flask are global objects, but not of the usual kind. These objects are actually proxies to objects that are local to a specific context. What a mouthful. But that is actually quite easy to understand.", "Imagine the context being the handling thread. A request comes in and the web server decides to spawn a new thread (or something else, the underlying object is capable of dealing with concurrency systems other than threads). When Flask starts its internal request handling it figures out that the current thread is the active context and binds the current application and the WSGI environments to that context (thread). It does that in an intelligent way so that one application can invoke another application without breaking.", "So what does this mean to you? Basically you can completely ignore that this is the case unless you are doing something like unit testing. You will notice that code which depends on a request object will suddenly break because there is no request object. The solution is creating a request object yourself and binding it to the context. The easiest solution for unit testing is to use the test_request_context() context manager. In combination with the with statement it will bind a test request so that you can interact with it. Here is an example:", "The other possibility is passing a whole WSGI environment to the request_context() method:", "The request object is documented in the API section and we will not cover it here in detail (see Request). Here is a broad overview of some of the most common operations. First of all you have to import it from the flask module:", "The current request method is available by using the method attribute. To access form data (data transmitted in a POST or PUT request) you can use the form attribute. Here is a full example of the two attributes mentioned above:", "What happens if the key does not exist in the form attribute? In that case a special KeyError is raised. You can catch it like a standard KeyError but if you don\u2019t do that, a HTTP 400 Bad Request error page is shown instead. So for many situations you don\u2019t have to deal with that problem.", "To access parameters submitted in the URL (?key=value) you can use the args attribute:", "We recommend accessing URL parameters with get or by catching the KeyError because users might change the URL and presenting them a 400 bad request page in that case is not user friendly.", "For a full list of methods and attributes of the request object, head over to the Request documentation.", "You can handle uploaded files with Flask easily. Just make sure not to forget to set the enctype=\"multipart/form-data\" attribute on your HTML form, otherwise the browser will not transmit your files at all.", "Uploaded files are stored in memory or at a temporary location on the filesystem. You can access those files by looking at the files attribute on the request object. Each uploaded file is stored in that dictionary. It behaves just like a standard Python file object, but it also has a save() method that allows you to store that file on the filesystem of the server. Here is a simple example showing how that works:", "If you want to know how the file was named on the client before it was uploaded to your application, you can access the filename attribute. However please keep in mind that this value can be forged so never ever trust that value. If you want to use the filename of the client to store the file on the server, pass it through the secure_filename() function that Werkzeug provides for you:", "For some better examples, see Uploading Files.", "To access cookies you can use the cookies attribute. To set cookies you can use the set_cookie method of response objects. The cookies attribute of request objects is a dictionary with all the cookies the client transmits. If you want to use sessions, do not use the cookies directly but instead use the Sessions in Flask that add some security on top of cookies for you.", "Reading cookies:", "Storing cookies:", "Note that cookies are set on response objects. Since you normally just return strings from the view functions Flask will convert them into response objects for you. If you explicitly want to do that you can use the make_response() function and then modify it.", "Sometimes you might want to set a cookie at a point where the response object does not exist yet. This is possible by utilizing the Deferred Request Callbacks pattern.", "For this also see About Responses.", "To redirect a user to another endpoint, use the redirect() function; to abort a request early with an error code, use the abort() function:", "This is a rather pointless example because a user will be redirected from the index to a page they cannot access (401 means access denied) but it shows how that works.", "By default a black and white error page is shown for each error code. If you want to customize the error page, you can use the errorhandler() decorator:", "Note the 404 after the render_template() call. This tells Flask that the status code of that page should be 404 which means not found. By default 200 is assumed which translates to: all went well.", "See Handling Application Errors for more details.", "The return value from a view function is automatically converted into a response object for you. If the return value is a string it\u2019s converted into a response object with the string as response body, a 200 OK status code and a text/html mimetype. If the return value is a dict, jsonify() is called to produce a response. The logic that Flask applies to converting return values into response objects is as follows:", "If you want to get hold of the resulting response object inside the view you can use the make_response() function.", "Imagine you have a view like this:", "You just need to wrap the return expression with make_response() and get the response object to modify it, then return it:", "A common response format when writing an API is JSON. It\u2019s easy to get started writing such an API with Flask. If you return a dict from a view, it will be converted to a JSON response.", "Depending on your API design, you may want to create JSON responses for types other than dict. In that case, use the jsonify() function, which will serialize any supported JSON data type. Or look into Flask community extensions that support more complex applications.", "In addition to the request object there is also a second object called session which allows you to store information specific to a user from one request to the next. This is implemented on top of cookies for you and signs the cookies cryptographically. What this means is that the user could look at the contents of your cookie but not modify it, unless they know the secret key used for signing.", "In order to use sessions you have to set a secret key. Here is how sessions work:", "How to generate good secret keys", "A secret key should be as random as possible. Your operating system has ways to generate pretty random data based on a cryptographic random generator. Use the following command to quickly generate a value for Flask.secret_key (or SECRET_KEY):", "A note on cookie-based sessions: Flask will take the values you put into the session object and serialize them into a cookie. If you are finding some values do not persist across requests, cookies are indeed enabled, and you are not getting a clear error message, check the size of the cookie in your page responses compared to the size supported by web browsers.", "Besides the default client-side based sessions, if you want to handle sessions on the server-side instead, there are several Flask extensions that support this.", "Good applications and user interfaces are all about feedback. If the user does not get enough feedback they will probably end up hating the application. Flask provides a really simple way to give feedback to a user with the flashing system. The flashing system basically makes it possible to record a message at the end of a request and access it on the next (and only the next) request. This is usually combined with a layout template to expose the message.", "To flash a message use the flash() method, to get hold of the messages you can use get_flashed_messages() which is also available in the templates. See Message Flashing for a full example.", "New in version 0.3.", "Sometimes you might be in a situation where you deal with data that should be correct, but actually is not. For example you may have some client-side code that sends an HTTP request to the server but it\u2019s obviously malformed. This might be caused by a user tampering with the data, or the client code failing. Most of the time it\u2019s okay to reply with 400 Bad Request in that situation, but sometimes that won\u2019t do and the code has to continue working.", "You may still want to log that something fishy happened. This is where loggers come in handy. As of Flask 0.3 a logger is preconfigured for you to use.", "Here are some example log calls:", "The attached logger is a standard logging Logger, so head over to the official logging docs for more information.", "See Handling Application Errors.", "To add WSGI middleware to your Flask application, wrap the application\u2019s wsgi_app attribute. For example, to apply Werkzeug\u2019s ProxyFix middleware for running behind Nginx:", "Wrapping app.wsgi_app instead of app means that app still points at your Flask application, not at the middleware, so you can continue to use and configure app directly.", "Extensions are packages that help you accomplish common tasks. For example, Flask-SQLAlchemy provides SQLAlchemy support that makes it simple and easy to use with Flask.", "For more on Flask extensions, see Extensions.", "Ready to deploy your new Flask app? See Deployment Options."]}, {"name": "redirect()", "path": "api/index#flask.redirect", "type": "flask", "text": ["Returns a response object (a WSGI application) that, if called, redirects the client to the target location. Supported codes are 301, 302, 303, 305, 307, and 308. 300 is not supported because it\u2019s not a real redirect and 304 because it\u2019s the answer for a request with a request with defined If-Modified-Since headers.", "New in version 0.10: The class used for the Response object can now be passed in.", "New in version 0.6: The location can now be a unicode string that is encoded using the iri_to_uri() function.", "Response"]}, {"name": "render_template()", "path": "api/index#flask.render_template", "type": "flask", "text": ["Renders a template from the template folder with the given context.", "str"]}, {"name": "render_template_string()", "path": "api/index#flask.render_template_string", "type": "flask", "text": ["Renders a template from the given template source string with the given context. Template variables will be autoescaped.", "str"]}, {"name": "Request", "path": "api/index#flask.Request", "type": "flask", "text": ["The request object used by default in Flask. Remembers the matched endpoint and view arguments.", "It is what ends up as request. If you want to replace the request object used you can subclass this and set request_class to your subclass.", "The request object is a Request subclass and provides all of the attributes Werkzeug defines plus a few Flask specific ones.", "None", "List of charsets this client supports as CharsetAccept object.", "List of encodings this client accepts. Encodings in a HTTP term are compression encodings such as gzip. For charsets have a look at accept_charset.", "List of languages this client accepts as LanguageAccept object.", "List of mimetypes this client supports as MIMEAccept object.", "Sent with a preflight request to indicate which headers will be sent with the cross origin request. Set access_control_allow_headers on the response to indicate which headers are allowed.", "Sent with a preflight request to indicate which method will be used for the cross origin request. Set access_control_allow_methods on the response to indicate which methods are allowed.", "If a forwarded header exists this is a list of all ip addresses from the client ip to the last proxy server.", "Decorate a function as responder that accepts the request as the last argument. This works like the responder() decorator but the function is passed the request object as the last argument and the request object will be closed automatically:", "As of Werkzeug 0.14 HTTP exceptions are automatically caught and converted to responses instead of failing.", "f (Callable[[Request], WSGIApplication]) \u2013 the WSGI callable to decorate", "a new WSGI callable", "WSGIApplication", "The parsed URL parameters (the part in the URL after the question mark).", "By default an ImmutableMultiDict is returned from this function. This can be changed by setting parameter_storage_class to a different type. This might be necessary if the order of the form data is important.", "The Authorization object in parsed form.", "Like url but without the query string.", "The name of the current blueprint", "A RequestCacheControl object for the incoming cache control headers.", "Closes associated resources of this request object. This closes all file handles explicitly. You can also use the request object in a with statement which will automatically close it.", "New in version 0.9.", "None", "The Content-Encoding entity-header field is used as a modifier to the media-type. When present, its value indicates what additional content codings have been applied to the entity-body, and thus what decoding mechanisms must be applied in order to obtain the media-type referenced by the Content-Type header field.", "New in version 0.9.", "The Content-Length entity-header field indicates the size of the entity-body in bytes or, in the case of the HEAD method, the size of the entity-body that would have been sent had the request been a GET.", "The Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest of the entity-body for the purpose of providing an end-to-end message integrity check (MIC) of the entity-body. (Note: a MIC is good for detecting accidental modification of the entity-body in transit, but is not proof against malicious attacks.)", "New in version 0.9.", "The Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of the HEAD method, the media type that would have been sent had the request been a GET.", "A dict with the contents of all cookies transmitted with the request.", "Contains the incoming request data as string in case it came with a mimetype Werkzeug does not handle.", "The Date general-header field represents the date and time at which the message was originated, having the same semantics as orig-date in RFC 822.", "Changed in version 2.0: The datetime object is timezone-aware.", "alias of werkzeug.datastructures.ImmutableMultiDict", "The endpoint that matched the request. This in combination with view_args can be used to reconstruct the same or a modified URL. If an exception happened when matching, this will be None.", "The WSGI environment containing HTTP headers and information from the WSGI server.", "MultiDict object containing all uploaded files. Each key in files is the name from the <input type=\"file\" name=\"\">. Each value in files is a Werkzeug FileStorage object.", "It basically behaves like a standard file object you know from Python, with the difference that it also has a save() function that can store the file on the filesystem.", "Note that files will only contain data if the request method was POST, PUT or PATCH and the <form> that posted to the request had enctype=\"multipart/form-data\". It will be empty otherwise.", "See the MultiDict / FileStorage documentation for more details about the used data structure.", "The form parameters. By default an ImmutableMultiDict is returned from this function. This can be changed by setting parameter_storage_class to a different type. This might be necessary if the order of the form data is important.", "Please keep in mind that file uploads will not end up here, but instead in the files attribute.", "Changed in version 0.9: Previous to Werkzeug 0.9 this would only contain form data for POST and PUT requests.", "alias of werkzeug.formparser.FormDataParser", "Create a new request object based on the values provided. If environ is given missing values are filled from there. This method is useful for small scripts when you need to simulate a request from an URL. Do not use this method for unittesting, there is a full featured client object (Client) that allows to create multipart requests, support for cookies etc.", "This accepts the same options as the EnvironBuilder.", "Changed in version 0.5: This method now accepts the same arguments as EnvironBuilder. Because of this the environ parameter is now called environ_overrides.", "request object", "werkzeug.wrappers.request.Request", "Requested path, including the query string.", "This reads the buffered incoming data from the client into one bytes object. By default this is cached but that behavior can be changed by setting cache to False.", "Usually it\u2019s a bad idea to call this method without checking the content length first as a client could send dozens of megabytes or more to cause memory problems on the server.", "Note that if the form data was already parsed this method will not return anything as form data parsing does not cache the data like this method does. To implicitly invoke form data parsing function set parse_form_data to True. When this is done the return value of this method will be an empty string if the form parser handles the data. This generally is not necessary as if the whole data is cached (which is the default) the form parser will used the cached data to parse the form data. Please be generally aware of checking the content length first in any case before calling this method to avoid exhausting server memory.", "If as_text is set to True the return value will be a decoded string.", "New in version 0.9.", "Union[bytes, str]", "Parse data as JSON.", "If the mimetype does not indicate JSON (application/json, see is_json()), this returns None.", "If parsing fails, on_json_loading_failed() is called and its return value is used as the return value.", "Optional[Any]", "The headers received with the request.", "The host name the request was made to, including the port if it\u2019s non-standard. Validated with trusted_hosts.", "The request URL scheme and host only.", "An object containing all the etags in the If-Match header.", "ETags", "The parsed If-Modified-Since header as a datetime object.", "Changed in version 2.0: The datetime object is timezone-aware.", "An object containing all the etags in the If-None-Match header.", "ETags", "The parsed If-Range header.", "Changed in version 2.0: IfRange.date is timezone-aware.", "New in version 0.7.", "The parsed If-Unmodified-Since header as a datetime object.", "Changed in version 2.0: The datetime object is timezone-aware.", "The WSGI input stream.", "In general it\u2019s a bad idea to use this one because you can easily read past the boundary. Use the stream instead.", "Check if the mimetype indicates JSON data, either application/json or application/*+json.", "boolean that is True if the application is served by a WSGI server that spawns multiple processes.", "boolean that is True if the application is served by a multithreaded WSGI server.", "boolean that is True if the application will be executed only once in a process lifetime. This is the case for CGI for example, but it\u2019s not guaranteed that the execution only happens one time.", "True if the request was made with a secure protocol (HTTPS or WSS).", "The parsed JSON data if mimetype indicates JSON (application/json, see is_json()).", "Calls get_json() with default arguments.", "alias of werkzeug.datastructures.ImmutableList", "Creates the form data parser. Instantiates the form_data_parser_class with some parameters.", "New in version 0.8.", "werkzeug.formparser.FormDataParser", "Read-only view of the MAX_CONTENT_LENGTH config key.", "The Max-Forwards request-header field provides a mechanism with the TRACE and OPTIONS methods to limit the number of proxies or gateways that can forward the request to the next inbound server.", "The method the request was made with, such as GET.", "Like content_type, but without parameters (eg, without charset, type etc.) and always lowercase. For example if the content type is text/HTML; charset=utf-8 the mimetype would be 'text/html'.", "The mimetype parameters as dict. For example if the content type is text/html; charset=utf-8 the params would be {'charset': 'utf-8'}.", "Called if get_json() parsing fails and isn\u2019t silenced. If this method returns a value, it is used as the return value for get_json(). The default implementation raises BadRequest.", "e (Exception) \u2013 ", "NoReturn", "The host that the request originated from. Set access_control_allow_origin on the response to indicate which origins are allowed.", "alias of werkzeug.datastructures.ImmutableMultiDict", "The path part of the URL after root_path. This is the path used for routing within the application.", "The Pragma general-header field is used to include implementation-specific directives that might apply to any recipient along the request/response chain. All pragma directives specify optional behavior from the viewpoint of the protocol; however, some systems MAY require that behavior be consistent with the directives.", "The part of the URL after the \u201c?\u201d. This is the raw value, use args for the parsed values.", "The parsed Range header.", "New in version 0.7.", "Range", "The Referer[sic] request-header field allows the client to specify, for the server\u2019s benefit, the address (URI) of the resource from which the Request-URI was obtained (the \u201creferrer\u201d, although the header field is misspelled).", "The address of the client sending the request.", "If the server supports user authentication, and the script is protected, this attribute contains the username the user has authenticated as.", "The prefix that the application is mounted under, without a trailing slash. path comes after this.", "The request URL scheme, host, and root path. This is the root that the application is accessed from.", "If matching the URL failed, this is the exception that will be raised / was raised as part of the request handling. This is usually a NotFound exception or something similar.", "The URL scheme of the protocol the request used, such as https or wss.", "Alias for self.root_path. environ[\"SCRIPT_ROOT\"] without a trailing slash.", "The address of the server. (host, port), (path, None) for unix sockets, or None if not known.", "Set when creating the request object. If True, reading from the request body will cause a RuntimeException. Useful to prevent modifying the stream from middleware.", "If the incoming form data was not encoded with a known mimetype the data is stored unmodified in this stream for consumption. Most of the time it is a better idea to use data which will give you that data as a string. The stream only returns the data once.", "Unlike input_stream this stream is properly guarded that you can\u2019t accidentally read past the length of the input. Werkzeug will internally always refer to this stream to read data which makes it possible to wrap this object with a stream that does filtering.", "Changed in version 0.9: This stream is now always available but might be consumed by the form parser later on. Previously the stream was only set if no parsing happened.", "The full request URL with the scheme, host, root path, path, and query string.", "The charset that is assumed for URLs. Defaults to the value of charset.", "New in version 0.6.", "Alias for root_url. The URL with scheme, host, and root path. For example, https://example.com/app/.", "The internal URL rule that matched the request. This can be useful to inspect which methods are allowed for the URL from a before/after handler (request.url_rule.methods) etc. Though if the request\u2019s method was invalid for the URL rule, the valid list is available in routing_exception.valid_methods instead (an attribute of the Werkzeug exception MethodNotAllowed) because the request was never internally bound.", "New in version 0.6.", "The user agent. Use user_agent.string to get the header value. Set user_agent_class to a subclass of UserAgent to provide parsing for the other properties or other extended data.", "Changed in version 2.0: The built in parser is deprecated and will be removed in Werkzeug 2.1. A UserAgent subclass must be set to parse data from the string.", "alias of werkzeug.useragents._UserAgent", "A werkzeug.datastructures.CombinedMultiDict that combines args and form.", "For GET requests, only args are present, not form.", "Changed in version 2.0: For GET requests, only args are present, not form.", "A dict of view arguments that matched the request. If an exception happened when matching, this will be None.", "True if the request method carries content. By default this is true if a Content-Type is sent.", "New in version 0.8."]}, {"name": "Request Content Checksums", "path": "patterns/requestchecksum/index", "type": "User's Guide: Design Patterns", "text": ["Various pieces of code can consume the request data and preprocess it. For instance JSON data ends up on the request object already read and processed, form data ends up there as well but goes through a different code path. This seems inconvenient when you want to calculate the checksum of the incoming request data. This is necessary sometimes for some APIs.", "Fortunately this is however very simple to change by wrapping the input stream.", "The following example calculates the SHA1 checksum of the incoming data as it gets read and stores it in the WSGI environment:", "To use this, all you need to do is to hook the calculating stream in before the request starts consuming data. (Eg: be careful accessing request.form or anything of that nature. before_request_handlers for instance should be careful not to access it).", "Example usage:"]}, {"name": "Request.access_control_request_headers", "path": "api/index#flask.Request.access_control_request_headers", "type": "flask", "text": ["Sent with a preflight request to indicate which headers will be sent with the cross origin request. Set access_control_allow_headers on the response to indicate which headers are allowed."]}, {"name": "Request.access_control_request_method", "path": "api/index#flask.Request.access_control_request_method", "type": "flask", "text": ["Sent with a preflight request to indicate which method will be used for the cross origin request. Set access_control_allow_methods on the response to indicate which methods are allowed."]}, {"name": "Request.application()", "path": "api/index#flask.Request.application", "type": "flask", "text": ["Decorate a function as responder that accepts the request as the last argument. This works like the responder() decorator but the function is passed the request object as the last argument and the request object will be closed automatically:", "As of Werkzeug 0.14 HTTP exceptions are automatically caught and converted to responses instead of failing.", "f (Callable[[Request], WSGIApplication]) \u2013 the WSGI callable to decorate", "a new WSGI callable", "WSGIApplication"]}, {"name": "Request.close()", "path": "api/index#flask.Request.close", "type": "flask", "text": ["Closes associated resources of this request object. This closes all file handles explicitly. You can also use the request object in a with statement which will automatically close it.", "New in version 0.9.", "None"]}, {"name": "Request.content_encoding", "path": "api/index#flask.Request.content_encoding", "type": "flask", "text": ["The Content-Encoding entity-header field is used as a modifier to the media-type. When present, its value indicates what additional content codings have been applied to the entity-body, and thus what decoding mechanisms must be applied in order to obtain the media-type referenced by the Content-Type header field.", "New in version 0.9."]}, {"name": "Request.content_md5", "path": "api/index#flask.Request.content_md5", "type": "flask", "text": ["The Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest of the entity-body for the purpose of providing an end-to-end message integrity check (MIC) of the entity-body. (Note: a MIC is good for detecting accidental modification of the entity-body in transit, but is not proof against malicious attacks.)", "New in version 0.9."]}, {"name": "Request.content_type", "path": "api/index#flask.Request.content_type", "type": "flask", "text": ["The Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of the HEAD method, the media type that would have been sent had the request been a GET."]}, {"name": "Request.date", "path": "api/index#flask.Request.date", "type": "flask", "text": ["The Date general-header field represents the date and time at which the message was originated, having the same semantics as orig-date in RFC 822.", "Changed in version 2.0: The datetime object is timezone-aware."]}, {"name": "Request.dict_storage_class", "path": "api/index#flask.Request.dict_storage_class", "type": "flask", "text": ["alias of werkzeug.datastructures.ImmutableMultiDict"]}, {"name": "Request.environ", "path": "api/index#flask.Request.environ", "type": "flask", "text": ["The WSGI environment containing HTTP headers and information from the WSGI server."]}, {"name": "Request.form_data_parser_class", "path": "api/index#flask.Request.form_data_parser_class", "type": "flask", "text": ["alias of werkzeug.formparser.FormDataParser"]}, {"name": "Request.from_values()", "path": "api/index#flask.Request.from_values", "type": "flask", "text": ["Create a new request object based on the values provided. If environ is given missing values are filled from there. This method is useful for small scripts when you need to simulate a request from an URL. Do not use this method for unittesting, there is a full featured client object (Client) that allows to create multipart requests, support for cookies etc.", "This accepts the same options as the EnvironBuilder.", "Changed in version 0.5: This method now accepts the same arguments as EnvironBuilder. Because of this the environ parameter is now called environ_overrides.", "request object", "werkzeug.wrappers.request.Request"]}, {"name": "Request.get_data()", "path": "api/index#flask.Request.get_data", "type": "flask", "text": ["This reads the buffered incoming data from the client into one bytes object. By default this is cached but that behavior can be changed by setting cache to False.", "Usually it\u2019s a bad idea to call this method without checking the content length first as a client could send dozens of megabytes or more to cause memory problems on the server.", "Note that if the form data was already parsed this method will not return anything as form data parsing does not cache the data like this method does. To implicitly invoke form data parsing function set parse_form_data to True. When this is done the return value of this method will be an empty string if the form parser handles the data. This generally is not necessary as if the whole data is cached (which is the default) the form parser will used the cached data to parse the form data. Please be generally aware of checking the content length first in any case before calling this method to avoid exhausting server memory.", "If as_text is set to True the return value will be a decoded string.", "New in version 0.9.", "Union[bytes, str]"]}, {"name": "Request.get_json()", "path": "api/index#flask.Request.get_json", "type": "flask", "text": ["Parse data as JSON.", "If the mimetype does not indicate JSON (application/json, see is_json()), this returns None.", "If parsing fails, on_json_loading_failed() is called and its return value is used as the return value.", "Optional[Any]"]}, {"name": "Request.headers", "path": "api/index#flask.Request.headers", "type": "flask", "text": ["The headers received with the request."]}, {"name": "Request.input_stream", "path": "api/index#flask.Request.input_stream", "type": "flask", "text": ["The WSGI input stream.", "In general it\u2019s a bad idea to use this one because you can easily read past the boundary. Use the stream instead."]}, {"name": "Request.is_multiprocess", "path": "api/index#flask.Request.is_multiprocess", "type": "flask", "text": ["boolean that is True if the application is served by a WSGI server that spawns multiple processes."]}, {"name": "Request.is_multithread", "path": "api/index#flask.Request.is_multithread", "type": "flask", "text": ["boolean that is True if the application is served by a multithreaded WSGI server."]}, {"name": "Request.is_run_once", "path": "api/index#flask.Request.is_run_once", "type": "flask", "text": ["boolean that is True if the application will be executed only once in a process lifetime. This is the case for CGI for example, but it\u2019s not guaranteed that the execution only happens one time."]}, {"name": "Request.list_storage_class", "path": "api/index#flask.Request.list_storage_class", "type": "flask", "text": ["alias of werkzeug.datastructures.ImmutableList"]}, {"name": "Request.make_form_data_parser()", "path": "api/index#flask.Request.make_form_data_parser", "type": "flask", "text": ["Creates the form data parser. Instantiates the form_data_parser_class with some parameters.", "New in version 0.8.", "werkzeug.formparser.FormDataParser"]}, {"name": "Request.max_forwards", "path": "api/index#flask.Request.max_forwards", "type": "flask", "text": ["The Max-Forwards request-header field provides a mechanism with the TRACE and OPTIONS methods to limit the number of proxies or gateways that can forward the request to the next inbound server."]}, {"name": "Request.method", "path": "api/index#flask.Request.method", "type": "flask", "text": ["The method the request was made with, such as GET."]}, {"name": "Request.on_json_loading_failed()", "path": "api/index#flask.Request.on_json_loading_failed", "type": "flask", "text": ["Called if get_json() parsing fails and isn\u2019t silenced. If this method returns a value, it is used as the return value for get_json(). The default implementation raises BadRequest.", "e (Exception) \u2013 ", "NoReturn"]}, {"name": "Request.origin", "path": "api/index#flask.Request.origin", "type": "flask", "text": ["The host that the request originated from. Set access_control_allow_origin on the response to indicate which origins are allowed."]}, {"name": "Request.parameter_storage_class", "path": "api/index#flask.Request.parameter_storage_class", "type": "flask", "text": ["alias of werkzeug.datastructures.ImmutableMultiDict"]}, {"name": "Request.path", "path": "api/index#flask.Request.path", "type": "flask", "text": ["The path part of the URL after root_path. This is the path used for routing within the application."]}, {"name": "Request.query_string", "path": "api/index#flask.Request.query_string", "type": "flask", "text": ["The part of the URL after the \u201c?\u201d. This is the raw value, use args for the parsed values."]}, {"name": "Request.referrer", "path": "api/index#flask.Request.referrer", "type": "flask", "text": ["The Referer[sic] request-header field allows the client to specify, for the server\u2019s benefit, the address (URI) of the resource from which the Request-URI was obtained (the \u201creferrer\u201d, although the header field is misspelled)."]}, {"name": "Request.remote_addr", "path": "api/index#flask.Request.remote_addr", "type": "flask", "text": ["The address of the client sending the request."]}, {"name": "Request.remote_user", "path": "api/index#flask.Request.remote_user", "type": "flask", "text": ["If the server supports user authentication, and the script is protected, this attribute contains the username the user has authenticated as."]}, {"name": "Request.root_path", "path": "api/index#flask.Request.root_path", "type": "flask", "text": ["The prefix that the application is mounted under, without a trailing slash. path comes after this."]}, {"name": "Request.routing_exception", "path": "api/index#flask.Request.routing_exception", "type": "flask", "text": ["If matching the URL failed, this is the exception that will be raised / was raised as part of the request handling. This is usually a NotFound exception or something similar."]}, {"name": "Request.scheme", "path": "api/index#flask.Request.scheme", "type": "flask", "text": ["The URL scheme of the protocol the request used, such as https or wss."]}, {"name": "Request.server", "path": "api/index#flask.Request.server", "type": "flask", "text": ["The address of the server. (host, port), (path, None) for unix sockets, or None if not known."]}, {"name": "Request.shallow", "path": "api/index#flask.Request.shallow", "type": "flask", "text": ["Set when creating the request object. If True, reading from the request body will cause a RuntimeException. Useful to prevent modifying the stream from middleware."]}, {"name": "Request.url_rule", "path": "api/index#flask.Request.url_rule", "type": "flask", "text": ["The internal URL rule that matched the request. This can be useful to inspect which methods are allowed for the URL from a before/after handler (request.url_rule.methods) etc. Though if the request\u2019s method was invalid for the URL rule, the valid list is available in routing_exception.valid_methods instead (an attribute of the Werkzeug exception MethodNotAllowed) because the request was never internally bound.", "New in version 0.6."]}, {"name": "Request.user_agent_class", "path": "api/index#flask.Request.user_agent_class", "type": "flask", "text": ["alias of werkzeug.useragents._UserAgent"]}, {"name": "Request.view_args", "path": "api/index#flask.Request.view_args", "type": "flask", "text": ["A dict of view arguments that matched the request. If an exception happened when matching, this will be None."]}, {"name": "RequestContext", "path": "api/index#flask.ctx.RequestContext", "type": "flask.ctx", "text": ["The request context contains all request relevant information. It is created at the beginning of the request and pushed to the _request_ctx_stack and removed at the end of it. It will create the URL adapter and request object for the WSGI environment provided.", "Do not attempt to use this class directly, instead use test_request_context() and request_context() to create this object.", "When the request context is popped, it will evaluate all the functions registered on the application for teardown execution (teardown_request()).", "The request context is automatically popped at the end of the request for you. In debug mode the request context is kept around if exceptions happen so that interactive debuggers have a chance to introspect the data. With 0.4 this can also be forced for requests that did not fail and outside of DEBUG mode. By setting 'flask._preserve_context' to True on the WSGI environment the context will not pop itself at the end of the request. This is used by the test_client() for example to implement the deferred cleanup functionality.", "You might find this helpful for unittests where you need the information from the context local around for a little longer. Make sure to properly pop() the stack yourself in that situation, otherwise your unittests will leak memory.", "None", "Creates a copy of this request context with the same request object. This can be used to move a request context to a different greenlet. Because the actual request object is the same this cannot be used to move a request context to a different thread unless access to the request object is locked.", "Changed in version 1.1: The current session object is used instead of reloading the original data. This prevents flask.session pointing to an out-of-date object.", "New in version 0.10.", "flask.ctx.RequestContext", "Can be overridden by a subclass to hook into the matching of the request.", "None", "Pops the request context and unbinds it by doing that. This will also trigger the execution of functions registered by the teardown_request() decorator.", "Changed in version 0.9: Added the exc argument.", "exc (Optional[BaseException]) \u2013 ", "None", "Binds the request context to the current context.", "None"]}, {"name": "RequestContext.copy()", "path": "api/index#flask.ctx.RequestContext.copy", "type": "flask.ctx", "text": ["Creates a copy of this request context with the same request object. This can be used to move a request context to a different greenlet. Because the actual request object is the same this cannot be used to move a request context to a different thread unless access to the request object is locked.", "Changed in version 1.1: The current session object is used instead of reloading the original data. This prevents flask.session pointing to an out-of-date object.", "New in version 0.10.", "flask.ctx.RequestContext"]}, {"name": "RequestContext.match_request()", "path": "api/index#flask.ctx.RequestContext.match_request", "type": "flask.ctx", "text": ["Can be overridden by a subclass to hook into the matching of the request.", "None"]}, {"name": "RequestContext.pop()", "path": "api/index#flask.ctx.RequestContext.pop", "type": "flask.ctx", "text": ["Pops the request context and unbinds it by doing that. This will also trigger the execution of functions registered by the teardown_request() decorator.", "Changed in version 0.9: Added the exc argument.", "exc (Optional[BaseException]) \u2013 ", "None"]}, {"name": "RequestContext.push()", "path": "api/index#flask.ctx.RequestContext.push", "type": "flask.ctx", "text": ["Binds the request context to the current context.", "None"]}, {"name": "Response", "path": "api/index#flask.Response", "type": "flask", "text": ["The response object that is used by default in Flask. Works like the response object from Werkzeug but is set to have an HTML mimetype by default. Quite often you don\u2019t have to create this object yourself because make_response() will take care of that for you.", "If you want to replace the response object used you can subclass this and set response_class to your subclass.", "Changed in version 1.0: JSON support is added to the response, like the request. This is useful when testing to get the test client response data as JSON.", "Changed in version 1.0: Added max_cookie_size.", "None", "The Accept-Ranges header. Even though the name would indicate that multiple values are supported, it must be one string token only.", "The values 'bytes' and 'none' are common.", "New in version 0.7.", "Whether credentials can be shared by the browser to JavaScript code. As part of the preflight request it indicates whether credentials can be used on the cross origin request.", "Which headers can be sent with the cross origin request.", "Which methods can be used for the cross origin request.", "The origin or \u2018*\u2019 for any origin that may make cross origin requests.", "Which headers can be shared by the browser to JavaScript code.", "The maximum age in seconds the access control settings can be cached for.", "Add an etag for the current response if there is none yet.", "Changed in version 2.0: SHA-1 is used to generate the value. MD5 may not be available in some environments.", "None", "The Age response-header field conveys the sender\u2019s estimate of the amount of time since the response (or its revalidation) was generated at the origin server.", "Age values are non-negative decimal integers, representing time in seconds.", "The Allow entity-header field lists the set of methods supported by the resource identified by the Request-URI. The purpose of this field is strictly to inform the recipient of valid methods associated with the resource. An Allow header field MUST be present in a 405 (Method Not Allowed) response.", "The Cache-Control general-header field is used to specify directives that MUST be obeyed by all caching mechanisms along the request/response chain.", "Returns the content length if available or None otherwise.", "Optional[int]", "Adds a function to the internal list of functions that should be called as part of closing down the response. Since 0.7 this function also returns the function that was passed so that this can be used as a decorator.", "New in version 0.6.", "func (Callable[[], Any]) \u2013 ", "Callable[[], Any]", "Close the wrapped response if possible. You can also use the object in a with statement which will automatically close it.", "New in version 0.9: Can now be used in a with statement.", "None", "The Content-Encoding entity-header field is used as a modifier to the media-type. When present, its value indicates what additional content codings have been applied to the entity-body, and thus what decoding mechanisms must be applied in order to obtain the media-type referenced by the Content-Type header field.", "The Content-Language entity-header field describes the natural language(s) of the intended audience for the enclosed entity. Note that this might not be equivalent to all the languages used within the entity-body.", "The Content-Length entity-header field indicates the size of the entity-body, in decimal number of OCTETs, sent to the recipient or, in the case of the HEAD method, the size of the entity-body that would have been sent had the request been a GET.", "The Content-Location entity-header field MAY be used to supply the resource location for the entity enclosed in the message when that entity is accessible from a location separate from the requested resource\u2019s URI.", "The Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest of the entity-body for the purpose of providing an end-to-end message integrity check (MIC) of the entity-body. (Note: a MIC is good for detecting accidental modification of the entity-body in transit, but is not proof against malicious attacks.)", "The Content-Range header as a ContentRange object. Available even if the header is not set.", "New in version 0.7.", "The Content-Security-Policy header adds an additional layer of security to help detect and mitigate certain types of attacks.", "The Content-Security-Policy-Report-Only header adds a csp policy that is not enforced but is reported thereby helping detect certain types of attacks.", "The Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of the HEAD method, the media type that would have been sent had the request been a GET.", "Prevents a document from loading any cross-origin resources that do not explicitly grant the document permission. Values must be a member of the werkzeug.http.COEP enum.", "Allows control over sharing of browsing context group with cross-origin documents. Values must be a member of the werkzeug.http.COOP enum.", "A descriptor that calls get_data() and set_data().", "The Date general-header field represents the date and time at which the message was originated, having the same semantics as orig-date in RFC 822.", "Changed in version 2.0: The datetime object is timezone-aware.", "Delete a cookie. Fails silently if key doesn\u2019t exist.", "None", "Pass the response body directly through as the WSGI iterable. This can be used when the body is a binary file or other iterator of bytes, to skip some unnecessary checks. Use send_file() instead of setting this manually.", "The Expires entity-header field gives the date/time after which the response is considered stale. A stale cache entry may not normally be returned by a cache.", "Changed in version 2.0: The datetime object is timezone-aware.", "Enforce that the WSGI response is a response object of the current type. Werkzeug will use the Response internally in many situations like the exceptions. If you call get_response() on an exception you will get back a regular Response object, even if you are using a custom subclass.", "This method can enforce a given response type, and it will also convert arbitrary WSGI callables into response objects if an environ is provided:", "This is especially useful if you want to post-process responses in the main dispatcher and use functionality provided by your subclass.", "Keep in mind that this will modify response objects in place if possible!", "a response object.", "Response", "Make the response object ready to be pickled. Does the following:", "Changed in version 2.0: An ETag header is added, the no_etag parameter is deprecated and will be removed in Werkzeug 2.1.", "Changed in version 0.6: The Content-Length header is set.", "no_etag (None) \u2013 ", "None", "Create a new response object from an application output. This works best if you pass it an application that returns a generator all the time. Sometimes applications may use the write() callable returned by the start_response function. This tries to resolve such edge cases automatically. But if you don\u2019t get the expected output you should set buffered to True which enforces buffering.", "a response object.", "Response", "Returns the application iterator for the given environ. Depending on the request method and the current status code the return value might be an empty response rather than the one from the response.", "If the request method is HEAD or the status code is in a range where the HTTP specification requires an empty response, an empty iterable is returned.", "New in version 0.6.", "environ (WSGIEnvironment) \u2013 the WSGI environment of the request.", "a response iterable.", "Iterable[bytes]", "The string representation of the response body. Whenever you call this property the response iterable is encoded and flattened. This can lead to unwanted behavior if you stream big data.", "This behavior can be disabled by setting implicit_sequence_conversion to False.", "If as_text is set to True the return value will be a decoded string.", "New in version 0.9.", "as_text (bool) \u2013 ", "Union[bytes, str]", "Return a tuple in the form (etag, is_weak). If there is no ETag the return value is (None, None).", "Union[Tuple[str, bool], Tuple[None, None]]", "Parse data as JSON. Useful during testing.", "If the mimetype does not indicate JSON (application/json, see is_json()), this returns None.", "Unlike Request.get_json(), the result is not cached.", "Optional[Any]", "This is automatically called right before the response is started and returns headers modified for the given environment. It returns a copy of the headers from the response with some modifications applied if necessary.", "For example the location header (if present) is joined with the root URL of the environment. Also the content length is automatically set to zero here for certain status codes.", "Changed in version 0.6: Previously that function was called fix_headers and modified the response object in place. Also since 0.6, IRIs in location and content-location headers are handled properly.", "Also starting with 0.6, Werkzeug will attempt to set the content length if it is able to figure it out on its own. This is the case if all the strings in the response iterable are already encoded and the iterable is buffered.", "environ (WSGIEnvironment) \u2013 the WSGI environment of the request.", "returns a new Headers object.", "werkzeug.datastructures.Headers", "Returns the final WSGI response as tuple. The first item in the tuple is the application iterator, the second the status and the third the list of headers. The response returned is created specially for the given environment. For example if the request method in the WSGI environment is 'HEAD' the response will be empty and only the headers and status code will be present.", "New in version 0.6.", "environ (WSGIEnvironment) \u2013 the WSGI environment of the request.", "an (app_iter, status, headers) tuple.", "Tuple[Iterable[bytes], str, List[Tuple[str, str]]]", "Check if the mimetype indicates JSON data, either application/json or application/*+json.", "If the iterator is buffered, this property will be True. A response object will consider an iterator to be buffered if the response attribute is a list or tuple.", "New in version 0.6.", "If the response is streamed (the response is not an iterable with a length information) this property is True. In this case streamed means that there is no information about the number of iterations. This is usually True if a generator is passed to the response object.", "This is useful for checking before applying some sort of post filtering that should not take place for streamed responses.", "Iter the response encoded with the encoding of the response. If the response object is invoked as WSGI application the return value of this method is used as application iterator unless direct_passthrough was activated.", "Iterator[bytes]", "The parsed JSON data if mimetype indicates JSON (application/json, see is_json()).", "Calls get_json() with default arguments.", "The Last-Modified entity-header field indicates the date and time at which the origin server believes the variant was last modified.", "Changed in version 2.0: The datetime object is timezone-aware.", "The Location response-header field is used to redirect the recipient to a location other than the Request-URI for completion of the request or identification of a new resource.", "Make the response conditional to the request. This method works best if an etag was defined for the response already. The add_etag method can be used to do that. If called without etag just the date header is set.", "This does nothing if the request method in the request or environ is anything but GET or HEAD.", "For optimal performance when handling range requests, it\u2019s recommended that your response data object implements seekable, seek and tell methods as described by io.IOBase. Objects returned by wrap_file() automatically implement those methods.", "It does not remove the body of the response because that\u2019s something the __call__() function does for us automatically.", "Returns self so that you can do return resp.make_conditional(req) but modifies the object in-place.", "RequestedRangeNotSatisfiable if Range header could not be parsed or satisfied.", "Response", "Changed in version 2.0: Range processing is skipped if length is 0 instead of raising a 416 Range Not Satisfiable error.", "Converts the response iterator in a list. By default this happens automatically if required. If implicit_sequence_conversion is disabled, this method is not automatically called and some properties might raise exceptions. This also encodes all the items.", "New in version 0.6.", "None", "Read-only view of the MAX_COOKIE_SIZE config key.", "See max_cookie_size in Werkzeug\u2019s docs.", "The mimetype (content type without charset etc.)", "The mimetype parameters as dict. For example if the content type is text/html; charset=utf-8 the params would be {'charset': 'utf-8'}.", "New in version 0.5.", "The Retry-After response-header field can be used with a 503 (Service Unavailable) response to indicate how long the service is expected to be unavailable to the requesting client.", "Time in seconds until expiration or date.", "Changed in version 2.0: The datetime object is timezone-aware.", "Sets a cookie.", "A warning is raised if the size of the cookie header exceeds max_cookie_size, but the header will still be set.", "None", "Sets a new string as response. The value must be a string or bytes. If a string is set it\u2019s encoded to the charset of the response (utf-8 by default).", "New in version 0.9.", "value (Union[bytes, str]) \u2013 ", "None", "Set the etag, and override the old one if there was one.", "None", "The HTTP status code as a string.", "The HTTP status code as a number.", "The response iterable as write-only stream.", "The Vary field value indicates the set of request-header fields that fully determines, while the response is fresh, whether a cache is permitted to use the response to reply to a subsequent request without revalidation.", "The WWW-Authenticate header in a parsed form."]}, {"name": "Response.accept_ranges", "path": "api/index#flask.Response.accept_ranges", "type": "flask", "text": ["The Accept-Ranges header. Even though the name would indicate that multiple values are supported, it must be one string token only.", "The values 'bytes' and 'none' are common.", "New in version 0.7."]}, {"name": "Response.access_control_allow_headers", "path": "api/index#flask.Response.access_control_allow_headers", "type": "flask", "text": ["Which headers can be sent with the cross origin request."]}, {"name": "Response.access_control_allow_methods", "path": "api/index#flask.Response.access_control_allow_methods", "type": "flask", "text": ["Which methods can be used for the cross origin request."]}, {"name": "Response.access_control_allow_origin", "path": "api/index#flask.Response.access_control_allow_origin", "type": "flask", "text": ["The origin or \u2018*\u2019 for any origin that may make cross origin requests."]}, {"name": "Response.access_control_expose_headers", "path": "api/index#flask.Response.access_control_expose_headers", "type": "flask", "text": ["Which headers can be shared by the browser to JavaScript code."]}, {"name": "Response.access_control_max_age", "path": "api/index#flask.Response.access_control_max_age", "type": "flask", "text": ["The maximum age in seconds the access control settings can be cached for."]}, {"name": "Response.add_etag()", "path": "api/index#flask.Response.add_etag", "type": "flask", "text": ["Add an etag for the current response if there is none yet.", "Changed in version 2.0: SHA-1 is used to generate the value. MD5 may not be available in some environments.", "None"]}, {"name": "Response.age", "path": "api/index#flask.Response.age", "type": "flask", "text": ["The Age response-header field conveys the sender\u2019s estimate of the amount of time since the response (or its revalidation) was generated at the origin server.", "Age values are non-negative decimal integers, representing time in seconds."]}, {"name": "Response.calculate_content_length()", "path": "api/index#flask.Response.calculate_content_length", "type": "flask", "text": ["Returns the content length if available or None otherwise.", "Optional[int]"]}, {"name": "Response.call_on_close()", "path": "api/index#flask.Response.call_on_close", "type": "flask", "text": ["Adds a function to the internal list of functions that should be called as part of closing down the response. Since 0.7 this function also returns the function that was passed so that this can be used as a decorator.", "New in version 0.6.", "func (Callable[[], Any]) \u2013 ", "Callable[[], Any]"]}, {"name": "Response.close()", "path": "api/index#flask.Response.close", "type": "flask", "text": ["Close the wrapped response if possible. You can also use the object in a with statement which will automatically close it.", "New in version 0.9: Can now be used in a with statement.", "None"]}, {"name": "Response.content_encoding", "path": "api/index#flask.Response.content_encoding", "type": "flask", "text": ["The Content-Encoding entity-header field is used as a modifier to the media-type. When present, its value indicates what additional content codings have been applied to the entity-body, and thus what decoding mechanisms must be applied in order to obtain the media-type referenced by the Content-Type header field."]}, {"name": "Response.content_length", "path": "api/index#flask.Response.content_length", "type": "flask", "text": ["The Content-Length entity-header field indicates the size of the entity-body, in decimal number of OCTETs, sent to the recipient or, in the case of the HEAD method, the size of the entity-body that would have been sent had the request been a GET."]}, {"name": "Response.content_location", "path": "api/index#flask.Response.content_location", "type": "flask", "text": ["The Content-Location entity-header field MAY be used to supply the resource location for the entity enclosed in the message when that entity is accessible from a location separate from the requested resource\u2019s URI."]}, {"name": "Response.content_md5", "path": "api/index#flask.Response.content_md5", "type": "flask", "text": ["The Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest of the entity-body for the purpose of providing an end-to-end message integrity check (MIC) of the entity-body. (Note: a MIC is good for detecting accidental modification of the entity-body in transit, but is not proof against malicious attacks.)"]}, {"name": "Response.content_security_policy", "path": "api/index#flask.Response.content_security_policy", "type": "flask", "text": ["The Content-Security-Policy header adds an additional layer of security to help detect and mitigate certain types of attacks."]}, {"name": "Response.content_security_policy_report_only", "path": "api/index#flask.Response.content_security_policy_report_only", "type": "flask", "text": ["The Content-Security-Policy-Report-Only header adds a csp policy that is not enforced but is reported thereby helping detect certain types of attacks."]}, {"name": "Response.content_type", "path": "api/index#flask.Response.content_type", "type": "flask", "text": ["The Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of the HEAD method, the media type that would have been sent had the request been a GET."]}, {"name": "Response.cross_origin_embedder_policy", "path": "api/index#flask.Response.cross_origin_embedder_policy", "type": "flask", "text": ["Prevents a document from loading any cross-origin resources that do not explicitly grant the document permission. Values must be a member of the werkzeug.http.COEP enum."]}, {"name": "Response.cross_origin_opener_policy", "path": "api/index#flask.Response.cross_origin_opener_policy", "type": "flask", "text": ["Allows control over sharing of browsing context group with cross-origin documents. Values must be a member of the werkzeug.http.COOP enum."]}, {"name": "Response.date", "path": "api/index#flask.Response.date", "type": "flask", "text": ["The Date general-header field represents the date and time at which the message was originated, having the same semantics as orig-date in RFC 822.", "Changed in version 2.0: The datetime object is timezone-aware."]}, {"name": "Response.delete_cookie()", "path": "api/index#flask.Response.delete_cookie", "type": "flask", "text": ["Delete a cookie. Fails silently if key doesn\u2019t exist.", "None"]}, {"name": "Response.direct_passthrough", "path": "api/index#flask.Response.direct_passthrough", "type": "flask", "text": ["Pass the response body directly through as the WSGI iterable. This can be used when the body is a binary file or other iterator of bytes, to skip some unnecessary checks. Use send_file() instead of setting this manually."]}, {"name": "Response.expires", "path": "api/index#flask.Response.expires", "type": "flask", "text": ["The Expires entity-header field gives the date/time after which the response is considered stale. A stale cache entry may not normally be returned by a cache.", "Changed in version 2.0: The datetime object is timezone-aware."]}, {"name": "Response.force_type()", "path": "api/index#flask.Response.force_type", "type": "flask", "text": ["Enforce that the WSGI response is a response object of the current type. Werkzeug will use the Response internally in many situations like the exceptions. If you call get_response() on an exception you will get back a regular Response object, even if you are using a custom subclass.", "This method can enforce a given response type, and it will also convert arbitrary WSGI callables into response objects if an environ is provided:", "This is especially useful if you want to post-process responses in the main dispatcher and use functionality provided by your subclass.", "Keep in mind that this will modify response objects in place if possible!", "a response object.", "Response"]}, {"name": "Response.freeze()", "path": "api/index#flask.Response.freeze", "type": "flask", "text": ["Make the response object ready to be pickled. Does the following:", "Changed in version 2.0: An ETag header is added, the no_etag parameter is deprecated and will be removed in Werkzeug 2.1.", "Changed in version 0.6: The Content-Length header is set.", "no_etag (None) \u2013 ", "None"]}, {"name": "Response.from_app()", "path": "api/index#flask.Response.from_app", "type": "flask", "text": ["Create a new response object from an application output. This works best if you pass it an application that returns a generator all the time. Sometimes applications may use the write() callable returned by the start_response function. This tries to resolve such edge cases automatically. But if you don\u2019t get the expected output you should set buffered to True which enforces buffering.", "a response object.", "Response"]}, {"name": "Response.get_app_iter()", "path": "api/index#flask.Response.get_app_iter", "type": "flask", "text": ["Returns the application iterator for the given environ. Depending on the request method and the current status code the return value might be an empty response rather than the one from the response.", "If the request method is HEAD or the status code is in a range where the HTTP specification requires an empty response, an empty iterable is returned.", "New in version 0.6.", "environ (WSGIEnvironment) \u2013 the WSGI environment of the request.", "a response iterable.", "Iterable[bytes]"]}, {"name": "Response.get_data()", "path": "api/index#flask.Response.get_data", "type": "flask", "text": ["The string representation of the response body. Whenever you call this property the response iterable is encoded and flattened. This can lead to unwanted behavior if you stream big data.", "This behavior can be disabled by setting implicit_sequence_conversion to False.", "If as_text is set to True the return value will be a decoded string.", "New in version 0.9.", "as_text (bool) \u2013 ", "Union[bytes, str]"]}, {"name": "Response.get_etag()", "path": "api/index#flask.Response.get_etag", "type": "flask", "text": ["Return a tuple in the form (etag, is_weak). If there is no ETag the return value is (None, None).", "Union[Tuple[str, bool], Tuple[None, None]]"]}, {"name": "Response.get_json()", "path": "api/index#flask.Response.get_json", "type": "flask", "text": ["Parse data as JSON. Useful during testing.", "If the mimetype does not indicate JSON (application/json, see is_json()), this returns None.", "Unlike Request.get_json(), the result is not cached.", "Optional[Any]"]}, {"name": "Response.get_wsgi_headers()", "path": "api/index#flask.Response.get_wsgi_headers", "type": "flask", "text": ["This is automatically called right before the response is started and returns headers modified for the given environment. It returns a copy of the headers from the response with some modifications applied if necessary.", "For example the location header (if present) is joined with the root URL of the environment. Also the content length is automatically set to zero here for certain status codes.", "Changed in version 0.6: Previously that function was called fix_headers and modified the response object in place. Also since 0.6, IRIs in location and content-location headers are handled properly.", "Also starting with 0.6, Werkzeug will attempt to set the content length if it is able to figure it out on its own. This is the case if all the strings in the response iterable are already encoded and the iterable is buffered.", "environ (WSGIEnvironment) \u2013 the WSGI environment of the request.", "returns a new Headers object.", "werkzeug.datastructures.Headers"]}, {"name": "Response.get_wsgi_response()", "path": "api/index#flask.Response.get_wsgi_response", "type": "flask", "text": ["Returns the final WSGI response as tuple. The first item in the tuple is the application iterator, the second the status and the third the list of headers. The response returned is created specially for the given environment. For example if the request method in the WSGI environment is 'HEAD' the response will be empty and only the headers and status code will be present.", "New in version 0.6.", "environ (WSGIEnvironment) \u2013 the WSGI environment of the request.", "an (app_iter, status, headers) tuple.", "Tuple[Iterable[bytes], str, List[Tuple[str, str]]]"]}, {"name": "Response.iter_encoded()", "path": "api/index#flask.Response.iter_encoded", "type": "flask", "text": ["Iter the response encoded with the encoding of the response. If the response object is invoked as WSGI application the return value of this method is used as application iterator unless direct_passthrough was activated.", "Iterator[bytes]"]}, {"name": "Response.last_modified", "path": "api/index#flask.Response.last_modified", "type": "flask", "text": ["The Last-Modified entity-header field indicates the date and time at which the origin server believes the variant was last modified.", "Changed in version 2.0: The datetime object is timezone-aware."]}, {"name": "Response.location", "path": "api/index#flask.Response.location", "type": "flask", "text": ["The Location response-header field is used to redirect the recipient to a location other than the Request-URI for completion of the request or identification of a new resource."]}, {"name": "Response.make_conditional()", "path": "api/index#flask.Response.make_conditional", "type": "flask", "text": ["Make the response conditional to the request. This method works best if an etag was defined for the response already. The add_etag method can be used to do that. If called without etag just the date header is set.", "This does nothing if the request method in the request or environ is anything but GET or HEAD.", "For optimal performance when handling range requests, it\u2019s recommended that your response data object implements seekable, seek and tell methods as described by io.IOBase. Objects returned by wrap_file() automatically implement those methods.", "It does not remove the body of the response because that\u2019s something the __call__() function does for us automatically.", "Returns self so that you can do return resp.make_conditional(req) but modifies the object in-place.", "RequestedRangeNotSatisfiable if Range header could not be parsed or satisfied.", "Response", "Changed in version 2.0: Range processing is skipped if length is 0 instead of raising a 416 Range Not Satisfiable error."]}, {"name": "Response.make_sequence()", "path": "api/index#flask.Response.make_sequence", "type": "flask", "text": ["Converts the response iterator in a list. By default this happens automatically if required. If implicit_sequence_conversion is disabled, this method is not automatically called and some properties might raise exceptions. This also encodes all the items.", "New in version 0.6.", "None"]}, {"name": "Response.set_cookie()", "path": "api/index#flask.Response.set_cookie", "type": "flask", "text": ["Sets a cookie.", "A warning is raised if the size of the cookie header exceeds max_cookie_size, but the header will still be set.", "None"]}, {"name": "Response.set_data()", "path": "api/index#flask.Response.set_data", "type": "flask", "text": ["Sets a new string as response. The value must be a string or bytes. If a string is set it\u2019s encoded to the charset of the response (utf-8 by default).", "New in version 0.9.", "value (Union[bytes, str]) \u2013 ", "None"]}, {"name": "Response.set_etag()", "path": "api/index#flask.Response.set_etag", "type": "flask", "text": ["Set the etag, and override the old one if there was one.", "None"]}, {"name": "safe_join()", "path": "api/index#flask.safe_join", "type": "flask", "text": ["Safely join zero or more untrusted path components to a base directory to avoid escaping the base directory.", "A safe path, otherwise None.", "str"]}, {"name": "ScriptInfo", "path": "api/index#flask.cli.ScriptInfo", "type": "flask.cli", "text": ["Helper object to deal with Flask applications. This is usually not necessary to interface with as it\u2019s used internally in the dispatching to click. In future versions of Flask this object will most likely play a bigger role. Typically it\u2019s created automatically by the FlaskGroup but you can also manually create it and pass it onwards as click object.", "Optionally the import path for the Flask application.", "Optionally a function that is passed the script info to create the instance of the application.", "A dictionary with arbitrary data that can be associated with this script info.", "Loads the Flask app (if not yet loaded) and returns it. Calling this multiple times will just result in the already loaded app to be returned."]}, {"name": "ScriptInfo.app_import_path", "path": "api/index#flask.cli.ScriptInfo.app_import_path", "type": "flask.cli", "text": ["Optionally the import path for the Flask application."]}, {"name": "ScriptInfo.create_app", "path": "api/index#flask.cli.ScriptInfo.create_app", "type": "flask.cli", "text": ["Optionally a function that is passed the script info to create the instance of the application."]}, {"name": "ScriptInfo.data", "path": "api/index#flask.cli.ScriptInfo.data", "type": "flask.cli", "text": ["A dictionary with arbitrary data that can be associated with this script info."]}, {"name": "ScriptInfo.load_app()", "path": "api/index#flask.cli.ScriptInfo.load_app", "type": "flask.cli", "text": ["Loads the Flask app (if not yet loaded) and returns it. Calling this multiple times will just result in the already loaded app to be returned."]}, {"name": "SECRET_KEY", "path": "config/index#SECRET_KEY", "type": "Configuration", "text": ["A secret key that will be used for securely signing the session cookie and can be used for any other security related needs by extensions or your application. It should be a long random bytes or str. For example, copy the output of this to your config:", "Do not reveal the secret key when posting questions or committing code.", "Default: None"]}, {"name": "SecureCookieSession", "path": "api/index#flask.sessions.SecureCookieSession", "type": "flask.sessions", "text": ["Base class for sessions based on signed cookies.", "This session backend will set the modified and accessed attributes. It cannot reliably track whether a session is new (vs. empty), so new remains hard coded to False.", "initial (Any) \u2013 ", "None", "header, which allows caching proxies to cache different pages for different users.", "Return the value for key if key is in the dictionary, else default.", "Any", "When data is changed, this is set to True. Only the session dictionary itself is tracked; if the session contains mutable data (for example a nested dict) then this must be set to True manually when modifying that data. The session cookie will only be written to the response if this is True.", "Insert key with a value of default if key is not in the dictionary.", "Return the value for key if key is in the dictionary, else default.", "Any"]}, {"name": "SecureCookieSession.accessed", "path": "api/index#flask.sessions.SecureCookieSession.accessed", "type": "flask.sessions", "text": ["header, which allows caching proxies to cache different pages for different users."]}, {"name": "SecureCookieSession.get()", "path": "api/index#flask.sessions.SecureCookieSession.get", "type": "flask.sessions", "text": ["Return the value for key if key is in the dictionary, else default.", "Any"]}, {"name": "SecureCookieSession.modified", "path": "api/index#flask.sessions.SecureCookieSession.modified", "type": "flask.sessions", "text": ["When data is changed, this is set to True. Only the session dictionary itself is tracked; if the session contains mutable data (for example a nested dict) then this must be set to True manually when modifying that data. The session cookie will only be written to the response if this is True."]}, {"name": "SecureCookieSession.setdefault()", "path": "api/index#flask.sessions.SecureCookieSession.setdefault", "type": "flask.sessions", "text": ["Insert key with a value of default if key is not in the dictionary.", "Return the value for key if key is in the dictionary, else default.", "Any"]}, {"name": "SecureCookieSessionInterface", "path": "api/index#flask.sessions.SecureCookieSessionInterface", "type": "flask.sessions", "text": ["The default session interface that stores sessions in signed cookies through the itsdangerous module.", "the hash function to use for the signature. The default is sha1", "the name of the itsdangerous supported key derivation. The default is hmac.", "This method has to be implemented and must either return None in case the loading failed because of a configuration error or an instance of a session object which implements a dictionary like interface + the methods and attributes on SessionMixin.", "Optional[flask.sessions.SecureCookieSession]", "the salt that should be applied on top of the secret key for the signing of cookie based sessions.", "This is called for actual sessions returned by open_session() at the end of the request. This is still called during a request context so if you absolutely need access to the request you can do that.", "None", "A python serializer for the payload. The default is a compact JSON derived serializer with support for some extra Python types such as datetime objects or tuples.", "alias of flask.sessions.SecureCookieSession"]}, {"name": "SecureCookieSessionInterface.digest_method()", "path": "api/index#flask.sessions.SecureCookieSessionInterface.digest_method", "type": "flask.sessions", "text": ["the hash function to use for the signature. The default is sha1"]}, {"name": "SecureCookieSessionInterface.key_derivation", "path": "api/index#flask.sessions.SecureCookieSessionInterface.key_derivation", "type": "flask.sessions", "text": ["the name of the itsdangerous supported key derivation. The default is hmac."]}, {"name": "SecureCookieSessionInterface.open_session()", "path": "api/index#flask.sessions.SecureCookieSessionInterface.open_session", "type": "flask.sessions", "text": ["This method has to be implemented and must either return None in case the loading failed because of a configuration error or an instance of a session object which implements a dictionary like interface + the methods and attributes on SessionMixin.", "Optional[flask.sessions.SecureCookieSession]"]}, {"name": "SecureCookieSessionInterface.salt", "path": "api/index#flask.sessions.SecureCookieSessionInterface.salt", "type": "flask.sessions", "text": ["the salt that should be applied on top of the secret key for the signing of cookie based sessions."]}, {"name": "SecureCookieSessionInterface.save_session()", "path": "api/index#flask.sessions.SecureCookieSessionInterface.save_session", "type": "flask.sessions", "text": ["This is called for actual sessions returned by open_session() at the end of the request. This is still called during a request context so if you absolutely need access to the request you can do that.", "None"]}, {"name": "SecureCookieSessionInterface.serializer", "path": "api/index#flask.sessions.SecureCookieSessionInterface.serializer", "type": "flask.sessions", "text": ["A python serializer for the payload. The default is a compact JSON derived serializer with support for some extra Python types such as datetime objects or tuples."]}, {"name": "SecureCookieSessionInterface.session_class", "path": "api/index#flask.sessions.SecureCookieSessionInterface.session_class", "type": "flask.sessions", "text": ["alias of flask.sessions.SecureCookieSession"]}, {"name": "Security Considerations", "path": "security/index", "type": "Additional Notes", "text": ["Web applications usually face all kinds of security problems and it\u2019s very hard to get everything right. Flask tries to solve a few of these things for you, but there are a couple more you have to take care of yourself.", "Cross site scripting is the concept of injecting arbitrary HTML (and with it JavaScript) into the context of a website. To remedy this, developers have to properly escape text so that it cannot include arbitrary HTML tags. For more information on that have a look at the Wikipedia article on Cross-Site Scripting.", "Flask configures Jinja2 to automatically escape all values unless explicitly told otherwise. This should rule out all XSS problems caused in templates, but there are still other places where you have to be careful:", "Another thing that is very important are unquoted attributes. While Jinja2 can protect you from XSS issues by escaping HTML, there is one thing it cannot protect you from: XSS by attribute injection. To counter this possible attack vector, be sure to always quote your attributes with either double or single quotes when using Jinja expressions in them:", "Why is this necessary? Because if you would not be doing that, an attacker could easily inject custom JavaScript handlers. For example an attacker could inject this piece of HTML+JavaScript:", "When the user would then move with the mouse over the input, the cookie would be presented to the user in an alert window. But instead of showing the cookie to the user, a good attacker might also execute any other JavaScript code. In combination with CSS injections the attacker might even make the element fill out the entire page so that the user would just have to have the mouse anywhere on the page to trigger the attack.", "There is one class of XSS issues that Jinja\u2019s escaping does not protect against. The a tag\u2019s href attribute can contain a javascript: URI, which the browser will execute when clicked if not secured properly.", "To prevent this, you\u2019ll need to set the Content Security Policy (CSP) response header.", "Another big problem is CSRF. This is a very complex topic and I won\u2019t outline it here in detail just mention what it is and how to theoretically prevent it.", "If your authentication information is stored in cookies, you have implicit state management. The state of \u201cbeing logged in\u201d is controlled by a cookie, and that cookie is sent with each request to a page. Unfortunately that includes requests triggered by 3rd party sites. If you don\u2019t keep that in mind, some people might be able to trick your application\u2019s users with social engineering to do stupid things without them knowing.", "Say you have a specific URL that, when you sent POST requests to will delete a user\u2019s profile (say http://example.com/user/delete). If an attacker now creates a page that sends a post request to that page with some JavaScript they just have to trick some users to load that page and their profiles will end up being deleted.", "Imagine you were to run Facebook with millions of concurrent users and someone would send out links to images of little kittens. When users would go to that page, their profiles would get deleted while they are looking at images of fluffy cats.", "How can you prevent that? Basically for each request that modifies content on the server you would have to either use a one-time token and store that in the cookie and also transmit it with the form data. After receiving the data on the server again, you would then have to compare the two tokens and ensure they are equal.", "Why does Flask not do that for you? The ideal place for this to happen is the form validation framework, which does not exist in Flask.", "In Flask 0.10 and lower, jsonify() did not serialize top-level arrays to JSON. This was because of a security vulnerability in ECMAScript 4.", "ECMAScript 5 closed this vulnerability, so only extremely old browsers are still vulnerable. All of these browsers have other more serious vulnerabilities, so this behavior was changed and jsonify() now supports serializing arrays.", "Browsers recognize various response headers in order to control security. We recommend reviewing each of the headers below for use in your application. The Flask-Talisman extension can be used to manage HTTPS and the security headers for you.", "Tells the browser to convert all HTTP requests to HTTPS, preventing man-in-the-middle (MITM) attacks.", "Tell the browser where it can load various types of resource from. This header should be used whenever possible, but requires some work to define the correct policy for your site. A very strict policy would be:", "Forces the browser to honor the response content type instead of trying to detect it, which can be abused to generate a cross-site scripting (XSS) attack.", "Prevents external sites from embedding your site in an iframe. This prevents a class of attacks where clicks in the outer frame can be translated invisibly to clicks on your page\u2019s elements. This is also known as \u201cclickjacking\u201d.", "The browser will try to prevent reflected XSS attacks by not loading the page if the request contains something that looks like JavaScript and the response contains the same data.", "These options can be added to a Set-Cookie header to improve their security. Flask has configuration options to set these on the session cookie. They can be set on other cookies too.", "Specifying Expires or Max-Age options, will remove the cookie after the given time, or the current time plus the age, respectively. If neither option is set, the cookie will be removed when the browser is closed.", "For the session cookie, if session.permanent is set, then PERMANENT_SESSION_LIFETIME is used to set the expiration. Flask\u2019s default cookie implementation validates that the cryptographic signature is not older than this value. Lowering this value may help mitigate replay attacks, where intercepted cookies can be sent at a later time.", "Use itsdangerous.TimedSerializer to sign and validate other cookie values (or any values that need secure signatures).", "This tells the browser to authenticate with the server using only the specific certificate key to prevent MITM attacks.", "Warning", "Be careful when enabling this, as it is very difficult to undo if you set up or upgrade your key incorrectly.", "Hidden characters such as the backspace character (\\b, ^H) can cause text to render differently in HTML than how it is interpreted if pasted into a terminal.", "For example, import y\\bose\\bm\\bi\\bt\\be\\b renders as import yosemite in HTML, but the backspaces are applied when pasted into a terminal, and it becomes import os.", "If you expect users to copy and paste untrusted code from your site, such as from comments posted by users on a technical blog, consider applying extra filtering, such as replacing all \\b characters.", "Most modern terminals will warn about and remove hidden characters when pasting, so this isn\u2019t strictly necessary. It\u2019s also possible to craft dangerous commands in other ways that aren\u2019t possible to filter. Depending on your site\u2019s use case, it may be good to show a warning about copying code in general."]}, {"name": "send_file()", "path": "api/index#flask.send_file", "type": "flask", "text": ["Send the contents of a file to the client.", "The first argument can be a file path or a file-like object. Paths are preferred in most cases because Werkzeug can manage the file and get extra information from the path. Passing a file-like object requires that the file is opened in binary mode, and is mostly useful when building a file in memory with io.BytesIO.", "Never pass file paths provided by a user. The path is assumed to be trusted, so a user could craft a path to access a file you didn\u2019t intend. Use send_from_directory() to safely serve user-requested paths from within a directory.", "If the WSGI server sets a file_wrapper in environ, it is used, otherwise Werkzeug\u2019s built-in wrapper is used. Alternatively, if the HTTP server supports X-Sendfile, configuring Flask with USE_X_SENDFILE = True will tell the server to send the given path, which is much more efficient than reading it in Python.", "Changed in version 2.0: download_name replaces the attachment_filename parameter. If as_attachment=False, it is passed with Content-Disposition: inline instead.", "Changed in version 2.0: max_age replaces the cache_timeout parameter. conditional is enabled and max_age is not set by default.", "Changed in version 2.0: etag replaces the add_etags parameter. It can be a string to use instead of generating one.", "Changed in version 2.0: Passing a file-like object that inherits from TextIOBase will raise a ValueError rather than sending an empty file.", "New in version 2.0: Moved the implementation to Werkzeug. This is now a wrapper to pass some Flask-specific arguments.", "Changed in version 1.1: filename may be a PathLike object.", "Changed in version 1.1: Passing a BytesIO object supports range requests.", "Changed in version 1.0.3: Filenames are encoded with ASCII instead of Latin-1 for broader compatibility with WSGI servers.", "Changed in version 1.0: UTF-8 filenames as specified in RFC 2231 are supported.", "Changed in version 0.12: The filename is no longer automatically inferred from file objects. If you want to use automatic MIME and etag support, pass a filename via filename_or_fp or attachment_filename.", "Changed in version 0.12: attachment_filename is preferred over filename for MIME detection.", "Changed in version 0.9: cache_timeout defaults to Flask.get_send_file_max_age().", "Changed in version 0.7: MIME guessing and etag support for file-like objects was deprecated because it was unreliable. Pass a filename if you are able to, otherwise attach an etag yourself.", "Changed in version 0.5: The add_etags, cache_timeout and conditional parameters were added. The default behavior is to add etags.", "New in version 0.2."]}, {"name": "SEND_FILE_MAX_AGE_DEFAULT", "path": "config/index#SEND_FILE_MAX_AGE_DEFAULT", "type": "Configuration", "text": ["When serving files, set the cache control max age to this number of seconds. Can be a datetime.timedelta or an int. Override this value on a per-file basis using get_send_file_max_age() on the application or blueprint.", "If None, send_file tells the browser to use conditional requests will be used instead of a timed cache, which is usually preferable.", "Default: None"]}, {"name": "send_from_directory()", "path": "api/index#flask.send_from_directory", "type": "flask", "text": ["Send a file from within a directory using send_file().", "This is a secure way to serve files from a folder, such as static files or uploads. Uses safe_join() to ensure the path coming from the client is not maliciously crafted to point outside the specified directory.", "If the final path does not point to an existing regular file, raises a 404 NotFound error.", "Response", "Changed in version 2.0: path replaces the filename parameter.", "New in version 2.0: Moved the implementation to Werkzeug. This is now a wrapper to pass some Flask-specific arguments.", "New in version 0.5."]}, {"name": "SERVER_NAME", "path": "config/index#SERVER_NAME", "type": "Configuration", "text": ["Inform the application what host and port it is bound to. Required for subdomain route matching support.", "If set, will be used for the session cookie domain if SESSION_COOKIE_DOMAIN is not set. Modern web browsers will not allow setting cookies for domains without a dot. To use a domain locally, add any names that should route to the app to your hosts file.", "If set, url_for can generate external URLs with only an application context instead of a request context.", "Default: None"]}, {"name": "session", "path": "api/index#flask.session", "type": "flask", "text": ["The session object works pretty much like an ordinary dict, with the difference that it keeps track of modifications.", "This is a proxy. See Notes On Proxies for more information.", "The following attributes are interesting:", "True if the session is new, False otherwise.", "True if the session object detected a modification. Be advised that modifications on mutable structures are not picked up automatically, in that situation you have to explicitly set the attribute to True yourself. Here an example:", "If set to True the session lives for permanent_session_lifetime seconds. The default is 31 days. If set to False (which is the default) the session will be deleted when the user closes the browser."]}, {"name": "session.modified", "path": "api/index#flask.session.modified", "type": "flask", "text": ["True if the session object detected a modification. Be advised that modifications on mutable structures are not picked up automatically, in that situation you have to explicitly set the attribute to True yourself. Here an example:"]}, {"name": "session.new", "path": "api/index#flask.session.new", "type": "flask", "text": ["True if the session is new, False otherwise."]}, {"name": "session.permanent", "path": "api/index#flask.session.permanent", "type": "flask", "text": ["If set to True the session lives for permanent_session_lifetime seconds. The default is 31 days. If set to False (which is the default) the session will be deleted when the user closes the browser."]}, {"name": "SessionInterface", "path": "api/index#flask.sessions.SessionInterface", "type": "flask.sessions", "text": ["The basic interface you have to implement in order to replace the default session interface which uses werkzeug\u2019s securecookie implementation. The only methods you have to implement are open_session() and save_session(), the others have useful defaults which you don\u2019t need to change.", "The session object returned by the open_session() method has to provide a dictionary like interface plus the properties and methods from the SessionMixin. We recommend just subclassing a dict and adding that mixin:", "If open_session() returns None Flask will call into make_null_session() to create a session that acts as replacement if the session support cannot work because some requirement is not fulfilled. The default NullSession class that is created will complain that the secret key was not set.", "To replace the session interface on an application all you have to do is to assign flask.Flask.session_interface:", "New in version 0.8.", "Returns the domain that should be set for the session cookie.", "Uses SESSION_COOKIE_DOMAIN if it is configured, otherwise falls back to detecting the domain based on SERVER_NAME.", "Once detected (or if not set at all), SESSION_COOKIE_DOMAIN is updated to avoid re-running the logic.", "app (Flask) \u2013 ", "Optional[str]", "Returns True if the session cookie should be httponly. This currently just returns the value of the SESSION_COOKIE_HTTPONLY config var.", "app (Flask) \u2013 ", "bool", "Returns the name of the session cookie.", "Uses app.session_cookie_name which is set to SESSION_COOKIE_NAME", "app (Flask) \u2013 ", "str", "Returns the path for which the cookie should be valid. The default implementation uses the value from the SESSION_COOKIE_PATH config var if it\u2019s set, and falls back to APPLICATION_ROOT or uses / if it\u2019s None.", "app (Flask) \u2013 ", "str", "Return 'Strict' or 'Lax' if the cookie should use the SameSite attribute. This currently just returns the value of the SESSION_COOKIE_SAMESITE setting.", "app (Flask) \u2013 ", "str", "Returns True if the cookie should be secure. This currently just returns the value of the SESSION_COOKIE_SECURE setting.", "app (Flask) \u2013 ", "bool", "A helper method that returns an expiration date for the session or None if the session is linked to the browser session. The default implementation returns now + the permanent session lifetime configured on the application.", "Optional[datetime.datetime]", "Checks if a given object is a null session. Null sessions are not asked to be saved.", "This checks if the object is an instance of null_session_class by default.", "obj (object) \u2013 ", "bool", "Creates a null session which acts as a replacement object if the real session support could not be loaded due to a configuration error. This mainly aids the user experience because the job of the null session is to still support lookup without complaining but modifications are answered with a helpful error message of what failed.", "This creates an instance of null_session_class by default.", "app (Flask) \u2013 ", "flask.sessions.NullSession", "make_null_session() will look here for the class that should be created when a null session is requested. Likewise the is_null_session() method will perform a typecheck against this type.", "alias of flask.sessions.NullSession", "This method has to be implemented and must either return None in case the loading failed because of a configuration error or an instance of a session object which implements a dictionary like interface + the methods and attributes on SessionMixin.", "Optional[flask.sessions.SessionMixin]", "A flag that indicates if the session interface is pickle based. This can be used by Flask extensions to make a decision in regards to how to deal with the session object.", "New in version 0.10.", "This is called for actual sessions returned by open_session() at the end of the request. This is still called during a request context so if you absolutely need access to the request you can do that.", "None", "Used by session backends to determine if a Set-Cookie header should be set for this session cookie for this response. If the session has been modified, the cookie is set. If the session is permanent and the SESSION_REFRESH_EACH_REQUEST config is true, the cookie is always set.", "This check is usually skipped if the session was deleted.", "New in version 0.11.", "bool"]}, {"name": "SessionInterface.get_cookie_domain()", "path": "api/index#flask.sessions.SessionInterface.get_cookie_domain", "type": "flask.sessions", "text": ["Returns the domain that should be set for the session cookie.", "Uses SESSION_COOKIE_DOMAIN if it is configured, otherwise falls back to detecting the domain based on SERVER_NAME.", "Once detected (or if not set at all), SESSION_COOKIE_DOMAIN is updated to avoid re-running the logic.", "app (Flask) \u2013 ", "Optional[str]"]}, {"name": "SessionInterface.get_cookie_httponly()", "path": "api/index#flask.sessions.SessionInterface.get_cookie_httponly", "type": "flask.sessions", "text": ["Returns True if the session cookie should be httponly. This currently just returns the value of the SESSION_COOKIE_HTTPONLY config var.", "app (Flask) \u2013 ", "bool"]}, {"name": "SessionInterface.get_cookie_name()", "path": "api/index#flask.sessions.SessionInterface.get_cookie_name", "type": "flask.sessions", "text": ["Returns the name of the session cookie.", "Uses app.session_cookie_name which is set to SESSION_COOKIE_NAME", "app (Flask) \u2013 ", "str"]}, {"name": "SessionInterface.get_cookie_path()", "path": "api/index#flask.sessions.SessionInterface.get_cookie_path", "type": "flask.sessions", "text": ["Returns the path for which the cookie should be valid. The default implementation uses the value from the SESSION_COOKIE_PATH config var if it\u2019s set, and falls back to APPLICATION_ROOT or uses / if it\u2019s None.", "app (Flask) \u2013 ", "str"]}, {"name": "SessionInterface.get_cookie_samesite()", "path": "api/index#flask.sessions.SessionInterface.get_cookie_samesite", "type": "flask.sessions", "text": ["Return 'Strict' or 'Lax' if the cookie should use the SameSite attribute. This currently just returns the value of the SESSION_COOKIE_SAMESITE setting.", "app (Flask) \u2013 ", "str"]}, {"name": "SessionInterface.get_cookie_secure()", "path": "api/index#flask.sessions.SessionInterface.get_cookie_secure", "type": "flask.sessions", "text": ["Returns True if the cookie should be secure. This currently just returns the value of the SESSION_COOKIE_SECURE setting.", "app (Flask) \u2013 ", "bool"]}, {"name": "SessionInterface.get_expiration_time()", "path": "api/index#flask.sessions.SessionInterface.get_expiration_time", "type": "flask.sessions", "text": ["A helper method that returns an expiration date for the session or None if the session is linked to the browser session. The default implementation returns now + the permanent session lifetime configured on the application.", "Optional[datetime.datetime]"]}, {"name": "SessionInterface.is_null_session()", "path": "api/index#flask.sessions.SessionInterface.is_null_session", "type": "flask.sessions", "text": ["Checks if a given object is a null session. Null sessions are not asked to be saved.", "This checks if the object is an instance of null_session_class by default.", "obj (object) \u2013 ", "bool"]}, {"name": "SessionInterface.make_null_session()", "path": "api/index#flask.sessions.SessionInterface.make_null_session", "type": "flask.sessions", "text": ["Creates a null session which acts as a replacement object if the real session support could not be loaded due to a configuration error. This mainly aids the user experience because the job of the null session is to still support lookup without complaining but modifications are answered with a helpful error message of what failed.", "This creates an instance of null_session_class by default.", "app (Flask) \u2013 ", "flask.sessions.NullSession"]}, {"name": "SessionInterface.null_session_class", "path": "api/index#flask.sessions.SessionInterface.null_session_class", "type": "flask.sessions", "text": ["make_null_session() will look here for the class that should be created when a null session is requested. Likewise the is_null_session() method will perform a typecheck against this type.", "alias of flask.sessions.NullSession"]}, {"name": "SessionInterface.open_session()", "path": "api/index#flask.sessions.SessionInterface.open_session", "type": "flask.sessions", "text": ["This method has to be implemented and must either return None in case the loading failed because of a configuration error or an instance of a session object which implements a dictionary like interface + the methods and attributes on SessionMixin.", "Optional[flask.sessions.SessionMixin]"]}, {"name": "SessionInterface.pickle_based", "path": "api/index#flask.sessions.SessionInterface.pickle_based", "type": "flask.sessions", "text": ["A flag that indicates if the session interface is pickle based. This can be used by Flask extensions to make a decision in regards to how to deal with the session object.", "New in version 0.10."]}, {"name": "SessionInterface.save_session()", "path": "api/index#flask.sessions.SessionInterface.save_session", "type": "flask.sessions", "text": ["This is called for actual sessions returned by open_session() at the end of the request. This is still called during a request context so if you absolutely need access to the request you can do that.", "None"]}, {"name": "SessionInterface.should_set_cookie()", "path": "api/index#flask.sessions.SessionInterface.should_set_cookie", "type": "flask.sessions", "text": ["Used by session backends to determine if a Set-Cookie header should be set for this session cookie for this response. If the session has been modified, the cookie is set. If the session is permanent and the SESSION_REFRESH_EACH_REQUEST config is true, the cookie is always set.", "This check is usually skipped if the session was deleted.", "New in version 0.11.", "bool"]}, {"name": "SessionMixin", "path": "api/index#flask.sessions.SessionMixin", "type": "flask.sessions", "text": ["Expands a basic dictionary with session attributes.", "Some implementations can detect when session data is read or written and set this when that happens. The mixin default is hard coded to True.", "Some implementations can detect changes to the session and set this when that happens. The mixin default is hard coded to True.", "This reflects the '_permanent' key in the dict."]}, {"name": "SessionMixin.accessed", "path": "api/index#flask.sessions.SessionMixin.accessed", "type": "flask.sessions", "text": ["Some implementations can detect when session data is read or written and set this when that happens. The mixin default is hard coded to True."]}, {"name": "SessionMixin.modified", "path": "api/index#flask.sessions.SessionMixin.modified", "type": "flask.sessions", "text": ["Some implementations can detect changes to the session and set this when that happens. The mixin default is hard coded to True."]}, {"name": "SESSION_COOKIE_DOMAIN", "path": "config/index#SESSION_COOKIE_DOMAIN", "type": "Configuration", "text": ["The domain match rule that the session cookie will be valid for. If not set, the cookie will be valid for all subdomains of SERVER_NAME. If False, the cookie\u2019s domain will not be set.", "Default: None"]}, {"name": "SESSION_COOKIE_HTTPONLY", "path": "config/index#SESSION_COOKIE_HTTPONLY", "type": "Configuration", "text": ["Browsers will not allow JavaScript access to cookies marked as \u201cHTTP only\u201d for security.", "Default: True"]}, {"name": "SESSION_COOKIE_NAME", "path": "config/index#SESSION_COOKIE_NAME", "type": "Configuration", "text": ["The name of the session cookie. Can be changed in case you already have a cookie with the same name.", "Default: 'session'"]}, {"name": "SESSION_COOKIE_PATH", "path": "config/index#SESSION_COOKIE_PATH", "type": "Configuration", "text": ["The path that the session cookie will be valid for. If not set, the cookie will be valid underneath APPLICATION_ROOT or / if that is not set.", "Default: None"]}, {"name": "SESSION_COOKIE_SAMESITE", "path": "config/index#SESSION_COOKIE_SAMESITE", "type": "Configuration", "text": ["Restrict how cookies are sent with requests from external sites. Can be set to 'Lax' (recommended) or 'Strict'. See Set-Cookie options.", "Default: None", "New in version 1.0."]}, {"name": "SESSION_COOKIE_SECURE", "path": "config/index#SESSION_COOKIE_SECURE", "type": "Configuration", "text": ["Browsers will only send cookies with requests over HTTPS if the cookie is marked \u201csecure\u201d. The application must be served over HTTPS for this to make sense.", "Default: False"]}, {"name": "SESSION_REFRESH_EACH_REQUEST", "path": "config/index#SESSION_REFRESH_EACH_REQUEST", "type": "Configuration", "text": ["Control whether the cookie is sent with every response when session.permanent is true. Sending the cookie every time (the default) can more reliably keep the session from expiring, but uses more bandwidth. Non-permanent sessions are not affected.", "Default: True"]}, {"name": "Signals", "path": "signals/index", "type": "User\u2019s Guide", "text": ["New in version 0.6.", "Starting with Flask 0.6, there is integrated support for signalling in Flask. This support is provided by the excellent blinker library and will gracefully fall back if it is not available.", "What are signals? Signals help you decouple applications by sending notifications when actions occur elsewhere in the core framework or another Flask extensions. In short, signals allow certain senders to notify subscribers that something happened.", "Flask comes with a couple of signals and other extensions might provide more. Also keep in mind that signals are intended to notify subscribers and should not encourage subscribers to modify data. You will notice that there are signals that appear to do the same thing like some of the builtin decorators do (eg: request_started is very similar to before_request()). However, there are differences in how they work. The core before_request() handler, for example, is executed in a specific order and is able to abort the request early by returning a response. In contrast all signal handlers are executed in undefined order and do not modify any data.", "The big advantage of signals over handlers is that you can safely subscribe to them for just a split second. These temporary subscriptions are helpful for unit testing for example. Say you want to know what templates were rendered as part of a request: signals allow you to do exactly that.", "To subscribe to a signal, you can use the connect() method of a signal. The first argument is the function that should be called when the signal is emitted, the optional second argument specifies a sender. To unsubscribe from a signal, you can use the disconnect() method.", "For all core Flask signals, the sender is the application that issued the signal. When you subscribe to a signal, be sure to also provide a sender unless you really want to listen for signals from all applications. This is especially true if you are developing an extension.", "For example, here is a helper context manager that can be used in a unit test to determine which templates were rendered and what variables were passed to the template:", "This can now easily be paired with a test client:", "Make sure to subscribe with an extra **extra argument so that your calls don\u2019t fail if Flask introduces new arguments to the signals.", "All the template rendering in the code issued by the application app in the body of the with block will now be recorded in the templates variable. Whenever a template is rendered, the template object as well as context are appended to it.", "Additionally there is a convenient helper method (connected_to()) that allows you to temporarily subscribe a function to a signal with a context manager on its own. Because the return value of the context manager cannot be specified that way, you have to pass the list in as an argument:", "The example above would then look like this:", "Blinker API Changes", "The connected_to() method arrived in Blinker with version 1.1.", "If you want to use signals in your own application, you can use the blinker library directly. The most common use case are named signals in a custom Namespace.. This is what is recommended most of the time:", "Now you can create new signals like this:", "The name for the signal here makes it unique and also simplifies debugging. You can access the name of the signal with the name attribute.", "For Extension Developers", "If you are writing a Flask extension and you want to gracefully degrade for missing blinker installations, you can do so by using the flask.signals.Namespace class.", "If you want to emit a signal, you can do so by calling the send() method. It accepts a sender as first argument and optionally some keyword arguments that are forwarded to the signal subscribers:", "Try to always pick a good sender. If you have a class that is emitting a signal, pass self as sender. If you are emitting a signal from a random function, you can pass current_app._get_current_object() as sender.", "Passing Proxies as Senders", "Never pass current_app as sender to a signal. Use current_app._get_current_object() instead. The reason for this is that current_app is a proxy and not the real application object.", "Signals fully support The Request Context when receiving signals. Context-local variables are consistently available between request_started and request_finished, so you can rely on flask.g and others as needed. Note the limitations described in Sending Signals and the request_tearing_down signal.", "With Blinker 1.1 you can also easily subscribe to signals by using the new connect_via() decorator:", "Take a look at Signals for a list of all builtin signals."]}, {"name": "Single-Page Applications", "path": "patterns/singlepageapplications/index", "type": "User's Guide: Design Patterns", "text": ["Flask can be used to serve Single-Page Applications (SPA) by placing static files produced by your frontend framework in a subfolder inside of your project. You will also need to create a catch-all endpoint that routes all requests to your SPA.", "The following example demonstrates how to serve an SPA along with an API:"]}, {"name": "SQLAlchemy in Flask", "path": "patterns/sqlalchemy/index", "type": "User's Guide: Design Patterns", "text": ["Many people prefer SQLAlchemy for database access. In this case it\u2019s encouraged to use a package instead of a module for your flask application and drop the models into a separate module (Large Applications as Packages). While that is not necessary, it makes a lot of sense.", "There are four very common ways to use SQLAlchemy. I will outline each of them here:", "Because SQLAlchemy is a common database abstraction layer and object relational mapper that requires a little bit of configuration effort, there is a Flask extension that handles that for you. This is recommended if you want to get started quickly.", "You can download Flask-SQLAlchemy from PyPI.", "The declarative extension in SQLAlchemy is the most recent method of using SQLAlchemy. It allows you to define tables and models in one go, similar to how Django works. In addition to the following text I recommend the official documentation on the declarative extension.", "Here\u2019s the example database.py module for your application:", "To define your models, just subclass the Base class that was created by the code above. If you are wondering why we don\u2019t have to care about threads here (like we did in the SQLite3 example above with the g object): that\u2019s because SQLAlchemy does that for us already with the scoped_session.", "To use SQLAlchemy in a declarative way with your application, you just have to put the following code into your application module. Flask will automatically remove database sessions at the end of the request or when the application shuts down:", "Here is an example model (put this into models.py, e.g.):", "To create the database you can use the init_db function:", "You can insert entries into the database like this:", "Querying is simple as well:", "Manual object relational mapping has a few upsides and a few downsides versus the declarative approach from above. The main difference is that you define tables and classes separately and map them together. It\u2019s more flexible but a little more to type. In general it works like the declarative approach, so make sure to also split up your application into multiple modules in a package.", "Here is an example database.py module for your application:", "As in the declarative approach, you need to close the session after each request or application context shutdown. Put this into your application module:", "Here is an example table and model (put this into models.py):", "Querying and inserting works exactly the same as in the example above.", "If you just want to use the database system (and SQL) abstraction layer you basically only need the engine:", "Then you can either declare the tables in your code like in the examples above, or automatically load them:", "To insert data you can use the insert method. We have to get a connection first so that we can use a transaction:", "SQLAlchemy will automatically commit for us.", "To query your database, you use the engine directly or use a connection:", "These results are also dict-like tuples:", "You can also pass strings of SQL statements to the execute() method:", "For more information about SQLAlchemy, head over to the website."]}, {"name": "Standalone WSGI Containers", "path": "deploying/wsgi-standalone/index", "type": "User's Guide: Deploying", "text": ["There are popular servers written in Python that contain WSGI applications and serve HTTP. These servers stand alone when they run; you can proxy to them from your web server. Note the section on Proxy Setups if you run into issues.", "Gunicorn \u2018Green Unicorn\u2019 is a WSGI HTTP Server for UNIX. It\u2019s a pre-fork worker model ported from Ruby\u2019s Unicorn project. It supports both eventlet and greenlet. Running a Flask application on this server is quite simple:", "Gunicorn provides many command-line options \u2013 see gunicorn -h. For example, to run a Flask application with 4 worker processes (-w\n4) binding to localhost port 4000 (-b 127.0.0.1:4000):", "The gunicorn command expects the names of your application module or package and the application instance within the module. If you use the application factory pattern, you can pass a call to that:", "uWSGI is a fast application server written in C. It is very configurable which makes it more complicated to setup than gunicorn.", "Running uWSGI HTTP Router:", "For a more optimized setup, see configuring uWSGI and NGINX.", "Gevent is a coroutine-based Python networking library that uses greenlet to provide a high-level synchronous API on top of libev event loop:", "Twisted Web is the web server shipped with Twisted, a mature, non-blocking event-driven networking library. Twisted Web comes with a standard WSGI container which can be controlled from the command line using the twistd utility:", "This example will run a Flask application called app from a module named myproject.", "Twisted Web supports many flags and options, and the twistd utility does as well; see twistd -h and twistd web -h for more information. For example, to run a Twisted Web server in the foreground, on port 8080, with an application from myproject:", "If you deploy your application using one of these servers behind an HTTP proxy you will need to rewrite a few headers in order for the application to work. The two problematic values in the WSGI environment usually are REMOTE_ADDR and HTTP_HOST. You can configure your httpd to pass these headers, or you can fix them in middleware. Werkzeug ships a fixer that will solve some common setups, but you might want to write your own WSGI middleware for specific setups.", "Here\u2019s a simple nginx configuration which proxies to an application served on localhost at port 8000, setting appropriate headers:", "If your httpd is not providing these headers, the most common setup invokes the host being set from X-Forwarded-Host and the remote address from X-Forwarded-For:", "Trusting Headers", "Please keep in mind that it is a security issue to use such a middleware in a non-proxy setup because it will blindly trust the incoming headers which might be forged by malicious clients.", "If you want to rewrite the headers from another header, you might want to use a fixer like this:"]}, {"name": "Streaming Contents", "path": "patterns/streaming/index", "type": "User's Guide: Design Patterns", "text": ["Sometimes you want to send an enormous amount of data to the client, much more than you want to keep in memory. When you are generating the data on the fly though, how do you send that back to the client without the roundtrip to the filesystem?", "The answer is by using generators and direct responses.", "This is a basic view function that generates a lot of CSV data on the fly. The trick is to have an inner function that uses a generator to generate data and to then invoke that function and pass it to a response object:", "Each yield expression is directly sent to the browser. Note though that some WSGI middlewares might break streaming, so be careful there in debug environments with profilers and other things you might have enabled.", "The Jinja2 template engine also supports rendering templates piece by piece. This functionality is not directly exposed by Flask because it is quite uncommon, but you can easily do it yourself:", "The trick here is to get the template object from the Jinja2 environment on the application and to call stream() instead of render() which returns a stream object instead of a string. Since we\u2019re bypassing the Flask template render functions and using the template object itself we have to make sure to update the render context ourselves by calling update_template_context(). The template is then evaluated as the stream is iterated over. Since each time you do a yield the server will flush the content to the client you might want to buffer up a few items in the template which you can do with rv.enable_buffering(size). 5 is a sane default.", "New in version 0.9.", "Note that when you stream data, the request context is already gone the moment the function executes. Flask 0.9 provides you with a helper that can keep the request context around during the execution of the generator:", "Without the stream_with_context() function you would get a RuntimeError at that point."]}, {"name": "stream_with_context()", "path": "api/index#flask.stream_with_context", "type": "flask", "text": ["Request contexts disappear when the response is started on the server. This is done for efficiency reasons and to make it less likely to encounter memory leaks with badly written WSGI middlewares. The downside is that if you are using streamed responses, the generator cannot access request bound information any more.", "This function however can help you keep the context around for longer:", "Alternatively it can also be used around a specific generator:", "New in version 0.9.", "generator_or_function (Union[Generator, Callable]) \u2013 ", "Generator"]}, {"name": "Subclassing Flask", "path": "patterns/subclassing/index", "type": "User's Guide: Design Patterns", "text": ["The Flask class is designed for subclassing.", "For example, you may want to override how request parameters are handled to preserve their order:", "This is the recommended approach for overriding or augmenting Flask\u2019s internal functionality."]}, {"name": "TaggedJSONSerializer", "path": "api/index#flask.json.tag.TaggedJSONSerializer", "type": "flask.json.tag", "text": ["Serializer that uses a tag system to compactly represent objects that are not JSON types. Passed as the intermediate serializer to itsdangerous.Serializer.", "The following extra types are supported:", "None", "Tag classes to bind when creating the serializer. Other tags can be added later using register().", "Tag the value and dump it to a compact JSON string.", "value (Any) \u2013 ", "str", "Load data from a JSON string and deserialized any tagged objects.", "value (str) \u2013 ", "Any", "Register a new tag with this serializer.", "KeyError \u2013 if the tag key is already registered and force is not true.", "None", "Convert a value to a tagged representation if necessary.", "value (Any) \u2013 ", "Dict[str, Any]", "Convert a tagged representation back to the original type.", "value (Dict[str, Any]) \u2013 ", "Any"]}, {"name": "TaggedJSONSerializer.default_tags", "path": "api/index#flask.json.tag.TaggedJSONSerializer.default_tags", "type": "flask.json.tag", "text": ["Tag classes to bind when creating the serializer. Other tags can be added later using register()."]}, {"name": "TaggedJSONSerializer.dumps()", "path": "api/index#flask.json.tag.TaggedJSONSerializer.dumps", "type": "flask.json.tag", "text": ["Tag the value and dump it to a compact JSON string.", "value (Any) \u2013 ", "str"]}, {"name": "TaggedJSONSerializer.loads()", "path": "api/index#flask.json.tag.TaggedJSONSerializer.loads", "type": "flask.json.tag", "text": ["Load data from a JSON string and deserialized any tagged objects.", "value (str) \u2013 ", "Any"]}, {"name": "TaggedJSONSerializer.register()", "path": "api/index#flask.json.tag.TaggedJSONSerializer.register", "type": "flask.json.tag", "text": ["Register a new tag with this serializer.", "KeyError \u2013 if the tag key is already registered and force is not true.", "None"]}, {"name": "TaggedJSONSerializer.tag()", "path": "api/index#flask.json.tag.TaggedJSONSerializer.tag", "type": "flask.json.tag", "text": ["Convert a value to a tagged representation if necessary.", "value (Any) \u2013 ", "Dict[str, Any]"]}, {"name": "TaggedJSONSerializer.untag()", "path": "api/index#flask.json.tag.TaggedJSONSerializer.untag", "type": "flask.json.tag", "text": ["Convert a tagged representation back to the original type.", "value (Dict[str, Any]) \u2013 ", "Any"]}, {"name": "Template Inheritance", "path": "patterns/templateinheritance/index", "type": "User's Guide: Design Patterns", "text": ["The most powerful part of Jinja is template inheritance. Template inheritance allows you to build a base \u201cskeleton\u201d template that contains all the common elements of your site and defines blocks that child templates can override.", "Sounds complicated but is very basic. It\u2019s easiest to understand it by starting with an example.", "This template, which we\u2019ll call layout.html, defines a simple HTML skeleton document that you might use for a simple two-column page. It\u2019s the job of \u201cchild\u201d templates to fill the empty blocks with content:", "In this example, the {% block %} tags define four blocks that child templates can fill in. All the block tag does is tell the template engine that a child template may override those portions of the template.", "A child template might look like this:", "The {% extends %} tag is the key here. It tells the template engine that this template \u201cextends\u201d another template. When the template system evaluates this template, first it locates the parent. The extends tag must be the first tag in the template. To render the contents of a block defined in the parent template, use {{ super() }}."]}, {"name": "Templates", "path": "templating/index", "type": "User\u2019s Guide", "text": ["Flask leverages Jinja2 as its template engine. You are obviously free to use a different template engine, but you still have to install Jinja2 to run Flask itself. This requirement is necessary to enable rich extensions. An extension can depend on Jinja2 being present.", "This section only gives a very quick introduction into how Jinja2 is integrated into Flask. If you want information on the template engine\u2019s syntax itself, head over to the official Jinja2 Template Documentation for more information.", "Unless customized, Jinja2 is configured by Flask as follows:", "The following global variables are available within Jinja2 templates by default:", "The current configuration object (flask.config)", "Changed in version 0.10: This is now always available, even in imported templates.", "New in version 0.6.", "The current request object (flask.request). This variable is unavailable if the template was rendered without an active request context.", "The current session object (flask.session). This variable is unavailable if the template was rendered without an active request context.", "The request-bound object for global variables (flask.g). This variable is unavailable if the template was rendered without an active request context.", "The flask.url_for() function.", "The flask.get_flashed_messages() function.", "The Jinja Context Behavior", "These variables are added to the context of variables, they are not global variables. The difference is that by default these will not show up in the context of imported templates. This is partially caused by performance considerations, partially to keep things explicit.", "What does this mean for you? If you have a macro you want to import, that needs to access the request object you have two possibilities:", "Importing with context looks like this:", "Autoescaping is the concept of automatically escaping special characters for you. Special characters in the sense of HTML (or XML, and thus XHTML) are &, >, <, \" as well as '. Because these characters carry specific meanings in documents on their own you have to replace them by so called \u201centities\u201d if you want to use them for text. Not doing so would not only cause user frustration by the inability to use these characters in text, but can also lead to security problems. (see Cross-Site Scripting (XSS))", "Sometimes however you will need to disable autoescaping in templates. This can be the case if you want to explicitly inject HTML into pages, for example if they come from a system that generates secure HTML like a markdown to HTML converter.", "There are three ways to accomplish that:", "To disable the autoescape system in templates, you can use the {%\nautoescape %} block:", "Whenever you do this, please be very cautious about the variables you are using in this block.", "If you want to register your own filters in Jinja2 you have two ways to do that. You can either put them by hand into the jinja_env of the application or use the template_filter() decorator.", "The two following examples work the same and both reverse an object:", "In case of the decorator the argument is optional if you want to use the function name as name of the filter. Once registered, you can use the filter in your templates in the same way as Jinja2\u2019s builtin filters, for example if you have a Python list in context called mylist:", "To inject new variables automatically into the context of a template, context processors exist in Flask. Context processors run before the template is rendered and have the ability to inject new values into the template context. A context processor is a function that returns a dictionary. The keys and values of this dictionary are then merged with the template context, for all templates in the app:", "The context processor above makes a variable called user available in the template with the value of g.user. This example is not very interesting because g is available in templates anyways, but it gives an idea how this works.", "Variables are not limited to values; a context processor can also make functions available to templates (since Python allows passing around functions):", "The context processor above makes the format_price function available to all templates:", "You could also build format_price as a template filter (see Registering Filters), but this demonstrates how to pass functions in a context processor."]}, {"name": "TEMPLATES_AUTO_RELOAD", "path": "config/index#TEMPLATES_AUTO_RELOAD", "type": "Configuration", "text": ["Reload templates when they are changed. If not set, it will be enabled in debug mode.", "Default: None"]}, {"name": "TESTING", "path": "config/index#TESTING", "type": "Configuration", "text": ["Enable testing mode. Exceptions are propagated rather than handled by the the app\u2019s error handlers. Extensions may also change their behavior to facilitate easier testing. You should enable this in your own tests.", "Default: False"]}, {"name": "Testing Flask Applications", "path": "testing/index", "type": "User\u2019s Guide", "text": ["Something that is untested is broken.", "The origin of this quote is unknown and while it is not entirely correct, it is also not far from the truth. Untested applications make it hard to improve existing code and developers of untested applications tend to become pretty paranoid. If an application has automated tests, you can safely make changes and instantly know if anything breaks.", "Flask provides a way to test your application by exposing the Werkzeug test Client and handling the context locals for you. You can then use that with your favourite testing solution.", "In this documentation we will use the pytest package as the base framework for our tests. You can install it with pip, like so:", "First, we need an application to test; we will use the application from the Tutorial. If you don\u2019t have that application yet, get the source code from the examples.", "So that we can import the module flaskr correctly, we need to run pip install -e . in the folder tutorial.", "We begin by adding a tests directory under the application root. Then create a Python file to store our tests (test_flaskr.py). When we format the filename like test_*.py, it will be auto-discoverable by pytest.", "Next, we create a pytest fixture called client() that configures the application for testing and initializes a new database:", "This client fixture will be called by each individual test. It gives us a simple interface to the application, where we can trigger test requests to the application. The client will also keep track of cookies for us.", "During setup, the TESTING config flag is activated. What this does is disable error catching during request handling, so that you get better error reports when performing test requests against the application.", "Because SQLite3 is filesystem-based, we can easily use the tempfile module to create a temporary database and initialize it. The mkstemp() function does two things for us: it returns a low-level file handle and a random file name, the latter we use as database name. We just have to keep the db_fd around so that we can use the os.close() function to close the file.", "To delete the database after the test, the fixture closes the file and removes it from the filesystem.", "If we now run the test suite, we should see the following output:", "Even though it did not run any actual tests, we already know that our flaskr application is syntactically valid, otherwise the import would have died with an exception.", "Now it\u2019s time to start testing the functionality of the application. Let\u2019s check that the application shows \u201cNo entries here so far\u201d if we access the root of the application (/). To do this, we add a new test function to test_flaskr.py, like this:", "Notice that our test functions begin with the word test; this allows pytest to automatically identify the function as a test to run.", "By using client.get we can send an HTTP GET request to the application with the given path. The return value will be a response_class object. We can now use the data attribute to inspect the return value (as string) from the application. In this case, we ensure that 'No entries here so far' is part of the output.", "Run it again and you should see one passing test:", "The majority of the functionality of our application is only available for the administrative user, so we need a way to log our test client in and out of the application. To do this, we fire some requests to the login and logout pages with the required form data (username and password). And because the login and logout pages redirect, we tell the client to follow_redirects.", "Add the following two functions to your test_flaskr.py file:", "Now we can easily test that logging in and out works and that it fails with invalid credentials. Add this new test function:", "We should also test that adding messages works. Add a new test function like this:", "Here we check that HTML is allowed in the text but not in the title, which is the intended behavior.", "Running that should now give us three passing tests:", "Besides using the test client as shown above, there is also the test_request_context() method that can be used in combination with the with statement to activate a request context temporarily. With this you can access the request, g and session objects like in view functions. Here is a full example that demonstrates this approach:", "All the other objects that are context bound can be used in the same way.", "If you want to test your application with different configurations and there does not seem to be a good way to do that, consider switching to application factories (see Application Factories).", "Note however that if you are using a test request context, the before_request() and after_request() functions are not called automatically. However teardown_request() functions are indeed executed when the test request context leaves the with block. If you do want the before_request() functions to be called as well, you need to call preprocess_request() yourself:", "This can be necessary to open database connections or something similar depending on how your application was designed.", "If you want to call the after_request() functions you need to call into process_response() which however requires that you pass it a response object:", "This in general is less useful because at that point you can directly start using the test client.", "New in version 0.10.", "A very common pattern is to store user authorization information and database connections on the application context or the flask.g object. The general pattern for this is to put the object on there on first usage and then to remove it on a teardown. Imagine for instance this code to get the current user:", "For a test it would be nice to override this user from the outside without having to change some code. This can be accomplished with hooking the flask.appcontext_pushed signal:", "And then to use it:", "New in version 0.4.", "Sometimes it is helpful to trigger a regular request but still keep the context around for a little longer so that additional introspection can happen. With Flask 0.4 this is possible by using the test_client() with a with block:", "If you were to use just the test_client() without the with block, the assert would fail with an error because request is no longer available (because you are trying to use it outside of the actual request).", "New in version 0.8.", "Sometimes it can be very helpful to access or modify the sessions from the test client. Generally there are two ways for this. If you just want to ensure that a session has certain keys set to certain values you can just keep the context around and access flask.session:", "This however does not make it possible to also modify the session or to access the session before a request was fired. Starting with Flask 0.8 we provide a so called \u201csession transaction\u201d which simulates the appropriate calls to open a session in the context of the test client and to modify it. At the end of the transaction the session is stored and ready to be used by the test client. This works independently of the session backend used:", "Note that in this case you have to use the sess object instead of the flask.session proxy. The object however itself will provide the same interface.", "New in version 1.0.", "Flask has great support for JSON, and is a popular choice for building JSON APIs. Making requests with JSON data and examining JSON data in responses is very convenient:", "Passing the json argument in the test client methods sets the request data to the JSON-serialized object and sets the content type to application/json. You can get the JSON data from the request or response with get_json.", "Click comes with utilities for testing your CLI commands. A CliRunner runs commands in isolation and captures the output in a Result object.", "Flask provides test_cli_runner() to create a FlaskCliRunner that passes the Flask app to the CLI automatically. Use its invoke() method to call commands in the same way they would be called from the command line.", "In the example above, invoking the command by name is useful because it verifies that the command was correctly registered with the app.", "If you want to test how your command parses parameters, without running the command, use its make_context() method. This is useful for testing complex validation rules and custom types."]}, {"name": "The Application Context", "path": "appcontext/index", "type": "User\u2019s Guide", "text": ["The application context keeps track of the application-level data during a request, CLI command, or other activity. Rather than passing the application around to each function, the current_app and g proxies are accessed instead.", "This is similar to the The Request Context, which keeps track of request-level data during a request. A corresponding application context is pushed when a request context is pushed.", "The Flask application object has attributes, such as config, that are useful to access within views and CLI commands. However, importing the app instance within the modules in your project is prone to circular import issues. When using the app factory pattern or writing reusable blueprints or extensions there won\u2019t be an app instance to import at all.", "Flask solves this issue with the application context. Rather than referring to an app directly, you use the current_app proxy, which points to the application handling the current activity.", "Flask automatically pushes an application context when handling a request. View functions, error handlers, and other functions that run during a request will have access to current_app.", "Flask will also automatically push an app context when running CLI commands registered with Flask.cli using @app.cli.command().", "The application context is created and destroyed as necessary. When a Flask application begins handling a request, it pushes an application context and a request context. When the request ends it pops the request context then the application context. Typically, an application context will have the same lifetime as a request.", "See The Request Context for more information about how the contexts work and the full life cycle of a request.", "If you try to access current_app, or anything that uses it, outside an application context, you\u2019ll get this error message:", "If you see that error while configuring your application, such as when initializing an extension, you can push a context manually since you have direct access to the app. Use app_context() in a with block, and everything that runs in the block will have access to current_app.", "If you see that error somewhere else in your code not related to configuring the application, it most likely indicates that you should move that code into a view function or CLI command.", "The application context is a good place to store common data during a request or CLI command. Flask provides the g object for this purpose. It is a simple namespace object that has the same lifetime as an application context.", "Note", "The g name stands for \u201cglobal\u201d, but that is referring to the data being global within a context. The data on g is lost after the context ends, and it is not an appropriate place to store data between requests. Use the session or a database to store data across requests.", "A common use for g is to manage resources during a request.", "For example, you can manage a database connection using this pattern:", "During a request, every call to get_db() will return the same connection, and it will be closed automatically at the end of the request.", "You can use LocalProxy to make a new context local from get_db():", "Accessing db will call get_db internally, in the same way that current_app works.", "If you\u2019re writing an extension, g should be reserved for user code. You may store internal data on the context itself, but be sure to use a sufficiently unique name. The current context is accessed with _app_ctx_stack.top. For more information see Flask Extension Development.", "The application will call functions registered with teardown_appcontext() when the application context is popped.", "If signals_available is true, the following signals are sent: appcontext_pushed, appcontext_tearing_down, and appcontext_popped."]}, {"name": "The Request Context", "path": "reqcontext/index", "type": "User\u2019s Guide", "text": ["The request context keeps track of the request-level data during a request. Rather than passing the request object to each function that runs during a request, the request and session proxies are accessed instead.", "This is similar to the The Application Context, which keeps track of the application-level data independent of a request. A corresponding application context is pushed when a request context is pushed.", "When the Flask application handles a request, it creates a Request object based on the environment it received from the WSGI server. Because a worker (thread, process, or coroutine depending on the server) handles only one request at a time, the request data can be considered global to that worker during that request. Flask uses the term context local for this.", "Flask automatically pushes a request context when handling a request. View functions, error handlers, and other functions that run during a request will have access to the request proxy, which points to the request object for the current request.", "When a Flask application begins handling a request, it pushes a request context, which also pushes an The Application Context. When the request ends it pops the request context then the application context.", "The context is unique to each thread (or other worker type). request cannot be passed to another thread, the other thread will have a different context stack and will not know about the request the parent thread was pointing to.", "Context locals are implemented in Werkzeug. See Context Locals for more information on how this works internally.", "If you try to access request, or anything that uses it, outside a request context, you\u2019ll get this error message:", "This should typically only happen when testing code that expects an active request. One option is to use the test client to simulate a full request. Or you can use test_request_context() in a with block, and everything that runs in the block will have access to request, populated with your test data.", "If you see that error somewhere else in your code not related to testing, it most likely indicates that you should move that code into a view function.", "For information on how to use the request context from the interactive Python shell, see Working with the Shell.", "The Flask.wsgi_app() method is called to handle each request. It manages the contexts during the request. Internally, the request and application contexts work as stacks, _request_ctx_stack and _app_ctx_stack. When contexts are pushed onto the stack, the proxies that depend on them are available and point at information from the top context on the stack.", "When the request starts, a RequestContext is created and pushed, which creates and pushes an AppContext first if a context for that application is not already the top context. While these contexts are pushed, the current_app, g, request, and session proxies are available to the original thread handling the request.", "Because the contexts are stacks, other contexts may be pushed to change the proxies during a request. While this is not a common pattern, it can be used in advanced applications to, for example, do internal redirects or chain different applications together.", "After the request is dispatched and a response is generated and sent, the request context is popped, which then pops the application context. Immediately before they are popped, the teardown_request() and teardown_appcontext() functions are executed. These execute even if an unhandled exception occurred during dispatch.", "Flask dispatches a request in multiple stages which can affect the request, response, and how errors are handled. The contexts are active during all of these stages.", "A Blueprint can add handlers for these events that are specific to the blueprint. The handlers for a blueprint will run if the blueprint owns the route that matches the request.", "If an exception is raised before the teardown functions, Flask tries to match it with an errorhandler() function to handle the exception and return a response. If no error handler is found, or the handler itself raises an exception, Flask returns a generic 500 Internal Server Error response. The teardown functions are still called, and are passed the exception object.", "If debug mode is enabled, unhandled exceptions are not converted to a 500 response and instead are propagated to the WSGI server. This allows the development server to present the interactive debugger with the traceback.", "The teardown callbacks are independent of the request dispatch, and are instead called by the contexts when they are popped. The functions are called even if there is an unhandled exception during dispatch, and for manually pushed contexts. This means there is no guarantee that any other parts of the request dispatch have run first. Be sure to write these functions in a way that does not depend on other callbacks and will not fail.", "During testing, it can be useful to defer popping the contexts after the request ends, so that their data can be accessed in the test function. Use the test_client() as a with block to preserve the contexts until the with block exits.", "If signals_available is true, the following signals are sent:", "At the end of a request, the request context is popped and all data associated with it is destroyed. If an error occurs during development, it is useful to delay destroying the data for debugging purposes.", "When the development server is running in development mode (the FLASK_ENV environment variable is set to 'development'), the error and data will be preserved and shown in the interactive debugger.", "This behavior can be controlled with the PRESERVE_CONTEXT_ON_EXCEPTION config. As described above, it defaults to True in the development environment.", "Do not enable PRESERVE_CONTEXT_ON_EXCEPTION in production, as it will cause your application to leak memory on exceptions.", "Some of the objects provided by Flask are proxies to other objects. The proxies are accessed in the same way for each worker thread, but point to the unique object bound to each worker behind the scenes as described on this page.", "Most of the time you don\u2019t have to care about that, but there are some exceptions where it is good to know that this object is actually a proxy:", "If you need to access the underlying object that is proxied, use the _get_current_object() method:"]}, {"name": "TRAP_BAD_REQUEST_ERRORS", "path": "config/index#TRAP_BAD_REQUEST_ERRORS", "type": "Configuration", "text": ["Trying to access a key that doesn\u2019t exist from request dicts like args and form will return a 400 Bad Request error page. Enable this to treat the error as an unhandled exception instead so that you get the interactive debugger. This is a more specific version of TRAP_HTTP_EXCEPTIONS. If unset, it is enabled in debug mode.", "Default: None"]}, {"name": "TRAP_HTTP_EXCEPTIONS", "path": "config/index#TRAP_HTTP_EXCEPTIONS", "type": "Configuration", "text": ["If there is no handler for an HTTPException-type exception, re-raise it to be handled by the interactive debugger instead of returning it as a simple error response.", "Default: False"]}, {"name": "Uploading Files", "path": "patterns/fileuploads/index", "type": "User's Guide: Design Patterns", "text": ["Ah yes, the good old problem of file uploads. The basic idea of file uploads is actually quite simple. It basically works like this:", "Let\u2019s start with a very basic application that uploads a file to a specific upload folder and displays a file to the user. Let\u2019s look at the bootstrapping code for our application:", "So first we need a couple of imports. Most should be straightforward, the werkzeug.secure_filename() is explained a little bit later. The UPLOAD_FOLDER is where we will store the uploaded files and the ALLOWED_EXTENSIONS is the set of allowed file extensions.", "Why do we limit the extensions that are allowed? You probably don\u2019t want your users to be able to upload everything there if the server is directly sending out the data to the client. That way you can make sure that users are not able to upload HTML files that would cause XSS problems (see Cross-Site Scripting (XSS)). Also make sure to disallow .php files if the server executes them, but who has PHP installed on their server, right? :)", "Next the functions that check if an extension is valid and that uploads the file and redirects the user to the URL for the uploaded file:", "So what does that secure_filename() function actually do? Now the problem is that there is that principle called \u201cnever trust user input\u201d. This is also true for the filename of an uploaded file. All submitted form data can be forged, and filenames can be dangerous. For the moment just remember: always use that function to secure a filename before storing it directly on the filesystem.", "Information for the Pros", "So you\u2019re interested in what that secure_filename() function does and what the problem is if you\u2019re not using it? So just imagine someone would send the following information as filename to your application:", "Assuming the number of ../ is correct and you would join this with the UPLOAD_FOLDER the user might have the ability to modify a file on the server\u2019s filesystem he or she should not modify. This does require some knowledge about how the application looks like, but trust me, hackers are patient :)", "Now let\u2019s look how that function works:", "We want to be able to serve the uploaded files so they can be downloaded by users. We\u2019ll define a download_file view to serve files in the upload folder by name. url_for(\"download_file\", name=name) generates download URLs.", "If you\u2019re using middleware or the HTTP server to serve files, you can register the download_file endpoint as build_only so url_for will work without a view function.", "New in version 0.6.", "So how exactly does Flask handle uploads? Well it will store them in the webserver\u2019s memory if the files are reasonably small, otherwise in a temporary location (as returned by tempfile.gettempdir()). But how do you specify the maximum file size after which an upload is aborted? By default Flask will happily accept file uploads with an unlimited amount of memory, but you can limit that by setting the MAX_CONTENT_LENGTH config key:", "The code above will limit the maximum allowed payload to 16 megabytes. If a larger file is transmitted, Flask will raise a RequestEntityTooLarge exception.", "Connection Reset Issue", "When using the local development server, you may get a connection reset error instead of a 413 response. You will get the correct status response when running the app with a production WSGI server.", "This feature was added in Flask 0.6 but can be achieved in older versions as well by subclassing the request object. For more information on that consult the Werkzeug documentation on file handling.", "A while ago many developers had the idea to read the incoming file in small chunks and store the upload progress in the database to be able to poll the progress with JavaScript from the client. The client asks the server every 5 seconds how much it has transmitted, but this is something it should already know.", "Now there are better solutions that work faster and are more reliable. There are JavaScript libraries like jQuery that have form plugins to ease the construction of progress bar.", "Because the common pattern for file uploads exists almost unchanged in all applications dealing with uploads, there is also a Flask extension called Flask-Uploads that implements a full fledged upload mechanism that allows controlling which file extensions are allowed to be uploaded."]}, {"name": "url_for()", "path": "api/index#flask.url_for", "type": "flask", "text": ["Generates a URL to the given endpoint with the method provided.", "Variable arguments that are unknown to the target endpoint are appended to the generated URL as query arguments. If the value of a query argument is None, the whole pair is skipped. In case blueprints are active you can shortcut references to the same blueprint by prefixing the local endpoint with a dot (.).", "This will reference the index function local to the current blueprint:", "See URL Building.", "Configuration values APPLICATION_ROOT and SERVER_NAME are only used when generating URLs outside of a request context.", "To integrate applications, Flask has a hook to intercept URL build errors through Flask.url_build_error_handlers. The url_for function results in a BuildError when the current app does not have a URL for the given endpoint and values. When it does, the current_app calls its url_build_error_handlers if it is not None, which can return a string to use as the result of url_for (instead of url_for\u2019s default to raise the BuildError exception) or re-raise the exception. An example:", "Here, error is the instance of BuildError, and endpoint and values are the arguments passed into url_for. Note that this is for building URLs outside the current application, and not for handling 404 NotFound errors.", "New in version 0.10: The _scheme parameter was added.", "New in version 0.9: The _anchor and _method parameters were added.", "New in version 0.9: Calls Flask.handle_build_error() on BuildError.", "str"]}, {"name": "USE_X_SENDFILE", "path": "config/index#USE_X_SENDFILE", "type": "Configuration", "text": ["When serving files, set the X-Sendfile header instead of serving the data with Flask. Some web servers, such as Apache, recognize this and serve the data more efficiently. This only makes sense when using such a server.", "Default: False"]}, {"name": "Using async and await", "path": "async-await/index", "type": "User\u2019s Guide", "text": ["New in version 2.0.", "Routes, error handlers, before request, after request, and teardown functions can all be coroutine functions if Flask is installed with the async extra (pip install flask[async]). This allows views to be defined with async def and use await.", "Using async on Windows on Python 3.8", "Python 3.8 has a bug related to asyncio on Windows. If you encounter something like ValueError: set_wakeup_fd only works in main thread, please upgrade to Python 3.9.", "Async functions require an event loop to run. Flask, as a WSGI application, uses one worker to handle one request/response cycle. When a request comes in to an async view, Flask will start an event loop in a thread, run the view function there, then return the result.", "Each request still ties up one worker, even for async views. The upside is that you can run async code within a view, for example to make multiple concurrent database queries, HTTP requests to an external API, etc. However, the number of requests your application can handle at one time will remain the same.", "Async is not inherently faster than sync code. Async is beneficial when performing concurrent IO-bound tasks, but will probably not improve CPU-bound tasks. Traditional Flask views will still be appropriate for most use cases, but Flask\u2019s async support enables writing and using code that wasn\u2019t possible natively before.", "Async functions will run in an event loop until they complete, at which stage the event loop will stop. This means any additional spawned tasks that haven\u2019t completed when the async function completes will be cancelled. Therefore you cannot spawn background tasks, for example via asyncio.create_task.", "If you wish to use background tasks it is best to use a task queue to trigger background work, rather than spawn tasks in a view function. With that in mind you can spawn asyncio tasks by serving Flask with an ASGI server and utilising the asgiref WsgiToAsgi adapter as described in ASGI. This works as the adapter creates an event loop that runs continually.", "Flask\u2019s async support is less performant than async-first frameworks due to the way it is implemented. If you have a mainly async codebase it would make sense to consider Quart. Quart is a reimplementation of Flask based on the ASGI standard instead of WSGI. This allows it to handle many concurrent requests, long running requests, and websockets without requiring multiple worker processes or threads.", "It has also already been possible to run Flask with Gevent or Eventlet to get many of the benefits of async request handling. These libraries patch low-level Python functions to accomplish this, whereas async/ await and ASGI use standard, modern Python capabilities. Deciding whether you should use Flask, Quart, or something else is ultimately up to understanding the specific needs of your project.", "Flask extensions predating Flask\u2019s async support do not expect async views. If they provide decorators to add functionality to views, those will probably not work with async views because they will not await the function or be awaitable. Other functions they provide will not be awaitable either and will probably be blocking if called within an async view.", "Extension authors can support async functions by utilising the flask.Flask.ensure_sync() method. For example, if the extension provides a view function decorator add ensure_sync before calling the decorated function,", "Check the changelog of the extension you want to use to see if they\u2019ve implemented async support, or make a feature request or PR to them.", "At the moment Flask only supports asyncio. It\u2019s possible to override flask.Flask.ensure_sync() to change how async functions are wrapped to use a different library."]}, {"name": "Using SQLite 3 with Flask", "path": "patterns/sqlite3/index", "type": "User's Guide: Design Patterns", "text": ["In Flask you can easily implement the opening of database connections on demand and closing them when the context dies (usually at the end of the request).", "Here is a simple example of how you can use SQLite 3 with Flask:", "Now, to use the database, the application must either have an active application context (which is always true if there is a request in flight) or create an application context itself. At that point the get_db function can be used to get the current database connection. Whenever the context is destroyed the database connection will be terminated.", "Note: if you use Flask 0.9 or older you need to use flask._app_ctx_stack.top instead of g as the flask.g object was bound to the request and not application context.", "Example:", "Note", "Please keep in mind that the teardown request and appcontext functions are always executed, even if a before-request handler failed or was never executed. Because of this we have to make sure here that the database is there before we close it.", "The upside of this approach (connecting on first use) is that this will only open the connection if truly necessary. If you want to use this code outside a request context you can use it in a Python shell by opening the application context by hand:", "Now in each request handling function you can access get_db() to get the current open database connection. To simplify working with SQLite, a row factory function is useful. It is executed for every result returned from the database to convert the result. For instance, in order to get dictionaries instead of tuples, this could be inserted into the get_db function we created above:", "This will make the sqlite3 module return dicts for this database connection, which are much nicer to deal with. Even more simply, we could place this in get_db instead:", "This would use Row objects rather than dicts to return the results of queries. These are namedtuple s, so we can access them either by index or by key. For example, assuming we have a sqlite3.Row called r for the rows id, FirstName, LastName, and MiddleInitial:", "Additionally, it is a good idea to provide a query function that combines getting the cursor, executing and fetching the results:", "This handy little function, in combination with a row factory, makes working with the database much more pleasant than it is by just using the raw cursor and connection objects.", "Here is how you can use it:", "Or if you just want a single result:", "To pass variable parts to the SQL statement, use a question mark in the statement and pass in the arguments as a list. Never directly add them to the SQL statement with string formatting because this makes it possible to attack the application using SQL Injections.", "Relational databases need schemas, so applications often ship a schema.sql file that creates the database. It\u2019s a good idea to provide a function that creates the database based on that schema. This function can do that for you:", "You can then create such a database from the Python shell:"]}, {"name": "Using URL Processors", "path": "patterns/urlprocessors/index", "type": "User's Guide: Design Patterns", "text": ["New in version 0.7.", "Flask 0.7 introduces the concept of URL processors. The idea is that you might have a bunch of resources with common parts in the URL that you don\u2019t always explicitly want to provide. For instance you might have a bunch of URLs that have the language code in it but you don\u2019t want to have to handle it in every single function yourself.", "URL processors are especially helpful when combined with blueprints. We will handle both application specific URL processors here as well as blueprint specifics.", "Consider an application like this:", "This is an awful lot of repetition as you have to handle the language code setting on the g object yourself in every single function. Sure, a decorator could be used to simplify this, but if you want to generate URLs from one function to another you would have to still provide the language code explicitly which can be annoying.", "For the latter, this is where url_defaults() functions come in. They can automatically inject values into a call to url_for(). The code below checks if the language code is not yet in the dictionary of URL values and if the endpoint wants a value named 'lang_code':", "The method is_endpoint_expecting() of the URL map can be used to figure out if it would make sense to provide a language code for the given endpoint.", "The reverse of that function are url_value_preprocessor()s. They are executed right after the request was matched and can execute code based on the URL values. The idea is that they pull information out of the values dictionary and put it somewhere else:", "That way you no longer have to do the lang_code assignment to g in every function. You can further improve that by writing your own decorator that prefixes URLs with the language code, but the more beautiful solution is using a blueprint. Once the 'lang_code' is popped from the values dictionary and it will no longer be forwarded to the view function reducing the code to this:", "Because blueprints can automatically prefix all URLs with a common string it\u2019s easy to automatically do that for every function. Furthermore blueprints can have per-blueprint URL processors which removes a whole lot of logic from the url_defaults() function because it no longer has to check if the URL is really interested in a 'lang_code' parameter:"]}, {"name": "uWSGI", "path": "deploying/uwsgi/index", "type": "User's Guide: Deploying", "text": ["uWSGI is a deployment option on servers like nginx, lighttpd, and cherokee; see FastCGI and Standalone WSGI Containers for other options. To use your WSGI application with uWSGI protocol you will need a uWSGI server first. uWSGI is both a protocol and an application server; the application server can serve uWSGI, FastCGI, and HTTP protocols.", "The most popular uWSGI server is uwsgi, which we will use for this guide. Make sure to have it installed to follow along.", "Watch Out", "Please make sure in advance that any app.run() calls you might have in your application file are inside an if __name__ ==\n'__main__': block or moved to a separate file. Just make sure it\u2019s not called because this will always start a local WSGI server which we do not want if we deploy that application to uWSGI.", "uwsgi is designed to operate on WSGI callables found in python modules.", "Given a flask application in myapp.py, use the following command:", "The --manage-script-name will move the handling of SCRIPT_NAME to uwsgi, since it is smarter about that. It is used together with the --mount directive which will make requests to /yourapplication be directed to myapp:app. If your application is accessible at root level, you can use a single / instead of /yourapplication. myapp refers to the name of the file of your flask application (without extension) or the module which provides app. app is the callable inside of your application (usually the line reads app = Flask(__name__).", "If you want to deploy your flask application inside of a virtual environment, you need to also add --virtualenv /path/to/virtual/environment. You might also need to add --plugin python or --plugin python3 depending on which python version you use for your project.", "A basic flask nginx configuration looks like this:", "This configuration binds the application to /yourapplication. If you want to have it in the URL root its a bit simpler:"]}, {"name": "View", "path": "api/index#flask.views.View", "type": "flask.views", "text": ["Alternative way to use view functions. A subclass has to implement dispatch_request() which is called with the view arguments from the URL routing system. If methods is provided the methods do not have to be passed to the add_url_rule() method explicitly:", "When you want to decorate a pluggable view you will have to either do that when the view function is created (by wrapping the return value of as_view()) or you can use the decorators attribute:", "The decorators stored in the decorators list are applied one after another when the view function is created. Note that you can not use the class based decorators since those would decorate the view class and not the generated view function!", "Converts the class into an actual view function that can be used with the routing system. Internally this generates a function on the fly which will instantiate the View on each request and call the dispatch_request() method on it.", "The arguments passed to as_view() are forwarded to the constructor of the class.", "Callable", "The canonical way to decorate class-based views is to decorate the return value of as_view(). However since this moves parts of the logic from the class declaration to the place where it\u2019s hooked into the routing system.", "You can place one or more decorators in this list and whenever the view function is created the result is automatically decorated.", "New in version 0.8.", "Subclasses have to override this method to implement the actual view function code. This method is called with all the arguments from the URL rule.", "Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], WSGIApplication]", "A list of methods this view can handle.", "Setting this disables or force-enables the automatic options handling."]}, {"name": "View Decorators", "path": "patterns/viewdecorators/index", "type": "User's Guide: Design Patterns", "text": ["Python has a really interesting feature called function decorators. This allows some really neat things for web applications. Because each view in Flask is a function, decorators can be used to inject additional functionality to one or more functions. The route() decorator is the one you probably used already. But there are use cases for implementing your own decorator. For instance, imagine you have a view that should only be used by people that are logged in. If a user goes to the site and is not logged in, they should be redirected to the login page. This is a good example of a use case where a decorator is an excellent solution.", "So let\u2019s implement such a decorator. A decorator is a function that wraps and replaces another function. Since the original function is replaced, you need to remember to copy the original function\u2019s information to the new function. Use functools.wraps() to handle this for you.", "This example assumes that the login page is called 'login' and that the current user is stored in g.user and is None if there is no-one logged in.", "To use the decorator, apply it as innermost decorator to a view function. When applying further decorators, always remember that the route() decorator is the outermost.", "Note", "The next value will exist in request.args after a GET request for the login page. You\u2019ll have to pass it along when sending the POST request from the login form. You can do this with a hidden input tag, then retrieve it from request.form when logging the user in.", "Imagine you have a view function that does an expensive calculation and because of that you would like to cache the generated results for a certain amount of time. A decorator would be nice for that. We\u2019re assuming you have set up a cache like mentioned in Caching.", "Here is an example cache function. It generates the cache key from a specific prefix (actually a format string) and the current path of the request. Notice that we are using a function that first creates the decorator that then decorates the function. Sounds awful? Unfortunately it is a little bit more complex, but the code should still be straightforward to read.", "The decorated function will then work as follows", "Here the code:", "Notice that this assumes an instantiated cache object is available, see Caching.", "A common pattern invented by the TurboGears guys a while back is a templating decorator. The idea of that decorator is that you return a dictionary with the values passed to the template from the view function and the template is automatically rendered. With that, the following three examples do exactly the same:", "As you can see, if no template name is provided it will use the endpoint of the URL map with dots converted to slashes + '.html'. Otherwise the provided template name is used. When the decorated function returns, the dictionary returned is passed to the template rendering function. If None is returned, an empty dictionary is assumed, if something else than a dictionary is returned we return it from the function unchanged. That way you can still use the redirect function or return simple strings.", "Here is the code for that decorator:", "When you want to use the werkzeug routing system for more flexibility you need to map the endpoint as defined in the Rule to a view function. This is possible with this decorator. For example:"]}, {"name": "View.as_view()", "path": "api/index#flask.views.View.as_view", "type": "flask.views", "text": ["Converts the class into an actual view function that can be used with the routing system. Internally this generates a function on the fly which will instantiate the View on each request and call the dispatch_request() method on it.", "The arguments passed to as_view() are forwarded to the constructor of the class.", "Callable"]}, {"name": "View.decorators", "path": "api/index#flask.views.View.decorators", "type": "flask.views", "text": ["The canonical way to decorate class-based views is to decorate the return value of as_view(). However since this moves parts of the logic from the class declaration to the place where it\u2019s hooked into the routing system.", "You can place one or more decorators in this list and whenever the view function is created the result is automatically decorated.", "New in version 0.8."]}, {"name": "View.dispatch_request()", "path": "api/index#flask.views.View.dispatch_request", "type": "flask.views", "text": ["Subclasses have to override this method to implement the actual view function code. This method is called with all the arguments from the URL rule.", "Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], WSGIApplication]"]}, {"name": "View.methods", "path": "api/index#flask.views.View.methods", "type": "flask.views", "text": ["A list of methods this view can handle."]}, {"name": "View.provide_automatic_options", "path": "api/index#flask.views.View.provide_automatic_options", "type": "flask.views", "text": ["Setting this disables or force-enables the automatic options handling."]}, {"name": "with_appcontext()", "path": "api/index#flask.cli.with_appcontext", "type": "flask.cli", "text": ["Wraps a callback so that it\u2019s guaranteed to be executed with the script\u2019s application context. If callbacks are registered directly to the app.cli object then they are wrapped with this function by default unless it\u2019s disabled."]}, {"name": "Working with the Shell", "path": "shell/index", "type": "User\u2019s Guide", "text": ["New in version 0.3.", "One of the reasons everybody loves Python is the interactive shell. It basically allows you to execute Python commands in real time and immediately get results back. Flask itself does not come with an interactive shell, because it does not require any specific setup upfront, just import your application and start playing around.", "There are however some handy helpers to make playing around in the shell a more pleasant experience. The main issue with interactive console sessions is that you\u2019re not triggering a request like a browser does which means that g, request and others are not available. But the code you want to test might depend on them, so what can you do?", "This is where some helper functions come in handy. Keep in mind however that these functions are not only there for interactive shell usage, but also for unit testing and other situations that require a faked request context.", "Generally it\u2019s recommended that you read the The Request Context chapter of the documentation first.", "Starting with Flask 0.11 the recommended way to work with the shell is the flask shell command which does a lot of this automatically for you. For instance the shell is automatically initialized with a loaded application context.", "For more information see Command Line Interface.", "The easiest way to create a proper request context from the shell is by using the test_request_context method which creates us a RequestContext:", "Normally you would use the with statement to make this request object active, but in the shell it\u2019s easier to use the push() and pop() methods by hand:", "From that point onwards you can work with the request object until you call pop:", "By just creating a request context, you still don\u2019t have run the code that is normally run before a request. This might result in your database being unavailable if you are connecting to the database in a before-request callback or the current user not being stored on the g object etc.", "This however can easily be done yourself. Just call preprocess_request():", "Keep in mind that the preprocess_request() function might return a response object, in that case just ignore it.", "To shutdown a request, you need to trick a bit before the after request functions (triggered by process_response()) operate on a response object:", "The functions registered as teardown_request() are automatically called when the context is popped. So this is the perfect place to automatically tear down resources that were needed by the request context (such as database connections).", "If you like the idea of experimenting in a shell, create yourself a module with stuff you want to star import into your interactive session. There you could also define some more helper methods for common things such as initializing the database, dropping tables etc.", "Just put them into a module (like shelltools) and import from there:"]}, {"name": "_AppCtxGlobals", "path": "api/index#flask.ctx._AppCtxGlobals", "type": "flask.ctx", "text": ["A plain object. Used as a namespace for storing data during an application context.", "Creating an app context automatically creates this object, which is made available as the g proxy.", "Check whether an attribute is present.", "New in version 0.10.", "Return an iterator over the attribute names.", "New in version 0.10.", "Get an attribute by name, or a default value. Like dict.get().", "Any", "New in version 0.10.", "Get and remove an attribute by name. Like dict.pop().", "Any", "New in version 0.11.", "Get the value of an attribute if it is present, otherwise set and return a default value. Like dict.setdefault().", "Any", "New in version 0.11."]}, {"name": "_AppCtxGlobals.get()", "path": "api/index#flask.ctx._AppCtxGlobals.get", "type": "flask.ctx", "text": ["Get an attribute by name, or a default value. Like dict.get().", "Any", "New in version 0.10."]}, {"name": "_AppCtxGlobals.pop()", "path": "api/index#flask.ctx._AppCtxGlobals.pop", "type": "flask.ctx", "text": ["Get and remove an attribute by name. Like dict.pop().", "Any", "New in version 0.11."]}, {"name": "_AppCtxGlobals.setdefault()", "path": "api/index#flask.ctx._AppCtxGlobals.setdefault", "type": "flask.ctx", "text": ["Get the value of an attribute if it is present, otherwise set and return a default value. Like dict.setdefault().", "Any", "New in version 0.11."]}]