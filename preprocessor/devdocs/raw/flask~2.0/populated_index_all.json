[{"name": "abort()", "path": "api/index#flask.abort", "type": "flask", "text": " \nflask.abort(status, *args, **kwargs)  \nRaises an HTTPException for the given status code or WSGI application. If a status code is given, it will be looked up in the list of exceptions and will raise that exception. If passed a WSGI application, it will wrap it in a proxy WSGI exception and raise that: abort(404)  # 404 Not Found\nabort(Response('Hello World'))\n  Parameters \n \nstatus (Union[int, Response]) \u2013  \nargs (Any) \u2013  \nkwargs (Any) \u2013    Return type \nNoReturn   \n"}, {"name": "Adding a favicon", "path": "patterns/favicon/index", "type": "User's Guide: Design Patterns", "text": "Adding a favicon A \u201cfavicon\u201d is an icon used by browsers for tabs and bookmarks. This helps to distinguish your website and to give it a unique brand. A common question is how to add a favicon to a Flask application. First, of course, you need an icon. It should be 16 \u00d7 16 pixels and in the ICO file format. This is not a requirement but a de-facto standard supported by all relevant browsers. Put the icon in your static directory as favicon.ico. Now, to get browsers to find your icon, the correct way is to add a link tag in your HTML. So, for example: <link rel=\"shortcut icon\" href=\"{{ url_for('static', filename='favicon.ico') }}\">\n That\u2019s all you need for most browsers, however some really old ones do not support this standard. The old de-facto standard is to serve this file, with this name, at the website root. If your application is not mounted at the root path of the domain you either need to configure the web server to serve the icon at the root or if you can\u2019t do that you\u2019re out of luck. If however your application is the root you can simply route a redirect: app.add_url_rule('/favicon.ico',\n                 redirect_to=url_for('static', filename='favicon.ico'))\n If you want to save the extra redirect request you can also write a view using send_from_directory(): import os\nfrom flask import send_from_directory\n\n@app.route('/favicon.ico')\ndef favicon():\n    return send_from_directory(os.path.join(app.root_path, 'static'),\n                               'favicon.ico', mimetype='image/vnd.microsoft.icon')\n We can leave out the explicit mimetype and it will be guessed, but we may as well specify it to avoid the extra guessing, as it will always be the same. The above will serve the icon via your application and if possible it\u2019s better to configure your dedicated web server to serve it; refer to the web server\u2019s documentation. See also  The Favicon article on Wikipedia \n"}, {"name": "Adding HTTP Method Overrides", "path": "patterns/methodoverrides/index", "type": "User's Guide: Design Patterns", "text": "Adding HTTP Method Overrides Some HTTP proxies do not support arbitrary HTTP methods or newer HTTP methods (such as PATCH). In that case it\u2019s possible to \u201cproxy\u201d HTTP methods through another HTTP method in total violation of the protocol. The way this works is by letting the client do an HTTP POST request and set the X-HTTP-Method-Override header. Then the method is replaced with the header value before being passed to Flask. This can be accomplished with an HTTP middleware: class HTTPMethodOverrideMiddleware(object):\n    allowed_methods = frozenset([\n        'GET',\n        'HEAD',\n        'POST',\n        'DELETE',\n        'PUT',\n        'PATCH',\n        'OPTIONS'\n    ])\n    bodyless_methods = frozenset(['GET', 'HEAD', 'OPTIONS', 'DELETE'])\n\n    def __init__(self, app):\n        self.app = app\n\n    def __call__(self, environ, start_response):\n        method = environ.get('HTTP_X_HTTP_METHOD_OVERRIDE', '').upper()\n        if method in self.allowed_methods:\n            environ['REQUEST_METHOD'] = method\n        if method in self.bodyless_methods:\n            environ['CONTENT_LENGTH'] = '0'\n        return self.app(environ, start_response)\n To use this with Flask, wrap the app object with the middleware: from flask import Flask\n\napp = Flask(__name__)\napp.wsgi_app = HTTPMethodOverrideMiddleware(app.wsgi_app)\n\n"}, {"name": "after_this_request()", "path": "api/index#flask.after_this_request", "type": "flask", "text": " \nflask.after_this_request(f)  \nExecutes a function after this request. This is useful to modify response objects. The function is passed the response object and has to return the same or a new one. Example: @app.route('/')\ndef index():\n    @after_this_request\n    def add_header(response):\n        response.headers['X-Foo'] = 'Parachute'\n        return response\n    return 'Hello World!'\n This is more useful if a function other than the view function wants to modify a response. For instance think of a decorator that wants to add some headers without converting the return value into a response object.  Changelog New in version 0.9.   Parameters \nf (Callable[[Response], Response]) \u2013   Return type \nCallable[[Response], Response]   \n"}, {"name": "AJAX with jQuery", "path": "patterns/jquery/index", "type": "User's Guide: Design Patterns", "text": "AJAX with jQuery jQuery is a small JavaScript library commonly used to simplify working with the DOM and JavaScript in general. It is the perfect tool to make web applications more dynamic by exchanging JSON between server and client. JSON itself is a very lightweight transport format, very similar to how Python primitives (numbers, strings, dicts and lists) look like which is widely supported and very easy to parse. It became popular a few years ago and quickly replaced XML as transport format in web applications. Loading jQuery In order to use jQuery, you have to download it first and place it in the static folder of your application and then ensure it\u2019s loaded. Ideally you have a layout template that is used for all pages where you just have to add a script statement to the bottom of your <body> to load jQuery: <script type=text/javascript src=\"{{\n  url_for('static', filename='jquery.js') }}\"></script>\n Another method is using Google\u2019s AJAX Libraries API to load jQuery: <script src=\"//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js\"></script>\n<script>window.jQuery || document.write('<script src=\"{{\n  url_for('static', filename='jquery.js') }}\">\\x3C/script>')</script>\n In this case you have to put jQuery into your static folder as a fallback, but it will first try to load it directly from Google. This has the advantage that your website will probably load faster for users if they went to at least one other website before using the same jQuery version from Google because it will already be in the browser cache. Where is My Site? Do you know where your application is? If you are developing the answer is quite simple: it\u2019s on localhost port something and directly on the root of that server. But what if you later decide to move your application to a different location? For example to http://example.com/myapp? On the server side this never was a problem because we were using the handy url_for() function that could answer that question for us, but if we are using jQuery we should not hardcode the path to the application but make that dynamic, so how can we do that? A simple method would be to add a script tag to our page that sets a global variable to the prefix to the root of the application. Something like this: <script type=text/javascript>\n  $SCRIPT_ROOT = {{ request.script_root|tojson }};\n</script>\n JSON View Functions Now let\u2019s create a server side function that accepts two URL arguments of numbers which should be added together and then sent back to the application in a JSON object. This is a really ridiculous example and is something you usually would do on the client side alone, but a simple example that shows how you would use jQuery and Flask nonetheless: from flask import Flask, jsonify, render_template, request\napp = Flask(__name__)\n\n@app.route('/_add_numbers')\ndef add_numbers():\n    a = request.args.get('a', 0, type=int)\n    b = request.args.get('b', 0, type=int)\n    return jsonify(result=a + b)\n\n@app.route('/')\ndef index():\n    return render_template('index.html')\n As you can see I also added an index method here that renders a template. This template will load jQuery as above and have a little form where we can add two numbers and a link to trigger the function on the server side. Note that we are using the get() method here which will never fail. If the key is missing a default value (here 0) is returned. Furthermore it can convert values to a specific type (like in our case int). This is especially handy for code that is triggered by a script (APIs, JavaScript etc.) because you don\u2019t need special error reporting in that case. The HTML Your index.html template either has to extend a layout.html template with jQuery loaded and the $SCRIPT_ROOT variable set, or do that on the top. Here\u2019s the HTML code needed for our little application (index.html). Notice that we also drop the script directly into the HTML here. It is usually a better idea to have that in a separate script file: <script type=text/javascript>\n  $(function() {\n    $('a#calculate').bind('click', function() {\n      $.getJSON($SCRIPT_ROOT + '/_add_numbers', {\n        a: $('input[name=\"a\"]').val(),\n        b: $('input[name=\"b\"]').val()\n      }, function(data) {\n        $(\"#result\").text(data.result);\n      });\n      return false;\n    });\n  });\n</script>\n<h1>jQuery Example</h1>\n<p><input type=text size=5 name=a> +\n   <input type=text size=5 name=b> =\n   <span id=result>?</span>\n<p><a href=# id=calculate>calculate server side</a>\n I won\u2019t go into detail here about how jQuery works, just a very quick explanation of the little bit of code above:  \n$(function() { ... }) specifies code that should run once the browser is done loading the basic parts of the page. \n$('selector') selects an element and lets you operate on it. \nelement.bind('event', func) specifies a function that should run when the user clicked on the element. If that function returns false, the default behavior will not kick in (in this case, navigate to the # URL). \n$.getJSON(url, data, func) sends a GET request to url and will send the contents of the data object as query parameters. Once the data arrived, it will call the given function with the return value as argument. Note that we can use the $SCRIPT_ROOT variable here that we set earlier.  Check out the example source for a full application demonstrating the code on this page, as well as the same thing using XMLHttpRequest and fetch.\n"}, {"name": "AppContext", "path": "api/index#flask.ctx.AppContext", "type": "flask.ctx", "text": " \nclass flask.ctx.AppContext(app)  \nThe application context binds an application object implicitly to the current thread or greenlet, similar to how the RequestContext binds request information. The application context is also implicitly created if a request context is created but the application is not on top of the individual application context.  Parameters \napp (Flask) \u2013   Return type \nNone    \npop(exc=<object object>)  \nPops the app context.  Parameters \nexc (Optional[BaseException]) \u2013   Return type \nNone   \n  \npush()  \nBinds the app context to the current context.  Return type \nNone   \n \n"}, {"name": "AppContext.pop()", "path": "api/index#flask.ctx.AppContext.pop", "type": "flask.ctx", "text": " \npop(exc=<object object>)  \nPops the app context.  Parameters \nexc (Optional[BaseException]) \u2013   Return type \nNone   \n"}, {"name": "AppContext.push()", "path": "api/index#flask.ctx.AppContext.push", "type": "flask.ctx", "text": " \npush()  \nBinds the app context to the current context.  Return type \nNone   \n"}, {"name": "AppGroup", "path": "api/index#flask.cli.AppGroup", "type": "flask.cli", "text": " \nclass flask.cli.AppGroup(name=None, commands=None, **attrs)  \nThis works similar to a regular click Group but it changes the behavior of the command() decorator so that it automatically wraps the functions in with_appcontext(). Not to be confused with FlaskGroup.  Parameters \n \nname (Optional[str]) \u2013  \ncommands (Optional[Union[Dict[str, click.core.Command], Sequence[click.core.Command]]]) \u2013  \nattrs (Any) \u2013    Return type \nNone    \ncommand(*args, **kwargs)  \nThis works exactly like the method of the same name on a regular click.Group but it wraps callbacks in with_appcontext() unless it\u2019s disabled by passing with_appcontext=False. \n  \ngroup(*args, **kwargs)  \nThis works exactly like the method of the same name on a regular click.Group but it defaults the group class to AppGroup. \n \n"}, {"name": "AppGroup.command()", "path": "api/index#flask.cli.AppGroup.command", "type": "flask.cli", "text": " \ncommand(*args, **kwargs)  \nThis works exactly like the method of the same name on a regular click.Group but it wraps callbacks in with_appcontext() unless it\u2019s disabled by passing with_appcontext=False. \n"}, {"name": "AppGroup.group()", "path": "api/index#flask.cli.AppGroup.group", "type": "flask.cli", "text": " \ngroup(*args, **kwargs)  \nThis works exactly like the method of the same name on a regular click.Group but it defaults the group class to AppGroup. \n"}, {"name": "Application Dispatching", "path": "patterns/appdispatch/index", "type": "User's Guide: Design Patterns", "text": "Application Dispatching Application dispatching is the process of combining multiple Flask applications on the WSGI level. You can combine not only Flask applications but any WSGI application. This would allow you to run a Django and a Flask application in the same interpreter side by side if you want. The usefulness of this depends on how the applications work internally. The fundamental difference from Large Applications as Packages is that in this case you are running the same or different Flask applications that are entirely isolated from each other. They run different configurations and are dispatched on the WSGI level. Working with this Document Each of the techniques and examples below results in an application object that can be run with any WSGI server. For production, see Deployment Options. For development, Werkzeug provides a server through werkzeug.serving.run_simple(): from werkzeug.serving import run_simple\nrun_simple('localhost', 5000, application, use_reloader=True)\n Note that run_simple is not intended for use in production. Use a production WSGI server. See Deployment Options. In order to use the interactive debugger, debugging must be enabled both on the application and the simple server. Here is the \u201chello world\u201d example with debugging and run_simple: from flask import Flask\nfrom werkzeug.serving import run_simple\n\napp = Flask(__name__)\napp.debug = True\n\n@app.route('/')\ndef hello_world():\n    return 'Hello World!'\n\nif __name__ == '__main__':\n    run_simple('localhost', 5000, app,\n               use_reloader=True, use_debugger=True, use_evalex=True)\n Combining Applications If you have entirely separated applications and you want them to work next to each other in the same Python interpreter process you can take advantage of the werkzeug.wsgi.DispatcherMiddleware. The idea here is that each Flask application is a valid WSGI application and they are combined by the dispatcher middleware into a larger one that is dispatched based on prefix. For example you could have your main application run on / and your backend interface on /backend: from werkzeug.middleware.dispatcher import DispatcherMiddleware\nfrom frontend_app import application as frontend\nfrom backend_app import application as backend\n\napplication = DispatcherMiddleware(frontend, {\n    '/backend': backend\n})\n Dispatch by Subdomain Sometimes you might want to use multiple instances of the same application with different configurations. Assuming the application is created inside a function and you can call that function to instantiate it, that is really easy to implement. In order to develop your application to support creating new instances in functions have a look at the Application Factories pattern. A very common example would be creating applications per subdomain. For instance you configure your webserver to dispatch all requests for all subdomains to your application and you then use the subdomain information to create user-specific instances. Once you have your server set up to listen on all subdomains you can use a very simple WSGI application to do the dynamic application creation. The perfect level for abstraction in that regard is the WSGI layer. You write your own WSGI application that looks at the request that comes and delegates it to your Flask application. If that application does not exist yet, it is dynamically created and remembered: from threading import Lock\n\nclass SubdomainDispatcher(object):\n\n    def __init__(self, domain, create_app):\n        self.domain = domain\n        self.create_app = create_app\n        self.lock = Lock()\n        self.instances = {}\n\n    def get_application(self, host):\n        host = host.split(':')[0]\n        assert host.endswith(self.domain), 'Configuration error'\n        subdomain = host[:-len(self.domain)].rstrip('.')\n        with self.lock:\n            app = self.instances.get(subdomain)\n            if app is None:\n                app = self.create_app(subdomain)\n                self.instances[subdomain] = app\n            return app\n\n    def __call__(self, environ, start_response):\n        app = self.get_application(environ['HTTP_HOST'])\n        return app(environ, start_response)\n This dispatcher can then be used like this: from myapplication import create_app, get_user_for_subdomain\nfrom werkzeug.exceptions import NotFound\n\ndef make_app(subdomain):\n    user = get_user_for_subdomain(subdomain)\n    if user is None:\n        # if there is no user for that subdomain we still have\n        # to return a WSGI application that handles that request.\n        # We can then just return the NotFound() exception as\n        # application which will render a default 404 page.\n        # You might also redirect the user to the main page then\n        return NotFound()\n\n    # otherwise create the application for the specific user\n    return create_app(user)\n\napplication = SubdomainDispatcher('example.com', make_app)\n Dispatch by Path Dispatching by a path on the URL is very similar. Instead of looking at the Host header to figure out the subdomain one simply looks at the request path up to the first slash: from threading import Lock\nfrom werkzeug.wsgi import pop_path_info, peek_path_info\n\nclass PathDispatcher(object):\n\n    def __init__(self, default_app, create_app):\n        self.default_app = default_app\n        self.create_app = create_app\n        self.lock = Lock()\n        self.instances = {}\n\n    def get_application(self, prefix):\n        with self.lock:\n            app = self.instances.get(prefix)\n            if app is None:\n                app = self.create_app(prefix)\n                if app is not None:\n                    self.instances[prefix] = app\n            return app\n\n    def __call__(self, environ, start_response):\n        app = self.get_application(peek_path_info(environ))\n        if app is not None:\n            pop_path_info(environ)\n        else:\n            app = self.default_app\n        return app(environ, start_response)\n The big difference between this and the subdomain one is that this one falls back to another application if the creator function returns None: from myapplication import create_app, default_app, get_user_for_prefix\n\ndef make_app(prefix):\n    user = get_user_for_prefix(prefix)\n    if user is not None:\n        return create_app(user)\n\napplication = PathDispatcher(default_app, make_app)\n\n"}, {"name": "Application Factories", "path": "patterns/appfactories/index", "type": "User's Guide: Design Patterns", "text": "Application Factories If you are already using packages and blueprints for your application (Modular Applications with Blueprints) there are a couple of really nice ways to further improve the experience. A common pattern is creating the application object when the blueprint is imported. But if you move the creation of this object into a function, you can then create multiple instances of this app later. So why would you want to do this?  Testing. You can have instances of the application with different settings to test every case. Multiple instances. Imagine you want to run different versions of the same application. Of course you could have multiple instances with different configs set up in your webserver, but if you use factories, you can have multiple instances of the same application running in the same application process which can be handy.  So how would you then actually implement that? Basic Factories The idea is to set up the application in a function. Like this: def create_app(config_filename):\n    app = Flask(__name__)\n    app.config.from_pyfile(config_filename)\n\n    from yourapplication.model import db\n    db.init_app(app)\n\n    from yourapplication.views.admin import admin\n    from yourapplication.views.frontend import frontend\n    app.register_blueprint(admin)\n    app.register_blueprint(frontend)\n\n    return app\n The downside is that you cannot use the application object in the blueprints at import time. You can however use it from within a request. How do you get access to the application with the config? Use current_app: from flask import current_app, Blueprint, render_template\nadmin = Blueprint('admin', __name__, url_prefix='/admin')\n\n@admin.route('/')\ndef index():\n    return render_template(current_app.config['INDEX_TEMPLATE'])\n Here we look up the name of a template in the config. Factories & Extensions It\u2019s preferable to create your extensions and app factories so that the extension object does not initially get bound to the application. Using Flask-SQLAlchemy, as an example, you should not do something along those lines: def create_app(config_filename):\n    app = Flask(__name__)\n    app.config.from_pyfile(config_filename)\n\n    db = SQLAlchemy(app)\n But, rather, in model.py (or equivalent): db = SQLAlchemy()\n and in your application.py (or equivalent): def create_app(config_filename):\n    app = Flask(__name__)\n    app.config.from_pyfile(config_filename)\n\n    from yourapplication.model import db\n    db.init_app(app)\n Using this design pattern, no application-specific state is stored on the extension object, so one extension object can be used for multiple apps. For more information about the design of extensions refer to Flask Extension Development. Using Applications To run such an application, you can use the flask command:  \nBashCMDPowershell\n\n\n$ export FLASK_APP=myapp\n$ flask run\n \n\n> set FLASK_APP=myapp\n> flask run\n \n\n> $env:FLASK_APP = \"myapp\"\n> flask run\n \n Flask will automatically detect the factory (create_app or make_app) in myapp. You can also pass arguments to the factory like this:  \nBashCMDPowershell\n\n\n$ export FLASK_APP=\"myapp:create_app('dev')\"\n$ flask run\n \n\n> set FLASK_APP=\"myapp:create_app('dev')\"\n> flask run\n \n\n> $env:FLASK_APP = \"myapp:create_app('dev')\"\n> flask run\n \n Then the create_app factory in myapp is called with the string 'dev' as the argument. See Command Line Interface for more detail. Factory Improvements The factory function above is not very clever, but you can improve it. The following changes are straightforward to implement:  Make it possible to pass in configuration values for unit tests so that you don\u2019t have to create config files on the filesystem. Call a function from a blueprint when the application is setting up so that you have a place to modify attributes of the application (like hooking in before/after request handlers etc.) Add in WSGI middlewares when the application is being created if necessary. \n"}, {"name": "APPLICATION_ROOT", "path": "config/index#APPLICATION_ROOT", "type": "Configuration", "text": " \nAPPLICATION_ROOT  \nInform the application what path it is mounted under by the application / web server. This is used for generating URLs outside the context of a request (inside a request, the dispatcher is responsible for setting SCRIPT_NAME instead; see Application Dispatching for examples of dispatch configuration). Will be used for the session cookie path if SESSION_COOKIE_PATH is not set. Default: '/' \n"}, {"name": "ASGI", "path": "deploying/asgi/index", "type": "User's Guide: Deploying", "text": "ASGI If you\u2019d like to use an ASGI server you will need to utilise WSGI to ASGI middleware. The asgiref [WsgiToAsgi](https://github.com/django/asgiref#wsgi-to-asgi-adapter) adapter is recommended as it integrates with the event loop used for Flask\u2019s Using async and await support. You can use the adapter by wrapping the Flask app, from asgiref.wsgi import WsgiToAsgi\nfrom flask import Flask\n\napp = Flask(__name__)\n\n...\n\nasgi_app = WsgiToAsgi(app)\n and then serving the asgi_app with the asgi server, e.g. using Hypercorn, $ hypercorn module:asgi_app\n\n"}, {"name": "Becoming Big", "path": "becomingbig/index", "type": "User\u2019s Guide", "text": "Becoming Big Here are your options when growing your codebase or scaling your application. Read the Source. Flask started in part to demonstrate how to build your own framework on top of existing well-used tools Werkzeug (WSGI) and Jinja (templating), and as it developed, it became useful to a wide audience. As you grow your codebase, don\u2019t just use Flask \u2013 understand it. Read the source. Flask\u2019s code is written to be read; its documentation is published so you can use its internal APIs. Flask sticks to documented APIs in upstream libraries, and documents its internal utilities so that you can find the hook points needed for your project. Hook. Extend. The API docs are full of available overrides, hook points, and Signals. You can provide custom classes for things like the request and response objects. Dig deeper on the APIs you use, and look for the customizations which are available out of the box in a Flask release. Look for ways in which your project can be refactored into a collection of utilities and Flask extensions. Explore the many Extensions in the community, and look for patterns to build your own extensions if you do not find the tools you need. Subclass. The Flask class has many methods designed for subclassing. You can quickly add or customize behavior by subclassing Flask (see the linked method docs) and using that subclass wherever you instantiate an application class. This works well with Application Factories. See Subclassing Flask for an example. Wrap with middleware. The Application Dispatching pattern shows in detail how to apply middleware. You can introduce WSGI middleware to wrap your Flask instances and introduce fixes and changes at the layer between your Flask application and your HTTP server. Werkzeug includes several middlewares. Fork. If none of the above options work, fork Flask. The majority of code of Flask is within Werkzeug and Jinja2. These libraries do the majority of the work. Flask is just the paste that glues those together. For every project there is the point where the underlying framework gets in the way (due to assumptions the original developers had). This is natural because if this would not be the case, the framework would be a very complex system to begin with which causes a steep learning curve and a lot of user frustration. This is not unique to Flask. Many people use patched and modified versions of their framework to counter shortcomings. This idea is also reflected in the license of Flask. You don\u2019t have to contribute any changes back if you decide to modify the framework. The downside of forking is of course that Flask extensions will most likely break because the new framework has a different import name. Furthermore integrating upstream changes can be a complex process, depending on the number of changes. Because of that, forking should be the very last resort. Scale like a pro. For many web applications the complexity of the code is less an issue than the scaling for the number of users or data entries expected. Flask by itself is only limited in terms of scaling by your application code, the data store you want to use and the Python implementation and webserver you are running on. Scaling well means for example that if you double the amount of servers you get about twice the performance. Scaling bad means that if you add a new server the application won\u2019t perform any better or would not even support a second server. There is only one limiting factor regarding scaling in Flask which are the context local proxies. They depend on context which in Flask is defined as being either a thread, process or greenlet. If your server uses some kind of concurrency that is not based on threads or greenlets, Flask will no longer be able to support these global proxies. However the majority of servers are using either threads, greenlets or separate processes to achieve concurrency which are all methods well supported by the underlying Werkzeug library. Discuss with the community. The Flask developers keep the framework accessible to users with codebases big and small. If you find an obstacle in your way, caused by Flask, don\u2019t hesitate to contact the developers on the mailing list or Discord server. The best way for the Flask and Flask extension developers to improve the tools for larger applications is getting feedback from users.\n"}, {"name": "Blueprint", "path": "api/index#flask.Blueprint", "type": "flask", "text": " \nclass flask.Blueprint(name, import_name, static_folder=None, static_url_path=None, template_folder=None, url_prefix=None, subdomain=None, url_defaults=None, root_path=None, cli_group=<object object>)  \nRepresents a blueprint, a collection of routes and other app-related functions that can be registered on a real application later. A blueprint is an object that allows defining application functions without requiring an application object ahead of time. It uses the same decorators as Flask, but defers the need for an application by recording them for later registration. Decorating a function with a blueprint creates a deferred function that is called with BlueprintSetupState when the blueprint is registered on an application. See Modular Applications with Blueprints for more information.  Parameters \n \nname (str) \u2013 The name of the blueprint. Will be prepended to each endpoint name. \nimport_name (str) \u2013 The name of the blueprint package, usually __name__. This helps locate the root_path for the blueprint. \nstatic_folder (Optional[str]) \u2013 A folder with static files that should be served by the blueprint\u2019s static route. The path is relative to the blueprint\u2019s root path. Blueprint static files are disabled by default. \nstatic_url_path (Optional[str]) \u2013 The url to serve static files from. Defaults to static_folder. If the blueprint does not have a url_prefix, the app\u2019s static route will take precedence, and the blueprint\u2019s static files won\u2019t be accessible. \ntemplate_folder (Optional[str]) \u2013 A folder with templates that should be added to the app\u2019s template search path. The path is relative to the blueprint\u2019s root path. Blueprint templates are disabled by default. Blueprint templates have a lower precedence than those in the app\u2019s templates folder. \nurl_prefix (Optional[str]) \u2013 A path to prepend to all of the blueprint\u2019s URLs, to make them distinct from the rest of the app\u2019s routes. \nsubdomain (Optional[str]) \u2013 A subdomain that blueprint routes will match on by default. \nurl_defaults (Optional[dict]) \u2013 A dict of default values that blueprint routes will receive by default. \nroot_path (Optional[str]) \u2013 By default, the blueprint will automatically set this based on import_name. In certain situations this automatic detection can fail, so the path can be specified manually instead. \ncli_group (Optional[str]) \u2013      Changelog Changed in version 1.1.0: Blueprints have a cli group to register nested CLI commands. The cli_group parameter controls the name of the group under the flask command.   New in version 0.7.   \nadd_app_template_filter(f, name=None)  \nRegister a custom template filter, available application wide. Like Flask.add_template_filter() but for a blueprint. Works exactly like the app_template_filter() decorator.  Parameters \n \nname (Optional[str]) \u2013 the optional name of the filter, otherwise the function name will be used. \nf (Callable[[Any], str]) \u2013    Return type \nNone   \n  \nadd_app_template_global(f, name=None)  \nRegister a custom template global, available application wide. Like Flask.add_template_global() but for a blueprint. Works exactly like the app_template_global() decorator.  Changelog New in version 0.10.   Parameters \n \nname (Optional[str]) \u2013 the optional name of the global, otherwise the function name will be used. \nf (Callable[[], Any]) \u2013    Return type \nNone   \n  \nadd_app_template_test(f, name=None)  \nRegister a custom template test, available application wide. Like Flask.add_template_test() but for a blueprint. Works exactly like the app_template_test() decorator.  Changelog New in version 0.10.   Parameters \n \nname (Optional[str]) \u2013 the optional name of the test, otherwise the function name will be used. \nf (Callable[[Any], bool]) \u2013    Return type \nNone   \n  \nadd_url_rule(rule, endpoint=None, view_func=None, **options)  \nLike Flask.add_url_rule() but for a blueprint. The endpoint for the url_for() function is prefixed with the name of the blueprint.  Parameters \n \nrule (str) \u2013  \nendpoint (Optional[str]) \u2013  \nview_func (Optional[Callable]) \u2013  \noptions (Any) \u2013    Return type \nNone   \n  \nafter_app_request(f)  \nLike Flask.after_request() but for a blueprint. Such a function is executed after each request, even if outside of the blueprint.  Parameters \nf (Callable[[Response], Response]) \u2013   Return type \nCallable[[Response], Response]   \n  \nafter_request(f)  \nRegister a function to run after each request to this object. The function is called with the response object, and must return a response object. This allows the functions to modify or replace the response before it is sent. If a function raises an exception, any remaining after_request functions will not be called. Therefore, this should not be used for actions that must execute, such as to close resources. Use teardown_request() for that.  Parameters \nf (Callable[[Response], Response]) \u2013   Return type \nCallable[[Response], Response]   \n  \nafter_request_funcs: t.Dict[AppOrBlueprintKey, t.List[AfterRequestCallable]]  \nA data structure of functions to call at the end of each request, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests. To register a function, use the after_request() decorator. This data structure is internal. It should not be modified directly and its format may change at any time. \n  \napp_context_processor(f)  \nLike Flask.context_processor() but for a blueprint. Such a function is executed each request, even if outside of the blueprint.  Parameters \nf (Callable[[], Dict[str, Any]]) \u2013   Return type \nCallable[[], Dict[str, Any]]   \n  \napp_errorhandler(code)  \nLike Flask.errorhandler() but for a blueprint. This handler is used for all requests, even if outside of the blueprint.  Parameters \ncode (Union[Type[Exception], int]) \u2013   Return type \nCallable   \n  \napp_template_filter(name=None)  \nRegister a custom template filter, available application wide. Like Flask.template_filter() but for a blueprint.  Parameters \nname (Optional[str]) \u2013 the optional name of the filter, otherwise the function name will be used.  Return type \nCallable   \n  \napp_template_global(name=None)  \nRegister a custom template global, available application wide. Like Flask.template_global() but for a blueprint.  Changelog New in version 0.10.   Parameters \nname (Optional[str]) \u2013 the optional name of the global, otherwise the function name will be used.  Return type \nCallable   \n  \napp_template_test(name=None)  \nRegister a custom template test, available application wide. Like Flask.template_test() but for a blueprint.  Changelog New in version 0.10.   Parameters \nname (Optional[str]) \u2013 the optional name of the test, otherwise the function name will be used.  Return type \nCallable   \n  \napp_url_defaults(f)  \nSame as url_defaults() but application wide.  Parameters \nf (Callable[[str, dict], None]) \u2013   Return type \nCallable[[str, dict], None]   \n  \napp_url_value_preprocessor(f)  \nSame as url_value_preprocessor() but application wide.  Parameters \nf (Callable[[Optional[str], Optional[dict]], None]) \u2013   Return type \nCallable[[Optional[str], Optional[dict]], None]   \n  \nbefore_app_first_request(f)  \nLike Flask.before_first_request(). Such a function is executed before the first request to the application.  Parameters \nf (Callable[[], None]) \u2013   Return type \nCallable[[], None]   \n  \nbefore_app_request(f)  \nLike Flask.before_request(). Such a function is executed before each request, even if outside of a blueprint.  Parameters \nf (Callable[[], None]) \u2013   Return type \nCallable[[], None]   \n  \nbefore_request(f)  \nRegister a function to run before each request. For example, this can be used to open a database connection, or to load the logged in user from the session. @app.before_request\ndef load_user():\n    if \"user_id\" in session:\n        g.user = db.session.get(session[\"user_id\"])\n The function will be called without any arguments. If it returns a non-None value, the value is handled as if it was the return value from the view, and further request handling is stopped.  Parameters \nf (Callable[[], None]) \u2013   Return type \nCallable[[], None]   \n  \nbefore_request_funcs: t.Dict[AppOrBlueprintKey, t.List[BeforeRequestCallable]]  \nA data structure of functions to call at the beginning of each request, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests. To register a function, use the before_request() decorator. This data structure is internal. It should not be modified directly and its format may change at any time. \n  \ncli  \nThe Click command group for registering CLI commands for this object. The commands are available from the flask command once the application has been discovered and blueprints have been registered. \n  \ncontext_processor(f)  \nRegisters a template context processor function.  Parameters \nf (Callable[[], Dict[str, Any]]) \u2013   Return type \nCallable[[], Dict[str, Any]]   \n  \ndelete(rule, **options)  \nShortcut for route() with methods=[\"DELETE\"].  New in version 2.0.   Parameters \n \nrule (str) \u2013  \noptions (Any) \u2013    Return type \nCallable   \n  \nendpoint(endpoint)  \nDecorate a view function to register it for the given endpoint. Used if a rule is added without a view_func with add_url_rule(). app.add_url_rule(\"/ex\", endpoint=\"example\")\n\n@app.endpoint(\"example\")\ndef example():\n    ...\n  Parameters \nendpoint (str) \u2013 The endpoint name to associate with the view function.  Return type \nCallable   \n  \nerror_handler_spec: t.Dict[AppOrBlueprintKey, t.Dict[t.Optional[int], t.Dict[t.Type[Exception], ErrorHandlerCallable]]]  \nA data structure of registered error handlers, in the format {scope: {code: {class: handler}}}`. The scope key is the name of a blueprint the handlers are active for, or None for all requests. The code key is the HTTP status code for HTTPException, or None for other exceptions. The innermost dictionary maps exception classes to handler functions. To register an error handler, use the errorhandler() decorator. This data structure is internal. It should not be modified directly and its format may change at any time. \n  \nerrorhandler(code_or_exception)  \nRegister a function to handle errors by code or exception class. A decorator that is used to register a function given an error code. Example: @app.errorhandler(404)\ndef page_not_found(error):\n    return 'This page does not exist', 404\n You can also register handlers for arbitrary exceptions: @app.errorhandler(DatabaseError)\ndef special_exception_handler(error):\n    return 'Database connection failed', 500\n  Changelog New in version 0.7: Use register_error_handler() instead of modifying error_handler_spec directly, for application wide error handlers.   New in version 0.7: One can now additionally also register custom exception types that do not necessarily have to be a subclass of the HTTPException class.   Parameters \ncode_or_exception (Union[Type[Exception], int]) \u2013 the code as integer for the handler, or an arbitrary exception  Return type \nCallable   \n  \nget(rule, **options)  \nShortcut for route() with methods=[\"GET\"].  New in version 2.0.   Parameters \n \nrule (str) \u2013  \noptions (Any) \u2013    Return type \nCallable   \n  \nget_send_file_max_age(filename)  \nUsed by send_file() to determine the max_age cache value for a given file path if it wasn\u2019t passed. By default, this returns SEND_FILE_MAX_AGE_DEFAULT from the configuration of current_app. This defaults to None, which tells the browser to use conditional requests instead of a timed cache, which is usually preferable.  Changed in version 2.0: The default configuration is None instead of 12 hours.   Changelog New in version 0.9.   Parameters \nfilename (str) \u2013   Return type \nOptional[int]   \n  \nproperty has_static_folder: bool  \nTrue if static_folder is set.  Changelog New in version 0.5.  \n\n  \nimport_name  \nThe name of the package or module that this object belongs to. Do not change this once it is set by the constructor. \n  \nproperty jinja_loader: Optional[jinja2.loaders.FileSystemLoader]  \nThe Jinja loader for this object\u2019s templates. By default this is a class jinja2.loaders.FileSystemLoader to template_folder if it is set.  Changelog New in version 0.5.  \n\n  \njson_decoder: Optional[Type[json.decoder.JSONDecoder]] = None  \nBlueprint local JSON decoder class to use. Set to None to use the app\u2019s json_decoder. \n  \njson_encoder: Optional[Type[json.encoder.JSONEncoder]] = None  \nBlueprint local JSON encoder class to use. Set to None to use the app\u2019s json_encoder. \n  \nmake_setup_state(app, options, first_registration=False)  \nCreates an instance of BlueprintSetupState() object that is later passed to the register callback functions. Subclasses can override this to return a subclass of the setup state.  Parameters \n \napp (Flask) \u2013  \noptions (dict) \u2013  \nfirst_registration (bool) \u2013    Return type \nflask.blueprints.BlueprintSetupState   \n  \nopen_resource(resource, mode='rb')  \nOpen a resource file relative to root_path for reading. For example, if the file schema.sql is next to the file app.py where the Flask app is defined, it can be opened with: with app.open_resource(\"schema.sql\") as f:\n    conn.executescript(f.read())\n  Parameters \n \nresource (str) \u2013 Path to the resource relative to root_path. \nmode (str) \u2013 Open the file in this mode. Only reading is supported, valid values are \u201cr\u201d (or \u201crt\u201d) and \u201crb\u201d.   Return type \nIO   \n  \npatch(rule, **options)  \nShortcut for route() with methods=[\"PATCH\"].  New in version 2.0.   Parameters \n \nrule (str) \u2013  \noptions (Any) \u2013    Return type \nCallable   \n  \npost(rule, **options)  \nShortcut for route() with methods=[\"POST\"].  New in version 2.0.   Parameters \n \nrule (str) \u2013  \noptions (Any) \u2013    Return type \nCallable   \n  \nput(rule, **options)  \nShortcut for route() with methods=[\"PUT\"].  New in version 2.0.   Parameters \n \nrule (str) \u2013  \noptions (Any) \u2013    Return type \nCallable   \n  \nrecord(func)  \nRegisters a function that is called when the blueprint is registered on the application. This function is called with the state as argument as returned by the make_setup_state() method.  Parameters \nfunc (Callable) \u2013   Return type \nNone   \n  \nrecord_once(func)  \nWorks like record() but wraps the function in another function that will ensure the function is only called once. If the blueprint is registered a second time on the application, the function passed is not called.  Parameters \nfunc (Callable) \u2013   Return type \nNone   \n  \nregister(app, options)  \nCalled by Flask.register_blueprint() to register all views and callbacks registered on the blueprint with the application. Creates a BlueprintSetupState and calls each record() callbackwith it.  Parameters \n \napp (Flask) \u2013 The application this blueprint is being registered with. \noptions (dict) \u2013 Keyword arguments forwarded from register_blueprint(). \nfirst_registration \u2013 Whether this is the first time this blueprint has been registered on the application.   Return type \nNone   \n  \nregister_blueprint(blueprint, **options)  \nRegister a Blueprint on this blueprint. Keyword arguments passed to this method will override the defaults set on the blueprint.  New in version 2.0.   Parameters \n \nblueprint (flask.blueprints.Blueprint) \u2013  \noptions (Any) \u2013    Return type \nNone   \n  \nregister_error_handler(code_or_exception, f)  \nAlternative error attach function to the errorhandler() decorator that is more straightforward to use for non decorator usage.  Changelog New in version 0.7.   Parameters \n \ncode_or_exception (Union[Type[Exception], int]) \u2013  \nf (Callable[[Exception], Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], Union[Headers, Dict[str, Union[str, List[str], Tuple[str, ...]]], List[Tuple[str, Union[str, List[str], Tuple[str, ...]]]]]], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, ...]]], List[Tuple[str, Union[str, List[str], Tuple[str, ...]]]]]], WSGIApplication]]) \u2013    Return type \nNone   \n  \nroot_path  \nAbsolute path to the package on the filesystem. Used to look up resources contained in the package. \n  \nroute(rule, **options)  \nDecorate a view function to register it with the given URL rule and options. Calls add_url_rule(), which has more details about the implementation. @app.route(\"/\")\ndef index():\n    return \"Hello, World!\"\n See URL Route Registrations. The endpoint name for the route defaults to the name of the view function if the endpoint parameter isn\u2019t passed. The methods parameter defaults to [\"GET\"]. HEAD and OPTIONS are added automatically.  Parameters \n \nrule (str) \u2013 The URL rule string. \noptions (Any) \u2013 Extra options passed to the Rule object.   Return type \nCallable   \n  \nsend_static_file(filename)  \nThe view function used to serve files from static_folder. A route is automatically registered for this view at static_url_path if static_folder is set.  Changelog New in version 0.5.   Parameters \nfilename (str) \u2013   Return type \nResponse   \n  \nproperty static_folder: Optional[str]  \nThe absolute path to the configured static folder. None if no static folder is set. \n  \nproperty static_url_path: Optional[str]  \nThe URL prefix that the static route will be accessible from. If it was not configured during init, it is derived from static_folder. \n  \nteardown_app_request(f)  \nLike Flask.teardown_request() but for a blueprint. Such a function is executed when tearing down each request, even if outside of the blueprint.  Parameters \nf (Callable[[Optional[BaseException]], Response]) \u2013   Return type \nCallable[[Optional[BaseException]], Response]   \n  \nteardown_request(f)  \nRegister a function to be run at the end of each request, regardless of whether there was an exception or not. These functions are executed when the request context is popped, even if not an actual request was performed. Example: ctx = app.test_request_context()\nctx.push()\n...\nctx.pop()\n When ctx.pop() is executed in the above example, the teardown functions are called just before the request context moves from the stack of active contexts. This becomes relevant if you are using such constructs in tests. Teardown functions must avoid raising exceptions, since they . If they execute code that might fail they will have to surround the execution of these code by try/except statements and log occurring errors. When a teardown function was called because of an exception it will be passed an error object. The return values of teardown functions are ignored.  Debug Note In debug mode Flask will not tear down a request on an exception immediately. Instead it will keep it alive so that the interactive debugger can still access it. This behavior can be controlled by the PRESERVE_CONTEXT_ON_EXCEPTION configuration variable.   Parameters \nf (Callable[[Optional[BaseException]], Response]) \u2013   Return type \nCallable[[Optional[BaseException]], Response]   \n  \nteardown_request_funcs: t.Dict[AppOrBlueprintKey, t.List[TeardownCallable]]  \nA data structure of functions to call at the end of each request even if an exception is raised, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests. To register a function, use the teardown_request() decorator. This data structure is internal. It should not be modified directly and its format may change at any time. \n  \ntemplate_context_processors: t.Dict[AppOrBlueprintKey, t.List[TemplateContextProcessorCallable]]  \nA data structure of functions to call to pass extra context values when rendering templates, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests. To register a function, use the context_processor() decorator. This data structure is internal. It should not be modified directly and its format may change at any time. \n  \ntemplate_folder  \nThe path to the templates folder, relative to root_path, to add to the template loader. None if templates should not be added. \n  \nurl_default_functions: t.Dict[AppOrBlueprintKey, t.List[URLDefaultCallable]]  \nA data structure of functions to call to modify the keyword arguments when generating URLs, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests. To register a function, use the url_defaults() decorator. This data structure is internal. It should not be modified directly and its format may change at any time. \n  \nurl_defaults(f)  \nCallback function for URL defaults for all view functions of the application. It\u2019s called with the endpoint and values and should update the values passed in place.  Parameters \nf (Callable[[str, dict], None]) \u2013   Return type \nCallable[[str, dict], None]   \n  \nurl_value_preprocessor(f)  \nRegister a URL value preprocessor function for all view functions in the application. These functions will be called before the before_request() functions. The function can modify the values captured from the matched url before they are passed to the view. For example, this can be used to pop a common language code value and place it in g rather than pass it to every view. The function is passed the endpoint name and values dict. The return value is ignored.  Parameters \nf (Callable[[Optional[str], Optional[dict]], None]) \u2013   Return type \nCallable[[Optional[str], Optional[dict]], None]   \n  \nurl_value_preprocessors: t.Dict[AppOrBlueprintKey, t.List[URLValuePreprocessorCallable]]  \nA data structure of functions to call to modify the keyword arguments passed to the view function, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests. To register a function, use the url_value_preprocessor() decorator. This data structure is internal. It should not be modified directly and its format may change at any time. \n  \nview_functions: t.Dict[str, t.Callable]  \nA dictionary mapping endpoint names to view functions. To register a view function, use the route() decorator. This data structure is internal. It should not be modified directly and its format may change at any time. \n \n"}, {"name": "Blueprint.add_app_template_filter()", "path": "api/index#flask.Blueprint.add_app_template_filter", "type": "flask", "text": " \nadd_app_template_filter(f, name=None)  \nRegister a custom template filter, available application wide. Like Flask.add_template_filter() but for a blueprint. Works exactly like the app_template_filter() decorator.  Parameters \n \nname (Optional[str]) \u2013 the optional name of the filter, otherwise the function name will be used. \nf (Callable[[Any], str]) \u2013    Return type \nNone   \n"}, {"name": "Blueprint.add_app_template_global()", "path": "api/index#flask.Blueprint.add_app_template_global", "type": "flask", "text": " \nadd_app_template_global(f, name=None)  \nRegister a custom template global, available application wide. Like Flask.add_template_global() but for a blueprint. Works exactly like the app_template_global() decorator.  Changelog New in version 0.10.   Parameters \n \nname (Optional[str]) \u2013 the optional name of the global, otherwise the function name will be used. \nf (Callable[[], Any]) \u2013    Return type \nNone   \n"}, {"name": "Blueprint.add_app_template_test()", "path": "api/index#flask.Blueprint.add_app_template_test", "type": "flask", "text": " \nadd_app_template_test(f, name=None)  \nRegister a custom template test, available application wide. Like Flask.add_template_test() but for a blueprint. Works exactly like the app_template_test() decorator.  Changelog New in version 0.10.   Parameters \n \nname (Optional[str]) \u2013 the optional name of the test, otherwise the function name will be used. \nf (Callable[[Any], bool]) \u2013    Return type \nNone   \n"}, {"name": "Blueprint.add_url_rule()", "path": "api/index#flask.Blueprint.add_url_rule", "type": "flask", "text": " \nadd_url_rule(rule, endpoint=None, view_func=None, **options)  \nLike Flask.add_url_rule() but for a blueprint. The endpoint for the url_for() function is prefixed with the name of the blueprint.  Parameters \n \nrule (str) \u2013  \nendpoint (Optional[str]) \u2013  \nview_func (Optional[Callable]) \u2013  \noptions (Any) \u2013    Return type \nNone   \n"}, {"name": "Blueprint.after_app_request()", "path": "api/index#flask.Blueprint.after_app_request", "type": "flask", "text": " \nafter_app_request(f)  \nLike Flask.after_request() but for a blueprint. Such a function is executed after each request, even if outside of the blueprint.  Parameters \nf (Callable[[Response], Response]) \u2013   Return type \nCallable[[Response], Response]   \n"}, {"name": "Blueprint.after_request()", "path": "api/index#flask.Blueprint.after_request", "type": "flask", "text": " \nafter_request(f)  \nRegister a function to run after each request to this object. The function is called with the response object, and must return a response object. This allows the functions to modify or replace the response before it is sent. If a function raises an exception, any remaining after_request functions will not be called. Therefore, this should not be used for actions that must execute, such as to close resources. Use teardown_request() for that.  Parameters \nf (Callable[[Response], Response]) \u2013   Return type \nCallable[[Response], Response]   \n"}, {"name": "Blueprint.after_request_funcs", "path": "api/index#flask.Blueprint.after_request_funcs", "type": "flask", "text": " \nafter_request_funcs: t.Dict[AppOrBlueprintKey, t.List[AfterRequestCallable]]  \nA data structure of functions to call at the end of each request, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests. To register a function, use the after_request() decorator. This data structure is internal. It should not be modified directly and its format may change at any time. \n"}, {"name": "Blueprint.app_context_processor()", "path": "api/index#flask.Blueprint.app_context_processor", "type": "flask", "text": " \napp_context_processor(f)  \nLike Flask.context_processor() but for a blueprint. Such a function is executed each request, even if outside of the blueprint.  Parameters \nf (Callable[[], Dict[str, Any]]) \u2013   Return type \nCallable[[], Dict[str, Any]]   \n"}, {"name": "Blueprint.app_errorhandler()", "path": "api/index#flask.Blueprint.app_errorhandler", "type": "flask", "text": " \napp_errorhandler(code)  \nLike Flask.errorhandler() but for a blueprint. This handler is used for all requests, even if outside of the blueprint.  Parameters \ncode (Union[Type[Exception], int]) \u2013   Return type \nCallable   \n"}, {"name": "Blueprint.app_template_filter()", "path": "api/index#flask.Blueprint.app_template_filter", "type": "flask", "text": " \napp_template_filter(name=None)  \nRegister a custom template filter, available application wide. Like Flask.template_filter() but for a blueprint.  Parameters \nname (Optional[str]) \u2013 the optional name of the filter, otherwise the function name will be used.  Return type \nCallable   \n"}, {"name": "Blueprint.app_template_global()", "path": "api/index#flask.Blueprint.app_template_global", "type": "flask", "text": " \napp_template_global(name=None)  \nRegister a custom template global, available application wide. Like Flask.template_global() but for a blueprint.  Changelog New in version 0.10.   Parameters \nname (Optional[str]) \u2013 the optional name of the global, otherwise the function name will be used.  Return type \nCallable   \n"}, {"name": "Blueprint.app_template_test()", "path": "api/index#flask.Blueprint.app_template_test", "type": "flask", "text": " \napp_template_test(name=None)  \nRegister a custom template test, available application wide. Like Flask.template_test() but for a blueprint.  Changelog New in version 0.10.   Parameters \nname (Optional[str]) \u2013 the optional name of the test, otherwise the function name will be used.  Return type \nCallable   \n"}, {"name": "Blueprint.app_url_defaults()", "path": "api/index#flask.Blueprint.app_url_defaults", "type": "flask", "text": " \napp_url_defaults(f)  \nSame as url_defaults() but application wide.  Parameters \nf (Callable[[str, dict], None]) \u2013   Return type \nCallable[[str, dict], None]   \n"}, {"name": "Blueprint.app_url_value_preprocessor()", "path": "api/index#flask.Blueprint.app_url_value_preprocessor", "type": "flask", "text": " \napp_url_value_preprocessor(f)  \nSame as url_value_preprocessor() but application wide.  Parameters \nf (Callable[[Optional[str], Optional[dict]], None]) \u2013   Return type \nCallable[[Optional[str], Optional[dict]], None]   \n"}, {"name": "Blueprint.before_app_first_request()", "path": "api/index#flask.Blueprint.before_app_first_request", "type": "flask", "text": " \nbefore_app_first_request(f)  \nLike Flask.before_first_request(). Such a function is executed before the first request to the application.  Parameters \nf (Callable[[], None]) \u2013   Return type \nCallable[[], None]   \n"}, {"name": "Blueprint.before_app_request()", "path": "api/index#flask.Blueprint.before_app_request", "type": "flask", "text": " \nbefore_app_request(f)  \nLike Flask.before_request(). Such a function is executed before each request, even if outside of a blueprint.  Parameters \nf (Callable[[], None]) \u2013   Return type \nCallable[[], None]   \n"}, {"name": "Blueprint.before_request()", "path": "api/index#flask.Blueprint.before_request", "type": "flask", "text": " \nbefore_request(f)  \nRegister a function to run before each request. For example, this can be used to open a database connection, or to load the logged in user from the session. @app.before_request\ndef load_user():\n    if \"user_id\" in session:\n        g.user = db.session.get(session[\"user_id\"])\n The function will be called without any arguments. If it returns a non-None value, the value is handled as if it was the return value from the view, and further request handling is stopped.  Parameters \nf (Callable[[], None]) \u2013   Return type \nCallable[[], None]   \n"}, {"name": "Blueprint.before_request_funcs", "path": "api/index#flask.Blueprint.before_request_funcs", "type": "flask", "text": " \nbefore_request_funcs: t.Dict[AppOrBlueprintKey, t.List[BeforeRequestCallable]]  \nA data structure of functions to call at the beginning of each request, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests. To register a function, use the before_request() decorator. This data structure is internal. It should not be modified directly and its format may change at any time. \n"}, {"name": "Blueprint.cli", "path": "api/index#flask.Blueprint.cli", "type": "flask", "text": " \ncli  \nThe Click command group for registering CLI commands for this object. The commands are available from the flask command once the application has been discovered and blueprints have been registered. \n"}, {"name": "Blueprint.context_processor()", "path": "api/index#flask.Blueprint.context_processor", "type": "flask", "text": " \ncontext_processor(f)  \nRegisters a template context processor function.  Parameters \nf (Callable[[], Dict[str, Any]]) \u2013   Return type \nCallable[[], Dict[str, Any]]   \n"}, {"name": "Blueprint.delete()", "path": "api/index#flask.Blueprint.delete", "type": "flask", "text": " \ndelete(rule, **options)  \nShortcut for route() with methods=[\"DELETE\"].  New in version 2.0.   Parameters \n \nrule (str) \u2013  \noptions (Any) \u2013    Return type \nCallable   \n"}, {"name": "Blueprint.endpoint()", "path": "api/index#flask.Blueprint.endpoint", "type": "flask", "text": " \nendpoint(endpoint)  \nDecorate a view function to register it for the given endpoint. Used if a rule is added without a view_func with add_url_rule(). app.add_url_rule(\"/ex\", endpoint=\"example\")\n\n@app.endpoint(\"example\")\ndef example():\n    ...\n  Parameters \nendpoint (str) \u2013 The endpoint name to associate with the view function.  Return type \nCallable   \n"}, {"name": "Blueprint.errorhandler()", "path": "api/index#flask.Blueprint.errorhandler", "type": "flask", "text": " \nerrorhandler(code_or_exception)  \nRegister a function to handle errors by code or exception class. A decorator that is used to register a function given an error code. Example: @app.errorhandler(404)\ndef page_not_found(error):\n    return 'This page does not exist', 404\n You can also register handlers for arbitrary exceptions: @app.errorhandler(DatabaseError)\ndef special_exception_handler(error):\n    return 'Database connection failed', 500\n  Changelog New in version 0.7: Use register_error_handler() instead of modifying error_handler_spec directly, for application wide error handlers.   New in version 0.7: One can now additionally also register custom exception types that do not necessarily have to be a subclass of the HTTPException class.   Parameters \ncode_or_exception (Union[Type[Exception], int]) \u2013 the code as integer for the handler, or an arbitrary exception  Return type \nCallable   \n"}, {"name": "Blueprint.error_handler_spec", "path": "api/index#flask.Blueprint.error_handler_spec", "type": "flask", "text": " \nerror_handler_spec: t.Dict[AppOrBlueprintKey, t.Dict[t.Optional[int], t.Dict[t.Type[Exception], ErrorHandlerCallable]]]  \nA data structure of registered error handlers, in the format {scope: {code: {class: handler}}}`. The scope key is the name of a blueprint the handlers are active for, or None for all requests. The code key is the HTTP status code for HTTPException, or None for other exceptions. The innermost dictionary maps exception classes to handler functions. To register an error handler, use the errorhandler() decorator. This data structure is internal. It should not be modified directly and its format may change at any time. \n"}, {"name": "Blueprint.get()", "path": "api/index#flask.Blueprint.get", "type": "flask", "text": " \nget(rule, **options)  \nShortcut for route() with methods=[\"GET\"].  New in version 2.0.   Parameters \n \nrule (str) \u2013  \noptions (Any) \u2013    Return type \nCallable   \n"}, {"name": "Blueprint.get_send_file_max_age()", "path": "api/index#flask.Blueprint.get_send_file_max_age", "type": "flask", "text": " \nget_send_file_max_age(filename)  \nUsed by send_file() to determine the max_age cache value for a given file path if it wasn\u2019t passed. By default, this returns SEND_FILE_MAX_AGE_DEFAULT from the configuration of current_app. This defaults to None, which tells the browser to use conditional requests instead of a timed cache, which is usually preferable.  Changed in version 2.0: The default configuration is None instead of 12 hours.   Changelog New in version 0.9.   Parameters \nfilename (str) \u2013   Return type \nOptional[int]   \n"}, {"name": "Blueprint.import_name", "path": "api/index#flask.Blueprint.import_name", "type": "flask", "text": " \nimport_name  \nThe name of the package or module that this object belongs to. Do not change this once it is set by the constructor. \n"}, {"name": "Blueprint.json_decoder", "path": "api/index#flask.Blueprint.json_decoder", "type": "flask", "text": " \njson_decoder: Optional[Type[json.decoder.JSONDecoder]] = None  \nBlueprint local JSON decoder class to use. Set to None to use the app\u2019s json_decoder. \n"}, {"name": "Blueprint.json_encoder", "path": "api/index#flask.Blueprint.json_encoder", "type": "flask", "text": " \njson_encoder: Optional[Type[json.encoder.JSONEncoder]] = None  \nBlueprint local JSON encoder class to use. Set to None to use the app\u2019s json_encoder. \n"}, {"name": "Blueprint.make_setup_state()", "path": "api/index#flask.Blueprint.make_setup_state", "type": "flask", "text": " \nmake_setup_state(app, options, first_registration=False)  \nCreates an instance of BlueprintSetupState() object that is later passed to the register callback functions. Subclasses can override this to return a subclass of the setup state.  Parameters \n \napp (Flask) \u2013  \noptions (dict) \u2013  \nfirst_registration (bool) \u2013    Return type \nflask.blueprints.BlueprintSetupState   \n"}, {"name": "Blueprint.open_resource()", "path": "api/index#flask.Blueprint.open_resource", "type": "flask", "text": " \nopen_resource(resource, mode='rb')  \nOpen a resource file relative to root_path for reading. For example, if the file schema.sql is next to the file app.py where the Flask app is defined, it can be opened with: with app.open_resource(\"schema.sql\") as f:\n    conn.executescript(f.read())\n  Parameters \n \nresource (str) \u2013 Path to the resource relative to root_path. \nmode (str) \u2013 Open the file in this mode. Only reading is supported, valid values are \u201cr\u201d (or \u201crt\u201d) and \u201crb\u201d.   Return type \nIO   \n"}, {"name": "Blueprint.patch()", "path": "api/index#flask.Blueprint.patch", "type": "flask", "text": " \npatch(rule, **options)  \nShortcut for route() with methods=[\"PATCH\"].  New in version 2.0.   Parameters \n \nrule (str) \u2013  \noptions (Any) \u2013    Return type \nCallable   \n"}, {"name": "Blueprint.post()", "path": "api/index#flask.Blueprint.post", "type": "flask", "text": " \npost(rule, **options)  \nShortcut for route() with methods=[\"POST\"].  New in version 2.0.   Parameters \n \nrule (str) \u2013  \noptions (Any) \u2013    Return type \nCallable   \n"}, {"name": "Blueprint.put()", "path": "api/index#flask.Blueprint.put", "type": "flask", "text": " \nput(rule, **options)  \nShortcut for route() with methods=[\"PUT\"].  New in version 2.0.   Parameters \n \nrule (str) \u2013  \noptions (Any) \u2013    Return type \nCallable   \n"}, {"name": "Blueprint.record()", "path": "api/index#flask.Blueprint.record", "type": "flask", "text": " \nrecord(func)  \nRegisters a function that is called when the blueprint is registered on the application. This function is called with the state as argument as returned by the make_setup_state() method.  Parameters \nfunc (Callable) \u2013   Return type \nNone   \n"}, {"name": "Blueprint.record_once()", "path": "api/index#flask.Blueprint.record_once", "type": "flask", "text": " \nrecord_once(func)  \nWorks like record() but wraps the function in another function that will ensure the function is only called once. If the blueprint is registered a second time on the application, the function passed is not called.  Parameters \nfunc (Callable) \u2013   Return type \nNone   \n"}, {"name": "Blueprint.register()", "path": "api/index#flask.Blueprint.register", "type": "flask", "text": " \nregister(app, options)  \nCalled by Flask.register_blueprint() to register all views and callbacks registered on the blueprint with the application. Creates a BlueprintSetupState and calls each record() callbackwith it.  Parameters \n \napp (Flask) \u2013 The application this blueprint is being registered with. \noptions (dict) \u2013 Keyword arguments forwarded from register_blueprint(). \nfirst_registration \u2013 Whether this is the first time this blueprint has been registered on the application.   Return type \nNone   \n"}, {"name": "Blueprint.register_blueprint()", "path": "api/index#flask.Blueprint.register_blueprint", "type": "flask", "text": " \nregister_blueprint(blueprint, **options)  \nRegister a Blueprint on this blueprint. Keyword arguments passed to this method will override the defaults set on the blueprint.  New in version 2.0.   Parameters \n \nblueprint (flask.blueprints.Blueprint) \u2013  \noptions (Any) \u2013    Return type \nNone   \n"}, {"name": "Blueprint.register_error_handler()", "path": "api/index#flask.Blueprint.register_error_handler", "type": "flask", "text": " \nregister_error_handler(code_or_exception, f)  \nAlternative error attach function to the errorhandler() decorator that is more straightforward to use for non decorator usage.  Changelog New in version 0.7.   Parameters \n \ncode_or_exception (Union[Type[Exception], int]) \u2013  \nf (Callable[[Exception], Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], Union[Headers, Dict[str, Union[str, List[str], Tuple[str, ...]]], List[Tuple[str, Union[str, List[str], Tuple[str, ...]]]]]], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, ...]]], List[Tuple[str, Union[str, List[str], Tuple[str, ...]]]]]], WSGIApplication]]) \u2013    Return type \nNone   \n"}, {"name": "Blueprint.root_path", "path": "api/index#flask.Blueprint.root_path", "type": "flask", "text": " \nroot_path  \nAbsolute path to the package on the filesystem. Used to look up resources contained in the package. \n"}, {"name": "Blueprint.route()", "path": "api/index#flask.Blueprint.route", "type": "flask", "text": " \nroute(rule, **options)  \nDecorate a view function to register it with the given URL rule and options. Calls add_url_rule(), which has more details about the implementation. @app.route(\"/\")\ndef index():\n    return \"Hello, World!\"\n See URL Route Registrations. The endpoint name for the route defaults to the name of the view function if the endpoint parameter isn\u2019t passed. The methods parameter defaults to [\"GET\"]. HEAD and OPTIONS are added automatically.  Parameters \n \nrule (str) \u2013 The URL rule string. \noptions (Any) \u2013 Extra options passed to the Rule object.   Return type \nCallable   \n"}, {"name": "Blueprint.send_static_file()", "path": "api/index#flask.Blueprint.send_static_file", "type": "flask", "text": " \nsend_static_file(filename)  \nThe view function used to serve files from static_folder. A route is automatically registered for this view at static_url_path if static_folder is set.  Changelog New in version 0.5.   Parameters \nfilename (str) \u2013   Return type \nResponse   \n"}, {"name": "Blueprint.teardown_app_request()", "path": "api/index#flask.Blueprint.teardown_app_request", "type": "flask", "text": " \nteardown_app_request(f)  \nLike Flask.teardown_request() but for a blueprint. Such a function is executed when tearing down each request, even if outside of the blueprint.  Parameters \nf (Callable[[Optional[BaseException]], Response]) \u2013   Return type \nCallable[[Optional[BaseException]], Response]   \n"}, {"name": "Blueprint.teardown_request()", "path": "api/index#flask.Blueprint.teardown_request", "type": "flask", "text": " \nteardown_request(f)  \nRegister a function to be run at the end of each request, regardless of whether there was an exception or not. These functions are executed when the request context is popped, even if not an actual request was performed. Example: ctx = app.test_request_context()\nctx.push()\n...\nctx.pop()\n When ctx.pop() is executed in the above example, the teardown functions are called just before the request context moves from the stack of active contexts. This becomes relevant if you are using such constructs in tests. Teardown functions must avoid raising exceptions, since they . If they execute code that might fail they will have to surround the execution of these code by try/except statements and log occurring errors. When a teardown function was called because of an exception it will be passed an error object. The return values of teardown functions are ignored.  Debug Note In debug mode Flask will not tear down a request on an exception immediately. Instead it will keep it alive so that the interactive debugger can still access it. This behavior can be controlled by the PRESERVE_CONTEXT_ON_EXCEPTION configuration variable.   Parameters \nf (Callable[[Optional[BaseException]], Response]) \u2013   Return type \nCallable[[Optional[BaseException]], Response]   \n"}, {"name": "Blueprint.teardown_request_funcs", "path": "api/index#flask.Blueprint.teardown_request_funcs", "type": "flask", "text": " \nteardown_request_funcs: t.Dict[AppOrBlueprintKey, t.List[TeardownCallable]]  \nA data structure of functions to call at the end of each request even if an exception is raised, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests. To register a function, use the teardown_request() decorator. This data structure is internal. It should not be modified directly and its format may change at any time. \n"}, {"name": "Blueprint.template_context_processors", "path": "api/index#flask.Blueprint.template_context_processors", "type": "flask", "text": " \ntemplate_context_processors: t.Dict[AppOrBlueprintKey, t.List[TemplateContextProcessorCallable]]  \nA data structure of functions to call to pass extra context values when rendering templates, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests. To register a function, use the context_processor() decorator. This data structure is internal. It should not be modified directly and its format may change at any time. \n"}, {"name": "Blueprint.template_folder", "path": "api/index#flask.Blueprint.template_folder", "type": "flask", "text": " \ntemplate_folder  \nThe path to the templates folder, relative to root_path, to add to the template loader. None if templates should not be added. \n"}, {"name": "Blueprint.url_defaults()", "path": "api/index#flask.Blueprint.url_defaults", "type": "flask", "text": " \nurl_defaults(f)  \nCallback function for URL defaults for all view functions of the application. It\u2019s called with the endpoint and values and should update the values passed in place.  Parameters \nf (Callable[[str, dict], None]) \u2013   Return type \nCallable[[str, dict], None]   \n"}, {"name": "Blueprint.url_default_functions", "path": "api/index#flask.Blueprint.url_default_functions", "type": "flask", "text": " \nurl_default_functions: t.Dict[AppOrBlueprintKey, t.List[URLDefaultCallable]]  \nA data structure of functions to call to modify the keyword arguments when generating URLs, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests. To register a function, use the url_defaults() decorator. This data structure is internal. It should not be modified directly and its format may change at any time. \n"}, {"name": "Blueprint.url_value_preprocessor()", "path": "api/index#flask.Blueprint.url_value_preprocessor", "type": "flask", "text": " \nurl_value_preprocessor(f)  \nRegister a URL value preprocessor function for all view functions in the application. These functions will be called before the before_request() functions. The function can modify the values captured from the matched url before they are passed to the view. For example, this can be used to pop a common language code value and place it in g rather than pass it to every view. The function is passed the endpoint name and values dict. The return value is ignored.  Parameters \nf (Callable[[Optional[str], Optional[dict]], None]) \u2013   Return type \nCallable[[Optional[str], Optional[dict]], None]   \n"}, {"name": "Blueprint.url_value_preprocessors", "path": "api/index#flask.Blueprint.url_value_preprocessors", "type": "flask", "text": " \nurl_value_preprocessors: t.Dict[AppOrBlueprintKey, t.List[URLValuePreprocessorCallable]]  \nA data structure of functions to call to modify the keyword arguments passed to the view function, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests. To register a function, use the url_value_preprocessor() decorator. This data structure is internal. It should not be modified directly and its format may change at any time. \n"}, {"name": "Blueprint.view_functions", "path": "api/index#flask.Blueprint.view_functions", "type": "flask", "text": " \nview_functions: t.Dict[str, t.Callable]  \nA dictionary mapping endpoint names to view functions. To register a view function, use the route() decorator. This data structure is internal. It should not be modified directly and its format may change at any time. \n"}, {"name": "BlueprintSetupState", "path": "api/index#flask.blueprints.BlueprintSetupState", "type": "flask.blueprints", "text": " \nclass flask.blueprints.BlueprintSetupState(blueprint, app, options, first_registration)  \nTemporary holder object for registering a blueprint with the application. An instance of this class is created by the make_setup_state() method and later passed to all register callback functions.  Parameters \n \nblueprint (Blueprint) \u2013  \napp (Flask) \u2013  \noptions (Any) \u2013  \nfirst_registration (bool) \u2013    Return type \nNone    \nadd_url_rule(rule, endpoint=None, view_func=None, **options)  \nA helper method to register a rule (and optionally a view function) to the application. The endpoint is automatically prefixed with the blueprint\u2019s name.  Parameters \n \nrule (str) \u2013  \nendpoint (Optional[str]) \u2013  \nview_func (Optional[Callable]) \u2013  \noptions (Any) \u2013    Return type \nNone   \n  \napp  \na reference to the current application \n  \nblueprint  \na reference to the blueprint that created this setup state. \n  \nfirst_registration  \nas blueprints can be registered multiple times with the application and not everything wants to be registered multiple times on it, this attribute can be used to figure out if the blueprint was registered in the past already. \n  \noptions  \na dictionary with all options that were passed to the register_blueprint() method. \n  \nsubdomain  \nThe subdomain that the blueprint should be active for, None otherwise. \n  \nurl_defaults  \nA dictionary with URL defaults that is added to each and every URL that was defined with the blueprint. \n  \nurl_prefix  \nThe prefix that should be used for all URLs defined on the blueprint. \n \n"}, {"name": "BlueprintSetupState.add_url_rule()", "path": "api/index#flask.blueprints.BlueprintSetupState.add_url_rule", "type": "flask.blueprints", "text": " \nadd_url_rule(rule, endpoint=None, view_func=None, **options)  \nA helper method to register a rule (and optionally a view function) to the application. The endpoint is automatically prefixed with the blueprint\u2019s name.  Parameters \n \nrule (str) \u2013  \nendpoint (Optional[str]) \u2013  \nview_func (Optional[Callable]) \u2013  \noptions (Any) \u2013    Return type \nNone   \n"}, {"name": "BlueprintSetupState.app", "path": "api/index#flask.blueprints.BlueprintSetupState.app", "type": "flask.blueprints", "text": " \napp  \na reference to the current application \n"}, {"name": "BlueprintSetupState.blueprint", "path": "api/index#flask.blueprints.BlueprintSetupState.blueprint", "type": "flask.blueprints", "text": " \nblueprint  \na reference to the blueprint that created this setup state. \n"}, {"name": "BlueprintSetupState.first_registration", "path": "api/index#flask.blueprints.BlueprintSetupState.first_registration", "type": "flask.blueprints", "text": " \nfirst_registration  \nas blueprints can be registered multiple times with the application and not everything wants to be registered multiple times on it, this attribute can be used to figure out if the blueprint was registered in the past already. \n"}, {"name": "BlueprintSetupState.options", "path": "api/index#flask.blueprints.BlueprintSetupState.options", "type": "flask.blueprints", "text": " \noptions  \na dictionary with all options that were passed to the register_blueprint() method. \n"}, {"name": "BlueprintSetupState.subdomain", "path": "api/index#flask.blueprints.BlueprintSetupState.subdomain", "type": "flask.blueprints", "text": " \nsubdomain  \nThe subdomain that the blueprint should be active for, None otherwise. \n"}, {"name": "BlueprintSetupState.url_defaults", "path": "api/index#flask.blueprints.BlueprintSetupState.url_defaults", "type": "flask.blueprints", "text": " \nurl_defaults  \nA dictionary with URL defaults that is added to each and every URL that was defined with the blueprint. \n"}, {"name": "BlueprintSetupState.url_prefix", "path": "api/index#flask.blueprints.BlueprintSetupState.url_prefix", "type": "flask.blueprints", "text": " \nurl_prefix  \nThe prefix that should be used for all URLs defined on the blueprint. \n"}, {"name": "Caching", "path": "patterns/caching/index", "type": "User's Guide: Design Patterns", "text": "Caching When your application runs slow, throw some caches in. Well, at least it\u2019s the easiest way to speed up things. What does a cache do? Say you have a function that takes some time to complete but the results would still be good enough if they were 5 minutes old. So then the idea is that you actually put the result of that calculation into a cache for some time. Flask itself does not provide caching for you, but Flask-Caching, an extension for Flask does. Flask-Caching supports various backends, and it is even possible to develop your own caching backend.\n"}, {"name": "Celery Background Tasks", "path": "patterns/celery/index", "type": "User's Guide: Design Patterns", "text": "Celery Background Tasks If your application has a long running task, such as processing some uploaded data or sending email, you don\u2019t want to wait for it to finish during a request. Instead, use a task queue to send the necessary data to another process that will run the task in the background while the request returns immediately. Celery is a powerful task queue that can be used for simple background tasks as well as complex multi-stage programs and schedules. This guide will show you how to configure Celery using Flask, but assumes you\u2019ve already read the First Steps with Celery guide in the Celery documentation. Install Celery is a separate Python package. Install it from PyPI using pip: $ pip install celery\n Configure The first thing you need is a Celery instance, this is called the celery application. It serves the same purpose as the Flask object in Flask, just for Celery. Since this instance is used as the entry-point for everything you want to do in Celery, like creating tasks and managing workers, it must be possible for other modules to import it. For instance you can place this in a tasks module. While you can use Celery without any reconfiguration with Flask, it becomes a bit nicer by subclassing tasks and adding support for Flask\u2019s application contexts and hooking it up with the Flask configuration. This is all that is necessary to properly integrate Celery with Flask: from celery import Celery\n\ndef make_celery(app):\n    celery = Celery(\n        app.import_name,\n        backend=app.config['CELERY_RESULT_BACKEND'],\n        broker=app.config['CELERY_BROKER_URL']\n    )\n    celery.conf.update(app.config)\n\n    class ContextTask(celery.Task):\n        def __call__(self, *args, **kwargs):\n            with app.app_context():\n                return self.run(*args, **kwargs)\n\n    celery.Task = ContextTask\n    return celery\n The function creates a new Celery object, configures it with the broker from the application config, updates the rest of the Celery config from the Flask config and then creates a subclass of the task that wraps the task execution in an application context. An example task Let\u2019s write a task that adds two numbers together and returns the result. We configure Celery\u2019s broker and backend to use Redis, create a celery application using the factor from above, and then use it to define the task. from flask import Flask\n\nflask_app = Flask(__name__)\nflask_app.config.update(\n    CELERY_BROKER_URL='redis://localhost:6379',\n    CELERY_RESULT_BACKEND='redis://localhost:6379'\n)\ncelery = make_celery(flask_app)\n\n@celery.task()\ndef add_together(a, b):\n    return a + b\n This task can now be called in the background: result = add_together.delay(23, 42)\nresult.wait()  # 65\n Run a worker If you jumped in and already executed the above code you will be disappointed to learn that .wait() will never actually return. That\u2019s because you also need to run a Celery worker to receive and execute the task. $ celery -A your_application.celery worker\n The your_application string has to point to your application\u2019s package or module that creates the celery object. Now that the worker is running, wait will return the result once the task is finished.\n"}, {"name": "CGI", "path": "deploying/cgi/index", "type": "User's Guide: Deploying", "text": "CGI If all other deployment methods do not work, CGI will work for sure. CGI is supported by all major servers but usually has a sub-optimal performance. This is also the way you can use a Flask application on Google\u2019s App Engine, where execution happens in a CGI-like environment.  Watch Out Please make sure in advance that any app.run() calls you might have in your application file are inside an if __name__ ==\n'__main__': block or moved to a separate file. Just make sure it\u2019s not called because this will always start a local WSGI server which we do not want if we deploy that application to CGI / app engine. With CGI, you will also have to make sure that your code does not contain any print statements, or that sys.stdout is overridden by something that doesn\u2019t write into the HTTP response.  Creating a .cgi file First you need to create the CGI application file. Let\u2019s call it yourapplication.cgi: #!/usr/bin/python\nfrom wsgiref.handlers import CGIHandler\nfrom yourapplication import app\n\nCGIHandler().run(app)\n Server Setup Usually there are two ways to configure the server. Either just copy the .cgi into a cgi-bin (and use mod_rewrite or something similar to rewrite the URL) or let the server point to the file directly. In Apache for example you can put something like this into the config: ScriptAlias /app /path/to/the/application.cgi\n On shared webhosting, though, you might not have access to your Apache config. In this case, a file called .htaccess, sitting in the public directory you want your app to be available, works too but the ScriptAlias directive won\u2019t work in that case: RewriteEngine On\nRewriteCond %{REQUEST_FILENAME} !-f # Don't interfere with static files\nRewriteRule ^(.*)$ /path/to/the/application.cgi/$1 [L]\n For more information consult the documentation of your webserver.\n"}, {"name": "Changes", "path": "changes/index", "type": "Additional Notes", "text": "Changes Version 2.0.1 Unreleased  Re-add the filename parameter in send_from_directory. The filename parameter has been renamed to path, the old name is deprecated. #4019\n  Version 2.0.0 Released 2021-05-11  Drop support for Python 2 and 3.5. Bump minimum versions of other Pallets projects: Werkzeug >= 2, Jinja2 >= 3, MarkupSafe >= 2, ItsDangerous >= 2, Click >= 8. Be sure to check the change logs for each project. For better compatibility with other applications (e.g. Celery) that still require Click 7, there is no hard dependency on Click 8 yet, but using Click 7 will trigger a DeprecationWarning and Flask 2.1 will depend on Click 8. JSON support no longer uses simplejson. To use another JSON module, override app.json_encoder and json_decoder. #3555\n The encoding option to JSON functions is deprecated. #3562\n Passing script_info to app factory functions is deprecated. This was not portable outside the flask command. Use click.get_current_context().obj if it\u2019s needed. #3552\n The CLI shows better error messages when the app failed to load when looking up commands. #2741\n Add sessions.SessionInterface.get_cookie_name() to allow setting the session cookie name dynamically. #3369\n Add Config.from_file() to load config using arbitrary file loaders, such as toml.load or json.load. Config.from_json() is deprecated in favor of this. #3398\n The flask run command will only defer errors on reload. Errors present during the initial call will cause the server to exit with the traceback immediately. #3431\n \nsend_file() raises a ValueError when passed an io object in text mode. Previously, it would respond with 200 OK and an empty file. #3358\n When using ad-hoc certificates, check for the cryptography library instead of PyOpenSSL. #3492\n When specifying a factory function with FLASK_APP, keyword argument can be passed. #3553\n When loading a .env or .flaskenv file, the current working directory is no longer changed to the location of the file. #3560\n When returning a (response, headers) tuple from a view, the headers replace rather than extend existing headers on the response. For example, this allows setting the Content-Type for jsonify(). Use response.headers.extend() if extending is desired. #3628\n The Scaffold class provides a common API for the Flask and Blueprint classes. Blueprint information is stored in attributes just like Flask, rather than opaque lambda functions. This is intended to improve consistency and maintainability. #3215\n Include samesite and secure options when removing the session cookie. #3726\n Support passing a pathlib.Path to static_folder. #3579\n \nsend_file and send_from_directory are wrappers around the implementations in werkzeug.utils. #3828\n Some send_file parameters have been renamed, the old names are deprecated. attachment_filename is renamed to download_name. cache_timeout is renamed to max_age. add_etags is renamed to etag. #3828, #3883\n \nsend_file passes download_name even if as_attachment=False by using Content-Disposition: inline. #3828\n \nsend_file sets conditional=True and max_age=None by default. Cache-Control is set to no-cache if max_age is not set, otherwise public. This tells browsers to validate conditional requests instead of using a timed cache. #3828\n \nhelpers.safe_join is deprecated. Use werkzeug.utils.safe_join instead. #3828\n The request context does route matching before opening the session. This could allow a session interface to change behavior based on request.endpoint. #3776\n Use Jinja\u2019s implementation of the |tojson filter. #3881\n Add route decorators for common HTTP methods. For example, @app.post(\"/login\") is a shortcut for @app.route(\"/login\", methods=[\"POST\"]). #3907\n Support async views, error handlers, before and after request, and teardown functions. #3412\n Support nesting blueprints. #593, #1548, #3923\n Set the default encoding to \u201cUTF-8\u201d when loading .env and .flaskenv files to allow to use non-ASCII characters. #3931\n \nflask shell sets up tab and history completion like the default python shell if readline is installed. #3941\n \nhelpers.total_seconds() is deprecated. Use timedelta.total_seconds() instead. #3962\n Add type hinting. #3973.  Version 1.1.2 Released 2020-04-03  Work around an issue when running the flask command with an external debugger on Windows. #3297\n The static route will not catch all URLs if the Flask static_folder argument ends with a slash. #3452\n  Version 1.1.1 Released 2019-07-08  The flask.json_available flag was added back for compatibility with some extensions. It will raise a deprecation warning when used, and will be removed in version 2.0.0. #3288\n  Version 1.1.0 Released 2019-07-04  Bump minimum Werkzeug version to >= 0.15. Drop support for Python 3.4. \nError handlers for InternalServerError or 500 will always be passed an instance of InternalServerError. If they are invoked due to an unhandled exception, that original exception is now available as e.original_exception rather than being passed directly to the handler. The same is true if the handler is for the base HTTPException. This makes error handler behavior more consistent. #3266  \nFlask.finalize_request() is called for all unhandled exceptions even if there is no 500 error handler.   \nFlask.logger takes the same name as Flask.name (the value passed as Flask(import_name). This reverts 1.0\u2019s behavior of always logging to \"flask.app\", in order to support multiple apps in the same process. A warning will be shown if old configuration is detected that needs to be moved. #2866\n \nflask.RequestContext.copy() includes the current session object in the request context copy. This prevents session pointing to an out-of-date object. #2935\n Using built-in RequestContext, unprintable Unicode characters in Host header will result in a HTTP 400 response and not HTTP 500 as previously. #2994\n \nsend_file() supports PathLike objects as described in PEP 0519, to support pathlib in Python 3. #3059\n \nsend_file() supports BytesIO partial content. #2957\n \nopen_resource() accepts the \u201crt\u201d file mode. This still does the same thing as \u201cr\u201d. #3163\n The MethodView.methods attribute set in a base class is used by subclasses. #3138\n \nFlask.jinja_options is a dict instead of an ImmutableDict to allow easier configuration. Changes must still be made before creating the environment. #3190\n Flask\u2019s JSONMixin for the request and response wrappers was moved into Werkzeug. Use Werkzeug\u2019s version with Flask-specific support. This bumps the Werkzeug dependency to >= 0.15. #3125\n The flask command entry point is simplified to take advantage of Werkzeug 0.15\u2019s better reloader support. This bumps the Werkzeug dependency to >= 0.15. #3022\n Support static_url_path that ends with a forward slash. #3134\n Support empty static_folder without requiring setting an empty static_url_path as well. #3124\n \njsonify() supports dataclasses.dataclass objects. #3195\n Allow customizing the Flask.url_map_class used for routing. #3069\n The development server port can be set to 0, which tells the OS to pick an available port. #2926\n The return value from cli.load_dotenv() is more consistent with the documentation. It will return False if python-dotenv is not installed, or if the given path isn\u2019t a file. #2937\n Signaling support has a stub for the connect_via method when the Blinker library is not installed. #3208\n Add an --extra-files option to the flask run CLI command to specify extra files that will trigger the reloader on change. #2897\n Allow returning a dictionary from a view function. Similar to how returning a string will produce a text/html response, returning a dict will call jsonify to produce a application/json response. #3111\n Blueprints have a cli Click group like app.cli. CLI commands registered with a blueprint will be available as a group under the flask command. #1357. When using the test client as a context manager (with client:), all preserved request contexts are popped when the block exits, ensuring nested contexts are cleaned up correctly. #3157\n Show a better error message when the view return type is not supported. #3214\n \nflask.testing.make_test_environ_builder() has been deprecated in favour of a new class flask.testing.EnvironBuilder. #3232\n The flask run command no longer fails if Python is not built with SSL support. Using the --cert option will show an appropriate error message. #3211\n URL matching now occurs after the request context is pushed, rather than when it\u2019s created. This allows custom URL converters to access the app and request contexts, such as to query a database for an id. #3088\n  Version 1.0.4 Released 2019-07-04  The key information for BadRequestKeyError is no longer cleared outside debug mode, so error handlers can still access it. This requires upgrading to Werkzeug 0.15.5. #3249\n \nsend_file url quotes the \u201c:\u201d and \u201c/\u201d characters for more compatible UTF-8 filename support in some browsers. #3074\n Fixes for PEP451 import loaders and pytest 5.x. #3275\n Show message about dotenv on stderr instead of stdout. #3285\n  Version 1.0.3 Released 2019-05-17  \nsend_file() encodes filenames as ASCII instead of Latin-1 (ISO-8859-1). This fixes compatibility with Gunicorn, which is stricter about header encodings than PEP 3333. #2766\n Allow custom CLIs using FlaskGroup to set the debug flag without it always being overwritten based on environment variables. #2765\n \nflask --version outputs Werkzeug\u2019s version and simplifies the Python version. #2825\n \nsend_file() handles an attachment_filename that is a native Python 2 string (bytes) with UTF-8 coded bytes. #2933\n A catch-all error handler registered for HTTPException will not handle RoutingException, which is used internally during routing. This fixes the unexpected behavior that had been introduced in 1.0. #2986\n Passing the json argument to app.test_client does not push/pop an extra app context. #2900\n  Version 1.0.2 Released 2018-05-02  Fix more backwards compatibility issues with merging slashes between a blueprint prefix and route. #2748\n Fix error with flask routes command when there are no routes. #2751\n  Version 1.0.1 Released 2018-04-29  Fix registering partials (with no __name__) as view functions. #2730\n Don\u2019t treat lists returned from view functions the same as tuples. Only tuples are interpreted as response data. #2736\n Extra slashes between a blueprint\u2019s url_prefix and a route URL are merged. This fixes some backwards compatibility issues with the change in 1.0. #2731, #2742\n Only trap BadRequestKeyError errors in debug mode, not all BadRequest errors. This allows abort(400) to continue working as expected. #2735\n The FLASK_SKIP_DOTENV environment variable can be set to 1 to skip automatically loading dotenv files. #2722\n  Version 1.0 Released 2018-04-26  Python 2.6 and 3.3 are no longer supported. Bump minimum dependency versions to the latest stable versions: Werkzeug >= 0.14, Jinja >= 2.10, itsdangerous >= 0.24, Click >= 5.1. #2586\n Skip app.run when a Flask application is run from the command line. This avoids some behavior that was confusing to debug. Change the default for JSONIFY_PRETTYPRINT_REGULAR to False. jsonify() returns a compact format by default, and an indented format in debug mode. #2193\n \nFlask.__init__ accepts the host_matching argument and sets it on url_map. #1559\n \nFlask.__init__ accepts the static_host argument and passes it as the host argument when defining the static route. #1559\n \nsend_file() supports Unicode in attachment_filename. #2223\n Pass _scheme argument from url_for() to handle_url_build_error(). #2017\n \nadd_url_rule() accepts the provide_automatic_options argument to disable adding the OPTIONS method. #1489\n \nMethodView subclasses inherit method handlers from base classes. #1936\n Errors caused while opening the session at the beginning of the request are handled by the app\u2019s error handlers. #2254\n Blueprints gained json_encoder and json_decoder attributes to override the app\u2019s encoder and decoder. #1898\n \nFlask.make_response() raises TypeError instead of ValueError for bad response types. The error messages have been improved to describe why the type is invalid. #2256\n Add routes CLI command to output routes registered on the application. #2259\n Show warning when session cookie domain is a bare hostname or an IP address, as these may not behave properly in some browsers, such as Chrome. #2282\n Allow IP address as exact session cookie domain. #2282\n \nSESSION_COOKIE_DOMAIN is set if it is detected through SERVER_NAME. #2282\n Auto-detect zero-argument app factory called create_app or make_app from FLASK_APP. #2297\n Factory functions are not required to take a script_info parameter to work with the flask command. If they take a single parameter or a parameter named script_info, the ScriptInfo object will be passed. #2319\n \nFLASK_APP can be set to an app factory, with arguments if needed, for example FLASK_APP=myproject.app:create_app('dev'). #2326\n \nFLASK_APP can point to local packages that are not installed in editable mode, although pip install -e is still preferred. #2414\n The View class attribute provide_automatic_options is set in as_view(), to be detected by add_url_rule(). #2316\n Error handling will try handlers registered for blueprint, code, app, code, blueprint, exception, app, exception. #2314\n \nCookie is added to the response\u2019s Vary header if the session is accessed at all during the request (and not deleted). #2288\n \ntest_request_context() accepts subdomain and url_scheme arguments for use when building the base URL. #1621\n Set APPLICATION_ROOT to '/' by default. This was already the implicit default when it was set to None. \nTRAP_BAD_REQUEST_ERRORS is enabled by default in debug mode. BadRequestKeyError has a message with the bad key in debug mode instead of the generic bad request message. #2348\n Allow registering new tags with TaggedJSONSerializer to support storing other types in the session cookie. #2352\n Only open the session if the request has not been pushed onto the context stack yet. This allows stream_with_context() generators to access the same session that the containing view uses. #2354\n Add json keyword argument for the test client request methods. This will dump the given object as JSON and set the appropriate content type. #2358\n Extract JSON handling to a mixin applied to both the Request and Response classes. This adds the is_json() and get_json() methods to the response to make testing JSON response much easier. #2358\n Removed error handler caching because it caused unexpected results for some exception inheritance hierarchies. Register handlers explicitly for each exception if you want to avoid traversing the MRO. #2362\n Fix incorrect JSON encoding of aware, non-UTC datetimes. #2374\n Template auto reloading will honor debug mode even even if jinja_env was already accessed. #2373\n \nThe following old deprecated code was removed. #2385  \nflask.ext - import extensions directly by their name instead of through the flask.ext namespace. For example, import flask.ext.sqlalchemy becomes import flask_sqlalchemy. \nFlask.init_jinja_globals - extend Flask.create_jinja_environment() instead. \nFlask.error_handlers - tracked by Flask.error_handler_spec, use Flask.errorhandler() to register handlers. \nFlask.request_globals_class - use Flask.app_ctx_globals_class instead. \nFlask.static_path - use Flask.static_url_path instead. \nRequest.module - use Request.blueprint instead.   The Request.json property is no longer deprecated. #1421\n Support passing a EnvironBuilder or dict to test_client.open. #2412\n The flask command and Flask.run() will load environment variables from .env and .flaskenv files if python-dotenv is installed. #2416\n When passing a full URL to the test client, the scheme in the URL is used instead of PREFERRED_URL_SCHEME. #2430\n \nFlask.logger has been simplified. LOGGER_NAME and LOGGER_HANDLER_POLICY config was removed. The logger is always named flask.app. The level is only set on first access, it doesn\u2019t check Flask.debug each time. Only one format is used, not different ones depending on Flask.debug. No handlers are removed, and a handler is only added if no handlers are already configured. #2436\n Blueprint view function names may not contain dots. #2450\n Fix a ValueError caused by invalid Range requests in some cases. #2526\n The development server uses threads by default. #2529\n Loading config files with silent=True will ignore ENOTDIR errors. #2581\n Pass --cert and --key options to flask run to run the development server over HTTPS. #2606\n Added SESSION_COOKIE_SAMESITE to control the SameSite attribute on the session cookie. #2607\n Added test_cli_runner() to create a Click runner that can invoke Flask CLI commands for testing. #2636\n Subdomain matching is disabled by default and setting SERVER_NAME does not implicitly enable it. It can be enabled by passing subdomain_matching=True to the Flask constructor. #2635\n A single trailing slash is stripped from the blueprint url_prefix when it is registered with the app. #2629\n \nRequest.get_json() doesn\u2019t cache the result if parsing fails when silent is true. #2651\n \nRequest.get_json() no longer accepts arbitrary encodings. Incoming JSON should be encoded using UTF-8 per RFC 8259, but Flask will autodetect UTF-8, -16, or -32. #2691\n Added MAX_COOKIE_SIZE and Response.max_cookie_size to control when Werkzeug warns about large cookies that browsers may ignore. #2693\n Updated documentation theme to make docs look better in small windows. #2709\n Rewrote the tutorial docs and example project to take a more structured approach to help new users avoid common pitfalls. #2676\n  Version 0.12.5 Released 2020-02-10  Pin Werkzeug to < 1.0.0. #3497\n  Version 0.12.4 Released 2018-04-29  Repackage 0.12.3 to fix package layout issue. #2728\n  Version 0.12.3 Released 2018-04-26  \nRequest.get_json() no longer accepts arbitrary encodings. Incoming JSON should be encoded using UTF-8 per RFC 8259, but Flask will autodetect UTF-8, -16, or -32. #2692\n Fix a Python warning about imports when using python -m flask. #2666\n Fix a ValueError caused by invalid Range requests in some cases.  Version 0.12.2 Released 2017-05-16  Fix a bug in safe_join on Windows.  Version 0.12.1 Released 2017-03-31  Prevent flask run from showing a NoAppException when an ImportError occurs within the imported application module. Fix encoding behavior of app.config.from_pyfile for Python 3. #2118\n Use the SERVER_NAME config if it is present as default values for app.run. #2109, #2152\n Call ctx.auto_pop with the exception object instead of None, in the event that a BaseException such as KeyboardInterrupt is raised in a request handler.  Version 0.12 Released 2016-12-21, codename Punsch  The cli command now responds to --version. Mimetype guessing and ETag generation for file-like objects in send_file has been removed. #104, :pr`1849` Mimetype guessing in send_file now fails loudly and doesn\u2019t fall back to application/octet-stream. #1988\n Make flask.safe_join able to join multiple paths like os.path.join #1730\n Revert a behavior change that made the dev server crash instead of returning an Internal Server Error. #2006\n Correctly invoke response handlers for both regular request dispatching as well as error handlers. Disable logger propagation by default for the app logger. Add support for range requests in send_file. \napp.test_client includes preset default environment, which can now be directly set, instead of per client.get. Fix crash when running under PyPy3. #1814\n  Version 0.11.1 Released 2016-06-07  Fixed a bug that prevented FLASK_APP=foobar/__init__.py from working. #1872\n  Version 0.11 Released 2016-05-29, codename Absinthe  Added support to serializing top-level arrays to flask.jsonify(). This introduces a security risk in ancient browsers. Added before_render_template signal. Added **kwargs to flask.Test.test_client() to support passing additional keyword arguments to the constructor of flask.Flask.test_client_class. Added SESSION_REFRESH_EACH_REQUEST config key that controls the set-cookie behavior. If set to True a permanent session will be refreshed each request and get their lifetime extended, if set to False it will only be modified if the session actually modifies. Non permanent sessions are not affected by this and will always expire if the browser window closes. Made Flask support custom JSON mimetypes for incoming data. Added support for returning tuples in the form (response,\nheaders) from a view function. Added flask.Config.from_json(). Added flask.Flask.config_class. Added flask.Config.get_namespace(). Templates are no longer automatically reloaded outside of debug mode. This can be configured with the new TEMPLATES_AUTO_RELOAD config key. Added a workaround for a limitation in Python 3.3\u2019s namespace loader. Added support for explicit root paths when using Python 3.3\u2019s namespace packages. Added flask and the flask.cli module to start the local debug server through the click CLI system. This is recommended over the old flask.run() method as it works faster and more reliable due to a different design and also replaces Flask-Script. Error handlers that match specific classes are now checked first, thereby allowing catching exceptions that are subclasses of HTTP exceptions (in werkzeug.exceptions). This makes it possible for an extension author to create exceptions that will by default result in the HTTP error of their choosing, but may be caught with a custom error handler if desired. Added flask.Config.from_mapping(). Flask will now log by default even if debug is disabled. The log format is now hardcoded but the default log handling can be disabled through the LOGGER_HANDLER_POLICY configuration key. Removed deprecated module functionality. Added the EXPLAIN_TEMPLATE_LOADING config flag which when enabled will instruct Flask to explain how it locates templates. This should help users debug when the wrong templates are loaded. Enforce blueprint handling in the order they were registered for template loading. Ported test suite to py.test. Deprecated request.json in favour of request.get_json(). Add \u201cpretty\u201d and \u201ccompressed\u201d separators definitions in jsonify() method. Reduces JSON response size when JSONIFY_PRETTYPRINT_REGULAR=False by removing unnecessary white space included by default after separators. JSON responses are now terminated with a newline character, because it is a convention that UNIX text files end with a newline and some clients don\u2019t deal well when this newline is missing. This came up originally as a part of https://github.com/postmanlabs/httpbin/issues/168. #1262\n The automatically provided OPTIONS method is now correctly disabled if the user registered an overriding rule with the lowercase-version options. #1288\n \nflask.json.jsonify now supports the datetime.date type. #1326\n Don\u2019t leak exception info of already caught exceptions to context teardown handlers. #1393\n Allow custom Jinja environment subclasses. #1422\n Updated extension dev guidelines. \nflask.g now has pop() and setdefault methods. Turn on autoescape for flask.templating.render_template_string by default. #1515\n \nflask.ext is now deprecated. #1484\n \nsend_from_directory now raises BadRequest if the filename is invalid on the server OS. #1763\n Added the JSONIFY_MIMETYPE configuration variable. #1728\n Exceptions during teardown handling will no longer leave bad application contexts lingering around. Fixed broken test_appcontext_signals() test case. Raise an AttributeError in flask.helpers.find_package() with a useful message explaining why it is raised when a PEP 302 import hook is used without an is_package() method. Fixed an issue causing exceptions raised before entering a request or app context to be passed to teardown handlers. Fixed an issue with query parameters getting removed from requests in the test client when absolute URLs were requested. Made @before_first_request into a decorator as intended. Fixed an etags bug when sending a file streams with a name. Fixed send_from_directory not expanding to the application root path correctly. Changed logic of before first request handlers to flip the flag after invoking. This will allow some uses that are potentially dangerous but should probably be permitted. Fixed Python 3 bug when a handler from app.url_build_error_handlers reraises the BuildError.  Version 0.10.1 Released 2013-06-14  Fixed an issue where |tojson was not quoting single quotes which made the filter not work properly in HTML attributes. Now it\u2019s possible to use that filter in single quoted attributes. This should make using that filter with angular.js easier. Added support for byte strings back to the session system. This broke compatibility with the common case of people putting binary data for token verification into the session. Fixed an issue where registering the same method twice for the same endpoint would trigger an exception incorrectly.  Version 0.10 Released 2013-06-13, codename Limoncello  Changed default cookie serialization format from pickle to JSON to limit the impact an attacker can do if the secret key leaks. Added template_test methods in addition to the already existing template_filter method family. Added template_global methods in addition to the already existing template_filter method family. Set the content-length header for x-sendfile. \ntojson filter now does not escape script blocks in HTML5 parsers. \ntojson used in templates is now safe by default due. This was allowed due to the different escaping behavior. Flask will now raise an error if you attempt to register a new function on an already used endpoint. Added wrapper module around simplejson and added default serialization of datetime objects. This allows much easier customization of how JSON is handled by Flask or any Flask extension. Removed deprecated internal flask.session module alias. Use flask.sessions instead to get the session module. This is not to be confused with flask.session the session proxy. Templates can now be rendered without request context. The behavior is slightly different as the request, session and g objects will not be available and blueprint\u2019s context processors are not called. The config object is now available to the template as a real global and not through a context processor which makes it available even in imported templates by default. Added an option to generate non-ascii encoded JSON which should result in less bytes being transmitted over the network. It\u2019s disabled by default to not cause confusion with existing libraries that might expect flask.json.dumps to return bytes by default. \nflask.g is now stored on the app context instead of the request context. \nflask.g now gained a get() method for not erroring out on non existing items. \nflask.g now can be used with the in operator to see what\u2019s defined and it now is iterable and will yield all attributes stored. \nflask.Flask.request_globals_class got renamed to flask.Flask.app_ctx_globals_class which is a better name to what it does since 0.10. \nrequest, session and g are now also added as proxies to the template context which makes them available in imported templates. One has to be very careful with those though because usage outside of macros might cause caching. Flask will no longer invoke the wrong error handlers if a proxy exception is passed through. Added a workaround for chrome\u2019s cookies in localhost not working as intended with domain names. Changed logic for picking defaults for cookie values from sessions to work better with Google Chrome. Added message_flashed signal that simplifies flashing testing. Added support for copying of request contexts for better working with greenlets. Removed custom JSON HTTP exception subclasses. If you were relying on them you can reintroduce them again yourself trivially. Using them however is strongly discouraged as the interface was flawed. Python requirements changed: requiring Python 2.6 or 2.7 now to prepare for Python 3.3 port. Changed how the teardown system is informed about exceptions. This is now more reliable in case something handles an exception halfway through the error handling process. Request context preservation in debug mode now keeps the exception information around which means that teardown handlers are able to distinguish error from success cases. Added the JSONIFY_PRETTYPRINT_REGULAR configuration variable. Flask now orders JSON keys by default to not trash HTTP caches due to different hash seeds between different workers. Added appcontext_pushed and appcontext_popped signals. The builtin run method now takes the SERVER_NAME into account when picking the default port to run on. Added flask.request.get_json() as a replacement for the old flask.request.json property.  Version 0.9 Released 2012-07-01, codename Campari  The flask.Request.on_json_loading_failed() now returns a JSON formatted response by default. The flask.url_for() function now can generate anchors to the generated links. The flask.url_for() function now can also explicitly generate URL rules specific to a given HTTP method. Logger now only returns the debug log setting if it was not set explicitly. Unregister a circular dependency between the WSGI environment and the request object when shutting down the request. This means that environ werkzeug.request will be None after the response was returned to the WSGI server but has the advantage that the garbage collector is not needed on CPython to tear down the request unless the user created circular dependencies themselves. Session is now stored after callbacks so that if the session payload is stored in the session you can still modify it in an after request callback. The flask.Flask class will avoid importing the provided import name if it can (the required first parameter), to benefit tools which build Flask instances programmatically. The Flask class will fall back to using import on systems with custom module hooks, e.g. Google App Engine, or when the import name is inside a zip archive (usually a .egg) prior to Python 2.7. Blueprints now have a decorator to add custom template filters application wide, flask.Blueprint.app_template_filter(). The Flask and Blueprint classes now have a non-decorator method for adding custom template filters application wide, flask.Flask.add_template_filter() and flask.Blueprint.add_app_template_filter(). The flask.get_flashed_messages() function now allows rendering flashed message categories in separate blocks, through a category_filter argument. The flask.Flask.run() method now accepts None for host and port arguments, using default values when None. This allows for calling run using configuration values, e.g. app.run(app.config.get('MYHOST'), app.config.get('MYPORT')), with proper behavior whether or not a config file is provided. The flask.render_template() method now accepts a either an iterable of template names or a single template name. Previously, it only accepted a single template name. On an iterable, the first template found is rendered. Added flask.Flask.app_context() which works very similar to the request context but only provides access to the current application. This also adds support for URL generation without an active request context. View functions can now return a tuple with the first instance being an instance of flask.Response. This allows for returning jsonify(error=\"error msg\"), 400 from a view function. \nFlask and Blueprint now provide a get_send_file_max_age() hook for subclasses to override behavior of serving static files from Flask when using flask.Flask.send_static_file() (used for the default static file handler) and send_file(). This hook is provided a filename, which for example allows changing cache controls by file extension. The default max-age for send_file and static files can be configured through a new SEND_FILE_MAX_AGE_DEFAULT configuration variable, which is used in the default get_send_file_max_age implementation. Fixed an assumption in sessions implementation which could break message flashing on sessions implementations which use external storage. Changed the behavior of tuple return values from functions. They are no longer arguments to the response object, they now have a defined meaning. Added flask.Flask.request_globals_class to allow a specific class to be used on creation of the g instance of each request. Added required_methods attribute to view functions to force-add methods on registration. Added flask.after_this_request(). Added flask.stream_with_context() and the ability to push contexts multiple times without producing unexpected behavior.  Version 0.8.1 Released 2012-07-01  Fixed an issue with the undocumented flask.session module to not work properly on Python 2.5. It should not be used but did cause some problems for package managers.  Version 0.8 Released 2011-09-29, codename Rakija  Refactored session support into a session interface so that the implementation of the sessions can be changed without having to override the Flask class. Empty session cookies are now deleted properly automatically. View functions can now opt out of getting the automatic OPTIONS implementation. HTTP exceptions and Bad Request errors can now be trapped so that they show up normally in the traceback. Flask in debug mode is now detecting some common problems and tries to warn you about them. Flask in debug mode will now complain with an assertion error if a view was attached after the first request was handled. This gives earlier feedback when users forget to import view code ahead of time. Added the ability to register callbacks that are only triggered once at the beginning of the first request. (Flask.before_first_request()) Malformed JSON data will now trigger a bad request HTTP exception instead of a value error which usually would result in a 500 internal server error if not handled. This is a backwards incompatible change. Applications now not only have a root path where the resources and modules are located but also an instance path which is the designated place to drop files that are modified at runtime (uploads etc.). Also this is conceptually only instance depending and outside version control so it\u2019s the perfect place to put configuration files etc. Added the APPLICATION_ROOT configuration variable. Implemented session_transaction() to easily modify sessions from the test environment. Refactored test client internally. The APPLICATION_ROOT configuration variable as well as SERVER_NAME are now properly used by the test client as defaults. Added flask.views.View.decorators to support simpler decorating of pluggable (class-based) views. Fixed an issue where the test client if used with the \u201cwith\u201d statement did not trigger the execution of the teardown handlers. Added finer control over the session cookie parameters. HEAD requests to a method view now automatically dispatch to the get method if no handler was implemented. Implemented the virtual flask.ext package to import extensions from. The context preservation on exceptions is now an integral component of Flask itself and no longer of the test client. This cleaned up some internal logic and lowers the odds of runaway request contexts in unittests. Fixed the Jinja2 environment\u2019s list_templates method not returning the correct names when blueprints or modules were involved.  Version 0.7.2 Released 2011-07-06  Fixed an issue with URL processors not properly working on blueprints.  Version 0.7.1 Released 2011-06-29  Added missing future import that broke 2.5 compatibility. Fixed an infinite redirect issue with blueprints.  Version 0.7 Released 2011-06-28, codename Grappa  Added make_default_options_response() which can be used by subclasses to alter the default behavior for OPTIONS responses. Unbound locals now raise a proper RuntimeError instead of an AttributeError. Mimetype guessing and etag support based on file objects is now deprecated for flask.send_file() because it was unreliable. Pass filenames instead or attach your own etags and provide a proper mimetype by hand. Static file handling for modules now requires the name of the static folder to be supplied explicitly. The previous autodetection was not reliable and caused issues on Google\u2019s App Engine. Until 1.0 the old behavior will continue to work but issue dependency warnings. Fixed a problem for Flask to run on jython. Added a PROPAGATE_EXCEPTIONS configuration variable that can be used to flip the setting of exception propagation which previously was linked to DEBUG alone and is now linked to either DEBUG or TESTING. Flask no longer internally depends on rules being added through the add_url_rule function and can now also accept regular werkzeug rules added to the url map. Added an endpoint method to the flask application object which allows one to register a callback to an arbitrary endpoint with a decorator. Use Last-Modified for static file sending instead of Date which was incorrectly introduced in 0.6. Added create_jinja_loader to override the loader creation process. Implemented a silent flag for config.from_pyfile. Added teardown_request decorator, for functions that should run at the end of a request regardless of whether an exception occurred. Also the behavior for after_request was changed. It\u2019s now no longer executed when an exception is raised. Implemented flask.has_request_context()\n Deprecated init_jinja_globals. Override the create_jinja_environment() method instead to achieve the same functionality. Added flask.safe_join()\n The automatic JSON request data unpacking now looks at the charset mimetype parameter. Don\u2019t modify the session on flask.get_flashed_messages() if there are no messages in the session. \nbefore_request handlers are now able to abort requests with errors. It is not possible to define user exception handlers. That way you can provide custom error messages from a central hub for certain errors that might occur during request processing (for instance database connection errors, timeouts from remote resources etc.). Blueprints can provide blueprint specific error handlers. Implemented generic class-based views.  Version 0.6.1 Released 2010-12-31  Fixed an issue where the default OPTIONS response was not exposing all valid methods in the Allow header. Jinja2 template loading syntax now allows \u201c./\u201d in front of a template load path. Previously this caused issues with module setups. Fixed an issue where the subdomain setting for modules was ignored for the static folder. Fixed a security problem that allowed clients to download arbitrary files if the host server was a windows based operating system and the client uses backslashes to escape the directory the files where exposed from.  Version 0.6 Released 2010-07-27, codename Whisky  After request functions are now called in reverse order of registration. OPTIONS is now automatically implemented by Flask unless the application explicitly adds \u2018OPTIONS\u2019 as method to the URL rule. In this case no automatic OPTIONS handling kicks in. Static rules are now even in place if there is no static folder for the module. This was implemented to aid GAE which will remove the static folder if it\u2019s part of a mapping in the .yml file. The config is now available in the templates as config. Context processors will no longer override values passed directly to the render function. Added the ability to limit the incoming request data with the new MAX_CONTENT_LENGTH configuration value. The endpoint for the flask.Module.add_url_rule() method is now optional to be consistent with the function of the same name on the application object. Added a flask.make_response() function that simplifies creating response object instances in views. Added signalling support based on blinker. This feature is currently optional and supposed to be used by extensions and applications. If you want to use it, make sure to have blinker installed. Refactored the way URL adapters are created. This process is now fully customizable with the create_url_adapter() method. Modules can now register for a subdomain instead of just an URL prefix. This makes it possible to bind a whole module to a configurable subdomain.  Version 0.5.2 Released 2010-07-15  Fixed another issue with loading templates from directories when modules were used.  Version 0.5.1 Released 2010-07-06  Fixes an issue with template loading from directories when modules where used.  Version 0.5 Released 2010-07-06, codename Calvados  Fixed a bug with subdomains that was caused by the inability to specify the server name. The server name can now be set with the SERVER_NAME config key. This key is now also used to set the session cookie cross-subdomain wide. Autoescaping is no longer active for all templates. Instead it is only active for .html, .htm, .xml and .xhtml. Inside templates this behavior can be changed with the autoescape tag. Refactored Flask internally. It now consists of more than a single file. \nflask.send_file() now emits etags and has the ability to do conditional responses builtin. (temporarily) dropped support for zipped applications. This was a rarely used feature and led to some confusing behavior. Added support for per-package template and static-file directories. Removed support for create_jinja_loader which is no longer used in 0.5 due to the improved module support. Added a helper function to expose files from any directory.  Version 0.4 Released 2010-06-18, codename Rakia  Added the ability to register application wide error handlers from modules. \nafter_request() handlers are now also invoked if the request dies with an exception and an error handling page kicks in. Test client has not the ability to preserve the request context for a little longer. This can also be used to trigger custom requests that do not pop the request stack for testing. Because the Python standard library caches loggers, the name of the logger is configurable now to better support unittests. Added TESTING switch that can activate unittesting helpers. The logger switches to DEBUG mode now if debug is enabled.  Version 0.3.1 Released 2010-05-28  Fixed a error reporting bug with flask.Config.from_envvar()\n Removed some unused code from flask Release does no longer include development leftover files (.git folder for themes, built documentation in zip and pdf file and some .pyc files)  Version 0.3 Released 2010-05-28, codename Schnaps  Added support for categories for flashed messages. The application now configures a logging.Handler and will log request handling exceptions to that logger when not in debug mode. This makes it possible to receive mails on server errors for example. Added support for context binding that does not require the use of the with statement for playing in the console. The request context is now available within the with statement making it possible to further push the request context or pop it. Added support for configurations.  Version 0.2 Released 2010-05-12, codename J?germeister  Various bugfixes Integrated JSON support Added get_template_attribute() helper function. \nadd_url_rule() can now also register a view function. Refactored internal request dispatching. Server listens on 127.0.0.1 by default now to fix issues with chrome. Added external URL support. Added support for send_file()\n Module support and internal request handling refactoring to better support pluggable applications. Sessions can be set to be permanent now on a per-session basis. Better error reporting on missing secret keys. Added support for Google Appengine.  Version 0.1 Released 2010-04-16  First public preview release. \n"}, {"name": "Command Line Interface", "path": "cli/index", "type": "User\u2019s Guide", "text": "Command Line Interface Installing Flask installs the flask script, a Click command line interface, in your virtualenv. Executed from the terminal, this script gives access to built-in, extension, and application-defined commands. The --help option will give more information about any commands and options. Application Discovery The flask command is installed by Flask, not your application; it must be told where to find your application in order to use it. The FLASK_APP environment variable is used to specify how to load the application.  \nBashCMDPowershell\n\n\n$ export FLASK_APP=hello\n$ flask run\n \n\n> set FLASK_APP=hello\n> flask run\n \n\n> $env:FLASK_APP = \"hello\"\n> flask run\n \n While FLASK_APP supports a variety of options for specifying your application, most use cases should be simple. Here are the typical values:  (nothing)\n\nThe name \u201capp\u201d or \u201cwsgi\u201d is imported (as a \u201c.py\u201d file, or package), automatically detecting an app (app or application) or factory (create_app or make_app).  \nFLASK_APP=hello \n\nThe given name is imported, automatically detecting an app (app or application) or factory (create_app or make_app).   FLASK_APP has three parts: an optional path that sets the current working directory, a Python file or dotted import path, and an optional variable name of the instance or factory. If the name is a factory, it can optionally be followed by arguments in parentheses. The following values demonstrate these parts:  \nFLASK_APP=src/hello \n\nSets the current working directory to src then imports hello.  \nFLASK_APP=hello.web \n\nImports the path hello.web.  \nFLASK_APP=hello:app2 \n\nUses the app2 Flask instance in hello.  \nFLASK_APP=\"hello:create_app('dev')\" \n\nThe create_app factory in hello is called with the string 'dev' as the argument.   If FLASK_APP is not set, the command will try to import \u201capp\u201d or \u201cwsgi\u201d (as a \u201c.py\u201d file, or package) and try to detect an application instance or factory. Within the given import, the command looks for an application instance named app or application, then any application instance. If no instance is found, the command looks for a factory function named create_app or make_app that returns an instance. If parentheses follow the factory name, their contents are parsed as Python literals and passed as arguments and keyword arguments to the function. This means that strings must still be in quotes. Run the Development Server The run command will start the development server. It replaces the Flask.run() method in most cases. $ flask run\n * Serving Flask app \"hello\"\n * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)\n  Warning Do not use this command to run your application in production. Only use the development server during development. The development server is provided for convenience, but is not designed to be particularly secure, stable, or efficient. See Deployment Options for how to run in production.  Open a Shell To explore the data in your application, you can start an interactive Python shell with the shell command. An application context will be active, and the app instance will be imported. $ flask shell\nPython 3.6.2 (default, Jul 20 2017, 03:52:27)\n[GCC 7.1.1 20170630] on linux\nApp: example\nInstance: /home/user/Projects/hello/instance\n>>>\n Use shell_context_processor() to add other automatic imports. Environments  Changelog New in version 1.0.  The environment in which the Flask app runs is set by the FLASK_ENV environment variable. If not set it defaults to production. The other recognized environment is development. Flask and extensions may choose to enable behaviors based on the environment. If the env is set to development, the flask command will enable debug mode and flask run will enable the interactive debugger and reloader.  \nBashCMDPowershell\n\n\n$ export FLASK_ENV=development\n$ flask run\n * Serving Flask app \"hello\"\n * Environment: development\n * Debug mode: on\n * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)\n * Restarting with inotify reloader\n * Debugger is active!\n * Debugger PIN: 223-456-919\n \n\n> set FLASK_ENV=development\n> flask run\n * Serving Flask app \"hello\"\n * Environment: development\n * Debug mode: on\n * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)\n * Restarting with inotify reloader\n * Debugger is active!\n * Debugger PIN: 223-456-919\n \n\n> $env:FLASK_ENV = \"development\"\n> flask run\n * Serving Flask app \"hello\"\n * Environment: development\n * Debug mode: on\n * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)\n * Restarting with inotify reloader\n * Debugger is active!\n * Debugger PIN: 223-456-919\n \n Watch Extra Files with the Reloader When using development mode, the reloader will trigger whenever your Python code or imported modules change. The reloader can watch additional files with the --extra-files option, or the FLASK_RUN_EXTRA_FILES environment variable. Multiple paths are separated with :, or ; on Windows.  \nBashCMDPowershell\n\n\n$ flask run --extra-files file1:dirA/file2:dirB/\n# or\n$ export FLASK_RUN_EXTRA_FILES=file1:dirA/file2:dirB/\n$ flask run\n * Running on http://127.0.0.1:8000/\n * Detected change in '/path/to/file1', reloading\n \n\n> flask run --extra-files file1:dirA/file2:dirB/\n# or\n> set FLASK_RUN_EXTRA_FILES=file1:dirA/file2:dirB/\n> flask run\n * Running on http://127.0.0.1:8000/\n * Detected change in '/path/to/file1', reloading\n \n\n> flask run --extra-files file1:dirA/file2:dirB/\n# or\n> $env:FLASK_RUN_EXTRA_FILES = \"file1:dirA/file2:dirB/\"\n> flask run\n * Running on http://127.0.0.1:8000/\n * Detected change in '/path/to/file1', reloading\n \n Debug Mode Debug mode will be enabled when FLASK_ENV is development, as described above. If you want to control debug mode separately, use FLASK_DEBUG. The value 1 enables it, 0 disables it. Environment Variables From dotenv Rather than setting FLASK_APP each time you open a new terminal, you can use Flask\u2019s dotenv support to set environment variables automatically. If python-dotenv is installed, running the flask command will set environment variables defined in the files .env and .flaskenv. This can be used to avoid having to set FLASK_APP manually every time you open a new terminal, and to set configuration using environment variables similar to how some deployment services work. Variables set on the command line are used over those set in .env, which are used over those set in .flaskenv. .flaskenv should be used for public variables, such as FLASK_APP, while .env should not be committed to your repository so that it can set private variables. Directories are scanned upwards from the directory you call flask from to locate the files. The current working directory will be set to the location of the file, with the assumption that that is the top level project directory. The files are only loaded by the flask command or calling run(). If you would like to load these files when running in production, you should call load_dotenv() manually. Setting Command Options Click is configured to load default values for command options from environment variables. The variables use the pattern FLASK_COMMAND_OPTION. For example, to set the port for the run command, instead of flask run --port 8000:  \nBashCMDPowershell\n\n\n$ export FLASK_RUN_PORT=8000\n$ flask run\n * Running on http://127.0.0.1:8000/\n \n\n> set FLASK_RUN_PORT=8000\n> flask run\n * Running on http://127.0.0.1:8000/\n \n\n> $env:FLASK_RUN_PORT = 8000\n> flask run\n * Running on http://127.0.0.1:8000/\n \n These can be added to the .flaskenv file just like FLASK_APP to control default command options. Disable dotenv The flask command will show a message if it detects dotenv files but python-dotenv is not installed. $ flask run\n * Tip: There are .env files present. Do \"pip install python-dotenv\" to use them.\n You can tell Flask not to load dotenv files even when python-dotenv is installed by setting the FLASK_SKIP_DOTENV environment variable. This can be useful if you want to load them manually, or if you\u2019re using a project runner that loads them already. Keep in mind that the environment variables must be set before the app loads or it won\u2019t configure as expected.  \nBashCMDPowershell\n\n\n$ export FLASK_SKIP_DOTENV=1\n$ flask run\n \n\n> set FLASK_SKIP_DOTENV=1\n> flask run\n \n\n> $env:FLASK_SKIP_DOTENV = 1\n> flask run\n \n Environment Variables From virtualenv If you do not want to install dotenv support, you can still set environment variables by adding them to the end of the virtualenv\u2019s activate script. Activating the virtualenv will set the variables.  \nBashCMDPowershell\n\n\nUnix Bash, venv/bin/activate: $ export FLASK_APP=hello\n \n\nWindows CMD, venv\\Scripts\\activate.bat: > set FLASK_APP=hello\n \n\nWindows Powershell, venv\\Scripts\\activate.ps1: > $env:FLASK_APP = \"hello\"\n \n It is preferred to use dotenv support over this, since .flaskenv can be committed to the repository so that it works automatically wherever the project is checked out. Custom Commands The flask command is implemented using Click. See that project\u2019s documentation for full information about writing commands. This example adds the command create-user that takes the argument name. import click\nfrom flask import Flask\n\napp = Flask(__name__)\n\n@app.cli.command(\"create-user\")\n@click.argument(\"name\")\ndef create_user(name):\n    ...\n $ flask create-user admin\n This example adds the same command, but as user create, a command in a group. This is useful if you want to organize multiple related commands. import click\nfrom flask import Flask\nfrom flask.cli import AppGroup\n\napp = Flask(__name__)\nuser_cli = AppGroup('user')\n\n@user_cli.command('create')\n@click.argument('name')\ndef create_user(name):\n    ...\n\napp.cli.add_command(user_cli)\n $ flask user create demo\n See Testing CLI Commands for an overview of how to test your custom commands. Registering Commands with Blueprints If your application uses blueprints, you can optionally register CLI commands directly onto them. When your blueprint is registered onto your application, the associated commands will be available to the flask command. By default, those commands will be nested in a group matching the name of the blueprint. from flask import Blueprint\n\nbp = Blueprint('students', __name__)\n\n@bp.cli.command('create')\n@click.argument('name')\ndef create(name):\n    ...\n\napp.register_blueprint(bp)\n $ flask students create alice\n You can alter the group name by specifying the cli_group parameter when creating the Blueprint object, or later with app.register_blueprint(bp, cli_group='...'). The following are equivalent: bp = Blueprint('students', __name__, cli_group='other')\n# or\napp.register_blueprint(bp, cli_group='other')\n $ flask other create alice\n Specifying cli_group=None will remove the nesting and merge the commands directly to the application\u2019s level: bp = Blueprint('students', __name__, cli_group=None)\n# or\napp.register_blueprint(bp, cli_group=None)\n $ flask create alice\n Application Context Commands added using the Flask app\u2019s cli command() decorator will be executed with an application context pushed, so your command and extensions have access to the app and its configuration. If you create a command using the Click command() decorator instead of the Flask decorator, you can use with_appcontext() to get the same behavior. import click\nfrom flask.cli import with_appcontext\n\n@click.command()\n@with_appcontext\ndef do_work():\n    ...\n\napp.cli.add_command(do_work)\n If you\u2019re sure a command doesn\u2019t need the context, you can disable it: @app.cli.command(with_appcontext=False)\ndef do_work():\n    ...\n Plugins Flask will automatically load commands specified in the flask.commands entry point. This is useful for extensions that want to add commands when they are installed. Entry points are specified in setup.py from setuptools import setup\n\nsetup(\n    name='flask-my-extension',\n    ...,\n    entry_points={\n        'flask.commands': [\n            'my-command=flask_my_extension.commands:cli'\n        ],\n    },\n)\n Inside flask_my_extension/commands.py you can then export a Click object: import click\n\n@click.command()\ndef cli():\n    ...\n Once that package is installed in the same virtualenv as your Flask project, you can run flask my-command to invoke the command. Custom Scripts When you are using the app factory pattern, it may be more convenient to define your own Click script. Instead of using FLASK_APP and letting Flask load your application, you can create your own Click object and export it as a console script entry point. Create an instance of FlaskGroup and pass it the factory: import click\nfrom flask import Flask\nfrom flask.cli import FlaskGroup\n\ndef create_app():\n    app = Flask('wiki')\n    # other setup\n    return app\n\n@click.group(cls=FlaskGroup, create_app=create_app)\ndef cli():\n    \"\"\"Management script for the Wiki application.\"\"\"\n Define the entry point in setup.py: from setuptools import setup\n\nsetup(\n    name='flask-my-extension',\n    ...,\n    entry_points={\n        'console_scripts': [\n            'wiki=wiki:cli'\n        ],\n    },\n)\n Install the application in the virtualenv in editable mode and the custom script is available. Note that you don\u2019t need to set FLASK_APP. $ pip install -e .\n$ wiki run\n  Errors in Custom Scripts When using a custom script, if you introduce an error in your module-level code, the reloader will fail because it can no longer load the entry point. The flask command, being separate from your code, does not have this issue and is recommended in most cases.  PyCharm Integration PyCharm Professional provides a special Flask run configuration. For the Community Edition, we need to configure it to call the flask run CLI command with the correct environment variables. These instructions should be similar for any other IDE you might want to use. In PyCharm, with your project open, click on Run from the menu bar and go to Edit Configurations. You\u2019ll be greeted by a screen similar to this:  There\u2019s quite a few options to change, but once we\u2019ve done it for one command, we can easily copy the entire configuration and make a single tweak to give us access to other commands, including any custom ones you may implement yourself. Click the + (Add New Configuration) button and select Python. Give the configuration a name such as \u201cflask run\u201d. For the flask run command, check \u201cSingle instance only\u201d since you can\u2019t run the server more than once at the same time. Select Module name from the dropdown (A) then input flask. The Parameters field (B) is set to the CLI command to execute (with any arguments). In this example we use run, which will run the development server. You can skip this next step if you\u2019re using Environment Variables From dotenv. We need to add an environment variable (C) to identify our application. Click on the browse button and add an entry with FLASK_APP on the left and the Python import or file on the right (hello for example). Add an entry with FLASK_ENV and set it to development. Next we need to set the working directory (D) to be the folder where our application resides. If you have installed your project as a package in your virtualenv, you may untick the PYTHONPATH options (E). This will more accurately match how you deploy the app later. Click Apply to save the configuration, or OK to save and close the window. Select the configuration in the main PyCharm window and click the play button next to it to run the server. Now that we have a configuration which runs flask run from within PyCharm, we can copy that configuration and alter the Script argument to run a different CLI command, e.g. flask shell.\n"}, {"name": "Config", "path": "api/index#flask.Config", "type": "flask", "text": " \nclass flask.Config(root_path, defaults=None)  \nWorks exactly like a dict but provides ways to fill it from files or special dictionaries. There are two common patterns to populate the config. Either you can fill the config from a config file: app.config.from_pyfile('yourconfig.cfg')\n Or alternatively you can define the configuration options in the module that calls from_object() or provide an import path to a module that should be loaded. It is also possible to tell it to use the same module and with that provide the configuration values just before the call: DEBUG = True\nSECRET_KEY = 'development key'\napp.config.from_object(__name__)\n In both cases (loading from any Python file or loading from modules), only uppercase keys are added to the config. This makes it possible to use lowercase values in the config file for temporary values that are not added to the config or to define the config keys in the same file that implements the application. Probably the most interesting way to load configurations is from an environment variable pointing to a file: app.config.from_envvar('YOURAPPLICATION_SETTINGS')\n In this case before launching the application you have to set this environment variable to the file you want to use. On Linux and OS X use the export statement: export YOURAPPLICATION_SETTINGS='/path/to/config/file'\n On windows use set instead.  Parameters \n \nroot_path (str) \u2013 path to which files are read relative from. When the config object is created by the application, this is the application\u2019s root_path. \ndefaults (Optional[dict]) \u2013 an optional dictionary of default values   Return type \nNone    \nfrom_envvar(variable_name, silent=False)  \nLoads a configuration from an environment variable pointing to a configuration file. This is basically just a shortcut with nicer error messages for this line of code: app.config.from_pyfile(os.environ['YOURAPPLICATION_SETTINGS'])\n  Parameters \n \nvariable_name (str) \u2013 name of the environment variable \nsilent (bool) \u2013 set to True if you want silent failure for missing files.   Returns \nbool. True if able to load config, False otherwise.  Return type \nbool   \n  \nfrom_file(filename, load, silent=False)  \nUpdate the values in the config from a file that is loaded using the load parameter. The loaded data is passed to the from_mapping() method. import toml\napp.config.from_file(\"config.toml\", load=toml.load)\n  Parameters \n \nfilename (str) \u2013 The path to the data file. This can be an absolute path or relative to the config root path. \nload (Callable[[Reader], Mapping] where Reader implements a read method.) \u2013 A callable that takes a file handle and returns a mapping of loaded data from the file. \nsilent (bool) \u2013 Ignore the file if it doesn\u2019t exist.   Return type \nbool    New in version 2.0.  \n  \nfrom_mapping(mapping=None, **kwargs)  \nUpdates the config like update() ignoring items with non-upper keys.  Changelog New in version 0.11.   Parameters \n \nmapping (Optional[Mapping[str, Any]]) \u2013  \nkwargs (Any) \u2013    Return type \nbool   \n  \nfrom_object(obj)  \nUpdates the values from the given object. An object can be of one of the following two types:  a string: in this case the object with that name will be imported an actual object reference: that object is used directly  Objects are usually either modules or classes. from_object() loads only the uppercase attributes of the module/class. A dict object will not work with from_object() because the keys of a dict are not attributes of the dict class. Example of module-based configuration: app.config.from_object('yourapplication.default_config')\nfrom yourapplication import default_config\napp.config.from_object(default_config)\n Nothing is done to the object before loading. If the object is a class and has @property attributes, it needs to be instantiated before being passed to this method. You should not use this function to load the actual configuration but rather configuration defaults. The actual config should be loaded with from_pyfile() and ideally from a location not within the package because the package might be installed system wide. See Development / Production for an example of class-based configuration using from_object().  Parameters \nobj (Union[object, str]) \u2013 an import name or object  Return type \nNone   \n  \nfrom_pyfile(filename, silent=False)  \nUpdates the values in the config from a Python file. This function behaves as if the file was imported as module with the from_object() function.  Parameters \n \nfilename (str) \u2013 the filename of the config. This can either be an absolute filename or a filename relative to the root path. \nsilent (bool) \u2013 set to True if you want silent failure for missing files.   Return type \nbool    Changelog New in version 0.7: silent parameter.  \n\n  \nget_namespace(namespace, lowercase=True, trim_namespace=True)  \nReturns a dictionary containing a subset of configuration options that match the specified namespace/prefix. Example usage: app.config['IMAGE_STORE_TYPE'] = 'fs'\napp.config['IMAGE_STORE_PATH'] = '/var/app/images'\napp.config['IMAGE_STORE_BASE_URL'] = 'http://img.website.com'\nimage_store_config = app.config.get_namespace('IMAGE_STORE_')\n The resulting dictionary image_store_config would look like: {\n    'type': 'fs',\n    'path': '/var/app/images',\n    'base_url': 'http://img.website.com'\n}\n This is often useful when configuration options map directly to keyword arguments in functions or class constructors.  Parameters \n \nnamespace (str) \u2013 a configuration namespace \nlowercase (bool) \u2013 a flag indicating if the keys of the resulting dictionary should be lowercase \ntrim_namespace (bool) \u2013 a flag indicating if the keys of the resulting dictionary should not include the namespace   Return type \nDict[str, Any]    Changelog New in version 0.11.  \n\n \n"}, {"name": "Config.from_envvar()", "path": "api/index#flask.Config.from_envvar", "type": "flask", "text": " \nfrom_envvar(variable_name, silent=False)  \nLoads a configuration from an environment variable pointing to a configuration file. This is basically just a shortcut with nicer error messages for this line of code: app.config.from_pyfile(os.environ['YOURAPPLICATION_SETTINGS'])\n  Parameters \n \nvariable_name (str) \u2013 name of the environment variable \nsilent (bool) \u2013 set to True if you want silent failure for missing files.   Returns \nbool. True if able to load config, False otherwise.  Return type \nbool   \n"}, {"name": "Config.from_file()", "path": "api/index#flask.Config.from_file", "type": "flask", "text": " \nfrom_file(filename, load, silent=False)  \nUpdate the values in the config from a file that is loaded using the load parameter. The loaded data is passed to the from_mapping() method. import toml\napp.config.from_file(\"config.toml\", load=toml.load)\n  Parameters \n \nfilename (str) \u2013 The path to the data file. This can be an absolute path or relative to the config root path. \nload (Callable[[Reader], Mapping] where Reader implements a read method.) \u2013 A callable that takes a file handle and returns a mapping of loaded data from the file. \nsilent (bool) \u2013 Ignore the file if it doesn\u2019t exist.   Return type \nbool    New in version 2.0.  \n"}, {"name": "Config.from_mapping()", "path": "api/index#flask.Config.from_mapping", "type": "flask", "text": " \nfrom_mapping(mapping=None, **kwargs)  \nUpdates the config like update() ignoring items with non-upper keys.  Changelog New in version 0.11.   Parameters \n \nmapping (Optional[Mapping[str, Any]]) \u2013  \nkwargs (Any) \u2013    Return type \nbool   \n"}, {"name": "Config.from_object()", "path": "api/index#flask.Config.from_object", "type": "flask", "text": " \nfrom_object(obj)  \nUpdates the values from the given object. An object can be of one of the following two types:  a string: in this case the object with that name will be imported an actual object reference: that object is used directly  Objects are usually either modules or classes. from_object() loads only the uppercase attributes of the module/class. A dict object will not work with from_object() because the keys of a dict are not attributes of the dict class. Example of module-based configuration: app.config.from_object('yourapplication.default_config')\nfrom yourapplication import default_config\napp.config.from_object(default_config)\n Nothing is done to the object before loading. If the object is a class and has @property attributes, it needs to be instantiated before being passed to this method. You should not use this function to load the actual configuration but rather configuration defaults. The actual config should be loaded with from_pyfile() and ideally from a location not within the package because the package might be installed system wide. See Development / Production for an example of class-based configuration using from_object().  Parameters \nobj (Union[object, str]) \u2013 an import name or object  Return type \nNone   \n"}, {"name": "Config.from_pyfile()", "path": "api/index#flask.Config.from_pyfile", "type": "flask", "text": " \nfrom_pyfile(filename, silent=False)  \nUpdates the values in the config from a Python file. This function behaves as if the file was imported as module with the from_object() function.  Parameters \n \nfilename (str) \u2013 the filename of the config. This can either be an absolute filename or a filename relative to the root path. \nsilent (bool) \u2013 set to True if you want silent failure for missing files.   Return type \nbool    Changelog New in version 0.7: silent parameter.  \n\n"}, {"name": "Config.get_namespace()", "path": "api/index#flask.Config.get_namespace", "type": "flask", "text": " \nget_namespace(namespace, lowercase=True, trim_namespace=True)  \nReturns a dictionary containing a subset of configuration options that match the specified namespace/prefix. Example usage: app.config['IMAGE_STORE_TYPE'] = 'fs'\napp.config['IMAGE_STORE_PATH'] = '/var/app/images'\napp.config['IMAGE_STORE_BASE_URL'] = 'http://img.website.com'\nimage_store_config = app.config.get_namespace('IMAGE_STORE_')\n The resulting dictionary image_store_config would look like: {\n    'type': 'fs',\n    'path': '/var/app/images',\n    'base_url': 'http://img.website.com'\n}\n This is often useful when configuration options map directly to keyword arguments in functions or class constructors.  Parameters \n \nnamespace (str) \u2013 a configuration namespace \nlowercase (bool) \u2013 a flag indicating if the keys of the resulting dictionary should be lowercase \ntrim_namespace (bool) \u2013 a flag indicating if the keys of the resulting dictionary should not include the namespace   Return type \nDict[str, Any]    Changelog New in version 0.11.  \n\n"}, {"name": "Configuration Handling", "path": "config/index", "type": "User\u2019s Guide", "text": "Configuration Handling Applications need some kind of configuration. There are different settings you might want to change depending on the application environment like toggling the debug mode, setting the secret key, and other such environment-specific things. The way Flask is designed usually requires the configuration to be available when the application starts up. You can hard code the configuration in the code, which for many small applications is not actually that bad, but there are better ways. Independent of how you load your config, there is a config object available which holds the loaded configuration values: The config attribute of the Flask object. This is the place where Flask itself puts certain configuration values and also where extensions can put their configuration values. But this is also where you can have your own configuration. Configuration Basics The config is actually a subclass of a dictionary and can be modified just like any dictionary: app = Flask(__name__)\napp.config['TESTING'] = True\n Certain configuration values are also forwarded to the Flask object so you can read and write them from there: app.testing = True\n To update multiple keys at once you can use the dict.update() method: app.config.update(\n    TESTING=True,\n    SECRET_KEY=b'_5#y2L\"F4Q8z\\n\\xec]/'\n)\n Environment and Debug Features The ENV and DEBUG config values are special because they may behave inconsistently if changed after the app has begun setting up. In order to set the environment and debug mode reliably, Flask uses environment variables. The environment is used to indicate to Flask, extensions, and other programs, like Sentry, what context Flask is running in. It is controlled with the FLASK_ENV environment variable and defaults to production. Setting FLASK_ENV to development will enable debug mode. flask run will use the interactive debugger and reloader by default in debug mode. To control this separately from the environment, use the FLASK_DEBUG flag.  Changelog Changed in version 1.0: Added FLASK_ENV to control the environment separately from debug mode. The development environment enables debug mode.  To switch Flask to the development environment and enable debug mode, set FLASK_ENV:  \nBashCMDPowershell\n\n\n$ export FLASK_ENV=development\n$ flask run\n \n\n> set FLASK_ENV=development\n> flask run\n \n\n> $env:FLASK_ENV = \"development\"\n> flask run\n \n Using the environment variables as described above is recommended. While it is possible to set ENV and DEBUG in your config or code, this is strongly discouraged. They can\u2019t be read early by the flask command, and some systems or extensions may have already configured themselves based on a previous value. Builtin Configuration Values The following configuration values are used internally by Flask:  \nENV  \nWhat environment the app is running in. Flask and extensions may enable behaviors based on the environment, such as enabling debug mode. The env attribute maps to this config key. This is set by the FLASK_ENV environment variable and may not behave as expected if set in code. Do not enable development when deploying in production. Default: 'production'  Changelog New in version 1.0.  \n\n  \nDEBUG  \nWhether debug mode is enabled. When using flask run to start the development server, an interactive debugger will be shown for unhandled exceptions, and the server will be reloaded when code changes. The debug attribute maps to this config key. This is enabled when ENV is 'development' and is overridden by the FLASK_DEBUG environment variable. It may not behave as expected if set in code. Do not enable debug mode when deploying in production. Default: True if ENV is 'development', or False otherwise. \n  \nTESTING  \nEnable testing mode. Exceptions are propagated rather than handled by the the app\u2019s error handlers. Extensions may also change their behavior to facilitate easier testing. You should enable this in your own tests. Default: False \n  \nPROPAGATE_EXCEPTIONS  \nExceptions are re-raised rather than being handled by the app\u2019s error handlers. If not set, this is implicitly true if TESTING or DEBUG is enabled. Default: None \n  \nPRESERVE_CONTEXT_ON_EXCEPTION  \nDon\u2019t pop the request context when an exception occurs. If not set, this is true if DEBUG is true. This allows debuggers to introspect the request data on errors, and should normally not need to be set directly. Default: None \n  \nTRAP_HTTP_EXCEPTIONS  \nIf there is no handler for an HTTPException-type exception, re-raise it to be handled by the interactive debugger instead of returning it as a simple error response. Default: False \n  \nTRAP_BAD_REQUEST_ERRORS  \nTrying to access a key that doesn\u2019t exist from request dicts like args and form will return a 400 Bad Request error page. Enable this to treat the error as an unhandled exception instead so that you get the interactive debugger. This is a more specific version of TRAP_HTTP_EXCEPTIONS. If unset, it is enabled in debug mode. Default: None \n  \nSECRET_KEY  \nA secret key that will be used for securely signing the session cookie and can be used for any other security related needs by extensions or your application. It should be a long random bytes or str. For example, copy the output of this to your config: $ python -c 'import os; print(os.urandom(16))'\nb'_5#y2L\"F4Q8z\\n\\xec]/'\n Do not reveal the secret key when posting questions or committing code. Default: None \n  \nSESSION_COOKIE_NAME  \nThe name of the session cookie. Can be changed in case you already have a cookie with the same name. Default: 'session' \n  \nSESSION_COOKIE_DOMAIN  \nThe domain match rule that the session cookie will be valid for. If not set, the cookie will be valid for all subdomains of SERVER_NAME. If False, the cookie\u2019s domain will not be set. Default: None \n  \nSESSION_COOKIE_PATH  \nThe path that the session cookie will be valid for. If not set, the cookie will be valid underneath APPLICATION_ROOT or / if that is not set. Default: None \n  \nSESSION_COOKIE_HTTPONLY  \nBrowsers will not allow JavaScript access to cookies marked as \u201cHTTP only\u201d for security. Default: True \n  \nSESSION_COOKIE_SECURE  \nBrowsers will only send cookies with requests over HTTPS if the cookie is marked \u201csecure\u201d. The application must be served over HTTPS for this to make sense. Default: False \n  \nSESSION_COOKIE_SAMESITE  \nRestrict how cookies are sent with requests from external sites. Can be set to 'Lax' (recommended) or 'Strict'. See Set-Cookie options. Default: None  Changelog New in version 1.0.  \n\n  \nPERMANENT_SESSION_LIFETIME  \nIf session.permanent is true, the cookie\u2019s expiration will be set this number of seconds in the future. Can either be a datetime.timedelta or an int. Flask\u2019s default cookie implementation validates that the cryptographic signature is not older than this value. Default: timedelta(days=31) (2678400 seconds) \n  \nSESSION_REFRESH_EACH_REQUEST  \nControl whether the cookie is sent with every response when session.permanent is true. Sending the cookie every time (the default) can more reliably keep the session from expiring, but uses more bandwidth. Non-permanent sessions are not affected. Default: True \n  \nUSE_X_SENDFILE  \nWhen serving files, set the X-Sendfile header instead of serving the data with Flask. Some web servers, such as Apache, recognize this and serve the data more efficiently. This only makes sense when using such a server. Default: False \n  \nSEND_FILE_MAX_AGE_DEFAULT  \nWhen serving files, set the cache control max age to this number of seconds. Can be a datetime.timedelta or an int. Override this value on a per-file basis using get_send_file_max_age() on the application or blueprint. If None, send_file tells the browser to use conditional requests will be used instead of a timed cache, which is usually preferable. Default: None \n  \nSERVER_NAME  \nInform the application what host and port it is bound to. Required for subdomain route matching support. If set, will be used for the session cookie domain if SESSION_COOKIE_DOMAIN is not set. Modern web browsers will not allow setting cookies for domains without a dot. To use a domain locally, add any names that should route to the app to your hosts file. 127.0.0.1 localhost.dev\n If set, url_for can generate external URLs with only an application context instead of a request context. Default: None \n  \nAPPLICATION_ROOT  \nInform the application what path it is mounted under by the application / web server. This is used for generating URLs outside the context of a request (inside a request, the dispatcher is responsible for setting SCRIPT_NAME instead; see Application Dispatching for examples of dispatch configuration). Will be used for the session cookie path if SESSION_COOKIE_PATH is not set. Default: '/' \n  \nPREFERRED_URL_SCHEME  \nUse this scheme for generating external URLs when not in a request context. Default: 'http' \n  \nMAX_CONTENT_LENGTH  \nDon\u2019t read more than this many bytes from the incoming request data. If not set and the request does not specify a CONTENT_LENGTH, no data will be read for security. Default: None \n  \nJSON_AS_ASCII  \nSerialize objects to ASCII-encoded JSON. If this is disabled, the JSON returned from jsonify will contain Unicode characters. This has security implications when rendering the JSON into JavaScript in templates, and should typically remain enabled. Default: True \n  \nJSON_SORT_KEYS  \nSort the keys of JSON objects alphabetically. This is useful for caching because it ensures the data is serialized the same way no matter what Python\u2019s hash seed is. While not recommended, you can disable this for a possible performance improvement at the cost of caching. Default: True \n  \nJSONIFY_PRETTYPRINT_REGULAR  \njsonify responses will be output with newlines, spaces, and indentation for easier reading by humans. Always enabled in debug mode. Default: False \n  \nJSONIFY_MIMETYPE  \nThe mimetype of jsonify responses. Default: 'application/json' \n  \nTEMPLATES_AUTO_RELOAD  \nReload templates when they are changed. If not set, it will be enabled in debug mode. Default: None \n  \nEXPLAIN_TEMPLATE_LOADING  \nLog debugging information tracing how a template file was loaded. This can be useful to figure out why a template was not loaded or the wrong file appears to be loaded. Default: False \n  \nMAX_COOKIE_SIZE  \nWarn if cookie headers are larger than this many bytes. Defaults to 4093. Larger cookies may be silently ignored by browsers. Set to 0 to disable the warning. \n  Changelog Changed in version 1.0: LOGGER_NAME and LOGGER_HANDLER_POLICY were removed. See Logging for information about configuration. Added ENV to reflect the FLASK_ENV environment variable. Added SESSION_COOKIE_SAMESITE to control the session cookie\u2019s SameSite option. Added MAX_COOKIE_SIZE to control a warning from Werkzeug.   New in version 0.11: SESSION_REFRESH_EACH_REQUEST, TEMPLATES_AUTO_RELOAD, LOGGER_HANDLER_POLICY, EXPLAIN_TEMPLATE_LOADING   New in version 0.10: JSON_AS_ASCII, JSON_SORT_KEYS, JSONIFY_PRETTYPRINT_REGULAR   New in version 0.9: PREFERRED_URL_SCHEME   New in version 0.8: TRAP_BAD_REQUEST_ERRORS, TRAP_HTTP_EXCEPTIONS, APPLICATION_ROOT, SESSION_COOKIE_DOMAIN, SESSION_COOKIE_PATH, SESSION_COOKIE_HTTPONLY, SESSION_COOKIE_SECURE   New in version 0.7: PROPAGATE_EXCEPTIONS, PRESERVE_CONTEXT_ON_EXCEPTION   New in version 0.6: MAX_CONTENT_LENGTH   New in version 0.5: SERVER_NAME   New in version 0.4: LOGGER_NAME   Configuring from Python Files Configuration becomes more useful if you can store it in a separate file, ideally located outside the actual application package. This makes packaging and distributing your application possible via various package handling tools (Deploying with Setuptools) and finally modifying the configuration file afterwards. So a common pattern is this: app = Flask(__name__)\napp.config.from_object('yourapplication.default_settings')\napp.config.from_envvar('YOURAPPLICATION_SETTINGS')\n This first loads the configuration from the yourapplication.default_settings module and then overrides the values with the contents of the file the YOURAPPLICATION_SETTINGS environment variable points to. This environment variable can be set in the shell before starting the server:  \nBashCMDPowershell\n\n\n$ export YOURAPPLICATION_SETTINGS=/path/to/settings.cfg\n$ flask run\n * Running on http://127.0.0.1:5000/\n \n\n> set YOURAPPLICATION_SETTINGS=\\path\\to\\settings.cfg\n> flask run\n * Running on http://127.0.0.1:5000/\n \n\n> $env:YOURAPPLICATION_SETTINGS = \"\\path\\to\\settings.cfg\"\n> flask run\n * Running on http://127.0.0.1:5000/\n \n The configuration files themselves are actual Python files. Only values in uppercase are actually stored in the config object later on. So make sure to use uppercase letters for your config keys. Here is an example of a configuration file: # Example configuration\nSECRET_KEY = b'_5#y2L\"F4Q8z\\n\\xec]/'\n Make sure to load the configuration very early on, so that extensions have the ability to access the configuration when starting up. There are other methods on the config object as well to load from individual files. For a complete reference, read the Config object\u2019s documentation. Configuring from Data Files It is also possible to load configuration from a file in a format of your choice using from_file(). For example to load from a TOML file: import toml\napp.config.from_file(\"config.toml\", load=toml.load)\n Or from a JSON file: import json\napp.config.from_file(\"config.json\", load=json.load)\n Configuring from Environment Variables In addition to pointing to configuration files using environment variables, you may find it useful (or necessary) to control your configuration values directly from the environment. Environment variables can be set in the shell before starting the server:  \nBashCMDPowershell\n\n\n$ export SECRET_KEY=\"5f352379324c22463451387a0aec5d2f\"\n$ export MAIL_ENABLED=false\n$ flask run\n * Running on http://127.0.0.1:5000/\n \n\n> set SECRET_KEY=\"5f352379324c22463451387a0aec5d2f\"\n> set MAIL_ENABLED=false\n> flask run\n * Running on http://127.0.0.1:5000/\n \n\n> $env:SECRET_KEY = \"5f352379324c22463451387a0aec5d2f\"\n> $env:MAIL_ENABLED = \"false\"\n> flask run\n * Running on http://127.0.0.1:5000/\n \n While this approach is straightforward to use, it is important to remember that environment variables are strings \u2013 they are not automatically deserialized into Python types. Here is an example of a configuration file that uses environment variables: import os\n\n_mail_enabled = os.environ.get(\"MAIL_ENABLED\", default=\"true\")\nMAIL_ENABLED = _mail_enabled.lower() in {\"1\", \"t\", \"true\"}\n\nSECRET_KEY = os.environ.get(\"SECRET_KEY\")\n\nif not SECRET_KEY:\n    raise ValueError(\"No SECRET_KEY set for Flask application\")\n Notice that any value besides an empty string will be interpreted as a boolean True value in Python, which requires care if an environment explicitly sets values intended to be False. Make sure to load the configuration very early on, so that extensions have the ability to access the configuration when starting up. There are other methods on the config object as well to load from individual files. For a complete reference, read the Config class documentation. Configuration Best Practices The downside with the approach mentioned earlier is that it makes testing a little harder. There is no single 100% solution for this problem in general, but there are a couple of things you can keep in mind to improve that experience:  Create your application in a function and register blueprints on it. That way you can create multiple instances of your application with different configurations attached which makes unit testing a lot easier. You can use this to pass in configuration as needed. Do not write code that needs the configuration at import time. If you limit yourself to request-only accesses to the configuration you can reconfigure the object later on as needed.  Development / Production Most applications need more than one configuration. There should be at least separate configurations for the production server and the one used during development. The easiest way to handle this is to use a default configuration that is always loaded and part of the version control, and a separate configuration that overrides the values as necessary as mentioned in the example above: app = Flask(__name__)\napp.config.from_object('yourapplication.default_settings')\napp.config.from_envvar('YOURAPPLICATION_SETTINGS')\n Then you just have to add a separate config.py file and export YOURAPPLICATION_SETTINGS=/path/to/config.py and you are done. However there are alternative ways as well. For example you could use imports or subclassing. What is very popular in the Django world is to make the import explicit in the config file by adding from yourapplication.default_settings\nimport * to the top of the file and then overriding the changes by hand. You could also inspect an environment variable like YOURAPPLICATION_MODE and set that to production, development etc and import different hard-coded files based on that. An interesting pattern is also to use classes and inheritance for configuration: class Config(object):\n    TESTING = False\n\nclass ProductionConfig(Config):\n    DATABASE_URI = 'mysql://user@localhost/foo'\n\nclass DevelopmentConfig(Config):\n    DATABASE_URI = \"sqlite:////tmp/foo.db\"\n\nclass TestingConfig(Config):\n    DATABASE_URI = 'sqlite:///:memory:'\n    TESTING = True\n To enable such a config you just have to call into from_object(): app.config.from_object('configmodule.ProductionConfig')\n Note that from_object() does not instantiate the class object. If you need to instantiate the class, such as to access a property, then you must do so before calling from_object(): from configmodule import ProductionConfig\napp.config.from_object(ProductionConfig())\n\n# Alternatively, import via string:\nfrom werkzeug.utils import import_string\ncfg = import_string('configmodule.ProductionConfig')()\napp.config.from_object(cfg)\n Instantiating the configuration object allows you to use @property in your configuration classes: class Config(object):\n    \"\"\"Base config, uses staging database server.\"\"\"\n    TESTING = False\n    DB_SERVER = '192.168.1.56'\n\n    @property\n    def DATABASE_URI(self):  # Note: all caps\n        return f\"mysql://user@{self.DB_SERVER}/foo\"\n\nclass ProductionConfig(Config):\n    \"\"\"Uses production database server.\"\"\"\n    DB_SERVER = '192.168.19.32'\n\nclass DevelopmentConfig(Config):\n    DB_SERVER = 'localhost'\n\nclass TestingConfig(Config):\n    DB_SERVER = 'localhost'\n    DATABASE_URI = 'sqlite:///:memory:'\n There are many different ways and it\u2019s up to you how you want to manage your configuration files. However here a list of good recommendations:  Keep a default configuration in version control. Either populate the config with this default configuration or import it in your own configuration files before overriding values. Use an environment variable to switch between the configurations. This can be done from outside the Python interpreter and makes development and deployment much easier because you can quickly and easily switch between different configs without having to touch the code at all. If you are working often on different projects you can even create your own script for sourcing that activates a virtualenv and exports the development configuration for you. Use a tool like fabric in production to push code and configurations separately to the production server(s). For some details about how to do that, head over to the Deploying with Fabric pattern.  Instance Folders  Changelog New in version 0.8.  Flask 0.8 introduces instance folders. Flask for a long time made it possible to refer to paths relative to the application\u2019s folder directly (via Flask.root_path). This was also how many developers loaded configurations stored next to the application. Unfortunately however this only works well if applications are not packages in which case the root path refers to the contents of the package. With Flask 0.8 a new attribute was introduced: Flask.instance_path. It refers to a new concept called the \u201cinstance folder\u201d. The instance folder is designed to not be under version control and be deployment specific. It\u2019s the perfect place to drop things that either change at runtime or configuration files. You can either explicitly provide the path of the instance folder when creating the Flask application or you can let Flask autodetect the instance folder. For explicit configuration use the instance_path parameter: app = Flask(__name__, instance_path='/path/to/instance/folder')\n Please keep in mind that this path must be absolute when provided. If the instance_path parameter is not provided the following default locations are used:  \nUninstalled module: /myapp.py\n/instance\n  \nUninstalled package: /myapp\n    /__init__.py\n/instance\n  \nInstalled module or package: $PREFIX/lib/pythonX.Y/site-packages/myapp\n$PREFIX/var/myapp-instance\n $PREFIX is the prefix of your Python installation. This can be /usr or the path to your virtualenv. You can print the value of sys.prefix to see what the prefix is set to.   Since the config object provided loading of configuration files from relative filenames we made it possible to change the loading via filenames to be relative to the instance path if wanted. The behavior of relative paths in config files can be flipped between \u201crelative to the application root\u201d (the default) to \u201crelative to instance folder\u201d via the instance_relative_config switch to the application constructor: app = Flask(__name__, instance_relative_config=True)\n Here is a full example of how to configure Flask to preload the config from a module and then override the config from a file in the instance folder if it exists: app = Flask(__name__, instance_relative_config=True)\napp.config.from_object('yourapplication.default_settings')\napp.config.from_pyfile('application.cfg', silent=True)\n The path to the instance folder can be found via the Flask.instance_path. Flask also provides a shortcut to open a file from the instance folder with Flask.open_instance_resource(). Example usage for both: filename = os.path.join(app.instance_path, 'application.cfg')\nwith open(filename) as f:\n    config = f.read()\n\n# or via open_instance_resource:\nwith app.open_instance_resource('application.cfg') as f:\n    config = f.read()\n\n"}, {"name": "copy_current_request_context()", "path": "api/index#flask.copy_current_request_context", "type": "flask", "text": " \nflask.copy_current_request_context(f)  \nA helper function that decorates a function to retain the current request context. This is useful when working with greenlets. The moment the function is decorated a copy of the request context is created and then pushed when the function is called. The current session is also included in the copied request context. Example: import gevent\nfrom flask import copy_current_request_context\n\n@app.route('/')\ndef index():\n    @copy_current_request_context\n    def do_some_work():\n        # do some work here, it can access flask.request or\n        # flask.session like you would otherwise in the view function.\n        ...\n    gevent.spawn(do_some_work)\n    return 'Regular response'\n  Changelog New in version 0.10.   Parameters \nf (Callable) \u2013   Return type \nCallable   \n"}, {"name": "DEBUG", "path": "config/index#DEBUG", "type": "Configuration", "text": " \nDEBUG  \nWhether debug mode is enabled. When using flask run to start the development server, an interactive debugger will be shown for unhandled exceptions, and the server will be reloaded when code changes. The debug attribute maps to this config key. This is enabled when ENV is 'development' and is overridden by the FLASK_DEBUG environment variable. It may not behave as expected if set in code. Do not enable debug mode when deploying in production. Default: True if ENV is 'development', or False otherwise. \n"}, {"name": "Debugging Application Errors", "path": "debugging/index", "type": "User\u2019s Guide", "text": "Debugging Application Errors In Production Do not run the development server, or enable the built-in debugger, in a production environment. The debugger allows executing arbitrary Python code from the browser. It\u2019s protected by a pin, but that should not be relied on for security. Use an error logging tool, such as Sentry, as described in Error Logging Tools, or enable logging and notifications as described in Logging. If you have access to the server, you could add some code to start an external debugger if request.remote_addr matches your IP. Some IDE debuggers also have a remote mode so breakpoints on the server can be interacted with locally. Only enable a debugger temporarily. The Built-In Debugger The built-in Werkzeug development server provides a debugger which shows an interactive traceback in the browser when an unhandled error occurs during a request. This debugger should only be used during development.   Warning The debugger allows executing arbitrary Python code from the browser. It is protected by a pin, but still represents a major security risk. Do not run the development server or debugger in a production environment.  To enable the debugger, run the development server with the FLASK_ENV environment variable set to development. This puts Flask in debug mode, which changes how it handles some errors, and enables the debugger and reloader.  \nBashCMDPowershell\n\n\n$ export FLASK_ENV=development\n$ flask run\n \n\n> set FLASK_ENV=development\n> flask run\n \n\n> $env:FLASK_ENV = \"development\"\n> flask run\n \n FLASK_ENV can only be set as an environment variable. When running from Python code, passing debug=True enables debug mode, which is mostly equivalent. Debug mode can be controled separately from FLASK_ENV with the FLASK_DEBUG environment variable as well. app.run(debug=True)\n Development Server and Command Line Interface have more information about running the debugger, debug mode, and development mode. More information about the debugger can be found in the Werkzeug documentation. External Debuggers External debuggers, such as those provided by IDEs, can offer a more powerful debugging experience than the built-in debugger. They can also be used to step through code during a request before an error is raised, or if no error is raised. Some even have a remote mode so you can debug code running on another machine. When using an external debugger, the app should still be in debug mode, but it can be useful to disable the built-in debugger and reloader, which can interfere. When running from the command line:  \nBashCMDPowershell\n\n\n$ export FLASK_ENV=development\n$ flask run --no-debugger --no-reload\n \n\n> set FLASK_ENV=development\n> flask run --no-debugger --no-reload\n \n\n> $env:FLASK_ENV = \"development\"\n> flask run --no-debugger --no-reload\n \n When running from Python: app.run(debug=True, use_debugger=False, use_reloader=False)\n Disabling these isn\u2019t required, an external debugger will continue to work with the following caveats. If the built-in debugger is not disabled, it will catch unhandled exceptions before the external debugger can. If the reloader is not disabled, it could cause an unexpected reload if code changes during debugging.\n"}, {"name": "Deferred Request Callbacks", "path": "patterns/deferredcallbacks/index", "type": "User's Guide: Design Patterns", "text": "Deferred Request Callbacks One of the design principles of Flask is that response objects are created and passed down a chain of potential callbacks that can modify them or replace them. When the request handling starts, there is no response object yet. It is created as necessary either by a view function or by some other component in the system. What happens if you want to modify the response at a point where the response does not exist yet? A common example for that would be a before_request() callback that wants to set a cookie on the response object. One way is to avoid the situation. Very often that is possible. For instance you can try to move that logic into a after_request() callback instead. However, sometimes moving code there makes it more complicated or awkward to reason about. As an alternative, you can use after_this_request() to register callbacks that will execute after only the current request. This way you can defer code execution from anywhere in the application, based on the current request. At any time during a request, we can register a function to be called at the end of the request. For example you can remember the current language of the user in a cookie in a before_request() callback: from flask import request, after_this_request\n\n@app.before_request\ndef detect_user_language():\n    language = request.cookies.get('user_lang')\n\n    if language is None:\n        language = guess_language_from_request()\n\n        # when the response exists, set a cookie with the language\n        @after_this_request\n        def remember_language(response):\n            response.set_cookie('user_lang', language)\n            return response\n\n    g.language = language\n\n"}, {"name": "Deploying with Fabric", "path": "patterns/fabric/index", "type": "User's Guide: Design Patterns", "text": "Deploying with Fabric Fabric is a tool for Python similar to Makefiles but with the ability to execute commands on a remote server. In combination with a properly set up Python package (Large Applications as Packages) and a good concept for configurations (Configuration Handling) it is very easy to deploy Flask applications to external servers. Before we get started, here a quick checklist of things we have to ensure upfront:  Fabric 1.0 has to be installed locally. This tutorial assumes the latest version of Fabric. The application already has to be a package and requires a working setup.py file (Deploying with Setuptools). In the following example we are using mod_wsgi for the remote servers. You can of course use your own favourite server there, but for this example we chose Apache + mod_wsgi because it\u2019s very easy to setup and has a simple way to reload applications without root access.  Creating the first Fabfile A fabfile is what controls what Fabric executes. It is named fabfile.py and executed by the fab command. All the functions defined in that file will show up as fab subcommands. They are executed on one or more hosts. These hosts can be defined either in the fabfile or on the command line. In this case we will add them to the fabfile. This is a basic first example that has the ability to upload the current source code to the server and install it into a pre-existing virtual environment: from fabric.api import *\n\n# the user to use for the remote commands\nenv.user = 'appuser'\n# the servers where the commands are executed\nenv.hosts = ['server1.example.com', 'server2.example.com']\n\ndef pack():\n    # build the package\n    local('python setup.py sdist --formats=gztar', capture=False)\n\ndef deploy():\n    # figure out the package name and version\n    dist = local('python setup.py --fullname', capture=True).strip()\n    filename = f'{dist}.tar.gz'\n\n    # upload the package to the temporary folder on the server\n    put(f'dist/{filename}', f'/tmp/{filename}')\n\n    # install the package in the application's virtualenv with pip\n    run(f'/var/www/yourapplication/env/bin/pip install /tmp/{filename}')\n\n    # remove the uploaded package\n    run(f'rm -r /tmp/{filename}')\n\n    # touch the .wsgi file to trigger a reload in mod_wsgi\n    run('touch /var/www/yourapplication.wsgi')\n Running Fabfiles Now how do you execute that fabfile? You use the fab command. To deploy the current version of the code on the remote server you would use this command: $ fab pack deploy\n However this requires that our server already has the /var/www/yourapplication folder created and /var/www/yourapplication/env to be a virtual environment. Furthermore are we not creating the configuration or .wsgi file on the server. So how do we bootstrap a new server into our infrastructure? This now depends on the number of servers we want to set up. If we just have one application server (which the majority of applications will have), creating a command in the fabfile for this is overkill. But obviously you can do that. In that case you would probably call it setup or bootstrap and then pass the servername explicitly on the command line: $ fab -H newserver.example.com bootstrap\n To setup a new server you would roughly do these steps:  \nCreate the directory structure in /var/www: $ mkdir /var/www/yourapplication\n$ cd /var/www/yourapplication\n$ virtualenv --distribute env\n  Upload a new application.wsgi file to the server and the configuration file for the application (eg: application.cfg) Create a new Apache config for yourapplication and activate it. Make sure to activate watching for changes of the .wsgi file so that we can automatically reload the application by touching it. See mod_wsgi (Apache).  So now the question is, where do the application.wsgi and application.cfg files come from? The WSGI File The WSGI file has to import the application and also to set an environment variable so that the application knows where to look for the config. This is a short example that does exactly that: import os\nos.environ['YOURAPPLICATION_CONFIG'] = '/var/www/yourapplication/application.cfg'\nfrom yourapplication import app\n The application itself then has to initialize itself like this to look for the config at that environment variable: app = Flask(__name__)\napp.config.from_object('yourapplication.default_config')\napp.config.from_envvar('YOURAPPLICATION_CONFIG')\n This approach is explained in detail in the Configuration Handling section of the documentation. The Configuration File Now as mentioned above, the application will find the correct configuration file by looking up the YOURAPPLICATION_CONFIG environment variable. So we have to put the configuration in a place where the application will able to find it. Configuration files have the unfriendly quality of being different on all computers, so you do not version them usually. A popular approach is to store configuration files for different servers in a separate version control repository and check them out on all servers. Then symlink the file that is active for the server into the location where it\u2019s expected (eg: /var/www/yourapplication). Either way, in our case here we only expect one or two servers and we can upload them ahead of time by hand. First Deployment Now we can do our first deployment. We have set up the servers so that they have their virtual environments and activated apache configs. Now we can pack up the application and deploy it: $ fab pack deploy\n Fabric will now connect to all servers and run the commands as written down in the fabfile. First it will execute pack so that we have our tarball ready and then it will execute deploy and upload the source code to all servers and install it there. Thanks to the setup.py file we will automatically pull in the required libraries into our virtual environment. Next Steps From that point onwards there is so much that can be done to make deployment actually fun:  Create a bootstrap command that initializes new servers. It could initialize a new virtual environment, setup apache appropriately etc. Put configuration files into a separate version control repository and symlink the active configs into place. You could also put your application code into a repository and check out the latest version on the server and then install. That way you can also easily go back to older versions. hook in testing functionality so that you can deploy to an external server and run the test suite.  Working with Fabric is fun and you will notice that it\u2019s quite magical to type fab deploy and see your application being deployed automatically to one or more remote servers.\n"}, {"name": "Deploying with Setuptools", "path": "patterns/distribute/index", "type": "User's Guide: Design Patterns", "text": "Deploying with Setuptools Setuptools, is an extension library that is commonly used to distribute Python libraries and extensions. It extends distutils, a basic module installation system shipped with Python to also support various more complex constructs that make larger applications easier to distribute:  \nsupport for dependencies: a library or application can declare a list of other libraries it depends on which will be installed automatically for you. \npackage registry: setuptools registers your package with your Python installation. This makes it possible to query information provided by one package from another package. The best known feature of this system is the entry point support which allows one package to declare an \u201centry point\u201d that another package can hook into to extend the other package. \ninstallation manager: pip can install other libraries for you.  Flask itself, and all the libraries you can find on PyPI are distributed with either setuptools or distutils. In this case we assume your application is called yourapplication.py and you are not using a module, but a package. If you have not yet converted your application into a package, head over to Large Applications as Packages to see how this can be done. A working deployment with setuptools is the first step into more complex and more automated deployment scenarios. If you want to fully automate the process, also read the Deploying with Fabric chapter. Basic Setup Script Because you have Flask installed, you have setuptools available on your system. Flask already depends upon setuptools. Standard disclaimer applies: use a virtualenv. Your setup code always goes into a file named setup.py next to your application. The name of the file is only convention, but because everybody will look for a file with that name, you better not change it. A basic setup.py file for a Flask application looks like this: from setuptools import setup\n\nsetup(\n    name='Your Application',\n    version='1.0',\n    long_description=__doc__,\n    packages=['yourapplication'],\n    include_package_data=True,\n    zip_safe=False,\n    install_requires=['Flask']\n)\n Please keep in mind that you have to list subpackages explicitly. If you want setuptools to lookup the packages for you automatically, you can use the find_packages function: from setuptools import setup, find_packages\n\nsetup(\n    ...\n    packages=find_packages()\n)\n Most parameters to the setup function should be self explanatory, include_package_data and zip_safe might not be. include_package_data tells setuptools to look for a MANIFEST.in file and install all the entries that match as package data. We will use this to distribute the static files and templates along with the Python module (see Distributing Resources). The zip_safe flag can be used to force or prevent zip Archive creation. In general you probably don\u2019t want your packages to be installed as zip files because some tools do not support them and they make debugging a lot harder. Tagging Builds It is useful to distinguish between release and development builds. Add a setup.cfg file to configure these options. [egg_info]\ntag_build = .dev\ntag_date = 1\n\n[aliases]\nrelease = egg_info -Db ''\n Running python setup.py sdist will create a development package with \u201c.dev\u201d and the current date appended: flaskr-1.0.dev20160314.tar.gz. Running python setup.py release sdist will create a release package with only the version: flaskr-1.0.tar.gz. Distributing Resources If you try to install the package you just created, you will notice that folders like static or templates are not installed for you. The reason for this is that setuptools does not know which files to add for you. What you should do, is to create a MANIFEST.in file next to your setup.py file. This file lists all the files that should be added to your tarball: recursive-include yourapplication/templates *\nrecursive-include yourapplication/static *\n Don\u2019t forget that even if you enlist them in your MANIFEST.in file, they won\u2019t be installed for you unless you set the include_package_data parameter of the setup function to True! Declaring Dependencies Dependencies are declared in the install_requires parameter as a list. Each item in that list is the name of a package that should be pulled from PyPI on installation. By default it will always use the most recent version, but you can also provide minimum and maximum version requirements. Here some examples: install_requires=[\n    'Flask>=0.2',\n    'SQLAlchemy>=0.6',\n    'BrokenPackage>=0.7,<=1.0'\n]\n As mentioned earlier, dependencies are pulled from PyPI. What if you want to depend on a package that cannot be found on PyPI and won\u2019t be because it is an internal package you don\u2019t want to share with anyone? Just do it as if there was a PyPI entry and provide a list of alternative locations where setuptools should look for tarballs: dependency_links=['http://example.com/yourfiles']\n Make sure that page has a directory listing and the links on the page are pointing to the actual tarballs with their correct filenames as this is how setuptools will find the files. If you have an internal company server that contains the packages, provide the URL to that server. Installing / Developing To install your application (ideally into a virtualenv) just run the setup.py script with the install parameter. It will install your application into the virtualenv\u2019s site-packages folder and also download and install all dependencies: $ python setup.py install\n If you are developing on the package and also want the requirements to be installed, you can use the develop command instead: $ python setup.py develop\n This has the advantage of just installing a link to the site-packages folder instead of copying the data over. You can then continue to work on the code without having to run install again after each change.\n"}, {"name": "Deployment Options", "path": "deploying/index", "type": "User's Guide: Deploying", "text": "Deployment Options While lightweight and easy to use, Flask\u2019s built-in server is not suitable for production as it doesn\u2019t scale well. Some of the options available for properly running Flask in production are documented here. If you want to deploy your Flask application to a WSGI server not listed here, look up the server documentation about how to use a WSGI app with it. Just remember that your Flask application object is the actual WSGI application. Hosted options  Deploying Flask on Heroku Deploying Flask on Google App Engine Deploying Flask on Google Cloud Run Deploying Flask on AWS Elastic Beanstalk Deploying on Azure (IIS) Deploying on PythonAnywhere  Self-hosted options  \nStandalone WSGI Containers Gunicorn uWSGI Gevent Twisted Web Proxy Setups   \nuWSGI Starting your app with uwsgi Configuring nginx   \nmod_wsgi (Apache) Installing mod_wsgi Creating a .wsgi file Configuring Apache Troubleshooting Support for Automatic Reloading Working with Virtual Environments   \nFastCGI Creating a .fcgi file Configuring Apache Configuring lighttpd Configuring nginx Running FastCGI Processes Debugging   \nCGI Creating a .cgi file Server Setup   ASGI \n"}, {"name": "Design Decisions in Flask", "path": "design/index", "type": "Additional Notes", "text": "Design Decisions in Flask If you are curious why Flask does certain things the way it does and not differently, this section is for you. This should give you an idea about some of the design decisions that may appear arbitrary and surprising at first, especially in direct comparison with other frameworks. The Explicit Application Object A Python web application based on WSGI has to have one central callable object that implements the actual application. In Flask this is an instance of the Flask class. Each Flask application has to create an instance of this class itself and pass it the name of the module, but why can\u2019t Flask do that itself? Without such an explicit application object the following code: from flask import Flask\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    return 'Hello World!'\n Would look like this instead: from hypothetical_flask import route\n\n@route('/')\ndef index():\n    return 'Hello World!'\n There are three major reasons for this. The most important one is that implicit application objects require that there may only be one instance at the time. There are ways to fake multiple applications with a single application object, like maintaining a stack of applications, but this causes some problems I won\u2019t outline here in detail. Now the question is: when does a microframework need more than one application at the same time? A good example for this is unit testing. When you want to test something it can be very helpful to create a minimal application to test specific behavior. When the application object is deleted everything it allocated will be freed again. Another thing that becomes possible when you have an explicit object lying around in your code is that you can subclass the base class (Flask) to alter specific behavior. This would not be possible without hacks if the object were created ahead of time for you based on a class that is not exposed to you. But there is another very important reason why Flask depends on an explicit instantiation of that class: the package name. Whenever you create a Flask instance you usually pass it __name__ as package name. Flask depends on that information to properly load resources relative to your module. With Python\u2019s outstanding support for reflection it can then access the package to figure out where the templates and static files are stored (see open_resource()). Now obviously there are frameworks around that do not need any configuration and will still be able to load templates relative to your application module. But they have to use the current working directory for that, which is a very unreliable way to determine where the application is. The current working directory is process-wide and if you are running multiple applications in one process (which could happen in a webserver without you knowing) the paths will be off. Worse: many webservers do not set the working directory to the directory of your application but to the document root which does not have to be the same folder. The third reason is \u201cexplicit is better than implicit\u201d. That object is your WSGI application, you don\u2019t have to remember anything else. If you want to apply a WSGI middleware, just wrap it and you\u2019re done (though there are better ways to do that so that you do not lose the reference to the application object wsgi_app()). Furthermore this design makes it possible to use a factory function to create the application which is very helpful for unit testing and similar things (Application Factories). The Routing System Flask uses the Werkzeug routing system which was designed to automatically order routes by complexity. This means that you can declare routes in arbitrary order and they will still work as expected. This is a requirement if you want to properly implement decorator based routing since decorators could be fired in undefined order when the application is split into multiple modules. Another design decision with the Werkzeug routing system is that routes in Werkzeug try to ensure that URLs are unique. Werkzeug will go quite far with that in that it will automatically redirect to a canonical URL if a route is ambiguous. One Template Engine Flask decides on one template engine: Jinja2. Why doesn\u2019t Flask have a pluggable template engine interface? You can obviously use a different template engine, but Flask will still configure Jinja2 for you. While that limitation that Jinja2 is always configured will probably go away, the decision to bundle one template engine and use that will not. Template engines are like programming languages and each of those engines has a certain understanding about how things work. On the surface they all work the same: you tell the engine to evaluate a template with a set of variables and take the return value as string. But that\u2019s about where similarities end. Jinja2 for example has an extensive filter system, a certain way to do template inheritance, support for reusable blocks (macros) that can be used from inside templates and also from Python code, supports iterative template rendering, configurable syntax and more. On the other hand an engine like Genshi is based on XML stream evaluation, template inheritance by taking the availability of XPath into account and more. Mako on the other hand treats templates similar to Python modules. When it comes to connecting a template engine with an application or framework there is more than just rendering templates. For instance, Flask uses Jinja2\u2019s extensive autoescaping support. Also it provides ways to access macros from Jinja2 templates. A template abstraction layer that would not take the unique features of the template engines away is a science on its own and a too large undertaking for a microframework like Flask. Furthermore extensions can then easily depend on one template language being present. You can easily use your own templating language, but an extension could still depend on Jinja itself. Micro with Dependencies Why does Flask call itself a microframework and yet it depends on two libraries (namely Werkzeug and Jinja2). Why shouldn\u2019t it? If we look over to the Ruby side of web development there we have a protocol very similar to WSGI. Just that it\u2019s called Rack there, but besides that it looks very much like a WSGI rendition for Ruby. But nearly all applications in Ruby land do not work with Rack directly, but on top of a library with the same name. This Rack library has two equivalents in Python: WebOb (formerly Paste) and Werkzeug. Paste is still around but from my understanding it\u2019s sort of deprecated in favour of WebOb. The development of WebOb and Werkzeug started side by side with similar ideas in mind: be a good implementation of WSGI for other applications to take advantage. Flask is a framework that takes advantage of the work already done by Werkzeug to properly interface WSGI (which can be a complex task at times). Thanks to recent developments in the Python package infrastructure, packages with dependencies are no longer an issue and there are very few reasons against having libraries that depend on others. Thread Locals Flask uses thread local objects (context local objects in fact, they support greenlet contexts as well) for request, session and an extra object you can put your own things on (g). Why is that and isn\u2019t that a bad idea? Yes it is usually not such a bright idea to use thread locals. They cause troubles for servers that are not based on the concept of threads and make large applications harder to maintain. However Flask is just not designed for large applications or asynchronous servers. Flask wants to make it quick and easy to write a traditional web application. Also see the Becoming Big section of the documentation for some inspiration for larger applications based on Flask. Async/await and ASGI support Flask supports async coroutines for view functions by executing the coroutine on a separate thread instead of using an event loop on the main thread as an async-first (ASGI) framework would. This is necessary for Flask to remain backwards compatible with extensions and code built before async was introduced into Python. This compromise introduces a performance cost compared with the ASGI frameworks, due to the overhead of the threads. Due to how tied to WSGI Flask\u2019s code is, it\u2019s not clear if it\u2019s possible to make the Flask class support ASGI and WSGI at the same time. Work is currently being done in Werkzeug to work with ASGI, which may eventually enable support in Flask as well. See Using async and await for more discussion. What Flask is, What Flask is Not Flask will never have a database layer. It will not have a form library or anything else in that direction. Flask itself just bridges to Werkzeug to implement a proper WSGI application and to Jinja2 to handle templating. It also binds to a few common standard library packages such as logging. Everything else is up for extensions. Why is this the case? Because people have different preferences and requirements and Flask could not meet those if it would force any of this into the core. The majority of web applications will need a template engine in some sort. However not every application needs a SQL database. The idea of Flask is to build a good foundation for all applications. Everything else is up to you or extensions.\n"}, {"name": "Development Server", "path": "server/index", "type": "User\u2019s Guide", "text": "Development Server Flask provides a run command to run the application with a development server. In development mode, this server provides an interactive debugger and will reload when code is changed.  Warning Do not use the development server when deploying to production. It is intended for use only during local development. It is not designed to be particularly efficient, stable, or secure. See Deployment Options for deployment options.  Command Line The flask run command line script is the recommended way to run the development server. It requires setting the FLASK_APP environment variable to point to your application, and FLASK_ENV=development to fully enable development mode.  \nBashCMDPowershell\n\n\n$ export FLASK_APP=hello\n$ export FLASK_ENV=development\n$ flask run\n \n\n> set FLASK_APP=hello\n> set FLASK_ENV=development\n> flask run\n \n\n> $env:FLASK_APP = \"hello\"\n> $env:FLASK_ENV = \"development\"\n> flask run\n \n This enables the development environment, including the interactive debugger and reloader, and then starts the server on http://localhost:5000/. Use flask run --help to see the available options, and Command Line Interface for detailed instructions about configuring and using the CLI.  Note Prior to Flask 1.0 the FLASK_ENV environment variable was not supported and you needed to enable debug mode by exporting FLASK_DEBUG=1. This can still be used to control debug mode, but you should prefer setting the development environment as shown above.  Lazy or Eager Loading When using the flask run command with the reloader, the server will continue to run even if you introduce syntax errors or other initialization errors into the code. Accessing the site will show the interactive debugger for the error, rather than crashing the server. This feature is called \u201clazy loading\u201d. If a syntax error is already present when calling flask run, it will fail immediately and show the traceback rather than waiting until the site is accessed. This is intended to make errors more visible initially while still allowing the server to handle errors on reload. To override this behavior and always fail immediately, even on reload, pass the --eager-loading option. To always keep the server running, even on the initial call, pass --lazy-loading. In Code As an alternative to the flask run command, the development server can also be started from Python with the Flask.run() method. This method takes arguments similar to the CLI options to control the server. The main difference from the CLI command is that the server will crash if there are errors when reloading. debug=True can be passed to enable the debugger and reloader, but the FLASK_ENV=development environment variable is still required to fully enable development mode. Place the call in a main block, otherwise it will interfere when trying to import and run the application with a production server later. if __name__ == \"__main__\":\n    app.run(debug=True)\n $ python hello.py\n\n"}, {"name": "dump()", "path": "api/index#flask.json.dump", "type": "flask.json", "text": " \nflask.json.dump(obj, fp, app=None, **kwargs)  \nSerialize an object to JSON written to a file object. Takes the same arguments as the built-in json.dump(), with some defaults from application configuration.  Parameters \n \nobj (Any) \u2013 Object to serialize to JSON. \nfp (IO[str]) \u2013 File object to write JSON to. \napp (Optional[Flask]) \u2013 Use this app\u2019s config instead of the active app context or defaults. \nkwargs (Any) \u2013 Extra arguments passed to json.dump().   Return type \nNone    Changed in version 2.0: Writing to a binary file, and the encoding argument, is deprecated and will be removed in Flask 2.1.  \n"}, {"name": "dumps()", "path": "api/index#flask.json.dumps", "type": "flask.json", "text": " \nflask.json.dumps(obj, app=None, **kwargs)  \nSerialize an object to a string of JSON. Takes the same arguments as the built-in json.dumps(), with some defaults from application configuration.  Parameters \n \nobj (Any) \u2013 Object to serialize to JSON. \napp (Optional[Flask]) \u2013 Use this app\u2019s config instead of the active app context or defaults. \nkwargs (Any) \u2013 Extra arguments passed to json.dumps().   Return type \nstr    Changed in version 2.0: encoding is deprecated and will be removed in Flask 2.1.   Changelog Changed in version 1.0.3: app can be passed directly, rather than requiring an app context for configuration.  \n\n"}, {"name": "ENV", "path": "config/index#ENV", "type": "Configuration", "text": " \nENV  \nWhat environment the app is running in. Flask and extensions may enable behaviors based on the environment, such as enabling debug mode. The env attribute maps to this config key. This is set by the FLASK_ENV environment variable and may not behave as expected if set in code. Do not enable development when deploying in production. Default: 'production'  Changelog New in version 1.0.  \n\n"}, {"name": "escape()", "path": "api/index#flask.escape", "type": "flask", "text": " \nflask.escape()  \nReplace the characters &, <, >, ', and \" in the string with HTML-safe sequences. Use this if you need to display text that might contain such characters in HTML. If the object has an __html__ method, it is called and the return value is assumed to already be safe for HTML.  Parameters \ns \u2013 An object to be converted to a string and escaped.  Returns \nA Markup string with the escaped text.   \n"}, {"name": "EXPLAIN_TEMPLATE_LOADING", "path": "config/index#EXPLAIN_TEMPLATE_LOADING", "type": "Configuration", "text": " \nEXPLAIN_TEMPLATE_LOADING  \nLog debugging information tracing how a template file was loaded. This can be useful to figure out why a template was not loaded or the wrong file appears to be loaded. Default: False \n"}, {"name": "Extensions", "path": "extensions/index", "type": "User\u2019s Guide", "text": "Extensions Extensions are extra packages that add functionality to a Flask application. For example, an extension might add support for sending email or connecting to a database. Some extensions add entire new frameworks to help build certain types of applications, like a REST API. Finding Extensions Flask extensions are usually named \u201cFlask-Foo\u201d or \u201cFoo-Flask\u201d. You can search PyPI for packages tagged with Framework :: Flask. Using Extensions Consult each extension\u2019s documentation for installation, configuration, and usage instructions. Generally, extensions pull their own configuration from app.config and are passed an application instance during initialization. For example, an extension called \u201cFlask-Foo\u201d might be used like this: from flask_foo import Foo\n\nfoo = Foo()\n\napp = Flask(__name__)\napp.config.update(\n    FOO_BAR='baz',\n    FOO_SPAM='eggs',\n)\n\nfoo.init_app(app)\n Building Extensions While the PyPI contains many Flask extensions, you may not find an extension that fits your need. If this is the case, you can create your own. Read Flask Extension Development to develop your own Flask extension.\n"}, {"name": "FastCGI", "path": "deploying/fastcgi/index", "type": "User's Guide: Deploying", "text": "FastCGI FastCGI is a deployment option on servers like nginx, lighttpd, and cherokee; see uWSGI and Standalone WSGI Containers for other options. To use your WSGI application with any of them you will need a FastCGI server first. The most popular one is flup which we will use for this guide. Make sure to have it installed to follow along.  Watch Out Please make sure in advance that any app.run() calls you might have in your application file are inside an if __name__ ==\n'__main__': block or moved to a separate file. Just make sure it\u2019s not called because this will always start a local WSGI server which we do not want if we deploy that application to FastCGI.  Creating a .fcgi file First you need to create the FastCGI server file. Let\u2019s call it yourapplication.fcgi: #!/usr/bin/python\nfrom flup.server.fcgi import WSGIServer\nfrom yourapplication import app\n\nif __name__ == '__main__':\n    WSGIServer(app).run()\n This is enough for Apache to work, however nginx and older versions of lighttpd need a socket to be explicitly passed to communicate with the FastCGI server. For that to work you need to pass the path to the socket to the WSGIServer: WSGIServer(application, bindAddress='/path/to/fcgi.sock').run()\n The path has to be the exact same path you define in the server config. Save the yourapplication.fcgi file somewhere you will find it again. It makes sense to have that in /var/www/yourapplication or something similar. Make sure to set the executable bit on that file so that the servers can execute it: $ chmod +x /var/www/yourapplication/yourapplication.fcgi\n Configuring Apache The example above is good enough for a basic Apache deployment but your .fcgi file will appear in your application URL e.g. example.com/yourapplication.fcgi/news/. There are few ways to configure your application so that yourapplication.fcgi does not appear in the URL. A preferable way is to use the ScriptAlias and SetHandler configuration directives to route requests to the FastCGI server. The following example uses FastCgiServer to start 5 instances of the application which will handle all incoming requests: LoadModule fastcgi_module /usr/lib64/httpd/modules/mod_fastcgi.so\n\nFastCgiServer /var/www/html/yourapplication/app.fcgi -idle-timeout 300 -processes 5\n\n<VirtualHost *>\n    ServerName webapp1.mydomain.com\n    DocumentRoot /var/www/html/yourapplication\n\n    AddHandler fastcgi-script fcgi\n    ScriptAlias / /var/www/html/yourapplication/app.fcgi/\n\n    <Location />\n        SetHandler fastcgi-script\n    </Location>\n</VirtualHost>\n These processes will be managed by Apache. If you\u2019re using a standalone FastCGI server, you can use the FastCgiExternalServer directive instead. Note that in the following the path is not real, it\u2019s simply used as an identifier to other directives such as AliasMatch: FastCgiServer /var/www/html/yourapplication -host 127.0.0.1:3000\n If you cannot set ScriptAlias, for example on a shared web host, you can use WSGI middleware to remove yourapplication.fcgi from the URLs. Set .htaccess: <IfModule mod_fcgid.c>\n   AddHandler fcgid-script .fcgi\n   <Files ~ (\\.fcgi)>\n       SetHandler fcgid-script\n       Options +FollowSymLinks +ExecCGI\n   </Files>\n</IfModule>\n\n<IfModule mod_rewrite.c>\n   Options +FollowSymlinks\n   RewriteEngine On\n   RewriteBase /\n   RewriteCond %{REQUEST_FILENAME} !-f\n   RewriteRule ^(.*)$ yourapplication.fcgi/$1 [QSA,L]\n</IfModule>\n Set yourapplication.fcgi: #!/usr/bin/python\n#: optional path to your local python site-packages folder\nimport sys\nsys.path.insert(0, '<your_local_path>/lib/python<your_python_version>/site-packages')\n\nfrom flup.server.fcgi import WSGIServer\nfrom yourapplication import app\n\nclass ScriptNameStripper(object):\n   def __init__(self, app):\n       self.app = app\n\n   def __call__(self, environ, start_response):\n       environ['SCRIPT_NAME'] = ''\n       return self.app(environ, start_response)\n\napp = ScriptNameStripper(app)\n\nif __name__ == '__main__':\n    WSGIServer(app).run()\n Configuring lighttpd A basic FastCGI configuration for lighttpd looks like that: fastcgi.server = (\"/yourapplication.fcgi\" =>\n    ((\n        \"socket\" => \"/tmp/yourapplication-fcgi.sock\",\n        \"bin-path\" => \"/var/www/yourapplication/yourapplication.fcgi\",\n        \"check-local\" => \"disable\",\n        \"max-procs\" => 1\n    ))\n)\n\nalias.url = (\n    \"/static/\" => \"/path/to/your/static/\"\n)\n\nurl.rewrite-once = (\n    \"^(/static($|/.*))$\" => \"$1\",\n    \"^(/.*)$\" => \"/yourapplication.fcgi$1\"\n)\n Remember to enable the FastCGI, alias and rewrite modules. This configuration binds the application to /yourapplication. If you want the application to work in the URL root you have to work around a lighttpd bug with the LighttpdCGIRootFix middleware. Make sure to apply it only if you are mounting the application the URL root. Also, see the Lighty docs for more information on FastCGI and Python (note that explicitly passing a socket to run() is no longer necessary). Configuring nginx Installing FastCGI applications on nginx is a bit different because by default no FastCGI parameters are forwarded. A basic Flask FastCGI configuration for nginx looks like this: location = /yourapplication { rewrite ^ /yourapplication/ last; }\nlocation /yourapplication { try_files $uri @yourapplication; }\nlocation @yourapplication {\n    include fastcgi_params;\n    fastcgi_split_path_info ^(/yourapplication)(.*)$;\n    fastcgi_param PATH_INFO $fastcgi_path_info;\n    fastcgi_param SCRIPT_NAME $fastcgi_script_name;\n    fastcgi_pass unix:/tmp/yourapplication-fcgi.sock;\n}\n This configuration binds the application to /yourapplication. If you want to have it in the URL root it\u2019s a bit simpler because you don\u2019t have to figure out how to calculate PATH_INFO and SCRIPT_NAME: location / { try_files $uri @yourapplication; }\nlocation @yourapplication {\n    include fastcgi_params;\n    fastcgi_param PATH_INFO $fastcgi_script_name;\n    fastcgi_param SCRIPT_NAME \"\";\n    fastcgi_pass unix:/tmp/yourapplication-fcgi.sock;\n}\n Running FastCGI Processes Since nginx and others do not load FastCGI apps, you have to do it by yourself. Supervisor can manage FastCGI processes. You can look around for other FastCGI process managers or write a script to run your .fcgi file at boot, e.g. using a SysV init.d script. For a temporary solution, you can always run the .fcgi script inside GNU screen. See man screen for details, and note that this is a manual solution which does not persist across system restart: $ screen\n$ /var/www/yourapplication/yourapplication.fcgi\n Debugging FastCGI deployments tend to be hard to debug on most web servers. Very often the only thing the server log tells you is something along the lines of \u201cpremature end of headers\u201d. In order to debug the application the only thing that can really give you ideas why it breaks is switching to the correct user and executing the application by hand. This example assumes your application is called application.fcgi and that your web server user is www-data: $ su www-data\n$ cd /var/www/yourapplication\n$ python application.fcgi\nTraceback (most recent call last):\n  File \"yourapplication.fcgi\", line 4, in <module>\nImportError: No module named yourapplication\n In this case the error seems to be \u201cyourapplication\u201d not being on the python path. Common problems are:  Relative paths being used. Don\u2019t rely on the current working directory. The code depending on environment variables that are not set by the web server. Different python interpreters being used. \n"}, {"name": "flash()", "path": "api/index#flask.flash", "type": "flask", "text": " \nflask.flash(message, category='message')  \nFlashes a message to the next request. In order to remove the flashed message from the session and to display it to the user, the template has to call get_flashed_messages().  Changelog Changed in version 0.3: category parameter added.   Parameters \n \nmessage (str) \u2013 the message to be flashed. \ncategory (str) \u2013 the category for the message. The following values are recommended: 'message' for any kind of message, 'error' for errors, 'info' for information messages and 'warning' for warnings. However any kind of string can be used as category.   Return type \nNone   \n"}, {"name": "Flask", "path": "api/index#flask.Flask", "type": "flask", "text": " \nclass flask.Flask(import_name, static_url_path=None, static_folder='static', static_host=None, host_matching=False, subdomain_matching=False, template_folder='templates', instance_path=None, instance_relative_config=False, root_path=None)  \nThe flask object implements a WSGI application and acts as the central object. It is passed the name of the module or package of the application. Once it is created it will act as a central registry for the view functions, the URL rules, template configuration and much more. The name of the package is used to resolve resources from inside the package or the folder the module is contained in depending on if the package parameter resolves to an actual python package (a folder with an __init__.py file inside) or a standard module (just a .py file). For more information about resource loading, see open_resource(). Usually you create a Flask instance in your main module or in the __init__.py file of your package like this: from flask import Flask\napp = Flask(__name__)\n  About the First Parameter The idea of the first parameter is to give Flask an idea of what belongs to your application. This name is used to find resources on the filesystem, can be used by extensions to improve debugging information and a lot more. So it\u2019s important what you provide there. If you are using a single module, __name__ is always the correct value. If you however are using a package, it\u2019s usually recommended to hardcode the name of your package there. For example if your application is defined in yourapplication/app.py you should create it with one of the two versions below: app = Flask('yourapplication')\napp = Flask(__name__.split('.')[0])\n Why is that? The application will work even with __name__, thanks to how resources are looked up. However it will make debugging more painful. Certain extensions can make assumptions based on the import name of your application. For example the Flask-SQLAlchemy extension will look for the code in your application that triggered an SQL query in debug mode. If the import name is not properly set up, that debugging information is lost. (For example it would only pick up SQL queries in yourapplication.app and not yourapplication.views.frontend)   Changelog New in version 1.0: The host_matching and static_host parameters were added.   New in version 1.0: The subdomain_matching parameter was added. Subdomain matching needs to be enabled manually now. Setting SERVER_NAME does not implicitly enable it.   New in version 0.11: The root_path parameter was added.   New in version 0.8: The instance_path and instance_relative_config parameters were added.   New in version 0.7: The static_url_path, static_folder, and template_folder parameters were added.   Parameters \n \nimport_name (str) \u2013 the name of the application package \nstatic_url_path (Optional[str]) \u2013 can be used to specify a different path for the static files on the web. Defaults to the name of the static_folder folder. \nstatic_folder (Optional[str]) \u2013 The folder with static files that is served at static_url_path. Relative to the application root_path or an absolute path. Defaults to 'static'. \nstatic_host (Optional[str]) \u2013 the host to use when adding the static route. Defaults to None. Required when using host_matching=True with a static_folder configured. \nhost_matching (bool) \u2013 set url_map.host_matching attribute. Defaults to False. \nsubdomain_matching (bool) \u2013 consider the subdomain relative to SERVER_NAME when matching routes. Defaults to False. \ntemplate_folder (Optional[str]) \u2013 the folder that contains the templates that should be used by the application. Defaults to 'templates' folder in the root path of the application. \ninstance_path (Optional[str]) \u2013 An alternative instance path for the application. By default the folder 'instance' next to the package or module is assumed to be the instance path. \ninstance_relative_config (bool) \u2013 if set to True relative filenames for loading the config are assumed to be relative to the instance path instead of the application root. \nroot_path (Optional[str]) \u2013 The path to the root of the application files. This should only be set manually when it can\u2019t be detected automatically, such as for namespace packages.     \nadd_template_filter(f, name=None)  \nRegister a custom template filter. Works exactly like the template_filter() decorator.  Parameters \n \nname (Optional[str]) \u2013 the optional name of the filter, otherwise the function name will be used. \nf (Callable[[Any], str]) \u2013    Return type \nNone   \n  \nadd_template_global(f, name=None)  \nRegister a custom template global function. Works exactly like the template_global() decorator.  Changelog New in version 0.10.   Parameters \n \nname (Optional[str]) \u2013 the optional name of the global function, otherwise the function name will be used. \nf (Callable[[], Any]) \u2013    Return type \nNone   \n  \nadd_template_test(f, name=None)  \nRegister a custom template test. Works exactly like the template_test() decorator.  Changelog New in version 0.10.   Parameters \n \nname (Optional[str]) \u2013 the optional name of the test, otherwise the function name will be used. \nf (Callable[[Any], bool]) \u2013    Return type \nNone   \n  \nadd_url_rule(rule, endpoint=None, view_func=None, provide_automatic_options=None, **options)  \nRegister a rule for routing incoming requests and building URLs. The route() decorator is a shortcut to call this with the view_func argument. These are equivalent: @app.route(\"/\")\ndef index():\n    ...\n def index():\n    ...\n\napp.add_url_rule(\"/\", view_func=index)\n See URL Route Registrations. The endpoint name for the route defaults to the name of the view function if the endpoint parameter isn\u2019t passed. An error will be raised if a function has already been registered for the endpoint. The methods parameter defaults to [\"GET\"]. HEAD is always added automatically, and OPTIONS is added automatically by default. view_func does not necessarily need to be passed, but if the rule should participate in routing an endpoint name must be associated with a view function at some point with the endpoint() decorator. app.add_url_rule(\"/\", endpoint=\"index\")\n\n@app.endpoint(\"index\")\ndef index():\n    ...\n If view_func has a required_methods attribute, those methods are added to the passed and automatic methods. If it has a provide_automatic_methods attribute, it is used as the default if the parameter is not passed.  Parameters \n \nrule (str) \u2013 The URL rule string. \nendpoint (Optional[str]) \u2013 The endpoint name to associate with the rule and view function. Used when routing and building URLs. Defaults to view_func.__name__. \nview_func (Optional[Callable]) \u2013 The view function to associate with the endpoint name. \nprovide_automatic_options (Optional[bool]) \u2013 Add the OPTIONS method and respond to OPTIONS requests automatically. \noptions (Any) \u2013 Extra options passed to the Rule object.   Return type \nNone   \n  \nafter_request(f)  \nRegister a function to run after each request to this object. The function is called with the response object, and must return a response object. This allows the functions to modify or replace the response before it is sent. If a function raises an exception, any remaining after_request functions will not be called. Therefore, this should not be used for actions that must execute, such as to close resources. Use teardown_request() for that.  Parameters \nf (Callable[[Response], Response]) \u2013   Return type \nCallable[[Response], Response]   \n  \nafter_request_funcs: t.Dict[AppOrBlueprintKey, t.List[AfterRequestCallable]]  \nA data structure of functions to call at the end of each request, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests. To register a function, use the after_request() decorator. This data structure is internal. It should not be modified directly and its format may change at any time. \n  \napp_context()  \nCreate an AppContext. Use as a with block to push the context, which will make current_app point at this application. An application context is automatically pushed by RequestContext.push() when handling a request, and when running a CLI command. Use this to manually create a context outside of these situations. with app.app_context():\n    init_db()\n See The Application Context.  Changelog New in version 0.9.   Return type \nflask.ctx.AppContext   \n  \napp_ctx_globals_class  \nalias of flask.ctx._AppCtxGlobals \n  \nasync_to_sync(func)  \nReturn a sync function that will run the coroutine function. result = app.async_to_sync(func)(*args, **kwargs)\n Override this method to change how the app converts async code to be synchronously callable.  New in version 2.0.   Parameters \nfunc (Callable[[...], Coroutine]) \u2013   Return type \nCallable[[\u2026], Any]   \n  \nauto_find_instance_path()  \nTries to locate the instance path if it was not provided to the constructor of the application class. It will basically calculate the path to a folder named instance next to your main file or the package.  Changelog New in version 0.8.   Return type \nstr   \n  \nbefore_first_request(f)  \nRegisters a function to be run before the first request to this instance of the application. The function will be called without any arguments and its return value is ignored.  Changelog New in version 0.8.   Parameters \nf (Callable[[], None]) \u2013   Return type \nCallable[[], None]   \n  \nbefore_first_request_funcs: t.List[BeforeRequestCallable]  \nA list of functions that will be called at the beginning of the first request to this instance. To register a function, use the before_first_request() decorator.  Changelog New in version 0.8.  \n\n  \nbefore_request(f)  \nRegister a function to run before each request. For example, this can be used to open a database connection, or to load the logged in user from the session. @app.before_request\ndef load_user():\n    if \"user_id\" in session:\n        g.user = db.session.get(session[\"user_id\"])\n The function will be called without any arguments. If it returns a non-None value, the value is handled as if it was the return value from the view, and further request handling is stopped.  Parameters \nf (Callable[[], None]) \u2013   Return type \nCallable[[], None]   \n  \nbefore_request_funcs: t.Dict[AppOrBlueprintKey, t.List[BeforeRequestCallable]]  \nA data structure of functions to call at the beginning of each request, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests. To register a function, use the before_request() decorator. This data structure is internal. It should not be modified directly and its format may change at any time. \n  \nblueprints: t.Dict[str, \u2018Blueprint\u2019]  \nMaps registered blueprint names to blueprint objects. The dict retains the order the blueprints were registered in. Blueprints can be registered multiple times, this dict does not track how often they were attached.  Changelog New in version 0.7.  \n\n  \ncli  \nThe Click command group for registering CLI commands for this object. The commands are available from the flask command once the application has been discovered and blueprints have been registered. \n  \nconfig  \nThe configuration dictionary as Config. This behaves exactly like a regular dictionary but supports additional methods to load a config from files. \n  \nconfig_class  \nalias of flask.config.Config \n  \ncontext_processor(f)  \nRegisters a template context processor function.  Parameters \nf (Callable[[], Dict[str, Any]]) \u2013   Return type \nCallable[[], Dict[str, Any]]   \n  \ncreate_global_jinja_loader()  \nCreates the loader for the Jinja2 environment. Can be used to override just the loader and keeping the rest unchanged. It\u2019s discouraged to override this function. Instead one should override the jinja_loader() function instead. The global loader dispatches between the loaders of the application and the individual blueprints.  Changelog New in version 0.7.   Return type \nflask.templating.DispatchingJinjaLoader   \n  \ncreate_jinja_environment()  \nCreate the Jinja environment based on jinja_options and the various Jinja-related methods of the app. Changing jinja_options after this will have no effect. Also adds Flask-related globals and filters to the environment.  Changelog Changed in version 0.11: Environment.auto_reload set in accordance with TEMPLATES_AUTO_RELOAD configuration option.   New in version 0.5.   Return type \nflask.templating.Environment   \n  \ncreate_url_adapter(request)  \nCreates a URL adapter for the given request. The URL adapter is created at a point where the request context is not yet set up so the request is passed explicitly.  Changelog Changed in version 1.0: SERVER_NAME no longer implicitly enables subdomain matching. Use subdomain_matching instead.   Changed in version 0.9: This can now also be called without a request object when the URL adapter is created for the application context.   New in version 0.6.   Parameters \nrequest (Optional[flask.wrappers.Request]) \u2013   Return type \nOptional[werkzeug.routing.MapAdapter]   \n  \nproperty debug: bool  \nWhether debug mode is enabled. When using flask run to start the development server, an interactive debugger will be shown for unhandled exceptions, and the server will be reloaded when code changes. This maps to the DEBUG config key. This is enabled when env is 'development' and is overridden by the FLASK_DEBUG environment variable. It may not behave as expected if set in code. Do not enable debug mode when deploying in production. Default: True if env is 'development', or False otherwise. \n  \ndefault_config = {'APPLICATION_ROOT': '/', 'DEBUG': None, 'ENV': None, 'EXPLAIN_TEMPLATE_LOADING': False, 'JSONIFY_MIMETYPE': 'application/json', 'JSONIFY_PRETTYPRINT_REGULAR': False, 'JSON_AS_ASCII': True, 'JSON_SORT_KEYS': True, 'MAX_CONTENT_LENGTH': None, 'MAX_COOKIE_SIZE': 4093, 'PERMANENT_SESSION_LIFETIME': datetime.timedelta(days=31), 'PREFERRED_URL_SCHEME': 'http', 'PRESERVE_CONTEXT_ON_EXCEPTION': None, 'PROPAGATE_EXCEPTIONS': None, 'SECRET_KEY': None, 'SEND_FILE_MAX_AGE_DEFAULT': None, 'SERVER_NAME': None, 'SESSION_COOKIE_DOMAIN': None, 'SESSION_COOKIE_HTTPONLY': True, 'SESSION_COOKIE_NAME': 'session', 'SESSION_COOKIE_PATH': None, 'SESSION_COOKIE_SAMESITE': None, 'SESSION_COOKIE_SECURE': False, 'SESSION_REFRESH_EACH_REQUEST': True, 'TEMPLATES_AUTO_RELOAD': None, 'TESTING': False, 'TRAP_BAD_REQUEST_ERRORS': None, 'TRAP_HTTP_EXCEPTIONS': False, 'USE_X_SENDFILE': False}  \nDefault configuration parameters. \n  \ndelete(rule, **options)  \nShortcut for route() with methods=[\"DELETE\"].  New in version 2.0.   Parameters \n \nrule (str) \u2013  \noptions (Any) \u2013    Return type \nCallable   \n  \ndispatch_request()  \nDoes the request dispatching. Matches the URL and returns the return value of the view or error handler. This does not have to be a response object. In order to convert the return value to a proper response object, call make_response().  Changelog Changed in version 0.7: This no longer does the exception handling, this code was moved to the new full_dispatch_request().   Return type \nUnion[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], WSGIApplication]   \n  \ndo_teardown_appcontext(exc=<object object>)  \nCalled right before the application context is popped. When handling a request, the application context is popped after the request context. See do_teardown_request(). This calls all functions decorated with teardown_appcontext(). Then the appcontext_tearing_down signal is sent. This is called by AppContext.pop().  Changelog New in version 0.9.   Parameters \nexc (Optional[BaseException]) \u2013   Return type \nNone   \n  \ndo_teardown_request(exc=<object object>)  \nCalled after the request is dispatched and the response is returned, right before the request context is popped. This calls all functions decorated with teardown_request(), and Blueprint.teardown_request() if a blueprint handled the request. Finally, the request_tearing_down signal is sent. This is called by RequestContext.pop(), which may be delayed during testing to maintain access to resources.  Parameters \nexc (Optional[BaseException]) \u2013 An unhandled exception raised while dispatching the request. Detected from the current exception information if not passed. Passed to each teardown function.  Return type \nNone    Changelog Changed in version 0.9: Added the exc argument.  \n\n  \nendpoint(endpoint)  \nDecorate a view function to register it for the given endpoint. Used if a rule is added without a view_func with add_url_rule(). app.add_url_rule(\"/ex\", endpoint=\"example\")\n\n@app.endpoint(\"example\")\ndef example():\n    ...\n  Parameters \nendpoint (str) \u2013 The endpoint name to associate with the view function.  Return type \nCallable   \n  \nensure_sync(func)  \nEnsure that the function is synchronous for WSGI workers. Plain def functions are returned as-is. async def functions are wrapped to run and wait for the response. Override this method to change how the app runs async views.  New in version 2.0.   Parameters \nfunc (Callable) \u2013   Return type \nCallable   \n  \nenv  \nWhat environment the app is running in. Flask and extensions may enable behaviors based on the environment, such as enabling debug mode. This maps to the ENV config key. This is set by the FLASK_ENV environment variable and may not behave as expected if set in code. Do not enable development when deploying in production. Default: 'production' \n  \nerror_handler_spec: t.Dict[AppOrBlueprintKey, t.Dict[t.Optional[int], t.Dict[t.Type[Exception], ErrorHandlerCallable]]]  \nA data structure of registered error handlers, in the format {scope: {code: {class: handler}}}`. The scope key is the name of a blueprint the handlers are active for, or None for all requests. The code key is the HTTP status code for HTTPException, or None for other exceptions. The innermost dictionary maps exception classes to handler functions. To register an error handler, use the errorhandler() decorator. This data structure is internal. It should not be modified directly and its format may change at any time. \n  \nerrorhandler(code_or_exception)  \nRegister a function to handle errors by code or exception class. A decorator that is used to register a function given an error code. Example: @app.errorhandler(404)\ndef page_not_found(error):\n    return 'This page does not exist', 404\n You can also register handlers for arbitrary exceptions: @app.errorhandler(DatabaseError)\ndef special_exception_handler(error):\n    return 'Database connection failed', 500\n  Changelog New in version 0.7: Use register_error_handler() instead of modifying error_handler_spec directly, for application wide error handlers.   New in version 0.7: One can now additionally also register custom exception types that do not necessarily have to be a subclass of the HTTPException class.   Parameters \ncode_or_exception (Union[Type[Exception], int]) \u2013 the code as integer for the handler, or an arbitrary exception  Return type \nCallable   \n  \nextensions: dict  \na place where extensions can store application specific state. For example this is where an extension could store database engines and similar things. The key must match the name of the extension module. For example in case of a \u201cFlask-Foo\u201d extension in flask_foo, the key would be 'foo'.  Changelog New in version 0.7.  \n\n  \nfull_dispatch_request()  \nDispatches the request and on top of that performs request pre and postprocessing as well as HTTP exception catching and error handling.  Changelog New in version 0.7.   Return type \nflask.wrappers.Response   \n  \nget(rule, **options)  \nShortcut for route() with methods=[\"GET\"].  New in version 2.0.   Parameters \n \nrule (str) \u2013  \noptions (Any) \u2013    Return type \nCallable   \n  \nget_send_file_max_age(filename)  \nUsed by send_file() to determine the max_age cache value for a given file path if it wasn\u2019t passed. By default, this returns SEND_FILE_MAX_AGE_DEFAULT from the configuration of current_app. This defaults to None, which tells the browser to use conditional requests instead of a timed cache, which is usually preferable.  Changed in version 2.0: The default configuration is None instead of 12 hours.   Changelog New in version 0.9.   Parameters \nfilename (str) \u2013   Return type \nOptional[int]   \n  \nproperty got_first_request: bool  \nThis attribute is set to True if the application started handling the first request.  Changelog New in version 0.8.  \n\n  \nhandle_exception(e)  \nHandle an exception that did not have an error handler associated with it, or that was raised from an error handler. This always causes a 500 InternalServerError. Always sends the got_request_exception signal. If propagate_exceptions is True, such as in debug mode, the error will be re-raised so that the debugger can display it. Otherwise, the original exception is logged, and an InternalServerError is returned. If an error handler is registered for InternalServerError or 500, it will be used. For consistency, the handler will always receive the InternalServerError. The original unhandled exception is available as e.original_exception.  Changelog Changed in version 1.1.0: Always passes the InternalServerError instance to the handler, setting original_exception to the unhandled error.   Changed in version 1.1.0: after_request functions and other finalization is done even for the default 500 response when there is no handler.   New in version 0.3.   Parameters \ne (Exception) \u2013   Return type \nflask.wrappers.Response   \n  \nhandle_http_exception(e)  \nHandles an HTTP exception. By default this will invoke the registered error handlers and fall back to returning the exception as response.  Changelog Changed in version 1.0.3: RoutingException, used internally for actions such as slash redirects during routing, is not passed to error handlers.   Changed in version 1.0: Exceptions are looked up by code and by MRO, so HTTPExcpetion subclasses can be handled with a catch-all handler for the base HTTPException.   New in version 0.3.   Parameters \ne (werkzeug.exceptions.HTTPException) \u2013   Return type \nUnion[werkzeug.exceptions.HTTPException, Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], WSGIApplication]   \n  \nhandle_url_build_error(error, endpoint, values)  \nHandle BuildError on url_for().  Parameters \n \nerror (Exception) \u2013  \nendpoint (str) \u2013  \nvalues (dict) \u2013    Return type \nstr   \n  \nhandle_user_exception(e)  \nThis method is called whenever an exception occurs that should be handled. A special case is HTTPException which is forwarded to the handle_http_exception() method. This function will either return a response value or reraise the exception with the same traceback.  Changelog Changed in version 1.0: Key errors raised from request data like form show the bad key in debug mode rather than a generic bad request message.   New in version 0.7.   Parameters \ne (Exception) \u2013   Return type \nUnion[werkzeug.exceptions.HTTPException, Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], WSGIApplication]   \n  \nproperty has_static_folder: bool  \nTrue if static_folder is set.  Changelog New in version 0.5.  \n\n  \nimport_name  \nThe name of the package or module that this object belongs to. Do not change this once it is set by the constructor. \n  \ninject_url_defaults(endpoint, values)  \nInjects the URL defaults for the given endpoint directly into the values dictionary passed. This is used internally and automatically called on URL building.  Changelog New in version 0.7.   Parameters \n \nendpoint (str) \u2013  \nvalues (dict) \u2013    Return type \nNone   \n  \ninstance_path  \nHolds the path to the instance folder.  Changelog New in version 0.8.  \n\n  \niter_blueprints()  \nIterates over all blueprints by the order they were registered.  Changelog New in version 0.11.   Return type \nValuesView[Blueprint]   \n  \nproperty jinja_env: flask.templating.Environment  \nThe Jinja environment used to load templates. The environment is created the first time this property is accessed. Changing jinja_options after that will have no effect. \n  \njinja_environment  \nalias of flask.templating.Environment \n  \nproperty jinja_loader: Optional[jinja2.loaders.FileSystemLoader]  \nThe Jinja loader for this object\u2019s templates. By default this is a class jinja2.loaders.FileSystemLoader to template_folder if it is set.  Changelog New in version 0.5.  \n\n  \njinja_options: dict = {}  \nOptions that are passed to the Jinja environment in create_jinja_environment(). Changing these options after the environment is created (accessing jinja_env) will have no effect.  Changelog Changed in version 1.1.0: This is a dict instead of an ImmutableDict to allow easier configuration.  \n\n  \njson_decoder  \nalias of flask.json.JSONDecoder \n  \njson_encoder  \nalias of flask.json.JSONEncoder \n  \nlog_exception(exc_info)  \nLogs an exception. This is called by handle_exception() if debugging is disabled and right before the handler is called. The default implementation logs the exception as error on the logger.  Changelog New in version 0.8.   Parameters \nexc_info (Union[Tuple[type, BaseException, types.TracebackType], Tuple[None, None, None]]) \u2013   Return type \nNone   \n  \nproperty logger: logging.Logger  \nA standard Python Logger for the app, with the same name as name. In debug mode, the logger\u2019s level will be set to DEBUG. If there are no handlers configured, a default handler will be added. See Logging for more information.  Changelog Changed in version 1.1.0: The logger takes the same name as name rather than hard-coding \"flask.app\".   Changed in version 1.0.0: Behavior was simplified. The logger is always named \"flask.app\". The level is only set during configuration, it doesn\u2019t check app.debug each time. Only one format is used, not different ones depending on app.debug. No handlers are removed, and a handler is only added if no handlers are already configured.   New in version 0.3.  \n\n  \nmake_config(instance_relative=False)  \nUsed to create the config attribute by the Flask constructor. The instance_relative parameter is passed in from the constructor of Flask (there named instance_relative_config) and indicates if the config should be relative to the instance path or the root path of the application.  Changelog New in version 0.8.   Parameters \ninstance_relative (bool) \u2013   Return type \nflask.config.Config   \n  \nmake_default_options_response()  \nThis method is called to create the default OPTIONS response. This can be changed through subclassing to change the default behavior of OPTIONS responses.  Changelog New in version 0.7.   Return type \nflask.wrappers.Response   \n  \nmake_response(rv)  \nConvert the return value from a view function to an instance of response_class.  Parameters \nrv (Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], Union[Headers, Dict[str, Union[str, List[str], Tuple[str, ...]]], List[Tuple[str, Union[str, List[str], Tuple[str, ...]]]]]], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, ...]]], List[Tuple[str, Union[str, List[str], Tuple[str, ...]]]]]], WSGIApplication]) \u2013 \nthe return value from the view function. The view function must return a response. Returning None, or the view ending without returning, is not allowed. The following types are allowed for view_rv:  \nstr \n\nA response object is created with the string encoded to UTF-8 as the body.  \nbytes \n\nA response object is created with the bytes as the body.  \ndict \n\nA dictionary that will be jsonify\u2019d before being returned.  \ntuple \n\nEither (body, status, headers), (body, status), or (body, headers), where body is any of the other types allowed here, status is a string or an integer, and headers is a dictionary or a list of (key, value) tuples. If body is a response_class instance, status overwrites the exiting value and headers are extended.  \nresponse_class\n\n\nThe object is returned unchanged.  \nother Response class \n\nThe object is coerced to response_class.  \ncallable()\n\n\nThe function is called as a WSGI application. The result is used to create a response object.    Return type \nflask.wrappers.Response    Changelog Changed in version 0.9: Previously a tuple was interpreted as the arguments for the response object.  \n\n  \nmake_shell_context()  \nReturns the shell context for an interactive shell for this application. This runs all the registered shell context processors.  Changelog New in version 0.11.   Return type \ndict   \n  \nproperty name: str  \nThe name of the application. This is usually the import name with the difference that it\u2019s guessed from the run file if the import name is main. This name is used as a display name when Flask needs the name of the application. It can be set and overridden to change the value.  Changelog New in version 0.8.  \n\n  \nopen_instance_resource(resource, mode='rb')  \nOpens a resource from the application\u2019s instance folder (instance_path). Otherwise works like open_resource(). Instance resources can also be opened for writing.  Parameters \n \nresource (str) \u2013 the name of the resource. To access resources within subfolders use forward slashes as separator. \nmode (str) \u2013 resource file opening mode, default is \u2018rb\u2019.   Return type \nIO   \n  \nopen_resource(resource, mode='rb')  \nOpen a resource file relative to root_path for reading. For example, if the file schema.sql is next to the file app.py where the Flask app is defined, it can be opened with: with app.open_resource(\"schema.sql\") as f:\n    conn.executescript(f.read())\n  Parameters \n \nresource (str) \u2013 Path to the resource relative to root_path. \nmode (str) \u2013 Open the file in this mode. Only reading is supported, valid values are \u201cr\u201d (or \u201crt\u201d) and \u201crb\u201d.   Return type \nIO   \n  \npatch(rule, **options)  \nShortcut for route() with methods=[\"PATCH\"].  New in version 2.0.   Parameters \n \nrule (str) \u2013  \noptions (Any) \u2013    Return type \nCallable   \n  \npermanent_session_lifetime  \nA timedelta which is used to set the expiration date of a permanent session. The default is 31 days which makes a permanent session survive for roughly one month. This attribute can also be configured from the config with the PERMANENT_SESSION_LIFETIME configuration key. Defaults to timedelta(days=31) \n  \npost(rule, **options)  \nShortcut for route() with methods=[\"POST\"].  New in version 2.0.   Parameters \n \nrule (str) \u2013  \noptions (Any) \u2013    Return type \nCallable   \n  \npreprocess_request()  \nCalled before the request is dispatched. Calls url_value_preprocessors registered with the app and the current blueprint (if any). Then calls before_request_funcs registered with the app and the blueprint. If any before_request() handler returns a non-None value, the value is handled as if it was the return value from the view, and further request handling is stopped.  Return type \nOptional[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], WSGIApplication]]   \n  \nproperty preserve_context_on_exception: bool  \nReturns the value of the PRESERVE_CONTEXT_ON_EXCEPTION configuration value in case it\u2019s set, otherwise a sensible default is returned.  Changelog New in version 0.7.  \n\n  \nprocess_response(response)  \nCan be overridden in order to modify the response object before it\u2019s sent to the WSGI server. By default this will call all the after_request() decorated functions.  Changelog Changed in version 0.5: As of Flask 0.5 the functions registered for after request execution are called in reverse order of registration.   Parameters \nresponse (flask.wrappers.Response) \u2013 a response_class object.  Returns \na new response object or the same, has to be an instance of response_class.  Return type \nflask.wrappers.Response   \n  \nproperty propagate_exceptions: bool  \nReturns the value of the PROPAGATE_EXCEPTIONS configuration value in case it\u2019s set, otherwise a sensible default is returned.  Changelog New in version 0.7.  \n\n  \nput(rule, **options)  \nShortcut for route() with methods=[\"PUT\"].  New in version 2.0.   Parameters \n \nrule (str) \u2013  \noptions (Any) \u2013    Return type \nCallable   \n  \nregister_blueprint(blueprint, **options)  \nRegister a Blueprint on the application. Keyword arguments passed to this method will override the defaults set on the blueprint. Calls the blueprint\u2019s register() method after recording the blueprint in the application\u2019s blueprints.  Parameters \n \nblueprint (Blueprint) \u2013 The blueprint to register. \nurl_prefix \u2013 Blueprint routes will be prefixed with this. \nsubdomain \u2013 Blueprint routes will match on this subdomain. \nurl_defaults \u2013 Blueprint routes will use these default values for view arguments. \noptions (Any) \u2013 Additional keyword arguments are passed to BlueprintSetupState. They can be accessed in record() callbacks.   Return type \nNone    Changelog New in version 0.7.  \n\n  \nregister_error_handler(code_or_exception, f)  \nAlternative error attach function to the errorhandler() decorator that is more straightforward to use for non decorator usage.  Changelog New in version 0.7.   Parameters \n \ncode_or_exception (Union[Type[Exception], int]) \u2013  \nf (Callable[[Exception], Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], Union[Headers, Dict[str, Union[str, List[str], Tuple[str, ...]]], List[Tuple[str, Union[str, List[str], Tuple[str, ...]]]]]], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, ...]]], List[Tuple[str, Union[str, List[str], Tuple[str, ...]]]]]], WSGIApplication]]) \u2013    Return type \nNone   \n  \nrequest_class  \nalias of flask.wrappers.Request \n  \nrequest_context(environ)  \nCreate a RequestContext representing a WSGI environment. Use a with block to push the context, which will make request point at this request. See The Request Context. Typically you should not call this from your own code. A request context is automatically pushed by the wsgi_app() when handling a request. Use test_request_context() to create an environment and context instead of this method.  Parameters \nenviron (dict) \u2013 a WSGI environment  Return type \nflask.ctx.RequestContext   \n  \nresponse_class  \nalias of flask.wrappers.Response \n  \nroot_path  \nAbsolute path to the package on the filesystem. Used to look up resources contained in the package. \n  \nroute(rule, **options)  \nDecorate a view function to register it with the given URL rule and options. Calls add_url_rule(), which has more details about the implementation. @app.route(\"/\")\ndef index():\n    return \"Hello, World!\"\n See URL Route Registrations. The endpoint name for the route defaults to the name of the view function if the endpoint parameter isn\u2019t passed. The methods parameter defaults to [\"GET\"]. HEAD and OPTIONS are added automatically.  Parameters \n \nrule (str) \u2013 The URL rule string. \noptions (Any) \u2013 Extra options passed to the Rule object.   Return type \nCallable   \n  \nrun(host=None, port=None, debug=None, load_dotenv=True, **options)  \nRuns the application on a local development server. Do not use run() in a production setting. It is not intended to meet security and performance requirements for a production server. Instead, see Deployment Options for WSGI server recommendations. If the debug flag is set the server will automatically reload for code changes and show a debugger in case an exception happened. If you want to run the application in debug mode, but disable the code execution on the interactive debugger, you can pass use_evalex=False as parameter. This will keep the debugger\u2019s traceback screen active, but disable code execution. It is not recommended to use this function for development with automatic reloading as this is badly supported. Instead you should be using the flask command line script\u2019s run support.  Keep in Mind Flask will suppress any server error with a generic error page unless it is in debug mode. As such to enable just the interactive debugger without the code reloading, you have to invoke run() with debug=True and use_reloader=False. Setting use_debugger to True without being in debug mode won\u2019t catch any exceptions because there won\u2019t be any to catch.   Parameters \n \nhost (Optional[str]) \u2013 the hostname to listen on. Set this to '0.0.0.0' to have the server available externally as well. Defaults to '127.0.0.1' or the host in the SERVER_NAME config variable if present. \nport (Optional[int]) \u2013 the port of the webserver. Defaults to 5000 or the port defined in the SERVER_NAME config variable if present. \ndebug (Optional[bool]) \u2013 if given, enable or disable debug mode. See debug. \nload_dotenv (bool) \u2013 Load the nearest .env and .flaskenv files to set environment variables. Will also change the working directory to the directory containing the first file found. \noptions (Any) \u2013 the options to be forwarded to the underlying Werkzeug server. See werkzeug.serving.run_simple() for more information.   Return type \nNone    Changelog Changed in version 1.0: If installed, python-dotenv will be used to load environment variables from .env and .flaskenv files. If set, the FLASK_ENV and FLASK_DEBUG environment variables will override env and debug. Threaded mode is enabled by default.   Changed in version 0.10: The default port is now picked from the SERVER_NAME variable.  \n\n  \nsecret_key  \nIf a secret key is set, cryptographic components can use this to sign cookies and other things. Set this to a complex random value when you want to use the secure cookie for instance. This attribute can also be configured from the config with the SECRET_KEY configuration key. Defaults to None. \n  \nselect_jinja_autoescape(filename)  \nReturns True if autoescaping should be active for the given template name. If no template name is given, returns True.  Changelog New in version 0.5.   Parameters \nfilename (str) \u2013   Return type \nbool   \n  \nsend_file_max_age_default  \nA timedelta or number of seconds which is used as the default max_age for send_file(). The default is None, which tells the browser to use conditional requests instead of a timed cache. Configured with the SEND_FILE_MAX_AGE_DEFAULT configuration key.  Changed in version 2.0: Defaults to None instead of 12 hours.  \n  \nsend_static_file(filename)  \nThe view function used to serve files from static_folder. A route is automatically registered for this view at static_url_path if static_folder is set.  Changelog New in version 0.5.   Parameters \nfilename (str) \u2013   Return type \nResponse   \n  \nsession_cookie_name  \nThe secure cookie uses this for the name of the session cookie. This attribute can also be configured from the config with the SESSION_COOKIE_NAME configuration key. Defaults to 'session' \n  \nsession_interface = <flask.sessions.SecureCookieSessionInterface object>  \nthe session interface to use. By default an instance of SecureCookieSessionInterface is used here.  Changelog New in version 0.8.  \n\n  \nshell_context_processor(f)  \nRegisters a shell context processor function.  Changelog New in version 0.11.   Parameters \nf (Callable) \u2013   Return type \nCallable   \n  \nshell_context_processors: t.List[t.Callable[], t.Dict[str, t.Any]]]  \nA list of shell context processor functions that should be run when a shell context is created.  Changelog New in version 0.11.  \n\n  \nshould_ignore_error(error)  \nThis is called to figure out if an error should be ignored or not as far as the teardown system is concerned. If this function returns True then the teardown handlers will not be passed the error.  Changelog New in version 0.10.   Parameters \nerror (Optional[BaseException]) \u2013   Return type \nbool   \n  \nproperty static_folder: Optional[str]  \nThe absolute path to the configured static folder. None if no static folder is set. \n  \nproperty static_url_path: Optional[str]  \nThe URL prefix that the static route will be accessible from. If it was not configured during init, it is derived from static_folder. \n  \nteardown_appcontext(f)  \nRegisters a function to be called when the application context ends. These functions are typically also called when the request context is popped. Example: ctx = app.app_context()\nctx.push()\n...\nctx.pop()\n When ctx.pop() is executed in the above example, the teardown functions are called just before the app context moves from the stack of active contexts. This becomes relevant if you are using such constructs in tests. Since a request context typically also manages an application context it would also be called when you pop a request context. When a teardown function was called because of an unhandled exception it will be passed an error object. If an errorhandler() is registered, it will handle the exception and the teardown will not receive it. The return values of teardown functions are ignored.  Changelog New in version 0.9.   Parameters \nf (Callable[[Optional[BaseException]], flask.wrappers.Response]) \u2013   Return type \nCallable[[Optional[BaseException]], flask.wrappers.Response]   \n  \nteardown_appcontext_funcs: t.List[TeardownCallable]  \nA list of functions that are called when the application context is destroyed. Since the application context is also torn down if the request ends this is the place to store code that disconnects from databases.  Changelog New in version 0.9.  \n\n  \nteardown_request(f)  \nRegister a function to be run at the end of each request, regardless of whether there was an exception or not. These functions are executed when the request context is popped, even if not an actual request was performed. Example: ctx = app.test_request_context()\nctx.push()\n...\nctx.pop()\n When ctx.pop() is executed in the above example, the teardown functions are called just before the request context moves from the stack of active contexts. This becomes relevant if you are using such constructs in tests. Teardown functions must avoid raising exceptions, since they . If they execute code that might fail they will have to surround the execution of these code by try/except statements and log occurring errors. When a teardown function was called because of an exception it will be passed an error object. The return values of teardown functions are ignored.  Debug Note In debug mode Flask will not tear down a request on an exception immediately. Instead it will keep it alive so that the interactive debugger can still access it. This behavior can be controlled by the PRESERVE_CONTEXT_ON_EXCEPTION configuration variable.   Parameters \nf (Callable[[Optional[BaseException]], Response]) \u2013   Return type \nCallable[[Optional[BaseException]], Response]   \n  \nteardown_request_funcs: t.Dict[AppOrBlueprintKey, t.List[TeardownCallable]]  \nA data structure of functions to call at the end of each request even if an exception is raised, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests. To register a function, use the teardown_request() decorator. This data structure is internal. It should not be modified directly and its format may change at any time. \n  \ntemplate_context_processors: t.Dict[AppOrBlueprintKey, t.List[TemplateContextProcessorCallable]]  \nA data structure of functions to call to pass extra context values when rendering templates, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests. To register a function, use the context_processor() decorator. This data structure is internal. It should not be modified directly and its format may change at any time. \n  \ntemplate_filter(name=None)  \nA decorator that is used to register custom template filter. You can specify a name for the filter, otherwise the function name will be used. Example: @app.template_filter()\ndef reverse(s):\n    return s[::-1]\n  Parameters \nname (Optional[str]) \u2013 the optional name of the filter, otherwise the function name will be used.  Return type \nCallable   \n  \ntemplate_folder  \nThe path to the templates folder, relative to root_path, to add to the template loader. None if templates should not be added. \n  \ntemplate_global(name=None)  \nA decorator that is used to register a custom template global function. You can specify a name for the global function, otherwise the function name will be used. Example: @app.template_global()\ndef double(n):\n    return 2 * n\n  Changelog New in version 0.10.   Parameters \nname (Optional[str]) \u2013 the optional name of the global function, otherwise the function name will be used.  Return type \nCallable   \n  \ntemplate_test(name=None)  \nA decorator that is used to register custom template test. You can specify a name for the test, otherwise the function name will be used. Example: @app.template_test()\ndef is_prime(n):\n    if n == 2:\n        return True\n    for i in range(2, int(math.ceil(math.sqrt(n))) + 1):\n        if n % i == 0:\n            return False\n    return True\n  Changelog New in version 0.10.   Parameters \nname (Optional[str]) \u2013 the optional name of the test, otherwise the function name will be used.  Return type \nCallable   \n  \nproperty templates_auto_reload: bool  \nReload templates when they are changed. Used by create_jinja_environment(). This attribute can be configured with TEMPLATES_AUTO_RELOAD. If not set, it will be enabled in debug mode.  Changelog New in version 1.0: This property was added but the underlying config and behavior already existed.  \n\n  \ntest_cli_runner(**kwargs)  \nCreate a CLI runner for testing CLI commands. See Testing CLI Commands. Returns an instance of test_cli_runner_class, by default FlaskCliRunner. The Flask app object is passed as the first argument.  Changelog New in version 1.0.   Parameters \nkwargs (Any) \u2013   Return type \nFlaskCliRunner   \n  \ntest_cli_runner_class: Optional[Type[FlaskCliRunner]] = None  \nThe CliRunner subclass, by default FlaskCliRunner that is used by test_cli_runner(). Its __init__ method should take a Flask app object as the first argument.  Changelog New in version 1.0.  \n\n  \ntest_client(use_cookies=True, **kwargs)  \nCreates a test client for this application. For information about unit testing head over to Testing Flask Applications. Note that if you are testing for assertions or exceptions in your application code, you must set app.testing = True in order for the exceptions to propagate to the test client. Otherwise, the exception will be handled by the application (not visible to the test client) and the only indication of an AssertionError or other exception will be a 500 status code response to the test client. See the testing attribute. For example: app.testing = True\nclient = app.test_client()\n The test client can be used in a with block to defer the closing down of the context until the end of the with block. This is useful if you want to access the context locals for testing: with app.test_client() as c:\n    rv = c.get('/?vodka=42')\n    assert request.args['vodka'] == '42'\n Additionally, you may pass optional keyword arguments that will then be passed to the application\u2019s test_client_class constructor. For example: from flask.testing import FlaskClient\n\nclass CustomClient(FlaskClient):\n    def __init__(self, *args, **kwargs):\n        self._authentication = kwargs.pop(\"authentication\")\n        super(CustomClient,self).__init__( *args, **kwargs)\n\napp.test_client_class = CustomClient\nclient = app.test_client(authentication='Basic ....')\n See FlaskClient for more information.  Changelog Changed in version 0.11: Added **kwargs to support passing additional keyword arguments to the constructor of test_client_class.   New in version 0.7: The use_cookies parameter was added as well as the ability to override the client to be used by setting the test_client_class attribute.   Changed in version 0.4: added support for with block usage for the client.   Parameters \n \nuse_cookies (bool) \u2013  \nkwargs (Any) \u2013    Return type \nFlaskClient   \n  \ntest_client_class: Optional[Type[FlaskClient]] = None  \nthe test client that is used with when test_client is used.  Changelog New in version 0.7.  \n\n  \ntest_request_context(*args, **kwargs)  \nCreate a RequestContext for a WSGI environment created from the given values. This is mostly useful during testing, where you may want to run a function that uses request data without dispatching a full request. See The Request Context. Use a with block to push the context, which will make request point at the request for the created environment. with test_request_context(...):\n    generate_report()\n When using the shell, it may be easier to push and pop the context manually to avoid indentation. ctx = app.test_request_context(...)\nctx.push()\n...\nctx.pop()\n Takes the same arguments as Werkzeug\u2019s EnvironBuilder, with some defaults from the application. See the linked Werkzeug docs for most of the available arguments. Flask-specific behavior is listed here.  Parameters \n \npath \u2013 URL path being requested. \nbase_url \u2013 Base URL where the app is being served, which path is relative to. If not given, built from PREFERRED_URL_SCHEME, subdomain, SERVER_NAME, and APPLICATION_ROOT. \nsubdomain \u2013 Subdomain name to append to SERVER_NAME. \nurl_scheme \u2013 Scheme to use instead of PREFERRED_URL_SCHEME. \ndata \u2013 The request body, either as a string or a dict of form keys and values. \njson \u2013 If given, this is serialized as JSON and passed as data. Also defaults content_type to application/json. \nargs (Any) \u2013 other positional arguments passed to EnvironBuilder. \nkwargs (Any) \u2013 other keyword arguments passed to EnvironBuilder.   Return type \nflask.ctx.RequestContext   \n  \ntesting  \nThe testing flag. Set this to True to enable the test mode of Flask extensions (and in the future probably also Flask itself). For example this might activate test helpers that have an additional runtime cost which should not be enabled by default. If this is enabled and PROPAGATE_EXCEPTIONS is not changed from the default it\u2019s implicitly enabled. This attribute can also be configured from the config with the TESTING configuration key. Defaults to False. \n  \ntrap_http_exception(e)  \nChecks if an HTTP exception should be trapped or not. By default this will return False for all exceptions except for a bad request key error if TRAP_BAD_REQUEST_ERRORS is set to True. It also returns True if TRAP_HTTP_EXCEPTIONS is set to True. This is called for all HTTP exceptions raised by a view function. If it returns True for any exception the error handler for this exception is not called and it shows up as regular exception in the traceback. This is helpful for debugging implicitly raised HTTP exceptions.  Changelog Changed in version 1.0: Bad request errors are not trapped by default in debug mode.   New in version 0.8.   Parameters \ne (Exception) \u2013   Return type \nbool   \n  \nupdate_template_context(context)  \nUpdate the template context with some commonly used variables. This injects request, session, config and g into the template context as well as everything template context processors want to inject. Note that the as of Flask 0.6, the original values in the context will not be overridden if a context processor decides to return a value with the same key.  Parameters \ncontext (dict) \u2013 the context as a dictionary that is updated in place to add extra variables.  Return type \nNone   \n  \nurl_build_error_handlers: t.List[t.Callable[[Exception, str, dict], str]]  \nA list of functions that are called when url_for() raises a BuildError. Each function registered here is called with error, endpoint and values. If a function returns None or raises a BuildError the next function is tried.  Changelog New in version 0.9.  \n\n  \nurl_default_functions: t.Dict[AppOrBlueprintKey, t.List[URLDefaultCallable]]  \nA data structure of functions to call to modify the keyword arguments when generating URLs, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests. To register a function, use the url_defaults() decorator. This data structure is internal. It should not be modified directly and its format may change at any time. \n  \nurl_defaults(f)  \nCallback function for URL defaults for all view functions of the application. It\u2019s called with the endpoint and values and should update the values passed in place.  Parameters \nf (Callable[[str, dict], None]) \u2013   Return type \nCallable[[str, dict], None]   \n  \nurl_map  \nThe Map for this instance. You can use this to change the routing converters after the class was created but before any routes are connected. Example: from werkzeug.routing import BaseConverter\n\nclass ListConverter(BaseConverter):\n    def to_python(self, value):\n        return value.split(',')\n    def to_url(self, values):\n        return ','.join(super(ListConverter, self).to_url(value)\n                        for value in values)\n\napp = Flask(__name__)\napp.url_map.converters['list'] = ListConverter\n \n  \nurl_map_class  \nalias of werkzeug.routing.Map \n  \nurl_rule_class  \nalias of werkzeug.routing.Rule \n  \nurl_value_preprocessor(f)  \nRegister a URL value preprocessor function for all view functions in the application. These functions will be called before the before_request() functions. The function can modify the values captured from the matched url before they are passed to the view. For example, this can be used to pop a common language code value and place it in g rather than pass it to every view. The function is passed the endpoint name and values dict. The return value is ignored.  Parameters \nf (Callable[[Optional[str], Optional[dict]], None]) \u2013   Return type \nCallable[[Optional[str], Optional[dict]], None]   \n  \nurl_value_preprocessors: t.Dict[AppOrBlueprintKey, t.List[URLValuePreprocessorCallable]]  \nA data structure of functions to call to modify the keyword arguments passed to the view function, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests. To register a function, use the url_value_preprocessor() decorator. This data structure is internal. It should not be modified directly and its format may change at any time. \n  \nuse_x_sendfile  \nEnable this if you want to use the X-Sendfile feature. Keep in mind that the server has to support this. This only affects files sent with the send_file() method.  Changelog New in version 0.2.  This attribute can also be configured from the config with the USE_X_SENDFILE configuration key. Defaults to False. \n  \nview_functions: t.Dict[str, t.Callable]  \nA dictionary mapping endpoint names to view functions. To register a view function, use the route() decorator. This data structure is internal. It should not be modified directly and its format may change at any time. \n  \nwsgi_app(environ, start_response)  \nThe actual WSGI application. This is not implemented in __call__() so that middlewares can be applied without losing a reference to the app object. Instead of doing this: app = MyMiddleware(app)\n It\u2019s a better idea to do this instead: app.wsgi_app = MyMiddleware(app.wsgi_app)\n Then you still have the original application object around and can continue to call methods on it.  Changelog Changed in version 0.7: Teardown events for the request and app contexts are called even if an unhandled error occurs. Other events may not be called depending on when an error occurs during dispatch. See Callbacks and Errors.   Parameters \n \nenviron (dict) \u2013 A WSGI environment. \nstart_response (Callable) \u2013 A callable accepting a status code, a list of headers, and an optional exception context to start the response.   Return type \nAny   \n \n"}, {"name": "Flask.add_template_filter()", "path": "api/index#flask.Flask.add_template_filter", "type": "flask", "text": " \nadd_template_filter(f, name=None)  \nRegister a custom template filter. Works exactly like the template_filter() decorator.  Parameters \n \nname (Optional[str]) \u2013 the optional name of the filter, otherwise the function name will be used. \nf (Callable[[Any], str]) \u2013    Return type \nNone   \n"}, {"name": "Flask.add_template_global()", "path": "api/index#flask.Flask.add_template_global", "type": "flask", "text": " \nadd_template_global(f, name=None)  \nRegister a custom template global function. Works exactly like the template_global() decorator.  Changelog New in version 0.10.   Parameters \n \nname (Optional[str]) \u2013 the optional name of the global function, otherwise the function name will be used. \nf (Callable[[], Any]) \u2013    Return type \nNone   \n"}, {"name": "Flask.add_template_test()", "path": "api/index#flask.Flask.add_template_test", "type": "flask", "text": " \nadd_template_test(f, name=None)  \nRegister a custom template test. Works exactly like the template_test() decorator.  Changelog New in version 0.10.   Parameters \n \nname (Optional[str]) \u2013 the optional name of the test, otherwise the function name will be used. \nf (Callable[[Any], bool]) \u2013    Return type \nNone   \n"}, {"name": "Flask.add_url_rule()", "path": "api/index#flask.Flask.add_url_rule", "type": "flask", "text": " \nadd_url_rule(rule, endpoint=None, view_func=None, provide_automatic_options=None, **options)  \nRegister a rule for routing incoming requests and building URLs. The route() decorator is a shortcut to call this with the view_func argument. These are equivalent: @app.route(\"/\")\ndef index():\n    ...\n def index():\n    ...\n\napp.add_url_rule(\"/\", view_func=index)\n See URL Route Registrations. The endpoint name for the route defaults to the name of the view function if the endpoint parameter isn\u2019t passed. An error will be raised if a function has already been registered for the endpoint. The methods parameter defaults to [\"GET\"]. HEAD is always added automatically, and OPTIONS is added automatically by default. view_func does not necessarily need to be passed, but if the rule should participate in routing an endpoint name must be associated with a view function at some point with the endpoint() decorator. app.add_url_rule(\"/\", endpoint=\"index\")\n\n@app.endpoint(\"index\")\ndef index():\n    ...\n If view_func has a required_methods attribute, those methods are added to the passed and automatic methods. If it has a provide_automatic_methods attribute, it is used as the default if the parameter is not passed.  Parameters \n \nrule (str) \u2013 The URL rule string. \nendpoint (Optional[str]) \u2013 The endpoint name to associate with the rule and view function. Used when routing and building URLs. Defaults to view_func.__name__. \nview_func (Optional[Callable]) \u2013 The view function to associate with the endpoint name. \nprovide_automatic_options (Optional[bool]) \u2013 Add the OPTIONS method and respond to OPTIONS requests automatically. \noptions (Any) \u2013 Extra options passed to the Rule object.   Return type \nNone   \n"}, {"name": "Flask.after_request()", "path": "api/index#flask.Flask.after_request", "type": "flask", "text": " \nafter_request(f)  \nRegister a function to run after each request to this object. The function is called with the response object, and must return a response object. This allows the functions to modify or replace the response before it is sent. If a function raises an exception, any remaining after_request functions will not be called. Therefore, this should not be used for actions that must execute, such as to close resources. Use teardown_request() for that.  Parameters \nf (Callable[[Response], Response]) \u2013   Return type \nCallable[[Response], Response]   \n"}, {"name": "Flask.after_request_funcs", "path": "api/index#flask.Flask.after_request_funcs", "type": "flask", "text": " \nafter_request_funcs: t.Dict[AppOrBlueprintKey, t.List[AfterRequestCallable]]  \nA data structure of functions to call at the end of each request, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests. To register a function, use the after_request() decorator. This data structure is internal. It should not be modified directly and its format may change at any time. \n"}, {"name": "flask.appcontext_popped", "path": "api/index#flask.appcontext_popped", "type": "flask", "text": " \nflask.appcontext_popped  \nThis signal is sent when an application context is popped. The sender is the application. This usually falls in line with the appcontext_tearing_down signal.  Changelog New in version 0.10.  \n\n"}, {"name": "flask.appcontext_pushed", "path": "api/index#flask.appcontext_pushed", "type": "flask", "text": " \nflask.appcontext_pushed  \nThis signal is sent when an application context is pushed. The sender is the application. This is usually useful for unittests in order to temporarily hook in information. For instance it can be used to set a resource early onto the g object. Example usage: from contextlib import contextmanager\nfrom flask import appcontext_pushed\n\n@contextmanager\ndef user_set(app, user):\n    def handler(sender, **kwargs):\n        g.user = user\n    with appcontext_pushed.connected_to(handler, app):\n        yield\n And in the testcode: def test_user_me(self):\n    with user_set(app, 'john'):\n        c = app.test_client()\n        resp = c.get('/users/me')\n        assert resp.data == 'username=john'\n  Changelog New in version 0.10.  \n\n"}, {"name": "flask.appcontext_tearing_down", "path": "api/index#flask.appcontext_tearing_down", "type": "flask", "text": " \nflask.appcontext_tearing_down  \nThis signal is sent when the app context is tearing down. This is always called, even if an exception is caused. Currently functions listening to this signal are called after the regular teardown handlers, but this is not something you can rely on. Example subscriber: def close_db_connection(sender, **extra):\n    session.close()\n\nfrom flask import appcontext_tearing_down\nappcontext_tearing_down.connect(close_db_connection, app)\n This will also be passed an exc keyword argument that has a reference to the exception that caused the teardown if there was one. \n"}, {"name": "Flask.app_context()", "path": "api/index#flask.Flask.app_context", "type": "flask", "text": " \napp_context()  \nCreate an AppContext. Use as a with block to push the context, which will make current_app point at this application. An application context is automatically pushed by RequestContext.push() when handling a request, and when running a CLI command. Use this to manually create a context outside of these situations. with app.app_context():\n    init_db()\n See The Application Context.  Changelog New in version 0.9.   Return type \nflask.ctx.AppContext   \n"}, {"name": "Flask.app_ctx_globals_class", "path": "api/index#flask.Flask.app_ctx_globals_class", "type": "flask", "text": " \napp_ctx_globals_class  \nalias of flask.ctx._AppCtxGlobals \n"}, {"name": "Flask.async_to_sync()", "path": "api/index#flask.Flask.async_to_sync", "type": "flask", "text": " \nasync_to_sync(func)  \nReturn a sync function that will run the coroutine function. result = app.async_to_sync(func)(*args, **kwargs)\n Override this method to change how the app converts async code to be synchronously callable.  New in version 2.0.   Parameters \nfunc (Callable[[...], Coroutine]) \u2013   Return type \nCallable[[\u2026], Any]   \n"}, {"name": "Flask.auto_find_instance_path()", "path": "api/index#flask.Flask.auto_find_instance_path", "type": "flask", "text": " \nauto_find_instance_path()  \nTries to locate the instance path if it was not provided to the constructor of the application class. It will basically calculate the path to a folder named instance next to your main file or the package.  Changelog New in version 0.8.   Return type \nstr   \n"}, {"name": "Flask.before_first_request()", "path": "api/index#flask.Flask.before_first_request", "type": "flask", "text": " \nbefore_first_request(f)  \nRegisters a function to be run before the first request to this instance of the application. The function will be called without any arguments and its return value is ignored.  Changelog New in version 0.8.   Parameters \nf (Callable[[], None]) \u2013   Return type \nCallable[[], None]   \n"}, {"name": "Flask.before_first_request_funcs", "path": "api/index#flask.Flask.before_first_request_funcs", "type": "flask", "text": " \nbefore_first_request_funcs: t.List[BeforeRequestCallable]  \nA list of functions that will be called at the beginning of the first request to this instance. To register a function, use the before_first_request() decorator.  Changelog New in version 0.8.  \n\n"}, {"name": "Flask.before_request()", "path": "api/index#flask.Flask.before_request", "type": "flask", "text": " \nbefore_request(f)  \nRegister a function to run before each request. For example, this can be used to open a database connection, or to load the logged in user from the session. @app.before_request\ndef load_user():\n    if \"user_id\" in session:\n        g.user = db.session.get(session[\"user_id\"])\n The function will be called without any arguments. If it returns a non-None value, the value is handled as if it was the return value from the view, and further request handling is stopped.  Parameters \nf (Callable[[], None]) \u2013   Return type \nCallable[[], None]   \n"}, {"name": "Flask.before_request_funcs", "path": "api/index#flask.Flask.before_request_funcs", "type": "flask", "text": " \nbefore_request_funcs: t.Dict[AppOrBlueprintKey, t.List[BeforeRequestCallable]]  \nA data structure of functions to call at the beginning of each request, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests. To register a function, use the before_request() decorator. This data structure is internal. It should not be modified directly and its format may change at any time. \n"}, {"name": "Flask.blueprints", "path": "api/index#flask.Flask.blueprints", "type": "flask", "text": " \nblueprints: t.Dict[str, \u2018Blueprint\u2019]  \nMaps registered blueprint names to blueprint objects. The dict retains the order the blueprints were registered in. Blueprints can be registered multiple times, this dict does not track how often they were attached.  Changelog New in version 0.7.  \n\n"}, {"name": "Flask.cli", "path": "api/index#flask.Flask.cli", "type": "flask", "text": " \ncli  \nThe Click command group for registering CLI commands for this object. The commands are available from the flask command once the application has been discovered and blueprints have been registered. \n"}, {"name": "flask.cli.run_command", "path": "api/index#flask.cli.run_command", "type": "flask", "text": " \nflask.cli.run_command = <Command run>  \nRun a local development server. This server is for development purposes only. It does not provide the stability, security, or performance of production WSGI servers. The reloader and debugger are enabled by default if FLASK_ENV=development or FLASK_DEBUG=1.  Parameters \n \nargs (Any) \u2013  \nkwargs (Any) \u2013    Return type \nAny   \n"}, {"name": "flask.cli.shell_command", "path": "api/index#flask.cli.shell_command", "type": "flask", "text": " \nflask.cli.shell_command = <Command shell>  \nRun an interactive Python shell in the context of a given Flask application. The application will populate the default namespace of this shell according to its configuration. This is useful for executing small snippets of management code without having to manually configure the application.  Parameters \n \nargs (Any) \u2013  \nkwargs (Any) \u2013    Return type \nAny   \n"}, {"name": "Flask.config", "path": "api/index#flask.Flask.config", "type": "flask", "text": " \nconfig  \nThe configuration dictionary as Config. This behaves exactly like a regular dictionary but supports additional methods to load a config from files. \n"}, {"name": "Flask.config_class", "path": "api/index#flask.Flask.config_class", "type": "flask", "text": " \nconfig_class  \nalias of flask.config.Config \n"}, {"name": "Flask.context_processor()", "path": "api/index#flask.Flask.context_processor", "type": "flask", "text": " \ncontext_processor(f)  \nRegisters a template context processor function.  Parameters \nf (Callable[[], Dict[str, Any]]) \u2013   Return type \nCallable[[], Dict[str, Any]]   \n"}, {"name": "Flask.create_global_jinja_loader()", "path": "api/index#flask.Flask.create_global_jinja_loader", "type": "flask", "text": " \ncreate_global_jinja_loader()  \nCreates the loader for the Jinja2 environment. Can be used to override just the loader and keeping the rest unchanged. It\u2019s discouraged to override this function. Instead one should override the jinja_loader() function instead. The global loader dispatches between the loaders of the application and the individual blueprints.  Changelog New in version 0.7.   Return type \nflask.templating.DispatchingJinjaLoader   \n"}, {"name": "Flask.create_jinja_environment()", "path": "api/index#flask.Flask.create_jinja_environment", "type": "flask", "text": " \ncreate_jinja_environment()  \nCreate the Jinja environment based on jinja_options and the various Jinja-related methods of the app. Changing jinja_options after this will have no effect. Also adds Flask-related globals and filters to the environment.  Changelog Changed in version 0.11: Environment.auto_reload set in accordance with TEMPLATES_AUTO_RELOAD configuration option.   New in version 0.5.   Return type \nflask.templating.Environment   \n"}, {"name": "Flask.create_url_adapter()", "path": "api/index#flask.Flask.create_url_adapter", "type": "flask", "text": " \ncreate_url_adapter(request)  \nCreates a URL adapter for the given request. The URL adapter is created at a point where the request context is not yet set up so the request is passed explicitly.  Changelog Changed in version 1.0: SERVER_NAME no longer implicitly enables subdomain matching. Use subdomain_matching instead.   Changed in version 0.9: This can now also be called without a request object when the URL adapter is created for the application context.   New in version 0.6.   Parameters \nrequest (Optional[flask.wrappers.Request]) \u2013   Return type \nOptional[werkzeug.routing.MapAdapter]   \n"}, {"name": "flask.current_app", "path": "api/index#flask.current_app", "type": "flask", "text": " \nflask.current_app  \nA proxy to the application handling the current request. This is useful to access the application without needing to import it, or if it can\u2019t be imported, such as when using the application factory pattern or in blueprints and extensions. This is only available when an application context is pushed. This happens automatically during requests and CLI commands. It can be controlled manually with app_context(). This is a proxy. See Notes On Proxies for more information. \n"}, {"name": "Flask.default_config", "path": "api/index#flask.Flask.default_config", "type": "flask", "text": " \ndefault_config = {'APPLICATION_ROOT': '/', 'DEBUG': None, 'ENV': None, 'EXPLAIN_TEMPLATE_LOADING': False, 'JSONIFY_MIMETYPE': 'application/json', 'JSONIFY_PRETTYPRINT_REGULAR': False, 'JSON_AS_ASCII': True, 'JSON_SORT_KEYS': True, 'MAX_CONTENT_LENGTH': None, 'MAX_COOKIE_SIZE': 4093, 'PERMANENT_SESSION_LIFETIME': datetime.timedelta(days=31), 'PREFERRED_URL_SCHEME': 'http', 'PRESERVE_CONTEXT_ON_EXCEPTION': None, 'PROPAGATE_EXCEPTIONS': None, 'SECRET_KEY': None, 'SEND_FILE_MAX_AGE_DEFAULT': None, 'SERVER_NAME': None, 'SESSION_COOKIE_DOMAIN': None, 'SESSION_COOKIE_HTTPONLY': True, 'SESSION_COOKIE_NAME': 'session', 'SESSION_COOKIE_PATH': None, 'SESSION_COOKIE_SAMESITE': None, 'SESSION_COOKIE_SECURE': False, 'SESSION_REFRESH_EACH_REQUEST': True, 'TEMPLATES_AUTO_RELOAD': None, 'TESTING': False, 'TRAP_BAD_REQUEST_ERRORS': None, 'TRAP_HTTP_EXCEPTIONS': False, 'USE_X_SENDFILE': False}  \nDefault configuration parameters. \n"}, {"name": "Flask.delete()", "path": "api/index#flask.Flask.delete", "type": "flask", "text": " \ndelete(rule, **options)  \nShortcut for route() with methods=[\"DELETE\"].  New in version 2.0.   Parameters \n \nrule (str) \u2013  \noptions (Any) \u2013    Return type \nCallable   \n"}, {"name": "Flask.dispatch_request()", "path": "api/index#flask.Flask.dispatch_request", "type": "flask", "text": " \ndispatch_request()  \nDoes the request dispatching. Matches the URL and returns the return value of the view or error handler. This does not have to be a response object. In order to convert the return value to a proper response object, call make_response().  Changelog Changed in version 0.7: This no longer does the exception handling, this code was moved to the new full_dispatch_request().   Return type \nUnion[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], WSGIApplication]   \n"}, {"name": "Flask.do_teardown_appcontext()", "path": "api/index#flask.Flask.do_teardown_appcontext", "type": "flask", "text": " \ndo_teardown_appcontext(exc=<object object>)  \nCalled right before the application context is popped. When handling a request, the application context is popped after the request context. See do_teardown_request(). This calls all functions decorated with teardown_appcontext(). Then the appcontext_tearing_down signal is sent. This is called by AppContext.pop().  Changelog New in version 0.9.   Parameters \nexc (Optional[BaseException]) \u2013   Return type \nNone   \n"}, {"name": "Flask.do_teardown_request()", "path": "api/index#flask.Flask.do_teardown_request", "type": "flask", "text": " \ndo_teardown_request(exc=<object object>)  \nCalled after the request is dispatched and the response is returned, right before the request context is popped. This calls all functions decorated with teardown_request(), and Blueprint.teardown_request() if a blueprint handled the request. Finally, the request_tearing_down signal is sent. This is called by RequestContext.pop(), which may be delayed during testing to maintain access to resources.  Parameters \nexc (Optional[BaseException]) \u2013 An unhandled exception raised while dispatching the request. Detected from the current exception information if not passed. Passed to each teardown function.  Return type \nNone    Changelog Changed in version 0.9: Added the exc argument.  \n\n"}, {"name": "Flask.endpoint()", "path": "api/index#flask.Flask.endpoint", "type": "flask", "text": " \nendpoint(endpoint)  \nDecorate a view function to register it for the given endpoint. Used if a rule is added without a view_func with add_url_rule(). app.add_url_rule(\"/ex\", endpoint=\"example\")\n\n@app.endpoint(\"example\")\ndef example():\n    ...\n  Parameters \nendpoint (str) \u2013 The endpoint name to associate with the view function.  Return type \nCallable   \n"}, {"name": "Flask.ensure_sync()", "path": "api/index#flask.Flask.ensure_sync", "type": "flask", "text": " \nensure_sync(func)  \nEnsure that the function is synchronous for WSGI workers. Plain def functions are returned as-is. async def functions are wrapped to run and wait for the response. Override this method to change how the app runs async views.  New in version 2.0.   Parameters \nfunc (Callable) \u2013   Return type \nCallable   \n"}, {"name": "Flask.env", "path": "api/index#flask.Flask.env", "type": "flask", "text": " \nenv  \nWhat environment the app is running in. Flask and extensions may enable behaviors based on the environment, such as enabling debug mode. This maps to the ENV config key. This is set by the FLASK_ENV environment variable and may not behave as expected if set in code. Do not enable development when deploying in production. Default: 'production' \n"}, {"name": "Flask.errorhandler()", "path": "api/index#flask.Flask.errorhandler", "type": "flask", "text": " \nerrorhandler(code_or_exception)  \nRegister a function to handle errors by code or exception class. A decorator that is used to register a function given an error code. Example: @app.errorhandler(404)\ndef page_not_found(error):\n    return 'This page does not exist', 404\n You can also register handlers for arbitrary exceptions: @app.errorhandler(DatabaseError)\ndef special_exception_handler(error):\n    return 'Database connection failed', 500\n  Changelog New in version 0.7: Use register_error_handler() instead of modifying error_handler_spec directly, for application wide error handlers.   New in version 0.7: One can now additionally also register custom exception types that do not necessarily have to be a subclass of the HTTPException class.   Parameters \ncode_or_exception (Union[Type[Exception], int]) \u2013 the code as integer for the handler, or an arbitrary exception  Return type \nCallable   \n"}, {"name": "Flask.error_handler_spec", "path": "api/index#flask.Flask.error_handler_spec", "type": "flask", "text": " \nerror_handler_spec: t.Dict[AppOrBlueprintKey, t.Dict[t.Optional[int], t.Dict[t.Type[Exception], ErrorHandlerCallable]]]  \nA data structure of registered error handlers, in the format {scope: {code: {class: handler}}}`. The scope key is the name of a blueprint the handlers are active for, or None for all requests. The code key is the HTTP status code for HTTPException, or None for other exceptions. The innermost dictionary maps exception classes to handler functions. To register an error handler, use the errorhandler() decorator. This data structure is internal. It should not be modified directly and its format may change at any time. \n"}, {"name": "Flask.extensions", "path": "api/index#flask.Flask.extensions", "type": "flask", "text": " \nextensions: dict  \na place where extensions can store application specific state. For example this is where an extension could store database engines and similar things. The key must match the name of the extension module. For example in case of a \u201cFlask-Foo\u201d extension in flask_foo, the key would be 'foo'.  Changelog New in version 0.7.  \n\n"}, {"name": "Flask.full_dispatch_request()", "path": "api/index#flask.Flask.full_dispatch_request", "type": "flask", "text": " \nfull_dispatch_request()  \nDispatches the request and on top of that performs request pre and postprocessing as well as HTTP exception catching and error handling.  Changelog New in version 0.7.   Return type \nflask.wrappers.Response   \n"}, {"name": "flask.g", "path": "api/index#flask.g", "type": "flask", "text": " \nflask.g  \nA namespace object that can store data during an application context. This is an instance of Flask.app_ctx_globals_class, which defaults to ctx._AppCtxGlobals. This is a good place to store resources during a request. During testing, you can use the Faking Resources and Context pattern to pre-configure such resources. This is a proxy. See Notes On Proxies for more information.  Changelog Changed in version 0.10: Bound to the application context instead of the request context.  \n\n"}, {"name": "Flask.get()", "path": "api/index#flask.Flask.get", "type": "flask", "text": " \nget(rule, **options)  \nShortcut for route() with methods=[\"GET\"].  New in version 2.0.   Parameters \n \nrule (str) \u2013  \noptions (Any) \u2013    Return type \nCallable   \n"}, {"name": "Flask.get_send_file_max_age()", "path": "api/index#flask.Flask.get_send_file_max_age", "type": "flask", "text": " \nget_send_file_max_age(filename)  \nUsed by send_file() to determine the max_age cache value for a given file path if it wasn\u2019t passed. By default, this returns SEND_FILE_MAX_AGE_DEFAULT from the configuration of current_app. This defaults to None, which tells the browser to use conditional requests instead of a timed cache, which is usually preferable.  Changed in version 2.0: The default configuration is None instead of 12 hours.   Changelog New in version 0.9.   Parameters \nfilename (str) \u2013   Return type \nOptional[int]   \n"}, {"name": "flask.got_request_exception", "path": "api/index#flask.got_request_exception", "type": "flask", "text": " \nflask.got_request_exception  \nThis signal is sent when an unhandled exception happens during request processing, including when debugging. The exception is passed to the subscriber as exception. This signal is not sent for HTTPException, or other exceptions that have error handlers registered, unless the exception was raised from an error handler. This example shows how to do some extra logging if a theoretical SecurityException was raised: from flask import got_request_exception\n\ndef log_security_exception(sender, exception, **extra):\n    if not isinstance(exception, SecurityException):\n        return\n\n    security_logger.exception(\n        f\"SecurityException at {request.url!r}\",\n        exc_info=exception,\n    )\n\ngot_request_exception.connect(log_security_exception, app)\n \n"}, {"name": "Flask.handle_exception()", "path": "api/index#flask.Flask.handle_exception", "type": "flask", "text": " \nhandle_exception(e)  \nHandle an exception that did not have an error handler associated with it, or that was raised from an error handler. This always causes a 500 InternalServerError. Always sends the got_request_exception signal. If propagate_exceptions is True, such as in debug mode, the error will be re-raised so that the debugger can display it. Otherwise, the original exception is logged, and an InternalServerError is returned. If an error handler is registered for InternalServerError or 500, it will be used. For consistency, the handler will always receive the InternalServerError. The original unhandled exception is available as e.original_exception.  Changelog Changed in version 1.1.0: Always passes the InternalServerError instance to the handler, setting original_exception to the unhandled error.   Changed in version 1.1.0: after_request functions and other finalization is done even for the default 500 response when there is no handler.   New in version 0.3.   Parameters \ne (Exception) \u2013   Return type \nflask.wrappers.Response   \n"}, {"name": "Flask.handle_http_exception()", "path": "api/index#flask.Flask.handle_http_exception", "type": "flask", "text": " \nhandle_http_exception(e)  \nHandles an HTTP exception. By default this will invoke the registered error handlers and fall back to returning the exception as response.  Changelog Changed in version 1.0.3: RoutingException, used internally for actions such as slash redirects during routing, is not passed to error handlers.   Changed in version 1.0: Exceptions are looked up by code and by MRO, so HTTPExcpetion subclasses can be handled with a catch-all handler for the base HTTPException.   New in version 0.3.   Parameters \ne (werkzeug.exceptions.HTTPException) \u2013   Return type \nUnion[werkzeug.exceptions.HTTPException, Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], WSGIApplication]   \n"}, {"name": "Flask.handle_url_build_error()", "path": "api/index#flask.Flask.handle_url_build_error", "type": "flask", "text": " \nhandle_url_build_error(error, endpoint, values)  \nHandle BuildError on url_for().  Parameters \n \nerror (Exception) \u2013  \nendpoint (str) \u2013  \nvalues (dict) \u2013    Return type \nstr   \n"}, {"name": "Flask.handle_user_exception()", "path": "api/index#flask.Flask.handle_user_exception", "type": "flask", "text": " \nhandle_user_exception(e)  \nThis method is called whenever an exception occurs that should be handled. A special case is HTTPException which is forwarded to the handle_http_exception() method. This function will either return a response value or reraise the exception with the same traceback.  Changelog Changed in version 1.0: Key errors raised from request data like form show the bad key in debug mode rather than a generic bad request message.   New in version 0.7.   Parameters \ne (Exception) \u2013   Return type \nUnion[werkzeug.exceptions.HTTPException, Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], WSGIApplication]   \n"}, {"name": "Flask.import_name", "path": "api/index#flask.Flask.import_name", "type": "flask", "text": " \nimport_name  \nThe name of the package or module that this object belongs to. Do not change this once it is set by the constructor. \n"}, {"name": "Flask.inject_url_defaults()", "path": "api/index#flask.Flask.inject_url_defaults", "type": "flask", "text": " \ninject_url_defaults(endpoint, values)  \nInjects the URL defaults for the given endpoint directly into the values dictionary passed. This is used internally and automatically called on URL building.  Changelog New in version 0.7.   Parameters \n \nendpoint (str) \u2013  \nvalues (dict) \u2013    Return type \nNone   \n"}, {"name": "Flask.instance_path", "path": "api/index#flask.Flask.instance_path", "type": "flask", "text": " \ninstance_path  \nHolds the path to the instance folder.  Changelog New in version 0.8.  \n\n"}, {"name": "Flask.iter_blueprints()", "path": "api/index#flask.Flask.iter_blueprints", "type": "flask", "text": " \niter_blueprints()  \nIterates over all blueprints by the order they were registered.  Changelog New in version 0.11.   Return type \nValuesView[Blueprint]   \n"}, {"name": "Flask.jinja_environment", "path": "api/index#flask.Flask.jinja_environment", "type": "flask", "text": " \njinja_environment  \nalias of flask.templating.Environment \n"}, {"name": "Flask.jinja_options", "path": "api/index#flask.Flask.jinja_options", "type": "flask", "text": " \njinja_options: dict = {}  \nOptions that are passed to the Jinja environment in create_jinja_environment(). Changing these options after the environment is created (accessing jinja_env) will have no effect.  Changelog Changed in version 1.1.0: This is a dict instead of an ImmutableDict to allow easier configuration.  \n\n"}, {"name": "Flask.json_decoder", "path": "api/index#flask.Flask.json_decoder", "type": "flask", "text": " \njson_decoder  \nalias of flask.json.JSONDecoder \n"}, {"name": "Flask.json_encoder", "path": "api/index#flask.Flask.json_encoder", "type": "flask", "text": " \njson_encoder  \nalias of flask.json.JSONEncoder \n"}, {"name": "Flask.log_exception()", "path": "api/index#flask.Flask.log_exception", "type": "flask", "text": " \nlog_exception(exc_info)  \nLogs an exception. This is called by handle_exception() if debugging is disabled and right before the handler is called. The default implementation logs the exception as error on the logger.  Changelog New in version 0.8.   Parameters \nexc_info (Union[Tuple[type, BaseException, types.TracebackType], Tuple[None, None, None]]) \u2013   Return type \nNone   \n"}, {"name": "Flask.make_config()", "path": "api/index#flask.Flask.make_config", "type": "flask", "text": " \nmake_config(instance_relative=False)  \nUsed to create the config attribute by the Flask constructor. The instance_relative parameter is passed in from the constructor of Flask (there named instance_relative_config) and indicates if the config should be relative to the instance path or the root path of the application.  Changelog New in version 0.8.   Parameters \ninstance_relative (bool) \u2013   Return type \nflask.config.Config   \n"}, {"name": "Flask.make_default_options_response()", "path": "api/index#flask.Flask.make_default_options_response", "type": "flask", "text": " \nmake_default_options_response()  \nThis method is called to create the default OPTIONS response. This can be changed through subclassing to change the default behavior of OPTIONS responses.  Changelog New in version 0.7.   Return type \nflask.wrappers.Response   \n"}, {"name": "Flask.make_response()", "path": "api/index#flask.Flask.make_response", "type": "flask", "text": " \nmake_response(rv)  \nConvert the return value from a view function to an instance of response_class.  Parameters \nrv (Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], Union[Headers, Dict[str, Union[str, List[str], Tuple[str, ...]]], List[Tuple[str, Union[str, List[str], Tuple[str, ...]]]]]], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, ...]]], List[Tuple[str, Union[str, List[str], Tuple[str, ...]]]]]], WSGIApplication]) \u2013 \nthe return value from the view function. The view function must return a response. Returning None, or the view ending without returning, is not allowed. The following types are allowed for view_rv:  \nstr \n\nA response object is created with the string encoded to UTF-8 as the body.  \nbytes \n\nA response object is created with the bytes as the body.  \ndict \n\nA dictionary that will be jsonify\u2019d before being returned.  \ntuple \n\nEither (body, status, headers), (body, status), or (body, headers), where body is any of the other types allowed here, status is a string or an integer, and headers is a dictionary or a list of (key, value) tuples. If body is a response_class instance, status overwrites the exiting value and headers are extended.  \nresponse_class\n\n\nThe object is returned unchanged.  \nother Response class \n\nThe object is coerced to response_class.  \ncallable()\n\n\nThe function is called as a WSGI application. The result is used to create a response object.    Return type \nflask.wrappers.Response    Changelog Changed in version 0.9: Previously a tuple was interpreted as the arguments for the response object.  \n\n"}, {"name": "Flask.make_shell_context()", "path": "api/index#flask.Flask.make_shell_context", "type": "flask", "text": " \nmake_shell_context()  \nReturns the shell context for an interactive shell for this application. This runs all the registered shell context processors.  Changelog New in version 0.11.   Return type \ndict   \n"}, {"name": "flask.message_flashed", "path": "api/index#flask.message_flashed", "type": "flask", "text": " \nflask.message_flashed  \nThis signal is sent when the application is flashing a message. The messages is sent as message keyword argument and the category as category. Example subscriber: recorded = []\ndef record(sender, message, category, **extra):\n    recorded.append((message, category))\n\nfrom flask import message_flashed\nmessage_flashed.connect(record, app)\n  Changelog New in version 0.10.  \n\n"}, {"name": "Flask.open_instance_resource()", "path": "api/index#flask.Flask.open_instance_resource", "type": "flask", "text": " \nopen_instance_resource(resource, mode='rb')  \nOpens a resource from the application\u2019s instance folder (instance_path). Otherwise works like open_resource(). Instance resources can also be opened for writing.  Parameters \n \nresource (str) \u2013 the name of the resource. To access resources within subfolders use forward slashes as separator. \nmode (str) \u2013 resource file opening mode, default is \u2018rb\u2019.   Return type \nIO   \n"}, {"name": "Flask.open_resource()", "path": "api/index#flask.Flask.open_resource", "type": "flask", "text": " \nopen_resource(resource, mode='rb')  \nOpen a resource file relative to root_path for reading. For example, if the file schema.sql is next to the file app.py where the Flask app is defined, it can be opened with: with app.open_resource(\"schema.sql\") as f:\n    conn.executescript(f.read())\n  Parameters \n \nresource (str) \u2013 Path to the resource relative to root_path. \nmode (str) \u2013 Open the file in this mode. Only reading is supported, valid values are \u201cr\u201d (or \u201crt\u201d) and \u201crb\u201d.   Return type \nIO   \n"}, {"name": "Flask.patch()", "path": "api/index#flask.Flask.patch", "type": "flask", "text": " \npatch(rule, **options)  \nShortcut for route() with methods=[\"PATCH\"].  New in version 2.0.   Parameters \n \nrule (str) \u2013  \noptions (Any) \u2013    Return type \nCallable   \n"}, {"name": "Flask.permanent_session_lifetime", "path": "api/index#flask.Flask.permanent_session_lifetime", "type": "flask", "text": " \npermanent_session_lifetime  \nA timedelta which is used to set the expiration date of a permanent session. The default is 31 days which makes a permanent session survive for roughly one month. This attribute can also be configured from the config with the PERMANENT_SESSION_LIFETIME configuration key. Defaults to timedelta(days=31) \n"}, {"name": "Flask.post()", "path": "api/index#flask.Flask.post", "type": "flask", "text": " \npost(rule, **options)  \nShortcut for route() with methods=[\"POST\"].  New in version 2.0.   Parameters \n \nrule (str) \u2013  \noptions (Any) \u2013    Return type \nCallable   \n"}, {"name": "Flask.preprocess_request()", "path": "api/index#flask.Flask.preprocess_request", "type": "flask", "text": " \npreprocess_request()  \nCalled before the request is dispatched. Calls url_value_preprocessors registered with the app and the current blueprint (if any). Then calls before_request_funcs registered with the app and the blueprint. If any before_request() handler returns a non-None value, the value is handled as if it was the return value from the view, and further request handling is stopped.  Return type \nOptional[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], WSGIApplication]]   \n"}, {"name": "Flask.process_response()", "path": "api/index#flask.Flask.process_response", "type": "flask", "text": " \nprocess_response(response)  \nCan be overridden in order to modify the response object before it\u2019s sent to the WSGI server. By default this will call all the after_request() decorated functions.  Changelog Changed in version 0.5: As of Flask 0.5 the functions registered for after request execution are called in reverse order of registration.   Parameters \nresponse (flask.wrappers.Response) \u2013 a response_class object.  Returns \na new response object or the same, has to be an instance of response_class.  Return type \nflask.wrappers.Response   \n"}, {"name": "Flask.put()", "path": "api/index#flask.Flask.put", "type": "flask", "text": " \nput(rule, **options)  \nShortcut for route() with methods=[\"PUT\"].  New in version 2.0.   Parameters \n \nrule (str) \u2013  \noptions (Any) \u2013    Return type \nCallable   \n"}, {"name": "Flask.register_blueprint()", "path": "api/index#flask.Flask.register_blueprint", "type": "flask", "text": " \nregister_blueprint(blueprint, **options)  \nRegister a Blueprint on the application. Keyword arguments passed to this method will override the defaults set on the blueprint. Calls the blueprint\u2019s register() method after recording the blueprint in the application\u2019s blueprints.  Parameters \n \nblueprint (Blueprint) \u2013 The blueprint to register. \nurl_prefix \u2013 Blueprint routes will be prefixed with this. \nsubdomain \u2013 Blueprint routes will match on this subdomain. \nurl_defaults \u2013 Blueprint routes will use these default values for view arguments. \noptions (Any) \u2013 Additional keyword arguments are passed to BlueprintSetupState. They can be accessed in record() callbacks.   Return type \nNone    Changelog New in version 0.7.  \n\n"}, {"name": "Flask.register_error_handler()", "path": "api/index#flask.Flask.register_error_handler", "type": "flask", "text": " \nregister_error_handler(code_or_exception, f)  \nAlternative error attach function to the errorhandler() decorator that is more straightforward to use for non decorator usage.  Changelog New in version 0.7.   Parameters \n \ncode_or_exception (Union[Type[Exception], int]) \u2013  \nf (Callable[[Exception], Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], Union[Headers, Dict[str, Union[str, List[str], Tuple[str, ...]]], List[Tuple[str, Union[str, List[str], Tuple[str, ...]]]]]], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, ...]]], List[Tuple[str, Union[str, List[str], Tuple[str, ...]]]]]], WSGIApplication]]) \u2013    Return type \nNone   \n"}, {"name": "flask.request", "path": "api/index#flask.request", "type": "flask", "text": " \nflask.request  \nTo access incoming request data, you can use the global request object. Flask parses incoming request data for you and gives you access to it through that global object. Internally Flask makes sure that you always get the correct data for the active thread if you are in a multithreaded environment. This is a proxy. See Notes On Proxies for more information. The request object is an instance of a Request. \n"}, {"name": "Flask.request_class", "path": "api/index#flask.Flask.request_class", "type": "flask", "text": " \nrequest_class  \nalias of flask.wrappers.Request \n"}, {"name": "Flask.request_context()", "path": "api/index#flask.Flask.request_context", "type": "flask", "text": " \nrequest_context(environ)  \nCreate a RequestContext representing a WSGI environment. Use a with block to push the context, which will make request point at this request. See The Request Context. Typically you should not call this from your own code. A request context is automatically pushed by the wsgi_app() when handling a request. Use test_request_context() to create an environment and context instead of this method.  Parameters \nenviron (dict) \u2013 a WSGI environment  Return type \nflask.ctx.RequestContext   \n"}, {"name": "flask.request_finished", "path": "api/index#flask.request_finished", "type": "flask", "text": " \nflask.request_finished  \nThis signal is sent right before the response is sent to the client. It is passed the response to be sent named response. Example subscriber: def log_response(sender, response, **extra):\n    sender.logger.debug('Request context is about to close down.  '\n                        'Response: %s', response)\n\nfrom flask import request_finished\nrequest_finished.connect(log_response, app)\n \n"}, {"name": "flask.request_started", "path": "api/index#flask.request_started", "type": "flask", "text": " \nflask.request_started  \nThis signal is sent when the request context is set up, before any request processing happens. Because the request context is already bound, the subscriber can access the request with the standard global proxies such as request. Example subscriber: def log_request(sender, **extra):\n    sender.logger.debug('Request context is set up')\n\nfrom flask import request_started\nrequest_started.connect(log_request, app)\n \n"}, {"name": "flask.request_tearing_down", "path": "api/index#flask.request_tearing_down", "type": "flask", "text": " \nflask.request_tearing_down  \nThis signal is sent when the request is tearing down. This is always called, even if an exception is caused. Currently functions listening to this signal are called after the regular teardown handlers, but this is not something you can rely on. Example subscriber: def close_db_connection(sender, **extra):\n    session.close()\n\nfrom flask import request_tearing_down\nrequest_tearing_down.connect(close_db_connection, app)\n As of Flask 0.9, this will also be passed an exc keyword argument that has a reference to the exception that caused the teardown if there was one. \n"}, {"name": "Flask.response_class", "path": "api/index#flask.Flask.response_class", "type": "flask", "text": " \nresponse_class  \nalias of flask.wrappers.Response \n"}, {"name": "Flask.root_path", "path": "api/index#flask.Flask.root_path", "type": "flask", "text": " \nroot_path  \nAbsolute path to the package on the filesystem. Used to look up resources contained in the package. \n"}, {"name": "Flask.route()", "path": "api/index#flask.Flask.route", "type": "flask", "text": " \nroute(rule, **options)  \nDecorate a view function to register it with the given URL rule and options. Calls add_url_rule(), which has more details about the implementation. @app.route(\"/\")\ndef index():\n    return \"Hello, World!\"\n See URL Route Registrations. The endpoint name for the route defaults to the name of the view function if the endpoint parameter isn\u2019t passed. The methods parameter defaults to [\"GET\"]. HEAD and OPTIONS are added automatically.  Parameters \n \nrule (str) \u2013 The URL rule string. \noptions (Any) \u2013 Extra options passed to the Rule object.   Return type \nCallable   \n"}, {"name": "Flask.run()", "path": "api/index#flask.Flask.run", "type": "flask", "text": " \nrun(host=None, port=None, debug=None, load_dotenv=True, **options)  \nRuns the application on a local development server. Do not use run() in a production setting. It is not intended to meet security and performance requirements for a production server. Instead, see Deployment Options for WSGI server recommendations. If the debug flag is set the server will automatically reload for code changes and show a debugger in case an exception happened. If you want to run the application in debug mode, but disable the code execution on the interactive debugger, you can pass use_evalex=False as parameter. This will keep the debugger\u2019s traceback screen active, but disable code execution. It is not recommended to use this function for development with automatic reloading as this is badly supported. Instead you should be using the flask command line script\u2019s run support.  Keep in Mind Flask will suppress any server error with a generic error page unless it is in debug mode. As such to enable just the interactive debugger without the code reloading, you have to invoke run() with debug=True and use_reloader=False. Setting use_debugger to True without being in debug mode won\u2019t catch any exceptions because there won\u2019t be any to catch.   Parameters \n \nhost (Optional[str]) \u2013 the hostname to listen on. Set this to '0.0.0.0' to have the server available externally as well. Defaults to '127.0.0.1' or the host in the SERVER_NAME config variable if present. \nport (Optional[int]) \u2013 the port of the webserver. Defaults to 5000 or the port defined in the SERVER_NAME config variable if present. \ndebug (Optional[bool]) \u2013 if given, enable or disable debug mode. See debug. \nload_dotenv (bool) \u2013 Load the nearest .env and .flaskenv files to set environment variables. Will also change the working directory to the directory containing the first file found. \noptions (Any) \u2013 the options to be forwarded to the underlying Werkzeug server. See werkzeug.serving.run_simple() for more information.   Return type \nNone    Changelog Changed in version 1.0: If installed, python-dotenv will be used to load environment variables from .env and .flaskenv files. If set, the FLASK_ENV and FLASK_DEBUG environment variables will override env and debug. Threaded mode is enabled by default.   Changed in version 0.10: The default port is now picked from the SERVER_NAME variable.  \n\n"}, {"name": "Flask.secret_key", "path": "api/index#flask.Flask.secret_key", "type": "flask", "text": " \nsecret_key  \nIf a secret key is set, cryptographic components can use this to sign cookies and other things. Set this to a complex random value when you want to use the secure cookie for instance. This attribute can also be configured from the config with the SECRET_KEY configuration key. Defaults to None. \n"}, {"name": "Flask.select_jinja_autoescape()", "path": "api/index#flask.Flask.select_jinja_autoescape", "type": "flask", "text": " \nselect_jinja_autoescape(filename)  \nReturns True if autoescaping should be active for the given template name. If no template name is given, returns True.  Changelog New in version 0.5.   Parameters \nfilename (str) \u2013   Return type \nbool   \n"}, {"name": "Flask.send_file_max_age_default", "path": "api/index#flask.Flask.send_file_max_age_default", "type": "flask", "text": " \nsend_file_max_age_default  \nA timedelta or number of seconds which is used as the default max_age for send_file(). The default is None, which tells the browser to use conditional requests instead of a timed cache. Configured with the SEND_FILE_MAX_AGE_DEFAULT configuration key.  Changed in version 2.0: Defaults to None instead of 12 hours.  \n"}, {"name": "Flask.send_static_file()", "path": "api/index#flask.Flask.send_static_file", "type": "flask", "text": " \nsend_static_file(filename)  \nThe view function used to serve files from static_folder. A route is automatically registered for this view at static_url_path if static_folder is set.  Changelog New in version 0.5.   Parameters \nfilename (str) \u2013   Return type \nResponse   \n"}, {"name": "Flask.session_cookie_name", "path": "api/index#flask.Flask.session_cookie_name", "type": "flask", "text": " \nsession_cookie_name  \nThe secure cookie uses this for the name of the session cookie. This attribute can also be configured from the config with the SESSION_COOKIE_NAME configuration key. Defaults to 'session' \n"}, {"name": "Flask.session_interface", "path": "api/index#flask.Flask.session_interface", "type": "flask", "text": " \nsession_interface = <flask.sessions.SecureCookieSessionInterface object>  \nthe session interface to use. By default an instance of SecureCookieSessionInterface is used here.  Changelog New in version 0.8.  \n\n"}, {"name": "Flask.shell_context_processor()", "path": "api/index#flask.Flask.shell_context_processor", "type": "flask", "text": " \nshell_context_processor(f)  \nRegisters a shell context processor function.  Changelog New in version 0.11.   Parameters \nf (Callable) \u2013   Return type \nCallable   \n"}, {"name": "Flask.shell_context_processors", "path": "api/index#flask.Flask.shell_context_processors", "type": "flask", "text": " \nshell_context_processors: t.List[t.Callable[], t.Dict[str, t.Any]]]  \nA list of shell context processor functions that should be run when a shell context is created.  Changelog New in version 0.11.  \n\n"}, {"name": "Flask.should_ignore_error()", "path": "api/index#flask.Flask.should_ignore_error", "type": "flask", "text": " \nshould_ignore_error(error)  \nThis is called to figure out if an error should be ignored or not as far as the teardown system is concerned. If this function returns True then the teardown handlers will not be passed the error.  Changelog New in version 0.10.   Parameters \nerror (Optional[BaseException]) \u2013   Return type \nbool   \n"}, {"name": "flask.signals.signals_available", "path": "api/index#flask.signals.signals_available", "type": "flask", "text": " \nsignals.signals_available  \nTrue if the signaling system is available. This is the case when blinker is installed. \n"}, {"name": "Flask.teardown_appcontext()", "path": "api/index#flask.Flask.teardown_appcontext", "type": "flask", "text": " \nteardown_appcontext(f)  \nRegisters a function to be called when the application context ends. These functions are typically also called when the request context is popped. Example: ctx = app.app_context()\nctx.push()\n...\nctx.pop()\n When ctx.pop() is executed in the above example, the teardown functions are called just before the app context moves from the stack of active contexts. This becomes relevant if you are using such constructs in tests. Since a request context typically also manages an application context it would also be called when you pop a request context. When a teardown function was called because of an unhandled exception it will be passed an error object. If an errorhandler() is registered, it will handle the exception and the teardown will not receive it. The return values of teardown functions are ignored.  Changelog New in version 0.9.   Parameters \nf (Callable[[Optional[BaseException]], flask.wrappers.Response]) \u2013   Return type \nCallable[[Optional[BaseException]], flask.wrappers.Response]   \n"}, {"name": "Flask.teardown_appcontext_funcs", "path": "api/index#flask.Flask.teardown_appcontext_funcs", "type": "flask", "text": " \nteardown_appcontext_funcs: t.List[TeardownCallable]  \nA list of functions that are called when the application context is destroyed. Since the application context is also torn down if the request ends this is the place to store code that disconnects from databases.  Changelog New in version 0.9.  \n\n"}, {"name": "Flask.teardown_request()", "path": "api/index#flask.Flask.teardown_request", "type": "flask", "text": " \nteardown_request(f)  \nRegister a function to be run at the end of each request, regardless of whether there was an exception or not. These functions are executed when the request context is popped, even if not an actual request was performed. Example: ctx = app.test_request_context()\nctx.push()\n...\nctx.pop()\n When ctx.pop() is executed in the above example, the teardown functions are called just before the request context moves from the stack of active contexts. This becomes relevant if you are using such constructs in tests. Teardown functions must avoid raising exceptions, since they . If they execute code that might fail they will have to surround the execution of these code by try/except statements and log occurring errors. When a teardown function was called because of an exception it will be passed an error object. The return values of teardown functions are ignored.  Debug Note In debug mode Flask will not tear down a request on an exception immediately. Instead it will keep it alive so that the interactive debugger can still access it. This behavior can be controlled by the PRESERVE_CONTEXT_ON_EXCEPTION configuration variable.   Parameters \nf (Callable[[Optional[BaseException]], Response]) \u2013   Return type \nCallable[[Optional[BaseException]], Response]   \n"}, {"name": "Flask.teardown_request_funcs", "path": "api/index#flask.Flask.teardown_request_funcs", "type": "flask", "text": " \nteardown_request_funcs: t.Dict[AppOrBlueprintKey, t.List[TeardownCallable]]  \nA data structure of functions to call at the end of each request even if an exception is raised, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests. To register a function, use the teardown_request() decorator. This data structure is internal. It should not be modified directly and its format may change at any time. \n"}, {"name": "Flask.template_context_processors", "path": "api/index#flask.Flask.template_context_processors", "type": "flask", "text": " \ntemplate_context_processors: t.Dict[AppOrBlueprintKey, t.List[TemplateContextProcessorCallable]]  \nA data structure of functions to call to pass extra context values when rendering templates, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests. To register a function, use the context_processor() decorator. This data structure is internal. It should not be modified directly and its format may change at any time. \n"}, {"name": "Flask.template_filter()", "path": "api/index#flask.Flask.template_filter", "type": "flask", "text": " \ntemplate_filter(name=None)  \nA decorator that is used to register custom template filter. You can specify a name for the filter, otherwise the function name will be used. Example: @app.template_filter()\ndef reverse(s):\n    return s[::-1]\n  Parameters \nname (Optional[str]) \u2013 the optional name of the filter, otherwise the function name will be used.  Return type \nCallable   \n"}, {"name": "Flask.template_folder", "path": "api/index#flask.Flask.template_folder", "type": "flask", "text": " \ntemplate_folder  \nThe path to the templates folder, relative to root_path, to add to the template loader. None if templates should not be added. \n"}, {"name": "Flask.template_global()", "path": "api/index#flask.Flask.template_global", "type": "flask", "text": " \ntemplate_global(name=None)  \nA decorator that is used to register a custom template global function. You can specify a name for the global function, otherwise the function name will be used. Example: @app.template_global()\ndef double(n):\n    return 2 * n\n  Changelog New in version 0.10.   Parameters \nname (Optional[str]) \u2013 the optional name of the global function, otherwise the function name will be used.  Return type \nCallable   \n"}, {"name": "flask.template_rendered", "path": "api/index#flask.template_rendered", "type": "flask", "text": " \nflask.template_rendered  \nThis signal is sent when a template was successfully rendered. The signal is invoked with the instance of the template as template and the context as dictionary (named context). Example subscriber: def log_template_renders(sender, template, context, **extra):\n    sender.logger.debug('Rendering template \"%s\" with context %s',\n                        template.name or 'string template',\n                        context)\n\nfrom flask import template_rendered\ntemplate_rendered.connect(log_template_renders, app)\n \n"}, {"name": "Flask.template_test()", "path": "api/index#flask.Flask.template_test", "type": "flask", "text": " \ntemplate_test(name=None)  \nA decorator that is used to register custom template test. You can specify a name for the test, otherwise the function name will be used. Example: @app.template_test()\ndef is_prime(n):\n    if n == 2:\n        return True\n    for i in range(2, int(math.ceil(math.sqrt(n))) + 1):\n        if n % i == 0:\n            return False\n    return True\n  Changelog New in version 0.10.   Parameters \nname (Optional[str]) \u2013 the optional name of the test, otherwise the function name will be used.  Return type \nCallable   \n"}, {"name": "Flask.testing", "path": "api/index#flask.Flask.testing", "type": "flask", "text": " \ntesting  \nThe testing flag. Set this to True to enable the test mode of Flask extensions (and in the future probably also Flask itself). For example this might activate test helpers that have an additional runtime cost which should not be enabled by default. If this is enabled and PROPAGATE_EXCEPTIONS is not changed from the default it\u2019s implicitly enabled. This attribute can also be configured from the config with the TESTING configuration key. Defaults to False. \n"}, {"name": "Flask.test_client()", "path": "api/index#flask.Flask.test_client", "type": "flask", "text": " \ntest_client(use_cookies=True, **kwargs)  \nCreates a test client for this application. For information about unit testing head over to Testing Flask Applications. Note that if you are testing for assertions or exceptions in your application code, you must set app.testing = True in order for the exceptions to propagate to the test client. Otherwise, the exception will be handled by the application (not visible to the test client) and the only indication of an AssertionError or other exception will be a 500 status code response to the test client. See the testing attribute. For example: app.testing = True\nclient = app.test_client()\n The test client can be used in a with block to defer the closing down of the context until the end of the with block. This is useful if you want to access the context locals for testing: with app.test_client() as c:\n    rv = c.get('/?vodka=42')\n    assert request.args['vodka'] == '42'\n Additionally, you may pass optional keyword arguments that will then be passed to the application\u2019s test_client_class constructor. For example: from flask.testing import FlaskClient\n\nclass CustomClient(FlaskClient):\n    def __init__(self, *args, **kwargs):\n        self._authentication = kwargs.pop(\"authentication\")\n        super(CustomClient,self).__init__( *args, **kwargs)\n\napp.test_client_class = CustomClient\nclient = app.test_client(authentication='Basic ....')\n See FlaskClient for more information.  Changelog Changed in version 0.11: Added **kwargs to support passing additional keyword arguments to the constructor of test_client_class.   New in version 0.7: The use_cookies parameter was added as well as the ability to override the client to be used by setting the test_client_class attribute.   Changed in version 0.4: added support for with block usage for the client.   Parameters \n \nuse_cookies (bool) \u2013  \nkwargs (Any) \u2013    Return type \nFlaskClient   \n"}, {"name": "Flask.test_client_class", "path": "api/index#flask.Flask.test_client_class", "type": "flask", "text": " \ntest_client_class: Optional[Type[FlaskClient]] = None  \nthe test client that is used with when test_client is used.  Changelog New in version 0.7.  \n\n"}, {"name": "Flask.test_cli_runner()", "path": "api/index#flask.Flask.test_cli_runner", "type": "flask", "text": " \ntest_cli_runner(**kwargs)  \nCreate a CLI runner for testing CLI commands. See Testing CLI Commands. Returns an instance of test_cli_runner_class, by default FlaskCliRunner. The Flask app object is passed as the first argument.  Changelog New in version 1.0.   Parameters \nkwargs (Any) \u2013   Return type \nFlaskCliRunner   \n"}, {"name": "Flask.test_cli_runner_class", "path": "api/index#flask.Flask.test_cli_runner_class", "type": "flask", "text": " \ntest_cli_runner_class: Optional[Type[FlaskCliRunner]] = None  \nThe CliRunner subclass, by default FlaskCliRunner that is used by test_cli_runner(). Its __init__ method should take a Flask app object as the first argument.  Changelog New in version 1.0.  \n\n"}, {"name": "Flask.test_request_context()", "path": "api/index#flask.Flask.test_request_context", "type": "flask", "text": " \ntest_request_context(*args, **kwargs)  \nCreate a RequestContext for a WSGI environment created from the given values. This is mostly useful during testing, where you may want to run a function that uses request data without dispatching a full request. See The Request Context. Use a with block to push the context, which will make request point at the request for the created environment. with test_request_context(...):\n    generate_report()\n When using the shell, it may be easier to push and pop the context manually to avoid indentation. ctx = app.test_request_context(...)\nctx.push()\n...\nctx.pop()\n Takes the same arguments as Werkzeug\u2019s EnvironBuilder, with some defaults from the application. See the linked Werkzeug docs for most of the available arguments. Flask-specific behavior is listed here.  Parameters \n \npath \u2013 URL path being requested. \nbase_url \u2013 Base URL where the app is being served, which path is relative to. If not given, built from PREFERRED_URL_SCHEME, subdomain, SERVER_NAME, and APPLICATION_ROOT. \nsubdomain \u2013 Subdomain name to append to SERVER_NAME. \nurl_scheme \u2013 Scheme to use instead of PREFERRED_URL_SCHEME. \ndata \u2013 The request body, either as a string or a dict of form keys and values. \njson \u2013 If given, this is serialized as JSON and passed as data. Also defaults content_type to application/json. \nargs (Any) \u2013 other positional arguments passed to EnvironBuilder. \nkwargs (Any) \u2013 other keyword arguments passed to EnvironBuilder.   Return type \nflask.ctx.RequestContext   \n"}, {"name": "Flask.trap_http_exception()", "path": "api/index#flask.Flask.trap_http_exception", "type": "flask", "text": " \ntrap_http_exception(e)  \nChecks if an HTTP exception should be trapped or not. By default this will return False for all exceptions except for a bad request key error if TRAP_BAD_REQUEST_ERRORS is set to True. It also returns True if TRAP_HTTP_EXCEPTIONS is set to True. This is called for all HTTP exceptions raised by a view function. If it returns True for any exception the error handler for this exception is not called and it shows up as regular exception in the traceback. This is helpful for debugging implicitly raised HTTP exceptions.  Changelog Changed in version 1.0: Bad request errors are not trapped by default in debug mode.   New in version 0.8.   Parameters \ne (Exception) \u2013   Return type \nbool   \n"}, {"name": "Flask.update_template_context()", "path": "api/index#flask.Flask.update_template_context", "type": "flask", "text": " \nupdate_template_context(context)  \nUpdate the template context with some commonly used variables. This injects request, session, config and g into the template context as well as everything template context processors want to inject. Note that the as of Flask 0.6, the original values in the context will not be overridden if a context processor decides to return a value with the same key.  Parameters \ncontext (dict) \u2013 the context as a dictionary that is updated in place to add extra variables.  Return type \nNone   \n"}, {"name": "Flask.url_build_error_handlers", "path": "api/index#flask.Flask.url_build_error_handlers", "type": "flask", "text": " \nurl_build_error_handlers: t.List[t.Callable[[Exception, str, dict], str]]  \nA list of functions that are called when url_for() raises a BuildError. Each function registered here is called with error, endpoint and values. If a function returns None or raises a BuildError the next function is tried.  Changelog New in version 0.9.  \n\n"}, {"name": "Flask.url_defaults()", "path": "api/index#flask.Flask.url_defaults", "type": "flask", "text": " \nurl_defaults(f)  \nCallback function for URL defaults for all view functions of the application. It\u2019s called with the endpoint and values and should update the values passed in place.  Parameters \nf (Callable[[str, dict], None]) \u2013   Return type \nCallable[[str, dict], None]   \n"}, {"name": "Flask.url_default_functions", "path": "api/index#flask.Flask.url_default_functions", "type": "flask", "text": " \nurl_default_functions: t.Dict[AppOrBlueprintKey, t.List[URLDefaultCallable]]  \nA data structure of functions to call to modify the keyword arguments when generating URLs, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests. To register a function, use the url_defaults() decorator. This data structure is internal. It should not be modified directly and its format may change at any time. \n"}, {"name": "Flask.url_map", "path": "api/index#flask.Flask.url_map", "type": "flask", "text": " \nurl_map  \nThe Map for this instance. You can use this to change the routing converters after the class was created but before any routes are connected. Example: from werkzeug.routing import BaseConverter\n\nclass ListConverter(BaseConverter):\n    def to_python(self, value):\n        return value.split(',')\n    def to_url(self, values):\n        return ','.join(super(ListConverter, self).to_url(value)\n                        for value in values)\n\napp = Flask(__name__)\napp.url_map.converters['list'] = ListConverter\n \n"}, {"name": "Flask.url_map_class", "path": "api/index#flask.Flask.url_map_class", "type": "flask", "text": " \nurl_map_class  \nalias of werkzeug.routing.Map \n"}, {"name": "Flask.url_rule_class", "path": "api/index#flask.Flask.url_rule_class", "type": "flask", "text": " \nurl_rule_class  \nalias of werkzeug.routing.Rule \n"}, {"name": "Flask.url_value_preprocessor()", "path": "api/index#flask.Flask.url_value_preprocessor", "type": "flask", "text": " \nurl_value_preprocessor(f)  \nRegister a URL value preprocessor function for all view functions in the application. These functions will be called before the before_request() functions. The function can modify the values captured from the matched url before they are passed to the view. For example, this can be used to pop a common language code value and place it in g rather than pass it to every view. The function is passed the endpoint name and values dict. The return value is ignored.  Parameters \nf (Callable[[Optional[str], Optional[dict]], None]) \u2013   Return type \nCallable[[Optional[str], Optional[dict]], None]   \n"}, {"name": "Flask.url_value_preprocessors", "path": "api/index#flask.Flask.url_value_preprocessors", "type": "flask", "text": " \nurl_value_preprocessors: t.Dict[AppOrBlueprintKey, t.List[URLValuePreprocessorCallable]]  \nA data structure of functions to call to modify the keyword arguments passed to the view function, in the format {scope: [functions]}. The scope key is the name of a blueprint the functions are active for, or None for all requests. To register a function, use the url_value_preprocessor() decorator. This data structure is internal. It should not be modified directly and its format may change at any time. \n"}, {"name": "Flask.use_x_sendfile", "path": "api/index#flask.Flask.use_x_sendfile", "type": "flask", "text": " \nuse_x_sendfile  \nEnable this if you want to use the X-Sendfile feature. Keep in mind that the server has to support this. This only affects files sent with the send_file() method.  Changelog New in version 0.2.  This attribute can also be configured from the config with the USE_X_SENDFILE configuration key. Defaults to False. \n"}, {"name": "Flask.view_functions", "path": "api/index#flask.Flask.view_functions", "type": "flask", "text": " \nview_functions: t.Dict[str, t.Callable]  \nA dictionary mapping endpoint names to view functions. To register a view function, use the route() decorator. This data structure is internal. It should not be modified directly and its format may change at any time. \n"}, {"name": "Flask.wsgi_app()", "path": "api/index#flask.Flask.wsgi_app", "type": "flask", "text": " \nwsgi_app(environ, start_response)  \nThe actual WSGI application. This is not implemented in __call__() so that middlewares can be applied without losing a reference to the app object. Instead of doing this: app = MyMiddleware(app)\n It\u2019s a better idea to do this instead: app.wsgi_app = MyMiddleware(app.wsgi_app)\n Then you still have the original application object around and can continue to call methods on it.  Changelog Changed in version 0.7: Teardown events for the request and app contexts are called even if an unhandled error occurs. Other events may not be called depending on when an error occurs during dispatch. See Callbacks and Errors.   Parameters \n \nenviron (dict) \u2013 A WSGI environment. \nstart_response (Callable) \u2013 A callable accepting a status code, a list of headers, and an optional exception context to start the response.   Return type \nAny   \n"}, {"name": "flask._app_ctx_stack", "path": "api/index#flask._app_ctx_stack", "type": "flask", "text": " \nflask._app_ctx_stack  \nThe internal LocalStack that holds AppContext instances. Typically, the current_app and g proxies should be accessed instead of the stack. Extensions can access the contexts on the stack as a namespace to store data.  Changelog New in version 0.9.  \n\n"}, {"name": "flask._request_ctx_stack", "path": "api/index#flask._request_ctx_stack", "type": "flask", "text": " \nflask._request_ctx_stack  \nThe internal LocalStack that holds RequestContext instances. Typically, the request and session proxies should be accessed instead of the stack. It may be useful to access the stack in extension code. The following attributes are always present on each layer of the stack:  \napp \n\nthe active Flask application.  \nurl_adapter \n\nthe URL adapter that was used to match the request.  \nrequest \n\nthe current request object.  \nsession \n\nthe active session object.  \ng \n\nan object with all the attributes of the flask.g object.  \nflashes \n\nan internal cache for the flashed messages.   Example usage: from flask import _request_ctx_stack\n\ndef get_session():\n    ctx = _request_ctx_stack.top\n    if ctx is not None:\n        return ctx.session\n \n"}, {"name": "FlaskClient", "path": "api/index#flask.testing.FlaskClient", "type": "flask.testing", "text": " \nclass flask.testing.FlaskClient(*args, **kwargs)  \nWorks like a regular Werkzeug test client but has some knowledge about how Flask works to defer the cleanup of the request context stack to the end of a with body when used in a with statement. For general information about how to use this class refer to werkzeug.test.Client.  Changelog Changed in version 0.12: app.test_client() includes preset default environment, which can be set after instantiation of the app.test_client() object in client.environ_base.  Basic usage is outlined in the Testing Flask Applications chapter.  Parameters \n \nargs (Any) \u2013  \nkwargs (Any) \u2013    Return type \nNone    \nopen(*args, as_tuple=False, buffered=False, follow_redirects=False, **kwargs)  \nGenerate an environ dict from the given arguments, make a request to the application using it, and return the response.  Parameters \n \nargs (Any) \u2013 Passed to EnvironBuilder to create the environ for the request. If a single arg is passed, it can be an existing EnvironBuilder or an environ dict. \nbuffered (bool) \u2013 Convert the iterator returned by the app into a list. If the iterator has a close() method, it is called automatically. \nfollow_redirects (bool) \u2013 Make additional requests to follow HTTP redirects until a non-redirect status is returned. TestResponse.history lists the intermediate responses. \nas_tuple (bool) \u2013  \nkwargs (Any) \u2013    Return type \nResponse    Changed in version 2.0: as_tuple is deprecated and will be removed in Werkzeug 2.1. Use TestResponse.request and request.environ instead.   Changed in version 2.0: The request input stream is closed when calling response.close(). Input streams for redirects are automatically closed.   Changelog Changed in version 0.5: If a dict is provided as file in the dict for the data parameter the content type has to be called content_type instead of mimetype. This change was made for consistency with werkzeug.FileWrapper.   Changed in version 0.5: Added the follow_redirects parameter.  \n\n  \nsession_transaction(*args, **kwargs)  \nWhen used in combination with a with statement this opens a session transaction. This can be used to modify the session that the test client uses. Once the with block is left the session is stored back. with client.session_transaction() as session:\n    session['value'] = 42\n Internally this is implemented by going through a temporary test request context and since session handling could depend on request variables this function accepts the same arguments as test_request_context() which are directly passed through.  Parameters \n \nargs (Any) \u2013  \nkwargs (Any) \u2013    Return type \nGenerator[flask.sessions.SessionMixin, None, None]   \n \n"}, {"name": "FlaskClient.open()", "path": "api/index#flask.testing.FlaskClient.open", "type": "flask.testing", "text": " \nopen(*args, as_tuple=False, buffered=False, follow_redirects=False, **kwargs)  \nGenerate an environ dict from the given arguments, make a request to the application using it, and return the response.  Parameters \n \nargs (Any) \u2013 Passed to EnvironBuilder to create the environ for the request. If a single arg is passed, it can be an existing EnvironBuilder or an environ dict. \nbuffered (bool) \u2013 Convert the iterator returned by the app into a list. If the iterator has a close() method, it is called automatically. \nfollow_redirects (bool) \u2013 Make additional requests to follow HTTP redirects until a non-redirect status is returned. TestResponse.history lists the intermediate responses. \nas_tuple (bool) \u2013  \nkwargs (Any) \u2013    Return type \nResponse    Changed in version 2.0: as_tuple is deprecated and will be removed in Werkzeug 2.1. Use TestResponse.request and request.environ instead.   Changed in version 2.0: The request input stream is closed when calling response.close(). Input streams for redirects are automatically closed.   Changelog Changed in version 0.5: If a dict is provided as file in the dict for the data parameter the content type has to be called content_type instead of mimetype. This change was made for consistency with werkzeug.FileWrapper.   Changed in version 0.5: Added the follow_redirects parameter.  \n\n"}, {"name": "FlaskClient.session_transaction()", "path": "api/index#flask.testing.FlaskClient.session_transaction", "type": "flask.testing", "text": " \nsession_transaction(*args, **kwargs)  \nWhen used in combination with a with statement this opens a session transaction. This can be used to modify the session that the test client uses. Once the with block is left the session is stored back. with client.session_transaction() as session:\n    session['value'] = 42\n Internally this is implemented by going through a temporary test request context and since session handling could depend on request variables this function accepts the same arguments as test_request_context() which are directly passed through.  Parameters \n \nargs (Any) \u2013  \nkwargs (Any) \u2013    Return type \nGenerator[flask.sessions.SessionMixin, None, None]   \n"}, {"name": "FlaskCliRunner", "path": "api/index#flask.testing.FlaskCliRunner", "type": "flask.testing", "text": " \nclass flask.testing.FlaskCliRunner(app, **kwargs)  \nA CliRunner for testing a Flask app\u2019s CLI commands. Typically created using test_cli_runner(). See Testing CLI Commands.  Parameters \n \napp (Flask) \u2013  \nkwargs (Any) \u2013    Return type \nNone    \ninvoke(cli=None, args=None, **kwargs)  \nInvokes a CLI command in an isolated environment. See CliRunner.invoke for full method documentation. See Testing CLI Commands for examples. If the obj argument is not given, passes an instance of ScriptInfo that knows how to load the Flask app being tested.  Parameters \n \ncli (Optional[Any]) \u2013 Command object to invoke. Default is the app\u2019s cli group. \nargs (Optional[Any]) \u2013 List of strings to invoke the command with. \nkwargs (Any) \u2013    Returns \na Result object.  Return type \nAny   \n \n"}, {"name": "FlaskCliRunner.invoke()", "path": "api/index#flask.testing.FlaskCliRunner.invoke", "type": "flask.testing", "text": " \ninvoke(cli=None, args=None, **kwargs)  \nInvokes a CLI command in an isolated environment. See CliRunner.invoke for full method documentation. See Testing CLI Commands for examples. If the obj argument is not given, passes an instance of ScriptInfo that knows how to load the Flask app being tested.  Parameters \n \ncli (Optional[Any]) \u2013 Command object to invoke. Default is the app\u2019s cli group. \nargs (Optional[Any]) \u2013 List of strings to invoke the command with. \nkwargs (Any) \u2013    Returns \na Result object.  Return type \nAny   \n"}, {"name": "FlaskGroup", "path": "api/index#flask.cli.FlaskGroup", "type": "flask.cli", "text": " \nclass flask.cli.FlaskGroup(add_default_commands=True, create_app=None, add_version_option=True, load_dotenv=True, set_debug_flag=True, **extra)  \nSpecial subclass of the AppGroup group that supports loading more commands from the configured Flask app. Normally a developer does not have to interface with this class but there are some very advanced use cases for which it makes sense to create an instance of this. see Custom Scripts.  Parameters \n \nadd_default_commands \u2013 if this is True then the default run and shell commands will be added. \nadd_version_option \u2013 adds the --version option. \ncreate_app \u2013 an optional callback that is passed the script info and returns the loaded app. \nload_dotenv \u2013 Load the nearest .env and .flaskenv files to set environment variables. Will also change the working directory to the directory containing the first file found. \nset_debug_flag \u2013 Set the app\u2019s debug flag based on the active environment     Changelog Changed in version 1.0: If installed, python-dotenv will be used to load environment variables from .env and .flaskenv files.   \nget_command(ctx, name)  \nGiven a context and a command name, this returns a Command object if it exists or returns None. \n  \nlist_commands(ctx)  \nReturns a list of subcommand names in the order they should appear. \n  \nmain(*args, **kwargs)  \nThis is the way to invoke a script with all the bells and whistles as a command line application. This will always terminate the application after a call. If this is not wanted, SystemExit needs to be caught. This method is also available by directly calling the instance of a Command.  Parameters \n \nargs \u2013 the arguments that should be used for parsing. If not provided, sys.argv[1:] is used. \nprog_name \u2013 the program name that should be used. By default the program name is constructed by taking the file name from sys.argv[0]. \ncomplete_var \u2013 the environment variable that controls the bash completion support. The default is \"_<prog_name>_COMPLETE\" with prog_name in uppercase. \nstandalone_mode \u2013 the default behavior is to invoke the script in standalone mode. Click will then handle exceptions and convert them into error messages and the function will never return but shut down the interpreter. If this is set to False they will be propagated to the caller and the return value of this function is the return value of invoke(). \nextra \u2013 extra keyword arguments are forwarded to the context constructor. See Context for more information.     Changed in version 8.0: When taking arguments from sys.argv on Windows, glob patterns, user dir, and env vars are expanded.   Changed in version 3.0: Added the standalone_mode parameter.  \n \n"}, {"name": "FlaskGroup.get_command()", "path": "api/index#flask.cli.FlaskGroup.get_command", "type": "flask.cli", "text": " \nget_command(ctx, name)  \nGiven a context and a command name, this returns a Command object if it exists or returns None. \n"}, {"name": "FlaskGroup.list_commands()", "path": "api/index#flask.cli.FlaskGroup.list_commands", "type": "flask.cli", "text": " \nlist_commands(ctx)  \nReturns a list of subcommand names in the order they should appear. \n"}, {"name": "FlaskGroup.main()", "path": "api/index#flask.cli.FlaskGroup.main", "type": "flask.cli", "text": " \nmain(*args, **kwargs)  \nThis is the way to invoke a script with all the bells and whistles as a command line application. This will always terminate the application after a call. If this is not wanted, SystemExit needs to be caught. This method is also available by directly calling the instance of a Command.  Parameters \n \nargs \u2013 the arguments that should be used for parsing. If not provided, sys.argv[1:] is used. \nprog_name \u2013 the program name that should be used. By default the program name is constructed by taking the file name from sys.argv[0]. \ncomplete_var \u2013 the environment variable that controls the bash completion support. The default is \"_<prog_name>_COMPLETE\" with prog_name in uppercase. \nstandalone_mode \u2013 the default behavior is to invoke the script in standalone mode. Click will then handle exceptions and convert them into error messages and the function will never return but shut down the interpreter. If this is set to False they will be propagated to the caller and the return value of this function is the return value of invoke(). \nextra \u2013 extra keyword arguments are forwarded to the context constructor. See Context for more information.     Changed in version 8.0: When taking arguments from sys.argv on Windows, glob patterns, user dir, and env vars are expanded.   Changed in version 3.0: Added the standalone_mode parameter.  \n"}, {"name": "Foreword", "path": "foreword/index", "type": "User\u2019s Guide", "text": "Foreword Read this before you get started with Flask. This hopefully answers some questions about the purpose and goals of the project, and when you should or should not be using it. What does \u201cmicro\u201d mean? \u201cMicro\u201d does not mean that your whole web application has to fit into a single Python file (although it certainly can), nor does it mean that Flask is lacking in functionality. The \u201cmicro\u201d in microframework means Flask aims to keep the core simple but extensible. Flask won\u2019t make many decisions for you, such as what database to use. Those decisions that it does make, such as what templating engine to use, are easy to change. Everything else is up to you, so that Flask can be everything you need and nothing you don\u2019t. By default, Flask does not include a database abstraction layer, form validation or anything else where different libraries already exist that can handle that. Instead, Flask supports extensions to add such functionality to your application as if it was implemented in Flask itself. Numerous extensions provide database integration, form validation, upload handling, various open authentication technologies, and more. Flask may be \u201cmicro\u201d, but it\u2019s ready for production use on a variety of needs. Configuration and Conventions Flask has many configuration values, with sensible defaults, and a few conventions when getting started. By convention, templates and static files are stored in subdirectories within the application\u2019s Python source tree, with the names templates and static respectively. While this can be changed, you usually don\u2019t have to, especially when getting started. Growing with Flask Once you have Flask up and running, you\u2019ll find a variety of extensions available in the community to integrate your project for production. As your codebase grows, you are free to make the design decisions appropriate for your project. Flask will continue to provide a very simple glue layer to the best that Python has to offer. You can implement advanced patterns in SQLAlchemy or another database tool, introduce non-relational data persistence as appropriate, and take advantage of framework-agnostic tools built for WSGI, the Python web interface. Flask includes many hooks to customize its behavior. Should you need more customization, the Flask class is built for subclassing. If you are interested in that, check out the Becoming Big chapter. If you are curious about the Flask design principles, head over to the section about Design Decisions in Flask.\n"}, {"name": "Foreword for Experienced Programmers", "path": "advanced_foreword/index", "type": "User\u2019s Guide", "text": "Foreword for Experienced Programmers Thread-Locals in Flask One of the design decisions in Flask was that simple tasks should be simple; they should not take a lot of code and yet they should not limit you. Because of that, Flask has a few design choices that some people might find surprising or unorthodox. For example, Flask uses thread-local objects internally so that you don\u2019t have to pass objects around from function to function within a request in order to stay threadsafe. This approach is convenient, but requires a valid request context for dependency injection or when attempting to reuse code which uses a value pegged to the request. The Flask project is honest about thread-locals, does not hide them, and calls out in the code and documentation where they are used. Develop for the Web with Caution Always keep security in mind when building web applications. If you write a web application, you are probably allowing users to register and leave their data on your server. The users are entrusting you with data. And even if you are the only user that might leave data in your application, you still want that data to be stored securely. Unfortunately, there are many ways the security of a web application can be compromised. Flask protects you against one of the most common security problems of modern web applications: cross-site scripting (XSS). Unless you deliberately mark insecure HTML as secure, Flask and the underlying Jinja2 template engine have you covered. But there are many more ways to cause security problems. The documentation will warn you about aspects of web development that require attention to security. Some of these security concerns are far more complex than one might think, and we all sometimes underestimate the likelihood that a vulnerability will be exploited - until a clever attacker figures out a way to exploit our applications. And don\u2019t think that your application is not important enough to attract an attacker. Depending on the kind of attack, chances are that automated bots are probing for ways to fill your database with spam, links to malicious software, and the like. Flask is no different from any other framework in that you the developer must build with caution, watching for exploits when building to your requirements.\n"}, {"name": "Form Validation with WTForms", "path": "patterns/wtforms/index", "type": "User's Guide: Design Patterns", "text": "Form Validation with WTForms When you have to work with form data submitted by a browser view, code quickly becomes very hard to read. There are libraries out there designed to make this process easier to manage. One of them is WTForms which we will handle here. If you find yourself in the situation of having many forms, you might want to give it a try. When you are working with WTForms you have to define your forms as classes first. I recommend breaking up the application into multiple modules (Large Applications as Packages) for that and adding a separate module for the forms.  Getting the most out of WTForms with an Extension The Flask-WTF extension expands on this pattern and adds a few little helpers that make working with forms and Flask more fun. You can get it from PyPI.  The Forms This is an example form for a typical registration page: from wtforms import Form, BooleanField, StringField, PasswordField, validators\n\nclass RegistrationForm(Form):\n    username = StringField('Username', [validators.Length(min=4, max=25)])\n    email = StringField('Email Address', [validators.Length(min=6, max=35)])\n    password = PasswordField('New Password', [\n        validators.DataRequired(),\n        validators.EqualTo('confirm', message='Passwords must match')\n    ])\n    confirm = PasswordField('Repeat Password')\n    accept_tos = BooleanField('I accept the TOS', [validators.DataRequired()])\n In the View In the view function, the usage of this form looks like this: @app.route('/register', methods=['GET', 'POST'])\ndef register():\n    form = RegistrationForm(request.form)\n    if request.method == 'POST' and form.validate():\n        user = User(form.username.data, form.email.data,\n                    form.password.data)\n        db_session.add(user)\n        flash('Thanks for registering')\n        return redirect(url_for('login'))\n    return render_template('register.html', form=form)\n Notice we\u2019re implying that the view is using SQLAlchemy here (SQLAlchemy in Flask), but that\u2019s not a requirement, of course. Adapt the code as necessary. Things to remember:  create the form from the request form value if the data is submitted via the HTTP POST method and args if the data is submitted as GET. to validate the data, call the validate() method, which will return True if the data validates, False otherwise. to access individual values from the form, access form.<NAME>.data.  Forms in Templates Now to the template side. When you pass the form to the templates, you can easily render them there. Look at the following example template to see how easy this is. WTForms does half the form generation for us already. To make it even nicer, we can write a macro that renders a field with label and a list of errors if there are any. Here\u2019s an example _formhelpers.html template with such a macro: {% macro render_field(field) %}\n  <dt>{{ field.label }}\n  <dd>{{ field(**kwargs)|safe }}\n  {% if field.errors %}\n    <ul class=errors>\n    {% for error in field.errors %}\n      <li>{{ error }}</li>\n    {% endfor %}\n    </ul>\n  {% endif %}\n  </dd>\n{% endmacro %}\n This macro accepts a couple of keyword arguments that are forwarded to WTForm\u2019s field function, which renders the field for us. The keyword arguments will be inserted as HTML attributes. So, for example, you can call render_field(form.username, class='username') to add a class to the input element. Note that WTForms returns standard Python strings, so we have to tell Jinja2 that this data is already HTML-escaped with the |safe filter. Here is the register.html template for the function we used above, which takes advantage of the _formhelpers.html template: {% from \"_formhelpers.html\" import render_field %}\n<form method=post>\n  <dl>\n    {{ render_field(form.username) }}\n    {{ render_field(form.email) }}\n    {{ render_field(form.password) }}\n    {{ render_field(form.confirm) }}\n    {{ render_field(form.accept_tos) }}\n  </dl>\n  <p><input type=submit value=Register>\n</form>\n For more information about WTForms, head over to the WTForms website.\n"}, {"name": "get_flashed_messages()", "path": "api/index#flask.get_flashed_messages", "type": "flask", "text": " \nflask.get_flashed_messages(with_categories=False, category_filter=())  \nPulls all flashed messages from the session and returns them. Further calls in the same request to the function will return the same messages. By default just the messages are returned, but when with_categories is set to True, the return value will be a list of tuples in the form (category, message) instead. Filter the flashed messages to one or more categories by providing those categories in category_filter. This allows rendering categories in separate html blocks. The with_categories and category_filter arguments are distinct:  \nwith_categories controls whether categories are returned with message text (True gives a tuple, where False gives just the message text). \ncategory_filter filters the messages down to only those matching the provided categories.  See Message Flashing for examples.  Changelog Changed in version 0.9: category_filter parameter added.   Changed in version 0.3: with_categories parameter added.   Parameters \n \nwith_categories (bool) \u2013 set to True to also receive categories. \ncategory_filter (Iterable[str]) \u2013 filter of categories to limit return values. Only categories in the list will be returned.   Return type \nUnion[List[str], List[Tuple[str, str]]]   \n"}, {"name": "get_template_attribute()", "path": "api/index#flask.get_template_attribute", "type": "flask", "text": " \nflask.get_template_attribute(template_name, attribute)  \nLoads a macro (or variable) a template exports. This can be used to invoke a macro from within Python code. If you for example have a template named _cider.html with the following contents: {% macro hello(name) %}Hello {{ name }}!{% endmacro %}\n You can access this from Python code like this: hello = get_template_attribute('_cider.html', 'hello')\nreturn hello('World')\n  Changelog New in version 0.2.   Parameters \n \ntemplate_name (str) \u2013 the name of the template \nattribute (str) \u2013 the name of the variable of macro to access   Return type \nAny   \n"}, {"name": "Handling Application Errors", "path": "errorhandling/index", "type": "User\u2019s Guide", "text": "Handling Application Errors Applications fail, servers fail. Sooner or later you will see an exception in production. Even if your code is 100% correct, you will still see exceptions from time to time. Why? Because everything else involved will fail. Here are some situations where perfectly fine code can lead to server errors:  the client terminated the request early and the application was still reading from the incoming data the database server was overloaded and could not handle the query a filesystem is full a harddrive crashed a backend server overloaded a programming error in a library you are using network connection of the server to another system failed  And that\u2019s just a small sample of issues you could be facing. So how do we deal with that sort of problem? By default if your application runs in production mode, and an exception is raised Flask will display a very simple page for you and log the exception to the logger. But there is more you can do, and we will cover some better setups to deal with errors including custom exceptions and 3rd party tools. Error Logging Tools Sending error mails, even if just for critical ones, can become overwhelming if enough users are hitting the error and log files are typically never looked at. This is why we recommend using Sentry for dealing with application errors. It\u2019s available as a source-available project on GitHub and is also available as a hosted version which you can try for free. Sentry aggregates duplicate errors, captures the full stack trace and local variables for debugging, and sends you mails based on new errors or frequency thresholds. To use Sentry you need to install the sentry-sdk client with extra flask dependencies. $ pip install sentry-sdk[flask]\n And then add this to your Flask app: import sentry_sdk\nfrom sentry_sdk.integrations.flask import FlaskIntegration\n\nsentry_sdk.init('YOUR_DSN_HERE', integrations=[FlaskIntegration()])\n The YOUR_DSN_HERE value needs to be replaced with the DSN value you get from your Sentry installation. After installation, failures leading to an Internal Server Error are automatically reported to Sentry and from there you can receive error notifications. See also:  Sentry also supports catching errors from a worker queue (RQ, Celery, etc.) in a similar fashion. See the Python SDK docs for more information. Getting started with Sentry Flask-specific documentation  Error Handlers When an error occurs in Flask, an appropriate HTTP status code will be returned. 400-499 indicate errors with the client\u2019s request data, or about the data requested. 500-599 indicate errors with the server or application itself. You might want to show custom error pages to the user when an error occurs. This can be done by registering error handlers. An error handler is a function that returns a response when a type of error is raised, similar to how a view is a function that returns a response when a request URL is matched. It is passed the instance of the error being handled, which is most likely a HTTPException. The status code of the response will not be set to the handler\u2019s code. Make sure to provide the appropriate HTTP status code when returning a response from a handler. Registering Register handlers by decorating a function with errorhandler(). Or use register_error_handler() to register the function later. Remember to set the error code when returning the response. @app.errorhandler(werkzeug.exceptions.BadRequest)\ndef handle_bad_request(e):\n    return 'bad request!', 400\n\n# or, without the decorator\napp.register_error_handler(400, handle_bad_request)\n werkzeug.exceptions.HTTPException subclasses like BadRequest and their HTTP codes are interchangeable when registering handlers. (BadRequest.code == 400) Non-standard HTTP codes cannot be registered by code because they are not known by Werkzeug. Instead, define a subclass of HTTPException with the appropriate code and register and raise that exception class. class InsufficientStorage(werkzeug.exceptions.HTTPException):\n    code = 507\n    description = 'Not enough storage space.'\n\napp.register_error_handler(InsufficientStorage, handle_507)\n\nraise InsufficientStorage()\n Handlers can be registered for any exception class, not just HTTPException subclasses or HTTP status codes. Handlers can be registered for a specific class, or for all subclasses of a parent class. Handling When building a Flask application you will run into exceptions. If some part of your code breaks while handling a request (and you have no error handlers registered), a \u201c500 Internal Server Error\u201d (InternalServerError) will be returned by default. Similarly, \u201c404 Not Found\u201d (NotFound) error will occur if a request is sent to an unregistered route. If a route receives an unallowed request method, a \u201c405 Method Not Allowed\u201d (MethodNotAllowed) will be raised. These are all subclasses of HTTPException and are provided by default in Flask. Flask gives you to the ability to raise any HTTP exception registered by Werkzeug. However, the default HTTP exceptions return simple exception pages. You might want to show custom error pages to the user when an error occurs. This can be done by registering error handlers. When Flask catches an exception while handling a request, it is first looked up by code. If no handler is registered for the code, Flask looks up the error by its class hierarchy; the most specific handler is chosen. If no handler is registered, HTTPException subclasses show a generic message about their code, while other exceptions are converted to a generic \u201c500 Internal Server Error\u201d. For example, if an instance of ConnectionRefusedError is raised, and a handler is registered for ConnectionError and ConnectionRefusedError, the more specific ConnectionRefusedError handler is called with the exception instance to generate the response. Handlers registered on the blueprint take precedence over those registered globally on the application, assuming a blueprint is handling the request that raises the exception. However, the blueprint cannot handle 404 routing errors because the 404 occurs at the routing level before the blueprint can be determined. Generic Exception Handlers It is possible to register error handlers for very generic base classes such as HTTPException or even Exception. However, be aware that these will catch more than you might expect. For example, an error handler for HTTPException might be useful for turning the default HTML errors pages into JSON. However, this handler will trigger for things you don\u2019t cause directly, such as 404 and 405 errors during routing. Be sure to craft your handler carefully so you don\u2019t lose information about the HTTP error. from flask import json\nfrom werkzeug.exceptions import HTTPException\n\n@app.errorhandler(HTTPException)\ndef handle_exception(e):\n    \"\"\"Return JSON instead of HTML for HTTP errors.\"\"\"\n    # start with the correct headers and status code from the error\n    response = e.get_response()\n    # replace the body with JSON\n    response.data = json.dumps({\n        \"code\": e.code,\n        \"name\": e.name,\n        \"description\": e.description,\n    })\n    response.content_type = \"application/json\"\n    return response\n An error handler for Exception might seem useful for changing how all errors, even unhandled ones, are presented to the user. However, this is similar to doing except Exception: in Python, it will capture all otherwise unhandled errors, including all HTTP status codes. In most cases it will be safer to register handlers for more specific exceptions. Since HTTPException instances are valid WSGI responses, you could also pass them through directly. from werkzeug.exceptions import HTTPException\n\n@app.errorhandler(Exception)\ndef handle_exception(e):\n    # pass through HTTP errors\n    if isinstance(e, HTTPException):\n        return e\n\n    # now you're handling non-HTTP exceptions only\n    return render_template(\"500_generic.html\", e=e), 500\n Error handlers still respect the exception class hierarchy. If you register handlers for both HTTPException and Exception, the Exception handler will not handle HTTPException subclasses because it the HTTPException handler is more specific. Unhandled Exceptions When there is no error handler registered for an exception, a 500 Internal Server Error will be returned instead. See flask.Flask.handle_exception() for information about this behavior. If there is an error handler registered for InternalServerError, this will be invoked. As of Flask 1.1.0, this error handler will always be passed an instance of InternalServerError, not the original unhandled error. The original error is available as e.original_exception. An error handler for \u201c500 Internal Server Error\u201d will be passed uncaught exceptions in addition to explicit 500 errors. In debug mode, a handler for \u201c500 Internal Server Error\u201d will not be used. Instead, the interactive debugger will be shown. Custom Error Pages Sometimes when building a Flask application, you might want to raise a HTTPException to signal to the user that something is wrong with the request. Fortunately, Flask comes with a handy abort() function that aborts a request with a HTTP error from werkzeug as desired. It will also provide a plain black and white error page for you with a basic description, but nothing fancy. Depending on the error code it is less or more likely for the user to actually see such an error. Consider the code below, we might have a user profile route, and if the user fails to pass a username we can raise a \u201c400 Bad Request\u201d. If the user passes a username and we can\u2019t find it, we raise a \u201c404 Not Found\u201d. from flask import abort, render_template, request\n\n# a username needs to be supplied in the query args\n# a successful request would be like /profile?username=jack\n@app.route(\"/profile\")\ndef user_profile():\n    username = request.arg.get(\"username\")\n    # if a username isn't supplied in the request, return a 400 bad request\n    if username is None:\n        abort(400)\n\n    user = get_user(username=username)\n    # if a user can't be found by their username, return 404 not found\n    if user is None:\n        abort(404)\n\n    return render_template(\"profile.html\", user=user)\n Here is another example implementation for a \u201c404 Page Not Found\u201d exception: from flask import render_template\n\n@app.errorhandler(404)\ndef page_not_found(e):\n    # note that we set the 404 status explicitly\n    return render_template('404.html'), 404\n When using Application Factories: from flask import Flask, render_template\n\ndef page_not_found(e):\n  return render_template('404.html'), 404\n\ndef create_app(config_filename):\n    app = Flask(__name__)\n    app.register_error_handler(404, page_not_found)\n    return app\n An example template might be this: {% extends \"layout.html\" %}\n{% block title %}Page Not Found{% endblock %}\n{% block body %}\n  <h1>Page Not Found</h1>\n  <p>What you were looking for is just not there.\n  <p><a href=\"{{ url_for('index') }}\">go somewhere nice</a>\n{% endblock %}\n Further Examples The above examples wouldn\u2019t actually be an improvement on the default exception pages. We can create a custom 500.html template like this: {% extends \"layout.html\" %}\n{% block title %}Internal Server Error{% endblock %}\n{% block body %}\n  <h1>Internal Server Error</h1>\n  <p>Oops... we seem to have made a mistake, sorry!</p>\n  <p><a href=\"{{ url_for('index') }}\">Go somewhere nice instead</a>\n{% endblock %}\n It can be implemented by rendering the template on \u201c500 Internal Server Error\u201d: from flask import render_template\n\n@app.errorhandler(500)\ndef internal_server_error(e):\n    # note that we set the 500 status explicitly\n    return render_template('500.html'), 500\n When using Application Factories: from flask import Flask, render_template\n\ndef internal_server_error(e):\n  return render_template('500.html'), 500\n\ndef create_app():\n    app = Flask(__name__)\n    app.register_error_handler(500, internal_server_error)\n    return app\n When using Modular Applications with Blueprints: from flask import Blueprint\n\nblog = Blueprint('blog', __name__)\n\n# as a decorator\n@blog.errorhandler(500)\ndef internal_server_error(e):\n    return render_template('500.html'), 500\n\n# or with register_error_handler\nblog.register_error_handler(500, internal_server_error)\n Blueprint Error Handlers In Modular Applications with Blueprints, most error handlers will work as expected. However, there is a caveat concerning handlers for 404 and 405 exceptions. These error handlers are only invoked from an appropriate raise statement or a call to abort in another of the blueprint\u2019s view functions; they are not invoked by, e.g., an invalid URL access. This is because the blueprint does not \u201cown\u201d a certain URL space, so the application instance has no way of knowing which blueprint error handler it should run if given an invalid URL. If you would like to execute different handling strategies for these errors based on URL prefixes, they may be defined at the application level using the request proxy object. from flask import jsonify, render_template\n\n# at the application level\n# not the blueprint level\n@app.errorhandler(404)\ndef page_not_found(e):\n    # if a request is in our blog URL space\n    if request.path.startswith('/blog/'):\n        # we return a custom blog 404 page\n        return render_template(\"blog/404.html\"), 404\n    else:\n        # otherwise we return our generic site-wide 404 page\n        return render_template(\"404.html\"), 404\n\n@app.errorhandler(405)\ndef method_not_allowed(e):\n    # if a request has the wrong method to our API\n    if request.path.startswith('/api/'):\n        # we return a json saying so\n        return jsonify(message=\"Method Not Allowed\"), 405\n    else:\n        # otherwise we return a generic site-wide 405 page\n        return render_template(\"405.html\"), 405\n Returning API Errors as JSON When building APIs in Flask, some developers realise that the built-in exceptions are not expressive enough for APIs and that the content type of text/html they are emitting is not very useful for API consumers. Using the same techniques as above and jsonify() we can return JSON responses to API errors. abort() is called with a description parameter. The error handler will use that as the JSON error message, and set the status code to 404. from flask import abort, jsonify\n\n@app.errorhandler(404)\ndef resource_not_found(e):\n    return jsonify(error=str(e)), 404\n\n@app.route(\"/cheese\")\ndef get_one_cheese():\n    resource = get_resource()\n\n    if resource is None:\n        abort(404, description=\"Resource not found\")\n\n    return jsonify(resource)\n We can also create custom exception classes. For instance, we can introduce a new custom exception for an API that can take a proper human readable message, a status code for the error and some optional payload to give more context for the error. This is a simple example: from flask import jsonify, request\n\nclass InvalidAPIUsage(Exception):\n    status_code = 400\n\n    def __init__(self, message, status_code=None, payload=None):\n        super().__init__()\n        self.message = message\n        if status_code is not None:\n            self.status_code = status_code\n        self.payload = payload\n\n    def to_dict(self):\n        rv = dict(self.payload or ())\n        rv['message'] = self.message\n        return rv\n\n@app.errorhandler(InvalidAPIUsage)\ndef invalid_api_usage(e):\n    return jsonify(e.to_dict())\n\n# an API app route for getting user information\n# a correct request might be /api/user?user_id=420\n@app.route(\"/api/user\")\ndef user_api(user_id):\n    user_id = request.arg.get(\"user_id\")\n    if not user_id:\n        raise InvalidAPIUsage(\"No user id provided!\")\n\n    user = get_user(user_id=user_id)\n    if not user:\n        raise InvalidAPIUsage(\"No such user!\", status_code=404)\n\n    return jsonify(user.to_dict())\n A view can now raise that exception with an error message. Additionally some extra payload can be provided as a dictionary through the payload parameter. Logging See Logging for information about how to log exceptions, such as by emailing them to admins. Debugging See Debugging Application Errors for information about how to debug errors in development and production.\n"}, {"name": "has_app_context()", "path": "api/index#flask.has_app_context", "type": "flask", "text": " \nflask.has_app_context()  \nWorks like has_request_context() but for the application context. You can also just do a boolean check on the current_app object instead.  Changelog New in version 0.9.   Return type \nbool   \n"}, {"name": "has_request_context()", "path": "api/index#flask.has_request_context", "type": "flask", "text": " \nflask.has_request_context()  \nIf you have code that wants to test if a request context is there or not this function can be used. For instance, you may want to take advantage of request information if the request object is available, but fail silently if it is unavailable. class User(db.Model):\n\n    def __init__(self, username, remote_addr=None):\n        self.username = username\n        if remote_addr is None and has_request_context():\n            remote_addr = request.remote_addr\n        self.remote_addr = remote_addr\n Alternatively you can also just test any of the context bound objects (such as request or g) for truthness: class User(db.Model):\n\n    def __init__(self, username, remote_addr=None):\n        self.username = username\n        if remote_addr is None and request:\n            remote_addr = request.remote_addr\n        self.remote_addr = remote_addr\n  Changelog New in version 0.7.   Return type \nbool   \n"}, {"name": "HTML/XHTML FAQ", "path": "htmlfaq/index", "type": "Additional Notes", "text": "HTML/XHTML FAQ The Flask documentation and example applications are using HTML5. You may notice that in many situations, when end tags are optional they are not used, so that the HTML is cleaner and faster to load. Because there is much confusion about HTML and XHTML among developers, this document tries to answer some of the major questions. History of XHTML For a while, it appeared that HTML was about to be replaced by XHTML. However, barely any websites on the Internet are actual XHTML (which is HTML processed using XML rules). There are a couple of major reasons why this is the case. One of them is Internet Explorer\u2019s lack of proper XHTML support. The XHTML spec states that XHTML must be served with the MIME type application/xhtml+xml, but Internet Explorer refuses to read files with that MIME type. While it is relatively easy to configure Web servers to serve XHTML properly, few people do. This is likely because properly using XHTML can be quite painful. One of the most important causes of pain is XML\u2019s draconian (strict and ruthless) error handling. When an XML parsing error is encountered, the browser is supposed to show the user an ugly error message, instead of attempting to recover from the error and display what it can. Most of the (X)HTML generation on the web is based on non-XML template engines (such as Jinja, the one used in Flask) which do not protect you from accidentally creating invalid XHTML. There are XML based template engines, such as Kid and the popular Genshi, but they often come with a larger runtime overhead and are not as straightforward to use because they have to obey XML rules. The majority of users, however, assumed they were properly using XHTML. They wrote an XHTML doctype at the top of the document and self-closed all the necessary tags (<br> becomes <br/> or <br></br> in XHTML). However, even if the document properly validates as XHTML, what really determines XHTML/HTML processing in browsers is the MIME type, which as said before is often not set properly. So the valid XHTML was being treated as invalid HTML. XHTML also changed the way JavaScript is used. To properly work with XHTML, programmers have to use the namespaced DOM interface with the XHTML namespace to query for HTML elements. History of HTML5 Development of the HTML5 specification was started in 2004 under the name \u201cWeb Applications 1.0\u201d by the Web Hypertext Application Technology Working Group, or WHATWG (which was formed by the major browser vendors Apple, Mozilla, and Opera) with the goal of writing a new and improved HTML specification, based on existing browser behavior instead of unrealistic and backwards-incompatible specifications. For example, in HTML4 <title/Hello/ theoretically parses exactly the same as <title>Hello</title>. However, since people were using XHTML-like tags along the lines of <link />, browser vendors implemented the XHTML syntax over the syntax defined by the specification. In 2007, the specification was adopted as the basis of a new HTML specification under the umbrella of the W3C, known as HTML5. Currently, it appears that XHTML is losing traction, as the XHTML 2 working group has been disbanded and HTML5 is being implemented by all major browser vendors. HTML versus XHTML The following table gives you a quick overview of features available in HTML 4.01, XHTML 1.1 and HTML5. (XHTML 1.0 is not included, as it was superseded by XHTML 1.1 and the barely-used XHTML5.)   \n HTML4.01 XHTML1.1 HTML5   \n<tag/value/ == <tag>value</tag>  1    \n<br/> supported    2  \n<script/> supported     \nshould be served as text/html   3   \nshould be served as application/xhtml+xml     \nstrict error handling     \ninline SVG     \ninline MathML     \n<video> tag     \n<audio> tag     \nNew semantic tags like <article>       \n1  \nThis is an obscure feature inherited from SGML. It is usually not supported by browsers, for reasons detailed above.  \n2  \nThis is for compatibility with server code that generates XHTML for tags such as <br>. It should not be used in new code.  \n3  \nXHTML 1.0 is the last XHTML standard that allows to be served as text/html for backwards compatibility reasons.   What does \u201cstrict\u201d mean? HTML5 has strictly defined parsing rules, but it also specifies exactly how a browser should react to parsing errors - unlike XHTML, which simply states parsing should abort. Some people are confused by apparently invalid syntax that still generates the expected results (for example, missing end tags or unquoted attribute values). Some of these work because of the lenient error handling most browsers use when they encounter a markup error, others are actually specified. The following constructs are optional in HTML5 by standard, but have to be supported by browsers:  Wrapping the document in an <html> tag Wrapping header elements in <head> or the body elements in <body>\n Closing the <p>, <li>, <dt>, <dd>, <tr>, <td>, <th>, <tbody>, <thead>, or <tfoot> tags. Quoting attributes, so long as they contain no whitespace or special characters (like <, >, ', or \"). Requiring boolean attributes to have a value.  This means the following page in HTML5 is perfectly valid: <!doctype html>\n<title>Hello HTML5</title>\n<div class=header>\n  <h1>Hello HTML5</h1>\n  <p class=tagline>HTML5 is awesome\n</div>\n<ul class=nav>\n  <li><a href=/index>Index</a>\n  <li><a href=/downloads>Downloads</a>\n  <li><a href=/about>About</a>\n</ul>\n<div class=body>\n  <h2>HTML5 is probably the future</h2>\n  <p>\n    There might be some other things around but in terms of\n    browser vendor support, HTML5 is hard to beat.\n  <dl>\n    <dt>Key 1\n    <dd>Value 1\n    <dt>Key 2\n    <dd>Value 2\n  </dl>\n</div>\n New technologies in HTML5 HTML5 adds many new features that make Web applications easier to write and to use.  The <audio> and <video> tags provide a way to embed audio and video without complicated add-ons like QuickTime or Flash. Semantic elements like <article>, <header>, <nav>, and <time> that make content easier to understand. The <canvas> tag, which supports a powerful drawing API, reducing the need for server-generated images to present data graphically. New form control types like <input type=\"date\"> that allow user agents to make entering and validating values easier. Advanced JavaScript APIs like Web Storage, Web Workers, Web Sockets, geolocation, and offline applications.  Many other features have been added, as well. A good guide to new features in HTML5 is Mark Pilgrim\u2019s book, Dive Into HTML5. Not all of them are supported in browsers yet, however, so use caution. What should be used? Currently, the answer is HTML5. There are very few reasons to use XHTML considering the latest developments in Web browsers. To summarize the reasons given above:  Internet Explorer has poor support for XHTML. Many JavaScript libraries also do not support XHTML, due to the more complicated namespacing API it requires. HTML5 adds several new features, including semantic tags and the long-awaited <audio> and <video> tags. It has the support of most browser vendors behind it. It is much easier to write, and more compact.  For most applications, it is undoubtedly better to use HTML5 than XHTML.\n"}, {"name": "Installation", "path": "installation/index", "type": "User\u2019s Guide", "text": "Installation Python Version We recommend using the latest version of Python. Flask supports Python 3.6 and newer. Dependencies These distributions will be installed automatically when installing Flask.  \nWerkzeug implements WSGI, the standard Python interface between applications and servers. \nJinja is a template language that renders the pages your application serves. \nMarkupSafe comes with Jinja. It escapes untrusted input when rendering templates to avoid injection attacks. \nItsDangerous securely signs data to ensure its integrity. This is used to protect Flask\u2019s session cookie. \nClick is a framework for writing command line applications. It provides the flask command and allows adding custom management commands.  Optional dependencies These distributions will not be installed automatically. Flask will detect and use them if you install them.  \nBlinker provides support for Signals. \npython-dotenv enables support for Environment Variables From dotenv when running flask commands. \nWatchdog provides a faster, more efficient reloader for the development server.  Virtual environments Use a virtual environment to manage the dependencies for your project, both in development and in production. What problem does a virtual environment solve? The more Python projects you have, the more likely it is that you need to work with different versions of Python libraries, or even Python itself. Newer versions of libraries for one project can break compatibility in another project. Virtual environments are independent groups of Python libraries, one for each project. Packages installed for one project will not affect other projects or the operating system\u2019s packages. Python comes bundled with the venv module to create virtual environments. Create an environment Create a project folder and a venv folder within:  \nmacOS/LinuxWindows\n\n\n$ mkdir myproject\n$ cd myproject\n$ python3 -m venv venv\n \n\n> mkdir myproject\n> cd myproject\n> py -3 -m venv venv\n \n Activate the environment Before you work on your project, activate the corresponding environment:  \nmacOS/LinuxWindows\n\n\n$ . venv/bin/activate\n \n\n> venv\\Scripts\\activate\n \n Your shell prompt will change to show the name of the activated environment. Install Flask Within the activated environment, use the following command to install Flask: $ pip install Flask\n Flask is now installed. Check out the Quickstart or go to the Documentation Overview.\n"}, {"name": "JSONDecoder", "path": "api/index#flask.json.JSONDecoder", "type": "flask.json", "text": " \nclass flask.json.JSONDecoder(*, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, strict=True, object_pairs_hook=None)  \nThe default JSON decoder. This does not change any behavior from the built-in json.JSONDecoder. Assign a subclass of this to flask.Flask.json_decoder or flask.Blueprint.json_decoder to override the default. \n"}, {"name": "JSONEncoder", "path": "api/index#flask.json.JSONEncoder", "type": "flask.json", "text": " \nclass flask.json.JSONEncoder(*, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, sort_keys=False, indent=None, separators=None, default=None)  \nThe default JSON encoder. Handles extra types compared to the built-in json.JSONEncoder.  \ndatetime.datetime and datetime.date are serialized to RFC 822 strings. This is the same as the HTTP date format. \nuuid.UUID is serialized to a string. \ndataclasses.dataclass is passed to dataclasses.asdict(). \nMarkup (or any object with a __html__ method) will call the __html__ method to get a string.  Assign a subclass of this to flask.Flask.json_encoder or flask.Blueprint.json_encoder to override the default.  \ndefault(o)  \nConvert o to a JSON serializable type. See json.JSONEncoder.default(). Python does not support overriding how basic types like str or list are serialized, they are handled before this method.  Parameters \no (Any) \u2013   Return type \nAny   \n \n"}, {"name": "JSONEncoder.default()", "path": "api/index#flask.json.JSONEncoder.default", "type": "flask.json", "text": " \ndefault(o)  \nConvert o to a JSON serializable type. See json.JSONEncoder.default(). Python does not support overriding how basic types like str or list are serialized, they are handled before this method.  Parameters \no (Any) \u2013   Return type \nAny   \n"}, {"name": "jsonify()", "path": "api/index#flask.json.jsonify", "type": "flask.json", "text": " \nflask.json.jsonify(*args, **kwargs)  \nSerialize data to JSON and wrap it in a Response with the application/json mimetype. Uses dumps() to serialize the data, but args and kwargs are treated as data rather than arguments to json.dumps().  Single argument: Treated as a single value. Multiple arguments: Treated as a list of values. jsonify(1, 2, 3) is the same as jsonify([1, 2, 3]). Keyword arguments: Treated as a dict of values. jsonify(data=data, errors=errors) is the same as jsonify({\"data\": data, \"errors\": errors}). Passing both arguments and keyword arguments is not allowed as it\u2019s not clear what should happen.  from flask import jsonify\n\n@app.route(\"/users/me\")\ndef get_current_user():\n    return jsonify(\n        username=g.user.username,\n        email=g.user.email,\n        id=g.user.id,\n    )\n Will return a JSON response like this: {\n  \"username\": \"admin\",\n  \"email\": \"admin@localhost\",\n  \"id\": 42\n}\n The default output omits indents and spaces after separators. In debug mode or if JSONIFY_PRETTYPRINT_REGULAR is True, the output will be formatted to be easier to read.  Changelog Changed in version 0.11: Added support for serializing top-level arrays. This introduces a security risk in ancient browsers. See JSON Security.   New in version 0.2.   Parameters \n \nargs (Any) \u2013  \nkwargs (Any) \u2013    Return type \nResponse   \n"}, {"name": "JSONIFY_MIMETYPE", "path": "config/index#JSONIFY_MIMETYPE", "type": "Configuration", "text": " \nJSONIFY_MIMETYPE  \nThe mimetype of jsonify responses. Default: 'application/json' \n"}, {"name": "JSONIFY_PRETTYPRINT_REGULAR", "path": "config/index#JSONIFY_PRETTYPRINT_REGULAR", "type": "Configuration", "text": " \nJSONIFY_PRETTYPRINT_REGULAR  \njsonify responses will be output with newlines, spaces, and indentation for easier reading by humans. Always enabled in debug mode. Default: False \n"}, {"name": "JSONTag", "path": "api/index#flask.json.tag.JSONTag", "type": "flask.json.tag", "text": " \nclass flask.json.tag.JSONTag(serializer)  \nBase class for defining type tags for TaggedJSONSerializer.  Parameters \nserializer (TaggedJSONSerializer) \u2013   Return type \nNone    \ncheck(value)  \nCheck if the given value should be tagged by this tag.  Parameters \nvalue (Any) \u2013   Return type \nbool   \n  \nkey: Optional[str] = None  \nThe tag to mark the serialized object with. If None, this tag is only used as an intermediate step during tagging. \n  \ntag(value)  \nConvert the value to a valid JSON type and add the tag structure around it.  Parameters \nvalue (Any) \u2013   Return type \nAny   \n  \nto_json(value)  \nConvert the Python object to an object that is a valid JSON type. The tag will be added later.  Parameters \nvalue (Any) \u2013   Return type \nAny   \n  \nto_python(value)  \nConvert the JSON representation back to the correct type. The tag will already be removed.  Parameters \nvalue (Any) \u2013   Return type \nAny   \n \n"}, {"name": "JSONTag.check()", "path": "api/index#flask.json.tag.JSONTag.check", "type": "flask.json.tag", "text": " \ncheck(value)  \nCheck if the given value should be tagged by this tag.  Parameters \nvalue (Any) \u2013   Return type \nbool   \n"}, {"name": "JSONTag.key", "path": "api/index#flask.json.tag.JSONTag.key", "type": "flask.json.tag", "text": " \nkey: Optional[str] = None  \nThe tag to mark the serialized object with. If None, this tag is only used as an intermediate step during tagging. \n"}, {"name": "JSONTag.tag()", "path": "api/index#flask.json.tag.JSONTag.tag", "type": "flask.json.tag", "text": " \ntag(value)  \nConvert the value to a valid JSON type and add the tag structure around it.  Parameters \nvalue (Any) \u2013   Return type \nAny   \n"}, {"name": "JSONTag.to_json()", "path": "api/index#flask.json.tag.JSONTag.to_json", "type": "flask.json.tag", "text": " \nto_json(value)  \nConvert the Python object to an object that is a valid JSON type. The tag will be added later.  Parameters \nvalue (Any) \u2013   Return type \nAny   \n"}, {"name": "JSONTag.to_python()", "path": "api/index#flask.json.tag.JSONTag.to_python", "type": "flask.json.tag", "text": " \nto_python(value)  \nConvert the JSON representation back to the correct type. The tag will already be removed.  Parameters \nvalue (Any) \u2013   Return type \nAny   \n"}, {"name": "JSON_AS_ASCII", "path": "config/index#JSON_AS_ASCII", "type": "Configuration", "text": " \nJSON_AS_ASCII  \nSerialize objects to ASCII-encoded JSON. If this is disabled, the JSON returned from jsonify will contain Unicode characters. This has security implications when rendering the JSON into JavaScript in templates, and should typically remain enabled. Default: True \n"}, {"name": "JSON_SORT_KEYS", "path": "config/index#JSON_SORT_KEYS", "type": "Configuration", "text": " \nJSON_SORT_KEYS  \nSort the keys of JSON objects alphabetically. This is useful for caching because it ensures the data is serialized the same way no matter what Python\u2019s hash seed is. While not recommended, you can disable this for a possible performance improvement at the cost of caching. Default: True \n"}, {"name": "Large Applications as Packages", "path": "patterns/packages/index", "type": "User's Guide: Design Patterns", "text": "Large Applications as Packages Imagine a simple flask application structure that looks like this: /yourapplication\n    yourapplication.py\n    /static\n        style.css\n    /templates\n        layout.html\n        index.html\n        login.html\n        ...\n While this is fine for small applications, for larger applications it\u2019s a good idea to use a package instead of a module. The Tutorial is structured to use the package pattern, see the example code. Simple Packages To convert that into a larger one, just create a new folder yourapplication inside the existing one and move everything below it. Then rename yourapplication.py to __init__.py. (Make sure to delete all .pyc files first, otherwise things would most likely break) You should then end up with something like that: /yourapplication\n    /yourapplication\n        __init__.py\n        /static\n            style.css\n        /templates\n            layout.html\n            index.html\n            login.html\n            ...\n But how do you run your application now? The naive python\nyourapplication/__init__.py will not work. Let\u2019s just say that Python does not want modules in packages to be the startup file. But that is not a big problem, just add a new file called setup.py next to the inner yourapplication folder with the following contents: from setuptools import setup\n\nsetup(\n    name='yourapplication',\n    packages=['yourapplication'],\n    include_package_data=True,\n    install_requires=[\n        'flask',\n    ],\n)\n In order to run the application you need to export an environment variable that tells Flask where to find the application instance:  \nBashCMDPowershell\n\n\n$ export FLASK_APP=yourapplication\n \n\n> set FLASK_APP=yourapplication\n \n\n> $env:FLASK_APP = \"yourapplication\"\n \n If you are outside of the project directory make sure to provide the exact path to your application directory. Similarly you can turn on the development features like this:  \nBashCMDPowershell\n\n\n$ export FLASK_ENV=development\n \n\n> set FLASK_ENV=development\n \n\n> $env:FLASK_ENV = \"development\"\n \n In order to install and run the application you need to issue the following commands: $ pip install -e .\n$ flask run\n What did we gain from this? Now we can restructure the application a bit into multiple modules. The only thing you have to remember is the following quick checklist:  the Flask application object creation has to be in the __init__.py file. That way each module can import it safely and the __name__ variable will resolve to the correct package. all the view functions (the ones with a route() decorator on top) have to be imported in the __init__.py file. Not the object itself, but the module it is in. Import the view module after the application object is created.  Here\u2019s an example __init__.py: from flask import Flask\napp = Flask(__name__)\n\nimport yourapplication.views\n And this is what views.py would look like: from yourapplication import app\n\n@app.route('/')\ndef index():\n    return 'Hello World!'\n You should then end up with something like that: /yourapplication\n    setup.py\n    /yourapplication\n        __init__.py\n        views.py\n        /static\n            style.css\n        /templates\n            layout.html\n            index.html\n            login.html\n            ...\n  Circular Imports Every Python programmer hates them, and yet we just added some: circular imports (That\u2019s when two modules depend on each other. In this case views.py depends on __init__.py). Be advised that this is a bad idea in general but here it is actually fine. The reason for this is that we are not actually using the views in __init__.py and just ensuring the module is imported and we are doing that at the bottom of the file. There are still some problems with that approach but if you want to use decorators there is no way around that. Check out the Becoming Big section for some inspiration how to deal with that.  Working with Blueprints If you have larger applications it\u2019s recommended to divide them into smaller groups where each group is implemented with the help of a blueprint. For a gentle introduction into this topic refer to the Modular Applications with Blueprints chapter of the documentation.\n"}, {"name": "Lazily Loading Views", "path": "patterns/lazyloading/index", "type": "User's Guide: Design Patterns", "text": "Lazily Loading Views Flask is usually used with the decorators. Decorators are simple and you have the URL right next to the function that is called for that specific URL. However there is a downside to this approach: it means all your code that uses decorators has to be imported upfront or Flask will never actually find your function. This can be a problem if your application has to import quick. It might have to do that on systems like Google\u2019s App Engine or other systems. So if you suddenly notice that your application outgrows this approach you can fall back to a centralized URL mapping. The system that enables having a central URL map is the add_url_rule() function. Instead of using decorators, you have a file that sets up the application with all URLs. Converting to Centralized URL Map Imagine the current application looks somewhat like this: from flask import Flask\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    pass\n\n@app.route('/user/<username>')\ndef user(username):\n    pass\n Then, with the centralized approach you would have one file with the views (views.py) but without any decorator: def index():\n    pass\n\ndef user(username):\n    pass\n And then a file that sets up an application which maps the functions to URLs: from flask import Flask\nfrom yourapplication import views\napp = Flask(__name__)\napp.add_url_rule('/', view_func=views.index)\napp.add_url_rule('/user/<username>', view_func=views.user)\n Loading Late So far we only split up the views and the routing, but the module is still loaded upfront. The trick is to actually load the view function as needed. This can be accomplished with a helper class that behaves just like a function but internally imports the real function on first use: from werkzeug.utils import import_string, cached_property\n\nclass LazyView(object):\n\n    def __init__(self, import_name):\n        self.__module__, self.__name__ = import_name.rsplit('.', 1)\n        self.import_name = import_name\n\n    @cached_property\n    def view(self):\n        return import_string(self.import_name)\n\n    def __call__(self, *args, **kwargs):\n        return self.view(*args, **kwargs)\n What\u2019s important here is is that __module__ and __name__ are properly set. This is used by Flask internally to figure out how to name the URL rules in case you don\u2019t provide a name for the rule yourself. Then you can define your central place to combine the views like this: from flask import Flask\nfrom yourapplication.helpers import LazyView\napp = Flask(__name__)\napp.add_url_rule('/',\n                 view_func=LazyView('yourapplication.views.index'))\napp.add_url_rule('/user/<username>',\n                 view_func=LazyView('yourapplication.views.user'))\n You can further optimize this in terms of amount of keystrokes needed to write this by having a function that calls into add_url_rule() by prefixing a string with the project name and a dot, and by wrapping view_func in a LazyView as needed. def url(import_name, url_rules=[], **options):\n    view = LazyView(f\"yourapplication.{import_name}\")\n    for url_rule in url_rules:\n        app.add_url_rule(url_rule, view_func=view, **options)\n\n# add a single route to the index view\nurl('views.index', ['/'])\n\n# add two routes to a single function endpoint\nurl_rules = ['/user/','/user/<username>']\nurl('views.user', url_rules)\n One thing to keep in mind is that before and after request handlers have to be in a file that is imported upfront to work properly on the first request. The same goes for any kind of remaining decorator.\n"}, {"name": "load()", "path": "api/index#flask.json.load", "type": "flask.json", "text": " \nflask.json.load(fp, app=None, **kwargs)  \nDeserialize an object from JSON read from a file object. Takes the same arguments as the built-in json.load(), with some defaults from application configuration.  Parameters \n \nfp (IO[str]) \u2013 File object to read JSON from. \napp (Optional[Flask]) \u2013 Use this app\u2019s config instead of the active app context or defaults. \nkwargs (Any) \u2013 Extra arguments passed to json.load().   Return type \nAny    Changed in version 2.0: encoding is deprecated and will be removed in Flask 2.1. The file must be text mode, or binary mode with UTF-8 bytes.  \n"}, {"name": "loads()", "path": "api/index#flask.json.loads", "type": "flask.json", "text": " \nflask.json.loads(s, app=None, **kwargs)  \nDeserialize an object from a string of JSON. Takes the same arguments as the built-in json.loads(), with some defaults from application configuration.  Parameters \n \ns (str) \u2013 JSON string to deserialize. \napp (Optional[Flask]) \u2013 Use this app\u2019s config instead of the active app context or defaults. \nkwargs (Any) \u2013 Extra arguments passed to json.loads().   Return type \nAny    Changed in version 2.0: encoding is deprecated and will be removed in Flask 2.1. The data must be a string or UTF-8 bytes.   Changelog Changed in version 1.0.3: app can be passed directly, rather than requiring an app context for configuration.  \n\n"}, {"name": "load_dotenv()", "path": "api/index#flask.cli.load_dotenv", "type": "flask.cli", "text": " \nflask.cli.load_dotenv(path=None)  \nLoad \u201cdotenv\u201d files in order of precedence to set environment variables. If an env var is already set it is not overwritten, so earlier files in the list are preferred over later files. This is a no-op if python-dotenv is not installed.  Parameters \npath \u2013 Load the file at this location instead of searching.  Returns \nTrue if a file was loaded.    Changed in version 2.0: When loading the env files, set the default encoding to UTF-8.   Changelog Changed in version 1.1.0: Returns False when python-dotenv is not installed, or when the given path isn\u2019t a file.   New in version 1.0.  \n\n"}, {"name": "Logging", "path": "logging/index", "type": "User\u2019s Guide", "text": "Logging Flask uses standard Python logging. Messages about your Flask application are logged with app.logger, which takes the same name as app.name. This logger can also be used to log your own messages. @app.route('/login', methods=['POST'])\ndef login():\n    user = get_user(request.form['username'])\n\n    if user.check_password(request.form['password']):\n        login_user(user)\n        app.logger.info('%s logged in successfully', user.username)\n        return redirect(url_for('index'))\n    else:\n        app.logger.info('%s failed to log in', user.username)\n        abort(401)\n If you don\u2019t configure logging, Python\u2019s default log level is usually \u2018warning\u2019. Nothing below the configured level will be visible. Basic Configuration When you want to configure logging for your project, you should do it as soon as possible when the program starts. If app.logger is accessed before logging is configured, it will add a default handler. If possible, configure logging before creating the application object. This example uses dictConfig() to create a logging configuration similar to Flask\u2019s default, except for all logs: from logging.config import dictConfig\n\ndictConfig({\n    'version': 1,\n    'formatters': {'default': {\n        'format': '[%(asctime)s] %(levelname)s in %(module)s: %(message)s',\n    }},\n    'handlers': {'wsgi': {\n        'class': 'logging.StreamHandler',\n        'stream': 'ext://flask.logging.wsgi_errors_stream',\n        'formatter': 'default'\n    }},\n    'root': {\n        'level': 'INFO',\n        'handlers': ['wsgi']\n    }\n})\n\napp = Flask(__name__)\n Default Configuration If you do not configure logging yourself, Flask will add a StreamHandler to app.logger automatically. During requests, it will write to the stream specified by the WSGI server in environ['wsgi.errors'] (which is usually sys.stderr). Outside a request, it will log to sys.stderr. Removing the Default Handler If you configured logging after accessing app.logger, and need to remove the default handler, you can import and remove it: from flask.logging import default_handler\n\napp.logger.removeHandler(default_handler)\n Email Errors to Admins When running the application on a remote server for production, you probably won\u2019t be looking at the log messages very often. The WSGI server will probably send log messages to a file, and you\u2019ll only check that file if a user tells you something went wrong. To be proactive about discovering and fixing bugs, you can configure a logging.handlers.SMTPHandler to send an email when errors and higher are logged. import logging\nfrom logging.handlers import SMTPHandler\n\nmail_handler = SMTPHandler(\n    mailhost='127.0.0.1',\n    fromaddr='server-error@example.com',\n    toaddrs=['admin@example.com'],\n    subject='Application Error'\n)\nmail_handler.setLevel(logging.ERROR)\nmail_handler.setFormatter(logging.Formatter(\n    '[%(asctime)s] %(levelname)s in %(module)s: %(message)s'\n))\n\nif not app.debug:\n    app.logger.addHandler(mail_handler)\n This requires that you have an SMTP server set up on the same server. See the Python docs for more information about configuring the handler. Injecting Request Information Seeing more information about the request, such as the IP address, may help debugging some errors. You can subclass logging.Formatter to inject your own fields that can be used in messages. You can change the formatter for Flask\u2019s default handler, the mail handler defined above, or any other handler. from flask import has_request_context, request\nfrom flask.logging import default_handler\n\nclass RequestFormatter(logging.Formatter):\n    def format(self, record):\n        if has_request_context():\n            record.url = request.url\n            record.remote_addr = request.remote_addr\n        else:\n            record.url = None\n            record.remote_addr = None\n\n        return super().format(record)\n\nformatter = RequestFormatter(\n    '[%(asctime)s] %(remote_addr)s requested %(url)s\\n'\n    '%(levelname)s in %(module)s: %(message)s'\n)\ndefault_handler.setFormatter(formatter)\nmail_handler.setFormatter(formatter)\n Other Libraries Other libraries may use logging extensively, and you want to see relevant messages from those logs too. The simplest way to do this is to add handlers to the root logger instead of only the app logger. from flask.logging import default_handler\n\nroot = logging.getLogger()\nroot.addHandler(default_handler)\nroot.addHandler(mail_handler)\n Depending on your project, it may be more useful to configure each logger you care about separately, instead of configuring only the root logger. for logger in (\n    app.logger,\n    logging.getLogger('sqlalchemy'),\n    logging.getLogger('other_package'),\n):\n    logger.addHandler(default_handler)\n    logger.addHandler(mail_handler)\n Werkzeug Werkzeug logs basic request/response information to the 'werkzeug' logger. If the root logger has no handlers configured, Werkzeug adds a StreamHandler to its logger. Flask Extensions Depending on the situation, an extension may choose to log to app.logger or its own named logger. Consult each extension\u2019s documentation for details.\n"}, {"name": "make_response()", "path": "api/index#flask.make_response", "type": "flask", "text": " \nflask.make_response(*args)  \nSometimes it is necessary to set additional headers in a view. Because views do not have to return response objects but can return a value that is converted into a response object by Flask itself, it becomes tricky to add headers to it. This function can be called instead of using a return and you will get a response object which you can use to attach headers. If view looked like this and you want to add a new header: def index():\n    return render_template('index.html', foo=42)\n You can now do something like this: def index():\n    response = make_response(render_template('index.html', foo=42))\n    response.headers['X-Parachutes'] = 'parachutes are cool'\n    return response\n This function accepts the very same arguments you can return from a view function. This for example creates a response with a 404 error code: response = make_response(render_template('not_found.html'), 404)\n The other use case of this function is to force the return value of a view function into a response which is helpful with view decorators: response = make_response(view_function())\nresponse.headers['X-Parachutes'] = 'parachutes are cool'\n Internally this function does the following things:  if no arguments are passed, it creates a new response argument if one argument is passed, flask.Flask.make_response() is invoked with it. if more than one argument is passed, the arguments are passed to the flask.Flask.make_response() function as tuple.   Changelog New in version 0.6.   Parameters \nargs (Any) \u2013   Return type \nResponse   \n"}, {"name": "Markup", "path": "api/index#flask.Markup", "type": "flask", "text": " \nclass flask.Markup(base='', encoding=None, errors='strict')  \nA string that is ready to be safely inserted into an HTML or XML document, either because it was escaped or because it was marked safe. Passing an object to the constructor converts it to text and wraps it to mark it safe without escaping. To escape the text, use the escape() class method instead. >>> Markup(\"Hello, <em>World</em>!\")\nMarkup('Hello, <em>World</em>!')\n>>> Markup(42)\nMarkup('42')\n>>> Markup.escape(\"Hello, <em>World</em>!\")\nMarkup('Hello &lt;em&gt;World&lt;/em&gt;!')\n This implements the __html__() interface that some frameworks use. Passing an object that implements __html__() will wrap the output of that method, marking it safe. >>> class Foo:\n...     def __html__(self):\n...         return '<a href=\"/foo\">foo</a>'\n...\n>>> Markup(Foo())\nMarkup('<a href=\"/foo\">foo</a>')\n This is a subclass of str. It has the same methods, but escapes their arguments and returns a Markup instance. >>> Markup(\"<em>%s</em>\") % (\"foo & bar\",)\nMarkup('<em>foo &amp; bar</em>')\n>>> Markup(\"<em>Hello</em> \") + \"<foo>\"\nMarkup('<em>Hello</em> &lt;foo&gt;')\n  Parameters \n \nbase (Any) \u2013  \nencoding (Optional[str]) \u2013  \nerrors (str) \u2013    Return type \nMarkup    \nclassmethod escape(s)  \nEscape a string. Calls escape() and ensures that for subclasses the correct type is returned.  Parameters \ns (Any) \u2013   Return type \nmarkupsafe.Markup   \n  \nstriptags()  \nunescape() the markup, remove tags, and normalize whitespace to single spaces. >>> Markup(\"Main &raquo;        <em>About</em>\").striptags()\n'Main \u00bb About'\n  Return type \nstr   \n  \nunescape()  \nConvert escaped markup back into a text string. This replaces HTML entities with the characters they represent. >>> Markup(\"Main &raquo; <em>About</em>\").unescape()\n'Main \u00bb <em>About</em>'\n  Return type \nstr   \n \n"}, {"name": "Markup.escape()", "path": "api/index#flask.Markup.escape", "type": "flask", "text": " \nclassmethod escape(s)  \nEscape a string. Calls escape() and ensures that for subclasses the correct type is returned.  Parameters \ns (Any) \u2013   Return type \nmarkupsafe.Markup   \n"}, {"name": "Markup.striptags()", "path": "api/index#flask.Markup.striptags", "type": "flask", "text": " \nstriptags()  \nunescape() the markup, remove tags, and normalize whitespace to single spaces. >>> Markup(\"Main &raquo;        <em>About</em>\").striptags()\n'Main \u00bb About'\n  Return type \nstr   \n"}, {"name": "Markup.unescape()", "path": "api/index#flask.Markup.unescape", "type": "flask", "text": " \nunescape()  \nConvert escaped markup back into a text string. This replaces HTML entities with the characters they represent. >>> Markup(\"Main &raquo; <em>About</em>\").unescape()\n'Main \u00bb <em>About</em>'\n  Return type \nstr   \n"}, {"name": "MAX_CONTENT_LENGTH", "path": "config/index#MAX_CONTENT_LENGTH", "type": "Configuration", "text": " \nMAX_CONTENT_LENGTH  \nDon\u2019t read more than this many bytes from the incoming request data. If not set and the request does not specify a CONTENT_LENGTH, no data will be read for security. Default: None \n"}, {"name": "MAX_COOKIE_SIZE", "path": "config/index#MAX_COOKIE_SIZE", "type": "Configuration", "text": " \nMAX_COOKIE_SIZE  \nWarn if cookie headers are larger than this many bytes. Defaults to 4093. Larger cookies may be silently ignored by browsers. Set to 0 to disable the warning. \n"}, {"name": "Message Flashing", "path": "patterns/flashing/index", "type": "User's Guide: Design Patterns", "text": "Message Flashing Good applications and user interfaces are all about feedback. If the user does not get enough feedback they will probably end up hating the application. Flask provides a really simple way to give feedback to a user with the flashing system. The flashing system basically makes it possible to record a message at the end of a request and access it next request and only next request. This is usually combined with a layout template that does this. Note that browsers and sometimes web servers enforce a limit on cookie sizes. This means that flashing messages that are too large for session cookies causes message flashing to fail silently. Simple Flashing So here is a full example: from flask import Flask, flash, redirect, render_template, \\\n     request, url_for\n\napp = Flask(__name__)\napp.secret_key = b'_5#y2L\"F4Q8z\\n\\xec]/'\n\n@app.route('/')\ndef index():\n    return render_template('index.html')\n\n@app.route('/login', methods=['GET', 'POST'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if request.form['username'] != 'admin' or \\\n                request.form['password'] != 'secret':\n            error = 'Invalid credentials'\n        else:\n            flash('You were successfully logged in')\n            return redirect(url_for('index'))\n    return render_template('login.html', error=error)\n And here is the layout.html template which does the magic: <!doctype html>\n<title>My Application</title>\n{% with messages = get_flashed_messages() %}\n  {% if messages %}\n    <ul class=flashes>\n    {% for message in messages %}\n      <li>{{ message }}</li>\n    {% endfor %}\n    </ul>\n  {% endif %}\n{% endwith %}\n{% block body %}{% endblock %}\n Here is the index.html template which inherits from layout.html: {% extends \"layout.html\" %}\n{% block body %}\n  <h1>Overview</h1>\n  <p>Do you want to <a href=\"{{ url_for('login') }}\">log in?</a>\n{% endblock %}\n And here is the login.html template which also inherits from layout.html: {% extends \"layout.html\" %}\n{% block body %}\n  <h1>Login</h1>\n  {% if error %}\n    <p class=error><strong>Error:</strong> {{ error }}\n  {% endif %}\n  <form method=post>\n    <dl>\n      <dt>Username:\n      <dd><input type=text name=username value=\"{{\n          request.form.username }}\">\n      <dt>Password:\n      <dd><input type=password name=password>\n    </dl>\n    <p><input type=submit value=Login>\n  </form>\n{% endblock %}\n Flashing With Categories  Changelog New in version 0.3.  It is also possible to provide categories when flashing a message. The default category if nothing is provided is 'message'. Alternative categories can be used to give the user better feedback. For example error messages could be displayed with a red background. To flash a message with a different category, just use the second argument to the flash() function: flash('Invalid password provided', 'error')\n Inside the template you then have to tell the get_flashed_messages() function to also return the categories. The loop looks slightly different in that situation then: {% with messages = get_flashed_messages(with_categories=true) %}\n  {% if messages %}\n    <ul class=flashes>\n    {% for category, message in messages %}\n      <li class=\"{{ category }}\">{{ message }}</li>\n    {% endfor %}\n    </ul>\n  {% endif %}\n{% endwith %}\n This is just one example of how to render these flashed messages. One might also use the category to add a prefix such as <strong>Error:</strong> to the message. Filtering Flash Messages  Changelog New in version 0.9.  Optionally you can pass a list of categories which filters the results of get_flashed_messages(). This is useful if you wish to render each category in a separate block. {% with errors = get_flashed_messages(category_filter=[\"error\"]) %}\n{% if errors %}\n<div class=\"alert-message block-message error\">\n  <a class=\"close\" href=\"#\">\u00d7</a>\n  <ul>\n    {%- for msg in errors %}\n    <li>{{ msg }}</li>\n    {% endfor -%}\n  </ul>\n</div>\n{% endif %}\n{% endwith %}\n\n"}, {"name": "MethodView", "path": "api/index#flask.views.MethodView", "type": "flask.views", "text": " \nclass flask.views.MethodView  \nA class-based view that dispatches request methods to the corresponding class methods. For example, if you implement a get method, it will be used to handle GET requests. class CounterAPI(MethodView):\n    def get(self):\n        return session.get('counter', 0)\n\n    def post(self):\n        session['counter'] = session.get('counter', 0) + 1\n        return 'OK'\n\napp.add_url_rule('/counter', view_func=CounterAPI.as_view('counter'))\n  \ndispatch_request(*args, **kwargs)  \nSubclasses have to override this method to implement the actual view function code. This method is called with all the arguments from the URL rule.  Parameters \n \nargs (Any) \u2013  \nkwargs (Any) \u2013    Return type \nUnion[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], WSGIApplication]   \n \n"}, {"name": "MethodView.dispatch_request()", "path": "api/index#flask.views.MethodView.dispatch_request", "type": "flask.views", "text": " \ndispatch_request(*args, **kwargs)  \nSubclasses have to override this method to implement the actual view function code. This method is called with all the arguments from the URL rule.  Parameters \n \nargs (Any) \u2013  \nkwargs (Any) \u2013    Return type \nUnion[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], WSGIApplication]   \n"}, {"name": "Modular Applications with Blueprints", "path": "blueprints/index", "type": "User\u2019s Guide", "text": "Modular Applications with Blueprints  Changelog New in version 0.7.  Flask uses a concept of blueprints for making application components and supporting common patterns within an application or across applications. Blueprints can greatly simplify how large applications work and provide a central means for Flask extensions to register operations on applications. A Blueprint object works similarly to a Flask application object, but it is not actually an application. Rather it is a blueprint of how to construct or extend an application. Why Blueprints? Blueprints in Flask are intended for these cases:  Factor an application into a set of blueprints. This is ideal for larger applications; a project could instantiate an application object, initialize several extensions, and register a collection of blueprints. Register a blueprint on an application at a URL prefix and/or subdomain. Parameters in the URL prefix/subdomain become common view arguments (with defaults) across all view functions in the blueprint. Register a blueprint multiple times on an application with different URL rules. Provide template filters, static files, templates, and other utilities through blueprints. A blueprint does not have to implement applications or view functions. Register a blueprint on an application for any of these cases when initializing a Flask extension.  A blueprint in Flask is not a pluggable app because it is not actually an application \u2013 it\u2019s a set of operations which can be registered on an application, even multiple times. Why not have multiple application objects? You can do that (see Application Dispatching), but your applications will have separate configs and will be managed at the WSGI layer. Blueprints instead provide separation at the Flask level, share application config, and can change an application object as necessary with being registered. The downside is that you cannot unregister a blueprint once an application was created without having to destroy the whole application object. The Concept of Blueprints The basic concept of blueprints is that they record operations to execute when registered on an application. Flask associates view functions with blueprints when dispatching requests and generating URLs from one endpoint to another. My First Blueprint This is what a very basic blueprint looks like. In this case we want to implement a blueprint that does simple rendering of static templates: from flask import Blueprint, render_template, abort\nfrom jinja2 import TemplateNotFound\n\nsimple_page = Blueprint('simple_page', __name__,\n                        template_folder='templates')\n\n@simple_page.route('/', defaults={'page': 'index'})\n@simple_page.route('/<page>')\ndef show(page):\n    try:\n        return render_template(f'pages/{page}.html')\n    except TemplateNotFound:\n        abort(404)\n When you bind a function with the help of the @simple_page.route decorator, the blueprint will record the intention of registering the function show on the application when it\u2019s later registered. Additionally it will prefix the endpoint of the function with the name of the blueprint which was given to the Blueprint constructor (in this case also simple_page). The blueprint\u2019s name does not modify the URL, only the endpoint. Registering Blueprints So how do you register that blueprint? Like this: from flask import Flask\nfrom yourapplication.simple_page import simple_page\n\napp = Flask(__name__)\napp.register_blueprint(simple_page)\n If you check the rules registered on the application, you will find these: >>> app.url_map\nMap([<Rule '/static/<filename>' (HEAD, OPTIONS, GET) -> static>,\n <Rule '/<page>' (HEAD, OPTIONS, GET) -> simple_page.show>,\n <Rule '/' (HEAD, OPTIONS, GET) -> simple_page.show>])\n The first one is obviously from the application itself for the static files. The other two are for the show function of the simple_page blueprint. As you can see, they are also prefixed with the name of the blueprint and separated by a dot (.). Blueprints however can also be mounted at different locations: app.register_blueprint(simple_page, url_prefix='/pages')\n And sure enough, these are the generated rules: >>> app.url_map\nMap([<Rule '/static/<filename>' (HEAD, OPTIONS, GET) -> static>,\n <Rule '/pages/<page>' (HEAD, OPTIONS, GET) -> simple_page.show>,\n <Rule '/pages/' (HEAD, OPTIONS, GET) -> simple_page.show>])\n On top of that you can register blueprints multiple times though not every blueprint might respond properly to that. In fact it depends on how the blueprint is implemented if it can be mounted more than once. Nesting Blueprints It is possible to register a blueprint on another blueprint. parent = Blueprint('parent', __name__, url_prefix='/parent')\nchild = Blueprint('child', __name__, url_prefix='/child')\nparent.register_blueprint(child)\napp.register_blueprint(parent)\n The child blueprint will gain the parent\u2019s name as a prefix to its name, and child URLs will be prefixed with the parent\u2019s URL prefix. url_for('parent.child.create')\n/parent/child/create\n Blueprint-specific before request functions, etc. registered with the parent will trigger for the child. If a child does not have an error handler that can handle a given exception, the parent\u2019s will be tried. Blueprint Resources Blueprints can provide resources as well. Sometimes you might want to introduce a blueprint only for the resources it provides. Blueprint Resource Folder Like for regular applications, blueprints are considered to be contained in a folder. While multiple blueprints can originate from the same folder, it does not have to be the case and it\u2019s usually not recommended. The folder is inferred from the second argument to Blueprint which is usually __name__. This argument specifies what logical Python module or package corresponds to the blueprint. If it points to an actual Python package that package (which is a folder on the filesystem) is the resource folder. If it\u2019s a module, the package the module is contained in will be the resource folder. You can access the Blueprint.root_path property to see what the resource folder is: >>> simple_page.root_path\n'/Users/username/TestProject/yourapplication'\n To quickly open sources from this folder you can use the open_resource() function: with simple_page.open_resource('static/style.css') as f:\n    code = f.read()\n Static Files A blueprint can expose a folder with static files by providing the path to the folder on the filesystem with the static_folder argument. It is either an absolute path or relative to the blueprint\u2019s location: admin = Blueprint('admin', __name__, static_folder='static')\n By default the rightmost part of the path is where it is exposed on the web. This can be changed with the static_url_path argument. Because the folder is called static here it will be available at the url_prefix of the blueprint + /static. If the blueprint has the prefix /admin, the static URL will be /admin/static. The endpoint is named blueprint_name.static. You can generate URLs to it with url_for() like you would with the static folder of the application: url_for('admin.static', filename='style.css')\n However, if the blueprint does not have a url_prefix, it is not possible to access the blueprint\u2019s static folder. This is because the URL would be /static in this case, and the application\u2019s /static route takes precedence. Unlike template folders, blueprint static folders are not searched if the file does not exist in the application static folder. Templates If you want the blueprint to expose templates you can do that by providing the template_folder parameter to the Blueprint constructor: admin = Blueprint('admin', __name__, template_folder='templates')\n For static files, the path can be absolute or relative to the blueprint resource folder. The template folder is added to the search path of templates but with a lower priority than the actual application\u2019s template folder. That way you can easily override templates that a blueprint provides in the actual application. This also means that if you don\u2019t want a blueprint template to be accidentally overridden, make sure that no other blueprint or actual application template has the same relative path. When multiple blueprints provide the same relative template path the first blueprint registered takes precedence over the others. So if you have a blueprint in the folder yourapplication/admin and you want to render the template 'admin/index.html' and you have provided templates as a template_folder you will have to create a file like this: yourapplication/admin/templates/admin/index.html. The reason for the extra admin folder is to avoid getting our template overridden by a template named index.html in the actual application template folder. To further reiterate this: if you have a blueprint named admin and you want to render a template called index.html which is specific to this blueprint, the best idea is to lay out your templates like this: yourpackage/\n    blueprints/\n        admin/\n            templates/\n                admin/\n                    index.html\n            __init__.py\n And then when you want to render the template, use admin/index.html as the name to look up the template by. If you encounter problems loading the correct templates enable the EXPLAIN_TEMPLATE_LOADING config variable which will instruct Flask to print out the steps it goes through to locate templates on every render_template call. Building URLs If you want to link from one page to another you can use the url_for() function just like you normally would do just that you prefix the URL endpoint with the name of the blueprint and a dot (.): url_for('admin.index')\n Additionally if you are in a view function of a blueprint or a rendered template and you want to link to another endpoint of the same blueprint, you can use relative redirects by prefixing the endpoint with a dot only: url_for('.index')\n This will link to admin.index for instance in case the current request was dispatched to any other admin blueprint endpoint. Blueprint Error Handlers Blueprints support the errorhandler decorator just like the Flask application object, so it is easy to make Blueprint-specific custom error pages. Here is an example for a \u201c404 Page Not Found\u201d exception: @simple_page.errorhandler(404)\ndef page_not_found(e):\n    return render_template('pages/404.html')\n Most errorhandlers will simply work as expected; however, there is a caveat concerning handlers for 404 and 405 exceptions. These errorhandlers are only invoked from an appropriate raise statement or a call to abort in another of the blueprint\u2019s view functions; they are not invoked by, e.g., an invalid URL access. This is because the blueprint does not \u201cown\u201d a certain URL space, so the application instance has no way of knowing which blueprint error handler it should run if given an invalid URL. If you would like to execute different handling strategies for these errors based on URL prefixes, they may be defined at the application level using the request proxy object: @app.errorhandler(404)\n@app.errorhandler(405)\ndef _handle_api_error(ex):\n    if request.path.startswith('/api/'):\n        return jsonify(error=str(ex)), ex.code\n    else:\n        return ex\n See Handling Application Errors.\n"}, {"name": "mod_wsgi (Apache)", "path": "deploying/mod_wsgi/index", "type": "User's Guide: Deploying", "text": "mod_wsgi (Apache) If you are using the Apache webserver, consider using mod_wsgi.  Watch Out Please make sure in advance that any app.run() calls you might have in your application file are inside an if __name__ ==\n'__main__': block or moved to a separate file. Just make sure it\u2019s not called because this will always start a local WSGI server which we do not want if we deploy that application to mod_wsgi.  Installing mod_wsgi\n If you don\u2019t have mod_wsgi installed yet you have to either install it using a package manager or compile it yourself. The mod_wsgi installation instructions cover source installations on UNIX systems. If you are using Ubuntu/Debian you can apt-get it and activate it as follows: $ apt-get install libapache2-mod-wsgi-py3\n If you are using a yum based distribution (Fedora, OpenSUSE, etc..) you can install it as follows: $ yum install mod_wsgi\n On FreeBSD install mod_wsgi by compiling the www/mod_wsgi port or by using pkg_add: $ pkg install ap24-py37-mod_wsgi\n If you are using pkgsrc you can install mod_wsgi by compiling the www/ap2-wsgi package. If you encounter segfaulting child processes after the first apache reload you can safely ignore them. Just restart the server. Creating a .wsgi file To run your application you need a yourapplication.wsgi file. This file contains the code mod_wsgi is executing on startup to get the application object. The object called application in that file is then used as application. For most applications the following file should be sufficient: from yourapplication import app as application\n If a factory function is used in a __init__.py file, then the function should be imported: from yourapplication import create_app\napplication = create_app()\n If you don\u2019t have a factory function for application creation but a singleton instance you can directly import that one as application. Store that file somewhere that you will find it again (e.g.: /var/www/yourapplication) and make sure that yourapplication and all the libraries that are in use are on the python load path. If you don\u2019t want to install it system wide consider using a virtual python instance. Keep in mind that you will have to actually install your application into the virtualenv as well. Alternatively there is the option to just patch the path in the .wsgi file before the import: import sys\nsys.path.insert(0, '/path/to/the/application')\n Configuring Apache The last thing you have to do is to create an Apache configuration file for your application. In this example we are telling mod_wsgi to execute the application under a different user for security reasons: <VirtualHost *>\n    ServerName example.com\n\n    WSGIDaemonProcess yourapplication user=user1 group=group1 threads=5\n    WSGIScriptAlias / /var/www/yourapplication/yourapplication.wsgi\n\n    <Directory /var/www/yourapplication>\n        WSGIProcessGroup yourapplication\n        WSGIApplicationGroup %{GLOBAL}\n        Order deny,allow\n        Allow from all\n    </Directory>\n</VirtualHost>\n Note: WSGIDaemonProcess isn\u2019t implemented in Windows and Apache will refuse to run with the above configuration. On a Windows system, eliminate those lines: <VirtualHost *>\n    ServerName example.com\n    WSGIScriptAlias / C:\\yourdir\\yourapp.wsgi\n    <Directory C:\\yourdir>\n        Order deny,allow\n        Allow from all\n    </Directory>\n</VirtualHost>\n Note: There have been some changes in access control configuration for Apache 2.4. Most notably, the syntax for directory permissions has changed from httpd 2.2 Order allow,deny\nAllow from all\n to httpd 2.4 syntax Require all granted\n For more information consult the mod_wsgi documentation. Troubleshooting If your application does not run, follow this guide to troubleshoot:  \nProblem: application does not run, errorlog shows SystemExit ignored\n\nYou have an app.run() call in your application file that is not guarded by an if __name__ == '__main__': condition. Either remove that run() call from the file and move it into a separate run.py file or put it into such an if block.  \nProblem: application gives permission errors\n\nProbably caused by your application running as the wrong user. Make sure the folders the application needs access to have the proper privileges set and the application runs as the correct user (user and group parameter to the WSGIDaemonProcess directive)  \nProblem: application dies with an error on print\n\nKeep in mind that mod_wsgi disallows doing anything with sys.stdout and sys.stderr. You can disable this protection from the config by setting the WSGIRestrictStdout to off: WSGIRestrictStdout Off\n Alternatively you can also replace the standard out in the .wsgi file with a different stream: import sys\nsys.stdout = sys.stderr\n  \nProblem: accessing resources gives IO errors\n\nYour application probably is a single .py file you symlinked into the site-packages folder. Please be aware that this does not work, instead you either have to put the folder into the pythonpath the file is stored in, or convert your application into a package. The reason for this is that for non-installed packages, the module filename is used to locate the resources and for symlinks the wrong filename is picked up.   Support for Automatic Reloading To help deployment tools you can activate support for automatic reloading. Whenever something changes the .wsgi file, mod_wsgi will reload all the daemon processes for us. For that, just add the following directive to your Directory section: WSGIScriptReloading On\n Working with Virtual Environments Virtual environments have the advantage that they never install the required dependencies system wide so you have a better control over what is used where. If you want to use a virtual environment with mod_wsgi you have to modify your .wsgi file slightly. Add the following lines to the top of your .wsgi file: activate_this = '/path/to/env/bin/activate_this.py'\nwith open(activate_this) as file_:\n    exec(file_.read(), dict(__file__=activate_this))\n This sets up the load paths according to the settings of the virtual environment. Keep in mind that the path has to be absolute.\n"}, {"name": "MongoDB with MongoEngine", "path": "patterns/mongoengine/index", "type": "User's Guide: Design Patterns", "text": "MongoDB with MongoEngine Using a document database like MongoDB is a common alternative to relational SQL databases. This pattern shows how to use MongoEngine, a document mapper library, to integrate with MongoDB. A running MongoDB server and Flask-MongoEngine are required. pip install flask-mongoengine\n Configuration Basic setup can be done by defining MONGODB_SETTINGS on app.config and creating a MongoEngine instance. from flask import Flask\nfrom flask_mongoengine import MongoEngine\n\napp = Flask(__name__)\napp.config['MONGODB_SETTINGS'] = {\n    \"db\": \"myapp\",\n}\ndb = MongoEngine(app)\n Mapping Documents To declare a model that represents a Mongo document, create a class that inherits from Document and declare each of the fields. import mongoengine as me\n\nclass Movie(me.Document):\n    title = me.StringField(required=True)\n    year = me.IntField()\n    rated = me.StringField()\n    director = me.StringField()\n    actors = me.ListField()\n If the document has nested fields, use EmbeddedDocument to defined the fields of the embedded document and EmbeddedDocumentField to declare it on the parent document. class Imdb(me.EmbeddedDocument):\n    imdb_id = me.StringField()\n    rating = me.DecimalField()\n    votes = me.IntField()\n\nclass Movie(me.Document):\n    ...\n    imdb = me.EmbeddedDocumentField(Imdb)\n Creating Data Instantiate your document class with keyword arguments for the fields. You can also assign values to the field attributes after instantiation. Then call doc.save(). bttf = Movie(title=\"Back To The Future\", year=1985)\nbttf.actors = [\n    \"Michael J. Fox\",\n    \"Christopher Lloyd\"\n]\nbttf.imdb = Imdb(imdb_id=\"tt0088763\", rating=8.5)\nbttf.save()\n Queries Use the class objects attribute to make queries. A keyword argument looks for an equal value on the field. bttf = Movies.objects(title=\"Back To The Future\").get_or_404()\n Query operators may be used by concatenating them with the field name using a double-underscore. objects, and queries returned by calling it, are iterable. some_theron_movie = Movie.objects(actors__in=[\"Charlize Theron\"]).first()\n\nfor recents in Movie.objects(year__gte=2017):\n    print(recents.title)\n Documentation There are many more ways to define and query documents with MongoEngine. For more information, check out the official documentation. Flask-MongoEngine adds helpful utilities on top of MongoEngine. Check out their documentation as well.\n"}, {"name": "Namespace", "path": "api/index#flask.signals.Namespace", "type": "flask.signals", "text": " \nclass signals.Namespace  \nAn alias for blinker.base.Namespace if blinker is available, otherwise a dummy class that creates fake signals. This class is available for Flask extensions that want to provide the same fallback system as Flask itself.  \nsignal(name, doc=None)  \nCreates a new signal for this namespace if blinker is available, otherwise returns a fake signal that has a send method that will do nothing but will fail with a RuntimeError for all other operations, including connecting. \n \n"}, {"name": "Namespace.signal()", "path": "api/index#flask.signals.Namespace.signal", "type": "flask.signals", "text": " \nsignal(name, doc=None)  \nCreates a new signal for this namespace if blinker is available, otherwise returns a fake signal that has a send method that will do nothing but will fail with a RuntimeError for all other operations, including connecting. \n"}, {"name": "NullSession", "path": "api/index#flask.sessions.NullSession", "type": "flask.sessions", "text": " \nclass flask.sessions.NullSession(initial=None)  \nClass used to generate nicer error messages if sessions are not available. Will still allow read-only access to the empty session but fail on setting.  Parameters \ninitial (Any) \u2013   Return type \nNone   \n"}, {"name": "pass_script_info()", "path": "api/index#flask.cli.pass_script_info", "type": "flask.cli", "text": " \nflask.cli.pass_script_info(f)  \nMarks a function so that an instance of ScriptInfo is passed as first argument to the click callback.  Parameters \nf (click.decorators.F) \u2013   Return type \nclick.decorators.F   \n"}, {"name": "Patterns for Flask", "path": "patterns/index", "type": "User's Guide: Design Patterns", "text": "Patterns for Flask Certain features and interactions are common enough that you will find them in most web applications. For example, many applications use a relational database and user authentication. They will open a database connection at the beginning of the request and get the information for the logged in user. At the end of the request, the database connection is closed. These types of patterns may be a bit outside the scope of Flask itself, but Flask makes it easy to implement them. Some common patterns are collected in the following pages.  \nLarge Applications as Packages Simple Packages Working with Blueprints   \nApplication Factories Basic Factories Factories & Extensions Using Applications Factory Improvements   \nApplication Dispatching Working with this Document Combining Applications Dispatch by Subdomain Dispatch by Path   \nUsing URL Processors Internationalized Application URLs Internationalized Blueprint URLs   \nDeploying with Setuptools Basic Setup Script Tagging Builds Distributing Resources Declaring Dependencies Installing / Developing   \nDeploying with Fabric Creating the first Fabfile Running Fabfiles The WSGI File The Configuration File First Deployment Next Steps   \nUsing SQLite 3 with Flask Connect on Demand Easy Querying Initial Schemas   \nSQLAlchemy in Flask Flask-SQLAlchemy Extension Declarative Manual Object Relational Mapping SQL Abstraction Layer   \nUploading Files A Gentle Introduction Improving Uploads Upload Progress Bars An Easier Solution   Caching \nView Decorators Login Required Decorator Caching Decorator Templating Decorator Endpoint Decorator   \nForm Validation with WTForms The Forms In the View Forms in Templates   \nTemplate Inheritance Base Template Child Template   \nMessage Flashing Simple Flashing Flashing With Categories Filtering Flash Messages   \nAJAX with jQuery Loading jQuery Where is My Site? JSON View Functions The HTML   \nLazily Loading Views Converting to Centralized URL Map Loading Late   \nMongoDB with MongoEngine Configuration Mapping Documents Creating Data Queries Documentation   \nAdding a favicon See also   \nStreaming Contents Basic Usage Streaming from Templates Streaming with Context   Deferred Request Callbacks Adding HTTP Method Overrides Request Content Checksums \nCelery Background Tasks Install Configure An example task Run a worker   Subclassing Flask Single-Page Applications \n"}, {"name": "PERMANENT_SESSION_LIFETIME", "path": "config/index#PERMANENT_SESSION_LIFETIME", "type": "Configuration", "text": " \nPERMANENT_SESSION_LIFETIME  \nIf session.permanent is true, the cookie\u2019s expiration will be set this number of seconds in the future. Can either be a datetime.timedelta or an int. Flask\u2019s default cookie implementation validates that the cryptographic signature is not older than this value. Default: timedelta(days=31) (2678400 seconds) \n"}, {"name": "Pluggable Views", "path": "views/index", "type": "User\u2019s Guide", "text": "Pluggable Views  Changelog New in version 0.7.  Flask 0.7 introduces pluggable views inspired by the generic views from Django which are based on classes instead of functions. The main intention is that you can replace parts of the implementations and this way have customizable pluggable views. Basic Principle Consider you have a function that loads a list of objects from the database and renders into a template: @app.route('/users/')\ndef show_users(page):\n    users = User.query.all()\n    return render_template('users.html', users=users)\n This is simple and flexible, but if you want to provide this view in a generic fashion that can be adapted to other models and templates as well you might want more flexibility. This is where pluggable class-based views come into place. As the first step to convert this into a class based view you would do this: from flask.views import View\n\nclass ShowUsers(View):\n\n    def dispatch_request(self):\n        users = User.query.all()\n        return render_template('users.html', objects=users)\n\napp.add_url_rule('/users/', view_func=ShowUsers.as_view('show_users'))\n As you can see what you have to do is to create a subclass of flask.views.View and implement dispatch_request(). Then we have to convert that class into an actual view function by using the as_view() class method. The string you pass to that function is the name of the endpoint that view will then have. But this by itself is not helpful, so let\u2019s refactor the code a bit: from flask.views import View\n\nclass ListView(View):\n\n    def get_template_name(self):\n        raise NotImplementedError()\n\n    def render_template(self, context):\n        return render_template(self.get_template_name(), **context)\n\n    def dispatch_request(self):\n        context = {'objects': self.get_objects()}\n        return self.render_template(context)\n\nclass UserView(ListView):\n\n    def get_template_name(self):\n        return 'users.html'\n\n    def get_objects(self):\n        return User.query.all()\n This of course is not that helpful for such a small example, but it\u2019s good enough to explain the basic principle. When you have a class-based view the question comes up what self points to. The way this works is that whenever the request is dispatched a new instance of the class is created and the dispatch_request() method is called with the parameters from the URL rule. The class itself is instantiated with the parameters passed to the as_view() function. For instance you can write a class like this: class RenderTemplateView(View):\n    def __init__(self, template_name):\n        self.template_name = template_name\n    def dispatch_request(self):\n        return render_template(self.template_name)\n And then you can register it like this: app.add_url_rule('/about', view_func=RenderTemplateView.as_view(\n    'about_page', template_name='about.html'))\n Method Hints Pluggable views are attached to the application like a regular function by either using route() or better add_url_rule(). That however also means that you would have to provide the names of the HTTP methods the view supports when you attach this. In order to move that information to the class you can provide a methods attribute that has this information: class MyView(View):\n    methods = ['GET', 'POST']\n\n    def dispatch_request(self):\n        if request.method == 'POST':\n            ...\n        ...\n\napp.add_url_rule('/myview', view_func=MyView.as_view('myview'))\n Method Based Dispatching For RESTful APIs it\u2019s especially helpful to execute a different function for each HTTP method. With the flask.views.MethodView you can easily do that. Each HTTP method maps to a function with the same name (just in lowercase): from flask.views import MethodView\n\nclass UserAPI(MethodView):\n\n    def get(self):\n        users = User.query.all()\n        ...\n\n    def post(self):\n        user = User.from_form_data(request.form)\n        ...\n\napp.add_url_rule('/users/', view_func=UserAPI.as_view('users'))\n That way you also don\u2019t have to provide the methods attribute. It\u2019s automatically set based on the methods defined in the class. Decorating Views Since the view class itself is not the view function that is added to the routing system it does not make much sense to decorate the class itself. Instead you either have to decorate the return value of as_view() by hand: def user_required(f):\n    \"\"\"Checks whether user is logged in or raises error 401.\"\"\"\n    def decorator(*args, **kwargs):\n        if not g.user:\n            abort(401)\n        return f(*args, **kwargs)\n    return decorator\n\nview = user_required(UserAPI.as_view('users'))\napp.add_url_rule('/users/', view_func=view)\n Starting with Flask 0.8 there is also an alternative way where you can specify a list of decorators to apply in the class declaration: class UserAPI(MethodView):\n    decorators = [user_required]\n Due to the implicit self from the caller\u2019s perspective you cannot use regular view decorators on the individual methods of the view however, keep this in mind. Method Views for APIs Web APIs are often working very closely with HTTP verbs so it makes a lot of sense to implement such an API based on the MethodView. That said, you will notice that the API will require different URL rules that go to the same method view most of the time. For instance consider that you are exposing a user object on the web:  \nURL Method Description  \n/users/ GET Gives a list of all users  \n/users/ POST Creates a new user  \n/users/<id> GET Shows a single user  \n/users/<id> PUT Updates a single user  \n/users/<id> DELETE Deletes a single user   So how would you go about doing that with the MethodView? The trick is to take advantage of the fact that you can provide multiple rules to the same view. Let\u2019s assume for the moment the view would look like this: class UserAPI(MethodView):\n\n    def get(self, user_id):\n        if user_id is None:\n            # return a list of users\n            pass\n        else:\n            # expose a single user\n            pass\n\n    def post(self):\n        # create a new user\n        pass\n\n    def delete(self, user_id):\n        # delete a single user\n        pass\n\n    def put(self, user_id):\n        # update a single user\n        pass\n So how do we hook this up with the routing system? By adding two rules and explicitly mentioning the methods for each: user_view = UserAPI.as_view('user_api')\napp.add_url_rule('/users/', defaults={'user_id': None},\n                 view_func=user_view, methods=['GET',])\napp.add_url_rule('/users/', view_func=user_view, methods=['POST',])\napp.add_url_rule('/users/<int:user_id>', view_func=user_view,\n                 methods=['GET', 'PUT', 'DELETE'])\n If you have a lot of APIs that look similar you can refactor that registration code: def register_api(view, endpoint, url, pk='id', pk_type='int'):\n    view_func = view.as_view(endpoint)\n    app.add_url_rule(url, defaults={pk: None},\n                     view_func=view_func, methods=['GET',])\n    app.add_url_rule(url, view_func=view_func, methods=['POST',])\n    app.add_url_rule(f'{url}<{pk_type}:{pk}>', view_func=view_func,\n                     methods=['GET', 'PUT', 'DELETE'])\n\nregister_api(UserAPI, 'user_api', '/users/', pk='user_id')\n\n"}, {"name": "PREFERRED_URL_SCHEME", "path": "config/index#PREFERRED_URL_SCHEME", "type": "Configuration", "text": " \nPREFERRED_URL_SCHEME  \nUse this scheme for generating external URLs when not in a request context. Default: 'http' \n"}, {"name": "PRESERVE_CONTEXT_ON_EXCEPTION", "path": "config/index#PRESERVE_CONTEXT_ON_EXCEPTION", "type": "Configuration", "text": " \nPRESERVE_CONTEXT_ON_EXCEPTION  \nDon\u2019t pop the request context when an exception occurs. If not set, this is true if DEBUG is true. This allows debuggers to introspect the request data on errors, and should normally not need to be set directly. Default: None \n"}, {"name": "PROPAGATE_EXCEPTIONS", "path": "config/index#PROPAGATE_EXCEPTIONS", "type": "Configuration", "text": " \nPROPAGATE_EXCEPTIONS  \nExceptions are re-raised rather than being handled by the app\u2019s error handlers. If not set, this is implicitly true if TESTING or DEBUG is enabled. Default: None \n"}, {"name": "Quickstart", "path": "quickstart/index", "type": "User\u2019s Guide", "text": "Quickstart Eager to get started? This page gives a good introduction to Flask. Follow Installation to set up a project and install Flask first. A Minimal Application A minimal Flask application looks something like this: from flask import Flask\n\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef hello_world():\n    return \"<p>Hello, World!</p>\"\n So what did that code do?  First we imported the Flask class. An instance of this class will be our WSGI application. Next we create an instance of this class. The first argument is the name of the application\u2019s module or package. __name__ is a convenient shortcut for this that is appropriate for most cases. This is needed so that Flask knows where to look for resources such as templates and static files. We then use the route() decorator to tell Flask what URL should trigger our function. The function returns the message we want to display in the user\u2019s browser. The default content type is HTML, so HTML in the string will be rendered by the browser.  Save it as hello.py or something similar. Make sure to not call your application flask.py because this would conflict with Flask itself. To run the application, use the flask command or python -m flask. Before you can do that you need to tell your terminal the application to work with by exporting the FLASK_APP environment variable:  \nBashCMDPowershell\n\n\n$ export FLASK_APP=hello\n$ flask run\n * Running on http://127.0.0.1:5000/\n \n\n> set FLASK_APP=hello\n> flask run\n * Running on http://127.0.0.1:5000/\n \n\n> $env:FLASK_APP = \"hello\"\n> flask run\n * Running on http://127.0.0.1:5000/\n \n  Application Discovery Behavior As a shortcut, if the file is named app.py or wsgi.py, you don\u2019t have to set the FLASK_APP environment variable. See Command Line Interface for more details.  This launches a very simple builtin server, which is good enough for testing but probably not what you want to use in production. For deployment options see Deployment Options. Now head over to http://127.0.0.1:5000/, and you should see your hello world greeting.  Externally Visible Server If you run the server you will notice that the server is only accessible from your own computer, not from any other in the network. This is the default because in debugging mode a user of the application can execute arbitrary Python code on your computer. If you have the debugger disabled or trust the users on your network, you can make the server publicly available simply by adding --host=0.0.0.0 to the command line: $ flask run --host=0.0.0.0\n This tells your operating system to listen on all public IPs.  What to do if the Server does not Start In case the python -m flask fails or flask does not exist, there are multiple reasons this might be the case. First of all you need to look at the error message. Old Version of Flask Versions of Flask older than 0.11 used to have different ways to start the application. In short, the flask command did not exist, and neither did python -m flask. In that case you have two options: either upgrade to newer Flask versions or have a look at Development Server to see the alternative method for running a server. Invalid Import Name The FLASK_APP environment variable is the name of the module to import at flask run. In case that module is incorrectly named you will get an import error upon start (or if debug is enabled when you navigate to the application). It will tell you what it tried to import and why it failed. The most common reason is a typo or because you did not actually create an app object. Debug Mode The flask run command can do more than just start the development server. By enabling debug mode, the server will automatically reload if code changes, and will show an interactive debugger in the browser if an error occurs during a request.   Warning The debugger allows executing arbitrary Python code from the browser. It is protected by a pin, but still represents a major security risk. Do not run the development server or debugger in a production environment.  To enable all development features, set the FLASK_ENV environment variable to development before calling flask run.  \nBashCMDPowershell\n\n\n$ export FLASK_ENV=development\n$ flask run\n \n\n> set FLASK_ENV=development\n> flask run\n \n\n> $env:FLASK_ENV = \"development\"\n> flask run\n \n See also:  \nDevelopment Server and Command Line Interface for information about running in development mode. \nDebugging Application Errors for information about using the built-in debugger and other debuggers. \nLogging and Handling Application Errors to log errors and display nice error pages.  HTML Escaping When returning HTML (the default response type in Flask), any user-provided values rendered in the output must be escaped to protect from injection attacks. HTML templates rendered with Jinja, introduced later, will do this automatically. escape(), shown here, can be used manually. It is omitted in most examples for brevity, but you should always be aware of how you\u2019re using untrusted data. from markupsafe import escape\n\n@app.route(\"/<name>\")\ndef hello(name):\n    return f\"Hello, {escape(name)}!\"\n If a user managed to submit the name <script>alert(\"bad\")</script>, escaping causes it to be rendered as text, rather than running the script in the user\u2019s browser. <name> in the route captures a value from the URL and passes it to the view function. These variable rules are explained below. Routing Modern web applications use meaningful URLs to help users. Users are more likely to like a page and come back if the page uses a meaningful URL they can remember and use to directly visit a page. Use the route() decorator to bind a function to a URL. @app.route('/')\ndef index():\n    return 'Index Page'\n\n@app.route('/hello')\ndef hello():\n    return 'Hello, World'\n You can do more! You can make parts of the URL dynamic and attach multiple rules to a function. Variable Rules You can add variable sections to a URL by marking sections with <variable_name>. Your function then receives the <variable_name> as a keyword argument. Optionally, you can use a converter to specify the type of the argument like <converter:variable_name>. from markupsafe import escape\n\n@app.route('/user/<username>')\ndef show_user_profile(username):\n    # show the user profile for that user\n    return f'User {username}'\n\n@app.route('/post/<int:post_id>')\ndef show_post(post_id):\n    # show the post with the given id, the id is an integer\n    return f'Post {post_id}'\n\n@app.route('/path/<path:subpath>')\ndef show_subpath(subpath):\n    # show the subpath after /path/\n    return f'Subpath {subpath}'\n Converter types:  \nstring (default) accepts any text without a slash  \nint accepts positive integers  \nfloat accepts positive floating point values  \npath like string but also accepts slashes  \nuuid accepts UUID strings   Unique URLs / Redirection Behavior The following two rules differ in their use of a trailing slash. @app.route('/projects/')\ndef projects():\n    return 'The project page'\n\n@app.route('/about')\ndef about():\n    return 'The about page'\n The canonical URL for the projects endpoint has a trailing slash. It\u2019s similar to a folder in a file system. If you access the URL without a trailing slash (/projects), Flask redirects you to the canonical URL with the trailing slash (/projects/). The canonical URL for the about endpoint does not have a trailing slash. It\u2019s similar to the pathname of a file. Accessing the URL with a trailing slash (/about/) produces a 404 \u201cNot Found\u201d error. This helps keep URLs unique for these resources, which helps search engines avoid indexing the same page twice. URL Building To build a URL to a specific function, use the url_for() function. It accepts the name of the function as its first argument and any number of keyword arguments, each corresponding to a variable part of the URL rule. Unknown variable parts are appended to the URL as query parameters. Why would you want to build URLs using the URL reversing function url_for() instead of hard-coding them into your templates?  Reversing is often more descriptive than hard-coding the URLs. You can change your URLs in one go instead of needing to remember to manually change hard-coded URLs. URL building handles escaping of special characters transparently. The generated paths are always absolute, avoiding unexpected behavior of relative paths in browsers. If your application is placed outside the URL root, for example, in /myapplication instead of /, url_for() properly handles that for you.  For example, here we use the test_request_context() method to try out url_for(). test_request_context() tells Flask to behave as though it\u2019s handling a request even while we use a Python shell. See Context Locals. from flask import url_for\n\n@app.route('/')\ndef index():\n    return 'index'\n\n@app.route('/login')\ndef login():\n    return 'login'\n\n@app.route('/user/<username>')\ndef profile(username):\n    return f'{username}\\'s profile'\n\nwith app.test_request_context():\n    print(url_for('index'))\n    print(url_for('login'))\n    print(url_for('login', next='/'))\n    print(url_for('profile', username='John Doe'))\n /\n/login\n/login?next=/\n/user/John%20Doe\n HTTP Methods Web applications use different HTTP methods when accessing URLs. You should familiarize yourself with the HTTP methods as you work with Flask. By default, a route only answers to GET requests. You can use the methods argument of the route() decorator to handle different HTTP methods. from flask import request\n\n@app.route('/login', methods=['GET', 'POST'])\ndef login():\n    if request.method == 'POST':\n        return do_the_login()\n    else:\n        return show_the_login_form()\n If GET is present, Flask automatically adds support for the HEAD method and handles HEAD requests according to the HTTP RFC. Likewise, OPTIONS is automatically implemented for you. Static Files Dynamic web applications also need static files. That\u2019s usually where the CSS and JavaScript files are coming from. Ideally your web server is configured to serve them for you, but during development Flask can do that as well. Just create a folder called static in your package or next to your module and it will be available at /static on the application. To generate URLs for static files, use the special 'static' endpoint name: url_for('static', filename='style.css')\n The file has to be stored on the filesystem as static/style.css. Rendering Templates Generating HTML from within Python is not fun, and actually pretty cumbersome because you have to do the HTML escaping on your own to keep the application secure. Because of that Flask configures the Jinja2 template engine for you automatically. To render a template you can use the render_template() method. All you have to do is provide the name of the template and the variables you want to pass to the template engine as keyword arguments. Here\u2019s a simple example of how to render a template: from flask import render_template\n\n@app.route('/hello/')\n@app.route('/hello/<name>')\ndef hello(name=None):\n    return render_template('hello.html', name=name)\n Flask will look for templates in the templates folder. So if your application is a module, this folder is next to that module, if it\u2019s a package it\u2019s actually inside your package: Case 1: a module: /application.py\n/templates\n    /hello.html\n Case 2: a package: /application\n    /__init__.py\n    /templates\n        /hello.html\n For templates you can use the full power of Jinja2 templates. Head over to the official Jinja2 Template Documentation for more information. Here is an example template: <!doctype html>\n<title>Hello from Flask</title>\n{% if name %}\n  <h1>Hello {{ name }}!</h1>\n{% else %}\n  <h1>Hello, World!</h1>\n{% endif %}\n Inside templates you also have access to the request, session and g 1 objects as well as the get_flashed_messages() function. Templates are especially useful if inheritance is used. If you want to know how that works, see Template Inheritance. Basically template inheritance makes it possible to keep certain elements on each page (like header, navigation and footer). Automatic escaping is enabled, so if name contains HTML it will be escaped automatically. If you can trust a variable and you know that it will be safe HTML (for example because it came from a module that converts wiki markup to HTML) you can mark it as safe by using the Markup class or by using the |safe filter in the template. Head over to the Jinja 2 documentation for more examples. Here is a basic introduction to how the Markup class works: >>> from markupsafe import Markup\n>>> Markup('<strong>Hello %s!</strong>') % '<blink>hacker</blink>'\nMarkup('<strong>Hello &lt;blink&gt;hacker&lt;/blink&gt;!</strong>')\n>>> Markup.escape('<blink>hacker</blink>')\nMarkup('&lt;blink&gt;hacker&lt;/blink&gt;')\n>>> Markup('<em>Marked up</em> &raquo; HTML').striptags()\n'Marked up \\xbb HTML'\n  Changelog Changed in version 0.5: Autoescaping is no longer enabled for all templates. The following extensions for templates trigger autoescaping: .html, .htm, .xml, .xhtml. Templates loaded from a string will have autoescaping disabled.   \n1  \nUnsure what that g object is? It\u2019s something in which you can store information for your own needs. See the documentation for flask.g and Using SQLite 3 with Flask.   Accessing Request Data For web applications it\u2019s crucial to react to the data a client sends to the server. In Flask this information is provided by the global request object. If you have some experience with Python you might be wondering how that object can be global and how Flask manages to still be threadsafe. The answer is context locals: Context Locals  Insider Information If you want to understand how that works and how you can implement tests with context locals, read this section, otherwise just skip it.  Certain objects in Flask are global objects, but not of the usual kind. These objects are actually proxies to objects that are local to a specific context. What a mouthful. But that is actually quite easy to understand. Imagine the context being the handling thread. A request comes in and the web server decides to spawn a new thread (or something else, the underlying object is capable of dealing with concurrency systems other than threads). When Flask starts its internal request handling it figures out that the current thread is the active context and binds the current application and the WSGI environments to that context (thread). It does that in an intelligent way so that one application can invoke another application without breaking. So what does this mean to you? Basically you can completely ignore that this is the case unless you are doing something like unit testing. You will notice that code which depends on a request object will suddenly break because there is no request object. The solution is creating a request object yourself and binding it to the context. The easiest solution for unit testing is to use the test_request_context() context manager. In combination with the with statement it will bind a test request so that you can interact with it. Here is an example: from flask import request\n\nwith app.test_request_context('/hello', method='POST'):\n    # now you can do something with the request until the\n    # end of the with block, such as basic assertions:\n    assert request.path == '/hello'\n    assert request.method == 'POST'\n The other possibility is passing a whole WSGI environment to the request_context() method: with app.request_context(environ):\n    assert request.method == 'POST'\n The Request Object The request object is documented in the API section and we will not cover it here in detail (see Request). Here is a broad overview of some of the most common operations. First of all you have to import it from the flask module: from flask import request\n The current request method is available by using the method attribute. To access form data (data transmitted in a POST or PUT request) you can use the form attribute. Here is a full example of the two attributes mentioned above: @app.route('/login', methods=['POST', 'GET'])\ndef login():\n    error = None\n    if request.method == 'POST':\n        if valid_login(request.form['username'],\n                       request.form['password']):\n            return log_the_user_in(request.form['username'])\n        else:\n            error = 'Invalid username/password'\n    # the code below is executed if the request method\n    # was GET or the credentials were invalid\n    return render_template('login.html', error=error)\n What happens if the key does not exist in the form attribute? In that case a special KeyError is raised. You can catch it like a standard KeyError but if you don\u2019t do that, a HTTP 400 Bad Request error page is shown instead. So for many situations you don\u2019t have to deal with that problem. To access parameters submitted in the URL (?key=value) you can use the args attribute: searchword = request.args.get('key', '')\n We recommend accessing URL parameters with get or by catching the KeyError because users might change the URL and presenting them a 400 bad request page in that case is not user friendly. For a full list of methods and attributes of the request object, head over to the Request documentation. File Uploads You can handle uploaded files with Flask easily. Just make sure not to forget to set the enctype=\"multipart/form-data\" attribute on your HTML form, otherwise the browser will not transmit your files at all. Uploaded files are stored in memory or at a temporary location on the filesystem. You can access those files by looking at the files attribute on the request object. Each uploaded file is stored in that dictionary. It behaves just like a standard Python file object, but it also has a save() method that allows you to store that file on the filesystem of the server. Here is a simple example showing how that works: from flask import request\n\n@app.route('/upload', methods=['GET', 'POST'])\ndef upload_file():\n    if request.method == 'POST':\n        f = request.files['the_file']\n        f.save('/var/www/uploads/uploaded_file.txt')\n    ...\n If you want to know how the file was named on the client before it was uploaded to your application, you can access the filename attribute. However please keep in mind that this value can be forged so never ever trust that value. If you want to use the filename of the client to store the file on the server, pass it through the secure_filename() function that Werkzeug provides for you: from werkzeug.utils import secure_filename\n\n@app.route('/upload', methods=['GET', 'POST'])\ndef upload_file():\n    if request.method == 'POST':\n        file = request.files['the_file']\n        file.save(f\"/var/www/uploads/{secure_filename(f.filename)}\")\n    ...\n For some better examples, see Uploading Files. Cookies To access cookies you can use the cookies attribute. To set cookies you can use the set_cookie method of response objects. The cookies attribute of request objects is a dictionary with all the cookies the client transmits. If you want to use sessions, do not use the cookies directly but instead use the Sessions in Flask that add some security on top of cookies for you. Reading cookies: from flask import request\n\n@app.route('/')\ndef index():\n    username = request.cookies.get('username')\n    # use cookies.get(key) instead of cookies[key] to not get a\n    # KeyError if the cookie is missing.\n Storing cookies: from flask import make_response\n\n@app.route('/')\ndef index():\n    resp = make_response(render_template(...))\n    resp.set_cookie('username', 'the username')\n    return resp\n Note that cookies are set on response objects. Since you normally just return strings from the view functions Flask will convert them into response objects for you. If you explicitly want to do that you can use the make_response() function and then modify it. Sometimes you might want to set a cookie at a point where the response object does not exist yet. This is possible by utilizing the Deferred Request Callbacks pattern. For this also see About Responses. Redirects and Errors To redirect a user to another endpoint, use the redirect() function; to abort a request early with an error code, use the abort() function: from flask import abort, redirect, url_for\n\n@app.route('/')\ndef index():\n    return redirect(url_for('login'))\n\n@app.route('/login')\ndef login():\n    abort(401)\n    this_is_never_executed()\n This is a rather pointless example because a user will be redirected from the index to a page they cannot access (401 means access denied) but it shows how that works. By default a black and white error page is shown for each error code. If you want to customize the error page, you can use the errorhandler() decorator: from flask import render_template\n\n@app.errorhandler(404)\ndef page_not_found(error):\n    return render_template('page_not_found.html'), 404\n Note the 404 after the render_template() call. This tells Flask that the status code of that page should be 404 which means not found. By default 200 is assumed which translates to: all went well. See Handling Application Errors for more details. About Responses The return value from a view function is automatically converted into a response object for you. If the return value is a string it\u2019s converted into a response object with the string as response body, a 200 OK status code and a text/html mimetype. If the return value is a dict, jsonify() is called to produce a response. The logic that Flask applies to converting return values into response objects is as follows:  If a response object of the correct type is returned it\u2019s directly returned from the view. If it\u2019s a string, a response object is created with that data and the default parameters. If it\u2019s a dict, a response object is created using jsonify. If a tuple is returned the items in the tuple can provide extra information. Such tuples have to be in the form (response, status), (response, headers), or (response, status, headers). The status value will override the status code and headers can be a list or dictionary of additional header values. If none of that works, Flask will assume the return value is a valid WSGI application and convert that into a response object.  If you want to get hold of the resulting response object inside the view you can use the make_response() function. Imagine you have a view like this: from flask import render_template\n\n@app.errorhandler(404)\ndef not_found(error):\n    return render_template('error.html'), 404\n You just need to wrap the return expression with make_response() and get the response object to modify it, then return it: from flask import make_response\n\n@app.errorhandler(404)\ndef not_found(error):\n    resp = make_response(render_template('error.html'), 404)\n    resp.headers['X-Something'] = 'A value'\n    return resp\n APIs with JSON A common response format when writing an API is JSON. It\u2019s easy to get started writing such an API with Flask. If you return a dict from a view, it will be converted to a JSON response. @app.route(\"/me\")\ndef me_api():\n    user = get_current_user()\n    return {\n        \"username\": user.username,\n        \"theme\": user.theme,\n        \"image\": url_for(\"user_image\", filename=user.image),\n    }\n Depending on your API design, you may want to create JSON responses for types other than dict. In that case, use the jsonify() function, which will serialize any supported JSON data type. Or look into Flask community extensions that support more complex applications. from flask import jsonify\n\n@app.route(\"/users\")\ndef users_api():\n    users = get_all_users()\n    return jsonify([user.to_json() for user in users])\n Sessions In addition to the request object there is also a second object called session which allows you to store information specific to a user from one request to the next. This is implemented on top of cookies for you and signs the cookies cryptographically. What this means is that the user could look at the contents of your cookie but not modify it, unless they know the secret key used for signing. In order to use sessions you have to set a secret key. Here is how sessions work: from flask import session\n\n# Set the secret key to some random bytes. Keep this really secret!\napp.secret_key = b'_5#y2L\"F4Q8z\\n\\xec]/'\n\n@app.route('/')\ndef index():\n    if 'username' in session:\n        return f'Logged in as {session[\"username\"]}'\n    return 'You are not logged in'\n\n@app.route('/login', methods=['GET', 'POST'])\ndef login():\n    if request.method == 'POST':\n        session['username'] = request.form['username']\n        return redirect(url_for('index'))\n    return '''\n        <form method=\"post\">\n            <p><input type=text name=username>\n            <p><input type=submit value=Login>\n        </form>\n    '''\n\n@app.route('/logout')\ndef logout():\n    # remove the username from the session if it's there\n    session.pop('username', None)\n    return redirect(url_for('index'))\n  How to generate good secret keys A secret key should be as random as possible. Your operating system has ways to generate pretty random data based on a cryptographic random generator. Use the following command to quickly generate a value for Flask.secret_key (or SECRET_KEY): $ python -c 'import os; print(os.urandom(16))'\nb'_5#y2L\"F4Q8z\\n\\xec]/'\n  A note on cookie-based sessions: Flask will take the values you put into the session object and serialize them into a cookie. If you are finding some values do not persist across requests, cookies are indeed enabled, and you are not getting a clear error message, check the size of the cookie in your page responses compared to the size supported by web browsers. Besides the default client-side based sessions, if you want to handle sessions on the server-side instead, there are several Flask extensions that support this. Message Flashing Good applications and user interfaces are all about feedback. If the user does not get enough feedback they will probably end up hating the application. Flask provides a really simple way to give feedback to a user with the flashing system. The flashing system basically makes it possible to record a message at the end of a request and access it on the next (and only the next) request. This is usually combined with a layout template to expose the message. To flash a message use the flash() method, to get hold of the messages you can use get_flashed_messages() which is also available in the templates. See Message Flashing for a full example. Logging  Changelog New in version 0.3.  Sometimes you might be in a situation where you deal with data that should be correct, but actually is not. For example you may have some client-side code that sends an HTTP request to the server but it\u2019s obviously malformed. This might be caused by a user tampering with the data, or the client code failing. Most of the time it\u2019s okay to reply with 400 Bad Request in that situation, but sometimes that won\u2019t do and the code has to continue working. You may still want to log that something fishy happened. This is where loggers come in handy. As of Flask 0.3 a logger is preconfigured for you to use. Here are some example log calls: app.logger.debug('A value for debugging')\napp.logger.warning('A warning occurred (%d apples)', 42)\napp.logger.error('An error occurred')\n The attached logger is a standard logging Logger, so head over to the official logging docs for more information. See Handling Application Errors. Hooking in WSGI Middleware To add WSGI middleware to your Flask application, wrap the application\u2019s wsgi_app attribute. For example, to apply Werkzeug\u2019s ProxyFix middleware for running behind Nginx: from werkzeug.middleware.proxy_fix import ProxyFix\napp.wsgi_app = ProxyFix(app.wsgi_app)\n Wrapping app.wsgi_app instead of app means that app still points at your Flask application, not at the middleware, so you can continue to use and configure app directly. Using Flask Extensions Extensions are packages that help you accomplish common tasks. For example, Flask-SQLAlchemy provides SQLAlchemy support that makes it simple and easy to use with Flask. For more on Flask extensions, see Extensions. Deploying to a Web Server Ready to deploy your new Flask app? See Deployment Options.\n"}, {"name": "redirect()", "path": "api/index#flask.redirect", "type": "flask", "text": " \nflask.redirect(location, code=302, Response=None)  \nReturns a response object (a WSGI application) that, if called, redirects the client to the target location. Supported codes are 301, 302, 303, 305, 307, and 308. 300 is not supported because it\u2019s not a real redirect and 304 because it\u2019s the answer for a request with a request with defined If-Modified-Since headers.  Changelog New in version 0.10: The class used for the Response object can now be passed in.   New in version 0.6: The location can now be a unicode string that is encoded using the iri_to_uri() function.   Parameters \n \nlocation (str) \u2013 the location the response should redirect to. \ncode (int) \u2013 the redirect status code. defaults to 302. \nResponse (class) \u2013 a Response class to use when instantiating a response. The default is werkzeug.wrappers.Response if unspecified.   Return type \nResponse   \n"}, {"name": "render_template()", "path": "api/index#flask.render_template", "type": "flask", "text": " \nflask.render_template(template_name_or_list, **context)  \nRenders a template from the template folder with the given context.  Parameters \n \ntemplate_name_or_list (Union[str, List[str]]) \u2013 the name of the template to be rendered, or an iterable with template names the first one existing will be rendered \ncontext (Any) \u2013 the variables that should be available in the context of the template.   Return type \nstr   \n"}, {"name": "render_template_string()", "path": "api/index#flask.render_template_string", "type": "flask", "text": " \nflask.render_template_string(source, **context)  \nRenders a template from the given template source string with the given context. Template variables will be autoescaped.  Parameters \n \nsource (str) \u2013 the source code of the template to be rendered \ncontext (Any) \u2013 the variables that should be available in the context of the template.   Return type \nstr   \n"}, {"name": "Request", "path": "api/index#flask.Request", "type": "flask", "text": " \nclass flask.Request(environ, populate_request=True, shallow=False)  \nThe request object used by default in Flask. Remembers the matched endpoint and view arguments. It is what ends up as request. If you want to replace the request object used you can subclass this and set request_class to your subclass. The request object is a Request subclass and provides all of the attributes Werkzeug defines plus a few Flask specific ones.  Parameters \n \nenviron (WSGIEnvironment) \u2013  \npopulate_request (bool) \u2013  \nshallow (bool) \u2013    Return type \nNone    \nproperty accept_charsets: werkzeug.datastructures.CharsetAccept  \nList of charsets this client supports as CharsetAccept object. \n  \nproperty accept_encodings: werkzeug.datastructures.Accept  \nList of encodings this client accepts. Encodings in a HTTP term are compression encodings such as gzip. For charsets have a look at accept_charset. \n  \nproperty accept_languages: werkzeug.datastructures.LanguageAccept  \nList of languages this client accepts as LanguageAccept object. \n  \nproperty accept_mimetypes: werkzeug.datastructures.MIMEAccept  \nList of mimetypes this client supports as MIMEAccept object. \n  \naccess_control_request_headers  \nSent with a preflight request to indicate which headers will be sent with the cross origin request. Set access_control_allow_headers on the response to indicate which headers are allowed. \n  \naccess_control_request_method  \nSent with a preflight request to indicate which method will be used for the cross origin request. Set access_control_allow_methods on the response to indicate which methods are allowed. \n  \nproperty access_route: List[str]  \nIf a forwarded header exists this is a list of all ip addresses from the client ip to the last proxy server. \n  \nclassmethod application(f)  \nDecorate a function as responder that accepts the request as the last argument. This works like the responder() decorator but the function is passed the request object as the last argument and the request object will be closed automatically: @Request.application\ndef my_wsgi_app(request):\n    return Response('Hello World!')\n As of Werkzeug 0.14 HTTP exceptions are automatically caught and converted to responses instead of failing.  Parameters \nf (Callable[[Request], WSGIApplication]) \u2013 the WSGI callable to decorate  Returns \na new WSGI callable  Return type \nWSGIApplication   \n  \nproperty args: MultiDict[str, str]  \nThe parsed URL parameters (the part in the URL after the question mark). By default an ImmutableMultiDict is returned from this function. This can be changed by setting parameter_storage_class to a different type. This might be necessary if the order of the form data is important. \n  \nproperty authorization: Optional[werkzeug.datastructures.Authorization]  \nThe Authorization object in parsed form. \n  \nproperty base_url: str  \nLike url but without the query string. \n  \nproperty blueprint: Optional[str]  \nThe name of the current blueprint \n  \nproperty cache_control: werkzeug.datastructures.RequestCacheControl  \nA RequestCacheControl object for the incoming cache control headers. \n  \nclose()  \nCloses associated resources of this request object. This closes all file handles explicitly. You can also use the request object in a with statement which will automatically close it.  Changelog New in version 0.9.   Return type \nNone   \n  \ncontent_encoding  \nThe Content-Encoding entity-header field is used as a modifier to the media-type. When present, its value indicates what additional content codings have been applied to the entity-body, and thus what decoding mechanisms must be applied in order to obtain the media-type referenced by the Content-Type header field.  Changelog New in version 0.9.  \n\n  \nproperty content_length: Optional[int]  \nThe Content-Length entity-header field indicates the size of the entity-body in bytes or, in the case of the HEAD method, the size of the entity-body that would have been sent had the request been a GET. \n  \ncontent_md5  \nThe Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest of the entity-body for the purpose of providing an end-to-end message integrity check (MIC) of the entity-body. (Note: a MIC is good for detecting accidental modification of the entity-body in transit, but is not proof against malicious attacks.)  Changelog New in version 0.9.  \n\n  \ncontent_type  \nThe Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of the HEAD method, the media type that would have been sent had the request been a GET. \n  \nproperty cookies: ImmutableMultiDict[str, str]  \nA dict with the contents of all cookies transmitted with the request. \n  \nproperty data: bytes  \nContains the incoming request data as string in case it came with a mimetype Werkzeug does not handle. \n  \ndate  \nThe Date general-header field represents the date and time at which the message was originated, having the same semantics as orig-date in RFC 822.  Changed in version 2.0: The datetime object is timezone-aware.  \n  \ndict_storage_class  \nalias of werkzeug.datastructures.ImmutableMultiDict \n  \nproperty endpoint: Optional[str]  \nThe endpoint that matched the request. This in combination with view_args can be used to reconstruct the same or a modified URL. If an exception happened when matching, this will be None. \n  \nenviron: WSGIEnvironment  \nThe WSGI environment containing HTTP headers and information from the WSGI server. \n  \nproperty files: ImmutableMultiDict[str, FileStorage]  \nMultiDict object containing all uploaded files. Each key in files is the name from the <input type=\"file\" name=\"\">. Each value in files is a Werkzeug FileStorage object. It basically behaves like a standard file object you know from Python, with the difference that it also has a save() function that can store the file on the filesystem. Note that files will only contain data if the request method was POST, PUT or PATCH and the <form> that posted to the request had enctype=\"multipart/form-data\". It will be empty otherwise. See the MultiDict / FileStorage documentation for more details about the used data structure. \n  \nproperty form: ImmutableMultiDict[str, str]  \nThe form parameters. By default an ImmutableMultiDict is returned from this function. This can be changed by setting parameter_storage_class to a different type. This might be necessary if the order of the form data is important. Please keep in mind that file uploads will not end up here, but instead in the files attribute.  Changelog Changed in version 0.9: Previous to Werkzeug 0.9 this would only contain form data for POST and PUT requests.  \n\n  \nform_data_parser_class  \nalias of werkzeug.formparser.FormDataParser \n  \nclassmethod from_values(*args, **kwargs)  \nCreate a new request object based on the values provided. If environ is given missing values are filled from there. This method is useful for small scripts when you need to simulate a request from an URL. Do not use this method for unittesting, there is a full featured client object (Client) that allows to create multipart requests, support for cookies etc. This accepts the same options as the EnvironBuilder.  Changelog Changed in version 0.5: This method now accepts the same arguments as EnvironBuilder. Because of this the environ parameter is now called environ_overrides.   Returns \nrequest object  Parameters \n \nargs (Any) \u2013  \nkwargs (Any) \u2013    Return type \nwerkzeug.wrappers.request.Request   \n  \nproperty full_path: str  \nRequested path, including the query string. \n  \nget_data(cache=True, as_text=False, parse_form_data=False)  \nThis reads the buffered incoming data from the client into one bytes object. By default this is cached but that behavior can be changed by setting cache to False. Usually it\u2019s a bad idea to call this method without checking the content length first as a client could send dozens of megabytes or more to cause memory problems on the server. Note that if the form data was already parsed this method will not return anything as form data parsing does not cache the data like this method does. To implicitly invoke form data parsing function set parse_form_data to True. When this is done the return value of this method will be an empty string if the form parser handles the data. This generally is not necessary as if the whole data is cached (which is the default) the form parser will used the cached data to parse the form data. Please be generally aware of checking the content length first in any case before calling this method to avoid exhausting server memory. If as_text is set to True the return value will be a decoded string.  Changelog New in version 0.9.   Parameters \n \ncache (bool) \u2013  \nas_text (bool) \u2013  \nparse_form_data (bool) \u2013    Return type \nUnion[bytes, str]   \n  \nget_json(force=False, silent=False, cache=True)  \nParse data as JSON. If the mimetype does not indicate JSON (application/json, see is_json()), this returns None. If parsing fails, on_json_loading_failed() is called and its return value is used as the return value.  Parameters \n \nforce (bool) \u2013 Ignore the mimetype and always try to parse JSON. \nsilent (bool) \u2013 Silence parsing errors and return None instead. \ncache (bool) \u2013 Store the parsed JSON to return for subsequent calls.   Return type \nOptional[Any]   \n  \nheaders  \nThe headers received with the request. \n  \nproperty host: str  \nThe host name the request was made to, including the port if it\u2019s non-standard. Validated with trusted_hosts. \n  \nproperty host_url: str  \nThe request URL scheme and host only. \n  \nproperty if_match: werkzeug.datastructures.ETags  \nAn object containing all the etags in the If-Match header.  Return type \nETags   \n  \nproperty if_modified_since: Optional[datetime.datetime]  \nThe parsed If-Modified-Since header as a datetime object.  Changed in version 2.0: The datetime object is timezone-aware.  \n  \nproperty if_none_match: werkzeug.datastructures.ETags  \nAn object containing all the etags in the If-None-Match header.  Return type \nETags   \n  \nproperty if_range: werkzeug.datastructures.IfRange  \nThe parsed If-Range header.  Changed in version 2.0: IfRange.date is timezone-aware.   Changelog New in version 0.7.  \n\n  \nproperty if_unmodified_since: Optional[datetime.datetime]  \nThe parsed If-Unmodified-Since header as a datetime object.  Changed in version 2.0: The datetime object is timezone-aware.  \n  \ninput_stream  \nThe WSGI input stream. In general it\u2019s a bad idea to use this one because you can easily read past the boundary. Use the stream instead. \n  \nproperty is_json: bool  \nCheck if the mimetype indicates JSON data, either application/json or application/*+json. \n  \nis_multiprocess  \nboolean that is True if the application is served by a WSGI server that spawns multiple processes. \n  \nis_multithread  \nboolean that is True if the application is served by a multithreaded WSGI server. \n  \nis_run_once  \nboolean that is True if the application will be executed only once in a process lifetime. This is the case for CGI for example, but it\u2019s not guaranteed that the execution only happens one time. \n  \nproperty is_secure: bool  \nTrue if the request was made with a secure protocol (HTTPS or WSS). \n  \nproperty json: Optional[Any]  \nThe parsed JSON data if mimetype indicates JSON (application/json, see is_json()). Calls get_json() with default arguments. \n  \nlist_storage_class  \nalias of werkzeug.datastructures.ImmutableList \n  \nmake_form_data_parser()  \nCreates the form data parser. Instantiates the form_data_parser_class with some parameters.  Changelog New in version 0.8.   Return type \nwerkzeug.formparser.FormDataParser   \n  \nproperty max_content_length: Optional[int]  \nRead-only view of the MAX_CONTENT_LENGTH config key. \n  \nmax_forwards  \nThe Max-Forwards request-header field provides a mechanism with the TRACE and OPTIONS methods to limit the number of proxies or gateways that can forward the request to the next inbound server. \n  \nmethod  \nThe method the request was made with, such as GET. \n  \nproperty mimetype: str  \nLike content_type, but without parameters (eg, without charset, type etc.) and always lowercase. For example if the content type is text/HTML; charset=utf-8 the mimetype would be 'text/html'. \n  \nproperty mimetype_params: Dict[str, str]  \nThe mimetype parameters as dict. For example if the content type is text/html; charset=utf-8 the params would be {'charset': 'utf-8'}. \n  \non_json_loading_failed(e)  \nCalled if get_json() parsing fails and isn\u2019t silenced. If this method returns a value, it is used as the return value for get_json(). The default implementation raises BadRequest.  Parameters \ne (Exception) \u2013   Return type \nNoReturn   \n  \norigin  \nThe host that the request originated from. Set access_control_allow_origin on the response to indicate which origins are allowed. \n  \nparameter_storage_class  \nalias of werkzeug.datastructures.ImmutableMultiDict \n  \npath  \nThe path part of the URL after root_path. This is the path used for routing within the application. \n  \nproperty pragma: werkzeug.datastructures.HeaderSet  \nThe Pragma general-header field is used to include implementation-specific directives that might apply to any recipient along the request/response chain. All pragma directives specify optional behavior from the viewpoint of the protocol; however, some systems MAY require that behavior be consistent with the directives. \n  \nquery_string  \nThe part of the URL after the \u201c?\u201d. This is the raw value, use args for the parsed values. \n  \nproperty range: Optional[werkzeug.datastructures.Range]  \nThe parsed Range header.  Changelog New in version 0.7.   Return type \nRange   \n  \nreferrer  \nThe Referer[sic] request-header field allows the client to specify, for the server\u2019s benefit, the address (URI) of the resource from which the Request-URI was obtained (the \u201creferrer\u201d, although the header field is misspelled). \n  \nremote_addr  \nThe address of the client sending the request. \n  \nremote_user  \nIf the server supports user authentication, and the script is protected, this attribute contains the username the user has authenticated as. \n  \nroot_path  \nThe prefix that the application is mounted under, without a trailing slash. path comes after this. \n  \nproperty root_url: str  \nThe request URL scheme, host, and root path. This is the root that the application is accessed from. \n  \nrouting_exception: Optional[Exception] = None  \nIf matching the URL failed, this is the exception that will be raised / was raised as part of the request handling. This is usually a NotFound exception or something similar. \n  \nscheme  \nThe URL scheme of the protocol the request used, such as https or wss. \n  \nproperty script_root: str  \nAlias for self.root_path. environ[\"SCRIPT_ROOT\"] without a trailing slash. \n  \nserver  \nThe address of the server. (host, port), (path, None) for unix sockets, or None if not known. \n  \nshallow: bool  \nSet when creating the request object. If True, reading from the request body will cause a RuntimeException. Useful to prevent modifying the stream from middleware. \n  \nproperty stream: BinaryIO  \nIf the incoming form data was not encoded with a known mimetype the data is stored unmodified in this stream for consumption. Most of the time it is a better idea to use data which will give you that data as a string. The stream only returns the data once. Unlike input_stream this stream is properly guarded that you can\u2019t accidentally read past the length of the input. Werkzeug will internally always refer to this stream to read data which makes it possible to wrap this object with a stream that does filtering.  Changelog Changed in version 0.9: This stream is now always available but might be consumed by the form parser later on. Previously the stream was only set if no parsing happened.  \n\n  \nproperty url: str  \nThe full request URL with the scheme, host, root path, path, and query string. \n  \nproperty url_charset: str  \nThe charset that is assumed for URLs. Defaults to the value of charset.  Changelog New in version 0.6.  \n\n  \nproperty url_root: str  \nAlias for root_url. The URL with scheme, host, and root path. For example, https://example.com/app/. \n  \nurl_rule: Optional[Rule] = None  \nThe internal URL rule that matched the request. This can be useful to inspect which methods are allowed for the URL from a before/after handler (request.url_rule.methods) etc. Though if the request\u2019s method was invalid for the URL rule, the valid list is available in routing_exception.valid_methods instead (an attribute of the Werkzeug exception MethodNotAllowed) because the request was never internally bound.  Changelog New in version 0.6.  \n\n  \nproperty user_agent: werkzeug.user_agent.UserAgent  \nThe user agent. Use user_agent.string to get the header value. Set user_agent_class to a subclass of UserAgent to provide parsing for the other properties or other extended data.  Changed in version 2.0: The built in parser is deprecated and will be removed in Werkzeug 2.1. A UserAgent subclass must be set to parse data from the string.  \n  \nuser_agent_class  \nalias of werkzeug.useragents._UserAgent \n  \nproperty values: CombinedMultiDict[str, str]  \nA werkzeug.datastructures.CombinedMultiDict that combines args and form. For GET requests, only args are present, not form.  Changed in version 2.0: For GET requests, only args are present, not form.  \n  \nview_args: Optional[Dict[str, Any]] = None  \nA dict of view arguments that matched the request. If an exception happened when matching, this will be None. \n  \nproperty want_form_data_parsed: bool  \nTrue if the request method carries content. By default this is true if a Content-Type is sent.  Changelog New in version 0.8.  \n\n \n"}, {"name": "Request Content Checksums", "path": "patterns/requestchecksum/index", "type": "User's Guide: Design Patterns", "text": "Request Content Checksums Various pieces of code can consume the request data and preprocess it. For instance JSON data ends up on the request object already read and processed, form data ends up there as well but goes through a different code path. This seems inconvenient when you want to calculate the checksum of the incoming request data. This is necessary sometimes for some APIs. Fortunately this is however very simple to change by wrapping the input stream. The following example calculates the SHA1 checksum of the incoming data as it gets read and stores it in the WSGI environment: import hashlib\n\nclass ChecksumCalcStream(object):\n\n    def __init__(self, stream):\n        self._stream = stream\n        self._hash = hashlib.sha1()\n\n    def read(self, bytes):\n        rv = self._stream.read(bytes)\n        self._hash.update(rv)\n        return rv\n\n    def readline(self, size_hint):\n        rv = self._stream.readline(size_hint)\n        self._hash.update(rv)\n        return rv\n\ndef generate_checksum(request):\n    env = request.environ\n    stream = ChecksumCalcStream(env['wsgi.input'])\n    env['wsgi.input'] = stream\n    return stream._hash\n To use this, all you need to do is to hook the calculating stream in before the request starts consuming data. (Eg: be careful accessing request.form or anything of that nature. before_request_handlers for instance should be careful not to access it). Example usage: @app.route('/special-api', methods=['POST'])\ndef special_api():\n    hash = generate_checksum(request)\n    # Accessing this parses the input stream\n    files = request.files\n    # At this point the hash is fully constructed.\n    checksum = hash.hexdigest()\n    return f\"Hash was: {checksum}\"\n\n"}, {"name": "Request.access_control_request_headers", "path": "api/index#flask.Request.access_control_request_headers", "type": "flask", "text": " \naccess_control_request_headers  \nSent with a preflight request to indicate which headers will be sent with the cross origin request. Set access_control_allow_headers on the response to indicate which headers are allowed. \n"}, {"name": "Request.access_control_request_method", "path": "api/index#flask.Request.access_control_request_method", "type": "flask", "text": " \naccess_control_request_method  \nSent with a preflight request to indicate which method will be used for the cross origin request. Set access_control_allow_methods on the response to indicate which methods are allowed. \n"}, {"name": "Request.application()", "path": "api/index#flask.Request.application", "type": "flask", "text": " \nclassmethod application(f)  \nDecorate a function as responder that accepts the request as the last argument. This works like the responder() decorator but the function is passed the request object as the last argument and the request object will be closed automatically: @Request.application\ndef my_wsgi_app(request):\n    return Response('Hello World!')\n As of Werkzeug 0.14 HTTP exceptions are automatically caught and converted to responses instead of failing.  Parameters \nf (Callable[[Request], WSGIApplication]) \u2013 the WSGI callable to decorate  Returns \na new WSGI callable  Return type \nWSGIApplication   \n"}, {"name": "Request.close()", "path": "api/index#flask.Request.close", "type": "flask", "text": " \nclose()  \nCloses associated resources of this request object. This closes all file handles explicitly. You can also use the request object in a with statement which will automatically close it.  Changelog New in version 0.9.   Return type \nNone   \n"}, {"name": "Request.content_encoding", "path": "api/index#flask.Request.content_encoding", "type": "flask", "text": " \ncontent_encoding  \nThe Content-Encoding entity-header field is used as a modifier to the media-type. When present, its value indicates what additional content codings have been applied to the entity-body, and thus what decoding mechanisms must be applied in order to obtain the media-type referenced by the Content-Type header field.  Changelog New in version 0.9.  \n\n"}, {"name": "Request.content_md5", "path": "api/index#flask.Request.content_md5", "type": "flask", "text": " \ncontent_md5  \nThe Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest of the entity-body for the purpose of providing an end-to-end message integrity check (MIC) of the entity-body. (Note: a MIC is good for detecting accidental modification of the entity-body in transit, but is not proof against malicious attacks.)  Changelog New in version 0.9.  \n\n"}, {"name": "Request.content_type", "path": "api/index#flask.Request.content_type", "type": "flask", "text": " \ncontent_type  \nThe Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of the HEAD method, the media type that would have been sent had the request been a GET. \n"}, {"name": "Request.date", "path": "api/index#flask.Request.date", "type": "flask", "text": " \ndate  \nThe Date general-header field represents the date and time at which the message was originated, having the same semantics as orig-date in RFC 822.  Changed in version 2.0: The datetime object is timezone-aware.  \n"}, {"name": "Request.dict_storage_class", "path": "api/index#flask.Request.dict_storage_class", "type": "flask", "text": " \ndict_storage_class  \nalias of werkzeug.datastructures.ImmutableMultiDict \n"}, {"name": "Request.environ", "path": "api/index#flask.Request.environ", "type": "flask", "text": " \nenviron: WSGIEnvironment  \nThe WSGI environment containing HTTP headers and information from the WSGI server. \n"}, {"name": "Request.form_data_parser_class", "path": "api/index#flask.Request.form_data_parser_class", "type": "flask", "text": " \nform_data_parser_class  \nalias of werkzeug.formparser.FormDataParser \n"}, {"name": "Request.from_values()", "path": "api/index#flask.Request.from_values", "type": "flask", "text": " \nclassmethod from_values(*args, **kwargs)  \nCreate a new request object based on the values provided. If environ is given missing values are filled from there. This method is useful for small scripts when you need to simulate a request from an URL. Do not use this method for unittesting, there is a full featured client object (Client) that allows to create multipart requests, support for cookies etc. This accepts the same options as the EnvironBuilder.  Changelog Changed in version 0.5: This method now accepts the same arguments as EnvironBuilder. Because of this the environ parameter is now called environ_overrides.   Returns \nrequest object  Parameters \n \nargs (Any) \u2013  \nkwargs (Any) \u2013    Return type \nwerkzeug.wrappers.request.Request   \n"}, {"name": "Request.get_data()", "path": "api/index#flask.Request.get_data", "type": "flask", "text": " \nget_data(cache=True, as_text=False, parse_form_data=False)  \nThis reads the buffered incoming data from the client into one bytes object. By default this is cached but that behavior can be changed by setting cache to False. Usually it\u2019s a bad idea to call this method without checking the content length first as a client could send dozens of megabytes or more to cause memory problems on the server. Note that if the form data was already parsed this method will not return anything as form data parsing does not cache the data like this method does. To implicitly invoke form data parsing function set parse_form_data to True. When this is done the return value of this method will be an empty string if the form parser handles the data. This generally is not necessary as if the whole data is cached (which is the default) the form parser will used the cached data to parse the form data. Please be generally aware of checking the content length first in any case before calling this method to avoid exhausting server memory. If as_text is set to True the return value will be a decoded string.  Changelog New in version 0.9.   Parameters \n \ncache (bool) \u2013  \nas_text (bool) \u2013  \nparse_form_data (bool) \u2013    Return type \nUnion[bytes, str]   \n"}, {"name": "Request.get_json()", "path": "api/index#flask.Request.get_json", "type": "flask", "text": " \nget_json(force=False, silent=False, cache=True)  \nParse data as JSON. If the mimetype does not indicate JSON (application/json, see is_json()), this returns None. If parsing fails, on_json_loading_failed() is called and its return value is used as the return value.  Parameters \n \nforce (bool) \u2013 Ignore the mimetype and always try to parse JSON. \nsilent (bool) \u2013 Silence parsing errors and return None instead. \ncache (bool) \u2013 Store the parsed JSON to return for subsequent calls.   Return type \nOptional[Any]   \n"}, {"name": "Request.headers", "path": "api/index#flask.Request.headers", "type": "flask", "text": " \nheaders  \nThe headers received with the request. \n"}, {"name": "Request.input_stream", "path": "api/index#flask.Request.input_stream", "type": "flask", "text": " \ninput_stream  \nThe WSGI input stream. In general it\u2019s a bad idea to use this one because you can easily read past the boundary. Use the stream instead. \n"}, {"name": "Request.is_multiprocess", "path": "api/index#flask.Request.is_multiprocess", "type": "flask", "text": " \nis_multiprocess  \nboolean that is True if the application is served by a WSGI server that spawns multiple processes. \n"}, {"name": "Request.is_multithread", "path": "api/index#flask.Request.is_multithread", "type": "flask", "text": " \nis_multithread  \nboolean that is True if the application is served by a multithreaded WSGI server. \n"}, {"name": "Request.is_run_once", "path": "api/index#flask.Request.is_run_once", "type": "flask", "text": " \nis_run_once  \nboolean that is True if the application will be executed only once in a process lifetime. This is the case for CGI for example, but it\u2019s not guaranteed that the execution only happens one time. \n"}, {"name": "Request.list_storage_class", "path": "api/index#flask.Request.list_storage_class", "type": "flask", "text": " \nlist_storage_class  \nalias of werkzeug.datastructures.ImmutableList \n"}, {"name": "Request.make_form_data_parser()", "path": "api/index#flask.Request.make_form_data_parser", "type": "flask", "text": " \nmake_form_data_parser()  \nCreates the form data parser. Instantiates the form_data_parser_class with some parameters.  Changelog New in version 0.8.   Return type \nwerkzeug.formparser.FormDataParser   \n"}, {"name": "Request.max_forwards", "path": "api/index#flask.Request.max_forwards", "type": "flask", "text": " \nmax_forwards  \nThe Max-Forwards request-header field provides a mechanism with the TRACE and OPTIONS methods to limit the number of proxies or gateways that can forward the request to the next inbound server. \n"}, {"name": "Request.method", "path": "api/index#flask.Request.method", "type": "flask", "text": " \nmethod  \nThe method the request was made with, such as GET. \n"}, {"name": "Request.on_json_loading_failed()", "path": "api/index#flask.Request.on_json_loading_failed", "type": "flask", "text": " \non_json_loading_failed(e)  \nCalled if get_json() parsing fails and isn\u2019t silenced. If this method returns a value, it is used as the return value for get_json(). The default implementation raises BadRequest.  Parameters \ne (Exception) \u2013   Return type \nNoReturn   \n"}, {"name": "Request.origin", "path": "api/index#flask.Request.origin", "type": "flask", "text": " \norigin  \nThe host that the request originated from. Set access_control_allow_origin on the response to indicate which origins are allowed. \n"}, {"name": "Request.parameter_storage_class", "path": "api/index#flask.Request.parameter_storage_class", "type": "flask", "text": " \nparameter_storage_class  \nalias of werkzeug.datastructures.ImmutableMultiDict \n"}, {"name": "Request.path", "path": "api/index#flask.Request.path", "type": "flask", "text": " \npath  \nThe path part of the URL after root_path. This is the path used for routing within the application. \n"}, {"name": "Request.query_string", "path": "api/index#flask.Request.query_string", "type": "flask", "text": " \nquery_string  \nThe part of the URL after the \u201c?\u201d. This is the raw value, use args for the parsed values. \n"}, {"name": "Request.referrer", "path": "api/index#flask.Request.referrer", "type": "flask", "text": " \nreferrer  \nThe Referer[sic] request-header field allows the client to specify, for the server\u2019s benefit, the address (URI) of the resource from which the Request-URI was obtained (the \u201creferrer\u201d, although the header field is misspelled). \n"}, {"name": "Request.remote_addr", "path": "api/index#flask.Request.remote_addr", "type": "flask", "text": " \nremote_addr  \nThe address of the client sending the request. \n"}, {"name": "Request.remote_user", "path": "api/index#flask.Request.remote_user", "type": "flask", "text": " \nremote_user  \nIf the server supports user authentication, and the script is protected, this attribute contains the username the user has authenticated as. \n"}, {"name": "Request.root_path", "path": "api/index#flask.Request.root_path", "type": "flask", "text": " \nroot_path  \nThe prefix that the application is mounted under, without a trailing slash. path comes after this. \n"}, {"name": "Request.routing_exception", "path": "api/index#flask.Request.routing_exception", "type": "flask", "text": " \nrouting_exception: Optional[Exception] = None  \nIf matching the URL failed, this is the exception that will be raised / was raised as part of the request handling. This is usually a NotFound exception or something similar. \n"}, {"name": "Request.scheme", "path": "api/index#flask.Request.scheme", "type": "flask", "text": " \nscheme  \nThe URL scheme of the protocol the request used, such as https or wss. \n"}, {"name": "Request.server", "path": "api/index#flask.Request.server", "type": "flask", "text": " \nserver  \nThe address of the server. (host, port), (path, None) for unix sockets, or None if not known. \n"}, {"name": "Request.shallow", "path": "api/index#flask.Request.shallow", "type": "flask", "text": " \nshallow: bool  \nSet when creating the request object. If True, reading from the request body will cause a RuntimeException. Useful to prevent modifying the stream from middleware. \n"}, {"name": "Request.url_rule", "path": "api/index#flask.Request.url_rule", "type": "flask", "text": " \nurl_rule: Optional[Rule] = None  \nThe internal URL rule that matched the request. This can be useful to inspect which methods are allowed for the URL from a before/after handler (request.url_rule.methods) etc. Though if the request\u2019s method was invalid for the URL rule, the valid list is available in routing_exception.valid_methods instead (an attribute of the Werkzeug exception MethodNotAllowed) because the request was never internally bound.  Changelog New in version 0.6.  \n\n"}, {"name": "Request.user_agent_class", "path": "api/index#flask.Request.user_agent_class", "type": "flask", "text": " \nuser_agent_class  \nalias of werkzeug.useragents._UserAgent \n"}, {"name": "Request.view_args", "path": "api/index#flask.Request.view_args", "type": "flask", "text": " \nview_args: Optional[Dict[str, Any]] = None  \nA dict of view arguments that matched the request. If an exception happened when matching, this will be None. \n"}, {"name": "RequestContext", "path": "api/index#flask.ctx.RequestContext", "type": "flask.ctx", "text": " \nclass flask.ctx.RequestContext(app, environ, request=None, session=None)  \nThe request context contains all request relevant information. It is created at the beginning of the request and pushed to the _request_ctx_stack and removed at the end of it. It will create the URL adapter and request object for the WSGI environment provided. Do not attempt to use this class directly, instead use test_request_context() and request_context() to create this object. When the request context is popped, it will evaluate all the functions registered on the application for teardown execution (teardown_request()). The request context is automatically popped at the end of the request for you. In debug mode the request context is kept around if exceptions happen so that interactive debuggers have a chance to introspect the data. With 0.4 this can also be forced for requests that did not fail and outside of DEBUG mode. By setting 'flask._preserve_context' to True on the WSGI environment the context will not pop itself at the end of the request. This is used by the test_client() for example to implement the deferred cleanup functionality. You might find this helpful for unittests where you need the information from the context local around for a little longer. Make sure to properly pop() the stack yourself in that situation, otherwise your unittests will leak memory.  Parameters \n \napp (Flask) \u2013  \nenviron (dict) \u2013  \nrequest (Optional[Request]) \u2013  \nsession (Optional[SessionMixin]) \u2013    Return type \nNone    \ncopy()  \nCreates a copy of this request context with the same request object. This can be used to move a request context to a different greenlet. Because the actual request object is the same this cannot be used to move a request context to a different thread unless access to the request object is locked.  Changelog Changed in version 1.1: The current session object is used instead of reloading the original data. This prevents flask.session pointing to an out-of-date object.   New in version 0.10.   Return type \nflask.ctx.RequestContext   \n  \nmatch_request()  \nCan be overridden by a subclass to hook into the matching of the request.  Return type \nNone   \n  \npop(exc=<object object>)  \nPops the request context and unbinds it by doing that. This will also trigger the execution of functions registered by the teardown_request() decorator.  Changelog Changed in version 0.9: Added the exc argument.   Parameters \nexc (Optional[BaseException]) \u2013   Return type \nNone   \n  \npush()  \nBinds the request context to the current context.  Return type \nNone   \n \n"}, {"name": "RequestContext.copy()", "path": "api/index#flask.ctx.RequestContext.copy", "type": "flask.ctx", "text": " \ncopy()  \nCreates a copy of this request context with the same request object. This can be used to move a request context to a different greenlet. Because the actual request object is the same this cannot be used to move a request context to a different thread unless access to the request object is locked.  Changelog Changed in version 1.1: The current session object is used instead of reloading the original data. This prevents flask.session pointing to an out-of-date object.   New in version 0.10.   Return type \nflask.ctx.RequestContext   \n"}, {"name": "RequestContext.match_request()", "path": "api/index#flask.ctx.RequestContext.match_request", "type": "flask.ctx", "text": " \nmatch_request()  \nCan be overridden by a subclass to hook into the matching of the request.  Return type \nNone   \n"}, {"name": "RequestContext.pop()", "path": "api/index#flask.ctx.RequestContext.pop", "type": "flask.ctx", "text": " \npop(exc=<object object>)  \nPops the request context and unbinds it by doing that. This will also trigger the execution of functions registered by the teardown_request() decorator.  Changelog Changed in version 0.9: Added the exc argument.   Parameters \nexc (Optional[BaseException]) \u2013   Return type \nNone   \n"}, {"name": "RequestContext.push()", "path": "api/index#flask.ctx.RequestContext.push", "type": "flask.ctx", "text": " \npush()  \nBinds the request context to the current context.  Return type \nNone   \n"}, {"name": "Response", "path": "api/index#flask.Response", "type": "flask", "text": " \nclass flask.Response(response=None, status=None, headers=None, mimetype=None, content_type=None, direct_passthrough=False)  \nThe response object that is used by default in Flask. Works like the response object from Werkzeug but is set to have an HTML mimetype by default. Quite often you don\u2019t have to create this object yourself because make_response() will take care of that for you. If you want to replace the response object used you can subclass this and set response_class to your subclass.  Changelog Changed in version 1.0: JSON support is added to the response, like the request. This is useful when testing to get the test client response data as JSON.   Changed in version 1.0: Added max_cookie_size.   Parameters \n \nresponse (Union[Iterable[str], Iterable[bytes]]) \u2013  \nstatus (Optional[Union[int, str, http.HTTPStatus]]) \u2013  \nheaders (werkzeug.datastructures.Headers) \u2013  \nmimetype (Optional[str]) \u2013  \ncontent_type (Optional[str]) \u2013  \ndirect_passthrough (bool) \u2013    Return type \nNone    \naccept_ranges  \nThe Accept-Ranges header. Even though the name would indicate that multiple values are supported, it must be one string token only. The values 'bytes' and 'none' are common.  Changelog New in version 0.7.  \n\n  \nproperty access_control_allow_credentials: bool  \nWhether credentials can be shared by the browser to JavaScript code. As part of the preflight request it indicates whether credentials can be used on the cross origin request. \n  \naccess_control_allow_headers  \nWhich headers can be sent with the cross origin request. \n  \naccess_control_allow_methods  \nWhich methods can be used for the cross origin request. \n  \naccess_control_allow_origin  \nThe origin or \u2018*\u2019 for any origin that may make cross origin requests. \n  \naccess_control_expose_headers  \nWhich headers can be shared by the browser to JavaScript code. \n  \naccess_control_max_age  \nThe maximum age in seconds the access control settings can be cached for. \n  \nadd_etag(overwrite=False, weak=False)  \nAdd an etag for the current response if there is none yet.  Changed in version 2.0: SHA-1 is used to generate the value. MD5 may not be available in some environments.   Parameters \n \noverwrite (bool) \u2013  \nweak (bool) \u2013    Return type \nNone   \n  \nage  \nThe Age response-header field conveys the sender\u2019s estimate of the amount of time since the response (or its revalidation) was generated at the origin server. Age values are non-negative decimal integers, representing time in seconds. \n  \nproperty allow: werkzeug.datastructures.HeaderSet  \nThe Allow entity-header field lists the set of methods supported by the resource identified by the Request-URI. The purpose of this field is strictly to inform the recipient of valid methods associated with the resource. An Allow header field MUST be present in a 405 (Method Not Allowed) response. \n  \nproperty cache_control: werkzeug.datastructures.ResponseCacheControl  \nThe Cache-Control general-header field is used to specify directives that MUST be obeyed by all caching mechanisms along the request/response chain. \n  \ncalculate_content_length()  \nReturns the content length if available or None otherwise.  Return type \nOptional[int]   \n  \ncall_on_close(func)  \nAdds a function to the internal list of functions that should be called as part of closing down the response. Since 0.7 this function also returns the function that was passed so that this can be used as a decorator.  Changelog New in version 0.6.   Parameters \nfunc (Callable[[], Any]) \u2013   Return type \nCallable[[], Any]   \n  \nclose()  \nClose the wrapped response if possible. You can also use the object in a with statement which will automatically close it.  Changelog New in version 0.9: Can now be used in a with statement.   Return type \nNone   \n  \ncontent_encoding  \nThe Content-Encoding entity-header field is used as a modifier to the media-type. When present, its value indicates what additional content codings have been applied to the entity-body, and thus what decoding mechanisms must be applied in order to obtain the media-type referenced by the Content-Type header field. \n  \nproperty content_language: werkzeug.datastructures.HeaderSet  \nThe Content-Language entity-header field describes the natural language(s) of the intended audience for the enclosed entity. Note that this might not be equivalent to all the languages used within the entity-body. \n  \ncontent_length  \nThe Content-Length entity-header field indicates the size of the entity-body, in decimal number of OCTETs, sent to the recipient or, in the case of the HEAD method, the size of the entity-body that would have been sent had the request been a GET. \n  \ncontent_location  \nThe Content-Location entity-header field MAY be used to supply the resource location for the entity enclosed in the message when that entity is accessible from a location separate from the requested resource\u2019s URI. \n  \ncontent_md5  \nThe Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest of the entity-body for the purpose of providing an end-to-end message integrity check (MIC) of the entity-body. (Note: a MIC is good for detecting accidental modification of the entity-body in transit, but is not proof against malicious attacks.) \n  \nproperty content_range: werkzeug.datastructures.ContentRange  \nThe Content-Range header as a ContentRange object. Available even if the header is not set.  Changelog New in version 0.7.  \n\n  \ncontent_security_policy  \nThe Content-Security-Policy header adds an additional layer of security to help detect and mitigate certain types of attacks. \n  \ncontent_security_policy_report_only  \nThe Content-Security-Policy-Report-Only header adds a csp policy that is not enforced but is reported thereby helping detect certain types of attacks. \n  \ncontent_type  \nThe Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of the HEAD method, the media type that would have been sent had the request been a GET. \n  \ncross_origin_embedder_policy  \nPrevents a document from loading any cross-origin resources that do not explicitly grant the document permission. Values must be a member of the werkzeug.http.COEP enum. \n  \ncross_origin_opener_policy  \nAllows control over sharing of browsing context group with cross-origin documents. Values must be a member of the werkzeug.http.COOP enum. \n  \nproperty data: Union[bytes, str]  \nA descriptor that calls get_data() and set_data(). \n  \ndate  \nThe Date general-header field represents the date and time at which the message was originated, having the same semantics as orig-date in RFC 822.  Changed in version 2.0: The datetime object is timezone-aware.  \n  \ndelete_cookie(key, path='/', domain=None, secure=False, httponly=False, samesite=None)  \nDelete a cookie. Fails silently if key doesn\u2019t exist.  Parameters \n \nkey (str) \u2013 the key (name) of the cookie to be deleted. \npath (str) \u2013 if the cookie that should be deleted was limited to a path, the path has to be defined here. \ndomain (Optional[str]) \u2013 if the cookie that should be deleted was limited to a domain, that domain has to be defined here. \nsecure (bool) \u2013 If True, the cookie will only be available via HTTPS. \nhttponly (bool) \u2013 Disallow JavaScript access to the cookie. \nsamesite (Optional[str]) \u2013 Limit the scope of the cookie to only be attached to requests that are \u201csame-site\u201d.   Return type \nNone   \n  \ndirect_passthrough  \nPass the response body directly through as the WSGI iterable. This can be used when the body is a binary file or other iterator of bytes, to skip some unnecessary checks. Use send_file() instead of setting this manually. \n  \nexpires  \nThe Expires entity-header field gives the date/time after which the response is considered stale. A stale cache entry may not normally be returned by a cache.  Changed in version 2.0: The datetime object is timezone-aware.  \n  \nclassmethod force_type(response, environ=None)  \nEnforce that the WSGI response is a response object of the current type. Werkzeug will use the Response internally in many situations like the exceptions. If you call get_response() on an exception you will get back a regular Response object, even if you are using a custom subclass. This method can enforce a given response type, and it will also convert arbitrary WSGI callables into response objects if an environ is provided: # convert a Werkzeug response object into an instance of the\n# MyResponseClass subclass.\nresponse = MyResponseClass.force_type(response)\n\n# convert any WSGI application into a response object\nresponse = MyResponseClass.force_type(response, environ)\n This is especially useful if you want to post-process responses in the main dispatcher and use functionality provided by your subclass. Keep in mind that this will modify response objects in place if possible!  Parameters \n \nresponse (Response) \u2013 a response object or wsgi application. \nenviron (Optional[WSGIEnvironment]) \u2013 a WSGI environment object.   Returns \na response object.  Return type \nResponse   \n  \nfreeze(no_etag=None)  \nMake the response object ready to be pickled. Does the following:  Buffer the response into a list, ignoring implicity_sequence_conversion and direct_passthrough. Set the Content-Length header. Generate an ETag header if one is not already set.   Changed in version 2.0: An ETag header is added, the no_etag parameter is deprecated and will be removed in Werkzeug 2.1.   Changelog Changed in version 0.6: The Content-Length header is set.   Parameters \nno_etag (None) \u2013   Return type \nNone   \n  \nclassmethod from_app(app, environ, buffered=False)  \nCreate a new response object from an application output. This works best if you pass it an application that returns a generator all the time. Sometimes applications may use the write() callable returned by the start_response function. This tries to resolve such edge cases automatically. But if you don\u2019t get the expected output you should set buffered to True which enforces buffering.  Parameters \n \napp (WSGIApplication) \u2013 the WSGI application to execute. \nenviron (WSGIEnvironment) \u2013 the WSGI environment to execute against. \nbuffered (bool) \u2013 set to True to enforce buffering.   Returns \na response object.  Return type \nResponse   \n  \nget_app_iter(environ)  \nReturns the application iterator for the given environ. Depending on the request method and the current status code the return value might be an empty response rather than the one from the response. If the request method is HEAD or the status code is in a range where the HTTP specification requires an empty response, an empty iterable is returned.  Changelog New in version 0.6.   Parameters \nenviron (WSGIEnvironment) \u2013 the WSGI environment of the request.  Returns \na response iterable.  Return type \nIterable[bytes]   \n  \nget_data(as_text=False)  \nThe string representation of the response body. Whenever you call this property the response iterable is encoded and flattened. This can lead to unwanted behavior if you stream big data. This behavior can be disabled by setting implicit_sequence_conversion to False. If as_text is set to True the return value will be a decoded string.  Changelog New in version 0.9.   Parameters \nas_text (bool) \u2013   Return type \nUnion[bytes, str]   \n  \nget_etag()  \nReturn a tuple in the form (etag, is_weak). If there is no ETag the return value is (None, None).  Return type \nUnion[Tuple[str, bool], Tuple[None, None]]   \n  \nget_json(force=False, silent=False)  \nParse data as JSON. Useful during testing. If the mimetype does not indicate JSON (application/json, see is_json()), this returns None. Unlike Request.get_json(), the result is not cached.  Parameters \n \nforce (bool) \u2013 Ignore the mimetype and always try to parse JSON. \nsilent (bool) \u2013 Silence parsing errors and return None instead.   Return type \nOptional[Any]   \n  \nget_wsgi_headers(environ)  \nThis is automatically called right before the response is started and returns headers modified for the given environment. It returns a copy of the headers from the response with some modifications applied if necessary. For example the location header (if present) is joined with the root URL of the environment. Also the content length is automatically set to zero here for certain status codes.  Changelog Changed in version 0.6: Previously that function was called fix_headers and modified the response object in place. Also since 0.6, IRIs in location and content-location headers are handled properly. Also starting with 0.6, Werkzeug will attempt to set the content length if it is able to figure it out on its own. This is the case if all the strings in the response iterable are already encoded and the iterable is buffered.   Parameters \nenviron (WSGIEnvironment) \u2013 the WSGI environment of the request.  Returns \nreturns a new Headers object.  Return type \nwerkzeug.datastructures.Headers   \n  \nget_wsgi_response(environ)  \nReturns the final WSGI response as tuple. The first item in the tuple is the application iterator, the second the status and the third the list of headers. The response returned is created specially for the given environment. For example if the request method in the WSGI environment is 'HEAD' the response will be empty and only the headers and status code will be present.  Changelog New in version 0.6.   Parameters \nenviron (WSGIEnvironment) \u2013 the WSGI environment of the request.  Returns \nan (app_iter, status, headers) tuple.  Return type \nTuple[Iterable[bytes], str, List[Tuple[str, str]]]   \n  \nproperty is_json: bool  \nCheck if the mimetype indicates JSON data, either application/json or application/*+json. \n  \nproperty is_sequence: bool  \nIf the iterator is buffered, this property will be True. A response object will consider an iterator to be buffered if the response attribute is a list or tuple.  Changelog New in version 0.6.  \n\n  \nproperty is_streamed: bool  \nIf the response is streamed (the response is not an iterable with a length information) this property is True. In this case streamed means that there is no information about the number of iterations. This is usually True if a generator is passed to the response object. This is useful for checking before applying some sort of post filtering that should not take place for streamed responses. \n  \niter_encoded()  \nIter the response encoded with the encoding of the response. If the response object is invoked as WSGI application the return value of this method is used as application iterator unless direct_passthrough was activated.  Return type \nIterator[bytes]   \n  \nproperty json: Optional[Any]  \nThe parsed JSON data if mimetype indicates JSON (application/json, see is_json()). Calls get_json() with default arguments. \n  \nlast_modified  \nThe Last-Modified entity-header field indicates the date and time at which the origin server believes the variant was last modified.  Changed in version 2.0: The datetime object is timezone-aware.  \n  \nlocation  \nThe Location response-header field is used to redirect the recipient to a location other than the Request-URI for completion of the request or identification of a new resource. \n  \nmake_conditional(request_or_environ, accept_ranges=False, complete_length=None)  \nMake the response conditional to the request. This method works best if an etag was defined for the response already. The add_etag method can be used to do that. If called without etag just the date header is set. This does nothing if the request method in the request or environ is anything but GET or HEAD. For optimal performance when handling range requests, it\u2019s recommended that your response data object implements seekable, seek and tell methods as described by io.IOBase. Objects returned by wrap_file() automatically implement those methods. It does not remove the body of the response because that\u2019s something the __call__() function does for us automatically. Returns self so that you can do return resp.make_conditional(req) but modifies the object in-place.  Parameters \n \nrequest_or_environ (WSGIEnvironment) \u2013 a request object or WSGI environment to be used to make the response conditional against. \naccept_ranges (Union[bool, str]) \u2013 This parameter dictates the value of Accept-Ranges header. If False (default), the header is not set. If True, it will be set to \"bytes\". If None, it will be set to \"none\". If it\u2019s a string, it will use this value. \ncomplete_length (Optional[int]) \u2013 Will be used only in valid Range Requests. It will set Content-Range complete length value and compute Content-Length real value. This parameter is mandatory for successful Range Requests completion.   Raises \nRequestedRangeNotSatisfiable if Range header could not be parsed or satisfied.  Return type \nResponse    Changed in version 2.0: Range processing is skipped if length is 0 instead of raising a 416 Range Not Satisfiable error.  \n  \nmake_sequence()  \nConverts the response iterator in a list. By default this happens automatically if required. If implicit_sequence_conversion is disabled, this method is not automatically called and some properties might raise exceptions. This also encodes all the items.  Changelog New in version 0.6.   Return type \nNone   \n  \nproperty max_cookie_size: int  \nRead-only view of the MAX_COOKIE_SIZE config key. See max_cookie_size in Werkzeug\u2019s docs. \n  \nproperty mimetype: Optional[str]  \nThe mimetype (content type without charset etc.) \n  \nproperty mimetype_params: Dict[str, str]  \nThe mimetype parameters as dict. For example if the content type is text/html; charset=utf-8 the params would be {'charset': 'utf-8'}.  Changelog New in version 0.5.  \n\n  \nproperty retry_after: Optional[datetime.datetime]  \nThe Retry-After response-header field can be used with a 503 (Service Unavailable) response to indicate how long the service is expected to be unavailable to the requesting client. Time in seconds until expiration or date.  Changed in version 2.0: The datetime object is timezone-aware.  \n  \nset_cookie(key, value='', max_age=None, expires=None, path='/', domain=None, secure=False, httponly=False, samesite=None)  \nSets a cookie. A warning is raised if the size of the cookie header exceeds max_cookie_size, but the header will still be set.  Parameters \n \nkey (str) \u2013 the key (name) of the cookie to be set. \nvalue (str) \u2013 the value of the cookie. \nmax_age (Optional[Union[datetime.timedelta, int]]) \u2013 should be a number of seconds, or None (default) if the cookie should last only as long as the client\u2019s browser session. \nexpires (Optional[Union[str, datetime.datetime, int, float]]) \u2013 should be a datetime object or UNIX timestamp. \npath (Optional[str]) \u2013 limits the cookie to a given path, per default it will span the whole domain. \ndomain (Optional[str]) \u2013 if you want to set a cross-domain cookie. For example, domain=\".example.com\" will set a cookie that is readable by the domain www.example.com, foo.example.com etc. Otherwise, a cookie will only be readable by the domain that set it. \nsecure (bool) \u2013 If True, the cookie will only be available via HTTPS. \nhttponly (bool) \u2013 Disallow JavaScript access to the cookie. \nsamesite (Optional[str]) \u2013 Limit the scope of the cookie to only be attached to requests that are \u201csame-site\u201d.   Return type \nNone   \n  \nset_data(value)  \nSets a new string as response. The value must be a string or bytes. If a string is set it\u2019s encoded to the charset of the response (utf-8 by default).  Changelog New in version 0.9.   Parameters \nvalue (Union[bytes, str]) \u2013   Return type \nNone   \n  \nset_etag(etag, weak=False)  \nSet the etag, and override the old one if there was one.  Parameters \n \netag (str) \u2013  \nweak (bool) \u2013    Return type \nNone   \n  \nproperty status: str  \nThe HTTP status code as a string. \n  \nproperty status_code: int  \nThe HTTP status code as a number. \n  \nproperty stream: werkzeug.wrappers.response.ResponseStream  \nThe response iterable as write-only stream. \n  \nproperty vary: werkzeug.datastructures.HeaderSet  \nThe Vary field value indicates the set of request-header fields that fully determines, while the response is fresh, whether a cache is permitted to use the response to reply to a subsequent request without revalidation. \n  \nproperty www_authenticate: werkzeug.datastructures.WWWAuthenticate  \nThe WWW-Authenticate header in a parsed form. \n \n"}, {"name": "Response.accept_ranges", "path": "api/index#flask.Response.accept_ranges", "type": "flask", "text": " \naccept_ranges  \nThe Accept-Ranges header. Even though the name would indicate that multiple values are supported, it must be one string token only. The values 'bytes' and 'none' are common.  Changelog New in version 0.7.  \n\n"}, {"name": "Response.access_control_allow_headers", "path": "api/index#flask.Response.access_control_allow_headers", "type": "flask", "text": " \naccess_control_allow_headers  \nWhich headers can be sent with the cross origin request. \n"}, {"name": "Response.access_control_allow_methods", "path": "api/index#flask.Response.access_control_allow_methods", "type": "flask", "text": " \naccess_control_allow_methods  \nWhich methods can be used for the cross origin request. \n"}, {"name": "Response.access_control_allow_origin", "path": "api/index#flask.Response.access_control_allow_origin", "type": "flask", "text": " \naccess_control_allow_origin  \nThe origin or \u2018*\u2019 for any origin that may make cross origin requests. \n"}, {"name": "Response.access_control_expose_headers", "path": "api/index#flask.Response.access_control_expose_headers", "type": "flask", "text": " \naccess_control_expose_headers  \nWhich headers can be shared by the browser to JavaScript code. \n"}, {"name": "Response.access_control_max_age", "path": "api/index#flask.Response.access_control_max_age", "type": "flask", "text": " \naccess_control_max_age  \nThe maximum age in seconds the access control settings can be cached for. \n"}, {"name": "Response.add_etag()", "path": "api/index#flask.Response.add_etag", "type": "flask", "text": " \nadd_etag(overwrite=False, weak=False)  \nAdd an etag for the current response if there is none yet.  Changed in version 2.0: SHA-1 is used to generate the value. MD5 may not be available in some environments.   Parameters \n \noverwrite (bool) \u2013  \nweak (bool) \u2013    Return type \nNone   \n"}, {"name": "Response.age", "path": "api/index#flask.Response.age", "type": "flask", "text": " \nage  \nThe Age response-header field conveys the sender\u2019s estimate of the amount of time since the response (or its revalidation) was generated at the origin server. Age values are non-negative decimal integers, representing time in seconds. \n"}, {"name": "Response.calculate_content_length()", "path": "api/index#flask.Response.calculate_content_length", "type": "flask", "text": " \ncalculate_content_length()  \nReturns the content length if available or None otherwise.  Return type \nOptional[int]   \n"}, {"name": "Response.call_on_close()", "path": "api/index#flask.Response.call_on_close", "type": "flask", "text": " \ncall_on_close(func)  \nAdds a function to the internal list of functions that should be called as part of closing down the response. Since 0.7 this function also returns the function that was passed so that this can be used as a decorator.  Changelog New in version 0.6.   Parameters \nfunc (Callable[[], Any]) \u2013   Return type \nCallable[[], Any]   \n"}, {"name": "Response.close()", "path": "api/index#flask.Response.close", "type": "flask", "text": " \nclose()  \nClose the wrapped response if possible. You can also use the object in a with statement which will automatically close it.  Changelog New in version 0.9: Can now be used in a with statement.   Return type \nNone   \n"}, {"name": "Response.content_encoding", "path": "api/index#flask.Response.content_encoding", "type": "flask", "text": " \ncontent_encoding  \nThe Content-Encoding entity-header field is used as a modifier to the media-type. When present, its value indicates what additional content codings have been applied to the entity-body, and thus what decoding mechanisms must be applied in order to obtain the media-type referenced by the Content-Type header field. \n"}, {"name": "Response.content_length", "path": "api/index#flask.Response.content_length", "type": "flask", "text": " \ncontent_length  \nThe Content-Length entity-header field indicates the size of the entity-body, in decimal number of OCTETs, sent to the recipient or, in the case of the HEAD method, the size of the entity-body that would have been sent had the request been a GET. \n"}, {"name": "Response.content_location", "path": "api/index#flask.Response.content_location", "type": "flask", "text": " \ncontent_location  \nThe Content-Location entity-header field MAY be used to supply the resource location for the entity enclosed in the message when that entity is accessible from a location separate from the requested resource\u2019s URI. \n"}, {"name": "Response.content_md5", "path": "api/index#flask.Response.content_md5", "type": "flask", "text": " \ncontent_md5  \nThe Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest of the entity-body for the purpose of providing an end-to-end message integrity check (MIC) of the entity-body. (Note: a MIC is good for detecting accidental modification of the entity-body in transit, but is not proof against malicious attacks.) \n"}, {"name": "Response.content_security_policy", "path": "api/index#flask.Response.content_security_policy", "type": "flask", "text": " \ncontent_security_policy  \nThe Content-Security-Policy header adds an additional layer of security to help detect and mitigate certain types of attacks. \n"}, {"name": "Response.content_security_policy_report_only", "path": "api/index#flask.Response.content_security_policy_report_only", "type": "flask", "text": " \ncontent_security_policy_report_only  \nThe Content-Security-Policy-Report-Only header adds a csp policy that is not enforced but is reported thereby helping detect certain types of attacks. \n"}, {"name": "Response.content_type", "path": "api/index#flask.Response.content_type", "type": "flask", "text": " \ncontent_type  \nThe Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of the HEAD method, the media type that would have been sent had the request been a GET. \n"}, {"name": "Response.cross_origin_embedder_policy", "path": "api/index#flask.Response.cross_origin_embedder_policy", "type": "flask", "text": " \ncross_origin_embedder_policy  \nPrevents a document from loading any cross-origin resources that do not explicitly grant the document permission. Values must be a member of the werkzeug.http.COEP enum. \n"}, {"name": "Response.cross_origin_opener_policy", "path": "api/index#flask.Response.cross_origin_opener_policy", "type": "flask", "text": " \ncross_origin_opener_policy  \nAllows control over sharing of browsing context group with cross-origin documents. Values must be a member of the werkzeug.http.COOP enum. \n"}, {"name": "Response.date", "path": "api/index#flask.Response.date", "type": "flask", "text": " \ndate  \nThe Date general-header field represents the date and time at which the message was originated, having the same semantics as orig-date in RFC 822.  Changed in version 2.0: The datetime object is timezone-aware.  \n"}, {"name": "Response.delete_cookie()", "path": "api/index#flask.Response.delete_cookie", "type": "flask", "text": " \ndelete_cookie(key, path='/', domain=None, secure=False, httponly=False, samesite=None)  \nDelete a cookie. Fails silently if key doesn\u2019t exist.  Parameters \n \nkey (str) \u2013 the key (name) of the cookie to be deleted. \npath (str) \u2013 if the cookie that should be deleted was limited to a path, the path has to be defined here. \ndomain (Optional[str]) \u2013 if the cookie that should be deleted was limited to a domain, that domain has to be defined here. \nsecure (bool) \u2013 If True, the cookie will only be available via HTTPS. \nhttponly (bool) \u2013 Disallow JavaScript access to the cookie. \nsamesite (Optional[str]) \u2013 Limit the scope of the cookie to only be attached to requests that are \u201csame-site\u201d.   Return type \nNone   \n"}, {"name": "Response.direct_passthrough", "path": "api/index#flask.Response.direct_passthrough", "type": "flask", "text": " \ndirect_passthrough  \nPass the response body directly through as the WSGI iterable. This can be used when the body is a binary file or other iterator of bytes, to skip some unnecessary checks. Use send_file() instead of setting this manually. \n"}, {"name": "Response.expires", "path": "api/index#flask.Response.expires", "type": "flask", "text": " \nexpires  \nThe Expires entity-header field gives the date/time after which the response is considered stale. A stale cache entry may not normally be returned by a cache.  Changed in version 2.0: The datetime object is timezone-aware.  \n"}, {"name": "Response.force_type()", "path": "api/index#flask.Response.force_type", "type": "flask", "text": " \nclassmethod force_type(response, environ=None)  \nEnforce that the WSGI response is a response object of the current type. Werkzeug will use the Response internally in many situations like the exceptions. If you call get_response() on an exception you will get back a regular Response object, even if you are using a custom subclass. This method can enforce a given response type, and it will also convert arbitrary WSGI callables into response objects if an environ is provided: # convert a Werkzeug response object into an instance of the\n# MyResponseClass subclass.\nresponse = MyResponseClass.force_type(response)\n\n# convert any WSGI application into a response object\nresponse = MyResponseClass.force_type(response, environ)\n This is especially useful if you want to post-process responses in the main dispatcher and use functionality provided by your subclass. Keep in mind that this will modify response objects in place if possible!  Parameters \n \nresponse (Response) \u2013 a response object or wsgi application. \nenviron (Optional[WSGIEnvironment]) \u2013 a WSGI environment object.   Returns \na response object.  Return type \nResponse   \n"}, {"name": "Response.freeze()", "path": "api/index#flask.Response.freeze", "type": "flask", "text": " \nfreeze(no_etag=None)  \nMake the response object ready to be pickled. Does the following:  Buffer the response into a list, ignoring implicity_sequence_conversion and direct_passthrough. Set the Content-Length header. Generate an ETag header if one is not already set.   Changed in version 2.0: An ETag header is added, the no_etag parameter is deprecated and will be removed in Werkzeug 2.1.   Changelog Changed in version 0.6: The Content-Length header is set.   Parameters \nno_etag (None) \u2013   Return type \nNone   \n"}, {"name": "Response.from_app()", "path": "api/index#flask.Response.from_app", "type": "flask", "text": " \nclassmethod from_app(app, environ, buffered=False)  \nCreate a new response object from an application output. This works best if you pass it an application that returns a generator all the time. Sometimes applications may use the write() callable returned by the start_response function. This tries to resolve such edge cases automatically. But if you don\u2019t get the expected output you should set buffered to True which enforces buffering.  Parameters \n \napp (WSGIApplication) \u2013 the WSGI application to execute. \nenviron (WSGIEnvironment) \u2013 the WSGI environment to execute against. \nbuffered (bool) \u2013 set to True to enforce buffering.   Returns \na response object.  Return type \nResponse   \n"}, {"name": "Response.get_app_iter()", "path": "api/index#flask.Response.get_app_iter", "type": "flask", "text": " \nget_app_iter(environ)  \nReturns the application iterator for the given environ. Depending on the request method and the current status code the return value might be an empty response rather than the one from the response. If the request method is HEAD or the status code is in a range where the HTTP specification requires an empty response, an empty iterable is returned.  Changelog New in version 0.6.   Parameters \nenviron (WSGIEnvironment) \u2013 the WSGI environment of the request.  Returns \na response iterable.  Return type \nIterable[bytes]   \n"}, {"name": "Response.get_data()", "path": "api/index#flask.Response.get_data", "type": "flask", "text": " \nget_data(as_text=False)  \nThe string representation of the response body. Whenever you call this property the response iterable is encoded and flattened. This can lead to unwanted behavior if you stream big data. This behavior can be disabled by setting implicit_sequence_conversion to False. If as_text is set to True the return value will be a decoded string.  Changelog New in version 0.9.   Parameters \nas_text (bool) \u2013   Return type \nUnion[bytes, str]   \n"}, {"name": "Response.get_etag()", "path": "api/index#flask.Response.get_etag", "type": "flask", "text": " \nget_etag()  \nReturn a tuple in the form (etag, is_weak). If there is no ETag the return value is (None, None).  Return type \nUnion[Tuple[str, bool], Tuple[None, None]]   \n"}, {"name": "Response.get_json()", "path": "api/index#flask.Response.get_json", "type": "flask", "text": " \nget_json(force=False, silent=False)  \nParse data as JSON. Useful during testing. If the mimetype does not indicate JSON (application/json, see is_json()), this returns None. Unlike Request.get_json(), the result is not cached.  Parameters \n \nforce (bool) \u2013 Ignore the mimetype and always try to parse JSON. \nsilent (bool) \u2013 Silence parsing errors and return None instead.   Return type \nOptional[Any]   \n"}, {"name": "Response.get_wsgi_headers()", "path": "api/index#flask.Response.get_wsgi_headers", "type": "flask", "text": " \nget_wsgi_headers(environ)  \nThis is automatically called right before the response is started and returns headers modified for the given environment. It returns a copy of the headers from the response with some modifications applied if necessary. For example the location header (if present) is joined with the root URL of the environment. Also the content length is automatically set to zero here for certain status codes.  Changelog Changed in version 0.6: Previously that function was called fix_headers and modified the response object in place. Also since 0.6, IRIs in location and content-location headers are handled properly. Also starting with 0.6, Werkzeug will attempt to set the content length if it is able to figure it out on its own. This is the case if all the strings in the response iterable are already encoded and the iterable is buffered.   Parameters \nenviron (WSGIEnvironment) \u2013 the WSGI environment of the request.  Returns \nreturns a new Headers object.  Return type \nwerkzeug.datastructures.Headers   \n"}, {"name": "Response.get_wsgi_response()", "path": "api/index#flask.Response.get_wsgi_response", "type": "flask", "text": " \nget_wsgi_response(environ)  \nReturns the final WSGI response as tuple. The first item in the tuple is the application iterator, the second the status and the third the list of headers. The response returned is created specially for the given environment. For example if the request method in the WSGI environment is 'HEAD' the response will be empty and only the headers and status code will be present.  Changelog New in version 0.6.   Parameters \nenviron (WSGIEnvironment) \u2013 the WSGI environment of the request.  Returns \nan (app_iter, status, headers) tuple.  Return type \nTuple[Iterable[bytes], str, List[Tuple[str, str]]]   \n"}, {"name": "Response.iter_encoded()", "path": "api/index#flask.Response.iter_encoded", "type": "flask", "text": " \niter_encoded()  \nIter the response encoded with the encoding of the response. If the response object is invoked as WSGI application the return value of this method is used as application iterator unless direct_passthrough was activated.  Return type \nIterator[bytes]   \n"}, {"name": "Response.last_modified", "path": "api/index#flask.Response.last_modified", "type": "flask", "text": " \nlast_modified  \nThe Last-Modified entity-header field indicates the date and time at which the origin server believes the variant was last modified.  Changed in version 2.0: The datetime object is timezone-aware.  \n"}, {"name": "Response.location", "path": "api/index#flask.Response.location", "type": "flask", "text": " \nlocation  \nThe Location response-header field is used to redirect the recipient to a location other than the Request-URI for completion of the request or identification of a new resource. \n"}, {"name": "Response.make_conditional()", "path": "api/index#flask.Response.make_conditional", "type": "flask", "text": " \nmake_conditional(request_or_environ, accept_ranges=False, complete_length=None)  \nMake the response conditional to the request. This method works best if an etag was defined for the response already. The add_etag method can be used to do that. If called without etag just the date header is set. This does nothing if the request method in the request or environ is anything but GET or HEAD. For optimal performance when handling range requests, it\u2019s recommended that your response data object implements seekable, seek and tell methods as described by io.IOBase. Objects returned by wrap_file() automatically implement those methods. It does not remove the body of the response because that\u2019s something the __call__() function does for us automatically. Returns self so that you can do return resp.make_conditional(req) but modifies the object in-place.  Parameters \n \nrequest_or_environ (WSGIEnvironment) \u2013 a request object or WSGI environment to be used to make the response conditional against. \naccept_ranges (Union[bool, str]) \u2013 This parameter dictates the value of Accept-Ranges header. If False (default), the header is not set. If True, it will be set to \"bytes\". If None, it will be set to \"none\". If it\u2019s a string, it will use this value. \ncomplete_length (Optional[int]) \u2013 Will be used only in valid Range Requests. It will set Content-Range complete length value and compute Content-Length real value. This parameter is mandatory for successful Range Requests completion.   Raises \nRequestedRangeNotSatisfiable if Range header could not be parsed or satisfied.  Return type \nResponse    Changed in version 2.0: Range processing is skipped if length is 0 instead of raising a 416 Range Not Satisfiable error.  \n"}, {"name": "Response.make_sequence()", "path": "api/index#flask.Response.make_sequence", "type": "flask", "text": " \nmake_sequence()  \nConverts the response iterator in a list. By default this happens automatically if required. If implicit_sequence_conversion is disabled, this method is not automatically called and some properties might raise exceptions. This also encodes all the items.  Changelog New in version 0.6.   Return type \nNone   \n"}, {"name": "Response.set_cookie()", "path": "api/index#flask.Response.set_cookie", "type": "flask", "text": " \nset_cookie(key, value='', max_age=None, expires=None, path='/', domain=None, secure=False, httponly=False, samesite=None)  \nSets a cookie. A warning is raised if the size of the cookie header exceeds max_cookie_size, but the header will still be set.  Parameters \n \nkey (str) \u2013 the key (name) of the cookie to be set. \nvalue (str) \u2013 the value of the cookie. \nmax_age (Optional[Union[datetime.timedelta, int]]) \u2013 should be a number of seconds, or None (default) if the cookie should last only as long as the client\u2019s browser session. \nexpires (Optional[Union[str, datetime.datetime, int, float]]) \u2013 should be a datetime object or UNIX timestamp. \npath (Optional[str]) \u2013 limits the cookie to a given path, per default it will span the whole domain. \ndomain (Optional[str]) \u2013 if you want to set a cross-domain cookie. For example, domain=\".example.com\" will set a cookie that is readable by the domain www.example.com, foo.example.com etc. Otherwise, a cookie will only be readable by the domain that set it. \nsecure (bool) \u2013 If True, the cookie will only be available via HTTPS. \nhttponly (bool) \u2013 Disallow JavaScript access to the cookie. \nsamesite (Optional[str]) \u2013 Limit the scope of the cookie to only be attached to requests that are \u201csame-site\u201d.   Return type \nNone   \n"}, {"name": "Response.set_data()", "path": "api/index#flask.Response.set_data", "type": "flask", "text": " \nset_data(value)  \nSets a new string as response. The value must be a string or bytes. If a string is set it\u2019s encoded to the charset of the response (utf-8 by default).  Changelog New in version 0.9.   Parameters \nvalue (Union[bytes, str]) \u2013   Return type \nNone   \n"}, {"name": "Response.set_etag()", "path": "api/index#flask.Response.set_etag", "type": "flask", "text": " \nset_etag(etag, weak=False)  \nSet the etag, and override the old one if there was one.  Parameters \n \netag (str) \u2013  \nweak (bool) \u2013    Return type \nNone   \n"}, {"name": "safe_join()", "path": "api/index#flask.safe_join", "type": "flask", "text": " \nflask.safe_join(directory, *pathnames)  \nSafely join zero or more untrusted path components to a base directory to avoid escaping the base directory.  Parameters \n \ndirectory (str) \u2013 The trusted base directory. \npathnames (str) \u2013 The untrusted path components relative to the base directory.   Returns \nA safe path, otherwise None.  Return type \nstr   \n"}, {"name": "ScriptInfo", "path": "api/index#flask.cli.ScriptInfo", "type": "flask.cli", "text": " \nclass flask.cli.ScriptInfo(app_import_path=None, create_app=None, set_debug_flag=True)  \nHelper object to deal with Flask applications. This is usually not necessary to interface with as it\u2019s used internally in the dispatching to click. In future versions of Flask this object will most likely play a bigger role. Typically it\u2019s created automatically by the FlaskGroup but you can also manually create it and pass it onwards as click object.  \napp_import_path  \nOptionally the import path for the Flask application. \n  \ncreate_app  \nOptionally a function that is passed the script info to create the instance of the application. \n  \ndata  \nA dictionary with arbitrary data that can be associated with this script info. \n  \nload_app()  \nLoads the Flask app (if not yet loaded) and returns it. Calling this multiple times will just result in the already loaded app to be returned. \n \n"}, {"name": "ScriptInfo.app_import_path", "path": "api/index#flask.cli.ScriptInfo.app_import_path", "type": "flask.cli", "text": " \napp_import_path  \nOptionally the import path for the Flask application. \n"}, {"name": "ScriptInfo.create_app", "path": "api/index#flask.cli.ScriptInfo.create_app", "type": "flask.cli", "text": " \ncreate_app  \nOptionally a function that is passed the script info to create the instance of the application. \n"}, {"name": "ScriptInfo.data", "path": "api/index#flask.cli.ScriptInfo.data", "type": "flask.cli", "text": " \ndata  \nA dictionary with arbitrary data that can be associated with this script info. \n"}, {"name": "ScriptInfo.load_app()", "path": "api/index#flask.cli.ScriptInfo.load_app", "type": "flask.cli", "text": " \nload_app()  \nLoads the Flask app (if not yet loaded) and returns it. Calling this multiple times will just result in the already loaded app to be returned. \n"}, {"name": "SECRET_KEY", "path": "config/index#SECRET_KEY", "type": "Configuration", "text": " \nSECRET_KEY  \nA secret key that will be used for securely signing the session cookie and can be used for any other security related needs by extensions or your application. It should be a long random bytes or str. For example, copy the output of this to your config: $ python -c 'import os; print(os.urandom(16))'\nb'_5#y2L\"F4Q8z\\n\\xec]/'\n Do not reveal the secret key when posting questions or committing code. Default: None \n"}, {"name": "SecureCookieSession", "path": "api/index#flask.sessions.SecureCookieSession", "type": "flask.sessions", "text": " \nclass flask.sessions.SecureCookieSession(initial=None)  \nBase class for sessions based on signed cookies. This session backend will set the modified and accessed attributes. It cannot reliably track whether a session is new (vs. empty), so new remains hard coded to False.  Parameters \ninitial (Any) \u2013   Return type \nNone    \naccessed = False  \nheader, which allows caching proxies to cache different pages for different users. \n  \nget(key, default=None)  \nReturn the value for key if key is in the dictionary, else default.  Parameters \n \nkey (str) \u2013  \ndefault (Optional[Any]) \u2013    Return type \nAny   \n  \nmodified = False  \nWhen data is changed, this is set to True. Only the session dictionary itself is tracked; if the session contains mutable data (for example a nested dict) then this must be set to True manually when modifying that data. The session cookie will only be written to the response if this is True. \n  \nsetdefault(key, default=None)  \nInsert key with a value of default if key is not in the dictionary. Return the value for key if key is in the dictionary, else default.  Parameters \n \nkey (str) \u2013  \ndefault (Optional[Any]) \u2013    Return type \nAny   \n \n"}, {"name": "SecureCookieSession.accessed", "path": "api/index#flask.sessions.SecureCookieSession.accessed", "type": "flask.sessions", "text": " \naccessed = False  \nheader, which allows caching proxies to cache different pages for different users. \n"}, {"name": "SecureCookieSession.get()", "path": "api/index#flask.sessions.SecureCookieSession.get", "type": "flask.sessions", "text": " \nget(key, default=None)  \nReturn the value for key if key is in the dictionary, else default.  Parameters \n \nkey (str) \u2013  \ndefault (Optional[Any]) \u2013    Return type \nAny   \n"}, {"name": "SecureCookieSession.modified", "path": "api/index#flask.sessions.SecureCookieSession.modified", "type": "flask.sessions", "text": " \nmodified = False  \nWhen data is changed, this is set to True. Only the session dictionary itself is tracked; if the session contains mutable data (for example a nested dict) then this must be set to True manually when modifying that data. The session cookie will only be written to the response if this is True. \n"}, {"name": "SecureCookieSession.setdefault()", "path": "api/index#flask.sessions.SecureCookieSession.setdefault", "type": "flask.sessions", "text": " \nsetdefault(key, default=None)  \nInsert key with a value of default if key is not in the dictionary. Return the value for key if key is in the dictionary, else default.  Parameters \n \nkey (str) \u2013  \ndefault (Optional[Any]) \u2013    Return type \nAny   \n"}, {"name": "SecureCookieSessionInterface", "path": "api/index#flask.sessions.SecureCookieSessionInterface", "type": "flask.sessions", "text": " \nclass flask.sessions.SecureCookieSessionInterface  \nThe default session interface that stores sessions in signed cookies through the itsdangerous module.  \nstatic digest_method()  \nthe hash function to use for the signature. The default is sha1 \n  \nkey_derivation = 'hmac'  \nthe name of the itsdangerous supported key derivation. The default is hmac. \n  \nopen_session(app, request)  \nThis method has to be implemented and must either return None in case the loading failed because of a configuration error or an instance of a session object which implements a dictionary like interface + the methods and attributes on SessionMixin.  Parameters \n \napp (Flask) \u2013  \nrequest (Request) \u2013    Return type \nOptional[flask.sessions.SecureCookieSession]   \n  \nsalt = 'cookie-session'  \nthe salt that should be applied on top of the secret key for the signing of cookie based sessions. \n  \nsave_session(app, session, response)  \nThis is called for actual sessions returned by open_session() at the end of the request. This is still called during a request context so if you absolutely need access to the request you can do that.  Parameters \n \napp (Flask) \u2013  \nsession (flask.sessions.SessionMixin) \u2013  \nresponse (Response) \u2013    Return type \nNone   \n  \nserializer = <flask.json.tag.TaggedJSONSerializer object>  \nA python serializer for the payload. The default is a compact JSON derived serializer with support for some extra Python types such as datetime objects or tuples. \n  \nsession_class  \nalias of flask.sessions.SecureCookieSession \n \n"}, {"name": "SecureCookieSessionInterface.digest_method()", "path": "api/index#flask.sessions.SecureCookieSessionInterface.digest_method", "type": "flask.sessions", "text": " \nstatic digest_method()  \nthe hash function to use for the signature. The default is sha1 \n"}, {"name": "SecureCookieSessionInterface.key_derivation", "path": "api/index#flask.sessions.SecureCookieSessionInterface.key_derivation", "type": "flask.sessions", "text": " \nkey_derivation = 'hmac'  \nthe name of the itsdangerous supported key derivation. The default is hmac. \n"}, {"name": "SecureCookieSessionInterface.open_session()", "path": "api/index#flask.sessions.SecureCookieSessionInterface.open_session", "type": "flask.sessions", "text": " \nopen_session(app, request)  \nThis method has to be implemented and must either return None in case the loading failed because of a configuration error or an instance of a session object which implements a dictionary like interface + the methods and attributes on SessionMixin.  Parameters \n \napp (Flask) \u2013  \nrequest (Request) \u2013    Return type \nOptional[flask.sessions.SecureCookieSession]   \n"}, {"name": "SecureCookieSessionInterface.salt", "path": "api/index#flask.sessions.SecureCookieSessionInterface.salt", "type": "flask.sessions", "text": " \nsalt = 'cookie-session'  \nthe salt that should be applied on top of the secret key for the signing of cookie based sessions. \n"}, {"name": "SecureCookieSessionInterface.save_session()", "path": "api/index#flask.sessions.SecureCookieSessionInterface.save_session", "type": "flask.sessions", "text": " \nsave_session(app, session, response)  \nThis is called for actual sessions returned by open_session() at the end of the request. This is still called during a request context so if you absolutely need access to the request you can do that.  Parameters \n \napp (Flask) \u2013  \nsession (flask.sessions.SessionMixin) \u2013  \nresponse (Response) \u2013    Return type \nNone   \n"}, {"name": "SecureCookieSessionInterface.serializer", "path": "api/index#flask.sessions.SecureCookieSessionInterface.serializer", "type": "flask.sessions", "text": " \nserializer = <flask.json.tag.TaggedJSONSerializer object>  \nA python serializer for the payload. The default is a compact JSON derived serializer with support for some extra Python types such as datetime objects or tuples. \n"}, {"name": "SecureCookieSessionInterface.session_class", "path": "api/index#flask.sessions.SecureCookieSessionInterface.session_class", "type": "flask.sessions", "text": " \nsession_class  \nalias of flask.sessions.SecureCookieSession \n"}, {"name": "Security Considerations", "path": "security/index", "type": "Additional Notes", "text": "Security Considerations Web applications usually face all kinds of security problems and it\u2019s very hard to get everything right. Flask tries to solve a few of these things for you, but there are a couple more you have to take care of yourself. Cross-Site Scripting (XSS) Cross site scripting is the concept of injecting arbitrary HTML (and with it JavaScript) into the context of a website. To remedy this, developers have to properly escape text so that it cannot include arbitrary HTML tags. For more information on that have a look at the Wikipedia article on Cross-Site Scripting. Flask configures Jinja2 to automatically escape all values unless explicitly told otherwise. This should rule out all XSS problems caused in templates, but there are still other places where you have to be careful:  generating HTML without the help of Jinja2 calling Markup on data submitted by users sending out HTML from uploaded files, never do that, use the Content-Disposition: attachment header to prevent that problem. sending out textfiles from uploaded files. Some browsers are using content-type guessing based on the first few bytes so users could trick a browser to execute HTML.  Another thing that is very important are unquoted attributes. While Jinja2 can protect you from XSS issues by escaping HTML, there is one thing it cannot protect you from: XSS by attribute injection. To counter this possible attack vector, be sure to always quote your attributes with either double or single quotes when using Jinja expressions in them: <input value=\"{{ value }}\">\n Why is this necessary? Because if you would not be doing that, an attacker could easily inject custom JavaScript handlers. For example an attacker could inject this piece of HTML+JavaScript: onmouseover=alert(document.cookie)\n When the user would then move with the mouse over the input, the cookie would be presented to the user in an alert window. But instead of showing the cookie to the user, a good attacker might also execute any other JavaScript code. In combination with CSS injections the attacker might even make the element fill out the entire page so that the user would just have to have the mouse anywhere on the page to trigger the attack. There is one class of XSS issues that Jinja\u2019s escaping does not protect against. The a tag\u2019s href attribute can contain a javascript: URI, which the browser will execute when clicked if not secured properly. <a href=\"{{ value }}\">click here</a>\n<a href=\"javascript:alert('unsafe');\">click here</a>\n To prevent this, you\u2019ll need to set the Content Security Policy (CSP) response header. Cross-Site Request Forgery (CSRF) Another big problem is CSRF. This is a very complex topic and I won\u2019t outline it here in detail just mention what it is and how to theoretically prevent it. If your authentication information is stored in cookies, you have implicit state management. The state of \u201cbeing logged in\u201d is controlled by a cookie, and that cookie is sent with each request to a page. Unfortunately that includes requests triggered by 3rd party sites. If you don\u2019t keep that in mind, some people might be able to trick your application\u2019s users with social engineering to do stupid things without them knowing. Say you have a specific URL that, when you sent POST requests to will delete a user\u2019s profile (say http://example.com/user/delete). If an attacker now creates a page that sends a post request to that page with some JavaScript they just have to trick some users to load that page and their profiles will end up being deleted. Imagine you were to run Facebook with millions of concurrent users and someone would send out links to images of little kittens. When users would go to that page, their profiles would get deleted while they are looking at images of fluffy cats. How can you prevent that? Basically for each request that modifies content on the server you would have to either use a one-time token and store that in the cookie and also transmit it with the form data. After receiving the data on the server again, you would then have to compare the two tokens and ensure they are equal. Why does Flask not do that for you? The ideal place for this to happen is the form validation framework, which does not exist in Flask. JSON Security In Flask 0.10 and lower, jsonify() did not serialize top-level arrays to JSON. This was because of a security vulnerability in ECMAScript 4. ECMAScript 5 closed this vulnerability, so only extremely old browsers are still vulnerable. All of these browsers have other more serious vulnerabilities, so this behavior was changed and jsonify() now supports serializing arrays. Security Headers Browsers recognize various response headers in order to control security. We recommend reviewing each of the headers below for use in your application. The Flask-Talisman extension can be used to manage HTTPS and the security headers for you. HTTP Strict Transport Security (HSTS) Tells the browser to convert all HTTP requests to HTTPS, preventing man-in-the-middle (MITM) attacks. response.headers['Strict-Transport-Security'] = 'max-age=31536000; includeSubDomains'\n  https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security  Content Security Policy (CSP) Tell the browser where it can load various types of resource from. This header should be used whenever possible, but requires some work to define the correct policy for your site. A very strict policy would be: response.headers['Content-Security-Policy'] = \"default-src 'self'\"\n  https://csp.withgoogle.com/docs/index.html https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy  X-Content-Type-Options Forces the browser to honor the response content type instead of trying to detect it, which can be abused to generate a cross-site scripting (XSS) attack. response.headers['X-Content-Type-Options'] = 'nosniff'\n  https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Content-Type-Options  X-Frame-Options Prevents external sites from embedding your site in an iframe. This prevents a class of attacks where clicks in the outer frame can be translated invisibly to clicks on your page\u2019s elements. This is also known as \u201cclickjacking\u201d. response.headers['X-Frame-Options'] = 'SAMEORIGIN'\n  https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options  X-XSS-Protection The browser will try to prevent reflected XSS attacks by not loading the page if the request contains something that looks like JavaScript and the response contains the same data. response.headers['X-XSS-Protection'] = '1; mode=block'\n  https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-XSS-Protection  Set-Cookie options These options can be added to a Set-Cookie header to improve their security. Flask has configuration options to set these on the session cookie. They can be set on other cookies too.  \nSecure limits cookies to HTTPS traffic only. \nHttpOnly protects the contents of cookies from being read with JavaScript. \nSameSite restricts how cookies are sent with requests from external sites. Can be set to 'Lax' (recommended) or 'Strict'. Lax prevents sending cookies with CSRF-prone requests from external sites, such as submitting a form. Strict prevents sending cookies with all external requests, including following regular links.  app.config.update(\n    SESSION_COOKIE_SECURE=True,\n    SESSION_COOKIE_HTTPONLY=True,\n    SESSION_COOKIE_SAMESITE='Lax',\n)\n\nresponse.set_cookie('username', 'flask', secure=True, httponly=True, samesite='Lax')\n Specifying Expires or Max-Age options, will remove the cookie after the given time, or the current time plus the age, respectively. If neither option is set, the cookie will be removed when the browser is closed. # cookie expires after 10 minutes\nresponse.set_cookie('snakes', '3', max_age=600)\n For the session cookie, if session.permanent is set, then PERMANENT_SESSION_LIFETIME is used to set the expiration. Flask\u2019s default cookie implementation validates that the cryptographic signature is not older than this value. Lowering this value may help mitigate replay attacks, where intercepted cookies can be sent at a later time. app.config.update(\n    PERMANENT_SESSION_LIFETIME=600\n)\n\n@app.route('/login', methods=['POST'])\ndef login():\n    ...\n    session.clear()\n    session['user_id'] = user.id\n    session.permanent = True\n    ...\n Use itsdangerous.TimedSerializer to sign and validate other cookie values (or any values that need secure signatures).  https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie  HTTP Public Key Pinning (HPKP) This tells the browser to authenticate with the server using only the specific certificate key to prevent MITM attacks.  Warning Be careful when enabling this, as it is very difficult to undo if you set up or upgrade your key incorrectly.   https://developer.mozilla.org/en-US/docs/Web/HTTP/Public_Key_Pinning  Copy/Paste to Terminal Hidden characters such as the backspace character (\\b, ^H) can cause text to render differently in HTML than how it is interpreted if pasted into a terminal. For example, import y\\bose\\bm\\bi\\bt\\be\\b renders as import yosemite in HTML, but the backspaces are applied when pasted into a terminal, and it becomes import os. If you expect users to copy and paste untrusted code from your site, such as from comments posted by users on a technical blog, consider applying extra filtering, such as replacing all \\b characters. body = body.replace(\"\\b\", \"\")\n Most modern terminals will warn about and remove hidden characters when pasting, so this isn\u2019t strictly necessary. It\u2019s also possible to craft dangerous commands in other ways that aren\u2019t possible to filter. Depending on your site\u2019s use case, it may be good to show a warning about copying code in general.\n"}, {"name": "send_file()", "path": "api/index#flask.send_file", "type": "flask", "text": " \nflask.send_file(path_or_file, mimetype=None, as_attachment=False, download_name=None, attachment_filename=None, conditional=True, etag=True, add_etags=None, last_modified=None, max_age=None, cache_timeout=None)  \nSend the contents of a file to the client. The first argument can be a file path or a file-like object. Paths are preferred in most cases because Werkzeug can manage the file and get extra information from the path. Passing a file-like object requires that the file is opened in binary mode, and is mostly useful when building a file in memory with io.BytesIO. Never pass file paths provided by a user. The path is assumed to be trusted, so a user could craft a path to access a file you didn\u2019t intend. Use send_from_directory() to safely serve user-requested paths from within a directory. If the WSGI server sets a file_wrapper in environ, it is used, otherwise Werkzeug\u2019s built-in wrapper is used. Alternatively, if the HTTP server supports X-Sendfile, configuring Flask with USE_X_SENDFILE = True will tell the server to send the given path, which is much more efficient than reading it in Python.  Parameters \n \npath_or_file \u2013 The path to the file to send, relative to the current working directory if a relative path is given. Alternatively, a file-like object opened in binary mode. Make sure the file pointer is seeked to the start of the data. \nmimetype \u2013 The MIME type to send for the file. If not provided, it will try to detect it from the file name. \nas_attachment \u2013 Indicate to a browser that it should offer to save the file instead of displaying it. \ndownload_name \u2013 The default name browsers will use when saving the file. Defaults to the passed file name. \nconditional \u2013 Enable conditional and range responses based on request headers. Requires passing a file path and environ. \netag \u2013 Calculate an ETag for the file, which requires passing a file path. Can also be a string to use instead. \nlast_modified \u2013 The last modified time to send for the file, in seconds. If not provided, it will try to detect it from the file path. \nmax_age \u2013 How long the client should cache the file, in seconds. If set, Cache-Control will be public, otherwise it will be no-cache to prefer conditional caching.     Changed in version 2.0: download_name replaces the attachment_filename parameter. If as_attachment=False, it is passed with Content-Disposition: inline instead.   Changed in version 2.0: max_age replaces the cache_timeout parameter. conditional is enabled and max_age is not set by default.   Changed in version 2.0: etag replaces the add_etags parameter. It can be a string to use instead of generating one.   Changed in version 2.0: Passing a file-like object that inherits from TextIOBase will raise a ValueError rather than sending an empty file.   New in version 2.0: Moved the implementation to Werkzeug. This is now a wrapper to pass some Flask-specific arguments.   Changelog Changed in version 1.1: filename may be a PathLike object.   Changed in version 1.1: Passing a BytesIO object supports range requests.   Changed in version 1.0.3: Filenames are encoded with ASCII instead of Latin-1 for broader compatibility with WSGI servers.   Changed in version 1.0: UTF-8 filenames as specified in RFC 2231 are supported.   Changed in version 0.12: The filename is no longer automatically inferred from file objects. If you want to use automatic MIME and etag support, pass a filename via filename_or_fp or attachment_filename.   Changed in version 0.12: attachment_filename is preferred over filename for MIME detection.   Changed in version 0.9: cache_timeout defaults to Flask.get_send_file_max_age().   Changed in version 0.7: MIME guessing and etag support for file-like objects was deprecated because it was unreliable. Pass a filename if you are able to, otherwise attach an etag yourself.   Changed in version 0.5: The add_etags, cache_timeout and conditional parameters were added. The default behavior is to add etags.   New in version 0.2.  \n\n"}, {"name": "SEND_FILE_MAX_AGE_DEFAULT", "path": "config/index#SEND_FILE_MAX_AGE_DEFAULT", "type": "Configuration", "text": " \nSEND_FILE_MAX_AGE_DEFAULT  \nWhen serving files, set the cache control max age to this number of seconds. Can be a datetime.timedelta or an int. Override this value on a per-file basis using get_send_file_max_age() on the application or blueprint. If None, send_file tells the browser to use conditional requests will be used instead of a timed cache, which is usually preferable. Default: None \n"}, {"name": "send_from_directory()", "path": "api/index#flask.send_from_directory", "type": "flask", "text": " \nflask.send_from_directory(directory, path, filename=None, **kwargs)  \nSend a file from within a directory using send_file(). @app.route(\"/uploads/<path:name>\")\ndef download_file(name):\n    return send_from_directory(\n        app.config['UPLOAD_FOLDER'], name, as_attachment=True\n    )\n This is a secure way to serve files from a folder, such as static files or uploads. Uses safe_join() to ensure the path coming from the client is not maliciously crafted to point outside the specified directory. If the final path does not point to an existing regular file, raises a 404 NotFound error.  Parameters \n \ndirectory (str) \u2013 The directory that path must be located under. \npath (str) \u2013 The path to the file to send, relative to directory. \nkwargs (Any) \u2013 Arguments to pass to send_file(). \nfilename (Optional[str]) \u2013    Return type \nResponse    Changed in version 2.0: path replaces the filename parameter.   New in version 2.0: Moved the implementation to Werkzeug. This is now a wrapper to pass some Flask-specific arguments.   Changelog New in version 0.5.  \n\n"}, {"name": "SERVER_NAME", "path": "config/index#SERVER_NAME", "type": "Configuration", "text": " \nSERVER_NAME  \nInform the application what host and port it is bound to. Required for subdomain route matching support. If set, will be used for the session cookie domain if SESSION_COOKIE_DOMAIN is not set. Modern web browsers will not allow setting cookies for domains without a dot. To use a domain locally, add any names that should route to the app to your hosts file. 127.0.0.1 localhost.dev\n If set, url_for can generate external URLs with only an application context instead of a request context. Default: None \n"}, {"name": "session", "path": "api/index#flask.session", "type": "flask", "text": " \nclass flask.session  \nThe session object works pretty much like an ordinary dict, with the difference that it keeps track of modifications. This is a proxy. See Notes On Proxies for more information. The following attributes are interesting:  \nnew  \nTrue if the session is new, False otherwise. \n  \nmodified  \nTrue if the session object detected a modification. Be advised that modifications on mutable structures are not picked up automatically, in that situation you have to explicitly set the attribute to True yourself. Here an example: # this change is not picked up because a mutable object (here\n# a list) is changed.\nsession['objects'].append(42)\n# so mark it as modified yourself\nsession.modified = True\n \n  \npermanent  \nIf set to True the session lives for permanent_session_lifetime seconds. The default is 31 days. If set to False (which is the default) the session will be deleted when the user closes the browser. \n \n"}, {"name": "session.modified", "path": "api/index#flask.session.modified", "type": "flask", "text": " \nmodified  \nTrue if the session object detected a modification. Be advised that modifications on mutable structures are not picked up automatically, in that situation you have to explicitly set the attribute to True yourself. Here an example: # this change is not picked up because a mutable object (here\n# a list) is changed.\nsession['objects'].append(42)\n# so mark it as modified yourself\nsession.modified = True\n \n"}, {"name": "session.new", "path": "api/index#flask.session.new", "type": "flask", "text": " \nnew  \nTrue if the session is new, False otherwise. \n"}, {"name": "session.permanent", "path": "api/index#flask.session.permanent", "type": "flask", "text": " \npermanent  \nIf set to True the session lives for permanent_session_lifetime seconds. The default is 31 days. If set to False (which is the default) the session will be deleted when the user closes the browser. \n"}, {"name": "SessionInterface", "path": "api/index#flask.sessions.SessionInterface", "type": "flask.sessions", "text": " \nclass flask.sessions.SessionInterface  \nThe basic interface you have to implement in order to replace the default session interface which uses werkzeug\u2019s securecookie implementation. The only methods you have to implement are open_session() and save_session(), the others have useful defaults which you don\u2019t need to change. The session object returned by the open_session() method has to provide a dictionary like interface plus the properties and methods from the SessionMixin. We recommend just subclassing a dict and adding that mixin: class Session(dict, SessionMixin):\n    pass\n If open_session() returns None Flask will call into make_null_session() to create a session that acts as replacement if the session support cannot work because some requirement is not fulfilled. The default NullSession class that is created will complain that the secret key was not set. To replace the session interface on an application all you have to do is to assign flask.Flask.session_interface: app = Flask(__name__)\napp.session_interface = MySessionInterface()\n  Changelog New in version 0.8.   \nget_cookie_domain(app)  \nReturns the domain that should be set for the session cookie. Uses SESSION_COOKIE_DOMAIN if it is configured, otherwise falls back to detecting the domain based on SERVER_NAME. Once detected (or if not set at all), SESSION_COOKIE_DOMAIN is updated to avoid re-running the logic.  Parameters \napp (Flask) \u2013   Return type \nOptional[str]   \n  \nget_cookie_httponly(app)  \nReturns True if the session cookie should be httponly. This currently just returns the value of the SESSION_COOKIE_HTTPONLY config var.  Parameters \napp (Flask) \u2013   Return type \nbool   \n  \nget_cookie_name(app)  \nReturns the name of the session cookie. Uses app.session_cookie_name which is set to SESSION_COOKIE_NAME  Parameters \napp (Flask) \u2013   Return type \nstr   \n  \nget_cookie_path(app)  \nReturns the path for which the cookie should be valid. The default implementation uses the value from the SESSION_COOKIE_PATH config var if it\u2019s set, and falls back to APPLICATION_ROOT or uses / if it\u2019s None.  Parameters \napp (Flask) \u2013   Return type \nstr   \n  \nget_cookie_samesite(app)  \nReturn 'Strict' or 'Lax' if the cookie should use the SameSite attribute. This currently just returns the value of the SESSION_COOKIE_SAMESITE setting.  Parameters \napp (Flask) \u2013   Return type \nstr   \n  \nget_cookie_secure(app)  \nReturns True if the cookie should be secure. This currently just returns the value of the SESSION_COOKIE_SECURE setting.  Parameters \napp (Flask) \u2013   Return type \nbool   \n  \nget_expiration_time(app, session)  \nA helper method that returns an expiration date for the session or None if the session is linked to the browser session. The default implementation returns now + the permanent session lifetime configured on the application.  Parameters \n \napp (Flask) \u2013  \nsession (flask.sessions.SessionMixin) \u2013    Return type \nOptional[datetime.datetime]   \n  \nis_null_session(obj)  \nChecks if a given object is a null session. Null sessions are not asked to be saved. This checks if the object is an instance of null_session_class by default.  Parameters \nobj (object) \u2013   Return type \nbool   \n  \nmake_null_session(app)  \nCreates a null session which acts as a replacement object if the real session support could not be loaded due to a configuration error. This mainly aids the user experience because the job of the null session is to still support lookup without complaining but modifications are answered with a helpful error message of what failed. This creates an instance of null_session_class by default.  Parameters \napp (Flask) \u2013   Return type \nflask.sessions.NullSession   \n  \nnull_session_class  \nmake_null_session() will look here for the class that should be created when a null session is requested. Likewise the is_null_session() method will perform a typecheck against this type. alias of flask.sessions.NullSession \n  \nopen_session(app, request)  \nThis method has to be implemented and must either return None in case the loading failed because of a configuration error or an instance of a session object which implements a dictionary like interface + the methods and attributes on SessionMixin.  Parameters \n \napp (Flask) \u2013  \nrequest (Request) \u2013    Return type \nOptional[flask.sessions.SessionMixin]   \n  \npickle_based = False  \nA flag that indicates if the session interface is pickle based. This can be used by Flask extensions to make a decision in regards to how to deal with the session object.  Changelog New in version 0.10.  \n\n  \nsave_session(app, session, response)  \nThis is called for actual sessions returned by open_session() at the end of the request. This is still called during a request context so if you absolutely need access to the request you can do that.  Parameters \n \napp (Flask) \u2013  \nsession (flask.sessions.SessionMixin) \u2013  \nresponse (Response) \u2013    Return type \nNone   \n  \nshould_set_cookie(app, session)  \nUsed by session backends to determine if a Set-Cookie header should be set for this session cookie for this response. If the session has been modified, the cookie is set. If the session is permanent and the SESSION_REFRESH_EACH_REQUEST config is true, the cookie is always set. This check is usually skipped if the session was deleted.  Changelog New in version 0.11.   Parameters \n \napp (Flask) \u2013  \nsession (flask.sessions.SessionMixin) \u2013    Return type \nbool   \n \n"}, {"name": "SessionInterface.get_cookie_domain()", "path": "api/index#flask.sessions.SessionInterface.get_cookie_domain", "type": "flask.sessions", "text": " \nget_cookie_domain(app)  \nReturns the domain that should be set for the session cookie. Uses SESSION_COOKIE_DOMAIN if it is configured, otherwise falls back to detecting the domain based on SERVER_NAME. Once detected (or if not set at all), SESSION_COOKIE_DOMAIN is updated to avoid re-running the logic.  Parameters \napp (Flask) \u2013   Return type \nOptional[str]   \n"}, {"name": "SessionInterface.get_cookie_httponly()", "path": "api/index#flask.sessions.SessionInterface.get_cookie_httponly", "type": "flask.sessions", "text": " \nget_cookie_httponly(app)  \nReturns True if the session cookie should be httponly. This currently just returns the value of the SESSION_COOKIE_HTTPONLY config var.  Parameters \napp (Flask) \u2013   Return type \nbool   \n"}, {"name": "SessionInterface.get_cookie_name()", "path": "api/index#flask.sessions.SessionInterface.get_cookie_name", "type": "flask.sessions", "text": " \nget_cookie_name(app)  \nReturns the name of the session cookie. Uses app.session_cookie_name which is set to SESSION_COOKIE_NAME  Parameters \napp (Flask) \u2013   Return type \nstr   \n"}, {"name": "SessionInterface.get_cookie_path()", "path": "api/index#flask.sessions.SessionInterface.get_cookie_path", "type": "flask.sessions", "text": " \nget_cookie_path(app)  \nReturns the path for which the cookie should be valid. The default implementation uses the value from the SESSION_COOKIE_PATH config var if it\u2019s set, and falls back to APPLICATION_ROOT or uses / if it\u2019s None.  Parameters \napp (Flask) \u2013   Return type \nstr   \n"}, {"name": "SessionInterface.get_cookie_samesite()", "path": "api/index#flask.sessions.SessionInterface.get_cookie_samesite", "type": "flask.sessions", "text": " \nget_cookie_samesite(app)  \nReturn 'Strict' or 'Lax' if the cookie should use the SameSite attribute. This currently just returns the value of the SESSION_COOKIE_SAMESITE setting.  Parameters \napp (Flask) \u2013   Return type \nstr   \n"}, {"name": "SessionInterface.get_cookie_secure()", "path": "api/index#flask.sessions.SessionInterface.get_cookie_secure", "type": "flask.sessions", "text": " \nget_cookie_secure(app)  \nReturns True if the cookie should be secure. This currently just returns the value of the SESSION_COOKIE_SECURE setting.  Parameters \napp (Flask) \u2013   Return type \nbool   \n"}, {"name": "SessionInterface.get_expiration_time()", "path": "api/index#flask.sessions.SessionInterface.get_expiration_time", "type": "flask.sessions", "text": " \nget_expiration_time(app, session)  \nA helper method that returns an expiration date for the session or None if the session is linked to the browser session. The default implementation returns now + the permanent session lifetime configured on the application.  Parameters \n \napp (Flask) \u2013  \nsession (flask.sessions.SessionMixin) \u2013    Return type \nOptional[datetime.datetime]   \n"}, {"name": "SessionInterface.is_null_session()", "path": "api/index#flask.sessions.SessionInterface.is_null_session", "type": "flask.sessions", "text": " \nis_null_session(obj)  \nChecks if a given object is a null session. Null sessions are not asked to be saved. This checks if the object is an instance of null_session_class by default.  Parameters \nobj (object) \u2013   Return type \nbool   \n"}, {"name": "SessionInterface.make_null_session()", "path": "api/index#flask.sessions.SessionInterface.make_null_session", "type": "flask.sessions", "text": " \nmake_null_session(app)  \nCreates a null session which acts as a replacement object if the real session support could not be loaded due to a configuration error. This mainly aids the user experience because the job of the null session is to still support lookup without complaining but modifications are answered with a helpful error message of what failed. This creates an instance of null_session_class by default.  Parameters \napp (Flask) \u2013   Return type \nflask.sessions.NullSession   \n"}, {"name": "SessionInterface.null_session_class", "path": "api/index#flask.sessions.SessionInterface.null_session_class", "type": "flask.sessions", "text": " \nnull_session_class  \nmake_null_session() will look here for the class that should be created when a null session is requested. Likewise the is_null_session() method will perform a typecheck against this type. alias of flask.sessions.NullSession \n"}, {"name": "SessionInterface.open_session()", "path": "api/index#flask.sessions.SessionInterface.open_session", "type": "flask.sessions", "text": " \nopen_session(app, request)  \nThis method has to be implemented and must either return None in case the loading failed because of a configuration error or an instance of a session object which implements a dictionary like interface + the methods and attributes on SessionMixin.  Parameters \n \napp (Flask) \u2013  \nrequest (Request) \u2013    Return type \nOptional[flask.sessions.SessionMixin]   \n"}, {"name": "SessionInterface.pickle_based", "path": "api/index#flask.sessions.SessionInterface.pickle_based", "type": "flask.sessions", "text": " \npickle_based = False  \nA flag that indicates if the session interface is pickle based. This can be used by Flask extensions to make a decision in regards to how to deal with the session object.  Changelog New in version 0.10.  \n\n"}, {"name": "SessionInterface.save_session()", "path": "api/index#flask.sessions.SessionInterface.save_session", "type": "flask.sessions", "text": " \nsave_session(app, session, response)  \nThis is called for actual sessions returned by open_session() at the end of the request. This is still called during a request context so if you absolutely need access to the request you can do that.  Parameters \n \napp (Flask) \u2013  \nsession (flask.sessions.SessionMixin) \u2013  \nresponse (Response) \u2013    Return type \nNone   \n"}, {"name": "SessionInterface.should_set_cookie()", "path": "api/index#flask.sessions.SessionInterface.should_set_cookie", "type": "flask.sessions", "text": " \nshould_set_cookie(app, session)  \nUsed by session backends to determine if a Set-Cookie header should be set for this session cookie for this response. If the session has been modified, the cookie is set. If the session is permanent and the SESSION_REFRESH_EACH_REQUEST config is true, the cookie is always set. This check is usually skipped if the session was deleted.  Changelog New in version 0.11.   Parameters \n \napp (Flask) \u2013  \nsession (flask.sessions.SessionMixin) \u2013    Return type \nbool   \n"}, {"name": "SessionMixin", "path": "api/index#flask.sessions.SessionMixin", "type": "flask.sessions", "text": " \nclass flask.sessions.SessionMixin  \nExpands a basic dictionary with session attributes.  \naccessed = True  \nSome implementations can detect when session data is read or written and set this when that happens. The mixin default is hard coded to True. \n  \nmodified = True  \nSome implementations can detect changes to the session and set this when that happens. The mixin default is hard coded to True. \n  \nproperty permanent: bool  \nThis reflects the '_permanent' key in the dict. \n \n"}, {"name": "SessionMixin.accessed", "path": "api/index#flask.sessions.SessionMixin.accessed", "type": "flask.sessions", "text": " \naccessed = True  \nSome implementations can detect when session data is read or written and set this when that happens. The mixin default is hard coded to True. \n"}, {"name": "SessionMixin.modified", "path": "api/index#flask.sessions.SessionMixin.modified", "type": "flask.sessions", "text": " \nmodified = True  \nSome implementations can detect changes to the session and set this when that happens. The mixin default is hard coded to True. \n"}, {"name": "SESSION_COOKIE_DOMAIN", "path": "config/index#SESSION_COOKIE_DOMAIN", "type": "Configuration", "text": " \nSESSION_COOKIE_DOMAIN  \nThe domain match rule that the session cookie will be valid for. If not set, the cookie will be valid for all subdomains of SERVER_NAME. If False, the cookie\u2019s domain will not be set. Default: None \n"}, {"name": "SESSION_COOKIE_HTTPONLY", "path": "config/index#SESSION_COOKIE_HTTPONLY", "type": "Configuration", "text": " \nSESSION_COOKIE_HTTPONLY  \nBrowsers will not allow JavaScript access to cookies marked as \u201cHTTP only\u201d for security. Default: True \n"}, {"name": "SESSION_COOKIE_NAME", "path": "config/index#SESSION_COOKIE_NAME", "type": "Configuration", "text": " \nSESSION_COOKIE_NAME  \nThe name of the session cookie. Can be changed in case you already have a cookie with the same name. Default: 'session' \n"}, {"name": "SESSION_COOKIE_PATH", "path": "config/index#SESSION_COOKIE_PATH", "type": "Configuration", "text": " \nSESSION_COOKIE_PATH  \nThe path that the session cookie will be valid for. If not set, the cookie will be valid underneath APPLICATION_ROOT or / if that is not set. Default: None \n"}, {"name": "SESSION_COOKIE_SAMESITE", "path": "config/index#SESSION_COOKIE_SAMESITE", "type": "Configuration", "text": " \nSESSION_COOKIE_SAMESITE  \nRestrict how cookies are sent with requests from external sites. Can be set to 'Lax' (recommended) or 'Strict'. See Set-Cookie options. Default: None  Changelog New in version 1.0.  \n\n"}, {"name": "SESSION_COOKIE_SECURE", "path": "config/index#SESSION_COOKIE_SECURE", "type": "Configuration", "text": " \nSESSION_COOKIE_SECURE  \nBrowsers will only send cookies with requests over HTTPS if the cookie is marked \u201csecure\u201d. The application must be served over HTTPS for this to make sense. Default: False \n"}, {"name": "SESSION_REFRESH_EACH_REQUEST", "path": "config/index#SESSION_REFRESH_EACH_REQUEST", "type": "Configuration", "text": " \nSESSION_REFRESH_EACH_REQUEST  \nControl whether the cookie is sent with every response when session.permanent is true. Sending the cookie every time (the default) can more reliably keep the session from expiring, but uses more bandwidth. Non-permanent sessions are not affected. Default: True \n"}, {"name": "Signals", "path": "signals/index", "type": "User\u2019s Guide", "text": "Signals  Changelog New in version 0.6.  Starting with Flask 0.6, there is integrated support for signalling in Flask. This support is provided by the excellent blinker library and will gracefully fall back if it is not available. What are signals? Signals help you decouple applications by sending notifications when actions occur elsewhere in the core framework or another Flask extensions. In short, signals allow certain senders to notify subscribers that something happened. Flask comes with a couple of signals and other extensions might provide more. Also keep in mind that signals are intended to notify subscribers and should not encourage subscribers to modify data. You will notice that there are signals that appear to do the same thing like some of the builtin decorators do (eg: request_started is very similar to before_request()). However, there are differences in how they work. The core before_request() handler, for example, is executed in a specific order and is able to abort the request early by returning a response. In contrast all signal handlers are executed in undefined order and do not modify any data. The big advantage of signals over handlers is that you can safely subscribe to them for just a split second. These temporary subscriptions are helpful for unit testing for example. Say you want to know what templates were rendered as part of a request: signals allow you to do exactly that. Subscribing to Signals To subscribe to a signal, you can use the connect() method of a signal. The first argument is the function that should be called when the signal is emitted, the optional second argument specifies a sender. To unsubscribe from a signal, you can use the disconnect() method. For all core Flask signals, the sender is the application that issued the signal. When you subscribe to a signal, be sure to also provide a sender unless you really want to listen for signals from all applications. This is especially true if you are developing an extension. For example, here is a helper context manager that can be used in a unit test to determine which templates were rendered and what variables were passed to the template: from flask import template_rendered\nfrom contextlib import contextmanager\n\n@contextmanager\ndef captured_templates(app):\n    recorded = []\n    def record(sender, template, context, **extra):\n        recorded.append((template, context))\n    template_rendered.connect(record, app)\n    try:\n        yield recorded\n    finally:\n        template_rendered.disconnect(record, app)\n This can now easily be paired with a test client: with captured_templates(app) as templates:\n    rv = app.test_client().get('/')\n    assert rv.status_code == 200\n    assert len(templates) == 1\n    template, context = templates[0]\n    assert template.name == 'index.html'\n    assert len(context['items']) == 10\n Make sure to subscribe with an extra **extra argument so that your calls don\u2019t fail if Flask introduces new arguments to the signals. All the template rendering in the code issued by the application app in the body of the with block will now be recorded in the templates variable. Whenever a template is rendered, the template object as well as context are appended to it. Additionally there is a convenient helper method (connected_to()) that allows you to temporarily subscribe a function to a signal with a context manager on its own. Because the return value of the context manager cannot be specified that way, you have to pass the list in as an argument: from flask import template_rendered\n\ndef captured_templates(app, recorded, **extra):\n    def record(sender, template, context):\n        recorded.append((template, context))\n    return template_rendered.connected_to(record, app)\n The example above would then look like this: templates = []\nwith captured_templates(app, templates, **extra):\n    ...\n    template, context = templates[0]\n  Blinker API Changes The connected_to() method arrived in Blinker with version 1.1.  Creating Signals If you want to use signals in your own application, you can use the blinker library directly. The most common use case are named signals in a custom Namespace.. This is what is recommended most of the time: from blinker import Namespace\nmy_signals = Namespace()\n Now you can create new signals like this: model_saved = my_signals.signal('model-saved')\n The name for the signal here makes it unique and also simplifies debugging. You can access the name of the signal with the name attribute.  For Extension Developers If you are writing a Flask extension and you want to gracefully degrade for missing blinker installations, you can do so by using the flask.signals.Namespace class.  Sending Signals If you want to emit a signal, you can do so by calling the send() method. It accepts a sender as first argument and optionally some keyword arguments that are forwarded to the signal subscribers: class Model(object):\n    ...\n\n    def save(self):\n        model_saved.send(self)\n Try to always pick a good sender. If you have a class that is emitting a signal, pass self as sender. If you are emitting a signal from a random function, you can pass current_app._get_current_object() as sender.  Passing Proxies as Senders Never pass current_app as sender to a signal. Use current_app._get_current_object() instead. The reason for this is that current_app is a proxy and not the real application object.  Signals and Flask\u2019s Request Context Signals fully support The Request Context when receiving signals. Context-local variables are consistently available between request_started and request_finished, so you can rely on flask.g and others as needed. Note the limitations described in Sending Signals and the request_tearing_down signal. Decorator Based Signal Subscriptions With Blinker 1.1 you can also easily subscribe to signals by using the new connect_via() decorator: from flask import template_rendered\n\n@template_rendered.connect_via(app)\ndef when_template_rendered(sender, template, context, **extra):\n    print f'Template {template.name} is rendered with {context}'\n Core Signals Take a look at Signals for a list of all builtin signals.\n"}, {"name": "Single-Page Applications", "path": "patterns/singlepageapplications/index", "type": "User's Guide: Design Patterns", "text": "Single-Page Applications Flask can be used to serve Single-Page Applications (SPA) by placing static files produced by your frontend framework in a subfolder inside of your project. You will also need to create a catch-all endpoint that routes all requests to your SPA. The following example demonstrates how to serve an SPA along with an API: from flask import Flask, jsonify\n\napp = Flask(__name__, static_folder='app', static_url_path=\"/app\")\n\n\n@app.route(\"/heartbeat\")\ndef heartbeat():\n    return jsonify({\"status\": \"healthy\"})\n\n\n@app.route('/', defaults={'path': ''})\n@app.route('/<path:path>')\ndef catch_all(path):\n    return app.send_static_file(\"index.html\")\n\n"}, {"name": "SQLAlchemy in Flask", "path": "patterns/sqlalchemy/index", "type": "User's Guide: Design Patterns", "text": "SQLAlchemy in Flask Many people prefer SQLAlchemy for database access. In this case it\u2019s encouraged to use a package instead of a module for your flask application and drop the models into a separate module (Large Applications as Packages). While that is not necessary, it makes a lot of sense. There are four very common ways to use SQLAlchemy. I will outline each of them here: Flask-SQLAlchemy Extension Because SQLAlchemy is a common database abstraction layer and object relational mapper that requires a little bit of configuration effort, there is a Flask extension that handles that for you. This is recommended if you want to get started quickly. You can download Flask-SQLAlchemy from PyPI. Declarative The declarative extension in SQLAlchemy is the most recent method of using SQLAlchemy. It allows you to define tables and models in one go, similar to how Django works. In addition to the following text I recommend the official documentation on the declarative extension. Here\u2019s the example database.py module for your application: from sqlalchemy import create_engine\nfrom sqlalchemy.orm import scoped_session, sessionmaker\nfrom sqlalchemy.ext.declarative import declarative_base\n\nengine = create_engine('sqlite:////tmp/test.db')\ndb_session = scoped_session(sessionmaker(autocommit=False,\n                                         autoflush=False,\n                                         bind=engine))\nBase = declarative_base()\nBase.query = db_session.query_property()\n\ndef init_db():\n    # import all modules here that might define models so that\n    # they will be registered properly on the metadata.  Otherwise\n    # you will have to import them first before calling init_db()\n    import yourapplication.models\n    Base.metadata.create_all(bind=engine)\n To define your models, just subclass the Base class that was created by the code above. If you are wondering why we don\u2019t have to care about threads here (like we did in the SQLite3 example above with the g object): that\u2019s because SQLAlchemy does that for us already with the scoped_session. To use SQLAlchemy in a declarative way with your application, you just have to put the following code into your application module. Flask will automatically remove database sessions at the end of the request or when the application shuts down: from yourapplication.database import db_session\n\n@app.teardown_appcontext\ndef shutdown_session(exception=None):\n    db_session.remove()\n Here is an example model (put this into models.py, e.g.): from sqlalchemy import Column, Integer, String\nfrom yourapplication.database import Base\n\nclass User(Base):\n    __tablename__ = 'users'\n    id = Column(Integer, primary_key=True)\n    name = Column(String(50), unique=True)\n    email = Column(String(120), unique=True)\n\n    def __init__(self, name=None, email=None):\n        self.name = name\n        self.email = email\n\n    def __repr__(self):\n        return f'<User {self.name!r}>'\n To create the database you can use the init_db function: >>> from yourapplication.database import init_db\n>>> init_db()\n You can insert entries into the database like this: >>> from yourapplication.database import db_session\n>>> from yourapplication.models import User\n>>> u = User('admin', 'admin@localhost')\n>>> db_session.add(u)\n>>> db_session.commit()\n Querying is simple as well: >>> User.query.all()\n[<User 'admin'>]\n>>> User.query.filter(User.name == 'admin').first()\n<User 'admin'>\n Manual Object Relational Mapping Manual object relational mapping has a few upsides and a few downsides versus the declarative approach from above. The main difference is that you define tables and classes separately and map them together. It\u2019s more flexible but a little more to type. In general it works like the declarative approach, so make sure to also split up your application into multiple modules in a package. Here is an example database.py module for your application: from sqlalchemy import create_engine, MetaData\nfrom sqlalchemy.orm import scoped_session, sessionmaker\n\nengine = create_engine('sqlite:////tmp/test.db')\nmetadata = MetaData()\ndb_session = scoped_session(sessionmaker(autocommit=False,\n                                         autoflush=False,\n                                         bind=engine))\ndef init_db():\n    metadata.create_all(bind=engine)\n As in the declarative approach, you need to close the session after each request or application context shutdown. Put this into your application module: from yourapplication.database import db_session\n\n@app.teardown_appcontext\ndef shutdown_session(exception=None):\n    db_session.remove()\n Here is an example table and model (put this into models.py): from sqlalchemy import Table, Column, Integer, String\nfrom sqlalchemy.orm import mapper\nfrom yourapplication.database import metadata, db_session\n\nclass User(object):\n    query = db_session.query_property()\n\n    def __init__(self, name=None, email=None):\n        self.name = name\n        self.email = email\n\n    def __repr__(self):\n        return f'<User {self.name!r}>'\n\nusers = Table('users', metadata,\n    Column('id', Integer, primary_key=True),\n    Column('name', String(50), unique=True),\n    Column('email', String(120), unique=True)\n)\nmapper(User, users)\n Querying and inserting works exactly the same as in the example above. SQL Abstraction Layer If you just want to use the database system (and SQL) abstraction layer you basically only need the engine: from sqlalchemy import create_engine, MetaData, Table\n\nengine = create_engine('sqlite:////tmp/test.db')\nmetadata = MetaData(bind=engine)\n Then you can either declare the tables in your code like in the examples above, or automatically load them: from sqlalchemy import Table\n\nusers = Table('users', metadata, autoload=True)\n To insert data you can use the insert method. We have to get a connection first so that we can use a transaction: >>> con = engine.connect()\n>>> con.execute(users.insert(), name='admin', email='admin@localhost')\n SQLAlchemy will automatically commit for us. To query your database, you use the engine directly or use a connection: >>> users.select(users.c.id == 1).execute().first()\n(1, 'admin', 'admin@localhost')\n These results are also dict-like tuples: >>> r = users.select(users.c.id == 1).execute().first()\n>>> r['name']\n'admin'\n You can also pass strings of SQL statements to the execute() method: >>> engine.execute('select * from users where id = :1', [1]).first()\n(1, 'admin', 'admin@localhost')\n For more information about SQLAlchemy, head over to the website.\n"}, {"name": "Standalone WSGI Containers", "path": "deploying/wsgi-standalone/index", "type": "User's Guide: Deploying", "text": "Standalone WSGI Containers There are popular servers written in Python that contain WSGI applications and serve HTTP. These servers stand alone when they run; you can proxy to them from your web server. Note the section on Proxy Setups if you run into issues. Gunicorn Gunicorn \u2018Green Unicorn\u2019 is a WSGI HTTP Server for UNIX. It\u2019s a pre-fork worker model ported from Ruby\u2019s Unicorn project. It supports both eventlet and greenlet. Running a Flask application on this server is quite simple: $ gunicorn myproject:app\n Gunicorn provides many command-line options \u2013 see gunicorn -h. For example, to run a Flask application with 4 worker processes (-w\n4) binding to localhost port 4000 (-b 127.0.0.1:4000): $ gunicorn -w 4 -b 127.0.0.1:4000 myproject:app\n The gunicorn command expects the names of your application module or package and the application instance within the module. If you use the application factory pattern, you can pass a call to that: $ gunicorn \"myproject:create_app()\"\n uWSGI uWSGI is a fast application server written in C. It is very configurable which makes it more complicated to setup than gunicorn. Running uWSGI HTTP Router: $ uwsgi --http 127.0.0.1:5000 --module myproject:app\n For a more optimized setup, see configuring uWSGI and NGINX. Gevent Gevent is a coroutine-based Python networking library that uses greenlet to provide a high-level synchronous API on top of libev event loop: from gevent.pywsgi import WSGIServer\nfrom yourapplication import app\n\nhttp_server = WSGIServer(('', 5000), app)\nhttp_server.serve_forever()\n Twisted Web Twisted Web is the web server shipped with Twisted, a mature, non-blocking event-driven networking library. Twisted Web comes with a standard WSGI container which can be controlled from the command line using the twistd utility: $ twistd web --wsgi myproject.app\n This example will run a Flask application called app from a module named myproject. Twisted Web supports many flags and options, and the twistd utility does as well; see twistd -h and twistd web -h for more information. For example, to run a Twisted Web server in the foreground, on port 8080, with an application from myproject: $ twistd -n web --port tcp:8080 --wsgi myproject.app\n Proxy Setups If you deploy your application using one of these servers behind an HTTP proxy you will need to rewrite a few headers in order for the application to work. The two problematic values in the WSGI environment usually are REMOTE_ADDR and HTTP_HOST. You can configure your httpd to pass these headers, or you can fix them in middleware. Werkzeug ships a fixer that will solve some common setups, but you might want to write your own WSGI middleware for specific setups. Here\u2019s a simple nginx configuration which proxies to an application served on localhost at port 8000, setting appropriate headers: server {\n    listen 80;\n\n    server_name _;\n\n    access_log  /var/log/nginx/access.log;\n    error_log  /var/log/nginx/error.log;\n\n    location / {\n        proxy_pass         http://127.0.0.1:8000/;\n        proxy_redirect     off;\n\n        proxy_set_header   Host                 $host;\n        proxy_set_header   X-Real-IP            $remote_addr;\n        proxy_set_header   X-Forwarded-For      $proxy_add_x_forwarded_for;\n        proxy_set_header   X-Forwarded-Proto    $scheme;\n    }\n}\n If your httpd is not providing these headers, the most common setup invokes the host being set from X-Forwarded-Host and the remote address from X-Forwarded-For: from werkzeug.middleware.proxy_fix import ProxyFix\napp.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1)\n  Trusting Headers Please keep in mind that it is a security issue to use such a middleware in a non-proxy setup because it will blindly trust the incoming headers which might be forged by malicious clients.  If you want to rewrite the headers from another header, you might want to use a fixer like this: class CustomProxyFix(object):\n\n    def __init__(self, app):\n        self.app = app\n\n    def __call__(self, environ, start_response):\n        host = environ.get('HTTP_X_FHOST', '')\n        if host:\n            environ['HTTP_HOST'] = host\n        return self.app(environ, start_response)\n\napp.wsgi_app = CustomProxyFix(app.wsgi_app)\n\n"}, {"name": "Streaming Contents", "path": "patterns/streaming/index", "type": "User's Guide: Design Patterns", "text": "Streaming Contents Sometimes you want to send an enormous amount of data to the client, much more than you want to keep in memory. When you are generating the data on the fly though, how do you send that back to the client without the roundtrip to the filesystem? The answer is by using generators and direct responses. Basic Usage This is a basic view function that generates a lot of CSV data on the fly. The trick is to have an inner function that uses a generator to generate data and to then invoke that function and pass it to a response object: @app.route('/large.csv')\ndef generate_large_csv():\n    def generate():\n        for row in iter_all_rows():\n            yield f\"{','.join(row)}\\n\"\n    return app.response_class(generate(), mimetype='text/csv')\n Each yield expression is directly sent to the browser. Note though that some WSGI middlewares might break streaming, so be careful there in debug environments with profilers and other things you might have enabled. Streaming from Templates The Jinja2 template engine also supports rendering templates piece by piece. This functionality is not directly exposed by Flask because it is quite uncommon, but you can easily do it yourself: def stream_template(template_name, **context):\n    app.update_template_context(context)\n    t = app.jinja_env.get_template(template_name)\n    rv = t.stream(context)\n    rv.enable_buffering(5)\n    return rv\n\n@app.route('/my-large-page.html')\ndef render_large_template():\n    rows = iter_all_rows()\n    return app.response_class(stream_template('the_template.html', rows=rows))\n The trick here is to get the template object from the Jinja2 environment on the application and to call stream() instead of render() which returns a stream object instead of a string. Since we\u2019re bypassing the Flask template render functions and using the template object itself we have to make sure to update the render context ourselves by calling update_template_context(). The template is then evaluated as the stream is iterated over. Since each time you do a yield the server will flush the content to the client you might want to buffer up a few items in the template which you can do with rv.enable_buffering(size). 5 is a sane default. Streaming with Context  Changelog New in version 0.9.  Note that when you stream data, the request context is already gone the moment the function executes. Flask 0.9 provides you with a helper that can keep the request context around during the execution of the generator: from flask import stream_with_context, request\n\n@app.route('/stream')\ndef streamed_response():\n    def generate():\n        yield 'Hello '\n        yield request.args['name']\n        yield '!'\n    return app.response_class(stream_with_context(generate()))\n Without the stream_with_context() function you would get a RuntimeError at that point.\n"}, {"name": "stream_with_context()", "path": "api/index#flask.stream_with_context", "type": "flask", "text": " \nflask.stream_with_context(generator_or_function)  \nRequest contexts disappear when the response is started on the server. This is done for efficiency reasons and to make it less likely to encounter memory leaks with badly written WSGI middlewares. The downside is that if you are using streamed responses, the generator cannot access request bound information any more. This function however can help you keep the context around for longer: from flask import stream_with_context, request, Response\n\n@app.route('/stream')\ndef streamed_response():\n    @stream_with_context\n    def generate():\n        yield 'Hello '\n        yield request.args['name']\n        yield '!'\n    return Response(generate())\n Alternatively it can also be used around a specific generator: from flask import stream_with_context, request, Response\n\n@app.route('/stream')\ndef streamed_response():\n    def generate():\n        yield 'Hello '\n        yield request.args['name']\n        yield '!'\n    return Response(stream_with_context(generate()))\n  Changelog New in version 0.9.   Parameters \ngenerator_or_function (Union[Generator, Callable]) \u2013   Return type \nGenerator   \n"}, {"name": "Subclassing Flask", "path": "patterns/subclassing/index", "type": "User's Guide: Design Patterns", "text": "Subclassing Flask The Flask class is designed for subclassing. For example, you may want to override how request parameters are handled to preserve their order: from flask import Flask, Request\nfrom werkzeug.datastructures import ImmutableOrderedMultiDict\nclass MyRequest(Request):\n    \"\"\"Request subclass to override request parameter storage\"\"\"\n    parameter_storage_class = ImmutableOrderedMultiDict\nclass MyFlask(Flask):\n    \"\"\"Flask subclass using the custom request class\"\"\"\n    request_class = MyRequest\n This is the recommended approach for overriding or augmenting Flask\u2019s internal functionality.\n"}, {"name": "TaggedJSONSerializer", "path": "api/index#flask.json.tag.TaggedJSONSerializer", "type": "flask.json.tag", "text": " \nclass flask.json.tag.TaggedJSONSerializer  \nSerializer that uses a tag system to compactly represent objects that are not JSON types. Passed as the intermediate serializer to itsdangerous.Serializer. The following extra types are supported:  dict tuple bytes Markup UUID datetime   Return type \nNone    \ndefault_tags = [<class 'flask.json.tag.TagDict'>, <class 'flask.json.tag.PassDict'>, <class 'flask.json.tag.TagTuple'>, <class 'flask.json.tag.PassList'>, <class 'flask.json.tag.TagBytes'>, <class 'flask.json.tag.TagMarkup'>, <class 'flask.json.tag.TagUUID'>, <class 'flask.json.tag.TagDateTime'>]  \nTag classes to bind when creating the serializer. Other tags can be added later using register(). \n  \ndumps(value)  \nTag the value and dump it to a compact JSON string.  Parameters \nvalue (Any) \u2013   Return type \nstr   \n  \nloads(value)  \nLoad data from a JSON string and deserialized any tagged objects.  Parameters \nvalue (str) \u2013   Return type \nAny   \n  \nregister(tag_class, force=False, index=None)  \nRegister a new tag with this serializer.  Parameters \n \ntag_class (Type[flask.json.tag.JSONTag]) \u2013 tag class to register. Will be instantiated with this serializer instance. \nforce (bool) \u2013 overwrite an existing tag. If false (default), a KeyError is raised. \nindex (Optional[int]) \u2013 index to insert the new tag in the tag order. Useful when the new tag is a special case of an existing tag. If None (default), the tag is appended to the end of the order.   Raises \nKeyError \u2013 if the tag key is already registered and force is not true.  Return type \nNone   \n  \ntag(value)  \nConvert a value to a tagged representation if necessary.  Parameters \nvalue (Any) \u2013   Return type \nDict[str, Any]   \n  \nuntag(value)  \nConvert a tagged representation back to the original type.  Parameters \nvalue (Dict[str, Any]) \u2013   Return type \nAny   \n \n"}, {"name": "TaggedJSONSerializer.default_tags", "path": "api/index#flask.json.tag.TaggedJSONSerializer.default_tags", "type": "flask.json.tag", "text": " \ndefault_tags = [<class 'flask.json.tag.TagDict'>, <class 'flask.json.tag.PassDict'>, <class 'flask.json.tag.TagTuple'>, <class 'flask.json.tag.PassList'>, <class 'flask.json.tag.TagBytes'>, <class 'flask.json.tag.TagMarkup'>, <class 'flask.json.tag.TagUUID'>, <class 'flask.json.tag.TagDateTime'>]  \nTag classes to bind when creating the serializer. Other tags can be added later using register(). \n"}, {"name": "TaggedJSONSerializer.dumps()", "path": "api/index#flask.json.tag.TaggedJSONSerializer.dumps", "type": "flask.json.tag", "text": " \ndumps(value)  \nTag the value and dump it to a compact JSON string.  Parameters \nvalue (Any) \u2013   Return type \nstr   \n"}, {"name": "TaggedJSONSerializer.loads()", "path": "api/index#flask.json.tag.TaggedJSONSerializer.loads", "type": "flask.json.tag", "text": " \nloads(value)  \nLoad data from a JSON string and deserialized any tagged objects.  Parameters \nvalue (str) \u2013   Return type \nAny   \n"}, {"name": "TaggedJSONSerializer.register()", "path": "api/index#flask.json.tag.TaggedJSONSerializer.register", "type": "flask.json.tag", "text": " \nregister(tag_class, force=False, index=None)  \nRegister a new tag with this serializer.  Parameters \n \ntag_class (Type[flask.json.tag.JSONTag]) \u2013 tag class to register. Will be instantiated with this serializer instance. \nforce (bool) \u2013 overwrite an existing tag. If false (default), a KeyError is raised. \nindex (Optional[int]) \u2013 index to insert the new tag in the tag order. Useful when the new tag is a special case of an existing tag. If None (default), the tag is appended to the end of the order.   Raises \nKeyError \u2013 if the tag key is already registered and force is not true.  Return type \nNone   \n"}, {"name": "TaggedJSONSerializer.tag()", "path": "api/index#flask.json.tag.TaggedJSONSerializer.tag", "type": "flask.json.tag", "text": " \ntag(value)  \nConvert a value to a tagged representation if necessary.  Parameters \nvalue (Any) \u2013   Return type \nDict[str, Any]   \n"}, {"name": "TaggedJSONSerializer.untag()", "path": "api/index#flask.json.tag.TaggedJSONSerializer.untag", "type": "flask.json.tag", "text": " \nuntag(value)  \nConvert a tagged representation back to the original type.  Parameters \nvalue (Dict[str, Any]) \u2013   Return type \nAny   \n"}, {"name": "Template Inheritance", "path": "patterns/templateinheritance/index", "type": "User's Guide: Design Patterns", "text": "Template Inheritance The most powerful part of Jinja is template inheritance. Template inheritance allows you to build a base \u201cskeleton\u201d template that contains all the common elements of your site and defines blocks that child templates can override. Sounds complicated but is very basic. It\u2019s easiest to understand it by starting with an example. Base Template This template, which we\u2019ll call layout.html, defines a simple HTML skeleton document that you might use for a simple two-column page. It\u2019s the job of \u201cchild\u201d templates to fill the empty blocks with content: <!doctype html>\n<html>\n  <head>\n    {% block head %}\n    <link rel=\"stylesheet\" href=\"{{ url_for('static', filename='style.css') }}\">\n    <title>{% block title %}{% endblock %} - My Webpage</title>\n    {% endblock %}\n  </head>\n  <body>\n    <div id=\"content\">{% block content %}{% endblock %}</div>\n    <div id=\"footer\">\n      {% block footer %}\n      &copy; Copyright 2010 by <a href=\"http://domain.invalid/\">you</a>.\n      {% endblock %}\n    </div>\n  </body>\n</html>\n In this example, the {% block %} tags define four blocks that child templates can fill in. All the block tag does is tell the template engine that a child template may override those portions of the template. Child Template A child template might look like this: {% extends \"layout.html\" %}\n{% block title %}Index{% endblock %}\n{% block head %}\n  {{ super() }}\n  <style type=\"text/css\">\n    .important { color: #336699; }\n  </style>\n{% endblock %}\n{% block content %}\n  <h1>Index</h1>\n  <p class=\"important\">\n    Welcome on my awesome homepage.\n{% endblock %}\n The {% extends %} tag is the key here. It tells the template engine that this template \u201cextends\u201d another template. When the template system evaluates this template, first it locates the parent. The extends tag must be the first tag in the template. To render the contents of a block defined in the parent template, use {{ super() }}.\n"}, {"name": "Templates", "path": "templating/index", "type": "User\u2019s Guide", "text": "Templates Flask leverages Jinja2 as its template engine. You are obviously free to use a different template engine, but you still have to install Jinja2 to run Flask itself. This requirement is necessary to enable rich extensions. An extension can depend on Jinja2 being present. This section only gives a very quick introduction into how Jinja2 is integrated into Flask. If you want information on the template engine\u2019s syntax itself, head over to the official Jinja2 Template Documentation for more information. Jinja Setup Unless customized, Jinja2 is configured by Flask as follows:  autoescaping is enabled for all templates ending in .html, .htm, .xml as well as .xhtml when using render_template(). autoescaping is enabled for all strings when using render_template_string(). a template has the ability to opt in/out autoescaping with the {% autoescape %} tag. Flask inserts a couple of global functions and helpers into the Jinja2 context, additionally to the values that are present by default.  Standard Context The following global variables are available within Jinja2 templates by default:   config\n \nThe current configuration object (flask.config)  Changelog Changed in version 0.10: This is now always available, even in imported templates.   New in version 0.6.  \n\n   request\n \nThe current request object (flask.request). This variable is unavailable if the template was rendered without an active request context. \n   session\n \nThe current session object (flask.session). This variable is unavailable if the template was rendered without an active request context. \n   g\n \nThe request-bound object for global variables (flask.g). This variable is unavailable if the template was rendered without an active request context. \n   url_for()\n \nThe flask.url_for() function. \n   get_flashed_messages()\n \nThe flask.get_flashed_messages() function. \n  The Jinja Context Behavior These variables are added to the context of variables, they are not global variables. The difference is that by default these will not show up in the context of imported templates. This is partially caused by performance considerations, partially to keep things explicit. What does this mean for you? If you have a macro you want to import, that needs to access the request object you have two possibilities:  you explicitly pass the request to the macro as parameter, or the attribute of the request object you are interested in. you import the macro \u201cwith context\u201d.  Importing with context looks like this: {% from '_helpers.html' import my_macro with context %}\n  Controlling Autoescaping Autoescaping is the concept of automatically escaping special characters for you. Special characters in the sense of HTML (or XML, and thus XHTML) are &, >, <, \" as well as '. Because these characters carry specific meanings in documents on their own you have to replace them by so called \u201centities\u201d if you want to use them for text. Not doing so would not only cause user frustration by the inability to use these characters in text, but can also lead to security problems. (see Cross-Site Scripting (XSS)) Sometimes however you will need to disable autoescaping in templates. This can be the case if you want to explicitly inject HTML into pages, for example if they come from a system that generates secure HTML like a markdown to HTML converter. There are three ways to accomplish that:  In the Python code, wrap the HTML string in a Markup object before passing it to the template. This is in general the recommended way. Inside the template, use the |safe filter to explicitly mark a string as safe HTML ({{ myvariable|safe }}) Temporarily disable the autoescape system altogether.  To disable the autoescape system in templates, you can use the {%\nautoescape %} block: {% autoescape false %}\n    <p>autoescaping is disabled here\n    <p>{{ will_not_be_escaped }}\n{% endautoescape %}\n Whenever you do this, please be very cautious about the variables you are using in this block. Registering Filters If you want to register your own filters in Jinja2 you have two ways to do that. You can either put them by hand into the jinja_env of the application or use the template_filter() decorator. The two following examples work the same and both reverse an object: @app.template_filter('reverse')\ndef reverse_filter(s):\n    return s[::-1]\n\ndef reverse_filter(s):\n    return s[::-1]\napp.jinja_env.filters['reverse'] = reverse_filter\n In case of the decorator the argument is optional if you want to use the function name as name of the filter. Once registered, you can use the filter in your templates in the same way as Jinja2\u2019s builtin filters, for example if you have a Python list in context called mylist: {% for x in mylist | reverse %}\n{% endfor %}\n Context Processors To inject new variables automatically into the context of a template, context processors exist in Flask. Context processors run before the template is rendered and have the ability to inject new values into the template context. A context processor is a function that returns a dictionary. The keys and values of this dictionary are then merged with the template context, for all templates in the app: @app.context_processor\ndef inject_user():\n    return dict(user=g.user)\n The context processor above makes a variable called user available in the template with the value of g.user. This example is not very interesting because g is available in templates anyways, but it gives an idea how this works. Variables are not limited to values; a context processor can also make functions available to templates (since Python allows passing around functions): @app.context_processor\ndef utility_processor():\n    def format_price(amount, currency=\"\u20ac\"):\n        return f\"{amount:.2f}{currency}\"\n    return dict(format_price=format_price)\n The context processor above makes the format_price function available to all templates: {{ format_price(0.33) }}\n You could also build format_price as a template filter (see Registering Filters), but this demonstrates how to pass functions in a context processor.\n"}, {"name": "TEMPLATES_AUTO_RELOAD", "path": "config/index#TEMPLATES_AUTO_RELOAD", "type": "Configuration", "text": " \nTEMPLATES_AUTO_RELOAD  \nReload templates when they are changed. If not set, it will be enabled in debug mode. Default: None \n"}, {"name": "TESTING", "path": "config/index#TESTING", "type": "Configuration", "text": " \nTESTING  \nEnable testing mode. Exceptions are propagated rather than handled by the the app\u2019s error handlers. Extensions may also change their behavior to facilitate easier testing. You should enable this in your own tests. Default: False \n"}, {"name": "Testing Flask Applications", "path": "testing/index", "type": "User\u2019s Guide", "text": "Testing Flask Applications Something that is untested is broken. The origin of this quote is unknown and while it is not entirely correct, it is also not far from the truth. Untested applications make it hard to improve existing code and developers of untested applications tend to become pretty paranoid. If an application has automated tests, you can safely make changes and instantly know if anything breaks. Flask provides a way to test your application by exposing the Werkzeug test Client and handling the context locals for you. You can then use that with your favourite testing solution. In this documentation we will use the pytest package as the base framework for our tests. You can install it with pip, like so: $ pip install pytest\n The Application First, we need an application to test; we will use the application from the Tutorial. If you don\u2019t have that application yet, get the source code from the examples. So that we can import the module flaskr correctly, we need to run pip install -e . in the folder tutorial. The Testing Skeleton We begin by adding a tests directory under the application root. Then create a Python file to store our tests (test_flaskr.py). When we format the filename like test_*.py, it will be auto-discoverable by pytest. Next, we create a pytest fixture called client() that configures the application for testing and initializes a new database: import os\nimport tempfile\n\nimport pytest\n\nfrom flaskr import create_app\n\n\n@pytest.fixture\ndef client():\n    db_fd, flaskr.app.config['DATABASE'] = tempfile.mkstemp()\n    flaskr.app.config['TESTING'] = True\n\n    with flaskr.app.test_client() as client:\n        with flaskr.app.app_context():\n            flaskr.init_db()\n        yield client\n\n    os.close(db_fd)\n    os.unlink(flaskr.app.config['DATABASE'])\n This client fixture will be called by each individual test. It gives us a simple interface to the application, where we can trigger test requests to the application. The client will also keep track of cookies for us. During setup, the TESTING config flag is activated. What this does is disable error catching during request handling, so that you get better error reports when performing test requests against the application. Because SQLite3 is filesystem-based, we can easily use the tempfile module to create a temporary database and initialize it. The mkstemp() function does two things for us: it returns a low-level file handle and a random file name, the latter we use as database name. We just have to keep the db_fd around so that we can use the os.close() function to close the file. To delete the database after the test, the fixture closes the file and removes it from the filesystem. If we now run the test suite, we should see the following output: $ pytest\n\n================ test session starts ================\nrootdir: ./flask/examples/flaskr, inifile: setup.cfg\ncollected 0 items\n\n=========== no tests ran in 0.07 seconds ============\n Even though it did not run any actual tests, we already know that our flaskr application is syntactically valid, otherwise the import would have died with an exception. The First Test Now it\u2019s time to start testing the functionality of the application. Let\u2019s check that the application shows \u201cNo entries here so far\u201d if we access the root of the application (/). To do this, we add a new test function to test_flaskr.py, like this: def test_empty_db(client):\n    \"\"\"Start with a blank database.\"\"\"\n\n    rv = client.get('/')\n    assert b'No entries here so far' in rv.data\n Notice that our test functions begin with the word test; this allows pytest to automatically identify the function as a test to run. By using client.get we can send an HTTP GET request to the application with the given path. The return value will be a response_class object. We can now use the data attribute to inspect the return value (as string) from the application. In this case, we ensure that 'No entries here so far' is part of the output. Run it again and you should see one passing test: $ pytest -v\n\n================ test session starts ================\nrootdir: ./flask/examples/flaskr, inifile: setup.cfg\ncollected 1 items\n\ntests/test_flaskr.py::test_empty_db PASSED\n\n============= 1 passed in 0.10 seconds ==============\n Logging In and Out The majority of the functionality of our application is only available for the administrative user, so we need a way to log our test client in and out of the application. To do this, we fire some requests to the login and logout pages with the required form data (username and password). And because the login and logout pages redirect, we tell the client to follow_redirects. Add the following two functions to your test_flaskr.py file: def login(client, username, password):\n    return client.post('/login', data=dict(\n        username=username,\n        password=password\n    ), follow_redirects=True)\n\n\ndef logout(client):\n    return client.get('/logout', follow_redirects=True)\n Now we can easily test that logging in and out works and that it fails with invalid credentials. Add this new test function: def test_login_logout(client):\n    \"\"\"Make sure login and logout works.\"\"\"\n\n    username = flaskr.app.config[\"USERNAME\"]\n    password = flaskr.app.config[\"PASSWORD\"]\n\n    rv = login(client, username, password)\n    assert b'You were logged in' in rv.data\n\n    rv = logout(client)\n    assert b'You were logged out' in rv.data\n\n    rv = login(client, f\"{username}x\", password)\n    assert b'Invalid username' in rv.data\n\n    rv = login(client, username, f'{password}x')\n    assert b'Invalid password' in rv.data\n Test Adding Messages We should also test that adding messages works. Add a new test function like this: def test_messages(client):\n    \"\"\"Test that messages work.\"\"\"\n\n    login(client, flaskr.app.config['USERNAME'], flaskr.app.config['PASSWORD'])\n    rv = client.post('/add', data=dict(\n        title='<Hello>',\n        text='<strong>HTML</strong> allowed here'\n    ), follow_redirects=True)\n    assert b'No entries here so far' not in rv.data\n    assert b'&lt;Hello&gt;' in rv.data\n    assert b'<strong>HTML</strong> allowed here' in rv.data\n Here we check that HTML is allowed in the text but not in the title, which is the intended behavior. Running that should now give us three passing tests: $ pytest -v\n\n================ test session starts ================\nrootdir: ./flask/examples/flaskr, inifile: setup.cfg\ncollected 3 items\n\ntests/test_flaskr.py::test_empty_db PASSED\ntests/test_flaskr.py::test_login_logout PASSED\ntests/test_flaskr.py::test_messages PASSED\n\n============= 3 passed in 0.23 seconds ==============\n Other Testing Tricks Besides using the test client as shown above, there is also the test_request_context() method that can be used in combination with the with statement to activate a request context temporarily. With this you can access the request, g and session objects like in view functions. Here is a full example that demonstrates this approach: import flask\n\napp = flask.Flask(__name__)\n\nwith app.test_request_context('/?name=Peter'):\n    assert flask.request.path == '/'\n    assert flask.request.args['name'] == 'Peter'\n All the other objects that are context bound can be used in the same way. If you want to test your application with different configurations and there does not seem to be a good way to do that, consider switching to application factories (see Application Factories). Note however that if you are using a test request context, the before_request() and after_request() functions are not called automatically. However teardown_request() functions are indeed executed when the test request context leaves the with block. If you do want the before_request() functions to be called as well, you need to call preprocess_request() yourself: app = flask.Flask(__name__)\n\nwith app.test_request_context('/?name=Peter'):\n    app.preprocess_request()\n    ...\n This can be necessary to open database connections or something similar depending on how your application was designed. If you want to call the after_request() functions you need to call into process_response() which however requires that you pass it a response object: app = flask.Flask(__name__)\n\nwith app.test_request_context('/?name=Peter'):\n    resp = Response('...')\n    resp = app.process_response(resp)\n    ...\n This in general is less useful because at that point you can directly start using the test client. Faking Resources and Context  Changelog New in version 0.10.  A very common pattern is to store user authorization information and database connections on the application context or the flask.g object. The general pattern for this is to put the object on there on first usage and then to remove it on a teardown. Imagine for instance this code to get the current user: def get_user():\n    user = getattr(g, 'user', None)\n    if user is None:\n        user = fetch_current_user_from_database()\n        g.user = user\n    return user\n For a test it would be nice to override this user from the outside without having to change some code. This can be accomplished with hooking the flask.appcontext_pushed signal: from contextlib import contextmanager\nfrom flask import appcontext_pushed, g\n\n@contextmanager\ndef user_set(app, user):\n    def handler(sender, **kwargs):\n        g.user = user\n    with appcontext_pushed.connected_to(handler, app):\n        yield\n And then to use it: from flask import json, jsonify\n\n@app.route('/users/me')\ndef users_me():\n    return jsonify(username=g.user.username)\n\nwith user_set(app, my_user):\n    with app.test_client() as c:\n        resp = c.get('/users/me')\n        data = json.loads(resp.data)\n        assert data['username'] == my_user.username\n Keeping the Context Around  Changelog New in version 0.4.  Sometimes it is helpful to trigger a regular request but still keep the context around for a little longer so that additional introspection can happen. With Flask 0.4 this is possible by using the test_client() with a with block: app = flask.Flask(__name__)\n\nwith app.test_client() as c:\n    rv = c.get('/?tequila=42')\n    assert request.args['tequila'] == '42'\n If you were to use just the test_client() without the with block, the assert would fail with an error because request is no longer available (because you are trying to use it outside of the actual request). Accessing and Modifying Sessions  Changelog New in version 0.8.  Sometimes it can be very helpful to access or modify the sessions from the test client. Generally there are two ways for this. If you just want to ensure that a session has certain keys set to certain values you can just keep the context around and access flask.session: with app.test_client() as c:\n    rv = c.get('/')\n    assert flask.session['foo'] == 42\n This however does not make it possible to also modify the session or to access the session before a request was fired. Starting with Flask 0.8 we provide a so called \u201csession transaction\u201d which simulates the appropriate calls to open a session in the context of the test client and to modify it. At the end of the transaction the session is stored and ready to be used by the test client. This works independently of the session backend used: with app.test_client() as c:\n    with c.session_transaction() as sess:\n        sess['a_key'] = 'a value'\n\n    # once this is reached the session was stored and ready to be used by the client\n    c.get(...)\n Note that in this case you have to use the sess object instead of the flask.session proxy. The object however itself will provide the same interface. Testing JSON APIs  Changelog New in version 1.0.  Flask has great support for JSON, and is a popular choice for building JSON APIs. Making requests with JSON data and examining JSON data in responses is very convenient: from flask import request, jsonify\n\n@app.route('/api/auth')\ndef auth():\n    json_data = request.get_json()\n    email = json_data['email']\n    password = json_data['password']\n    return jsonify(token=generate_token(email, password))\n\nwith app.test_client() as c:\n    rv = c.post('/api/auth', json={\n        'email': 'flask@example.com', 'password': 'secret'\n    })\n    json_data = rv.get_json()\n    assert verify_token(email, json_data['token'])\n Passing the json argument in the test client methods sets the request data to the JSON-serialized object and sets the content type to application/json. You can get the JSON data from the request or response with get_json. Testing CLI Commands Click comes with utilities for testing your CLI commands. A CliRunner runs commands in isolation and captures the output in a Result object. Flask provides test_cli_runner() to create a FlaskCliRunner that passes the Flask app to the CLI automatically. Use its invoke() method to call commands in the same way they would be called from the command line. import click\n\n@app.cli.command('hello')\n@click.option('--name', default='World')\ndef hello_command(name):\n    click.echo(f'Hello, {name}!')\n\ndef test_hello():\n    runner = app.test_cli_runner()\n\n    # invoke the command directly\n    result = runner.invoke(hello_command, ['--name', 'Flask'])\n    assert 'Hello, Flask' in result.output\n\n    # or by name\n    result = runner.invoke(args=['hello'])\n    assert 'World' in result.output\n In the example above, invoking the command by name is useful because it verifies that the command was correctly registered with the app. If you want to test how your command parses parameters, without running the command, use its make_context() method. This is useful for testing complex validation rules and custom types. def upper(ctx, param, value):\n    if value is not None:\n        return value.upper()\n\n@app.cli.command('hello')\n@click.option('--name', default='World', callback=upper)\ndef hello_command(name):\n    click.echo(f'Hello, {name}!')\n\ndef test_hello_params():\n    context = hello_command.make_context('hello', ['--name', 'flask'])\n    assert context.params['name'] == 'FLASK'\n\n"}, {"name": "The Application Context", "path": "appcontext/index", "type": "User\u2019s Guide", "text": "The Application Context The application context keeps track of the application-level data during a request, CLI command, or other activity. Rather than passing the application around to each function, the current_app and g proxies are accessed instead. This is similar to the The Request Context, which keeps track of request-level data during a request. A corresponding application context is pushed when a request context is pushed. Purpose of the Context The Flask application object has attributes, such as config, that are useful to access within views and CLI commands. However, importing the app instance within the modules in your project is prone to circular import issues. When using the app factory pattern or writing reusable blueprints or extensions there won\u2019t be an app instance to import at all. Flask solves this issue with the application context. Rather than referring to an app directly, you use the current_app proxy, which points to the application handling the current activity. Flask automatically pushes an application context when handling a request. View functions, error handlers, and other functions that run during a request will have access to current_app. Flask will also automatically push an app context when running CLI commands registered with Flask.cli using @app.cli.command(). Lifetime of the Context The application context is created and destroyed as necessary. When a Flask application begins handling a request, it pushes an application context and a request context. When the request ends it pops the request context then the application context. Typically, an application context will have the same lifetime as a request. See The Request Context for more information about how the contexts work and the full life cycle of a request. Manually Push a Context If you try to access current_app, or anything that uses it, outside an application context, you\u2019ll get this error message: RuntimeError: Working outside of application context.\n\nThis typically means that you attempted to use functionality that\nneeded to interface with the current application object in some way.\nTo solve this, set up an application context with app.app_context().\n If you see that error while configuring your application, such as when initializing an extension, you can push a context manually since you have direct access to the app. Use app_context() in a with block, and everything that runs in the block will have access to current_app. def create_app():\n    app = Flask(__name__)\n\n    with app.app_context():\n        init_db()\n\n    return app\n If you see that error somewhere else in your code not related to configuring the application, it most likely indicates that you should move that code into a view function or CLI command. Storing Data The application context is a good place to store common data during a request or CLI command. Flask provides the g object for this purpose. It is a simple namespace object that has the same lifetime as an application context.  Note The g name stands for \u201cglobal\u201d, but that is referring to the data being global within a context. The data on g is lost after the context ends, and it is not an appropriate place to store data between requests. Use the session or a database to store data across requests.  A common use for g is to manage resources during a request.  \nget_X() creates resource X if it does not exist, caching it as g.X. \nteardown_X() closes or otherwise deallocates the resource if it exists. It is registered as a teardown_appcontext() handler.  For example, you can manage a database connection using this pattern: from flask import g\n\ndef get_db():\n    if 'db' not in g:\n        g.db = connect_to_database()\n\n    return g.db\n\n@app.teardown_appcontext\ndef teardown_db(exception):\n    db = g.pop('db', None)\n\n    if db is not None:\n        db.close()\n During a request, every call to get_db() will return the same connection, and it will be closed automatically at the end of the request. You can use LocalProxy to make a new context local from get_db(): from werkzeug.local import LocalProxy\ndb = LocalProxy(get_db)\n Accessing db will call get_db internally, in the same way that current_app works. If you\u2019re writing an extension, g should be reserved for user code. You may store internal data on the context itself, but be sure to use a sufficiently unique name. The current context is accessed with _app_ctx_stack.top. For more information see Flask Extension Development. Events and Signals The application will call functions registered with teardown_appcontext() when the application context is popped. If signals_available is true, the following signals are sent: appcontext_pushed, appcontext_tearing_down, and appcontext_popped.\n"}, {"name": "The Request Context", "path": "reqcontext/index", "type": "User\u2019s Guide", "text": "The Request Context The request context keeps track of the request-level data during a request. Rather than passing the request object to each function that runs during a request, the request and session proxies are accessed instead. This is similar to the The Application Context, which keeps track of the application-level data independent of a request. A corresponding application context is pushed when a request context is pushed. Purpose of the Context When the Flask application handles a request, it creates a Request object based on the environment it received from the WSGI server. Because a worker (thread, process, or coroutine depending on the server) handles only one request at a time, the request data can be considered global to that worker during that request. Flask uses the term context local for this. Flask automatically pushes a request context when handling a request. View functions, error handlers, and other functions that run during a request will have access to the request proxy, which points to the request object for the current request. Lifetime of the Context When a Flask application begins handling a request, it pushes a request context, which also pushes an The Application Context. When the request ends it pops the request context then the application context. The context is unique to each thread (or other worker type). request cannot be passed to another thread, the other thread will have a different context stack and will not know about the request the parent thread was pointing to. Context locals are implemented in Werkzeug. See Context Locals for more information on how this works internally. Manually Push a Context If you try to access request, or anything that uses it, outside a request context, you\u2019ll get this error message: RuntimeError: Working outside of request context.\n\nThis typically means that you attempted to use functionality that\nneeded an active HTTP request. Consult the documentation on testing\nfor information about how to avoid this problem.\n This should typically only happen when testing code that expects an active request. One option is to use the test client to simulate a full request. Or you can use test_request_context() in a with block, and everything that runs in the block will have access to request, populated with your test data. def generate_report(year):\n    format = request.args.get('format')\n    ...\n\nwith app.test_request_context(\n        '/make_report/2017', data={'format': 'short'}):\n    generate_report()\n If you see that error somewhere else in your code not related to testing, it most likely indicates that you should move that code into a view function. For information on how to use the request context from the interactive Python shell, see Working with the Shell. How the Context Works The Flask.wsgi_app() method is called to handle each request. It manages the contexts during the request. Internally, the request and application contexts work as stacks, _request_ctx_stack and _app_ctx_stack. When contexts are pushed onto the stack, the proxies that depend on them are available and point at information from the top context on the stack. When the request starts, a RequestContext is created and pushed, which creates and pushes an AppContext first if a context for that application is not already the top context. While these contexts are pushed, the current_app, g, request, and session proxies are available to the original thread handling the request. Because the contexts are stacks, other contexts may be pushed to change the proxies during a request. While this is not a common pattern, it can be used in advanced applications to, for example, do internal redirects or chain different applications together. After the request is dispatched and a response is generated and sent, the request context is popped, which then pops the application context. Immediately before they are popped, the teardown_request() and teardown_appcontext() functions are executed. These execute even if an unhandled exception occurred during dispatch. Callbacks and Errors Flask dispatches a request in multiple stages which can affect the request, response, and how errors are handled. The contexts are active during all of these stages. A Blueprint can add handlers for these events that are specific to the blueprint. The handlers for a blueprint will run if the blueprint owns the route that matches the request.  Before each request, before_request() functions are called. If one of these functions return a value, the other functions are skipped. The return value is treated as the response and the view function is not called. If the before_request() functions did not return a response, the view function for the matched route is called and returns a response. The return value of the view is converted into an actual response object and passed to the after_request() functions. Each function returns a modified or new response object. After the response is returned, the contexts are popped, which calls the teardown_request() and teardown_appcontext() functions. These functions are called even if an unhandled exception was raised at any point above.  If an exception is raised before the teardown functions, Flask tries to match it with an errorhandler() function to handle the exception and return a response. If no error handler is found, or the handler itself raises an exception, Flask returns a generic 500 Internal Server Error response. The teardown functions are still called, and are passed the exception object. If debug mode is enabled, unhandled exceptions are not converted to a 500 response and instead are propagated to the WSGI server. This allows the development server to present the interactive debugger with the traceback. Teardown Callbacks The teardown callbacks are independent of the request dispatch, and are instead called by the contexts when they are popped. The functions are called even if there is an unhandled exception during dispatch, and for manually pushed contexts. This means there is no guarantee that any other parts of the request dispatch have run first. Be sure to write these functions in a way that does not depend on other callbacks and will not fail. During testing, it can be useful to defer popping the contexts after the request ends, so that their data can be accessed in the test function. Use the test_client() as a with block to preserve the contexts until the with block exits. from flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/')\ndef hello():\n    print('during view')\n    return 'Hello, World!'\n\n@app.teardown_request\ndef show_teardown(exception):\n    print('after with block')\n\nwith app.test_request_context():\n    print('during with block')\n\n# teardown functions are called after the context with block exits\n\nwith app.test_client() as client:\n    client.get('/')\n    # the contexts are not popped even though the request ended\n    print(request.path)\n\n# the contexts are popped and teardown functions are called after\n# the client with block exits\n Signals If signals_available is true, the following signals are sent:  \nrequest_started is sent before the before_request() functions are called. \nrequest_finished is sent after the after_request() functions are called. \ngot_request_exception is sent when an exception begins to be handled, but before an errorhandler() is looked up or called. \nrequest_tearing_down is sent after the teardown_request() functions are called.  Context Preservation on Error At the end of a request, the request context is popped and all data associated with it is destroyed. If an error occurs during development, it is useful to delay destroying the data for debugging purposes. When the development server is running in development mode (the FLASK_ENV environment variable is set to 'development'), the error and data will be preserved and shown in the interactive debugger. This behavior can be controlled with the PRESERVE_CONTEXT_ON_EXCEPTION config. As described above, it defaults to True in the development environment. Do not enable PRESERVE_CONTEXT_ON_EXCEPTION in production, as it will cause your application to leak memory on exceptions. Notes On Proxies Some of the objects provided by Flask are proxies to other objects. The proxies are accessed in the same way for each worker thread, but point to the unique object bound to each worker behind the scenes as described on this page. Most of the time you don\u2019t have to care about that, but there are some exceptions where it is good to know that this object is actually a proxy:  The proxy objects cannot fake their type as the actual object types. If you want to perform instance checks, you have to do that on the object being proxied. The reference to the proxied object is needed in some situations, such as sending Signals or passing data to a background thread.  If you need to access the underlying object that is proxied, use the _get_current_object() method: app = current_app._get_current_object()\nmy_signal.send(app)\n\n"}, {"name": "TRAP_BAD_REQUEST_ERRORS", "path": "config/index#TRAP_BAD_REQUEST_ERRORS", "type": "Configuration", "text": " \nTRAP_BAD_REQUEST_ERRORS  \nTrying to access a key that doesn\u2019t exist from request dicts like args and form will return a 400 Bad Request error page. Enable this to treat the error as an unhandled exception instead so that you get the interactive debugger. This is a more specific version of TRAP_HTTP_EXCEPTIONS. If unset, it is enabled in debug mode. Default: None \n"}, {"name": "TRAP_HTTP_EXCEPTIONS", "path": "config/index#TRAP_HTTP_EXCEPTIONS", "type": "Configuration", "text": " \nTRAP_HTTP_EXCEPTIONS  \nIf there is no handler for an HTTPException-type exception, re-raise it to be handled by the interactive debugger instead of returning it as a simple error response. Default: False \n"}, {"name": "Uploading Files", "path": "patterns/fileuploads/index", "type": "User's Guide: Design Patterns", "text": "Uploading Files Ah yes, the good old problem of file uploads. The basic idea of file uploads is actually quite simple. It basically works like this:  A <form> tag is marked with enctype=multipart/form-data and an <input type=file> is placed in that form. The application accesses the file from the files dictionary on the request object. use the save() method of the file to save the file permanently somewhere on the filesystem.  A Gentle Introduction Let\u2019s start with a very basic application that uploads a file to a specific upload folder and displays a file to the user. Let\u2019s look at the bootstrapping code for our application: import os\nfrom flask import Flask, flash, request, redirect, url_for\nfrom werkzeug.utils import secure_filename\n\nUPLOAD_FOLDER = '/path/to/the/uploads'\nALLOWED_EXTENSIONS = {'txt', 'pdf', 'png', 'jpg', 'jpeg', 'gif'}\n\napp = Flask(__name__)\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\n So first we need a couple of imports. Most should be straightforward, the werkzeug.secure_filename() is explained a little bit later. The UPLOAD_FOLDER is where we will store the uploaded files and the ALLOWED_EXTENSIONS is the set of allowed file extensions. Why do we limit the extensions that are allowed? You probably don\u2019t want your users to be able to upload everything there if the server is directly sending out the data to the client. That way you can make sure that users are not able to upload HTML files that would cause XSS problems (see Cross-Site Scripting (XSS)). Also make sure to disallow .php files if the server executes them, but who has PHP installed on their server, right? :) Next the functions that check if an extension is valid and that uploads the file and redirects the user to the URL for the uploaded file: def allowed_file(filename):\n    return '.' in filename and \\\n           filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\n\n@app.route('/', methods=['GET', 'POST'])\ndef upload_file():\n    if request.method == 'POST':\n        # check if the post request has the file part\n        if 'file' not in request.files:\n            flash('No file part')\n            return redirect(request.url)\n        file = request.files['file']\n        # If the user does not select a file, the browser submits an\n        # empty file without a filename.\n        if file.filename == '':\n            flash('No selected file')\n            return redirect(request.url)\n        if file and allowed_file(file.filename):\n            filename = secure_filename(file.filename)\n            file.save(os.path.join(app.config['UPLOAD_FOLDER'], filename))\n            return redirect(url_for('download_file', name=filename))\n    return '''\n    <!doctype html>\n    <title>Upload new File</title>\n    <h1>Upload new File</h1>\n    <form method=post enctype=multipart/form-data>\n      <input type=file name=file>\n      <input type=submit value=Upload>\n    </form>\n    '''\n So what does that secure_filename() function actually do? Now the problem is that there is that principle called \u201cnever trust user input\u201d. This is also true for the filename of an uploaded file. All submitted form data can be forged, and filenames can be dangerous. For the moment just remember: always use that function to secure a filename before storing it directly on the filesystem.  Information for the Pros So you\u2019re interested in what that secure_filename() function does and what the problem is if you\u2019re not using it? So just imagine someone would send the following information as filename to your application: filename = \"../../../../home/username/.bashrc\"\n Assuming the number of ../ is correct and you would join this with the UPLOAD_FOLDER the user might have the ability to modify a file on the server\u2019s filesystem he or she should not modify. This does require some knowledge about how the application looks like, but trust me, hackers are patient :) Now let\u2019s look how that function works: >>> secure_filename('../../../../home/username/.bashrc')\n'home_username_.bashrc'\n  We want to be able to serve the uploaded files so they can be downloaded by users. We\u2019ll define a download_file view to serve files in the upload folder by name. url_for(\"download_file\", name=name) generates download URLs. from flask import send_from_directory\n\n@app.route('/uploads/<name>')\ndef download_file(name):\n    return send_from_directory(app.config[\"UPLOAD_FOLDER\"], name)\n If you\u2019re using middleware or the HTTP server to serve files, you can register the download_file endpoint as build_only so url_for will work without a view function. app.add_url_rule(\n    \"/uploads/<name>\", endpoint=\"download_file\", build_only=True\n)\n Improving Uploads  Changelog New in version 0.6.  So how exactly does Flask handle uploads? Well it will store them in the webserver\u2019s memory if the files are reasonably small, otherwise in a temporary location (as returned by tempfile.gettempdir()). But how do you specify the maximum file size after which an upload is aborted? By default Flask will happily accept file uploads with an unlimited amount of memory, but you can limit that by setting the MAX_CONTENT_LENGTH config key: from flask import Flask, Request\n\napp = Flask(__name__)\napp.config['MAX_CONTENT_LENGTH'] = 16 * 1000 * 1000\n The code above will limit the maximum allowed payload to 16 megabytes. If a larger file is transmitted, Flask will raise a RequestEntityTooLarge exception.  Connection Reset Issue When using the local development server, you may get a connection reset error instead of a 413 response. You will get the correct status response when running the app with a production WSGI server.  This feature was added in Flask 0.6 but can be achieved in older versions as well by subclassing the request object. For more information on that consult the Werkzeug documentation on file handling. Upload Progress Bars A while ago many developers had the idea to read the incoming file in small chunks and store the upload progress in the database to be able to poll the progress with JavaScript from the client. The client asks the server every 5 seconds how much it has transmitted, but this is something it should already know. An Easier Solution Now there are better solutions that work faster and are more reliable. There are JavaScript libraries like jQuery that have form plugins to ease the construction of progress bar. Because the common pattern for file uploads exists almost unchanged in all applications dealing with uploads, there is also a Flask extension called Flask-Uploads that implements a full fledged upload mechanism that allows controlling which file extensions are allowed to be uploaded.\n"}, {"name": "url_for()", "path": "api/index#flask.url_for", "type": "flask", "text": " \nflask.url_for(endpoint, **values)  \nGenerates a URL to the given endpoint with the method provided. Variable arguments that are unknown to the target endpoint are appended to the generated URL as query arguments. If the value of a query argument is None, the whole pair is skipped. In case blueprints are active you can shortcut references to the same blueprint by prefixing the local endpoint with a dot (.). This will reference the index function local to the current blueprint: url_for('.index')\n See URL Building. Configuration values APPLICATION_ROOT and SERVER_NAME are only used when generating URLs outside of a request context. To integrate applications, Flask has a hook to intercept URL build errors through Flask.url_build_error_handlers. The url_for function results in a BuildError when the current app does not have a URL for the given endpoint and values. When it does, the current_app calls its url_build_error_handlers if it is not None, which can return a string to use as the result of url_for (instead of url_for\u2019s default to raise the BuildError exception) or re-raise the exception. An example: def external_url_handler(error, endpoint, values):\n    \"Looks up an external URL when `url_for` cannot build a URL.\"\n    # This is an example of hooking the build_error_handler.\n    # Here, lookup_url is some utility function you've built\n    # which looks up the endpoint in some external URL registry.\n    url = lookup_url(endpoint, **values)\n    if url is None:\n        # External lookup did not have a URL.\n        # Re-raise the BuildError, in context of original traceback.\n        exc_type, exc_value, tb = sys.exc_info()\n        if exc_value is error:\n            raise exc_type(exc_value).with_traceback(tb)\n        else:\n            raise error\n    # url_for will use this result, instead of raising BuildError.\n    return url\n\napp.url_build_error_handlers.append(external_url_handler)\n Here, error is the instance of BuildError, and endpoint and values are the arguments passed into url_for. Note that this is for building URLs outside the current application, and not for handling 404 NotFound errors.  Changelog New in version 0.10: The _scheme parameter was added.   New in version 0.9: The _anchor and _method parameters were added.   New in version 0.9: Calls Flask.handle_build_error() on BuildError.   Parameters \n \nendpoint (str) \u2013 the endpoint of the URL (name of the function) \nvalues (Any) \u2013 the variable arguments of the URL rule \n_external \u2013 if set to True, an absolute URL is generated. Server address can be changed via SERVER_NAME configuration variable which falls back to the Host header, then to the IP and port of the request. \n_scheme \u2013 a string specifying the desired URL scheme. The _external parameter must be set to True or a ValueError is raised. The default behavior uses the same scheme as the current request, or PREFERRED_URL_SCHEME if no request context is available. This also can be set to an empty string to build protocol-relative URLs. \n_anchor \u2013 if provided this is added as anchor to the URL. \n_method \u2013 if provided this explicitly specifies an HTTP method.   Return type \nstr   \n"}, {"name": "USE_X_SENDFILE", "path": "config/index#USE_X_SENDFILE", "type": "Configuration", "text": " \nUSE_X_SENDFILE  \nWhen serving files, set the X-Sendfile header instead of serving the data with Flask. Some web servers, such as Apache, recognize this and serve the data more efficiently. This only makes sense when using such a server. Default: False \n"}, {"name": "Using async and await", "path": "async-await/index", "type": "User\u2019s Guide", "text": "Using async and await  New in version 2.0.  Routes, error handlers, before request, after request, and teardown functions can all be coroutine functions if Flask is installed with the async extra (pip install flask[async]). This allows views to be defined with async def and use await. @app.route(\"/get-data\")\nasync def get_data():\n    data = await async_db_query(...)\n    return jsonify(data)\n  Using async on Windows on Python 3.8 Python 3.8 has a bug related to asyncio on Windows. If you encounter something like ValueError: set_wakeup_fd only works in main thread, please upgrade to Python 3.9.  Performance Async functions require an event loop to run. Flask, as a WSGI application, uses one worker to handle one request/response cycle. When a request comes in to an async view, Flask will start an event loop in a thread, run the view function there, then return the result. Each request still ties up one worker, even for async views. The upside is that you can run async code within a view, for example to make multiple concurrent database queries, HTTP requests to an external API, etc. However, the number of requests your application can handle at one time will remain the same. Async is not inherently faster than sync code. Async is beneficial when performing concurrent IO-bound tasks, but will probably not improve CPU-bound tasks. Traditional Flask views will still be appropriate for most use cases, but Flask\u2019s async support enables writing and using code that wasn\u2019t possible natively before. Background tasks Async functions will run in an event loop until they complete, at which stage the event loop will stop. This means any additional spawned tasks that haven\u2019t completed when the async function completes will be cancelled. Therefore you cannot spawn background tasks, for example via asyncio.create_task. If you wish to use background tasks it is best to use a task queue to trigger background work, rather than spawn tasks in a view function. With that in mind you can spawn asyncio tasks by serving Flask with an ASGI server and utilising the asgiref WsgiToAsgi adapter as described in ASGI. This works as the adapter creates an event loop that runs continually. When to use Quart instead Flask\u2019s async support is less performant than async-first frameworks due to the way it is implemented. If you have a mainly async codebase it would make sense to consider Quart. Quart is a reimplementation of Flask based on the ASGI standard instead of WSGI. This allows it to handle many concurrent requests, long running requests, and websockets without requiring multiple worker processes or threads. It has also already been possible to run Flask with Gevent or Eventlet to get many of the benefits of async request handling. These libraries patch low-level Python functions to accomplish this, whereas async/ await and ASGI use standard, modern Python capabilities. Deciding whether you should use Flask, Quart, or something else is ultimately up to understanding the specific needs of your project. Extensions Flask extensions predating Flask\u2019s async support do not expect async views. If they provide decorators to add functionality to views, those will probably not work with async views because they will not await the function or be awaitable. Other functions they provide will not be awaitable either and will probably be blocking if called within an async view. Extension authors can support async functions by utilising the flask.Flask.ensure_sync() method. For example, if the extension provides a view function decorator add ensure_sync before calling the decorated function, def extension(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        ...  # Extension logic\n        return current_app.ensure_sync(func)(*args, **kwargs)\n\n    return wrapper\n Check the changelog of the extension you want to use to see if they\u2019ve implemented async support, or make a feature request or PR to them. Other event loops At the moment Flask only supports asyncio. It\u2019s possible to override flask.Flask.ensure_sync() to change how async functions are wrapped to use a different library.\n"}, {"name": "Using SQLite 3 with Flask", "path": "patterns/sqlite3/index", "type": "User's Guide: Design Patterns", "text": "Using SQLite 3 with Flask In Flask you can easily implement the opening of database connections on demand and closing them when the context dies (usually at the end of the request). Here is a simple example of how you can use SQLite 3 with Flask: import sqlite3\nfrom flask import g\n\nDATABASE = '/path/to/database.db'\n\ndef get_db():\n    db = getattr(g, '_database', None)\n    if db is None:\n        db = g._database = sqlite3.connect(DATABASE)\n    return db\n\n@app.teardown_appcontext\ndef close_connection(exception):\n    db = getattr(g, '_database', None)\n    if db is not None:\n        db.close()\n Now, to use the database, the application must either have an active application context (which is always true if there is a request in flight) or create an application context itself. At that point the get_db function can be used to get the current database connection. Whenever the context is destroyed the database connection will be terminated. Note: if you use Flask 0.9 or older you need to use flask._app_ctx_stack.top instead of g as the flask.g object was bound to the request and not application context. Example: @app.route('/')\ndef index():\n    cur = get_db().cursor()\n    ...\n  Note Please keep in mind that the teardown request and appcontext functions are always executed, even if a before-request handler failed or was never executed. Because of this we have to make sure here that the database is there before we close it.  Connect on Demand The upside of this approach (connecting on first use) is that this will only open the connection if truly necessary. If you want to use this code outside a request context you can use it in a Python shell by opening the application context by hand: with app.app_context():\n    # now you can use get_db()\n Easy Querying Now in each request handling function you can access get_db() to get the current open database connection. To simplify working with SQLite, a row factory function is useful. It is executed for every result returned from the database to convert the result. For instance, in order to get dictionaries instead of tuples, this could be inserted into the get_db function we created above: def make_dicts(cursor, row):\n    return dict((cursor.description[idx][0], value)\n                for idx, value in enumerate(row))\n\ndb.row_factory = make_dicts\n This will make the sqlite3 module return dicts for this database connection, which are much nicer to deal with. Even more simply, we could place this in get_db instead: db.row_factory = sqlite3.Row\n This would use Row objects rather than dicts to return the results of queries. These are namedtuple s, so we can access them either by index or by key. For example, assuming we have a sqlite3.Row called r for the rows id, FirstName, LastName, and MiddleInitial: >>> # You can get values based on the row's name\n>>> r['FirstName']\nJohn\n>>> # Or, you can get them based on index\n>>> r[1]\nJohn\n# Row objects are also iterable:\n>>> for value in r:\n...     print(value)\n1\nJohn\nDoe\nM\n Additionally, it is a good idea to provide a query function that combines getting the cursor, executing and fetching the results: def query_db(query, args=(), one=False):\n    cur = get_db().execute(query, args)\n    rv = cur.fetchall()\n    cur.close()\n    return (rv[0] if rv else None) if one else rv\n This handy little function, in combination with a row factory, makes working with the database much more pleasant than it is by just using the raw cursor and connection objects. Here is how you can use it: for user in query_db('select * from users'):\n    print user['username'], 'has the id', user['user_id']\n Or if you just want a single result: user = query_db('select * from users where username = ?',\n                [the_username], one=True)\nif user is None:\n    print 'No such user'\nelse:\n    print the_username, 'has the id', user['user_id']\n To pass variable parts to the SQL statement, use a question mark in the statement and pass in the arguments as a list. Never directly add them to the SQL statement with string formatting because this makes it possible to attack the application using SQL Injections. Initial Schemas Relational databases need schemas, so applications often ship a schema.sql file that creates the database. It\u2019s a good idea to provide a function that creates the database based on that schema. This function can do that for you: def init_db():\n    with app.app_context():\n        db = get_db()\n        with app.open_resource('schema.sql', mode='r') as f:\n            db.cursor().executescript(f.read())\n        db.commit()\n You can then create such a database from the Python shell: >>> from yourapplication import init_db\n>>> init_db()\n\n"}, {"name": "Using URL Processors", "path": "patterns/urlprocessors/index", "type": "User's Guide: Design Patterns", "text": "Using URL Processors  Changelog New in version 0.7.  Flask 0.7 introduces the concept of URL processors. The idea is that you might have a bunch of resources with common parts in the URL that you don\u2019t always explicitly want to provide. For instance you might have a bunch of URLs that have the language code in it but you don\u2019t want to have to handle it in every single function yourself. URL processors are especially helpful when combined with blueprints. We will handle both application specific URL processors here as well as blueprint specifics. Internationalized Application URLs Consider an application like this: from flask import Flask, g\n\napp = Flask(__name__)\n\n@app.route('/<lang_code>/')\ndef index(lang_code):\n    g.lang_code = lang_code\n    ...\n\n@app.route('/<lang_code>/about')\ndef about(lang_code):\n    g.lang_code = lang_code\n    ...\n This is an awful lot of repetition as you have to handle the language code setting on the g object yourself in every single function. Sure, a decorator could be used to simplify this, but if you want to generate URLs from one function to another you would have to still provide the language code explicitly which can be annoying. For the latter, this is where url_defaults() functions come in. They can automatically inject values into a call to url_for(). The code below checks if the language code is not yet in the dictionary of URL values and if the endpoint wants a value named 'lang_code': @app.url_defaults\ndef add_language_code(endpoint, values):\n    if 'lang_code' in values or not g.lang_code:\n        return\n    if app.url_map.is_endpoint_expecting(endpoint, 'lang_code'):\n        values['lang_code'] = g.lang_code\n The method is_endpoint_expecting() of the URL map can be used to figure out if it would make sense to provide a language code for the given endpoint. The reverse of that function are url_value_preprocessor()s. They are executed right after the request was matched and can execute code based on the URL values. The idea is that they pull information out of the values dictionary and put it somewhere else: @app.url_value_preprocessor\ndef pull_lang_code(endpoint, values):\n    g.lang_code = values.pop('lang_code', None)\n That way you no longer have to do the lang_code assignment to g in every function. You can further improve that by writing your own decorator that prefixes URLs with the language code, but the more beautiful solution is using a blueprint. Once the 'lang_code' is popped from the values dictionary and it will no longer be forwarded to the view function reducing the code to this: from flask import Flask, g\n\napp = Flask(__name__)\n\n@app.url_defaults\ndef add_language_code(endpoint, values):\n    if 'lang_code' in values or not g.lang_code:\n        return\n    if app.url_map.is_endpoint_expecting(endpoint, 'lang_code'):\n        values['lang_code'] = g.lang_code\n\n@app.url_value_preprocessor\ndef pull_lang_code(endpoint, values):\n    g.lang_code = values.pop('lang_code', None)\n\n@app.route('/<lang_code>/')\ndef index():\n    ...\n\n@app.route('/<lang_code>/about')\ndef about():\n    ...\n Internationalized Blueprint URLs Because blueprints can automatically prefix all URLs with a common string it\u2019s easy to automatically do that for every function. Furthermore blueprints can have per-blueprint URL processors which removes a whole lot of logic from the url_defaults() function because it no longer has to check if the URL is really interested in a 'lang_code' parameter: from flask import Blueprint, g\n\nbp = Blueprint('frontend', __name__, url_prefix='/<lang_code>')\n\n@bp.url_defaults\ndef add_language_code(endpoint, values):\n    values.setdefault('lang_code', g.lang_code)\n\n@bp.url_value_preprocessor\ndef pull_lang_code(endpoint, values):\n    g.lang_code = values.pop('lang_code')\n\n@bp.route('/')\ndef index():\n    ...\n\n@bp.route('/about')\ndef about():\n    ...\n\n"}, {"name": "uWSGI", "path": "deploying/uwsgi/index", "type": "User's Guide: Deploying", "text": "uWSGI uWSGI is a deployment option on servers like nginx, lighttpd, and cherokee; see FastCGI and Standalone WSGI Containers for other options. To use your WSGI application with uWSGI protocol you will need a uWSGI server first. uWSGI is both a protocol and an application server; the application server can serve uWSGI, FastCGI, and HTTP protocols. The most popular uWSGI server is uwsgi, which we will use for this guide. Make sure to have it installed to follow along.  Watch Out Please make sure in advance that any app.run() calls you might have in your application file are inside an if __name__ ==\n'__main__': block or moved to a separate file. Just make sure it\u2019s not called because this will always start a local WSGI server which we do not want if we deploy that application to uWSGI.  Starting your app with uwsgi uwsgi is designed to operate on WSGI callables found in python modules. Given a flask application in myapp.py, use the following command: $ uwsgi -s /tmp/yourapplication.sock --manage-script-name --mount /yourapplication=myapp:app\n The --manage-script-name will move the handling of SCRIPT_NAME to uwsgi, since it is smarter about that. It is used together with the --mount directive which will make requests to /yourapplication be directed to myapp:app. If your application is accessible at root level, you can use a single / instead of /yourapplication. myapp refers to the name of the file of your flask application (without extension) or the module which provides app. app is the callable inside of your application (usually the line reads app = Flask(__name__). If you want to deploy your flask application inside of a virtual environment, you need to also add --virtualenv /path/to/virtual/environment. You might also need to add --plugin python or --plugin python3 depending on which python version you use for your project. Configuring nginx A basic flask nginx configuration looks like this: location = /yourapplication { rewrite ^ /yourapplication/; }\nlocation /yourapplication { try_files $uri @yourapplication; }\nlocation @yourapplication {\n  include uwsgi_params;\n  uwsgi_pass unix:/tmp/yourapplication.sock;\n}\n This configuration binds the application to /yourapplication. If you want to have it in the URL root its a bit simpler: location / { try_files $uri @yourapplication; }\nlocation @yourapplication {\n    include uwsgi_params;\n    uwsgi_pass unix:/tmp/yourapplication.sock;\n}\n\n"}, {"name": "View", "path": "api/index#flask.views.View", "type": "flask.views", "text": " \nclass flask.views.View  \nAlternative way to use view functions. A subclass has to implement dispatch_request() which is called with the view arguments from the URL routing system. If methods is provided the methods do not have to be passed to the add_url_rule() method explicitly: class MyView(View):\n    methods = ['GET']\n\n    def dispatch_request(self, name):\n        return f\"Hello {name}!\"\n\napp.add_url_rule('/hello/<name>', view_func=MyView.as_view('myview'))\n When you want to decorate a pluggable view you will have to either do that when the view function is created (by wrapping the return value of as_view()) or you can use the decorators attribute: class SecretView(View):\n    methods = ['GET']\n    decorators = [superuser_required]\n\n    def dispatch_request(self):\n        ...\n The decorators stored in the decorators list are applied one after another when the view function is created. Note that you can not use the class based decorators since those would decorate the view class and not the generated view function!  \nclassmethod as_view(name, *class_args, **class_kwargs)  \nConverts the class into an actual view function that can be used with the routing system. Internally this generates a function on the fly which will instantiate the View on each request and call the dispatch_request() method on it. The arguments passed to as_view() are forwarded to the constructor of the class.  Parameters \n \nname (str) \u2013  \nclass_args (Any) \u2013  \nclass_kwargs (Any) \u2013    Return type \nCallable   \n  \ndecorators: List[Callable] = []  \nThe canonical way to decorate class-based views is to decorate the return value of as_view(). However since this moves parts of the logic from the class declaration to the place where it\u2019s hooked into the routing system. You can place one or more decorators in this list and whenever the view function is created the result is automatically decorated.  Changelog New in version 0.8.  \n\n  \ndispatch_request()  \nSubclasses have to override this method to implement the actual view function code. This method is called with all the arguments from the URL rule.  Return type \nUnion[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], WSGIApplication]   \n  \nmethods: Optional[List[str]] = None  \nA list of methods this view can handle. \n  \nprovide_automatic_options: Optional[bool] = None  \nSetting this disables or force-enables the automatic options handling. \n \n"}, {"name": "View Decorators", "path": "patterns/viewdecorators/index", "type": "User's Guide: Design Patterns", "text": "View Decorators Python has a really interesting feature called function decorators. This allows some really neat things for web applications. Because each view in Flask is a function, decorators can be used to inject additional functionality to one or more functions. The route() decorator is the one you probably used already. But there are use cases for implementing your own decorator. For instance, imagine you have a view that should only be used by people that are logged in. If a user goes to the site and is not logged in, they should be redirected to the login page. This is a good example of a use case where a decorator is an excellent solution. Login Required Decorator So let\u2019s implement such a decorator. A decorator is a function that wraps and replaces another function. Since the original function is replaced, you need to remember to copy the original function\u2019s information to the new function. Use functools.wraps() to handle this for you. This example assumes that the login page is called 'login' and that the current user is stored in g.user and is None if there is no-one logged in. from functools import wraps\nfrom flask import g, request, redirect, url_for\n\ndef login_required(f):\n    @wraps(f)\n    def decorated_function(*args, **kwargs):\n        if g.user is None:\n            return redirect(url_for('login', next=request.url))\n        return f(*args, **kwargs)\n    return decorated_function\n To use the decorator, apply it as innermost decorator to a view function. When applying further decorators, always remember that the route() decorator is the outermost. @app.route('/secret_page')\n@login_required\ndef secret_page():\n    pass\n  Note The next value will exist in request.args after a GET request for the login page. You\u2019ll have to pass it along when sending the POST request from the login form. You can do this with a hidden input tag, then retrieve it from request.form when logging the user in. <input type=\"hidden\" value=\"{{ request.args.get('next', '') }}\"/>\n  Caching Decorator Imagine you have a view function that does an expensive calculation and because of that you would like to cache the generated results for a certain amount of time. A decorator would be nice for that. We\u2019re assuming you have set up a cache like mentioned in Caching. Here is an example cache function. It generates the cache key from a specific prefix (actually a format string) and the current path of the request. Notice that we are using a function that first creates the decorator that then decorates the function. Sounds awful? Unfortunately it is a little bit more complex, but the code should still be straightforward to read. The decorated function will then work as follows  get the unique cache key for the current request based on the current path. get the value for that key from the cache. If the cache returned something we will return that value. otherwise the original function is called and the return value is stored in the cache for the timeout provided (by default 5 minutes).  Here the code: from functools import wraps\nfrom flask import request\n\ndef cached(timeout=5 * 60, key='view/{}'):\n    def decorator(f):\n        @wraps(f)\n        def decorated_function(*args, **kwargs):\n            cache_key = key.format(request.path)\n            rv = cache.get(cache_key)\n            if rv is not None:\n                return rv\n            rv = f(*args, **kwargs)\n            cache.set(cache_key, rv, timeout=timeout)\n            return rv\n        return decorated_function\n    return decorator\n Notice that this assumes an instantiated cache object is available, see Caching. Templating Decorator A common pattern invented by the TurboGears guys a while back is a templating decorator. The idea of that decorator is that you return a dictionary with the values passed to the template from the view function and the template is automatically rendered. With that, the following three examples do exactly the same: @app.route('/')\ndef index():\n    return render_template('index.html', value=42)\n\n@app.route('/')\n@templated('index.html')\ndef index():\n    return dict(value=42)\n\n@app.route('/')\n@templated()\ndef index():\n    return dict(value=42)\n As you can see, if no template name is provided it will use the endpoint of the URL map with dots converted to slashes + '.html'. Otherwise the provided template name is used. When the decorated function returns, the dictionary returned is passed to the template rendering function. If None is returned, an empty dictionary is assumed, if something else than a dictionary is returned we return it from the function unchanged. That way you can still use the redirect function or return simple strings. Here is the code for that decorator: from functools import wraps\nfrom flask import request, render_template\n\ndef templated(template=None):\n    def decorator(f):\n        @wraps(f)\n        def decorated_function(*args, **kwargs):\n            template_name = template\n            if template_name is None:\n                template_name = f\"'{request.endpoint.replace('.', '/')}.html'\"\n            ctx = f(*args, **kwargs)\n            if ctx is None:\n                ctx = {}\n            elif not isinstance(ctx, dict):\n                return ctx\n            return render_template(template_name, **ctx)\n        return decorated_function\n    return decorator\n Endpoint Decorator When you want to use the werkzeug routing system for more flexibility you need to map the endpoint as defined in the Rule to a view function. This is possible with this decorator. For example: from flask import Flask\nfrom werkzeug.routing import Rule\n\napp = Flask(__name__)\napp.url_map.add(Rule('/', endpoint='index'))\n\n@app.endpoint('index')\ndef my_index():\n    return \"Hello world\"\n\n"}, {"name": "View.as_view()", "path": "api/index#flask.views.View.as_view", "type": "flask.views", "text": " \nclassmethod as_view(name, *class_args, **class_kwargs)  \nConverts the class into an actual view function that can be used with the routing system. Internally this generates a function on the fly which will instantiate the View on each request and call the dispatch_request() method on it. The arguments passed to as_view() are forwarded to the constructor of the class.  Parameters \n \nname (str) \u2013  \nclass_args (Any) \u2013  \nclass_kwargs (Any) \u2013    Return type \nCallable   \n"}, {"name": "View.decorators", "path": "api/index#flask.views.View.decorators", "type": "flask.views", "text": " \ndecorators: List[Callable] = []  \nThe canonical way to decorate class-based views is to decorate the return value of as_view(). However since this moves parts of the logic from the class declaration to the place where it\u2019s hooked into the routing system. You can place one or more decorators in this list and whenever the view function is created the result is automatically decorated.  Changelog New in version 0.8.  \n\n"}, {"name": "View.dispatch_request()", "path": "api/index#flask.views.View.dispatch_request", "type": "flask.views", "text": " \ndispatch_request()  \nSubclasses have to override this method to implement the actual view function code. This method is called with all the arguments from the URL rule.  Return type \nUnion[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], WSGIApplication]   \n"}, {"name": "View.methods", "path": "api/index#flask.views.View.methods", "type": "flask.views", "text": " \nmethods: Optional[List[str]] = None  \nA list of methods this view can handle. \n"}, {"name": "View.provide_automatic_options", "path": "api/index#flask.views.View.provide_automatic_options", "type": "flask.views", "text": " \nprovide_automatic_options: Optional[bool] = None  \nSetting this disables or force-enables the automatic options handling. \n"}, {"name": "with_appcontext()", "path": "api/index#flask.cli.with_appcontext", "type": "flask.cli", "text": " \nflask.cli.with_appcontext(f)  \nWraps a callback so that it\u2019s guaranteed to be executed with the script\u2019s application context. If callbacks are registered directly to the app.cli object then they are wrapped with this function by default unless it\u2019s disabled. \n"}, {"name": "Working with the Shell", "path": "shell/index", "type": "User\u2019s Guide", "text": "Working with the Shell  Changelog New in version 0.3.  One of the reasons everybody loves Python is the interactive shell. It basically allows you to execute Python commands in real time and immediately get results back. Flask itself does not come with an interactive shell, because it does not require any specific setup upfront, just import your application and start playing around. There are however some handy helpers to make playing around in the shell a more pleasant experience. The main issue with interactive console sessions is that you\u2019re not triggering a request like a browser does which means that g, request and others are not available. But the code you want to test might depend on them, so what can you do? This is where some helper functions come in handy. Keep in mind however that these functions are not only there for interactive shell usage, but also for unit testing and other situations that require a faked request context. Generally it\u2019s recommended that you read the The Request Context chapter of the documentation first. Command Line Interface Starting with Flask 0.11 the recommended way to work with the shell is the flask shell command which does a lot of this automatically for you. For instance the shell is automatically initialized with a loaded application context. For more information see Command Line Interface. Creating a Request Context The easiest way to create a proper request context from the shell is by using the test_request_context method which creates us a RequestContext: >>> ctx = app.test_request_context()\n Normally you would use the with statement to make this request object active, but in the shell it\u2019s easier to use the push() and pop() methods by hand: >>> ctx.push()\n From that point onwards you can work with the request object until you call pop: >>> ctx.pop()\n Firing Before/After Request By just creating a request context, you still don\u2019t have run the code that is normally run before a request. This might result in your database being unavailable if you are connecting to the database in a before-request callback or the current user not being stored on the g object etc. This however can easily be done yourself. Just call preprocess_request(): >>> ctx = app.test_request_context()\n>>> ctx.push()\n>>> app.preprocess_request()\n Keep in mind that the preprocess_request() function might return a response object, in that case just ignore it. To shutdown a request, you need to trick a bit before the after request functions (triggered by process_response()) operate on a response object: >>> app.process_response(app.response_class())\n<Response 0 bytes [200 OK]>\n>>> ctx.pop()\n The functions registered as teardown_request() are automatically called when the context is popped. So this is the perfect place to automatically tear down resources that were needed by the request context (such as database connections). Further Improving the Shell Experience If you like the idea of experimenting in a shell, create yourself a module with stuff you want to star import into your interactive session. There you could also define some more helper methods for common things such as initializing the database, dropping tables etc. Just put them into a module (like shelltools) and import from there: >>> from shelltools import *\n\n"}, {"name": "_AppCtxGlobals", "path": "api/index#flask.ctx._AppCtxGlobals", "type": "flask.ctx", "text": " \nclass flask.ctx._AppCtxGlobals  \nA plain object. Used as a namespace for storing data during an application context. Creating an app context automatically creates this object, which is made available as the g proxy.   'key' in g\n \nCheck whether an attribute is present.  Changelog New in version 0.10.  \n\n   iter(g)\n \nReturn an iterator over the attribute names.  Changelog New in version 0.10.  \n\n  \nget(name, default=None)  \nGet an attribute by name, or a default value. Like dict.get().  Parameters \n \nname (str) \u2013 Name of attribute to get. \ndefault (Optional[Any]) \u2013 Value to return if the attribute is not present.   Return type \nAny    Changelog New in version 0.10.  \n\n  \npop(name, default=<object object>)  \nGet and remove an attribute by name. Like dict.pop().  Parameters \n \nname (str) \u2013 Name of attribute to pop. \ndefault (Any) \u2013 Value to return if the attribute is not present, instead of raising a KeyError.   Return type \nAny    Changelog New in version 0.11.  \n\n  \nsetdefault(name, default=None)  \nGet the value of an attribute if it is present, otherwise set and return a default value. Like dict.setdefault().  Parameters \n \nname (str) \u2013 Name of attribute to get. \ndefault (Optional[Any]) \u2013 Value to set and return if the attribute is not present.   Return type \nAny    Changelog New in version 0.11.  \n\n \n"}, {"name": "_AppCtxGlobals.get()", "path": "api/index#flask.ctx._AppCtxGlobals.get", "type": "flask.ctx", "text": " \nget(name, default=None)  \nGet an attribute by name, or a default value. Like dict.get().  Parameters \n \nname (str) \u2013 Name of attribute to get. \ndefault (Optional[Any]) \u2013 Value to return if the attribute is not present.   Return type \nAny    Changelog New in version 0.10.  \n\n"}, {"name": "_AppCtxGlobals.pop()", "path": "api/index#flask.ctx._AppCtxGlobals.pop", "type": "flask.ctx", "text": " \npop(name, default=<object object>)  \nGet and remove an attribute by name. Like dict.pop().  Parameters \n \nname (str) \u2013 Name of attribute to pop. \ndefault (Any) \u2013 Value to return if the attribute is not present, instead of raising a KeyError.   Return type \nAny    Changelog New in version 0.11.  \n\n"}, {"name": "_AppCtxGlobals.setdefault()", "path": "api/index#flask.ctx._AppCtxGlobals.setdefault", "type": "flask.ctx", "text": " \nsetdefault(name, default=None)  \nGet the value of an attribute if it is present, otherwise set and return a default value. Like dict.setdefault().  Parameters \n \nname (str) \u2013 Name of attribute to get. \ndefault (Optional[Any]) \u2013 Value to set and return if the attribute is not present.   Return type \nAny    Changelog New in version 0.11.  \n\n"}]