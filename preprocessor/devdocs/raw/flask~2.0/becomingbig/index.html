<h1>Becoming Big</h1> <p>Here are your options when growing your codebase or scaling your application.</p>  <h2 id="read-the-source">Read the Source.</h2> <p>Flask started in part to demonstrate how to build your own framework on top of existing well-used tools Werkzeug (WSGI) and Jinja (templating), and as it developed, it became useful to a wide audience. As you grow your codebase, don’t just use Flask – understand it. Read the source. Flask’s code is written to be read; its documentation is published so you can use its internal APIs. Flask sticks to documented APIs in upstream libraries, and documents its internal utilities so that you can find the hook points needed for your project.</p>   <h2 id="hook-extend">Hook. Extend.</h2> <p>The <a class="reference internal" href="../api/index"><span class="doc">API</span></a> docs are full of available overrides, hook points, and <a class="reference internal" href="../signals/index"><span class="doc">Signals</span></a>. You can provide custom classes for things like the request and response objects. Dig deeper on the APIs you use, and look for the customizations which are available out of the box in a Flask release. Look for ways in which your project can be refactored into a collection of utilities and Flask extensions. Explore the many <a class="reference internal" href="../extensions/index"><span class="doc">Extensions</span></a> in the community, and look for patterns to build your own extensions if you do not find the tools you need.</p>   <h2 id="subclass">Subclass.</h2> <p>The <a class="reference internal" href="../api/index#flask.Flask" title="flask.Flask"><code>Flask</code></a> class has many methods designed for subclassing. You can quickly add or customize behavior by subclassing <a class="reference internal" href="../api/index#flask.Flask" title="flask.Flask"><code>Flask</code></a> (see the linked method docs) and using that subclass wherever you instantiate an application class. This works well with <a class="reference internal" href="../patterns/appfactories/index"><span class="doc">Application Factories</span></a>. See <a class="reference internal" href="../patterns/subclassing/index"><span class="doc">Subclassing Flask</span></a> for an example.</p>   <h2 id="wrap-with-middleware">Wrap with middleware.</h2> <p>The <a class="reference internal" href="../patterns/appdispatch/index"><span class="doc">Application Dispatching</span></a> pattern shows in detail how to apply middleware. You can introduce WSGI middleware to wrap your Flask instances and introduce fixes and changes at the layer between your Flask application and your HTTP server. Werkzeug includes several <a class="reference external" href="https://werkzeug.palletsprojects.com/middleware/">middlewares</a>.</p>   <h2 id="fork">Fork.</h2> <p>If none of the above options work, fork Flask. The majority of code of Flask is within Werkzeug and Jinja2. These libraries do the majority of the work. Flask is just the paste that glues those together. For every project there is the point where the underlying framework gets in the way (due to assumptions the original developers had). This is natural because if this would not be the case, the framework would be a very complex system to begin with which causes a steep learning curve and a lot of user frustration.</p> <p>This is not unique to Flask. Many people use patched and modified versions of their framework to counter shortcomings. This idea is also reflected in the license of Flask. You don’t have to contribute any changes back if you decide to modify the framework.</p> <p>The downside of forking is of course that Flask extensions will most likely break because the new framework has a different import name. Furthermore integrating upstream changes can be a complex process, depending on the number of changes. Because of that, forking should be the very last resort.</p>   <h2 id="scale-like-a-pro">Scale like a pro.</h2> <p>For many web applications the complexity of the code is less an issue than the scaling for the number of users or data entries expected. Flask by itself is only limited in terms of scaling by your application code, the data store you want to use and the Python implementation and webserver you are running on.</p> <p>Scaling well means for example that if you double the amount of servers you get about twice the performance. Scaling bad means that if you add a new server the application won’t perform any better or would not even support a second server.</p> <p>There is only one limiting factor regarding scaling in Flask which are the context local proxies. They depend on context which in Flask is defined as being either a thread, process or greenlet. If your server uses some kind of concurrency that is not based on threads or greenlets, Flask will no longer be able to support these global proxies. However the majority of servers are using either threads, greenlets or separate processes to achieve concurrency which are all methods well supported by the underlying Werkzeug library.</p>   <h2 id="discuss-with-the-community">Discuss with the community.</h2> <p>The Flask developers keep the framework accessible to users with codebases big and small. If you find an obstacle in your way, caused by Flask, don’t hesitate to contact the developers on the mailing list or Discord server. The best way for the Flask and Flask extension developers to improve the tools for larger applications is getting feedback from users.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2007&ndash;2021 Pallets<br>Licensed under the BSD 3-clause License.<br>
    <a href="https://flask.palletsprojects.com/en/2.0.x/becomingbig/" class="_attribution-link">https://flask.palletsprojects.com/en/2.0.x/becomingbig/</a>
  </p>
</div>
