[{"name": "abort()", "path": "api/index#flask.abort", "type": "flask", "text": "\nRaises an `HTTPException` for the given status code or WSGI application.\n\nIf a status code is given, it will be looked up in the list of exceptions and\nwill raise that exception. If passed a WSGI application, it will wrap it in a\nproxy WSGI exception and raise that:\n\nNoReturn\n\n"}, {"name": "Adding a favicon", "path": "patterns/favicon/index", "type": "User's Guide: Design Patterns", "text": "\nA \u201cfavicon\u201d is an icon used by browsers for tabs and bookmarks. This helps to\ndistinguish your website and to give it a unique brand.\n\nA common question is how to add a favicon to a Flask application. First, of\ncourse, you need an icon. It should be 16 \u00d7 16 pixels and in the ICO file\nformat. This is not a requirement but a de-facto standard supported by all\nrelevant browsers. Put the icon in your static directory as `favicon.ico`.\n\nNow, to get browsers to find your icon, the correct way is to add a link tag\nin your HTML. So, for example:\n\nThat\u2019s all you need for most browsers, however some really old ones do not\nsupport this standard. The old de-facto standard is to serve this file, with\nthis name, at the website root. If your application is not mounted at the root\npath of the domain you either need to configure the web server to serve the\nicon at the root or if you can\u2019t do that you\u2019re out of luck. If however your\napplication is the root you can simply route a redirect:\n\nIf you want to save the extra redirect request you can also write a view using\n`send_from_directory()`:\n\nWe can leave out the explicit mimetype and it will be guessed, but we may as\nwell specify it to avoid the extra guessing, as it will always be the same.\n\nThe above will serve the icon via your application and if possible it\u2019s better\nto configure your dedicated web server to serve it; refer to the web server\u2019s\ndocumentation.\n\n"}, {"name": "Adding HTTP Method Overrides", "path": "patterns/methodoverrides/index", "type": "User's Guide: Design Patterns", "text": "\nSome HTTP proxies do not support arbitrary HTTP methods or newer HTTP methods\n(such as PATCH). In that case it\u2019s possible to \u201cproxy\u201d HTTP methods through\nanother HTTP method in total violation of the protocol.\n\nThe way this works is by letting the client do an HTTP POST request and set\nthe `X-HTTP-Method-Override` header. Then the method is replaced with the\nheader value before being passed to Flask.\n\nThis can be accomplished with an HTTP middleware:\n\nTo use this with Flask, wrap the app object with the middleware:\n\n"}, {"name": "after_this_request()", "path": "api/index#flask.after_this_request", "type": "flask", "text": "\nExecutes a function after this request. This is useful to modify response\nobjects. The function is passed the response object and has to return the same\nor a new one.\n\nExample:\n\nThis is more useful if a function other than the view function wants to modify\na response. For instance think of a decorator that wants to add some headers\nwithout converting the return value into a response object.\n\nNew in version 0.9.\n\nf (Callable[[Response], Response]) \u2013\n\nCallable[[Response], Response]\n\n"}, {"name": "AJAX with jQuery", "path": "patterns/jquery/index", "type": "User's Guide: Design Patterns", "text": "\njQuery is a small JavaScript library commonly used to simplify working with\nthe DOM and JavaScript in general. It is the perfect tool to make web\napplications more dynamic by exchanging JSON between server and client.\n\nJSON itself is a very lightweight transport format, very similar to how Python\nprimitives (numbers, strings, dicts and lists) look like which is widely\nsupported and very easy to parse. It became popular a few years ago and\nquickly replaced XML as transport format in web applications.\n\nIn order to use jQuery, you have to download it first and place it in the\nstatic folder of your application and then ensure it\u2019s loaded. Ideally you\nhave a layout template that is used for all pages where you just have to add a\nscript statement to the bottom of your `<body>` to load jQuery:\n\nAnother method is using Google\u2019s AJAX Libraries API to load jQuery:\n\nIn this case you have to put jQuery into your static folder as a fallback, but\nit will first try to load it directly from Google. This has the advantage that\nyour website will probably load faster for users if they went to at least one\nother website before using the same jQuery version from Google because it will\nalready be in the browser cache.\n\nDo you know where your application is? If you are developing the answer is\nquite simple: it\u2019s on localhost port something and directly on the root of\nthat server. But what if you later decide to move your application to a\ndifferent location? For example to `http://example.com/myapp`? On the server\nside this never was a problem because we were using the handy `url_for()`\nfunction that could answer that question for us, but if we are using jQuery we\nshould not hardcode the path to the application but make that dynamic, so how\ncan we do that?\n\nA simple method would be to add a script tag to our page that sets a global\nvariable to the prefix to the root of the application. Something like this:\n\nNow let\u2019s create a server side function that accepts two URL arguments of\nnumbers which should be added together and then sent back to the application\nin a JSON object. This is a really ridiculous example and is something you\nusually would do on the client side alone, but a simple example that shows how\nyou would use jQuery and Flask nonetheless:\n\nAs you can see I also added an `index` method here that renders a template.\nThis template will load jQuery as above and have a little form where we can\nadd two numbers and a link to trigger the function on the server side.\n\nNote that we are using the `get()` method here which will never fail. If the\nkey is missing a default value (here `0`) is returned. Furthermore it can\nconvert values to a specific type (like in our case `int`). This is especially\nhandy for code that is triggered by a script (APIs, JavaScript etc.) because\nyou don\u2019t need special error reporting in that case.\n\nYour index.html template either has to extend a `layout.html` template with\njQuery loaded and the `$SCRIPT_ROOT` variable set, or do that on the top.\nHere\u2019s the HTML code needed for our little application (`index.html`). Notice\nthat we also drop the script directly into the HTML here. It is usually a\nbetter idea to have that in a separate script file:\n\nI won\u2019t go into detail here about how jQuery works, just a very quick\nexplanation of the little bit of code above:\n\nCheck out the example source for a full application demonstrating the code on\nthis page, as well as the same thing using `XMLHttpRequest` and `fetch`.\n\n"}, {"name": "AppContext", "path": "api/index#flask.ctx.AppContext", "type": "flask.ctx", "text": "\nThe application context binds an application object implicitly to the current\nthread or greenlet, similar to how the `RequestContext` binds request\ninformation. The application context is also implicitly created if a request\ncontext is created but the application is not on top of the individual\napplication context.\n\napp (Flask) \u2013\n\nNone\n\nPops the app context.\n\nexc (Optional[BaseException]) \u2013\n\nNone\n\nBinds the app context to the current context.\n\nNone\n\n"}, {"name": "AppContext.pop()", "path": "api/index#flask.ctx.AppContext.pop", "type": "flask.ctx", "text": "\nPops the app context.\n\nexc (Optional[BaseException]) \u2013\n\nNone\n\n"}, {"name": "AppContext.push()", "path": "api/index#flask.ctx.AppContext.push", "type": "flask.ctx", "text": "\nBinds the app context to the current context.\n\nNone\n\n"}, {"name": "AppGroup", "path": "api/index#flask.cli.AppGroup", "type": "flask.cli", "text": "\nThis works similar to a regular click `Group` but it changes the behavior of\nthe `command()` decorator so that it automatically wraps the functions in\n`with_appcontext()`.\n\nNot to be confused with `FlaskGroup`.\n\nNone\n\nThis works exactly like the method of the same name on a regular `click.Group`\nbut it wraps callbacks in `with_appcontext()` unless it\u2019s disabled by passing\n`with_appcontext=False`.\n\nThis works exactly like the method of the same name on a regular `click.Group`\nbut it defaults the group class to `AppGroup`.\n\n"}, {"name": "AppGroup.command()", "path": "api/index#flask.cli.AppGroup.command", "type": "flask.cli", "text": "\nThis works exactly like the method of the same name on a regular `click.Group`\nbut it wraps callbacks in `with_appcontext()` unless it\u2019s disabled by passing\n`with_appcontext=False`.\n\n"}, {"name": "AppGroup.group()", "path": "api/index#flask.cli.AppGroup.group", "type": "flask.cli", "text": "\nThis works exactly like the method of the same name on a regular `click.Group`\nbut it defaults the group class to `AppGroup`.\n\n"}, {"name": "Application Dispatching", "path": "patterns/appdispatch/index", "type": "User's Guide: Design Patterns", "text": "\nApplication dispatching is the process of combining multiple Flask\napplications on the WSGI level. You can combine not only Flask applications\nbut any WSGI application. This would allow you to run a Django and a Flask\napplication in the same interpreter side by side if you want. The usefulness\nof this depends on how the applications work internally.\n\nThe fundamental difference from Large Applications as Packages is that in this\ncase you are running the same or different Flask applications that are\nentirely isolated from each other. They run different configurations and are\ndispatched on the WSGI level.\n\nEach of the techniques and examples below results in an `application` object\nthat can be run with any WSGI server. For production, see Deployment Options.\nFor development, Werkzeug provides a server through\n`werkzeug.serving.run_simple()`:\n\nNote that `run_simple` is not intended for use in production. Use a production\nWSGI server. See Deployment Options.\n\nIn order to use the interactive debugger, debugging must be enabled both on\nthe application and the simple server. Here is the \u201chello world\u201d example with\ndebugging and `run_simple`:\n\nIf you have entirely separated applications and you want them to work next to\neach other in the same Python interpreter process you can take advantage of\nthe `werkzeug.wsgi.DispatcherMiddleware`. The idea here is that each Flask\napplication is a valid WSGI application and they are combined by the\ndispatcher middleware into a larger one that is dispatched based on prefix.\n\nFor example you could have your main application run on `/` and your backend\ninterface on `/backend`:\n\nSometimes you might want to use multiple instances of the same application\nwith different configurations. Assuming the application is created inside a\nfunction and you can call that function to instantiate it, that is really easy\nto implement. In order to develop your application to support creating new\ninstances in functions have a look at the Application Factories pattern.\n\nA very common example would be creating applications per subdomain. For\ninstance you configure your webserver to dispatch all requests for all\nsubdomains to your application and you then use the subdomain information to\ncreate user-specific instances. Once you have your server set up to listen on\nall subdomains you can use a very simple WSGI application to do the dynamic\napplication creation.\n\nThe perfect level for abstraction in that regard is the WSGI layer. You write\nyour own WSGI application that looks at the request that comes and delegates\nit to your Flask application. If that application does not exist yet, it is\ndynamically created and remembered:\n\nThis dispatcher can then be used like this:\n\nDispatching by a path on the URL is very similar. Instead of looking at the\n`Host` header to figure out the subdomain one simply looks at the request path\nup to the first slash:\n\nThe big difference between this and the subdomain one is that this one falls\nback to another application if the creator function returns `None`:\n\n"}, {"name": "Application Factories", "path": "patterns/appfactories/index", "type": "User's Guide: Design Patterns", "text": "\nIf you are already using packages and blueprints for your application (Modular\nApplications with Blueprints) there are a couple of really nice ways to\nfurther improve the experience. A common pattern is creating the application\nobject when the blueprint is imported. But if you move the creation of this\nobject into a function, you can then create multiple instances of this app\nlater.\n\nSo why would you want to do this?\n\nSo how would you then actually implement that?\n\nThe idea is to set up the application in a function. Like this:\n\nThe downside is that you cannot use the application object in the blueprints\nat import time. You can however use it from within a request. How do you get\naccess to the application with the config? Use `current_app`:\n\nHere we look up the name of a template in the config.\n\nIt\u2019s preferable to create your extensions and app factories so that the\nextension object does not initially get bound to the application.\n\nUsing Flask-SQLAlchemy, as an example, you should not do something along those\nlines:\n\nBut, rather, in model.py (or equivalent):\n\nand in your application.py (or equivalent):\n\nUsing this design pattern, no application-specific state is stored on the\nextension object, so one extension object can be used for multiple apps. For\nmore information about the design of extensions refer to Flask Extension\nDevelopment.\n\nTo run such an application, you can use the flask command:\n\nFlask will automatically detect the factory (`create_app` or `make_app`) in\n`myapp`. You can also pass arguments to the factory like this:\n\nThen the `create_app` factory in `myapp` is called with the string `'dev'` as\nthe argument. See Command Line Interface for more detail.\n\nThe factory function above is not very clever, but you can improve it. The\nfollowing changes are straightforward to implement:\n\n"}, {"name": "APPLICATION_ROOT", "path": "config/index#APPLICATION_ROOT", "type": "Configuration", "text": "\nInform the application what path it is mounted under by the application / web\nserver. This is used for generating URLs outside the context of a request\n(inside a request, the dispatcher is responsible for setting `SCRIPT_NAME`\ninstead; see Application Dispatching for examples of dispatch configuration).\n\nWill be used for the session cookie path if `SESSION_COOKIE_PATH` is not set.\n\nDefault: `'/'`\n\n"}, {"name": "ASGI", "path": "deploying/asgi/index", "type": "User's Guide: Deploying", "text": "\nIf you\u2019d like to use an ASGI server you will need to utilise WSGI to ASGI\nmiddleware. The asgiref [WsgiToAsgi](https://github.com/django/asgiref#wsgi-\nto-asgi-adapter) adapter is recommended as it integrates with the event loop\nused for Flask\u2019s Using async and await support. You can use the adapter by\nwrapping the Flask app,\n\nand then serving the `asgi_app` with the asgi server, e.g. using Hypercorn,\n\n"}, {"name": "Becoming Big", "path": "becomingbig/index", "type": "User\u2019s Guide", "text": "\nHere are your options when growing your codebase or scaling your application.\n\nFlask started in part to demonstrate how to build your own framework on top of\nexisting well-used tools Werkzeug (WSGI) and Jinja (templating), and as it\ndeveloped, it became useful to a wide audience. As you grow your codebase,\ndon\u2019t just use Flask \u2013 understand it. Read the source. Flask\u2019s code is written\nto be read; its documentation is published so you can use its internal APIs.\nFlask sticks to documented APIs in upstream libraries, and documents its\ninternal utilities so that you can find the hook points needed for your\nproject.\n\nThe API docs are full of available overrides, hook points, and Signals. You\ncan provide custom classes for things like the request and response objects.\nDig deeper on the APIs you use, and look for the customizations which are\navailable out of the box in a Flask release. Look for ways in which your\nproject can be refactored into a collection of utilities and Flask extensions.\nExplore the many Extensions in the community, and look for patterns to build\nyour own extensions if you do not find the tools you need.\n\nThe `Flask` class has many methods designed for subclassing. You can quickly\nadd or customize behavior by subclassing `Flask` (see the linked method docs)\nand using that subclass wherever you instantiate an application class. This\nworks well with Application Factories. See Subclassing Flask for an example.\n\nThe Application Dispatching pattern shows in detail how to apply middleware.\nYou can introduce WSGI middleware to wrap your Flask instances and introduce\nfixes and changes at the layer between your Flask application and your HTTP\nserver. Werkzeug includes several middlewares.\n\nIf none of the above options work, fork Flask. The majority of code of Flask\nis within Werkzeug and Jinja2. These libraries do the majority of the work.\nFlask is just the paste that glues those together. For every project there is\nthe point where the underlying framework gets in the way (due to assumptions\nthe original developers had). This is natural because if this would not be the\ncase, the framework would be a very complex system to begin with which causes\na steep learning curve and a lot of user frustration.\n\nThis is not unique to Flask. Many people use patched and modified versions of\ntheir framework to counter shortcomings. This idea is also reflected in the\nlicense of Flask. You don\u2019t have to contribute any changes back if you decide\nto modify the framework.\n\nThe downside of forking is of course that Flask extensions will most likely\nbreak because the new framework has a different import name. Furthermore\nintegrating upstream changes can be a complex process, depending on the number\nof changes. Because of that, forking should be the very last resort.\n\nFor many web applications the complexity of the code is less an issue than the\nscaling for the number of users or data entries expected. Flask by itself is\nonly limited in terms of scaling by your application code, the data store you\nwant to use and the Python implementation and webserver you are running on.\n\nScaling well means for example that if you double the amount of servers you\nget about twice the performance. Scaling bad means that if you add a new\nserver the application won\u2019t perform any better or would not even support a\nsecond server.\n\nThere is only one limiting factor regarding scaling in Flask which are the\ncontext local proxies. They depend on context which in Flask is defined as\nbeing either a thread, process or greenlet. If your server uses some kind of\nconcurrency that is not based on threads or greenlets, Flask will no longer be\nable to support these global proxies. However the majority of servers are\nusing either threads, greenlets or separate processes to achieve concurrency\nwhich are all methods well supported by the underlying Werkzeug library.\n\nThe Flask developers keep the framework accessible to users with codebases big\nand small. If you find an obstacle in your way, caused by Flask, don\u2019t\nhesitate to contact the developers on the mailing list or Discord server. The\nbest way for the Flask and Flask extension developers to improve the tools for\nlarger applications is getting feedback from users.\n\n"}, {"name": "Blueprint", "path": "api/index#flask.Blueprint", "type": "flask", "text": "\nRepresents a blueprint, a collection of routes and other app-related functions\nthat can be registered on a real application later.\n\nA blueprint is an object that allows defining application functions without\nrequiring an application object ahead of time. It uses the same decorators as\n`Flask`, but defers the need for an application by recording them for later\nregistration.\n\nDecorating a function with a blueprint creates a deferred function that is\ncalled with `BlueprintSetupState` when the blueprint is registered on an\napplication.\n\nSee Modular Applications with Blueprints for more information.\n\nChanged in version 1.1.0: Blueprints have a `cli` group to register nested CLI\ncommands. The `cli_group` parameter controls the name of the group under the\n`flask` command.\n\nNew in version 0.7.\n\nRegister a custom template filter, available application wide. Like\n`Flask.add_template_filter()` but for a blueprint. Works exactly like the\n`app_template_filter()` decorator.\n\nNone\n\nRegister a custom template global, available application wide. Like\n`Flask.add_template_global()` but for a blueprint. Works exactly like the\n`app_template_global()` decorator.\n\nNew in version 0.10.\n\nNone\n\nRegister a custom template test, available application wide. Like\n`Flask.add_template_test()` but for a blueprint. Works exactly like the\n`app_template_test()` decorator.\n\nNew in version 0.10.\n\nNone\n\nLike `Flask.add_url_rule()` but for a blueprint. The endpoint for the\n`url_for()` function is prefixed with the name of the blueprint.\n\nNone\n\nLike `Flask.after_request()` but for a blueprint. Such a function is executed\nafter each request, even if outside of the blueprint.\n\nf (Callable[[Response], Response]) \u2013\n\nCallable[[Response], Response]\n\nRegister a function to run after each request to this object.\n\nThe function is called with the response object, and must return a response\nobject. This allows the functions to modify or replace the response before it\nis sent.\n\nIf a function raises an exception, any remaining `after_request` functions\nwill not be called. Therefore, this should not be used for actions that must\nexecute, such as to close resources. Use `teardown_request()` for that.\n\nf (Callable[[Response], Response]) \u2013\n\nCallable[[Response], Response]\n\nA data structure of functions to call at the end of each request, in the\nformat `{scope: [functions]}`. The `scope` key is the name of a blueprint the\nfunctions are active for, or `None` for all requests.\n\nTo register a function, use the `after_request()` decorator.\n\nThis data structure is internal. It should not be modified directly and its\nformat may change at any time.\n\nLike `Flask.context_processor()` but for a blueprint. Such a function is\nexecuted each request, even if outside of the blueprint.\n\nf (Callable[[], Dict[str, Any]]) \u2013\n\nCallable[[], Dict[str, Any]]\n\nLike `Flask.errorhandler()` but for a blueprint. This handler is used for all\nrequests, even if outside of the blueprint.\n\ncode (Union[Type[Exception], int]) \u2013\n\nCallable\n\nRegister a custom template filter, available application wide. Like\n`Flask.template_filter()` but for a blueprint.\n\nname (Optional[str]) \u2013 the optional name of the filter, otherwise the function\nname will be used.\n\nCallable\n\nRegister a custom template global, available application wide. Like\n`Flask.template_global()` but for a blueprint.\n\nNew in version 0.10.\n\nname (Optional[str]) \u2013 the optional name of the global, otherwise the function\nname will be used.\n\nCallable\n\nRegister a custom template test, available application wide. Like\n`Flask.template_test()` but for a blueprint.\n\nNew in version 0.10.\n\nname (Optional[str]) \u2013 the optional name of the test, otherwise the function\nname will be used.\n\nCallable\n\nSame as `url_defaults()` but application wide.\n\nf (Callable[[str, dict], None]) \u2013\n\nCallable[[str, dict], None]\n\nSame as `url_value_preprocessor()` but application wide.\n\nf (Callable[[Optional[str], Optional[dict]], None]) \u2013\n\nCallable[[Optional[str], Optional[dict]], None]\n\nLike `Flask.before_first_request()`. Such a function is executed before the\nfirst request to the application.\n\nf (Callable[[], None]) \u2013\n\nCallable[[], None]\n\nLike `Flask.before_request()`. Such a function is executed before each\nrequest, even if outside of a blueprint.\n\nf (Callable[[], None]) \u2013\n\nCallable[[], None]\n\nRegister a function to run before each request.\n\nFor example, this can be used to open a database connection, or to load the\nlogged in user from the session.\n\nThe function will be called without any arguments. If it returns a non-`None`\nvalue, the value is handled as if it was the return value from the view, and\nfurther request handling is stopped.\n\nf (Callable[[], None]) \u2013\n\nCallable[[], None]\n\nA data structure of functions to call at the beginning of each request, in the\nformat `{scope: [functions]}`. The `scope` key is the name of a blueprint the\nfunctions are active for, or `None` for all requests.\n\nTo register a function, use the `before_request()` decorator.\n\nThis data structure is internal. It should not be modified directly and its\nformat may change at any time.\n\nThe Click command group for registering CLI commands for this object. The\ncommands are available from the `flask` command once the application has been\ndiscovered and blueprints have been registered.\n\nRegisters a template context processor function.\n\nf (Callable[[], Dict[str, Any]]) \u2013\n\nCallable[[], Dict[str, Any]]\n\nShortcut for `route()` with `methods=[\"DELETE\"]`.\n\nNew in version 2.0.\n\nCallable\n\nDecorate a view function to register it for the given endpoint. Used if a rule\nis added without a `view_func` with `add_url_rule()`.\n\nendpoint (str) \u2013 The endpoint name to associate with the view function.\n\nCallable\n\nA data structure of registered error handlers, in the format `{scope: {code:\n{class: handler}}}``. The `scope` key is the name of a blueprint the handlers\nare active for, or `None` for all requests. The `code` key is the HTTP status\ncode for `HTTPException`, or `None` for other exceptions. The innermost\ndictionary maps exception classes to handler functions.\n\nTo register an error handler, use the `errorhandler()` decorator.\n\nThis data structure is internal. It should not be modified directly and its\nformat may change at any time.\n\nRegister a function to handle errors by code or exception class.\n\nA decorator that is used to register a function given an error code. Example:\n\nYou can also register handlers for arbitrary exceptions:\n\nNew in version 0.7: Use `register_error_handler()` instead of modifying\n`error_handler_spec` directly, for application wide error handlers.\n\nNew in version 0.7: One can now additionally also register custom exception\ntypes that do not necessarily have to be a subclass of the `HTTPException`\nclass.\n\ncode_or_exception (Union[Type[Exception], int]) \u2013 the code as integer for the\nhandler, or an arbitrary exception\n\nCallable\n\nShortcut for `route()` with `methods=[\"GET\"]`.\n\nNew in version 2.0.\n\nCallable\n\nUsed by `send_file()` to determine the `max_age` cache value for a given file\npath if it wasn\u2019t passed.\n\nBy default, this returns `SEND_FILE_MAX_AGE_DEFAULT` from the configuration of\n`current_app`. This defaults to `None`, which tells the browser to use\nconditional requests instead of a timed cache, which is usually preferable.\n\nChanged in version 2.0: The default configuration is `None` instead of 12\nhours.\n\nNew in version 0.9.\n\nfilename (str) \u2013\n\nOptional[int]\n\n`True` if `static_folder` is set.\n\nNew in version 0.5.\n\nThe name of the package or module that this object belongs to. Do not change\nthis once it is set by the constructor.\n\nThe Jinja loader for this object\u2019s templates. By default this is a class\n`jinja2.loaders.FileSystemLoader` to `template_folder` if it is set.\n\nNew in version 0.5.\n\nBlueprint local JSON decoder class to use. Set to `None` to use the app\u2019s\n`json_decoder`.\n\nBlueprint local JSON encoder class to use. Set to `None` to use the app\u2019s\n`json_encoder`.\n\nCreates an instance of `BlueprintSetupState()` object that is later passed to\nthe register callback functions. Subclasses can override this to return a\nsubclass of the setup state.\n\nflask.blueprints.BlueprintSetupState\n\nOpen a resource file relative to `root_path` for reading.\n\nFor example, if the file `schema.sql` is next to the file `app.py` where the\n`Flask` app is defined, it can be opened with:\n\nIO\n\nShortcut for `route()` with `methods=[\"PATCH\"]`.\n\nNew in version 2.0.\n\nCallable\n\nShortcut for `route()` with `methods=[\"POST\"]`.\n\nNew in version 2.0.\n\nCallable\n\nShortcut for `route()` with `methods=[\"PUT\"]`.\n\nNew in version 2.0.\n\nCallable\n\nRegisters a function that is called when the blueprint is registered on the\napplication. This function is called with the state as argument as returned by\nthe `make_setup_state()` method.\n\nfunc (Callable) \u2013\n\nNone\n\nWorks like `record()` but wraps the function in another function that will\nensure the function is only called once. If the blueprint is registered a\nsecond time on the application, the function passed is not called.\n\nfunc (Callable) \u2013\n\nNone\n\nCalled by `Flask.register_blueprint()` to register all views and callbacks\nregistered on the blueprint with the application. Creates a\n`BlueprintSetupState` and calls each `record()` callbackwith it.\n\nNone\n\nRegister a `Blueprint` on this blueprint. Keyword arguments passed to this\nmethod will override the defaults set on the blueprint.\n\nNew in version 2.0.\n\nNone\n\nAlternative error attach function to the `errorhandler()` decorator that is\nmore straightforward to use for non decorator usage.\n\nNew in version 0.7.\n\nNone\n\nAbsolute path to the package on the filesystem. Used to look up resources\ncontained in the package.\n\nDecorate a view function to register it with the given URL rule and options.\nCalls `add_url_rule()`, which has more details about the implementation.\n\nSee URL Route Registrations.\n\nThe endpoint name for the route defaults to the name of the view function if\nthe `endpoint` parameter isn\u2019t passed.\n\nThe `methods` parameter defaults to `[\"GET\"]`. `HEAD` and `OPTIONS` are added\nautomatically.\n\nCallable\n\nThe view function used to serve files from `static_folder`. A route is\nautomatically registered for this view at `static_url_path` if `static_folder`\nis set.\n\nNew in version 0.5.\n\nfilename (str) \u2013\n\nResponse\n\nThe absolute path to the configured static folder. `None` if no static folder\nis set.\n\nThe URL prefix that the static route will be accessible from.\n\nIf it was not configured during init, it is derived from `static_folder`.\n\nLike `Flask.teardown_request()` but for a blueprint. Such a function is\nexecuted when tearing down each request, even if outside of the blueprint.\n\nf (Callable[[Optional[BaseException]], Response]) \u2013\n\nCallable[[Optional[BaseException]], Response]\n\nRegister a function to be run at the end of each request, regardless of\nwhether there was an exception or not. These functions are executed when the\nrequest context is popped, even if not an actual request was performed.\n\nExample:\n\nWhen `ctx.pop()` is executed in the above example, the teardown functions are\ncalled just before the request context moves from the stack of active\ncontexts. This becomes relevant if you are using such constructs in tests.\n\nTeardown functions must avoid raising exceptions, since they . If they execute\ncode that might fail they will have to surround the execution of these code by\ntry/except statements and log occurring errors.\n\nWhen a teardown function was called because of an exception it will be passed\nan error object.\n\nThe return values of teardown functions are ignored.\n\nDebug Note\n\nIn debug mode Flask will not tear down a request on an exception immediately.\nInstead it will keep it alive so that the interactive debugger can still\naccess it. This behavior can be controlled by the\n`PRESERVE_CONTEXT_ON_EXCEPTION` configuration variable.\n\nf (Callable[[Optional[BaseException]], Response]) \u2013\n\nCallable[[Optional[BaseException]], Response]\n\nA data structure of functions to call at the end of each request even if an\nexception is raised, in the format `{scope: [functions]}`. The `scope` key is\nthe name of a blueprint the functions are active for, or `None` for all\nrequests.\n\nTo register a function, use the `teardown_request()` decorator.\n\nThis data structure is internal. It should not be modified directly and its\nformat may change at any time.\n\nA data structure of functions to call to pass extra context values when\nrendering templates, in the format `{scope: [functions]}`. The `scope` key is\nthe name of a blueprint the functions are active for, or `None` for all\nrequests.\n\nTo register a function, use the `context_processor()` decorator.\n\nThis data structure is internal. It should not be modified directly and its\nformat may change at any time.\n\nThe path to the templates folder, relative to `root_path`, to add to the\ntemplate loader. `None` if templates should not be added.\n\nA data structure of functions to call to modify the keyword arguments when\ngenerating URLs, in the format `{scope: [functions]}`. The `scope` key is the\nname of a blueprint the functions are active for, or `None` for all requests.\n\nTo register a function, use the `url_defaults()` decorator.\n\nThis data structure is internal. It should not be modified directly and its\nformat may change at any time.\n\nCallback function for URL defaults for all view functions of the application.\nIt\u2019s called with the endpoint and values and should update the values passed\nin place.\n\nf (Callable[[str, dict], None]) \u2013\n\nCallable[[str, dict], None]\n\nRegister a URL value preprocessor function for all view functions in the\napplication. These functions will be called before the `before_request()`\nfunctions.\n\nThe function can modify the values captured from the matched url before they\nare passed to the view. For example, this can be used to pop a common language\ncode value and place it in `g` rather than pass it to every view.\n\nThe function is passed the endpoint name and values dict. The return value is\nignored.\n\nf (Callable[[Optional[str], Optional[dict]], None]) \u2013\n\nCallable[[Optional[str], Optional[dict]], None]\n\nA data structure of functions to call to modify the keyword arguments passed\nto the view function, in the format `{scope: [functions]}`. The `scope` key is\nthe name of a blueprint the functions are active for, or `None` for all\nrequests.\n\nTo register a function, use the `url_value_preprocessor()` decorator.\n\nThis data structure is internal. It should not be modified directly and its\nformat may change at any time.\n\nA dictionary mapping endpoint names to view functions.\n\nTo register a view function, use the `route()` decorator.\n\nThis data structure is internal. It should not be modified directly and its\nformat may change at any time.\n\n"}, {"name": "Blueprint.add_app_template_filter()", "path": "api/index#flask.Blueprint.add_app_template_filter", "type": "flask", "text": "\nRegister a custom template filter, available application wide. Like\n`Flask.add_template_filter()` but for a blueprint. Works exactly like the\n`app_template_filter()` decorator.\n\nNone\n\n"}, {"name": "Blueprint.add_app_template_global()", "path": "api/index#flask.Blueprint.add_app_template_global", "type": "flask", "text": "\nRegister a custom template global, available application wide. Like\n`Flask.add_template_global()` but for a blueprint. Works exactly like the\n`app_template_global()` decorator.\n\nNew in version 0.10.\n\nNone\n\n"}, {"name": "Blueprint.add_app_template_test()", "path": "api/index#flask.Blueprint.add_app_template_test", "type": "flask", "text": "\nRegister a custom template test, available application wide. Like\n`Flask.add_template_test()` but for a blueprint. Works exactly like the\n`app_template_test()` decorator.\n\nNew in version 0.10.\n\nNone\n\n"}, {"name": "Blueprint.add_url_rule()", "path": "api/index#flask.Blueprint.add_url_rule", "type": "flask", "text": "\nLike `Flask.add_url_rule()` but for a blueprint. The endpoint for the\n`url_for()` function is prefixed with the name of the blueprint.\n\nNone\n\n"}, {"name": "Blueprint.after_app_request()", "path": "api/index#flask.Blueprint.after_app_request", "type": "flask", "text": "\nLike `Flask.after_request()` but for a blueprint. Such a function is executed\nafter each request, even if outside of the blueprint.\n\nf (Callable[[Response], Response]) \u2013\n\nCallable[[Response], Response]\n\n"}, {"name": "Blueprint.after_request()", "path": "api/index#flask.Blueprint.after_request", "type": "flask", "text": "\nRegister a function to run after each request to this object.\n\nThe function is called with the response object, and must return a response\nobject. This allows the functions to modify or replace the response before it\nis sent.\n\nIf a function raises an exception, any remaining `after_request` functions\nwill not be called. Therefore, this should not be used for actions that must\nexecute, such as to close resources. Use `teardown_request()` for that.\n\nf (Callable[[Response], Response]) \u2013\n\nCallable[[Response], Response]\n\n"}, {"name": "Blueprint.after_request_funcs", "path": "api/index#flask.Blueprint.after_request_funcs", "type": "flask", "text": "\nA data structure of functions to call at the end of each request, in the\nformat `{scope: [functions]}`. The `scope` key is the name of a blueprint the\nfunctions are active for, or `None` for all requests.\n\nTo register a function, use the `after_request()` decorator.\n\nThis data structure is internal. It should not be modified directly and its\nformat may change at any time.\n\n"}, {"name": "Blueprint.app_context_processor()", "path": "api/index#flask.Blueprint.app_context_processor", "type": "flask", "text": "\nLike `Flask.context_processor()` but for a blueprint. Such a function is\nexecuted each request, even if outside of the blueprint.\n\nf (Callable[[], Dict[str, Any]]) \u2013\n\nCallable[[], Dict[str, Any]]\n\n"}, {"name": "Blueprint.app_errorhandler()", "path": "api/index#flask.Blueprint.app_errorhandler", "type": "flask", "text": "\nLike `Flask.errorhandler()` but for a blueprint. This handler is used for all\nrequests, even if outside of the blueprint.\n\ncode (Union[Type[Exception], int]) \u2013\n\nCallable\n\n"}, {"name": "Blueprint.app_template_filter()", "path": "api/index#flask.Blueprint.app_template_filter", "type": "flask", "text": "\nRegister a custom template filter, available application wide. Like\n`Flask.template_filter()` but for a blueprint.\n\nname (Optional[str]) \u2013 the optional name of the filter, otherwise the function\nname will be used.\n\nCallable\n\n"}, {"name": "Blueprint.app_template_global()", "path": "api/index#flask.Blueprint.app_template_global", "type": "flask", "text": "\nRegister a custom template global, available application wide. Like\n`Flask.template_global()` but for a blueprint.\n\nNew in version 0.10.\n\nname (Optional[str]) \u2013 the optional name of the global, otherwise the function\nname will be used.\n\nCallable\n\n"}, {"name": "Blueprint.app_template_test()", "path": "api/index#flask.Blueprint.app_template_test", "type": "flask", "text": "\nRegister a custom template test, available application wide. Like\n`Flask.template_test()` but for a blueprint.\n\nNew in version 0.10.\n\nname (Optional[str]) \u2013 the optional name of the test, otherwise the function\nname will be used.\n\nCallable\n\n"}, {"name": "Blueprint.app_url_defaults()", "path": "api/index#flask.Blueprint.app_url_defaults", "type": "flask", "text": "\nSame as `url_defaults()` but application wide.\n\nf (Callable[[str, dict], None]) \u2013\n\nCallable[[str, dict], None]\n\n"}, {"name": "Blueprint.app_url_value_preprocessor()", "path": "api/index#flask.Blueprint.app_url_value_preprocessor", "type": "flask", "text": "\nSame as `url_value_preprocessor()` but application wide.\n\nf (Callable[[Optional[str], Optional[dict]], None]) \u2013\n\nCallable[[Optional[str], Optional[dict]], None]\n\n"}, {"name": "Blueprint.before_app_first_request()", "path": "api/index#flask.Blueprint.before_app_first_request", "type": "flask", "text": "\nLike `Flask.before_first_request()`. Such a function is executed before the\nfirst request to the application.\n\nf (Callable[[], None]) \u2013\n\nCallable[[], None]\n\n"}, {"name": "Blueprint.before_app_request()", "path": "api/index#flask.Blueprint.before_app_request", "type": "flask", "text": "\nLike `Flask.before_request()`. Such a function is executed before each\nrequest, even if outside of a blueprint.\n\nf (Callable[[], None]) \u2013\n\nCallable[[], None]\n\n"}, {"name": "Blueprint.before_request()", "path": "api/index#flask.Blueprint.before_request", "type": "flask", "text": "\nRegister a function to run before each request.\n\nFor example, this can be used to open a database connection, or to load the\nlogged in user from the session.\n\nThe function will be called without any arguments. If it returns a non-`None`\nvalue, the value is handled as if it was the return value from the view, and\nfurther request handling is stopped.\n\nf (Callable[[], None]) \u2013\n\nCallable[[], None]\n\n"}, {"name": "Blueprint.before_request_funcs", "path": "api/index#flask.Blueprint.before_request_funcs", "type": "flask", "text": "\nA data structure of functions to call at the beginning of each request, in the\nformat `{scope: [functions]}`. The `scope` key is the name of a blueprint the\nfunctions are active for, or `None` for all requests.\n\nTo register a function, use the `before_request()` decorator.\n\nThis data structure is internal. It should not be modified directly and its\nformat may change at any time.\n\n"}, {"name": "Blueprint.cli", "path": "api/index#flask.Blueprint.cli", "type": "flask", "text": "\nThe Click command group for registering CLI commands for this object. The\ncommands are available from the `flask` command once the application has been\ndiscovered and blueprints have been registered.\n\n"}, {"name": "Blueprint.context_processor()", "path": "api/index#flask.Blueprint.context_processor", "type": "flask", "text": "\nRegisters a template context processor function.\n\nf (Callable[[], Dict[str, Any]]) \u2013\n\nCallable[[], Dict[str, Any]]\n\n"}, {"name": "Blueprint.delete()", "path": "api/index#flask.Blueprint.delete", "type": "flask", "text": "\nShortcut for `route()` with `methods=[\"DELETE\"]`.\n\nNew in version 2.0.\n\nCallable\n\n"}, {"name": "Blueprint.endpoint()", "path": "api/index#flask.Blueprint.endpoint", "type": "flask", "text": "\nDecorate a view function to register it for the given endpoint. Used if a rule\nis added without a `view_func` with `add_url_rule()`.\n\nendpoint (str) \u2013 The endpoint name to associate with the view function.\n\nCallable\n\n"}, {"name": "Blueprint.errorhandler()", "path": "api/index#flask.Blueprint.errorhandler", "type": "flask", "text": "\nRegister a function to handle errors by code or exception class.\n\nA decorator that is used to register a function given an error code. Example:\n\nYou can also register handlers for arbitrary exceptions:\n\nNew in version 0.7: Use `register_error_handler()` instead of modifying\n`error_handler_spec` directly, for application wide error handlers.\n\nNew in version 0.7: One can now additionally also register custom exception\ntypes that do not necessarily have to be a subclass of the `HTTPException`\nclass.\n\ncode_or_exception (Union[Type[Exception], int]) \u2013 the code as integer for the\nhandler, or an arbitrary exception\n\nCallable\n\n"}, {"name": "Blueprint.error_handler_spec", "path": "api/index#flask.Blueprint.error_handler_spec", "type": "flask", "text": "\nA data structure of registered error handlers, in the format `{scope: {code:\n{class: handler}}}``. The `scope` key is the name of a blueprint the handlers\nare active for, or `None` for all requests. The `code` key is the HTTP status\ncode for `HTTPException`, or `None` for other exceptions. The innermost\ndictionary maps exception classes to handler functions.\n\nTo register an error handler, use the `errorhandler()` decorator.\n\nThis data structure is internal. It should not be modified directly and its\nformat may change at any time.\n\n"}, {"name": "Blueprint.get()", "path": "api/index#flask.Blueprint.get", "type": "flask", "text": "\nShortcut for `route()` with `methods=[\"GET\"]`.\n\nNew in version 2.0.\n\nCallable\n\n"}, {"name": "Blueprint.get_send_file_max_age()", "path": "api/index#flask.Blueprint.get_send_file_max_age", "type": "flask", "text": "\nUsed by `send_file()` to determine the `max_age` cache value for a given file\npath if it wasn\u2019t passed.\n\nBy default, this returns `SEND_FILE_MAX_AGE_DEFAULT` from the configuration of\n`current_app`. This defaults to `None`, which tells the browser to use\nconditional requests instead of a timed cache, which is usually preferable.\n\nChanged in version 2.0: The default configuration is `None` instead of 12\nhours.\n\nNew in version 0.9.\n\nfilename (str) \u2013\n\nOptional[int]\n\n"}, {"name": "Blueprint.import_name", "path": "api/index#flask.Blueprint.import_name", "type": "flask", "text": "\nThe name of the package or module that this object belongs to. Do not change\nthis once it is set by the constructor.\n\n"}, {"name": "Blueprint.json_decoder", "path": "api/index#flask.Blueprint.json_decoder", "type": "flask", "text": "\nBlueprint local JSON decoder class to use. Set to `None` to use the app\u2019s\n`json_decoder`.\n\n"}, {"name": "Blueprint.json_encoder", "path": "api/index#flask.Blueprint.json_encoder", "type": "flask", "text": "\nBlueprint local JSON encoder class to use. Set to `None` to use the app\u2019s\n`json_encoder`.\n\n"}, {"name": "Blueprint.make_setup_state()", "path": "api/index#flask.Blueprint.make_setup_state", "type": "flask", "text": "\nCreates an instance of `BlueprintSetupState()` object that is later passed to\nthe register callback functions. Subclasses can override this to return a\nsubclass of the setup state.\n\nflask.blueprints.BlueprintSetupState\n\n"}, {"name": "Blueprint.open_resource()", "path": "api/index#flask.Blueprint.open_resource", "type": "flask", "text": "\nOpen a resource file relative to `root_path` for reading.\n\nFor example, if the file `schema.sql` is next to the file `app.py` where the\n`Flask` app is defined, it can be opened with:\n\nIO\n\n"}, {"name": "Blueprint.patch()", "path": "api/index#flask.Blueprint.patch", "type": "flask", "text": "\nShortcut for `route()` with `methods=[\"PATCH\"]`.\n\nNew in version 2.0.\n\nCallable\n\n"}, {"name": "Blueprint.post()", "path": "api/index#flask.Blueprint.post", "type": "flask", "text": "\nShortcut for `route()` with `methods=[\"POST\"]`.\n\nNew in version 2.0.\n\nCallable\n\n"}, {"name": "Blueprint.put()", "path": "api/index#flask.Blueprint.put", "type": "flask", "text": "\nShortcut for `route()` with `methods=[\"PUT\"]`.\n\nNew in version 2.0.\n\nCallable\n\n"}, {"name": "Blueprint.record()", "path": "api/index#flask.Blueprint.record", "type": "flask", "text": "\nRegisters a function that is called when the blueprint is registered on the\napplication. This function is called with the state as argument as returned by\nthe `make_setup_state()` method.\n\nfunc (Callable) \u2013\n\nNone\n\n"}, {"name": "Blueprint.record_once()", "path": "api/index#flask.Blueprint.record_once", "type": "flask", "text": "\nWorks like `record()` but wraps the function in another function that will\nensure the function is only called once. If the blueprint is registered a\nsecond time on the application, the function passed is not called.\n\nfunc (Callable) \u2013\n\nNone\n\n"}, {"name": "Blueprint.register()", "path": "api/index#flask.Blueprint.register", "type": "flask", "text": "\nCalled by `Flask.register_blueprint()` to register all views and callbacks\nregistered on the blueprint with the application. Creates a\n`BlueprintSetupState` and calls each `record()` callbackwith it.\n\nNone\n\n"}, {"name": "Blueprint.register_blueprint()", "path": "api/index#flask.Blueprint.register_blueprint", "type": "flask", "text": "\nRegister a `Blueprint` on this blueprint. Keyword arguments passed to this\nmethod will override the defaults set on the blueprint.\n\nNew in version 2.0.\n\nNone\n\n"}, {"name": "Blueprint.register_error_handler()", "path": "api/index#flask.Blueprint.register_error_handler", "type": "flask", "text": "\nAlternative error attach function to the `errorhandler()` decorator that is\nmore straightforward to use for non decorator usage.\n\nNew in version 0.7.\n\nNone\n\n"}, {"name": "Blueprint.root_path", "path": "api/index#flask.Blueprint.root_path", "type": "flask", "text": "\nAbsolute path to the package on the filesystem. Used to look up resources\ncontained in the package.\n\n"}, {"name": "Blueprint.route()", "path": "api/index#flask.Blueprint.route", "type": "flask", "text": "\nDecorate a view function to register it with the given URL rule and options.\nCalls `add_url_rule()`, which has more details about the implementation.\n\nSee URL Route Registrations.\n\nThe endpoint name for the route defaults to the name of the view function if\nthe `endpoint` parameter isn\u2019t passed.\n\nThe `methods` parameter defaults to `[\"GET\"]`. `HEAD` and `OPTIONS` are added\nautomatically.\n\nCallable\n\n"}, {"name": "Blueprint.send_static_file()", "path": "api/index#flask.Blueprint.send_static_file", "type": "flask", "text": "\nThe view function used to serve files from `static_folder`. A route is\nautomatically registered for this view at `static_url_path` if `static_folder`\nis set.\n\nNew in version 0.5.\n\nfilename (str) \u2013\n\nResponse\n\n"}, {"name": "Blueprint.teardown_app_request()", "path": "api/index#flask.Blueprint.teardown_app_request", "type": "flask", "text": "\nLike `Flask.teardown_request()` but for a blueprint. Such a function is\nexecuted when tearing down each request, even if outside of the blueprint.\n\nf (Callable[[Optional[BaseException]], Response]) \u2013\n\nCallable[[Optional[BaseException]], Response]\n\n"}, {"name": "Blueprint.teardown_request()", "path": "api/index#flask.Blueprint.teardown_request", "type": "flask", "text": "\nRegister a function to be run at the end of each request, regardless of\nwhether there was an exception or not. These functions are executed when the\nrequest context is popped, even if not an actual request was performed.\n\nExample:\n\nWhen `ctx.pop()` is executed in the above example, the teardown functions are\ncalled just before the request context moves from the stack of active\ncontexts. This becomes relevant if you are using such constructs in tests.\n\nTeardown functions must avoid raising exceptions, since they . If they execute\ncode that might fail they will have to surround the execution of these code by\ntry/except statements and log occurring errors.\n\nWhen a teardown function was called because of an exception it will be passed\nan error object.\n\nThe return values of teardown functions are ignored.\n\nDebug Note\n\nIn debug mode Flask will not tear down a request on an exception immediately.\nInstead it will keep it alive so that the interactive debugger can still\naccess it. This behavior can be controlled by the\n`PRESERVE_CONTEXT_ON_EXCEPTION` configuration variable.\n\nf (Callable[[Optional[BaseException]], Response]) \u2013\n\nCallable[[Optional[BaseException]], Response]\n\n"}, {"name": "Blueprint.teardown_request_funcs", "path": "api/index#flask.Blueprint.teardown_request_funcs", "type": "flask", "text": "\nA data structure of functions to call at the end of each request even if an\nexception is raised, in the format `{scope: [functions]}`. The `scope` key is\nthe name of a blueprint the functions are active for, or `None` for all\nrequests.\n\nTo register a function, use the `teardown_request()` decorator.\n\nThis data structure is internal. It should not be modified directly and its\nformat may change at any time.\n\n"}, {"name": "Blueprint.template_context_processors", "path": "api/index#flask.Blueprint.template_context_processors", "type": "flask", "text": "\nA data structure of functions to call to pass extra context values when\nrendering templates, in the format `{scope: [functions]}`. The `scope` key is\nthe name of a blueprint the functions are active for, or `None` for all\nrequests.\n\nTo register a function, use the `context_processor()` decorator.\n\nThis data structure is internal. It should not be modified directly and its\nformat may change at any time.\n\n"}, {"name": "Blueprint.template_folder", "path": "api/index#flask.Blueprint.template_folder", "type": "flask", "text": "\nThe path to the templates folder, relative to `root_path`, to add to the\ntemplate loader. `None` if templates should not be added.\n\n"}, {"name": "Blueprint.url_defaults()", "path": "api/index#flask.Blueprint.url_defaults", "type": "flask", "text": "\nCallback function for URL defaults for all view functions of the application.\nIt\u2019s called with the endpoint and values and should update the values passed\nin place.\n\nf (Callable[[str, dict], None]) \u2013\n\nCallable[[str, dict], None]\n\n"}, {"name": "Blueprint.url_default_functions", "path": "api/index#flask.Blueprint.url_default_functions", "type": "flask", "text": "\nA data structure of functions to call to modify the keyword arguments when\ngenerating URLs, in the format `{scope: [functions]}`. The `scope` key is the\nname of a blueprint the functions are active for, or `None` for all requests.\n\nTo register a function, use the `url_defaults()` decorator.\n\nThis data structure is internal. It should not be modified directly and its\nformat may change at any time.\n\n"}, {"name": "Blueprint.url_value_preprocessor()", "path": "api/index#flask.Blueprint.url_value_preprocessor", "type": "flask", "text": "\nRegister a URL value preprocessor function for all view functions in the\napplication. These functions will be called before the `before_request()`\nfunctions.\n\nThe function can modify the values captured from the matched url before they\nare passed to the view. For example, this can be used to pop a common language\ncode value and place it in `g` rather than pass it to every view.\n\nThe function is passed the endpoint name and values dict. The return value is\nignored.\n\nf (Callable[[Optional[str], Optional[dict]], None]) \u2013\n\nCallable[[Optional[str], Optional[dict]], None]\n\n"}, {"name": "Blueprint.url_value_preprocessors", "path": "api/index#flask.Blueprint.url_value_preprocessors", "type": "flask", "text": "\nA data structure of functions to call to modify the keyword arguments passed\nto the view function, in the format `{scope: [functions]}`. The `scope` key is\nthe name of a blueprint the functions are active for, or `None` for all\nrequests.\n\nTo register a function, use the `url_value_preprocessor()` decorator.\n\nThis data structure is internal. It should not be modified directly and its\nformat may change at any time.\n\n"}, {"name": "Blueprint.view_functions", "path": "api/index#flask.Blueprint.view_functions", "type": "flask", "text": "\nA dictionary mapping endpoint names to view functions.\n\nTo register a view function, use the `route()` decorator.\n\nThis data structure is internal. It should not be modified directly and its\nformat may change at any time.\n\n"}, {"name": "BlueprintSetupState", "path": "api/index#flask.blueprints.BlueprintSetupState", "type": "flask.blueprints", "text": "\nTemporary holder object for registering a blueprint with the application. An\ninstance of this class is created by the `make_setup_state()` method and later\npassed to all register callback functions.\n\nNone\n\nA helper method to register a rule (and optionally a view function) to the\napplication. The endpoint is automatically prefixed with the blueprint\u2019s name.\n\nNone\n\na reference to the current application\n\na reference to the blueprint that created this setup state.\n\nas blueprints can be registered multiple times with the application and not\neverything wants to be registered multiple times on it, this attribute can be\nused to figure out if the blueprint was registered in the past already.\n\na dictionary with all options that were passed to the `register_blueprint()`\nmethod.\n\nThe subdomain that the blueprint should be active for, `None` otherwise.\n\nA dictionary with URL defaults that is added to each and every URL that was\ndefined with the blueprint.\n\nThe prefix that should be used for all URLs defined on the blueprint.\n\n"}, {"name": "BlueprintSetupState.add_url_rule()", "path": "api/index#flask.blueprints.BlueprintSetupState.add_url_rule", "type": "flask.blueprints", "text": "\nA helper method to register a rule (and optionally a view function) to the\napplication. The endpoint is automatically prefixed with the blueprint\u2019s name.\n\nNone\n\n"}, {"name": "BlueprintSetupState.app", "path": "api/index#flask.blueprints.BlueprintSetupState.app", "type": "flask.blueprints", "text": "\na reference to the current application\n\n"}, {"name": "BlueprintSetupState.blueprint", "path": "api/index#flask.blueprints.BlueprintSetupState.blueprint", "type": "flask.blueprints", "text": "\na reference to the blueprint that created this setup state.\n\n"}, {"name": "BlueprintSetupState.first_registration", "path": "api/index#flask.blueprints.BlueprintSetupState.first_registration", "type": "flask.blueprints", "text": "\nas blueprints can be registered multiple times with the application and not\neverything wants to be registered multiple times on it, this attribute can be\nused to figure out if the blueprint was registered in the past already.\n\n"}, {"name": "BlueprintSetupState.options", "path": "api/index#flask.blueprints.BlueprintSetupState.options", "type": "flask.blueprints", "text": "\na dictionary with all options that were passed to the `register_blueprint()`\nmethod.\n\n"}, {"name": "BlueprintSetupState.subdomain", "path": "api/index#flask.blueprints.BlueprintSetupState.subdomain", "type": "flask.blueprints", "text": "\nThe subdomain that the blueprint should be active for, `None` otherwise.\n\n"}, {"name": "BlueprintSetupState.url_defaults", "path": "api/index#flask.blueprints.BlueprintSetupState.url_defaults", "type": "flask.blueprints", "text": "\nA dictionary with URL defaults that is added to each and every URL that was\ndefined with the blueprint.\n\n"}, {"name": "BlueprintSetupState.url_prefix", "path": "api/index#flask.blueprints.BlueprintSetupState.url_prefix", "type": "flask.blueprints", "text": "\nThe prefix that should be used for all URLs defined on the blueprint.\n\n"}, {"name": "Caching", "path": "patterns/caching/index", "type": "User's Guide: Design Patterns", "text": "\nWhen your application runs slow, throw some caches in. Well, at least it\u2019s the\neasiest way to speed up things. What does a cache do? Say you have a function\nthat takes some time to complete but the results would still be good enough if\nthey were 5 minutes old. So then the idea is that you actually put the result\nof that calculation into a cache for some time.\n\nFlask itself does not provide caching for you, but Flask-Caching, an extension\nfor Flask does. Flask-Caching supports various backends, and it is even\npossible to develop your own caching backend.\n\n"}, {"name": "Celery Background Tasks", "path": "patterns/celery/index", "type": "User's Guide: Design Patterns", "text": "\nIf your application has a long running task, such as processing some uploaded\ndata or sending email, you don\u2019t want to wait for it to finish during a\nrequest. Instead, use a task queue to send the necessary data to another\nprocess that will run the task in the background while the request returns\nimmediately.\n\nCelery is a powerful task queue that can be used for simple background tasks\nas well as complex multi-stage programs and schedules. This guide will show\nyou how to configure Celery using Flask, but assumes you\u2019ve already read the\nFirst Steps with Celery guide in the Celery documentation.\n\nCelery is a separate Python package. Install it from PyPI using pip:\n\nThe first thing you need is a Celery instance, this is called the celery\napplication. It serves the same purpose as the `Flask` object in Flask, just\nfor Celery. Since this instance is used as the entry-point for everything you\nwant to do in Celery, like creating tasks and managing workers, it must be\npossible for other modules to import it.\n\nFor instance you can place this in a `tasks` module. While you can use Celery\nwithout any reconfiguration with Flask, it becomes a bit nicer by subclassing\ntasks and adding support for Flask\u2019s application contexts and hooking it up\nwith the Flask configuration.\n\nThis is all that is necessary to properly integrate Celery with Flask:\n\nThe function creates a new Celery object, configures it with the broker from\nthe application config, updates the rest of the Celery config from the Flask\nconfig and then creates a subclass of the task that wraps the task execution\nin an application context.\n\nLet\u2019s write a task that adds two numbers together and returns the result. We\nconfigure Celery\u2019s broker and backend to use Redis, create a `celery`\napplication using the factor from above, and then use it to define the task.\n\nThis task can now be called in the background:\n\nIf you jumped in and already executed the above code you will be disappointed\nto learn that `.wait()` will never actually return. That\u2019s because you also\nneed to run a Celery worker to receive and execute the task.\n\nThe `your_application` string has to point to your application\u2019s package or\nmodule that creates the `celery` object.\n\nNow that the worker is running, `wait` will return the result once the task is\nfinished.\n\n"}, {"name": "CGI", "path": "deploying/cgi/index", "type": "User's Guide: Deploying", "text": "\nIf all other deployment methods do not work, CGI will work for sure. CGI is\nsupported by all major servers but usually has a sub-optimal performance.\n\nThis is also the way you can use a Flask application on Google\u2019s App Engine,\nwhere execution happens in a CGI-like environment.\n\nWatch Out\n\nPlease make sure in advance that any `app.run()` calls you might have in your\napplication file are inside an `if __name__ == '__main__':` block or moved to\na separate file. Just make sure it\u2019s not called because this will always start\na local WSGI server which we do not want if we deploy that application to CGI\n/ app engine.\n\nWith CGI, you will also have to make sure that your code does not contain any\n`print` statements, or that `sys.stdout` is overridden by something that\ndoesn\u2019t write into the HTTP response.\n\nFirst you need to create the CGI application file. Let\u2019s call it\n`yourapplication.cgi`:\n\nUsually there are two ways to configure the server. Either just copy the\n`.cgi` into a `cgi-bin` (and use `mod_rewrite` or something similar to rewrite\nthe URL) or let the server point to the file directly.\n\nIn Apache for example you can put something like this into the config:\n\nOn shared webhosting, though, you might not have access to your Apache config.\nIn this case, a file called `.htaccess`, sitting in the public directory you\nwant your app to be available, works too but the `ScriptAlias` directive won\u2019t\nwork in that case:\n\nFor more information consult the documentation of your webserver.\n\n"}, {"name": "Changes", "path": "changes/index", "type": "Additional Notes", "text": "\nUnreleased\n\nReleased 2021-05-11\n\nReleased 2020-04-03\n\nReleased 2019-07-08\n\nReleased 2019-07-04\n\nError handlers for `InternalServerError` or `500` will always be passed an\ninstance of `InternalServerError`. If they are invoked due to an unhandled\nexception, that original exception is now available as `e.original_exception`\nrather than being passed directly to the handler. The same is true if the\nhandler is for the base `HTTPException`. This makes error handler behavior\nmore consistent. #3266\n\nReleased 2019-07-04\n\nReleased 2019-05-17\n\nReleased 2018-05-02\n\nReleased 2018-04-29\n\nReleased 2018-04-26\n\nThe following old deprecated code was removed. #2385\n\nReleased 2020-02-10\n\nReleased 2018-04-29\n\nReleased 2018-04-26\n\nReleased 2017-05-16\n\nReleased 2017-03-31\n\nReleased 2016-12-21, codename Punsch\n\nReleased 2016-06-07\n\nReleased 2016-05-29, codename Absinthe\n\nReleased 2013-06-14\n\nReleased 2013-06-13, codename Limoncello\n\nReleased 2012-07-01, codename Campari\n\nReleased 2012-07-01\n\nReleased 2011-09-29, codename Rakija\n\nReleased 2011-07-06\n\nReleased 2011-06-29\n\nReleased 2011-06-28, codename Grappa\n\nReleased 2010-12-31\n\nReleased 2010-07-27, codename Whisky\n\nReleased 2010-07-15\n\nReleased 2010-07-06\n\nReleased 2010-07-06, codename Calvados\n\nReleased 2010-06-18, codename Rakia\n\nReleased 2010-05-28\n\nReleased 2010-05-28, codename Schnaps\n\nReleased 2010-05-12, codename J?germeister\n\nReleased 2010-04-16\n\n"}, {"name": "Command Line Interface", "path": "cli/index", "type": "User\u2019s Guide", "text": "\nInstalling Flask installs the `flask` script, a Click command line interface,\nin your virtualenv. Executed from the terminal, this script gives access to\nbuilt-in, extension, and application-defined commands. The `--help` option\nwill give more information about any commands and options.\n\nThe `flask` command is installed by Flask, not your application; it must be\ntold where to find your application in order to use it. The `FLASK_APP`\nenvironment variable is used to specify how to load the application.\n\nWhile `FLASK_APP` supports a variety of options for specifying your\napplication, most use cases should be simple. Here are the typical values:\n\nThe name \u201capp\u201d or \u201cwsgi\u201d is imported (as a \u201c.py\u201d file, or package),\nautomatically detecting an app (`app` or `application`) or factory\n(`create_app` or `make_app`).\n\nThe given name is imported, automatically detecting an app (`app` or\n`application`) or factory (`create_app` or `make_app`).\n\n`FLASK_APP` has three parts: an optional path that sets the current working\ndirectory, a Python file or dotted import path, and an optional variable name\nof the instance or factory. If the name is a factory, it can optionally be\nfollowed by arguments in parentheses. The following values demonstrate these\nparts:\n\nSets the current working directory to `src` then imports `hello`.\n\nImports the path `hello.web`.\n\nUses the `app2` Flask instance in `hello`.\n\nThe `create_app` factory in `hello` is called with the string `'dev'` as the\nargument.\n\nIf `FLASK_APP` is not set, the command will try to import \u201capp\u201d or \u201cwsgi\u201d (as\na \u201c.py\u201d file, or package) and try to detect an application instance or\nfactory.\n\nWithin the given import, the command looks for an application instance named\n`app` or `application`, then any application instance. If no instance is\nfound, the command looks for a factory function named `create_app` or\n`make_app` that returns an instance.\n\nIf parentheses follow the factory name, their contents are parsed as Python\nliterals and passed as arguments and keyword arguments to the function. This\nmeans that strings must still be in quotes.\n\nThe `run` command will start the development server. It replaces the\n`Flask.run()` method in most cases.\n\nWarning\n\nDo not use this command to run your application in production. Only use the\ndevelopment server during development. The development server is provided for\nconvenience, but is not designed to be particularly secure, stable, or\nefficient. See Deployment Options for how to run in production.\n\nTo explore the data in your application, you can start an interactive Python\nshell with the `shell` command. An application context will be active, and the\napp instance will be imported.\n\nUse `shell_context_processor()` to add other automatic imports.\n\nNew in version 1.0.\n\nThe environment in which the Flask app runs is set by the `FLASK_ENV`\nenvironment variable. If not set it defaults to `production`. The other\nrecognized environment is `development`. Flask and extensions may choose to\nenable behaviors based on the environment.\n\nIf the env is set to `development`, the `flask` command will enable debug mode\nand `flask run` will enable the interactive debugger and reloader.\n\nWhen using development mode, the reloader will trigger whenever your Python\ncode or imported modules change. The reloader can watch additional files with\nthe `--extra-files` option, or the `FLASK_RUN_EXTRA_FILES` environment\nvariable. Multiple paths are separated with `:`, or `;` on Windows.\n\nDebug mode will be enabled when `FLASK_ENV` is `development`, as described\nabove. If you want to control debug mode separately, use `FLASK_DEBUG`. The\nvalue `1` enables it, `0` disables it.\n\nRather than setting `FLASK_APP` each time you open a new terminal, you can use\nFlask\u2019s dotenv support to set environment variables automatically.\n\nIf python-dotenv is installed, running the `flask` command will set\nenvironment variables defined in the files `.env` and `.flaskenv`. This can be\nused to avoid having to set `FLASK_APP` manually every time you open a new\nterminal, and to set configuration using environment variables similar to how\nsome deployment services work.\n\nVariables set on the command line are used over those set in `.env`, which are\nused over those set in `.flaskenv`. `.flaskenv` should be used for public\nvariables, such as `FLASK_APP`, while `.env` should not be committed to your\nrepository so that it can set private variables.\n\nDirectories are scanned upwards from the directory you call `flask` from to\nlocate the files. The current working directory will be set to the location of\nthe file, with the assumption that that is the top level project directory.\n\nThe files are only loaded by the `flask` command or calling `run()`. If you\nwould like to load these files when running in production, you should call\n`load_dotenv()` manually.\n\nClick is configured to load default values for command options from\nenvironment variables. The variables use the pattern `FLASK_COMMAND_OPTION`.\nFor example, to set the port for the run command, instead of `flask run --port\n8000`:\n\nThese can be added to the `.flaskenv` file just like `FLASK_APP` to control\ndefault command options.\n\nThe `flask` command will show a message if it detects dotenv files but python-\ndotenv is not installed.\n\nYou can tell Flask not to load dotenv files even when python-dotenv is\ninstalled by setting the `FLASK_SKIP_DOTENV` environment variable. This can be\nuseful if you want to load them manually, or if you\u2019re using a project runner\nthat loads them already. Keep in mind that the environment variables must be\nset before the app loads or it won\u2019t configure as expected.\n\nIf you do not want to install dotenv support, you can still set environment\nvariables by adding them to the end of the virtualenv\u2019s `activate` script.\nActivating the virtualenv will set the variables.\n\nUnix Bash, `venv/bin/activate`:\n\nWindows CMD, `venv\\Scripts\\activate.bat`:\n\nWindows Powershell, `venv\\Scripts\\activate.ps1`:\n\nIt is preferred to use dotenv support over this, since `.flaskenv` can be\ncommitted to the repository so that it works automatically wherever the\nproject is checked out.\n\nThe `flask` command is implemented using Click. See that project\u2019s\ndocumentation for full information about writing commands.\n\nThis example adds the command `create-user` that takes the argument `name`.\n\nThis example adds the same command, but as `user create`, a command in a\ngroup. This is useful if you want to organize multiple related commands.\n\nSee Testing CLI Commands for an overview of how to test your custom commands.\n\nIf your application uses blueprints, you can optionally register CLI commands\ndirectly onto them. When your blueprint is registered onto your application,\nthe associated commands will be available to the `flask` command. By default,\nthose commands will be nested in a group matching the name of the blueprint.\n\nYou can alter the group name by specifying the `cli_group` parameter when\ncreating the `Blueprint` object, or later with `app.register_blueprint(bp,\ncli_group='...')`. The following are equivalent:\n\nSpecifying `cli_group=None` will remove the nesting and merge the commands\ndirectly to the application\u2019s level:\n\nCommands added using the Flask app\u2019s `cli` `command()` decorator will be\nexecuted with an application context pushed, so your command and extensions\nhave access to the app and its configuration. If you create a command using\nthe Click `command()` decorator instead of the Flask decorator, you can use\n`with_appcontext()` to get the same behavior.\n\nIf you\u2019re sure a command doesn\u2019t need the context, you can disable it:\n\nFlask will automatically load commands specified in the `flask.commands` entry\npoint. This is useful for extensions that want to add commands when they are\ninstalled. Entry points are specified in `setup.py`\n\nInside `flask_my_extension/commands.py` you can then export a Click object:\n\nOnce that package is installed in the same virtualenv as your Flask project,\nyou can run `flask my-command` to invoke the command.\n\nWhen you are using the app factory pattern, it may be more convenient to\ndefine your own Click script. Instead of using `FLASK_APP` and letting Flask\nload your application, you can create your own Click object and export it as a\nconsole script entry point.\n\nCreate an instance of `FlaskGroup` and pass it the factory:\n\nDefine the entry point in `setup.py`:\n\nInstall the application in the virtualenv in editable mode and the custom\nscript is available. Note that you don\u2019t need to set `FLASK_APP`.\n\nErrors in Custom Scripts\n\nWhen using a custom script, if you introduce an error in your module-level\ncode, the reloader will fail because it can no longer load the entry point.\n\nThe `flask` command, being separate from your code, does not have this issue\nand is recommended in most cases.\n\nPyCharm Professional provides a special Flask run configuration. For the\nCommunity Edition, we need to configure it to call the `flask run` CLI command\nwith the correct environment variables. These instructions should be similar\nfor any other IDE you might want to use.\n\nIn PyCharm, with your project open, click on Run from the menu bar and go to\nEdit Configurations. You\u2019ll be greeted by a screen similar to this:\n\nThere\u2019s quite a few options to change, but once we\u2019ve done it for one command,\nwe can easily copy the entire configuration and make a single tweak to give us\naccess to other commands, including any custom ones you may implement\nyourself.\n\nClick the + (Add New Configuration) button and select Python. Give the\nconfiguration a name such as \u201cflask run\u201d. For the `flask run` command, check\n\u201cSingle instance only\u201d since you can\u2019t run the server more than once at the\nsame time.\n\nSelect Module name from the dropdown (A) then input `flask`.\n\nThe Parameters field (B) is set to the CLI command to execute (with any\narguments). In this example we use `run`, which will run the development\nserver.\n\nYou can skip this next step if you\u2019re using Environment Variables From dotenv.\nWe need to add an environment variable (C) to identify our application. Click\non the browse button and add an entry with `FLASK_APP` on the left and the\nPython import or file on the right (`hello` for example). Add an entry with\n`FLASK_ENV` and set it to `development`.\n\nNext we need to set the working directory (D) to be the folder where our\napplication resides.\n\nIf you have installed your project as a package in your virtualenv, you may\nuntick the PYTHONPATH options (E). This will more accurately match how you\ndeploy the app later.\n\nClick Apply to save the configuration, or OK to save and close the window.\nSelect the configuration in the main PyCharm window and click the play button\nnext to it to run the server.\n\nNow that we have a configuration which runs `flask run` from within PyCharm,\nwe can copy that configuration and alter the Script argument to run a\ndifferent CLI command, e.g. `flask shell`.\n\n"}, {"name": "Config", "path": "api/index#flask.Config", "type": "flask", "text": "\nWorks exactly like a dict but provides ways to fill it from files or special\ndictionaries. There are two common patterns to populate the config.\n\nEither you can fill the config from a config file:\n\nOr alternatively you can define the configuration options in the module that\ncalls `from_object()` or provide an import path to a module that should be\nloaded. It is also possible to tell it to use the same module and with that\nprovide the configuration values just before the call:\n\nIn both cases (loading from any Python file or loading from modules), only\nuppercase keys are added to the config. This makes it possible to use\nlowercase values in the config file for temporary values that are not added to\nthe config or to define the config keys in the same file that implements the\napplication.\n\nProbably the most interesting way to load configurations is from an\nenvironment variable pointing to a file:\n\nIn this case before launching the application you have to set this environment\nvariable to the file you want to use. On Linux and OS X use the export\nstatement:\n\nOn windows use `set` instead.\n\nNone\n\nLoads a configuration from an environment variable pointing to a configuration\nfile. This is basically just a shortcut with nicer error messages for this\nline of code:\n\nbool. `True` if able to load config, `False` otherwise.\n\nbool\n\nUpdate the values in the config from a file that is loaded using the `load`\nparameter. The loaded data is passed to the `from_mapping()` method.\n\nbool\n\nNew in version 2.0.\n\nUpdates the config like `update()` ignoring items with non-upper keys.\n\nNew in version 0.11.\n\nbool\n\nUpdates the values from the given object. An object can be of one of the\nfollowing two types:\n\nObjects are usually either modules or classes. `from_object()` loads only the\nuppercase attributes of the module/class. A `dict` object will not work with\n`from_object()` because the keys of a `dict` are not attributes of the `dict`\nclass.\n\nExample of module-based configuration:\n\nNothing is done to the object before loading. If the object is a class and has\n`@property` attributes, it needs to be instantiated before being passed to\nthis method.\n\nYou should not use this function to load the actual configuration but rather\nconfiguration defaults. The actual config should be loaded with\n`from_pyfile()` and ideally from a location not within the package because the\npackage might be installed system wide.\n\nSee Development / Production for an example of class-based configuration using\n`from_object()`.\n\nobj (Union[object, str]) \u2013 an import name or object\n\nNone\n\nUpdates the values in the config from a Python file. This function behaves as\nif the file was imported as module with the `from_object()` function.\n\nbool\n\nNew in version 0.7: `silent` parameter.\n\nReturns a dictionary containing a subset of configuration options that match\nthe specified namespace/prefix. Example usage:\n\nThe resulting dictionary `image_store_config` would look like:\n\nThis is often useful when configuration options map directly to keyword\narguments in functions or class constructors.\n\nDict[str, Any]\n\nNew in version 0.11.\n\n"}, {"name": "Config.from_envvar()", "path": "api/index#flask.Config.from_envvar", "type": "flask", "text": "\nLoads a configuration from an environment variable pointing to a configuration\nfile. This is basically just a shortcut with nicer error messages for this\nline of code:\n\nbool. `True` if able to load config, `False` otherwise.\n\nbool\n\n"}, {"name": "Config.from_file()", "path": "api/index#flask.Config.from_file", "type": "flask", "text": "\nUpdate the values in the config from a file that is loaded using the `load`\nparameter. The loaded data is passed to the `from_mapping()` method.\n\nbool\n\nNew in version 2.0.\n\n"}, {"name": "Config.from_mapping()", "path": "api/index#flask.Config.from_mapping", "type": "flask", "text": "\nUpdates the config like `update()` ignoring items with non-upper keys.\n\nNew in version 0.11.\n\nbool\n\n"}, {"name": "Config.from_object()", "path": "api/index#flask.Config.from_object", "type": "flask", "text": "\nUpdates the values from the given object. An object can be of one of the\nfollowing two types:\n\nObjects are usually either modules or classes. `from_object()` loads only the\nuppercase attributes of the module/class. A `dict` object will not work with\n`from_object()` because the keys of a `dict` are not attributes of the `dict`\nclass.\n\nExample of module-based configuration:\n\nNothing is done to the object before loading. If the object is a class and has\n`@property` attributes, it needs to be instantiated before being passed to\nthis method.\n\nYou should not use this function to load the actual configuration but rather\nconfiguration defaults. The actual config should be loaded with\n`from_pyfile()` and ideally from a location not within the package because the\npackage might be installed system wide.\n\nSee Development / Production for an example of class-based configuration using\n`from_object()`.\n\nobj (Union[object, str]) \u2013 an import name or object\n\nNone\n\n"}, {"name": "Config.from_pyfile()", "path": "api/index#flask.Config.from_pyfile", "type": "flask", "text": "\nUpdates the values in the config from a Python file. This function behaves as\nif the file was imported as module with the `from_object()` function.\n\nbool\n\nNew in version 0.7: `silent` parameter.\n\n"}, {"name": "Config.get_namespace()", "path": "api/index#flask.Config.get_namespace", "type": "flask", "text": "\nReturns a dictionary containing a subset of configuration options that match\nthe specified namespace/prefix. Example usage:\n\nThe resulting dictionary `image_store_config` would look like:\n\nThis is often useful when configuration options map directly to keyword\narguments in functions or class constructors.\n\nDict[str, Any]\n\nNew in version 0.11.\n\n"}, {"name": "Configuration Handling", "path": "config/index", "type": "User\u2019s Guide", "text": "\nApplications need some kind of configuration. There are different settings you\nmight want to change depending on the application environment like toggling\nthe debug mode, setting the secret key, and other such environment-specific\nthings.\n\nThe way Flask is designed usually requires the configuration to be available\nwhen the application starts up. You can hard code the configuration in the\ncode, which for many small applications is not actually that bad, but there\nare better ways.\n\nIndependent of how you load your config, there is a config object available\nwhich holds the loaded configuration values: The `config` attribute of the\n`Flask` object. This is the place where Flask itself puts certain\nconfiguration values and also where extensions can put their configuration\nvalues. But this is also where you can have your own configuration.\n\nThe `config` is actually a subclass of a dictionary and can be modified just\nlike any dictionary:\n\nCertain configuration values are also forwarded to the `Flask` object so you\ncan read and write them from there:\n\nTo update multiple keys at once you can use the `dict.update()` method:\n\nThe `ENV` and `DEBUG` config values are special because they may behave\ninconsistently if changed after the app has begun setting up. In order to set\nthe environment and debug mode reliably, Flask uses environment variables.\n\nThe environment is used to indicate to Flask, extensions, and other programs,\nlike Sentry, what context Flask is running in. It is controlled with the\n`FLASK_ENV` environment variable and defaults to `production`.\n\nSetting `FLASK_ENV` to `development` will enable debug mode. `flask run` will\nuse the interactive debugger and reloader by default in debug mode. To control\nthis separately from the environment, use the `FLASK_DEBUG` flag.\n\nChanged in version 1.0: Added `FLASK_ENV` to control the environment\nseparately from debug mode. The development environment enables debug mode.\n\nTo switch Flask to the development environment and enable debug mode, set\n`FLASK_ENV`:\n\nUsing the environment variables as described above is recommended. While it is\npossible to set `ENV` and `DEBUG` in your config or code, this is strongly\ndiscouraged. They can\u2019t be read early by the `flask` command, and some systems\nor extensions may have already configured themselves based on a previous\nvalue.\n\nThe following configuration values are used internally by Flask:\n\nWhat environment the app is running in. Flask and extensions may enable\nbehaviors based on the environment, such as enabling debug mode. The `env`\nattribute maps to this config key. This is set by the `FLASK_ENV` environment\nvariable and may not behave as expected if set in code.\n\nDo not enable development when deploying in production.\n\nDefault: `'production'`\n\nNew in version 1.0.\n\nWhether debug mode is enabled. When using `flask run` to start the development\nserver, an interactive debugger will be shown for unhandled exceptions, and\nthe server will be reloaded when code changes. The `debug` attribute maps to\nthis config key. This is enabled when `ENV` is `'development'` and is\noverridden by the `FLASK_DEBUG` environment variable. It may not behave as\nexpected if set in code.\n\nDo not enable debug mode when deploying in production.\n\nDefault: `True` if `ENV` is `'development'`, or `False` otherwise.\n\nEnable testing mode. Exceptions are propagated rather than handled by the the\napp\u2019s error handlers. Extensions may also change their behavior to facilitate\neasier testing. You should enable this in your own tests.\n\nDefault: `False`\n\nExceptions are re-raised rather than being handled by the app\u2019s error\nhandlers. If not set, this is implicitly true if `TESTING` or `DEBUG` is\nenabled.\n\nDefault: `None`\n\nDon\u2019t pop the request context when an exception occurs. If not set, this is\ntrue if `DEBUG` is true. This allows debuggers to introspect the request data\non errors, and should normally not need to be set directly.\n\nDefault: `None`\n\nIf there is no handler for an `HTTPException`-type exception, re-raise it to\nbe handled by the interactive debugger instead of returning it as a simple\nerror response.\n\nDefault: `False`\n\nTrying to access a key that doesn\u2019t exist from request dicts like `args` and\n`form` will return a 400 Bad Request error page. Enable this to treat the\nerror as an unhandled exception instead so that you get the interactive\ndebugger. This is a more specific version of `TRAP_HTTP_EXCEPTIONS`. If unset,\nit is enabled in debug mode.\n\nDefault: `None`\n\nA secret key that will be used for securely signing the session cookie and can\nbe used for any other security related needs by extensions or your\napplication. It should be a long random `bytes` or `str`. For example, copy\nthe output of this to your config:\n\nDo not reveal the secret key when posting questions or committing code.\n\nDefault: `None`\n\nThe name of the session cookie. Can be changed in case you already have a\ncookie with the same name.\n\nDefault: `'session'`\n\nThe domain match rule that the session cookie will be valid for. If not set,\nthe cookie will be valid for all subdomains of `SERVER_NAME`. If `False`, the\ncookie\u2019s domain will not be set.\n\nDefault: `None`\n\nThe path that the session cookie will be valid for. If not set, the cookie\nwill be valid underneath `APPLICATION_ROOT` or `/` if that is not set.\n\nDefault: `None`\n\nBrowsers will not allow JavaScript access to cookies marked as \u201cHTTP only\u201d for\nsecurity.\n\nDefault: `True`\n\nBrowsers will only send cookies with requests over HTTPS if the cookie is\nmarked \u201csecure\u201d. The application must be served over HTTPS for this to make\nsense.\n\nDefault: `False`\n\nRestrict how cookies are sent with requests from external sites. Can be set to\n`'Lax'` (recommended) or `'Strict'`. See Set-Cookie options.\n\nDefault: `None`\n\nNew in version 1.0.\n\nIf `session.permanent` is true, the cookie\u2019s expiration will be set this\nnumber of seconds in the future. Can either be a `datetime.timedelta` or an\n`int`.\n\nFlask\u2019s default cookie implementation validates that the cryptographic\nsignature is not older than this value.\n\nDefault: `timedelta(days=31)` (`2678400` seconds)\n\nControl whether the cookie is sent with every response when\n`session.permanent` is true. Sending the cookie every time (the default) can\nmore reliably keep the session from expiring, but uses more bandwidth. Non-\npermanent sessions are not affected.\n\nDefault: `True`\n\nWhen serving files, set the `X-Sendfile` header instead of serving the data\nwith Flask. Some web servers, such as Apache, recognize this and serve the\ndata more efficiently. This only makes sense when using such a server.\n\nDefault: `False`\n\nWhen serving files, set the cache control max age to this number of seconds.\nCan be a `datetime.timedelta` or an `int`. Override this value on a per-file\nbasis using `get_send_file_max_age()` on the application or blueprint.\n\nIf `None`, `send_file` tells the browser to use conditional requests will be\nused instead of a timed cache, which is usually preferable.\n\nDefault: `None`\n\nInform the application what host and port it is bound to. Required for\nsubdomain route matching support.\n\nIf set, will be used for the session cookie domain if `SESSION_COOKIE_DOMAIN`\nis not set. Modern web browsers will not allow setting cookies for domains\nwithout a dot. To use a domain locally, add any names that should route to the\napp to your `hosts` file.\n\nIf set, `url_for` can generate external URLs with only an application context\ninstead of a request context.\n\nDefault: `None`\n\nInform the application what path it is mounted under by the application / web\nserver. This is used for generating URLs outside the context of a request\n(inside a request, the dispatcher is responsible for setting `SCRIPT_NAME`\ninstead; see Application Dispatching for examples of dispatch configuration).\n\nWill be used for the session cookie path if `SESSION_COOKIE_PATH` is not set.\n\nDefault: `'/'`\n\nUse this scheme for generating external URLs when not in a request context.\n\nDefault: `'http'`\n\nDon\u2019t read more than this many bytes from the incoming request data. If not\nset and the request does not specify a `CONTENT_LENGTH`, no data will be read\nfor security.\n\nDefault: `None`\n\nSerialize objects to ASCII-encoded JSON. If this is disabled, the JSON\nreturned from `jsonify` will contain Unicode characters. This has security\nimplications when rendering the JSON into JavaScript in templates, and should\ntypically remain enabled.\n\nDefault: `True`\n\nSort the keys of JSON objects alphabetically. This is useful for caching\nbecause it ensures the data is serialized the same way no matter what Python\u2019s\nhash seed is. While not recommended, you can disable this for a possible\nperformance improvement at the cost of caching.\n\nDefault: `True`\n\n`jsonify` responses will be output with newlines, spaces, and indentation for\neasier reading by humans. Always enabled in debug mode.\n\nDefault: `False`\n\nThe mimetype of `jsonify` responses.\n\nDefault: `'application/json'`\n\nReload templates when they are changed. If not set, it will be enabled in\ndebug mode.\n\nDefault: `None`\n\nLog debugging information tracing how a template file was loaded. This can be\nuseful to figure out why a template was not loaded or the wrong file appears\nto be loaded.\n\nDefault: `False`\n\nWarn if cookie headers are larger than this many bytes. Defaults to `4093`.\nLarger cookies may be silently ignored by browsers. Set to `0` to disable the\nwarning.\n\nChanged in version 1.0: `LOGGER_NAME` and `LOGGER_HANDLER_POLICY` were\nremoved. See Logging for information about configuration.\n\nAdded `ENV` to reflect the `FLASK_ENV` environment variable.\n\nAdded `SESSION_COOKIE_SAMESITE` to control the session cookie\u2019s `SameSite`\noption.\n\nAdded `MAX_COOKIE_SIZE` to control a warning from Werkzeug.\n\nNew in version 0.11: `SESSION_REFRESH_EACH_REQUEST`, `TEMPLATES_AUTO_RELOAD`,\n`LOGGER_HANDLER_POLICY`, `EXPLAIN_TEMPLATE_LOADING`\n\nNew in version 0.10: `JSON_AS_ASCII`, `JSON_SORT_KEYS`,\n`JSONIFY_PRETTYPRINT_REGULAR`\n\nNew in version 0.9: `PREFERRED_URL_SCHEME`\n\nNew in version 0.8: `TRAP_BAD_REQUEST_ERRORS`, `TRAP_HTTP_EXCEPTIONS`,\n`APPLICATION_ROOT`, `SESSION_COOKIE_DOMAIN`, `SESSION_COOKIE_PATH`,\n`SESSION_COOKIE_HTTPONLY`, `SESSION_COOKIE_SECURE`\n\nNew in version 0.7: `PROPAGATE_EXCEPTIONS`, `PRESERVE_CONTEXT_ON_EXCEPTION`\n\nNew in version 0.6: `MAX_CONTENT_LENGTH`\n\nNew in version 0.5: `SERVER_NAME`\n\nNew in version 0.4: `LOGGER_NAME`\n\nConfiguration becomes more useful if you can store it in a separate file,\nideally located outside the actual application package. This makes packaging\nand distributing your application possible via various package handling tools\n(Deploying with Setuptools) and finally modifying the configuration file\nafterwards.\n\nSo a common pattern is this:\n\nThis first loads the configuration from the `yourapplication.default_settings`\nmodule and then overrides the values with the contents of the file the\n`YOURAPPLICATION_SETTINGS` environment variable points to. This environment\nvariable can be set in the shell before starting the server:\n\nThe configuration files themselves are actual Python files. Only values in\nuppercase are actually stored in the config object later on. So make sure to\nuse uppercase letters for your config keys.\n\nHere is an example of a configuration file:\n\nMake sure to load the configuration very early on, so that extensions have the\nability to access the configuration when starting up. There are other methods\non the config object as well to load from individual files. For a complete\nreference, read the `Config` object\u2019s documentation.\n\nIt is also possible to load configuration from a file in a format of your\nchoice using `from_file()`. For example to load from a TOML file:\n\nOr from a JSON file:\n\nIn addition to pointing to configuration files using environment variables,\nyou may find it useful (or necessary) to control your configuration values\ndirectly from the environment.\n\nEnvironment variables can be set in the shell before starting the server:\n\nWhile this approach is straightforward to use, it is important to remember\nthat environment variables are strings \u2013 they are not automatically\ndeserialized into Python types.\n\nHere is an example of a configuration file that uses environment variables:\n\nNotice that any value besides an empty string will be interpreted as a boolean\n`True` value in Python, which requires care if an environment explicitly sets\nvalues intended to be `False`.\n\nMake sure to load the configuration very early on, so that extensions have the\nability to access the configuration when starting up. There are other methods\non the config object as well to load from individual files. For a complete\nreference, read the `Config` class documentation.\n\nThe downside with the approach mentioned earlier is that it makes testing a\nlittle harder. There is no single 100% solution for this problem in general,\nbut there are a couple of things you can keep in mind to improve that\nexperience:\n\nMost applications need more than one configuration. There should be at least\nseparate configurations for the production server and the one used during\ndevelopment. The easiest way to handle this is to use a default configuration\nthat is always loaded and part of the version control, and a separate\nconfiguration that overrides the values as necessary as mentioned in the\nexample above:\n\nThen you just have to add a separate `config.py` file and export\n`YOURAPPLICATION_SETTINGS=/path/to/config.py` and you are done. However there\nare alternative ways as well. For example you could use imports or\nsubclassing.\n\nWhat is very popular in the Django world is to make the import explicit in the\nconfig file by adding `from yourapplication.default_settings import *` to the\ntop of the file and then overriding the changes by hand. You could also\ninspect an environment variable like `YOURAPPLICATION_MODE` and set that to\n`production`, `development` etc and import different hard-coded files based on\nthat.\n\nAn interesting pattern is also to use classes and inheritance for\nconfiguration:\n\nTo enable such a config you just have to call into `from_object()`:\n\nNote that `from_object()` does not instantiate the class object. If you need\nto instantiate the class, such as to access a property, then you must do so\nbefore calling `from_object()`:\n\nInstantiating the configuration object allows you to use `@property` in your\nconfiguration classes:\n\nThere are many different ways and it\u2019s up to you how you want to manage your\nconfiguration files. However here a list of good recommendations:\n\nNew in version 0.8.\n\nFlask 0.8 introduces instance folders. Flask for a long time made it possible\nto refer to paths relative to the application\u2019s folder directly (via\n`Flask.root_path`). This was also how many developers loaded configurations\nstored next to the application. Unfortunately however this only works well if\napplications are not packages in which case the root path refers to the\ncontents of the package.\n\nWith Flask 0.8 a new attribute was introduced: `Flask.instance_path`. It\nrefers to a new concept called the \u201cinstance folder\u201d. The instance folder is\ndesigned to not be under version control and be deployment specific. It\u2019s the\nperfect place to drop things that either change at runtime or configuration\nfiles.\n\nYou can either explicitly provide the path of the instance folder when\ncreating the Flask application or you can let Flask autodetect the instance\nfolder. For explicit configuration use the `instance_path` parameter:\n\nPlease keep in mind that this path must be absolute when provided.\n\nIf the `instance_path` parameter is not provided the following default\nlocations are used:\n\nUninstalled module:\n\nUninstalled package:\n\nInstalled module or package:\n\n`$PREFIX` is the prefix of your Python installation. This can be `/usr` or the\npath to your virtualenv. You can print the value of `sys.prefix` to see what\nthe prefix is set to.\n\nSince the config object provided loading of configuration files from relative\nfilenames we made it possible to change the loading via filenames to be\nrelative to the instance path if wanted. The behavior of relative paths in\nconfig files can be flipped between \u201crelative to the application root\u201d (the\ndefault) to \u201crelative to instance folder\u201d via the `instance_relative_config`\nswitch to the application constructor:\n\nHere is a full example of how to configure Flask to preload the config from a\nmodule and then override the config from a file in the instance folder if it\nexists:\n\nThe path to the instance folder can be found via the `Flask.instance_path`.\nFlask also provides a shortcut to open a file from the instance folder with\n`Flask.open_instance_resource()`.\n\nExample usage for both:\n\n"}, {"name": "copy_current_request_context()", "path": "api/index#flask.copy_current_request_context", "type": "flask", "text": "\nA helper function that decorates a function to retain the current request\ncontext. This is useful when working with greenlets. The moment the function\nis decorated a copy of the request context is created and then pushed when the\nfunction is called. The current session is also included in the copied request\ncontext.\n\nExample:\n\nNew in version 0.10.\n\nf (Callable) \u2013\n\nCallable\n\n"}, {"name": "DEBUG", "path": "config/index#DEBUG", "type": "Configuration", "text": "\nWhether debug mode is enabled. When using `flask run` to start the development\nserver, an interactive debugger will be shown for unhandled exceptions, and\nthe server will be reloaded when code changes. The `debug` attribute maps to\nthis config key. This is enabled when `ENV` is `'development'` and is\noverridden by the `FLASK_DEBUG` environment variable. It may not behave as\nexpected if set in code.\n\nDo not enable debug mode when deploying in production.\n\nDefault: `True` if `ENV` is `'development'`, or `False` otherwise.\n\n"}, {"name": "Debugging Application Errors", "path": "debugging/index", "type": "User\u2019s Guide", "text": "\nDo not run the development server, or enable the built-in debugger, in a\nproduction environment. The debugger allows executing arbitrary Python code\nfrom the browser. It\u2019s protected by a pin, but that should not be relied on\nfor security.\n\nUse an error logging tool, such as Sentry, as described in Error Logging\nTools, or enable logging and notifications as described in Logging.\n\nIf you have access to the server, you could add some code to start an external\ndebugger if `request.remote_addr` matches your IP. Some IDE debuggers also\nhave a remote mode so breakpoints on the server can be interacted with\nlocally. Only enable a debugger temporarily.\n\nThe built-in Werkzeug development server provides a debugger which shows an\ninteractive traceback in the browser when an unhandled error occurs during a\nrequest. This debugger should only be used during development.\n\nWarning\n\nThe debugger allows executing arbitrary Python code from the browser. It is\nprotected by a pin, but still represents a major security risk. Do not run the\ndevelopment server or debugger in a production environment.\n\nTo enable the debugger, run the development server with the `FLASK_ENV`\nenvironment variable set to `development`. This puts Flask in debug mode,\nwhich changes how it handles some errors, and enables the debugger and\nreloader.\n\n`FLASK_ENV` can only be set as an environment variable. When running from\nPython code, passing `debug=True` enables debug mode, which is mostly\nequivalent. Debug mode can be controled separately from `FLASK_ENV` with the\n`FLASK_DEBUG` environment variable as well.\n\nDevelopment Server and Command Line Interface have more information about\nrunning the debugger, debug mode, and development mode. More information about\nthe debugger can be found in the Werkzeug documentation.\n\nExternal debuggers, such as those provided by IDEs, can offer a more powerful\ndebugging experience than the built-in debugger. They can also be used to step\nthrough code during a request before an error is raised, or if no error is\nraised. Some even have a remote mode so you can debug code running on another\nmachine.\n\nWhen using an external debugger, the app should still be in debug mode, but it\ncan be useful to disable the built-in debugger and reloader, which can\ninterfere.\n\nWhen running from the command line:\n\nWhen running from Python:\n\nDisabling these isn\u2019t required, an external debugger will continue to work\nwith the following caveats. If the built-in debugger is not disabled, it will\ncatch unhandled exceptions before the external debugger can. If the reloader\nis not disabled, it could cause an unexpected reload if code changes during\ndebugging.\n\n"}, {"name": "Deferred Request Callbacks", "path": "patterns/deferredcallbacks/index", "type": "User's Guide: Design Patterns", "text": "\nOne of the design principles of Flask is that response objects are created and\npassed down a chain of potential callbacks that can modify them or replace\nthem. When the request handling starts, there is no response object yet. It is\ncreated as necessary either by a view function or by some other component in\nthe system.\n\nWhat happens if you want to modify the response at a point where the response\ndoes not exist yet? A common example for that would be a `before_request()`\ncallback that wants to set a cookie on the response object.\n\nOne way is to avoid the situation. Very often that is possible. For instance\nyou can try to move that logic into a `after_request()` callback instead.\nHowever, sometimes moving code there makes it more complicated or awkward to\nreason about.\n\nAs an alternative, you can use `after_this_request()` to register callbacks\nthat will execute after only the current request. This way you can defer code\nexecution from anywhere in the application, based on the current request.\n\nAt any time during a request, we can register a function to be called at the\nend of the request. For example you can remember the current language of the\nuser in a cookie in a `before_request()` callback:\n\n"}, {"name": "Deploying with Fabric", "path": "patterns/fabric/index", "type": "User's Guide: Design Patterns", "text": "\nFabric is a tool for Python similar to Makefiles but with the ability to\nexecute commands on a remote server. In combination with a properly set up\nPython package (Large Applications as Packages) and a good concept for\nconfigurations (Configuration Handling) it is very easy to deploy Flask\napplications to external servers.\n\nBefore we get started, here a quick checklist of things we have to ensure\nupfront:\n\nA fabfile is what controls what Fabric executes. It is named `fabfile.py` and\nexecuted by the `fab` command. All the functions defined in that file will\nshow up as `fab` subcommands. They are executed on one or more hosts. These\nhosts can be defined either in the fabfile or on the command line. In this\ncase we will add them to the fabfile.\n\nThis is a basic first example that has the ability to upload the current\nsource code to the server and install it into a pre-existing virtual\nenvironment:\n\nNow how do you execute that fabfile? You use the `fab` command. To deploy the\ncurrent version of the code on the remote server you would use this command:\n\nHowever this requires that our server already has the\n`/var/www/yourapplication` folder created and `/var/www/yourapplication/env`\nto be a virtual environment. Furthermore are we not creating the configuration\nor `.wsgi` file on the server. So how do we bootstrap a new server into our\ninfrastructure?\n\nThis now depends on the number of servers we want to set up. If we just have\none application server (which the majority of applications will have),\ncreating a command in the fabfile for this is overkill. But obviously you can\ndo that. In that case you would probably call it `setup` or `bootstrap` and\nthen pass the servername explicitly on the command line:\n\nTo setup a new server you would roughly do these steps:\n\nCreate the directory structure in `/var/www`:\n\nSo now the question is, where do the `application.wsgi` and `application.cfg`\nfiles come from?\n\nThe WSGI file has to import the application and also to set an environment\nvariable so that the application knows where to look for the config. This is a\nshort example that does exactly that:\n\nThe application itself then has to initialize itself like this to look for the\nconfig at that environment variable:\n\nThis approach is explained in detail in the Configuration Handling section of\nthe documentation.\n\nNow as mentioned above, the application will find the correct configuration\nfile by looking up the `YOURAPPLICATION_CONFIG` environment variable. So we\nhave to put the configuration in a place where the application will able to\nfind it. Configuration files have the unfriendly quality of being different on\nall computers, so you do not version them usually.\n\nA popular approach is to store configuration files for different servers in a\nseparate version control repository and check them out on all servers. Then\nsymlink the file that is active for the server into the location where it\u2019s\nexpected (eg: `/var/www/yourapplication`).\n\nEither way, in our case here we only expect one or two servers and we can\nupload them ahead of time by hand.\n\nNow we can do our first deployment. We have set up the servers so that they\nhave their virtual environments and activated apache configs. Now we can pack\nup the application and deploy it:\n\nFabric will now connect to all servers and run the commands as written down in\nthe fabfile. First it will execute pack so that we have our tarball ready and\nthen it will execute deploy and upload the source code to all servers and\ninstall it there. Thanks to the `setup.py` file we will automatically pull in\nthe required libraries into our virtual environment.\n\nFrom that point onwards there is so much that can be done to make deployment\nactually fun:\n\nWorking with Fabric is fun and you will notice that it\u2019s quite magical to type\n`fab deploy` and see your application being deployed automatically to one or\nmore remote servers.\n\n"}, {"name": "Deploying with Setuptools", "path": "patterns/distribute/index", "type": "User's Guide: Design Patterns", "text": "\nSetuptools, is an extension library that is commonly used to distribute Python\nlibraries and extensions. It extends distutils, a basic module installation\nsystem shipped with Python to also support various more complex constructs\nthat make larger applications easier to distribute:\n\nFlask itself, and all the libraries you can find on PyPI are distributed with\neither setuptools or distutils.\n\nIn this case we assume your application is called `yourapplication.py` and you\nare not using a module, but a package. If you have not yet converted your\napplication into a package, head over to Large Applications as Packages to see\nhow this can be done.\n\nA working deployment with setuptools is the first step into more complex and\nmore automated deployment scenarios. If you want to fully automate the\nprocess, also read the Deploying with Fabric chapter.\n\nBecause you have Flask installed, you have setuptools available on your\nsystem. Flask already depends upon setuptools.\n\nStandard disclaimer applies: use a virtualenv.\n\nYour setup code always goes into a file named `setup.py` next to your\napplication. The name of the file is only convention, but because everybody\nwill look for a file with that name, you better not change it.\n\nA basic `setup.py` file for a Flask application looks like this:\n\nPlease keep in mind that you have to list subpackages explicitly. If you want\nsetuptools to lookup the packages for you automatically, you can use the\n`find_packages` function:\n\nMost parameters to the `setup` function should be self explanatory,\n`include_package_data` and `zip_safe` might not be. `include_package_data`\ntells setuptools to look for a `MANIFEST.in` file and install all the entries\nthat match as package data. We will use this to distribute the static files\nand templates along with the Python module (see Distributing Resources). The\n`zip_safe` flag can be used to force or prevent zip Archive creation. In\ngeneral you probably don\u2019t want your packages to be installed as zip files\nbecause some tools do not support them and they make debugging a lot harder.\n\nIt is useful to distinguish between release and development builds. Add a\n`setup.cfg` file to configure these options.\n\nRunning `python setup.py sdist` will create a development package with \u201c.dev\u201d\nand the current date appended: `flaskr-1.0.dev20160314.tar.gz`. Running\n`python setup.py release sdist` will create a release package with only the\nversion: `flaskr-1.0.tar.gz`.\n\nIf you try to install the package you just created, you will notice that\nfolders like `static` or `templates` are not installed for you. The reason for\nthis is that setuptools does not know which files to add for you. What you\nshould do, is to create a `MANIFEST.in` file next to your `setup.py` file.\nThis file lists all the files that should be added to your tarball:\n\nDon\u2019t forget that even if you enlist them in your `MANIFEST.in` file, they\nwon\u2019t be installed for you unless you set the `include_package_data` parameter\nof the `setup` function to `True`!\n\nDependencies are declared in the `install_requires` parameter as a list. Each\nitem in that list is the name of a package that should be pulled from PyPI on\ninstallation. By default it will always use the most recent version, but you\ncan also provide minimum and maximum version requirements. Here some examples:\n\nAs mentioned earlier, dependencies are pulled from PyPI. What if you want to\ndepend on a package that cannot be found on PyPI and won\u2019t be because it is an\ninternal package you don\u2019t want to share with anyone? Just do it as if there\nwas a PyPI entry and provide a list of alternative locations where setuptools\nshould look for tarballs:\n\nMake sure that page has a directory listing and the links on the page are\npointing to the actual tarballs with their correct filenames as this is how\nsetuptools will find the files. If you have an internal company server that\ncontains the packages, provide the URL to that server.\n\nTo install your application (ideally into a virtualenv) just run the\n`setup.py` script with the `install` parameter. It will install your\napplication into the virtualenv\u2019s site-packages folder and also download and\ninstall all dependencies:\n\nIf you are developing on the package and also want the requirements to be\ninstalled, you can use the `develop` command instead:\n\nThis has the advantage of just installing a link to the site-packages folder\ninstead of copying the data over. You can then continue to work on the code\nwithout having to run `install` again after each change.\n\n"}, {"name": "Deployment Options", "path": "deploying/index", "type": "User's Guide: Deploying", "text": "\nWhile lightweight and easy to use, Flask\u2019s built-in server is not suitable for\nproduction as it doesn\u2019t scale well. Some of the options available for\nproperly running Flask in production are documented here.\n\nIf you want to deploy your Flask application to a WSGI server not listed here,\nlook up the server documentation about how to use a WSGI app with it. Just\nremember that your `Flask` application object is the actual WSGI application.\n\n"}, {"name": "Design Decisions in Flask", "path": "design/index", "type": "Additional Notes", "text": "\nIf you are curious why Flask does certain things the way it does and not\ndifferently, this section is for you. This should give you an idea about some\nof the design decisions that may appear arbitrary and surprising at first,\nespecially in direct comparison with other frameworks.\n\nA Python web application based on WSGI has to have one central callable object\nthat implements the actual application. In Flask this is an instance of the\n`Flask` class. Each Flask application has to create an instance of this class\nitself and pass it the name of the module, but why can\u2019t Flask do that itself?\n\nWithout such an explicit application object the following code:\n\nWould look like this instead:\n\nThere are three major reasons for this. The most important one is that\nimplicit application objects require that there may only be one instance at\nthe time. There are ways to fake multiple applications with a single\napplication object, like maintaining a stack of applications, but this causes\nsome problems I won\u2019t outline here in detail. Now the question is: when does a\nmicroframework need more than one application at the same time? A good example\nfor this is unit testing. When you want to test something it can be very\nhelpful to create a minimal application to test specific behavior. When the\napplication object is deleted everything it allocated will be freed again.\n\nAnother thing that becomes possible when you have an explicit object lying\naround in your code is that you can subclass the base class (`Flask`) to alter\nspecific behavior. This would not be possible without hacks if the object were\ncreated ahead of time for you based on a class that is not exposed to you.\n\nBut there is another very important reason why Flask depends on an explicit\ninstantiation of that class: the package name. Whenever you create a Flask\ninstance you usually pass it `__name__` as package name. Flask depends on that\ninformation to properly load resources relative to your module. With Python\u2019s\noutstanding support for reflection it can then access the package to figure\nout where the templates and static files are stored (see `open_resource()`).\nNow obviously there are frameworks around that do not need any configuration\nand will still be able to load templates relative to your application module.\nBut they have to use the current working directory for that, which is a very\nunreliable way to determine where the application is. The current working\ndirectory is process-wide and if you are running multiple applications in one\nprocess (which could happen in a webserver without you knowing) the paths will\nbe off. Worse: many webservers do not set the working directory to the\ndirectory of your application but to the document root which does not have to\nbe the same folder.\n\nThe third reason is \u201cexplicit is better than implicit\u201d. That object is your\nWSGI application, you don\u2019t have to remember anything else. If you want to\napply a WSGI middleware, just wrap it and you\u2019re done (though there are better\nways to do that so that you do not lose the reference to the application\nobject `wsgi_app()`).\n\nFurthermore this design makes it possible to use a factory function to create\nthe application which is very helpful for unit testing and similar things\n(Application Factories).\n\nFlask uses the Werkzeug routing system which was designed to automatically\norder routes by complexity. This means that you can declare routes in\narbitrary order and they will still work as expected. This is a requirement if\nyou want to properly implement decorator based routing since decorators could\nbe fired in undefined order when the application is split into multiple\nmodules.\n\nAnother design decision with the Werkzeug routing system is that routes in\nWerkzeug try to ensure that URLs are unique. Werkzeug will go quite far with\nthat in that it will automatically redirect to a canonical URL if a route is\nambiguous.\n\nFlask decides on one template engine: Jinja2. Why doesn\u2019t Flask have a\npluggable template engine interface? You can obviously use a different\ntemplate engine, but Flask will still configure Jinja2 for you. While that\nlimitation that Jinja2 is always configured will probably go away, the\ndecision to bundle one template engine and use that will not.\n\nTemplate engines are like programming languages and each of those engines has\na certain understanding about how things work. On the surface they all work\nthe same: you tell the engine to evaluate a template with a set of variables\nand take the return value as string.\n\nBut that\u2019s about where similarities end. Jinja2 for example has an extensive\nfilter system, a certain way to do template inheritance, support for reusable\nblocks (macros) that can be used from inside templates and also from Python\ncode, supports iterative template rendering, configurable syntax and more. On\nthe other hand an engine like Genshi is based on XML stream evaluation,\ntemplate inheritance by taking the availability of XPath into account and\nmore. Mako on the other hand treats templates similar to Python modules.\n\nWhen it comes to connecting a template engine with an application or framework\nthere is more than just rendering templates. For instance, Flask uses Jinja2\u2019s\nextensive autoescaping support. Also it provides ways to access macros from\nJinja2 templates.\n\nA template abstraction layer that would not take the unique features of the\ntemplate engines away is a science on its own and a too large undertaking for\na microframework like Flask.\n\nFurthermore extensions can then easily depend on one template language being\npresent. You can easily use your own templating language, but an extension\ncould still depend on Jinja itself.\n\nWhy does Flask call itself a microframework and yet it depends on two\nlibraries (namely Werkzeug and Jinja2). Why shouldn\u2019t it? If we look over to\nthe Ruby side of web development there we have a protocol very similar to\nWSGI. Just that it\u2019s called Rack there, but besides that it looks very much\nlike a WSGI rendition for Ruby. But nearly all applications in Ruby land do\nnot work with Rack directly, but on top of a library with the same name. This\nRack library has two equivalents in Python: WebOb (formerly Paste) and\nWerkzeug. Paste is still around but from my understanding it\u2019s sort of\ndeprecated in favour of WebOb. The development of WebOb and Werkzeug started\nside by side with similar ideas in mind: be a good implementation of WSGI for\nother applications to take advantage.\n\nFlask is a framework that takes advantage of the work already done by Werkzeug\nto properly interface WSGI (which can be a complex task at times). Thanks to\nrecent developments in the Python package infrastructure, packages with\ndependencies are no longer an issue and there are very few reasons against\nhaving libraries that depend on others.\n\nFlask uses thread local objects (context local objects in fact, they support\ngreenlet contexts as well) for request, session and an extra object you can\nput your own things on (`g`). Why is that and isn\u2019t that a bad idea?\n\nYes it is usually not such a bright idea to use thread locals. They cause\ntroubles for servers that are not based on the concept of threads and make\nlarge applications harder to maintain. However Flask is just not designed for\nlarge applications or asynchronous servers. Flask wants to make it quick and\neasy to write a traditional web application.\n\nAlso see the Becoming Big section of the documentation for some inspiration\nfor larger applications based on Flask.\n\nFlask supports `async` coroutines for view functions by executing the\ncoroutine on a separate thread instead of using an event loop on the main\nthread as an async-first (ASGI) framework would. This is necessary for Flask\nto remain backwards compatible with extensions and code built before `async`\nwas introduced into Python. This compromise introduces a performance cost\ncompared with the ASGI frameworks, due to the overhead of the threads.\n\nDue to how tied to WSGI Flask\u2019s code is, it\u2019s not clear if it\u2019s possible to\nmake the `Flask` class support ASGI and WSGI at the same time. Work is\ncurrently being done in Werkzeug to work with ASGI, which may eventually\nenable support in Flask as well.\n\nSee Using async and await for more discussion.\n\nFlask will never have a database layer. It will not have a form library or\nanything else in that direction. Flask itself just bridges to Werkzeug to\nimplement a proper WSGI application and to Jinja2 to handle templating. It\nalso binds to a few common standard library packages such as logging.\nEverything else is up for extensions.\n\nWhy is this the case? Because people have different preferences and\nrequirements and Flask could not meet those if it would force any of this into\nthe core. The majority of web applications will need a template engine in some\nsort. However not every application needs a SQL database.\n\nThe idea of Flask is to build a good foundation for all applications.\nEverything else is up to you or extensions.\n\n"}, {"name": "Development Server", "path": "server/index", "type": "User\u2019s Guide", "text": "\nFlask provides a `run` command to run the application with a development\nserver. In development mode, this server provides an interactive debugger and\nwill reload when code is changed.\n\nWarning\n\nDo not use the development server when deploying to production. It is intended\nfor use only during local development. It is not designed to be particularly\nefficient, stable, or secure.\n\nSee Deployment Options for deployment options.\n\nThe `flask run` command line script is the recommended way to run the\ndevelopment server. It requires setting the `FLASK_APP` environment variable\nto point to your application, and `FLASK_ENV=development` to fully enable\ndevelopment mode.\n\nThis enables the development environment, including the interactive debugger\nand reloader, and then starts the server on http://localhost:5000/. Use `flask\nrun --help` to see the available options, and Command Line Interface for\ndetailed instructions about configuring and using the CLI.\n\nNote\n\nPrior to Flask 1.0 the `FLASK_ENV` environment variable was not supported and\nyou needed to enable debug mode by exporting `FLASK_DEBUG=1`. This can still\nbe used to control debug mode, but you should prefer setting the development\nenvironment as shown above.\n\nWhen using the `flask run` command with the reloader, the server will continue\nto run even if you introduce syntax errors or other initialization errors into\nthe code. Accessing the site will show the interactive debugger for the error,\nrather than crashing the server. This feature is called \u201clazy loading\u201d.\n\nIf a syntax error is already present when calling `flask run`, it will fail\nimmediately and show the traceback rather than waiting until the site is\naccessed. This is intended to make errors more visible initially while still\nallowing the server to handle errors on reload.\n\nTo override this behavior and always fail immediately, even on reload, pass\nthe `--eager-loading` option. To always keep the server running, even on the\ninitial call, pass `--lazy-loading`.\n\nAs an alternative to the `flask run` command, the development server can also\nbe started from Python with the `Flask.run()` method. This method takes\narguments similar to the CLI options to control the server. The main\ndifference from the CLI command is that the server will crash if there are\nerrors when reloading.\n\n`debug=True` can be passed to enable the debugger and reloader, but the\n`FLASK_ENV=development` environment variable is still required to fully enable\ndevelopment mode.\n\nPlace the call in a main block, otherwise it will interfere when trying to\nimport and run the application with a production server later.\n\n"}, {"name": "dump()", "path": "api/index#flask.json.dump", "type": "flask.json", "text": "\nSerialize an object to JSON written to a file object.\n\nTakes the same arguments as the built-in `json.dump()`, with some defaults\nfrom application configuration.\n\nNone\n\nChanged in version 2.0: Writing to a binary file, and the `encoding` argument,\nis deprecated and will be removed in Flask 2.1.\n\n"}, {"name": "dumps()", "path": "api/index#flask.json.dumps", "type": "flask.json", "text": "\nSerialize an object to a string of JSON.\n\nTakes the same arguments as the built-in `json.dumps()`, with some defaults\nfrom application configuration.\n\nstr\n\nChanged in version 2.0: `encoding` is deprecated and will be removed in Flask\n2.1.\n\nChanged in version 1.0.3: `app` can be passed directly, rather than requiring\nan app context for configuration.\n\n"}, {"name": "ENV", "path": "config/index#ENV", "type": "Configuration", "text": "\nWhat environment the app is running in. Flask and extensions may enable\nbehaviors based on the environment, such as enabling debug mode. The `env`\nattribute maps to this config key. This is set by the `FLASK_ENV` environment\nvariable and may not behave as expected if set in code.\n\nDo not enable development when deploying in production.\n\nDefault: `'production'`\n\nNew in version 1.0.\n\n"}, {"name": "escape()", "path": "api/index#flask.escape", "type": "flask", "text": "\nReplace the characters `&`, `<`, `>`, `'`, and `\"` in the string with HTML-\nsafe sequences. Use this if you need to display text that might contain such\ncharacters in HTML.\n\nIf the object has an `__html__` method, it is called and the return value is\nassumed to already be safe for HTML.\n\ns \u2013 An object to be converted to a string and escaped.\n\nA `Markup` string with the escaped text.\n\n"}, {"name": "EXPLAIN_TEMPLATE_LOADING", "path": "config/index#EXPLAIN_TEMPLATE_LOADING", "type": "Configuration", "text": "\nLog debugging information tracing how a template file was loaded. This can be\nuseful to figure out why a template was not loaded or the wrong file appears\nto be loaded.\n\nDefault: `False`\n\n"}, {"name": "Extensions", "path": "extensions/index", "type": "User\u2019s Guide", "text": "\nExtensions are extra packages that add functionality to a Flask application.\nFor example, an extension might add support for sending email or connecting to\na database. Some extensions add entire new frameworks to help build certain\ntypes of applications, like a REST API.\n\nFlask extensions are usually named \u201cFlask-Foo\u201d or \u201cFoo-Flask\u201d. You can search\nPyPI for packages tagged with Framework :: Flask.\n\nConsult each extension\u2019s documentation for installation, configuration, and\nusage instructions. Generally, extensions pull their own configuration from\n`app.config` and are passed an application instance during initialization. For\nexample, an extension called \u201cFlask-Foo\u201d might be used like this:\n\nWhile the PyPI contains many Flask extensions, you may not find an extension\nthat fits your need. If this is the case, you can create your own. Read Flask\nExtension Development to develop your own Flask extension.\n\n"}, {"name": "FastCGI", "path": "deploying/fastcgi/index", "type": "User's Guide: Deploying", "text": "\nFastCGI is a deployment option on servers like nginx, lighttpd, and cherokee;\nsee uWSGI and Standalone WSGI Containers for other options. To use your WSGI\napplication with any of them you will need a FastCGI server first. The most\npopular one is flup which we will use for this guide. Make sure to have it\ninstalled to follow along.\n\nWatch Out\n\nPlease make sure in advance that any `app.run()` calls you might have in your\napplication file are inside an `if __name__ == '__main__':` block or moved to\na separate file. Just make sure it\u2019s not called because this will always start\na local WSGI server which we do not want if we deploy that application to\nFastCGI.\n\nFirst you need to create the FastCGI server file. Let\u2019s call it\n`yourapplication.fcgi`:\n\nThis is enough for Apache to work, however nginx and older versions of\nlighttpd need a socket to be explicitly passed to communicate with the FastCGI\nserver. For that to work you need to pass the path to the socket to the\n`WSGIServer`:\n\nThe path has to be the exact same path you define in the server config.\n\nSave the `yourapplication.fcgi` file somewhere you will find it again. It\nmakes sense to have that in `/var/www/yourapplication` or something similar.\n\nMake sure to set the executable bit on that file so that the servers can\nexecute it:\n\nThe example above is good enough for a basic Apache deployment but your\n`.fcgi` file will appear in your application URL e.g.\n`example.com/yourapplication.fcgi/news/`. There are few ways to configure your\napplication so that yourapplication.fcgi does not appear in the URL. A\npreferable way is to use the ScriptAlias and SetHandler configuration\ndirectives to route requests to the FastCGI server. The following example uses\nFastCgiServer to start 5 instances of the application which will handle all\nincoming requests:\n\nThese processes will be managed by Apache. If you\u2019re using a standalone\nFastCGI server, you can use the FastCgiExternalServer directive instead. Note\nthat in the following the path is not real, it\u2019s simply used as an identifier\nto other directives such as AliasMatch:\n\nIf you cannot set ScriptAlias, for example on a shared web host, you can use\nWSGI middleware to remove yourapplication.fcgi from the URLs. Set .htaccess:\n\nSet yourapplication.fcgi:\n\nA basic FastCGI configuration for lighttpd looks like that:\n\nRemember to enable the FastCGI, alias and rewrite modules. This configuration\nbinds the application to `/yourapplication`. If you want the application to\nwork in the URL root you have to work around a lighttpd bug with the\n`LighttpdCGIRootFix` middleware.\n\nMake sure to apply it only if you are mounting the application the URL root.\nAlso, see the Lighty docs for more information on FastCGI and Python (note\nthat explicitly passing a socket to run() is no longer necessary).\n\nInstalling FastCGI applications on nginx is a bit different because by default\nno FastCGI parameters are forwarded.\n\nA basic Flask FastCGI configuration for nginx looks like this:\n\nThis configuration binds the application to `/yourapplication`. If you want to\nhave it in the URL root it\u2019s a bit simpler because you don\u2019t have to figure\nout how to calculate `PATH_INFO` and `SCRIPT_NAME`:\n\nSince nginx and others do not load FastCGI apps, you have to do it by\nyourself. Supervisor can manage FastCGI processes. You can look around for\nother FastCGI process managers or write a script to run your `.fcgi` file at\nboot, e.g. using a SysV `init.d` script. For a temporary solution, you can\nalways run the `.fcgi` script inside GNU screen. See `man screen` for details,\nand note that this is a manual solution which does not persist across system\nrestart:\n\nFastCGI deployments tend to be hard to debug on most web servers. Very often\nthe only thing the server log tells you is something along the lines of\n\u201cpremature end of headers\u201d. In order to debug the application the only thing\nthat can really give you ideas why it breaks is switching to the correct user\nand executing the application by hand.\n\nThis example assumes your application is called `application.fcgi` and that\nyour web server user is `www-data`:\n\nIn this case the error seems to be \u201cyourapplication\u201d not being on the python\npath. Common problems are:\n\n"}, {"name": "flash()", "path": "api/index#flask.flash", "type": "flask", "text": "\nFlashes a message to the next request. In order to remove the flashed message\nfrom the session and to display it to the user, the template has to call\n`get_flashed_messages()`.\n\nChanged in version 0.3: `category` parameter added.\n\nNone\n\n"}, {"name": "Flask", "path": "api/index#flask.Flask", "type": "flask", "text": "\nThe flask object implements a WSGI application and acts as the central object.\nIt is passed the name of the module or package of the application. Once it is\ncreated it will act as a central registry for the view functions, the URL\nrules, template configuration and much more.\n\nThe name of the package is used to resolve resources from inside the package\nor the folder the module is contained in depending on if the package parameter\nresolves to an actual python package (a folder with an `__init__.py` file\ninside) or a standard module (just a `.py` file).\n\nFor more information about resource loading, see `open_resource()`.\n\nUsually you create a `Flask` instance in your main module or in the\n`__init__.py` file of your package like this:\n\nAbout the First Parameter\n\nThe idea of the first parameter is to give Flask an idea of what belongs to\nyour application. This name is used to find resources on the filesystem, can\nbe used by extensions to improve debugging information and a lot more.\n\nSo it\u2019s important what you provide there. If you are using a single module,\n`__name__` is always the correct value. If you however are using a package,\nit\u2019s usually recommended to hardcode the name of your package there.\n\nFor example if your application is defined in `yourapplication/app.py` you\nshould create it with one of the two versions below:\n\nWhy is that? The application will work even with `__name__`, thanks to how\nresources are looked up. However it will make debugging more painful. Certain\nextensions can make assumptions based on the import name of your application.\nFor example the Flask-SQLAlchemy extension will look for the code in your\napplication that triggered an SQL query in debug mode. If the import name is\nnot properly set up, that debugging information is lost. (For example it would\nonly pick up SQL queries in `yourapplication.app` and not\n`yourapplication.views.frontend`)\n\nNew in version 1.0: The `host_matching` and `static_host` parameters were\nadded.\n\nNew in version 1.0: The `subdomain_matching` parameter was added. Subdomain\nmatching needs to be enabled manually now. Setting `SERVER_NAME` does not\nimplicitly enable it.\n\nNew in version 0.11: The `root_path` parameter was added.\n\nNew in version 0.8: The `instance_path` and `instance_relative_config`\nparameters were added.\n\nNew in version 0.7: The `static_url_path`, `static_folder`, and\n`template_folder` parameters were added.\n\nRegister a custom template filter. Works exactly like the `template_filter()`\ndecorator.\n\nNone\n\nRegister a custom template global function. Works exactly like the\n`template_global()` decorator.\n\nNew in version 0.10.\n\nNone\n\nRegister a custom template test. Works exactly like the `template_test()`\ndecorator.\n\nNew in version 0.10.\n\nNone\n\nRegister a rule for routing incoming requests and building URLs. The `route()`\ndecorator is a shortcut to call this with the `view_func` argument. These are\nequivalent:\n\nSee URL Route Registrations.\n\nThe endpoint name for the route defaults to the name of the view function if\nthe `endpoint` parameter isn\u2019t passed. An error will be raised if a function\nhas already been registered for the endpoint.\n\nThe `methods` parameter defaults to `[\"GET\"]`. `HEAD` is always added\nautomatically, and `OPTIONS` is added automatically by default.\n\n`view_func` does not necessarily need to be passed, but if the rule should\nparticipate in routing an endpoint name must be associated with a view\nfunction at some point with the `endpoint()` decorator.\n\nIf `view_func` has a `required_methods` attribute, those methods are added to\nthe passed and automatic methods. If it has a `provide_automatic_methods`\nattribute, it is used as the default if the parameter is not passed.\n\nNone\n\nRegister a function to run after each request to this object.\n\nThe function is called with the response object, and must return a response\nobject. This allows the functions to modify or replace the response before it\nis sent.\n\nIf a function raises an exception, any remaining `after_request` functions\nwill not be called. Therefore, this should not be used for actions that must\nexecute, such as to close resources. Use `teardown_request()` for that.\n\nf (Callable[[Response], Response]) \u2013\n\nCallable[[Response], Response]\n\nA data structure of functions to call at the end of each request, in the\nformat `{scope: [functions]}`. The `scope` key is the name of a blueprint the\nfunctions are active for, or `None` for all requests.\n\nTo register a function, use the `after_request()` decorator.\n\nThis data structure is internal. It should not be modified directly and its\nformat may change at any time.\n\nCreate an `AppContext`. Use as a `with` block to push the context, which will\nmake `current_app` point at this application.\n\nAn application context is automatically pushed by `RequestContext.push()` when\nhandling a request, and when running a CLI command. Use this to manually\ncreate a context outside of these situations.\n\nSee The Application Context.\n\nNew in version 0.9.\n\nflask.ctx.AppContext\n\nalias of `flask.ctx._AppCtxGlobals`\n\nReturn a sync function that will run the coroutine function.\n\nOverride this method to change how the app converts async code to be\nsynchronously callable.\n\nNew in version 2.0.\n\nfunc (Callable[[...], Coroutine]) \u2013\n\nCallable[[\u2026], Any]\n\nTries to locate the instance path if it was not provided to the constructor of\nthe application class. It will basically calculate the path to a folder named\n`instance` next to your main file or the package.\n\nNew in version 0.8.\n\nstr\n\nRegisters a function to be run before the first request to this instance of\nthe application.\n\nThe function will be called without any arguments and its return value is\nignored.\n\nNew in version 0.8.\n\nf (Callable[[], None]) \u2013\n\nCallable[[], None]\n\nA list of functions that will be called at the beginning of the first request\nto this instance. To register a function, use the `before_first_request()`\ndecorator.\n\nNew in version 0.8.\n\nRegister a function to run before each request.\n\nFor example, this can be used to open a database connection, or to load the\nlogged in user from the session.\n\nThe function will be called without any arguments. If it returns a non-`None`\nvalue, the value is handled as if it was the return value from the view, and\nfurther request handling is stopped.\n\nf (Callable[[], None]) \u2013\n\nCallable[[], None]\n\nA data structure of functions to call at the beginning of each request, in the\nformat `{scope: [functions]}`. The `scope` key is the name of a blueprint the\nfunctions are active for, or `None` for all requests.\n\nTo register a function, use the `before_request()` decorator.\n\nThis data structure is internal. It should not be modified directly and its\nformat may change at any time.\n\nMaps registered blueprint names to blueprint objects. The dict retains the\norder the blueprints were registered in. Blueprints can be registered multiple\ntimes, this dict does not track how often they were attached.\n\nNew in version 0.7.\n\nThe Click command group for registering CLI commands for this object. The\ncommands are available from the `flask` command once the application has been\ndiscovered and blueprints have been registered.\n\nThe configuration dictionary as `Config`. This behaves exactly like a regular\ndictionary but supports additional methods to load a config from files.\n\nalias of `flask.config.Config`\n\nRegisters a template context processor function.\n\nf (Callable[[], Dict[str, Any]]) \u2013\n\nCallable[[], Dict[str, Any]]\n\nCreates the loader for the Jinja2 environment. Can be used to override just\nthe loader and keeping the rest unchanged. It\u2019s discouraged to override this\nfunction. Instead one should override the `jinja_loader()` function instead.\n\nThe global loader dispatches between the loaders of the application and the\nindividual blueprints.\n\nNew in version 0.7.\n\nflask.templating.DispatchingJinjaLoader\n\nCreate the Jinja environment based on `jinja_options` and the various Jinja-\nrelated methods of the app. Changing `jinja_options` after this will have no\neffect. Also adds Flask-related globals and filters to the environment.\n\nChanged in version 0.11: `Environment.auto_reload` set in accordance with\n`TEMPLATES_AUTO_RELOAD` configuration option.\n\nNew in version 0.5.\n\nflask.templating.Environment\n\nCreates a URL adapter for the given request. The URL adapter is created at a\npoint where the request context is not yet set up so the request is passed\nexplicitly.\n\nChanged in version 1.0: `SERVER_NAME` no longer implicitly enables subdomain\nmatching. Use `subdomain_matching` instead.\n\nChanged in version 0.9: This can now also be called without a request object\nwhen the URL adapter is created for the application context.\n\nNew in version 0.6.\n\nrequest (Optional[flask.wrappers.Request]) \u2013\n\nOptional[werkzeug.routing.MapAdapter]\n\nWhether debug mode is enabled. When using `flask run` to start the development\nserver, an interactive debugger will be shown for unhandled exceptions, and\nthe server will be reloaded when code changes. This maps to the `DEBUG` config\nkey. This is enabled when `env` is `'development'` and is overridden by the\n`FLASK_DEBUG` environment variable. It may not behave as expected if set in\ncode.\n\nDo not enable debug mode when deploying in production.\n\nDefault: `True` if `env` is `'development'`, or `False` otherwise.\n\nDefault configuration parameters.\n\nShortcut for `route()` with `methods=[\"DELETE\"]`.\n\nNew in version 2.0.\n\nCallable\n\nDoes the request dispatching. Matches the URL and returns the return value of\nthe view or error handler. This does not have to be a response object. In\norder to convert the return value to a proper response object, call\n`make_response()`.\n\nChanged in version 0.7: This no longer does the exception handling, this code\nwas moved to the new `full_dispatch_request()`.\n\nUnion[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None],\nTuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]],\nUnion[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]],\nList[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]],\nTuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]],\nint], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None,\nNone]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]],\nList[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], WSGIApplication]\n\nCalled right before the application context is popped.\n\nWhen handling a request, the application context is popped after the request\ncontext. See `do_teardown_request()`.\n\nThis calls all functions decorated with `teardown_appcontext()`. Then the\n`appcontext_tearing_down` signal is sent.\n\nThis is called by `AppContext.pop()`.\n\nNew in version 0.9.\n\nexc (Optional[BaseException]) \u2013\n\nNone\n\nCalled after the request is dispatched and the response is returned, right\nbefore the request context is popped.\n\nThis calls all functions decorated with `teardown_request()`, and\n`Blueprint.teardown_request()` if a blueprint handled the request. Finally,\nthe `request_tearing_down` signal is sent.\n\nThis is called by `RequestContext.pop()`, which may be delayed during testing\nto maintain access to resources.\n\nexc (Optional[BaseException]) \u2013 An unhandled exception raised while\ndispatching the request. Detected from the current exception information if\nnot passed. Passed to each teardown function.\n\nNone\n\nChanged in version 0.9: Added the `exc` argument.\n\nDecorate a view function to register it for the given endpoint. Used if a rule\nis added without a `view_func` with `add_url_rule()`.\n\nendpoint (str) \u2013 The endpoint name to associate with the view function.\n\nCallable\n\nEnsure that the function is synchronous for WSGI workers. Plain `def`\nfunctions are returned as-is. `async def` functions are wrapped to run and\nwait for the response.\n\nOverride this method to change how the app runs async views.\n\nNew in version 2.0.\n\nfunc (Callable) \u2013\n\nCallable\n\nWhat environment the app is running in. Flask and extensions may enable\nbehaviors based on the environment, such as enabling debug mode. This maps to\nthe `ENV` config key. This is set by the `FLASK_ENV` environment variable and\nmay not behave as expected if set in code.\n\nDo not enable development when deploying in production.\n\nDefault: `'production'`\n\nA data structure of registered error handlers, in the format `{scope: {code:\n{class: handler}}}``. The `scope` key is the name of a blueprint the handlers\nare active for, or `None` for all requests. The `code` key is the HTTP status\ncode for `HTTPException`, or `None` for other exceptions. The innermost\ndictionary maps exception classes to handler functions.\n\nTo register an error handler, use the `errorhandler()` decorator.\n\nThis data structure is internal. It should not be modified directly and its\nformat may change at any time.\n\nRegister a function to handle errors by code or exception class.\n\nA decorator that is used to register a function given an error code. Example:\n\nYou can also register handlers for arbitrary exceptions:\n\nNew in version 0.7: Use `register_error_handler()` instead of modifying\n`error_handler_spec` directly, for application wide error handlers.\n\nNew in version 0.7: One can now additionally also register custom exception\ntypes that do not necessarily have to be a subclass of the `HTTPException`\nclass.\n\ncode_or_exception (Union[Type[Exception], int]) \u2013 the code as integer for the\nhandler, or an arbitrary exception\n\nCallable\n\na place where extensions can store application specific state. For example\nthis is where an extension could store database engines and similar things.\n\nThe key must match the name of the extension module. For example in case of a\n\u201cFlask-Foo\u201d extension in `flask_foo`, the key would be `'foo'`.\n\nNew in version 0.7.\n\nDispatches the request and on top of that performs request pre and\npostprocessing as well as HTTP exception catching and error handling.\n\nNew in version 0.7.\n\nflask.wrappers.Response\n\nShortcut for `route()` with `methods=[\"GET\"]`.\n\nNew in version 2.0.\n\nCallable\n\nUsed by `send_file()` to determine the `max_age` cache value for a given file\npath if it wasn\u2019t passed.\n\nBy default, this returns `SEND_FILE_MAX_AGE_DEFAULT` from the configuration of\n`current_app`. This defaults to `None`, which tells the browser to use\nconditional requests instead of a timed cache, which is usually preferable.\n\nChanged in version 2.0: The default configuration is `None` instead of 12\nhours.\n\nNew in version 0.9.\n\nfilename (str) \u2013\n\nOptional[int]\n\nThis attribute is set to `True` if the application started handling the first\nrequest.\n\nNew in version 0.8.\n\nHandle an exception that did not have an error handler associated with it, or\nthat was raised from an error handler. This always causes a 500\n`InternalServerError`.\n\nAlways sends the `got_request_exception` signal.\n\nIf `propagate_exceptions` is `True`, such as in debug mode, the error will be\nre-raised so that the debugger can display it. Otherwise, the original\nexception is logged, and an `InternalServerError` is returned.\n\nIf an error handler is registered for `InternalServerError` or `500`, it will\nbe used. For consistency, the handler will always receive the\n`InternalServerError`. The original unhandled exception is available as\n`e.original_exception`.\n\nChanged in version 1.1.0: Always passes the `InternalServerError` instance to\nthe handler, setting `original_exception` to the unhandled error.\n\nChanged in version 1.1.0: `after_request` functions and other finalization is\ndone even for the default 500 response when there is no handler.\n\nNew in version 0.3.\n\ne (Exception) \u2013\n\nflask.wrappers.Response\n\nHandles an HTTP exception. By default this will invoke the registered error\nhandlers and fall back to returning the exception as response.\n\nChanged in version 1.0.3: `RoutingException`, used internally for actions such\nas slash redirects during routing, is not passed to error handlers.\n\nChanged in version 1.0: Exceptions are looked up by code and by MRO, so\n`HTTPExcpetion` subclasses can be handled with a catch-all handler for the\nbase `HTTPException`.\n\nNew in version 0.3.\n\ne (werkzeug.exceptions.HTTPException) \u2013\n\nUnion[werkzeug.exceptions.HTTPException, Response, AnyStr, Dict[str, Any],\nGenerator[AnyStr, None, None], Tuple[Union[Response, AnyStr, Dict[str, Any],\nGenerator[AnyStr, None, None]], Union[Headers, Dict[str, Union[str, List[str],\nTuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]],\nTuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]],\nint], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None,\nNone]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]],\nList[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], WSGIApplication]\n\nHandle `BuildError` on `url_for()`.\n\nstr\n\nThis method is called whenever an exception occurs that should be handled. A\nspecial case is `HTTPException` which is forwarded to the\n`handle_http_exception()` method. This function will either return a response\nvalue or reraise the exception with the same traceback.\n\nChanged in version 1.0: Key errors raised from request data like `form` show\nthe bad key in debug mode rather than a generic bad request message.\n\nNew in version 0.7.\n\ne (Exception) \u2013\n\nUnion[werkzeug.exceptions.HTTPException, Response, AnyStr, Dict[str, Any],\nGenerator[AnyStr, None, None], Tuple[Union[Response, AnyStr, Dict[str, Any],\nGenerator[AnyStr, None, None]], Union[Headers, Dict[str, Union[str, List[str],\nTuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]],\nTuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]],\nint], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None,\nNone]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]],\nList[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], WSGIApplication]\n\n`True` if `static_folder` is set.\n\nNew in version 0.5.\n\nThe name of the package or module that this object belongs to. Do not change\nthis once it is set by the constructor.\n\nInjects the URL defaults for the given endpoint directly into the values\ndictionary passed. This is used internally and automatically called on URL\nbuilding.\n\nNew in version 0.7.\n\nNone\n\nHolds the path to the instance folder.\n\nNew in version 0.8.\n\nIterates over all blueprints by the order they were registered.\n\nNew in version 0.11.\n\nValuesView[Blueprint]\n\nThe Jinja environment used to load templates.\n\nThe environment is created the first time this property is accessed. Changing\n`jinja_options` after that will have no effect.\n\nalias of `flask.templating.Environment`\n\nThe Jinja loader for this object\u2019s templates. By default this is a class\n`jinja2.loaders.FileSystemLoader` to `template_folder` if it is set.\n\nNew in version 0.5.\n\nOptions that are passed to the Jinja environment in\n`create_jinja_environment()`. Changing these options after the environment is\ncreated (accessing `jinja_env`) will have no effect.\n\nChanged in version 1.1.0: This is a `dict` instead of an `ImmutableDict` to\nallow easier configuration.\n\nalias of `flask.json.JSONDecoder`\n\nalias of `flask.json.JSONEncoder`\n\nLogs an exception. This is called by `handle_exception()` if debugging is\ndisabled and right before the handler is called. The default implementation\nlogs the exception as error on the `logger`.\n\nNew in version 0.8.\n\nexc_info (Union[Tuple[type, BaseException, types.TracebackType], Tuple[None,\nNone, None]]) \u2013\n\nNone\n\nA standard Python `Logger` for the app, with the same name as `name`.\n\nIn debug mode, the logger\u2019s `level` will be set to `DEBUG`.\n\nIf there are no handlers configured, a default handler will be added. See\nLogging for more information.\n\nChanged in version 1.1.0: The logger takes the same name as `name` rather than\nhard-coding `\"flask.app\"`.\n\nChanged in version 1.0.0: Behavior was simplified. The logger is always named\n`\"flask.app\"`. The level is only set during configuration, it doesn\u2019t check\n`app.debug` each time. Only one format is used, not different ones depending\non `app.debug`. No handlers are removed, and a handler is only added if no\nhandlers are already configured.\n\nNew in version 0.3.\n\nUsed to create the config attribute by the Flask constructor. The\n`instance_relative` parameter is passed in from the constructor of Flask\n(there named `instance_relative_config`) and indicates if the config should be\nrelative to the instance path or the root path of the application.\n\nNew in version 0.8.\n\ninstance_relative (bool) \u2013\n\nflask.config.Config\n\nThis method is called to create the default `OPTIONS` response. This can be\nchanged through subclassing to change the default behavior of `OPTIONS`\nresponses.\n\nNew in version 0.7.\n\nflask.wrappers.Response\n\nConvert the return value from a view function to an instance of\n`response_class`.\n\nrv (Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None],\nTuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]],\nUnion[Headers, Dict[str, Union[str, List[str], Tuple[str, ...]]],\nList[Tuple[str, Union[str, List[str], Tuple[str, ...]]]]]],\nTuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]],\nint], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None,\nNone]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, ...]]],\nList[Tuple[str, Union[str, List[str], Tuple[str, ...]]]]]], WSGIApplication])\n\u2013\n\nthe return value from the view function. The view function must return a\nresponse. Returning `None`, or the view ending without returning, is not\nallowed. The following types are allowed for `view_rv`:\n\nA response object is created with the string encoded to UTF-8 as the body.\n\nA response object is created with the bytes as the body.\n\nA dictionary that will be jsonify\u2019d before being returned.\n\nEither `(body, status, headers)`, `(body, status)`, or `(body, headers)`,\nwhere `body` is any of the other types allowed here, `status` is a string or\nan integer, and `headers` is a dictionary or a list of `(key, value)` tuples.\nIf `body` is a `response_class` instance, `status` overwrites the exiting\nvalue and `headers` are extended.\n\nThe object is returned unchanged.\n\nThe object is coerced to `response_class`.\n\nThe function is called as a WSGI application. The result is used to create a\nresponse object.\n\nflask.wrappers.Response\n\nChanged in version 0.9: Previously a tuple was interpreted as the arguments\nfor the response object.\n\nReturns the shell context for an interactive shell for this application. This\nruns all the registered shell context processors.\n\nNew in version 0.11.\n\ndict\n\nThe name of the application. This is usually the import name with the\ndifference that it\u2019s guessed from the run file if the import name is main.\nThis name is used as a display name when Flask needs the name of the\napplication. It can be set and overridden to change the value.\n\nNew in version 0.8.\n\nOpens a resource from the application\u2019s instance folder (`instance_path`).\nOtherwise works like `open_resource()`. Instance resources can also be opened\nfor writing.\n\nIO\n\nOpen a resource file relative to `root_path` for reading.\n\nFor example, if the file `schema.sql` is next to the file `app.py` where the\n`Flask` app is defined, it can be opened with:\n\nIO\n\nShortcut for `route()` with `methods=[\"PATCH\"]`.\n\nNew in version 2.0.\n\nCallable\n\nA `timedelta` which is used to set the expiration date of a permanent session.\nThe default is 31 days which makes a permanent session survive for roughly one\nmonth.\n\nThis attribute can also be configured from the config with the\n`PERMANENT_SESSION_LIFETIME` configuration key. Defaults to\n`timedelta(days=31)`\n\nShortcut for `route()` with `methods=[\"POST\"]`.\n\nNew in version 2.0.\n\nCallable\n\nCalled before the request is dispatched. Calls `url_value_preprocessors`\nregistered with the app and the current blueprint (if any). Then calls\n`before_request_funcs` registered with the app and the blueprint.\n\nIf any `before_request()` handler returns a non-None value, the value is\nhandled as if it was the return value from the view, and further request\nhandling is stopped.\n\nOptional[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None,\nNone], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None,\nNone]], Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]],\nList[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]],\nTuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]],\nint], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None,\nNone]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]],\nList[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], WSGIApplication]]\n\nReturns the value of the `PRESERVE_CONTEXT_ON_EXCEPTION` configuration value\nin case it\u2019s set, otherwise a sensible default is returned.\n\nNew in version 0.7.\n\nCan be overridden in order to modify the response object before it\u2019s sent to\nthe WSGI server. By default this will call all the `after_request()` decorated\nfunctions.\n\nChanged in version 0.5: As of Flask 0.5 the functions registered for after\nrequest execution are called in reverse order of registration.\n\nresponse (flask.wrappers.Response) \u2013 a `response_class` object.\n\na new response object or the same, has to be an instance of `response_class`.\n\nflask.wrappers.Response\n\nReturns the value of the `PROPAGATE_EXCEPTIONS` configuration value in case\nit\u2019s set, otherwise a sensible default is returned.\n\nNew in version 0.7.\n\nShortcut for `route()` with `methods=[\"PUT\"]`.\n\nNew in version 2.0.\n\nCallable\n\nRegister a `Blueprint` on the application. Keyword arguments passed to this\nmethod will override the defaults set on the blueprint.\n\nCalls the blueprint\u2019s `register()` method after recording the blueprint in the\napplication\u2019s `blueprints`.\n\nNone\n\nNew in version 0.7.\n\nAlternative error attach function to the `errorhandler()` decorator that is\nmore straightforward to use for non decorator usage.\n\nNew in version 0.7.\n\nNone\n\nalias of `flask.wrappers.Request`\n\nCreate a `RequestContext` representing a WSGI environment. Use a `with` block\nto push the context, which will make `request` point at this request.\n\nSee The Request Context.\n\nTypically you should not call this from your own code. A request context is\nautomatically pushed by the `wsgi_app()` when handling a request. Use\n`test_request_context()` to create an environment and context instead of this\nmethod.\n\nenviron (dict) \u2013 a WSGI environment\n\nflask.ctx.RequestContext\n\nalias of `flask.wrappers.Response`\n\nAbsolute path to the package on the filesystem. Used to look up resources\ncontained in the package.\n\nDecorate a view function to register it with the given URL rule and options.\nCalls `add_url_rule()`, which has more details about the implementation.\n\nSee URL Route Registrations.\n\nThe endpoint name for the route defaults to the name of the view function if\nthe `endpoint` parameter isn\u2019t passed.\n\nThe `methods` parameter defaults to `[\"GET\"]`. `HEAD` and `OPTIONS` are added\nautomatically.\n\nCallable\n\nRuns the application on a local development server.\n\nDo not use `run()` in a production setting. It is not intended to meet\nsecurity and performance requirements for a production server. Instead, see\nDeployment Options for WSGI server recommendations.\n\nIf the `debug` flag is set the server will automatically reload for code\nchanges and show a debugger in case an exception happened.\n\nIf you want to run the application in debug mode, but disable the code\nexecution on the interactive debugger, you can pass `use_evalex=False` as\nparameter. This will keep the debugger\u2019s traceback screen active, but disable\ncode execution.\n\nIt is not recommended to use this function for development with automatic\nreloading as this is badly supported. Instead you should be using the flask\ncommand line script\u2019s `run` support.\n\nKeep in Mind\n\nFlask will suppress any server error with a generic error page unless it is in\ndebug mode. As such to enable just the interactive debugger without the code\nreloading, you have to invoke `run()` with `debug=True` and\n`use_reloader=False`. Setting `use_debugger` to `True` without being in debug\nmode won\u2019t catch any exceptions because there won\u2019t be any to catch.\n\nNone\n\nChanged in version 1.0: If installed, python-dotenv will be used to load\nenvironment variables from `.env` and `.flaskenv` files.\n\nIf set, the `FLASK_ENV` and `FLASK_DEBUG` environment variables will override\n`env` and `debug`.\n\nThreaded mode is enabled by default.\n\nChanged in version 0.10: The default port is now picked from the `SERVER_NAME`\nvariable.\n\nIf a secret key is set, cryptographic components can use this to sign cookies\nand other things. Set this to a complex random value when you want to use the\nsecure cookie for instance.\n\nThis attribute can also be configured from the config with the `SECRET_KEY`\nconfiguration key. Defaults to `None`.\n\nReturns `True` if autoescaping should be active for the given template name.\nIf no template name is given, returns `True`.\n\nNew in version 0.5.\n\nfilename (str) \u2013\n\nbool\n\nA `timedelta` or number of seconds which is used as the default `max_age` for\n`send_file()`. The default is `None`, which tells the browser to use\nconditional requests instead of a timed cache.\n\nConfigured with the `SEND_FILE_MAX_AGE_DEFAULT` configuration key.\n\nChanged in version 2.0: Defaults to `None` instead of 12 hours.\n\nThe view function used to serve files from `static_folder`. A route is\nautomatically registered for this view at `static_url_path` if `static_folder`\nis set.\n\nNew in version 0.5.\n\nfilename (str) \u2013\n\nResponse\n\nThe secure cookie uses this for the name of the session cookie.\n\nThis attribute can also be configured from the config with the\n`SESSION_COOKIE_NAME` configuration key. Defaults to `'session'`\n\nthe session interface to use. By default an instance of\n`SecureCookieSessionInterface` is used here.\n\nNew in version 0.8.\n\nRegisters a shell context processor function.\n\nNew in version 0.11.\n\nf (Callable) \u2013\n\nCallable\n\nA list of shell context processor functions that should be run when a shell\ncontext is created.\n\nNew in version 0.11.\n\nThis is called to figure out if an error should be ignored or not as far as\nthe teardown system is concerned. If this function returns `True` then the\nteardown handlers will not be passed the error.\n\nNew in version 0.10.\n\nerror (Optional[BaseException]) \u2013\n\nbool\n\nThe absolute path to the configured static folder. `None` if no static folder\nis set.\n\nThe URL prefix that the static route will be accessible from.\n\nIf it was not configured during init, it is derived from `static_folder`.\n\nRegisters a function to be called when the application context ends. These\nfunctions are typically also called when the request context is popped.\n\nExample:\n\nWhen `ctx.pop()` is executed in the above example, the teardown functions are\ncalled just before the app context moves from the stack of active contexts.\nThis becomes relevant if you are using such constructs in tests.\n\nSince a request context typically also manages an application context it would\nalso be called when you pop a request context.\n\nWhen a teardown function was called because of an unhandled exception it will\nbe passed an error object. If an `errorhandler()` is registered, it will\nhandle the exception and the teardown will not receive it.\n\nThe return values of teardown functions are ignored.\n\nNew in version 0.9.\n\nf (Callable[[Optional[BaseException]], flask.wrappers.Response]) \u2013\n\nCallable[[Optional[BaseException]], flask.wrappers.Response]\n\nA list of functions that are called when the application context is destroyed.\nSince the application context is also torn down if the request ends this is\nthe place to store code that disconnects from databases.\n\nNew in version 0.9.\n\nRegister a function to be run at the end of each request, regardless of\nwhether there was an exception or not. These functions are executed when the\nrequest context is popped, even if not an actual request was performed.\n\nExample:\n\nWhen `ctx.pop()` is executed in the above example, the teardown functions are\ncalled just before the request context moves from the stack of active\ncontexts. This becomes relevant if you are using such constructs in tests.\n\nTeardown functions must avoid raising exceptions, since they . If they execute\ncode that might fail they will have to surround the execution of these code by\ntry/except statements and log occurring errors.\n\nWhen a teardown function was called because of an exception it will be passed\nan error object.\n\nThe return values of teardown functions are ignored.\n\nDebug Note\n\nIn debug mode Flask will not tear down a request on an exception immediately.\nInstead it will keep it alive so that the interactive debugger can still\naccess it. This behavior can be controlled by the\n`PRESERVE_CONTEXT_ON_EXCEPTION` configuration variable.\n\nf (Callable[[Optional[BaseException]], Response]) \u2013\n\nCallable[[Optional[BaseException]], Response]\n\nA data structure of functions to call at the end of each request even if an\nexception is raised, in the format `{scope: [functions]}`. The `scope` key is\nthe name of a blueprint the functions are active for, or `None` for all\nrequests.\n\nTo register a function, use the `teardown_request()` decorator.\n\nThis data structure is internal. It should not be modified directly and its\nformat may change at any time.\n\nA data structure of functions to call to pass extra context values when\nrendering templates, in the format `{scope: [functions]}`. The `scope` key is\nthe name of a blueprint the functions are active for, or `None` for all\nrequests.\n\nTo register a function, use the `context_processor()` decorator.\n\nThis data structure is internal. It should not be modified directly and its\nformat may change at any time.\n\nA decorator that is used to register custom template filter. You can specify a\nname for the filter, otherwise the function name will be used. Example:\n\nname (Optional[str]) \u2013 the optional name of the filter, otherwise the function\nname will be used.\n\nCallable\n\nThe path to the templates folder, relative to `root_path`, to add to the\ntemplate loader. `None` if templates should not be added.\n\nA decorator that is used to register a custom template global function. You\ncan specify a name for the global function, otherwise the function name will\nbe used. Example:\n\nNew in version 0.10.\n\nname (Optional[str]) \u2013 the optional name of the global function, otherwise the\nfunction name will be used.\n\nCallable\n\nA decorator that is used to register custom template test. You can specify a\nname for the test, otherwise the function name will be used. Example:\n\nNew in version 0.10.\n\nname (Optional[str]) \u2013 the optional name of the test, otherwise the function\nname will be used.\n\nCallable\n\nReload templates when they are changed. Used by `create_jinja_environment()`.\n\nThis attribute can be configured with `TEMPLATES_AUTO_RELOAD`. If not set, it\nwill be enabled in debug mode.\n\nNew in version 1.0: This property was added but the underlying config and\nbehavior already existed.\n\nCreate a CLI runner for testing CLI commands. See Testing CLI Commands.\n\nReturns an instance of `test_cli_runner_class`, by default `FlaskCliRunner`.\nThe Flask app object is passed as the first argument.\n\nNew in version 1.0.\n\nkwargs (Any) \u2013\n\nFlaskCliRunner\n\nThe `CliRunner` subclass, by default `FlaskCliRunner` that is used by\n`test_cli_runner()`. Its `__init__` method should take a Flask app object as\nthe first argument.\n\nNew in version 1.0.\n\nCreates a test client for this application. For information about unit testing\nhead over to Testing Flask Applications.\n\nNote that if you are testing for assertions or exceptions in your application\ncode, you must set `app.testing = True` in order for the exceptions to\npropagate to the test client. Otherwise, the exception will be handled by the\napplication (not visible to the test client) and the only indication of an\nAssertionError or other exception will be a 500 status code response to the\ntest client. See the `testing` attribute. For example:\n\nThe test client can be used in a `with` block to defer the closing down of the\ncontext until the end of the `with` block. This is useful if you want to\naccess the context locals for testing:\n\nAdditionally, you may pass optional keyword arguments that will then be passed\nto the application\u2019s `test_client_class` constructor. For example:\n\nSee `FlaskClient` for more information.\n\nChanged in version 0.11: Added `**kwargs` to support passing additional\nkeyword arguments to the constructor of `test_client_class`.\n\nNew in version 0.7: The `use_cookies` parameter was added as well as the\nability to override the client to be used by setting the `test_client_class`\nattribute.\n\nChanged in version 0.4: added support for `with` block usage for the client.\n\nFlaskClient\n\nthe test client that is used with when `test_client` is used.\n\nNew in version 0.7.\n\nCreate a `RequestContext` for a WSGI environment created from the given\nvalues. This is mostly useful during testing, where you may want to run a\nfunction that uses request data without dispatching a full request.\n\nSee The Request Context.\n\nUse a `with` block to push the context, which will make `request` point at the\nrequest for the created environment.\n\nWhen using the shell, it may be easier to push and pop the context manually to\navoid indentation.\n\nTakes the same arguments as Werkzeug\u2019s `EnvironBuilder`, with some defaults\nfrom the application. See the linked Werkzeug docs for most of the available\narguments. Flask-specific behavior is listed here.\n\nflask.ctx.RequestContext\n\nThe testing flag. Set this to `True` to enable the test mode of Flask\nextensions (and in the future probably also Flask itself). For example this\nmight activate test helpers that have an additional runtime cost which should\nnot be enabled by default.\n\nIf this is enabled and PROPAGATE_EXCEPTIONS is not changed from the default\nit\u2019s implicitly enabled.\n\nThis attribute can also be configured from the config with the `TESTING`\nconfiguration key. Defaults to `False`.\n\nChecks if an HTTP exception should be trapped or not. By default this will\nreturn `False` for all exceptions except for a bad request key error if\n`TRAP_BAD_REQUEST_ERRORS` is set to `True`. It also returns `True` if\n`TRAP_HTTP_EXCEPTIONS` is set to `True`.\n\nThis is called for all HTTP exceptions raised by a view function. If it\nreturns `True` for any exception the error handler for this exception is not\ncalled and it shows up as regular exception in the traceback. This is helpful\nfor debugging implicitly raised HTTP exceptions.\n\nChanged in version 1.0: Bad request errors are not trapped by default in debug\nmode.\n\nNew in version 0.8.\n\ne (Exception) \u2013\n\nbool\n\nUpdate the template context with some commonly used variables. This injects\nrequest, session, config and g into the template context as well as everything\ntemplate context processors want to inject. Note that the as of Flask 0.6, the\noriginal values in the context will not be overridden if a context processor\ndecides to return a value with the same key.\n\ncontext (dict) \u2013 the context as a dictionary that is updated in place to add\nextra variables.\n\nNone\n\nA list of functions that are called when `url_for()` raises a `BuildError`.\nEach function registered here is called with `error`, `endpoint` and `values`.\nIf a function returns `None` or raises a `BuildError` the next function is\ntried.\n\nNew in version 0.9.\n\nA data structure of functions to call to modify the keyword arguments when\ngenerating URLs, in the format `{scope: [functions]}`. The `scope` key is the\nname of a blueprint the functions are active for, or `None` for all requests.\n\nTo register a function, use the `url_defaults()` decorator.\n\nThis data structure is internal. It should not be modified directly and its\nformat may change at any time.\n\nCallback function for URL defaults for all view functions of the application.\nIt\u2019s called with the endpoint and values and should update the values passed\nin place.\n\nf (Callable[[str, dict], None]) \u2013\n\nCallable[[str, dict], None]\n\nThe `Map` for this instance. You can use this to change the routing converters\nafter the class was created but before any routes are connected. Example:\n\nalias of `werkzeug.routing.Map`\n\nalias of `werkzeug.routing.Rule`\n\nRegister a URL value preprocessor function for all view functions in the\napplication. These functions will be called before the `before_request()`\nfunctions.\n\nThe function can modify the values captured from the matched url before they\nare passed to the view. For example, this can be used to pop a common language\ncode value and place it in `g` rather than pass it to every view.\n\nThe function is passed the endpoint name and values dict. The return value is\nignored.\n\nf (Callable[[Optional[str], Optional[dict]], None]) \u2013\n\nCallable[[Optional[str], Optional[dict]], None]\n\nA data structure of functions to call to modify the keyword arguments passed\nto the view function, in the format `{scope: [functions]}`. The `scope` key is\nthe name of a blueprint the functions are active for, or `None` for all\nrequests.\n\nTo register a function, use the `url_value_preprocessor()` decorator.\n\nThis data structure is internal. It should not be modified directly and its\nformat may change at any time.\n\nEnable this if you want to use the X-Sendfile feature. Keep in mind that the\nserver has to support this. This only affects files sent with the\n`send_file()` method.\n\nNew in version 0.2.\n\nThis attribute can also be configured from the config with the\n`USE_X_SENDFILE` configuration key. Defaults to `False`.\n\nA dictionary mapping endpoint names to view functions.\n\nTo register a view function, use the `route()` decorator.\n\nThis data structure is internal. It should not be modified directly and its\nformat may change at any time.\n\nThe actual WSGI application. This is not implemented in `__call__()` so that\nmiddlewares can be applied without losing a reference to the app object.\nInstead of doing this:\n\nIt\u2019s a better idea to do this instead:\n\nThen you still have the original application object around and can continue to\ncall methods on it.\n\nChanged in version 0.7: Teardown events for the request and app contexts are\ncalled even if an unhandled error occurs. Other events may not be called\ndepending on when an error occurs during dispatch. See Callbacks and Errors.\n\nAny\n\n"}, {"name": "Flask.add_template_filter()", "path": "api/index#flask.Flask.add_template_filter", "type": "flask", "text": "\nRegister a custom template filter. Works exactly like the `template_filter()`\ndecorator.\n\nNone\n\n"}, {"name": "Flask.add_template_global()", "path": "api/index#flask.Flask.add_template_global", "type": "flask", "text": "\nRegister a custom template global function. Works exactly like the\n`template_global()` decorator.\n\nNew in version 0.10.\n\nNone\n\n"}, {"name": "Flask.add_template_test()", "path": "api/index#flask.Flask.add_template_test", "type": "flask", "text": "\nRegister a custom template test. Works exactly like the `template_test()`\ndecorator.\n\nNew in version 0.10.\n\nNone\n\n"}, {"name": "Flask.add_url_rule()", "path": "api/index#flask.Flask.add_url_rule", "type": "flask", "text": "\nRegister a rule for routing incoming requests and building URLs. The `route()`\ndecorator is a shortcut to call this with the `view_func` argument. These are\nequivalent:\n\nSee URL Route Registrations.\n\nThe endpoint name for the route defaults to the name of the view function if\nthe `endpoint` parameter isn\u2019t passed. An error will be raised if a function\nhas already been registered for the endpoint.\n\nThe `methods` parameter defaults to `[\"GET\"]`. `HEAD` is always added\nautomatically, and `OPTIONS` is added automatically by default.\n\n`view_func` does not necessarily need to be passed, but if the rule should\nparticipate in routing an endpoint name must be associated with a view\nfunction at some point with the `endpoint()` decorator.\n\nIf `view_func` has a `required_methods` attribute, those methods are added to\nthe passed and automatic methods. If it has a `provide_automatic_methods`\nattribute, it is used as the default if the parameter is not passed.\n\nNone\n\n"}, {"name": "Flask.after_request()", "path": "api/index#flask.Flask.after_request", "type": "flask", "text": "\nRegister a function to run after each request to this object.\n\nThe function is called with the response object, and must return a response\nobject. This allows the functions to modify or replace the response before it\nis sent.\n\nIf a function raises an exception, any remaining `after_request` functions\nwill not be called. Therefore, this should not be used for actions that must\nexecute, such as to close resources. Use `teardown_request()` for that.\n\nf (Callable[[Response], Response]) \u2013\n\nCallable[[Response], Response]\n\n"}, {"name": "Flask.after_request_funcs", "path": "api/index#flask.Flask.after_request_funcs", "type": "flask", "text": "\nA data structure of functions to call at the end of each request, in the\nformat `{scope: [functions]}`. The `scope` key is the name of a blueprint the\nfunctions are active for, or `None` for all requests.\n\nTo register a function, use the `after_request()` decorator.\n\nThis data structure is internal. It should not be modified directly and its\nformat may change at any time.\n\n"}, {"name": "flask.appcontext_popped", "path": "api/index#flask.appcontext_popped", "type": "flask", "text": "\nThis signal is sent when an application context is popped. The sender is the\napplication. This usually falls in line with the `appcontext_tearing_down`\nsignal.\n\nNew in version 0.10.\n\n"}, {"name": "flask.appcontext_pushed", "path": "api/index#flask.appcontext_pushed", "type": "flask", "text": "\nThis signal is sent when an application context is pushed. The sender is the\napplication. This is usually useful for unittests in order to temporarily hook\nin information. For instance it can be used to set a resource early onto the\n`g` object.\n\nExample usage:\n\nAnd in the testcode:\n\nNew in version 0.10.\n\n"}, {"name": "flask.appcontext_tearing_down", "path": "api/index#flask.appcontext_tearing_down", "type": "flask", "text": "\nThis signal is sent when the app context is tearing down. This is always\ncalled, even if an exception is caused. Currently functions listening to this\nsignal are called after the regular teardown handlers, but this is not\nsomething you can rely on.\n\nExample subscriber:\n\nThis will also be passed an `exc` keyword argument that has a reference to the\nexception that caused the teardown if there was one.\n\n"}, {"name": "Flask.app_context()", "path": "api/index#flask.Flask.app_context", "type": "flask", "text": "\nCreate an `AppContext`. Use as a `with` block to push the context, which will\nmake `current_app` point at this application.\n\nAn application context is automatically pushed by `RequestContext.push()` when\nhandling a request, and when running a CLI command. Use this to manually\ncreate a context outside of these situations.\n\nSee The Application Context.\n\nNew in version 0.9.\n\nflask.ctx.AppContext\n\n"}, {"name": "Flask.app_ctx_globals_class", "path": "api/index#flask.Flask.app_ctx_globals_class", "type": "flask", "text": "\nalias of `flask.ctx._AppCtxGlobals`\n\n"}, {"name": "Flask.async_to_sync()", "path": "api/index#flask.Flask.async_to_sync", "type": "flask", "text": "\nReturn a sync function that will run the coroutine function.\n\nOverride this method to change how the app converts async code to be\nsynchronously callable.\n\nNew in version 2.0.\n\nfunc (Callable[[...], Coroutine]) \u2013\n\nCallable[[\u2026], Any]\n\n"}, {"name": "Flask.auto_find_instance_path()", "path": "api/index#flask.Flask.auto_find_instance_path", "type": "flask", "text": "\nTries to locate the instance path if it was not provided to the constructor of\nthe application class. It will basically calculate the path to a folder named\n`instance` next to your main file or the package.\n\nNew in version 0.8.\n\nstr\n\n"}, {"name": "Flask.before_first_request()", "path": "api/index#flask.Flask.before_first_request", "type": "flask", "text": "\nRegisters a function to be run before the first request to this instance of\nthe application.\n\nThe function will be called without any arguments and its return value is\nignored.\n\nNew in version 0.8.\n\nf (Callable[[], None]) \u2013\n\nCallable[[], None]\n\n"}, {"name": "Flask.before_first_request_funcs", "path": "api/index#flask.Flask.before_first_request_funcs", "type": "flask", "text": "\nA list of functions that will be called at the beginning of the first request\nto this instance. To register a function, use the `before_first_request()`\ndecorator.\n\nNew in version 0.8.\n\n"}, {"name": "Flask.before_request()", "path": "api/index#flask.Flask.before_request", "type": "flask", "text": "\nRegister a function to run before each request.\n\nFor example, this can be used to open a database connection, or to load the\nlogged in user from the session.\n\nThe function will be called without any arguments. If it returns a non-`None`\nvalue, the value is handled as if it was the return value from the view, and\nfurther request handling is stopped.\n\nf (Callable[[], None]) \u2013\n\nCallable[[], None]\n\n"}, {"name": "Flask.before_request_funcs", "path": "api/index#flask.Flask.before_request_funcs", "type": "flask", "text": "\nA data structure of functions to call at the beginning of each request, in the\nformat `{scope: [functions]}`. The `scope` key is the name of a blueprint the\nfunctions are active for, or `None` for all requests.\n\nTo register a function, use the `before_request()` decorator.\n\nThis data structure is internal. It should not be modified directly and its\nformat may change at any time.\n\n"}, {"name": "Flask.blueprints", "path": "api/index#flask.Flask.blueprints", "type": "flask", "text": "\nMaps registered blueprint names to blueprint objects. The dict retains the\norder the blueprints were registered in. Blueprints can be registered multiple\ntimes, this dict does not track how often they were attached.\n\nNew in version 0.7.\n\n"}, {"name": "Flask.cli", "path": "api/index#flask.Flask.cli", "type": "flask", "text": "\nThe Click command group for registering CLI commands for this object. The\ncommands are available from the `flask` command once the application has been\ndiscovered and blueprints have been registered.\n\n"}, {"name": "flask.cli.run_command", "path": "api/index#flask.cli.run_command", "type": "flask", "text": "\nRun a local development server.\n\nThis server is for development purposes only. It does not provide the\nstability, security, or performance of production WSGI servers.\n\nThe reloader and debugger are enabled by default if FLASK_ENV=development or\nFLASK_DEBUG=1.\n\nAny\n\n"}, {"name": "flask.cli.shell_command", "path": "api/index#flask.cli.shell_command", "type": "flask", "text": "\nRun an interactive Python shell in the context of a given Flask application.\nThe application will populate the default namespace of this shell according to\nits configuration.\n\nThis is useful for executing small snippets of management code without having\nto manually configure the application.\n\nAny\n\n"}, {"name": "Flask.config", "path": "api/index#flask.Flask.config", "type": "flask", "text": "\nThe configuration dictionary as `Config`. This behaves exactly like a regular\ndictionary but supports additional methods to load a config from files.\n\n"}, {"name": "Flask.config_class", "path": "api/index#flask.Flask.config_class", "type": "flask", "text": "\nalias of `flask.config.Config`\n\n"}, {"name": "Flask.context_processor()", "path": "api/index#flask.Flask.context_processor", "type": "flask", "text": "\nRegisters a template context processor function.\n\nf (Callable[[], Dict[str, Any]]) \u2013\n\nCallable[[], Dict[str, Any]]\n\n"}, {"name": "Flask.create_global_jinja_loader()", "path": "api/index#flask.Flask.create_global_jinja_loader", "type": "flask", "text": "\nCreates the loader for the Jinja2 environment. Can be used to override just\nthe loader and keeping the rest unchanged. It\u2019s discouraged to override this\nfunction. Instead one should override the `jinja_loader()` function instead.\n\nThe global loader dispatches between the loaders of the application and the\nindividual blueprints.\n\nNew in version 0.7.\n\nflask.templating.DispatchingJinjaLoader\n\n"}, {"name": "Flask.create_jinja_environment()", "path": "api/index#flask.Flask.create_jinja_environment", "type": "flask", "text": "\nCreate the Jinja environment based on `jinja_options` and the various Jinja-\nrelated methods of the app. Changing `jinja_options` after this will have no\neffect. Also adds Flask-related globals and filters to the environment.\n\nChanged in version 0.11: `Environment.auto_reload` set in accordance with\n`TEMPLATES_AUTO_RELOAD` configuration option.\n\nNew in version 0.5.\n\nflask.templating.Environment\n\n"}, {"name": "Flask.create_url_adapter()", "path": "api/index#flask.Flask.create_url_adapter", "type": "flask", "text": "\nCreates a URL adapter for the given request. The URL adapter is created at a\npoint where the request context is not yet set up so the request is passed\nexplicitly.\n\nChanged in version 1.0: `SERVER_NAME` no longer implicitly enables subdomain\nmatching. Use `subdomain_matching` instead.\n\nChanged in version 0.9: This can now also be called without a request object\nwhen the URL adapter is created for the application context.\n\nNew in version 0.6.\n\nrequest (Optional[flask.wrappers.Request]) \u2013\n\nOptional[werkzeug.routing.MapAdapter]\n\n"}, {"name": "flask.current_app", "path": "api/index#flask.current_app", "type": "flask", "text": "\nA proxy to the application handling the current request. This is useful to\naccess the application without needing to import it, or if it can\u2019t be\nimported, such as when using the application factory pattern or in blueprints\nand extensions.\n\nThis is only available when an application context is pushed. This happens\nautomatically during requests and CLI commands. It can be controlled manually\nwith `app_context()`.\n\nThis is a proxy. See Notes On Proxies for more information.\n\n"}, {"name": "Flask.default_config", "path": "api/index#flask.Flask.default_config", "type": "flask", "text": "\nDefault configuration parameters.\n\n"}, {"name": "Flask.delete()", "path": "api/index#flask.Flask.delete", "type": "flask", "text": "\nShortcut for `route()` with `methods=[\"DELETE\"]`.\n\nNew in version 2.0.\n\nCallable\n\n"}, {"name": "Flask.dispatch_request()", "path": "api/index#flask.Flask.dispatch_request", "type": "flask", "text": "\nDoes the request dispatching. Matches the URL and returns the return value of\nthe view or error handler. This does not have to be a response object. In\norder to convert the return value to a proper response object, call\n`make_response()`.\n\nChanged in version 0.7: This no longer does the exception handling, this code\nwas moved to the new `full_dispatch_request()`.\n\nUnion[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None],\nTuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]],\nUnion[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]],\nList[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]],\nTuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]],\nint], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None,\nNone]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]],\nList[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], WSGIApplication]\n\n"}, {"name": "Flask.do_teardown_appcontext()", "path": "api/index#flask.Flask.do_teardown_appcontext", "type": "flask", "text": "\nCalled right before the application context is popped.\n\nWhen handling a request, the application context is popped after the request\ncontext. See `do_teardown_request()`.\n\nThis calls all functions decorated with `teardown_appcontext()`. Then the\n`appcontext_tearing_down` signal is sent.\n\nThis is called by `AppContext.pop()`.\n\nNew in version 0.9.\n\nexc (Optional[BaseException]) \u2013\n\nNone\n\n"}, {"name": "Flask.do_teardown_request()", "path": "api/index#flask.Flask.do_teardown_request", "type": "flask", "text": "\nCalled after the request is dispatched and the response is returned, right\nbefore the request context is popped.\n\nThis calls all functions decorated with `teardown_request()`, and\n`Blueprint.teardown_request()` if a blueprint handled the request. Finally,\nthe `request_tearing_down` signal is sent.\n\nThis is called by `RequestContext.pop()`, which may be delayed during testing\nto maintain access to resources.\n\nexc (Optional[BaseException]) \u2013 An unhandled exception raised while\ndispatching the request. Detected from the current exception information if\nnot passed. Passed to each teardown function.\n\nNone\n\nChanged in version 0.9: Added the `exc` argument.\n\n"}, {"name": "Flask.endpoint()", "path": "api/index#flask.Flask.endpoint", "type": "flask", "text": "\nDecorate a view function to register it for the given endpoint. Used if a rule\nis added without a `view_func` with `add_url_rule()`.\n\nendpoint (str) \u2013 The endpoint name to associate with the view function.\n\nCallable\n\n"}, {"name": "Flask.ensure_sync()", "path": "api/index#flask.Flask.ensure_sync", "type": "flask", "text": "\nEnsure that the function is synchronous for WSGI workers. Plain `def`\nfunctions are returned as-is. `async def` functions are wrapped to run and\nwait for the response.\n\nOverride this method to change how the app runs async views.\n\nNew in version 2.0.\n\nfunc (Callable) \u2013\n\nCallable\n\n"}, {"name": "Flask.env", "path": "api/index#flask.Flask.env", "type": "flask", "text": "\nWhat environment the app is running in. Flask and extensions may enable\nbehaviors based on the environment, such as enabling debug mode. This maps to\nthe `ENV` config key. This is set by the `FLASK_ENV` environment variable and\nmay not behave as expected if set in code.\n\nDo not enable development when deploying in production.\n\nDefault: `'production'`\n\n"}, {"name": "Flask.errorhandler()", "path": "api/index#flask.Flask.errorhandler", "type": "flask", "text": "\nRegister a function to handle errors by code or exception class.\n\nA decorator that is used to register a function given an error code. Example:\n\nYou can also register handlers for arbitrary exceptions:\n\nNew in version 0.7: Use `register_error_handler()` instead of modifying\n`error_handler_spec` directly, for application wide error handlers.\n\nNew in version 0.7: One can now additionally also register custom exception\ntypes that do not necessarily have to be a subclass of the `HTTPException`\nclass.\n\ncode_or_exception (Union[Type[Exception], int]) \u2013 the code as integer for the\nhandler, or an arbitrary exception\n\nCallable\n\n"}, {"name": "Flask.error_handler_spec", "path": "api/index#flask.Flask.error_handler_spec", "type": "flask", "text": "\nA data structure of registered error handlers, in the format `{scope: {code:\n{class: handler}}}``. The `scope` key is the name of a blueprint the handlers\nare active for, or `None` for all requests. The `code` key is the HTTP status\ncode for `HTTPException`, or `None` for other exceptions. The innermost\ndictionary maps exception classes to handler functions.\n\nTo register an error handler, use the `errorhandler()` decorator.\n\nThis data structure is internal. It should not be modified directly and its\nformat may change at any time.\n\n"}, {"name": "Flask.extensions", "path": "api/index#flask.Flask.extensions", "type": "flask", "text": "\na place where extensions can store application specific state. For example\nthis is where an extension could store database engines and similar things.\n\nThe key must match the name of the extension module. For example in case of a\n\u201cFlask-Foo\u201d extension in `flask_foo`, the key would be `'foo'`.\n\nNew in version 0.7.\n\n"}, {"name": "Flask.full_dispatch_request()", "path": "api/index#flask.Flask.full_dispatch_request", "type": "flask", "text": "\nDispatches the request and on top of that performs request pre and\npostprocessing as well as HTTP exception catching and error handling.\n\nNew in version 0.7.\n\nflask.wrappers.Response\n\n"}, {"name": "flask.g", "path": "api/index#flask.g", "type": "flask", "text": "\nA namespace object that can store data during an application context. This is\nan instance of `Flask.app_ctx_globals_class`, which defaults to\n`ctx._AppCtxGlobals`.\n\nThis is a good place to store resources during a request. During testing, you\ncan use the Faking Resources and Context pattern to pre-configure such\nresources.\n\nThis is a proxy. See Notes On Proxies for more information.\n\nChanged in version 0.10: Bound to the application context instead of the\nrequest context.\n\n"}, {"name": "Flask.get()", "path": "api/index#flask.Flask.get", "type": "flask", "text": "\nShortcut for `route()` with `methods=[\"GET\"]`.\n\nNew in version 2.0.\n\nCallable\n\n"}, {"name": "Flask.get_send_file_max_age()", "path": "api/index#flask.Flask.get_send_file_max_age", "type": "flask", "text": "\nUsed by `send_file()` to determine the `max_age` cache value for a given file\npath if it wasn\u2019t passed.\n\nBy default, this returns `SEND_FILE_MAX_AGE_DEFAULT` from the configuration of\n`current_app`. This defaults to `None`, which tells the browser to use\nconditional requests instead of a timed cache, which is usually preferable.\n\nChanged in version 2.0: The default configuration is `None` instead of 12\nhours.\n\nNew in version 0.9.\n\nfilename (str) \u2013\n\nOptional[int]\n\n"}, {"name": "flask.got_request_exception", "path": "api/index#flask.got_request_exception", "type": "flask", "text": "\nThis signal is sent when an unhandled exception happens during request\nprocessing, including when debugging. The exception is passed to the\nsubscriber as `exception`.\n\nThis signal is not sent for `HTTPException`, or other exceptions that have\nerror handlers registered, unless the exception was raised from an error\nhandler.\n\nThis example shows how to do some extra logging if a theoretical\n`SecurityException` was raised:\n\n"}, {"name": "Flask.handle_exception()", "path": "api/index#flask.Flask.handle_exception", "type": "flask", "text": "\nHandle an exception that did not have an error handler associated with it, or\nthat was raised from an error handler. This always causes a 500\n`InternalServerError`.\n\nAlways sends the `got_request_exception` signal.\n\nIf `propagate_exceptions` is `True`, such as in debug mode, the error will be\nre-raised so that the debugger can display it. Otherwise, the original\nexception is logged, and an `InternalServerError` is returned.\n\nIf an error handler is registered for `InternalServerError` or `500`, it will\nbe used. For consistency, the handler will always receive the\n`InternalServerError`. The original unhandled exception is available as\n`e.original_exception`.\n\nChanged in version 1.1.0: Always passes the `InternalServerError` instance to\nthe handler, setting `original_exception` to the unhandled error.\n\nChanged in version 1.1.0: `after_request` functions and other finalization is\ndone even for the default 500 response when there is no handler.\n\nNew in version 0.3.\n\ne (Exception) \u2013\n\nflask.wrappers.Response\n\n"}, {"name": "Flask.handle_http_exception()", "path": "api/index#flask.Flask.handle_http_exception", "type": "flask", "text": "\nHandles an HTTP exception. By default this will invoke the registered error\nhandlers and fall back to returning the exception as response.\n\nChanged in version 1.0.3: `RoutingException`, used internally for actions such\nas slash redirects during routing, is not passed to error handlers.\n\nChanged in version 1.0: Exceptions are looked up by code and by MRO, so\n`HTTPExcpetion` subclasses can be handled with a catch-all handler for the\nbase `HTTPException`.\n\nNew in version 0.3.\n\ne (werkzeug.exceptions.HTTPException) \u2013\n\nUnion[werkzeug.exceptions.HTTPException, Response, AnyStr, Dict[str, Any],\nGenerator[AnyStr, None, None], Tuple[Union[Response, AnyStr, Dict[str, Any],\nGenerator[AnyStr, None, None]], Union[Headers, Dict[str, Union[str, List[str],\nTuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]],\nTuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]],\nint], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None,\nNone]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]],\nList[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], WSGIApplication]\n\n"}, {"name": "Flask.handle_url_build_error()", "path": "api/index#flask.Flask.handle_url_build_error", "type": "flask", "text": "\nHandle `BuildError` on `url_for()`.\n\nstr\n\n"}, {"name": "Flask.handle_user_exception()", "path": "api/index#flask.Flask.handle_user_exception", "type": "flask", "text": "\nThis method is called whenever an exception occurs that should be handled. A\nspecial case is `HTTPException` which is forwarded to the\n`handle_http_exception()` method. This function will either return a response\nvalue or reraise the exception with the same traceback.\n\nChanged in version 1.0: Key errors raised from request data like `form` show\nthe bad key in debug mode rather than a generic bad request message.\n\nNew in version 0.7.\n\ne (Exception) \u2013\n\nUnion[werkzeug.exceptions.HTTPException, Response, AnyStr, Dict[str, Any],\nGenerator[AnyStr, None, None], Tuple[Union[Response, AnyStr, Dict[str, Any],\nGenerator[AnyStr, None, None]], Union[Headers, Dict[str, Union[str, List[str],\nTuple[str, \u2026]]], List[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]],\nTuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]],\nint], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None,\nNone]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]],\nList[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], WSGIApplication]\n\n"}, {"name": "Flask.import_name", "path": "api/index#flask.Flask.import_name", "type": "flask", "text": "\nThe name of the package or module that this object belongs to. Do not change\nthis once it is set by the constructor.\n\n"}, {"name": "Flask.inject_url_defaults()", "path": "api/index#flask.Flask.inject_url_defaults", "type": "flask", "text": "\nInjects the URL defaults for the given endpoint directly into the values\ndictionary passed. This is used internally and automatically called on URL\nbuilding.\n\nNew in version 0.7.\n\nNone\n\n"}, {"name": "Flask.instance_path", "path": "api/index#flask.Flask.instance_path", "type": "flask", "text": "\nHolds the path to the instance folder.\n\nNew in version 0.8.\n\n"}, {"name": "Flask.iter_blueprints()", "path": "api/index#flask.Flask.iter_blueprints", "type": "flask", "text": "\nIterates over all blueprints by the order they were registered.\n\nNew in version 0.11.\n\nValuesView[Blueprint]\n\n"}, {"name": "Flask.jinja_environment", "path": "api/index#flask.Flask.jinja_environment", "type": "flask", "text": "\nalias of `flask.templating.Environment`\n\n"}, {"name": "Flask.jinja_options", "path": "api/index#flask.Flask.jinja_options", "type": "flask", "text": "\nOptions that are passed to the Jinja environment in\n`create_jinja_environment()`. Changing these options after the environment is\ncreated (accessing `jinja_env`) will have no effect.\n\nChanged in version 1.1.0: This is a `dict` instead of an `ImmutableDict` to\nallow easier configuration.\n\n"}, {"name": "Flask.json_decoder", "path": "api/index#flask.Flask.json_decoder", "type": "flask", "text": "\nalias of `flask.json.JSONDecoder`\n\n"}, {"name": "Flask.json_encoder", "path": "api/index#flask.Flask.json_encoder", "type": "flask", "text": "\nalias of `flask.json.JSONEncoder`\n\n"}, {"name": "Flask.log_exception()", "path": "api/index#flask.Flask.log_exception", "type": "flask", "text": "\nLogs an exception. This is called by `handle_exception()` if debugging is\ndisabled and right before the handler is called. The default implementation\nlogs the exception as error on the `logger`.\n\nNew in version 0.8.\n\nexc_info (Union[Tuple[type, BaseException, types.TracebackType], Tuple[None,\nNone, None]]) \u2013\n\nNone\n\n"}, {"name": "Flask.make_config()", "path": "api/index#flask.Flask.make_config", "type": "flask", "text": "\nUsed to create the config attribute by the Flask constructor. The\n`instance_relative` parameter is passed in from the constructor of Flask\n(there named `instance_relative_config`) and indicates if the config should be\nrelative to the instance path or the root path of the application.\n\nNew in version 0.8.\n\ninstance_relative (bool) \u2013\n\nflask.config.Config\n\n"}, {"name": "Flask.make_default_options_response()", "path": "api/index#flask.Flask.make_default_options_response", "type": "flask", "text": "\nThis method is called to create the default `OPTIONS` response. This can be\nchanged through subclassing to change the default behavior of `OPTIONS`\nresponses.\n\nNew in version 0.7.\n\nflask.wrappers.Response\n\n"}, {"name": "Flask.make_response()", "path": "api/index#flask.Flask.make_response", "type": "flask", "text": "\nConvert the return value from a view function to an instance of\n`response_class`.\n\nrv (Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None],\nTuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]],\nUnion[Headers, Dict[str, Union[str, List[str], Tuple[str, ...]]],\nList[Tuple[str, Union[str, List[str], Tuple[str, ...]]]]]],\nTuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]],\nint], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None,\nNone]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, ...]]],\nList[Tuple[str, Union[str, List[str], Tuple[str, ...]]]]]], WSGIApplication])\n\u2013\n\nthe return value from the view function. The view function must return a\nresponse. Returning `None`, or the view ending without returning, is not\nallowed. The following types are allowed for `view_rv`:\n\nA response object is created with the string encoded to UTF-8 as the body.\n\nA response object is created with the bytes as the body.\n\nA dictionary that will be jsonify\u2019d before being returned.\n\nEither `(body, status, headers)`, `(body, status)`, or `(body, headers)`,\nwhere `body` is any of the other types allowed here, `status` is a string or\nan integer, and `headers` is a dictionary or a list of `(key, value)` tuples.\nIf `body` is a `response_class` instance, `status` overwrites the exiting\nvalue and `headers` are extended.\n\nThe object is returned unchanged.\n\nThe object is coerced to `response_class`.\n\nThe function is called as a WSGI application. The result is used to create a\nresponse object.\n\nflask.wrappers.Response\n\nChanged in version 0.9: Previously a tuple was interpreted as the arguments\nfor the response object.\n\n"}, {"name": "Flask.make_shell_context()", "path": "api/index#flask.Flask.make_shell_context", "type": "flask", "text": "\nReturns the shell context for an interactive shell for this application. This\nruns all the registered shell context processors.\n\nNew in version 0.11.\n\ndict\n\n"}, {"name": "flask.message_flashed", "path": "api/index#flask.message_flashed", "type": "flask", "text": "\nThis signal is sent when the application is flashing a message. The messages\nis sent as `message` keyword argument and the category as `category`.\n\nExample subscriber:\n\nNew in version 0.10.\n\n"}, {"name": "Flask.open_instance_resource()", "path": "api/index#flask.Flask.open_instance_resource", "type": "flask", "text": "\nOpens a resource from the application\u2019s instance folder (`instance_path`).\nOtherwise works like `open_resource()`. Instance resources can also be opened\nfor writing.\n\nIO\n\n"}, {"name": "Flask.open_resource()", "path": "api/index#flask.Flask.open_resource", "type": "flask", "text": "\nOpen a resource file relative to `root_path` for reading.\n\nFor example, if the file `schema.sql` is next to the file `app.py` where the\n`Flask` app is defined, it can be opened with:\n\nIO\n\n"}, {"name": "Flask.patch()", "path": "api/index#flask.Flask.patch", "type": "flask", "text": "\nShortcut for `route()` with `methods=[\"PATCH\"]`.\n\nNew in version 2.0.\n\nCallable\n\n"}, {"name": "Flask.permanent_session_lifetime", "path": "api/index#flask.Flask.permanent_session_lifetime", "type": "flask", "text": "\nA `timedelta` which is used to set the expiration date of a permanent session.\nThe default is 31 days which makes a permanent session survive for roughly one\nmonth.\n\nThis attribute can also be configured from the config with the\n`PERMANENT_SESSION_LIFETIME` configuration key. Defaults to\n`timedelta(days=31)`\n\n"}, {"name": "Flask.post()", "path": "api/index#flask.Flask.post", "type": "flask", "text": "\nShortcut for `route()` with `methods=[\"POST\"]`.\n\nNew in version 2.0.\n\nCallable\n\n"}, {"name": "Flask.preprocess_request()", "path": "api/index#flask.Flask.preprocess_request", "type": "flask", "text": "\nCalled before the request is dispatched. Calls `url_value_preprocessors`\nregistered with the app and the current blueprint (if any). Then calls\n`before_request_funcs` registered with the app and the blueprint.\n\nIf any `before_request()` handler returns a non-None value, the value is\nhandled as if it was the return value from the view, and further request\nhandling is stopped.\n\nOptional[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None,\nNone], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None,\nNone]], Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]],\nList[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]],\nTuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]],\nint], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None,\nNone]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]],\nList[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], WSGIApplication]]\n\n"}, {"name": "Flask.process_response()", "path": "api/index#flask.Flask.process_response", "type": "flask", "text": "\nCan be overridden in order to modify the response object before it\u2019s sent to\nthe WSGI server. By default this will call all the `after_request()` decorated\nfunctions.\n\nChanged in version 0.5: As of Flask 0.5 the functions registered for after\nrequest execution are called in reverse order of registration.\n\nresponse (flask.wrappers.Response) \u2013 a `response_class` object.\n\na new response object or the same, has to be an instance of `response_class`.\n\nflask.wrappers.Response\n\n"}, {"name": "Flask.put()", "path": "api/index#flask.Flask.put", "type": "flask", "text": "\nShortcut for `route()` with `methods=[\"PUT\"]`.\n\nNew in version 2.0.\n\nCallable\n\n"}, {"name": "Flask.register_blueprint()", "path": "api/index#flask.Flask.register_blueprint", "type": "flask", "text": "\nRegister a `Blueprint` on the application. Keyword arguments passed to this\nmethod will override the defaults set on the blueprint.\n\nCalls the blueprint\u2019s `register()` method after recording the blueprint in the\napplication\u2019s `blueprints`.\n\nNone\n\nNew in version 0.7.\n\n"}, {"name": "Flask.register_error_handler()", "path": "api/index#flask.Flask.register_error_handler", "type": "flask", "text": "\nAlternative error attach function to the `errorhandler()` decorator that is\nmore straightforward to use for non decorator usage.\n\nNew in version 0.7.\n\nNone\n\n"}, {"name": "flask.request", "path": "api/index#flask.request", "type": "flask", "text": "\nTo access incoming request data, you can use the global `request` object.\nFlask parses incoming request data for you and gives you access to it through\nthat global object. Internally Flask makes sure that you always get the\ncorrect data for the active thread if you are in a multithreaded environment.\n\nThis is a proxy. See Notes On Proxies for more information.\n\nThe request object is an instance of a `Request`.\n\n"}, {"name": "Flask.request_class", "path": "api/index#flask.Flask.request_class", "type": "flask", "text": "\nalias of `flask.wrappers.Request`\n\n"}, {"name": "Flask.request_context()", "path": "api/index#flask.Flask.request_context", "type": "flask", "text": "\nCreate a `RequestContext` representing a WSGI environment. Use a `with` block\nto push the context, which will make `request` point at this request.\n\nSee The Request Context.\n\nTypically you should not call this from your own code. A request context is\nautomatically pushed by the `wsgi_app()` when handling a request. Use\n`test_request_context()` to create an environment and context instead of this\nmethod.\n\nenviron (dict) \u2013 a WSGI environment\n\nflask.ctx.RequestContext\n\n"}, {"name": "flask.request_finished", "path": "api/index#flask.request_finished", "type": "flask", "text": "\nThis signal is sent right before the response is sent to the client. It is\npassed the response to be sent named `response`.\n\nExample subscriber:\n\n"}, {"name": "flask.request_started", "path": "api/index#flask.request_started", "type": "flask", "text": "\nThis signal is sent when the request context is set up, before any request\nprocessing happens. Because the request context is already bound, the\nsubscriber can access the request with the standard global proxies such as\n`request`.\n\nExample subscriber:\n\n"}, {"name": "flask.request_tearing_down", "path": "api/index#flask.request_tearing_down", "type": "flask", "text": "\nThis signal is sent when the request is tearing down. This is always called,\neven if an exception is caused. Currently functions listening to this signal\nare called after the regular teardown handlers, but this is not something you\ncan rely on.\n\nExample subscriber:\n\nAs of Flask 0.9, this will also be passed an `exc` keyword argument that has a\nreference to the exception that caused the teardown if there was one.\n\n"}, {"name": "Flask.response_class", "path": "api/index#flask.Flask.response_class", "type": "flask", "text": "\nalias of `flask.wrappers.Response`\n\n"}, {"name": "Flask.root_path", "path": "api/index#flask.Flask.root_path", "type": "flask", "text": "\nAbsolute path to the package on the filesystem. Used to look up resources\ncontained in the package.\n\n"}, {"name": "Flask.route()", "path": "api/index#flask.Flask.route", "type": "flask", "text": "\nDecorate a view function to register it with the given URL rule and options.\nCalls `add_url_rule()`, which has more details about the implementation.\n\nSee URL Route Registrations.\n\nThe endpoint name for the route defaults to the name of the view function if\nthe `endpoint` parameter isn\u2019t passed.\n\nThe `methods` parameter defaults to `[\"GET\"]`. `HEAD` and `OPTIONS` are added\nautomatically.\n\nCallable\n\n"}, {"name": "Flask.run()", "path": "api/index#flask.Flask.run", "type": "flask", "text": "\nRuns the application on a local development server.\n\nDo not use `run()` in a production setting. It is not intended to meet\nsecurity and performance requirements for a production server. Instead, see\nDeployment Options for WSGI server recommendations.\n\nIf the `debug` flag is set the server will automatically reload for code\nchanges and show a debugger in case an exception happened.\n\nIf you want to run the application in debug mode, but disable the code\nexecution on the interactive debugger, you can pass `use_evalex=False` as\nparameter. This will keep the debugger\u2019s traceback screen active, but disable\ncode execution.\n\nIt is not recommended to use this function for development with automatic\nreloading as this is badly supported. Instead you should be using the flask\ncommand line script\u2019s `run` support.\n\nKeep in Mind\n\nFlask will suppress any server error with a generic error page unless it is in\ndebug mode. As such to enable just the interactive debugger without the code\nreloading, you have to invoke `run()` with `debug=True` and\n`use_reloader=False`. Setting `use_debugger` to `True` without being in debug\nmode won\u2019t catch any exceptions because there won\u2019t be any to catch.\n\nNone\n\nChanged in version 1.0: If installed, python-dotenv will be used to load\nenvironment variables from `.env` and `.flaskenv` files.\n\nIf set, the `FLASK_ENV` and `FLASK_DEBUG` environment variables will override\n`env` and `debug`.\n\nThreaded mode is enabled by default.\n\nChanged in version 0.10: The default port is now picked from the `SERVER_NAME`\nvariable.\n\n"}, {"name": "Flask.secret_key", "path": "api/index#flask.Flask.secret_key", "type": "flask", "text": "\nIf a secret key is set, cryptographic components can use this to sign cookies\nand other things. Set this to a complex random value when you want to use the\nsecure cookie for instance.\n\nThis attribute can also be configured from the config with the `SECRET_KEY`\nconfiguration key. Defaults to `None`.\n\n"}, {"name": "Flask.select_jinja_autoescape()", "path": "api/index#flask.Flask.select_jinja_autoescape", "type": "flask", "text": "\nReturns `True` if autoescaping should be active for the given template name.\nIf no template name is given, returns `True`.\n\nNew in version 0.5.\n\nfilename (str) \u2013\n\nbool\n\n"}, {"name": "Flask.send_file_max_age_default", "path": "api/index#flask.Flask.send_file_max_age_default", "type": "flask", "text": "\nA `timedelta` or number of seconds which is used as the default `max_age` for\n`send_file()`. The default is `None`, which tells the browser to use\nconditional requests instead of a timed cache.\n\nConfigured with the `SEND_FILE_MAX_AGE_DEFAULT` configuration key.\n\nChanged in version 2.0: Defaults to `None` instead of 12 hours.\n\n"}, {"name": "Flask.send_static_file()", "path": "api/index#flask.Flask.send_static_file", "type": "flask", "text": "\nThe view function used to serve files from `static_folder`. A route is\nautomatically registered for this view at `static_url_path` if `static_folder`\nis set.\n\nNew in version 0.5.\n\nfilename (str) \u2013\n\nResponse\n\n"}, {"name": "Flask.session_cookie_name", "path": "api/index#flask.Flask.session_cookie_name", "type": "flask", "text": "\nThe secure cookie uses this for the name of the session cookie.\n\nThis attribute can also be configured from the config with the\n`SESSION_COOKIE_NAME` configuration key. Defaults to `'session'`\n\n"}, {"name": "Flask.session_interface", "path": "api/index#flask.Flask.session_interface", "type": "flask", "text": "\nthe session interface to use. By default an instance of\n`SecureCookieSessionInterface` is used here.\n\nNew in version 0.8.\n\n"}, {"name": "Flask.shell_context_processor()", "path": "api/index#flask.Flask.shell_context_processor", "type": "flask", "text": "\nRegisters a shell context processor function.\n\nNew in version 0.11.\n\nf (Callable) \u2013\n\nCallable\n\n"}, {"name": "Flask.shell_context_processors", "path": "api/index#flask.Flask.shell_context_processors", "type": "flask", "text": "\nA list of shell context processor functions that should be run when a shell\ncontext is created.\n\nNew in version 0.11.\n\n"}, {"name": "Flask.should_ignore_error()", "path": "api/index#flask.Flask.should_ignore_error", "type": "flask", "text": "\nThis is called to figure out if an error should be ignored or not as far as\nthe teardown system is concerned. If this function returns `True` then the\nteardown handlers will not be passed the error.\n\nNew in version 0.10.\n\nerror (Optional[BaseException]) \u2013\n\nbool\n\n"}, {"name": "flask.signals.signals_available", "path": "api/index#flask.signals.signals_available", "type": "flask", "text": "\n`True` if the signaling system is available. This is the case when blinker is\ninstalled.\n\n"}, {"name": "Flask.teardown_appcontext()", "path": "api/index#flask.Flask.teardown_appcontext", "type": "flask", "text": "\nRegisters a function to be called when the application context ends. These\nfunctions are typically also called when the request context is popped.\n\nExample:\n\nWhen `ctx.pop()` is executed in the above example, the teardown functions are\ncalled just before the app context moves from the stack of active contexts.\nThis becomes relevant if you are using such constructs in tests.\n\nSince a request context typically also manages an application context it would\nalso be called when you pop a request context.\n\nWhen a teardown function was called because of an unhandled exception it will\nbe passed an error object. If an `errorhandler()` is registered, it will\nhandle the exception and the teardown will not receive it.\n\nThe return values of teardown functions are ignored.\n\nNew in version 0.9.\n\nf (Callable[[Optional[BaseException]], flask.wrappers.Response]) \u2013\n\nCallable[[Optional[BaseException]], flask.wrappers.Response]\n\n"}, {"name": "Flask.teardown_appcontext_funcs", "path": "api/index#flask.Flask.teardown_appcontext_funcs", "type": "flask", "text": "\nA list of functions that are called when the application context is destroyed.\nSince the application context is also torn down if the request ends this is\nthe place to store code that disconnects from databases.\n\nNew in version 0.9.\n\n"}, {"name": "Flask.teardown_request()", "path": "api/index#flask.Flask.teardown_request", "type": "flask", "text": "\nRegister a function to be run at the end of each request, regardless of\nwhether there was an exception or not. These functions are executed when the\nrequest context is popped, even if not an actual request was performed.\n\nExample:\n\nWhen `ctx.pop()` is executed in the above example, the teardown functions are\ncalled just before the request context moves from the stack of active\ncontexts. This becomes relevant if you are using such constructs in tests.\n\nTeardown functions must avoid raising exceptions, since they . If they execute\ncode that might fail they will have to surround the execution of these code by\ntry/except statements and log occurring errors.\n\nWhen a teardown function was called because of an exception it will be passed\nan error object.\n\nThe return values of teardown functions are ignored.\n\nDebug Note\n\nIn debug mode Flask will not tear down a request on an exception immediately.\nInstead it will keep it alive so that the interactive debugger can still\naccess it. This behavior can be controlled by the\n`PRESERVE_CONTEXT_ON_EXCEPTION` configuration variable.\n\nf (Callable[[Optional[BaseException]], Response]) \u2013\n\nCallable[[Optional[BaseException]], Response]\n\n"}, {"name": "Flask.teardown_request_funcs", "path": "api/index#flask.Flask.teardown_request_funcs", "type": "flask", "text": "\nA data structure of functions to call at the end of each request even if an\nexception is raised, in the format `{scope: [functions]}`. The `scope` key is\nthe name of a blueprint the functions are active for, or `None` for all\nrequests.\n\nTo register a function, use the `teardown_request()` decorator.\n\nThis data structure is internal. It should not be modified directly and its\nformat may change at any time.\n\n"}, {"name": "Flask.template_context_processors", "path": "api/index#flask.Flask.template_context_processors", "type": "flask", "text": "\nA data structure of functions to call to pass extra context values when\nrendering templates, in the format `{scope: [functions]}`. The `scope` key is\nthe name of a blueprint the functions are active for, or `None` for all\nrequests.\n\nTo register a function, use the `context_processor()` decorator.\n\nThis data structure is internal. It should not be modified directly and its\nformat may change at any time.\n\n"}, {"name": "Flask.template_filter()", "path": "api/index#flask.Flask.template_filter", "type": "flask", "text": "\nA decorator that is used to register custom template filter. You can specify a\nname for the filter, otherwise the function name will be used. Example:\n\nname (Optional[str]) \u2013 the optional name of the filter, otherwise the function\nname will be used.\n\nCallable\n\n"}, {"name": "Flask.template_folder", "path": "api/index#flask.Flask.template_folder", "type": "flask", "text": "\nThe path to the templates folder, relative to `root_path`, to add to the\ntemplate loader. `None` if templates should not be added.\n\n"}, {"name": "Flask.template_global()", "path": "api/index#flask.Flask.template_global", "type": "flask", "text": "\nA decorator that is used to register a custom template global function. You\ncan specify a name for the global function, otherwise the function name will\nbe used. Example:\n\nNew in version 0.10.\n\nname (Optional[str]) \u2013 the optional name of the global function, otherwise the\nfunction name will be used.\n\nCallable\n\n"}, {"name": "flask.template_rendered", "path": "api/index#flask.template_rendered", "type": "flask", "text": "\nThis signal is sent when a template was successfully rendered. The signal is\ninvoked with the instance of the template as `template` and the context as\ndictionary (named `context`).\n\nExample subscriber:\n\n"}, {"name": "Flask.template_test()", "path": "api/index#flask.Flask.template_test", "type": "flask", "text": "\nA decorator that is used to register custom template test. You can specify a\nname for the test, otherwise the function name will be used. Example:\n\nNew in version 0.10.\n\nname (Optional[str]) \u2013 the optional name of the test, otherwise the function\nname will be used.\n\nCallable\n\n"}, {"name": "Flask.testing", "path": "api/index#flask.Flask.testing", "type": "flask", "text": "\nThe testing flag. Set this to `True` to enable the test mode of Flask\nextensions (and in the future probably also Flask itself). For example this\nmight activate test helpers that have an additional runtime cost which should\nnot be enabled by default.\n\nIf this is enabled and PROPAGATE_EXCEPTIONS is not changed from the default\nit\u2019s implicitly enabled.\n\nThis attribute can also be configured from the config with the `TESTING`\nconfiguration key. Defaults to `False`.\n\n"}, {"name": "Flask.test_client()", "path": "api/index#flask.Flask.test_client", "type": "flask", "text": "\nCreates a test client for this application. For information about unit testing\nhead over to Testing Flask Applications.\n\nNote that if you are testing for assertions or exceptions in your application\ncode, you must set `app.testing = True` in order for the exceptions to\npropagate to the test client. Otherwise, the exception will be handled by the\napplication (not visible to the test client) and the only indication of an\nAssertionError or other exception will be a 500 status code response to the\ntest client. See the `testing` attribute. For example:\n\nThe test client can be used in a `with` block to defer the closing down of the\ncontext until the end of the `with` block. This is useful if you want to\naccess the context locals for testing:\n\nAdditionally, you may pass optional keyword arguments that will then be passed\nto the application\u2019s `test_client_class` constructor. For example:\n\nSee `FlaskClient` for more information.\n\nChanged in version 0.11: Added `**kwargs` to support passing additional\nkeyword arguments to the constructor of `test_client_class`.\n\nNew in version 0.7: The `use_cookies` parameter was added as well as the\nability to override the client to be used by setting the `test_client_class`\nattribute.\n\nChanged in version 0.4: added support for `with` block usage for the client.\n\nFlaskClient\n\n"}, {"name": "Flask.test_client_class", "path": "api/index#flask.Flask.test_client_class", "type": "flask", "text": "\nthe test client that is used with when `test_client` is used.\n\nNew in version 0.7.\n\n"}, {"name": "Flask.test_cli_runner()", "path": "api/index#flask.Flask.test_cli_runner", "type": "flask", "text": "\nCreate a CLI runner for testing CLI commands. See Testing CLI Commands.\n\nReturns an instance of `test_cli_runner_class`, by default `FlaskCliRunner`.\nThe Flask app object is passed as the first argument.\n\nNew in version 1.0.\n\nkwargs (Any) \u2013\n\nFlaskCliRunner\n\n"}, {"name": "Flask.test_cli_runner_class", "path": "api/index#flask.Flask.test_cli_runner_class", "type": "flask", "text": "\nThe `CliRunner` subclass, by default `FlaskCliRunner` that is used by\n`test_cli_runner()`. Its `__init__` method should take a Flask app object as\nthe first argument.\n\nNew in version 1.0.\n\n"}, {"name": "Flask.test_request_context()", "path": "api/index#flask.Flask.test_request_context", "type": "flask", "text": "\nCreate a `RequestContext` for a WSGI environment created from the given\nvalues. This is mostly useful during testing, where you may want to run a\nfunction that uses request data without dispatching a full request.\n\nSee The Request Context.\n\nUse a `with` block to push the context, which will make `request` point at the\nrequest for the created environment.\n\nWhen using the shell, it may be easier to push and pop the context manually to\navoid indentation.\n\nTakes the same arguments as Werkzeug\u2019s `EnvironBuilder`, with some defaults\nfrom the application. See the linked Werkzeug docs for most of the available\narguments. Flask-specific behavior is listed here.\n\nflask.ctx.RequestContext\n\n"}, {"name": "Flask.trap_http_exception()", "path": "api/index#flask.Flask.trap_http_exception", "type": "flask", "text": "\nChecks if an HTTP exception should be trapped or not. By default this will\nreturn `False` for all exceptions except for a bad request key error if\n`TRAP_BAD_REQUEST_ERRORS` is set to `True`. It also returns `True` if\n`TRAP_HTTP_EXCEPTIONS` is set to `True`.\n\nThis is called for all HTTP exceptions raised by a view function. If it\nreturns `True` for any exception the error handler for this exception is not\ncalled and it shows up as regular exception in the traceback. This is helpful\nfor debugging implicitly raised HTTP exceptions.\n\nChanged in version 1.0: Bad request errors are not trapped by default in debug\nmode.\n\nNew in version 0.8.\n\ne (Exception) \u2013\n\nbool\n\n"}, {"name": "Flask.update_template_context()", "path": "api/index#flask.Flask.update_template_context", "type": "flask", "text": "\nUpdate the template context with some commonly used variables. This injects\nrequest, session, config and g into the template context as well as everything\ntemplate context processors want to inject. Note that the as of Flask 0.6, the\noriginal values in the context will not be overridden if a context processor\ndecides to return a value with the same key.\n\ncontext (dict) \u2013 the context as a dictionary that is updated in place to add\nextra variables.\n\nNone\n\n"}, {"name": "Flask.url_build_error_handlers", "path": "api/index#flask.Flask.url_build_error_handlers", "type": "flask", "text": "\nA list of functions that are called when `url_for()` raises a `BuildError`.\nEach function registered here is called with `error`, `endpoint` and `values`.\nIf a function returns `None` or raises a `BuildError` the next function is\ntried.\n\nNew in version 0.9.\n\n"}, {"name": "Flask.url_defaults()", "path": "api/index#flask.Flask.url_defaults", "type": "flask", "text": "\nCallback function for URL defaults for all view functions of the application.\nIt\u2019s called with the endpoint and values and should update the values passed\nin place.\n\nf (Callable[[str, dict], None]) \u2013\n\nCallable[[str, dict], None]\n\n"}, {"name": "Flask.url_default_functions", "path": "api/index#flask.Flask.url_default_functions", "type": "flask", "text": "\nA data structure of functions to call to modify the keyword arguments when\ngenerating URLs, in the format `{scope: [functions]}`. The `scope` key is the\nname of a blueprint the functions are active for, or `None` for all requests.\n\nTo register a function, use the `url_defaults()` decorator.\n\nThis data structure is internal. It should not be modified directly and its\nformat may change at any time.\n\n"}, {"name": "Flask.url_map", "path": "api/index#flask.Flask.url_map", "type": "flask", "text": "\nThe `Map` for this instance. You can use this to change the routing converters\nafter the class was created but before any routes are connected. Example:\n\n"}, {"name": "Flask.url_map_class", "path": "api/index#flask.Flask.url_map_class", "type": "flask", "text": "\nalias of `werkzeug.routing.Map`\n\n"}, {"name": "Flask.url_rule_class", "path": "api/index#flask.Flask.url_rule_class", "type": "flask", "text": "\nalias of `werkzeug.routing.Rule`\n\n"}, {"name": "Flask.url_value_preprocessor()", "path": "api/index#flask.Flask.url_value_preprocessor", "type": "flask", "text": "\nRegister a URL value preprocessor function for all view functions in the\napplication. These functions will be called before the `before_request()`\nfunctions.\n\nThe function can modify the values captured from the matched url before they\nare passed to the view. For example, this can be used to pop a common language\ncode value and place it in `g` rather than pass it to every view.\n\nThe function is passed the endpoint name and values dict. The return value is\nignored.\n\nf (Callable[[Optional[str], Optional[dict]], None]) \u2013\n\nCallable[[Optional[str], Optional[dict]], None]\n\n"}, {"name": "Flask.url_value_preprocessors", "path": "api/index#flask.Flask.url_value_preprocessors", "type": "flask", "text": "\nA data structure of functions to call to modify the keyword arguments passed\nto the view function, in the format `{scope: [functions]}`. The `scope` key is\nthe name of a blueprint the functions are active for, or `None` for all\nrequests.\n\nTo register a function, use the `url_value_preprocessor()` decorator.\n\nThis data structure is internal. It should not be modified directly and its\nformat may change at any time.\n\n"}, {"name": "Flask.use_x_sendfile", "path": "api/index#flask.Flask.use_x_sendfile", "type": "flask", "text": "\nEnable this if you want to use the X-Sendfile feature. Keep in mind that the\nserver has to support this. This only affects files sent with the\n`send_file()` method.\n\nNew in version 0.2.\n\nThis attribute can also be configured from the config with the\n`USE_X_SENDFILE` configuration key. Defaults to `False`.\n\n"}, {"name": "Flask.view_functions", "path": "api/index#flask.Flask.view_functions", "type": "flask", "text": "\nA dictionary mapping endpoint names to view functions.\n\nTo register a view function, use the `route()` decorator.\n\nThis data structure is internal. It should not be modified directly and its\nformat may change at any time.\n\n"}, {"name": "Flask.wsgi_app()", "path": "api/index#flask.Flask.wsgi_app", "type": "flask", "text": "\nThe actual WSGI application. This is not implemented in `__call__()` so that\nmiddlewares can be applied without losing a reference to the app object.\nInstead of doing this:\n\nIt\u2019s a better idea to do this instead:\n\nThen you still have the original application object around and can continue to\ncall methods on it.\n\nChanged in version 0.7: Teardown events for the request and app contexts are\ncalled even if an unhandled error occurs. Other events may not be called\ndepending on when an error occurs during dispatch. See Callbacks and Errors.\n\nAny\n\n"}, {"name": "flask._app_ctx_stack", "path": "api/index#flask._app_ctx_stack", "type": "flask", "text": "\nThe internal `LocalStack` that holds `AppContext` instances. Typically, the\n`current_app` and `g` proxies should be accessed instead of the stack.\nExtensions can access the contexts on the stack as a namespace to store data.\n\nNew in version 0.9.\n\n"}, {"name": "flask._request_ctx_stack", "path": "api/index#flask._request_ctx_stack", "type": "flask", "text": "\nThe internal `LocalStack` that holds `RequestContext` instances. Typically,\nthe `request` and `session` proxies should be accessed instead of the stack.\nIt may be useful to access the stack in extension code.\n\nThe following attributes are always present on each layer of the stack:\n\nthe active Flask application.\n\nthe URL adapter that was used to match the request.\n\nthe current request object.\n\nthe active session object.\n\nan object with all the attributes of the `flask.g` object.\n\nan internal cache for the flashed messages.\n\nExample usage:\n\n"}, {"name": "FlaskClient", "path": "api/index#flask.testing.FlaskClient", "type": "flask.testing", "text": "\nWorks like a regular Werkzeug test client but has some knowledge about how\nFlask works to defer the cleanup of the request context stack to the end of a\n`with` body when used in a `with` statement. For general information about how\nto use this class refer to `werkzeug.test.Client`.\n\nChanged in version 0.12: `app.test_client()` includes preset default\nenvironment, which can be set after instantiation of the `app.test_client()`\nobject in `client.environ_base`.\n\nBasic usage is outlined in the Testing Flask Applications chapter.\n\nNone\n\nGenerate an environ dict from the given arguments, make a request to the\napplication using it, and return the response.\n\nResponse\n\nChanged in version 2.0: `as_tuple` is deprecated and will be removed in\nWerkzeug 2.1. Use `TestResponse.request` and `request.environ` instead.\n\nChanged in version 2.0: The request input stream is closed when calling\n`response.close()`. Input streams for redirects are automatically closed.\n\nChanged in version 0.5: If a dict is provided as file in the dict for the\n`data` parameter the content type has to be called `content_type` instead of\n`mimetype`. This change was made for consistency with `werkzeug.FileWrapper`.\n\nChanged in version 0.5: Added the `follow_redirects` parameter.\n\nWhen used in combination with a `with` statement this opens a session\ntransaction. This can be used to modify the session that the test client uses.\nOnce the `with` block is left the session is stored back.\n\nInternally this is implemented by going through a temporary test request\ncontext and since session handling could depend on request variables this\nfunction accepts the same arguments as `test_request_context()` which are\ndirectly passed through.\n\nGenerator[flask.sessions.SessionMixin, None, None]\n\n"}, {"name": "FlaskClient.open()", "path": "api/index#flask.testing.FlaskClient.open", "type": "flask.testing", "text": "\nGenerate an environ dict from the given arguments, make a request to the\napplication using it, and return the response.\n\nResponse\n\nChanged in version 2.0: `as_tuple` is deprecated and will be removed in\nWerkzeug 2.1. Use `TestResponse.request` and `request.environ` instead.\n\nChanged in version 2.0: The request input stream is closed when calling\n`response.close()`. Input streams for redirects are automatically closed.\n\nChanged in version 0.5: If a dict is provided as file in the dict for the\n`data` parameter the content type has to be called `content_type` instead of\n`mimetype`. This change was made for consistency with `werkzeug.FileWrapper`.\n\nChanged in version 0.5: Added the `follow_redirects` parameter.\n\n"}, {"name": "FlaskClient.session_transaction()", "path": "api/index#flask.testing.FlaskClient.session_transaction", "type": "flask.testing", "text": "\nWhen used in combination with a `with` statement this opens a session\ntransaction. This can be used to modify the session that the test client uses.\nOnce the `with` block is left the session is stored back.\n\nInternally this is implemented by going through a temporary test request\ncontext and since session handling could depend on request variables this\nfunction accepts the same arguments as `test_request_context()` which are\ndirectly passed through.\n\nGenerator[flask.sessions.SessionMixin, None, None]\n\n"}, {"name": "FlaskCliRunner", "path": "api/index#flask.testing.FlaskCliRunner", "type": "flask.testing", "text": "\nA `CliRunner` for testing a Flask app\u2019s CLI commands. Typically created using\n`test_cli_runner()`. See Testing CLI Commands.\n\nNone\n\nInvokes a CLI command in an isolated environment. See `CliRunner.invoke` for\nfull method documentation. See Testing CLI Commands for examples.\n\nIf the `obj` argument is not given, passes an instance of `ScriptInfo` that\nknows how to load the Flask app being tested.\n\na `Result` object.\n\nAny\n\n"}, {"name": "FlaskCliRunner.invoke()", "path": "api/index#flask.testing.FlaskCliRunner.invoke", "type": "flask.testing", "text": "\nInvokes a CLI command in an isolated environment. See `CliRunner.invoke` for\nfull method documentation. See Testing CLI Commands for examples.\n\nIf the `obj` argument is not given, passes an instance of `ScriptInfo` that\nknows how to load the Flask app being tested.\n\na `Result` object.\n\nAny\n\n"}, {"name": "FlaskGroup", "path": "api/index#flask.cli.FlaskGroup", "type": "flask.cli", "text": "\nSpecial subclass of the `AppGroup` group that supports loading more commands\nfrom the configured Flask app. Normally a developer does not have to interface\nwith this class but there are some very advanced use cases for which it makes\nsense to create an instance of this. see Custom Scripts.\n\nChanged in version 1.0: If installed, python-dotenv will be used to load\nenvironment variables from `.env` and `.flaskenv` files.\n\nGiven a context and a command name, this returns a `Command` object if it\nexists or returns `None`.\n\nReturns a list of subcommand names in the order they should appear.\n\nThis is the way to invoke a script with all the bells and whistles as a\ncommand line application. This will always terminate the application after a\ncall. If this is not wanted, `SystemExit` needs to be caught.\n\nThis method is also available by directly calling the instance of a `Command`.\n\nChanged in version 8.0: When taking arguments from `sys.argv` on Windows, glob\npatterns, user dir, and env vars are expanded.\n\nChanged in version 3.0: Added the `standalone_mode` parameter.\n\n"}, {"name": "FlaskGroup.get_command()", "path": "api/index#flask.cli.FlaskGroup.get_command", "type": "flask.cli", "text": "\nGiven a context and a command name, this returns a `Command` object if it\nexists or returns `None`.\n\n"}, {"name": "FlaskGroup.list_commands()", "path": "api/index#flask.cli.FlaskGroup.list_commands", "type": "flask.cli", "text": "\nReturns a list of subcommand names in the order they should appear.\n\n"}, {"name": "FlaskGroup.main()", "path": "api/index#flask.cli.FlaskGroup.main", "type": "flask.cli", "text": "\nThis is the way to invoke a script with all the bells and whistles as a\ncommand line application. This will always terminate the application after a\ncall. If this is not wanted, `SystemExit` needs to be caught.\n\nThis method is also available by directly calling the instance of a `Command`.\n\nChanged in version 8.0: When taking arguments from `sys.argv` on Windows, glob\npatterns, user dir, and env vars are expanded.\n\nChanged in version 3.0: Added the `standalone_mode` parameter.\n\n"}, {"name": "Foreword", "path": "foreword/index", "type": "User\u2019s Guide", "text": "\nRead this before you get started with Flask. This hopefully answers some\nquestions about the purpose and goals of the project, and when you should or\nshould not be using it.\n\n\u201cMicro\u201d does not mean that your whole web application has to fit into a single\nPython file (although it certainly can), nor does it mean that Flask is\nlacking in functionality. The \u201cmicro\u201d in microframework means Flask aims to\nkeep the core simple but extensible. Flask won\u2019t make many decisions for you,\nsuch as what database to use. Those decisions that it does make, such as what\ntemplating engine to use, are easy to change. Everything else is up to you, so\nthat Flask can be everything you need and nothing you don\u2019t.\n\nBy default, Flask does not include a database abstraction layer, form\nvalidation or anything else where different libraries already exist that can\nhandle that. Instead, Flask supports extensions to add such functionality to\nyour application as if it was implemented in Flask itself. Numerous extensions\nprovide database integration, form validation, upload handling, various open\nauthentication technologies, and more. Flask may be \u201cmicro\u201d, but it\u2019s ready\nfor production use on a variety of needs.\n\nFlask has many configuration values, with sensible defaults, and a few\nconventions when getting started. By convention, templates and static files\nare stored in subdirectories within the application\u2019s Python source tree, with\nthe names `templates` and `static` respectively. While this can be changed,\nyou usually don\u2019t have to, especially when getting started.\n\nOnce you have Flask up and running, you\u2019ll find a variety of extensions\navailable in the community to integrate your project for production.\n\nAs your codebase grows, you are free to make the design decisions appropriate\nfor your project. Flask will continue to provide a very simple glue layer to\nthe best that Python has to offer. You can implement advanced patterns in\nSQLAlchemy or another database tool, introduce non-relational data persistence\nas appropriate, and take advantage of framework-agnostic tools built for WSGI,\nthe Python web interface.\n\nFlask includes many hooks to customize its behavior. Should you need more\ncustomization, the Flask class is built for subclassing. If you are interested\nin that, check out the Becoming Big chapter. If you are curious about the\nFlask design principles, head over to the section about Design Decisions in\nFlask.\n\n"}, {"name": "Foreword for Experienced Programmers", "path": "advanced_foreword/index", "type": "User\u2019s Guide", "text": "\nOne of the design decisions in Flask was that simple tasks should be simple;\nthey should not take a lot of code and yet they should not limit you. Because\nof that, Flask has a few design choices that some people might find surprising\nor unorthodox. For example, Flask uses thread-local objects internally so that\nyou don\u2019t have to pass objects around from function to function within a\nrequest in order to stay threadsafe. This approach is convenient, but requires\na valid request context for dependency injection or when attempting to reuse\ncode which uses a value pegged to the request. The Flask project is honest\nabout thread-locals, does not hide them, and calls out in the code and\ndocumentation where they are used.\n\nAlways keep security in mind when building web applications.\n\nIf you write a web application, you are probably allowing users to register\nand leave their data on your server. The users are entrusting you with data.\nAnd even if you are the only user that might leave data in your application,\nyou still want that data to be stored securely.\n\nUnfortunately, there are many ways the security of a web application can be\ncompromised. Flask protects you against one of the most common security\nproblems of modern web applications: cross-site scripting (XSS). Unless you\ndeliberately mark insecure HTML as secure, Flask and the underlying Jinja2\ntemplate engine have you covered. But there are many more ways to cause\nsecurity problems.\n\nThe documentation will warn you about aspects of web development that require\nattention to security. Some of these security concerns are far more complex\nthan one might think, and we all sometimes underestimate the likelihood that a\nvulnerability will be exploited - until a clever attacker figures out a way to\nexploit our applications. And don\u2019t think that your application is not\nimportant enough to attract an attacker. Depending on the kind of attack,\nchances are that automated bots are probing for ways to fill your database\nwith spam, links to malicious software, and the like.\n\nFlask is no different from any other framework in that you the developer must\nbuild with caution, watching for exploits when building to your requirements.\n\n"}, {"name": "Form Validation with WTForms", "path": "patterns/wtforms/index", "type": "User's Guide: Design Patterns", "text": "\nWhen you have to work with form data submitted by a browser view, code quickly\nbecomes very hard to read. There are libraries out there designed to make this\nprocess easier to manage. One of them is WTForms which we will handle here. If\nyou find yourself in the situation of having many forms, you might want to\ngive it a try.\n\nWhen you are working with WTForms you have to define your forms as classes\nfirst. I recommend breaking up the application into multiple modules (Large\nApplications as Packages) for that and adding a separate module for the forms.\n\nGetting the most out of WTForms with an Extension\n\nThe Flask-WTF extension expands on this pattern and adds a few little helpers\nthat make working with forms and Flask more fun. You can get it from PyPI.\n\nThis is an example form for a typical registration page:\n\nIn the view function, the usage of this form looks like this:\n\nNotice we\u2019re implying that the view is using SQLAlchemy here (SQLAlchemy in\nFlask), but that\u2019s not a requirement, of course. Adapt the code as necessary.\n\nThings to remember:\n\nNow to the template side. When you pass the form to the templates, you can\neasily render them there. Look at the following example template to see how\neasy this is. WTForms does half the form generation for us already. To make it\neven nicer, we can write a macro that renders a field with label and a list of\nerrors if there are any.\n\nHere\u2019s an example `_formhelpers.html` template with such a macro:\n\nThis macro accepts a couple of keyword arguments that are forwarded to\nWTForm\u2019s field function, which renders the field for us. The keyword arguments\nwill be inserted as HTML attributes. So, for example, you can call\n`render_field(form.username, class='username')` to add a class to the input\nelement. Note that WTForms returns standard Python strings, so we have to tell\nJinja2 that this data is already HTML-escaped with the `|safe` filter.\n\nHere is the `register.html` template for the function we used above, which\ntakes advantage of the `_formhelpers.html` template:\n\nFor more information about WTForms, head over to the WTForms website.\n\n"}, {"name": "get_flashed_messages()", "path": "api/index#flask.get_flashed_messages", "type": "flask", "text": "\nPulls all flashed messages from the session and returns them. Further calls in\nthe same request to the function will return the same messages. By default\njust the messages are returned, but when `with_categories` is set to `True`,\nthe return value will be a list of tuples in the form `(category, message)`\ninstead.\n\nFilter the flashed messages to one or more categories by providing those\ncategories in `category_filter`. This allows rendering categories in separate\nhtml blocks. The `with_categories` and `category_filter` arguments are\ndistinct:\n\nSee Message Flashing for examples.\n\nChanged in version 0.9: `category_filter` parameter added.\n\nChanged in version 0.3: `with_categories` parameter added.\n\nUnion[List[str], List[Tuple[str, str]]]\n\n"}, {"name": "get_template_attribute()", "path": "api/index#flask.get_template_attribute", "type": "flask", "text": "\nLoads a macro (or variable) a template exports. This can be used to invoke a\nmacro from within Python code. If you for example have a template named\n`_cider.html` with the following contents:\n\nYou can access this from Python code like this:\n\nNew in version 0.2.\n\nAny\n\n"}, {"name": "Handling Application Errors", "path": "errorhandling/index", "type": "User\u2019s Guide", "text": "\nApplications fail, servers fail. Sooner or later you will see an exception in\nproduction. Even if your code is 100% correct, you will still see exceptions\nfrom time to time. Why? Because everything else involved will fail. Here are\nsome situations where perfectly fine code can lead to server errors:\n\nAnd that\u2019s just a small sample of issues you could be facing. So how do we\ndeal with that sort of problem? By default if your application runs in\nproduction mode, and an exception is raised Flask will display a very simple\npage for you and log the exception to the `logger`.\n\nBut there is more you can do, and we will cover some better setups to deal\nwith errors including custom exceptions and 3rd party tools.\n\nSending error mails, even if just for critical ones, can become overwhelming\nif enough users are hitting the error and log files are typically never looked\nat. This is why we recommend using Sentry for dealing with application errors.\nIt\u2019s available as a source-available project on GitHub and is also available\nas a hosted version which you can try for free. Sentry aggregates duplicate\nerrors, captures the full stack trace and local variables for debugging, and\nsends you mails based on new errors or frequency thresholds.\n\nTo use Sentry you need to install the `sentry-sdk` client with extra `flask`\ndependencies.\n\nAnd then add this to your Flask app:\n\nThe `YOUR_DSN_HERE` value needs to be replaced with the DSN value you get from\nyour Sentry installation.\n\nAfter installation, failures leading to an Internal Server Error are\nautomatically reported to Sentry and from there you can receive error\nnotifications.\n\nSee also:\n\nWhen an error occurs in Flask, an appropriate HTTP status code will be\nreturned. 400-499 indicate errors with the client\u2019s request data, or about the\ndata requested. 500-599 indicate errors with the server or application itself.\n\nYou might want to show custom error pages to the user when an error occurs.\nThis can be done by registering error handlers.\n\nAn error handler is a function that returns a response when a type of error is\nraised, similar to how a view is a function that returns a response when a\nrequest URL is matched. It is passed the instance of the error being handled,\nwhich is most likely a `HTTPException`.\n\nThe status code of the response will not be set to the handler\u2019s code. Make\nsure to provide the appropriate HTTP status code when returning a response\nfrom a handler.\n\nRegister handlers by decorating a function with `errorhandler()`. Or use\n`register_error_handler()` to register the function later. Remember to set the\nerror code when returning the response.\n\n`werkzeug.exceptions.HTTPException` subclasses like `BadRequest` and their\nHTTP codes are interchangeable when registering handlers. (`BadRequest.code ==\n400`)\n\nNon-standard HTTP codes cannot be registered by code because they are not\nknown by Werkzeug. Instead, define a subclass of `HTTPException` with the\nappropriate code and register and raise that exception class.\n\nHandlers can be registered for any exception class, not just `HTTPException`\nsubclasses or HTTP status codes. Handlers can be registered for a specific\nclass, or for all subclasses of a parent class.\n\nWhen building a Flask application you will run into exceptions. If some part\nof your code breaks while handling a request (and you have no error handlers\nregistered), a \u201c500 Internal Server Error\u201d (`InternalServerError`) will be\nreturned by default. Similarly, \u201c404 Not Found\u201d (`NotFound`) error will occur\nif a request is sent to an unregistered route. If a route receives an\nunallowed request method, a \u201c405 Method Not Allowed\u201d (`MethodNotAllowed`) will\nbe raised. These are all subclasses of `HTTPException` and are provided by\ndefault in Flask.\n\nFlask gives you to the ability to raise any HTTP exception registered by\nWerkzeug. However, the default HTTP exceptions return simple exception pages.\nYou might want to show custom error pages to the user when an error occurs.\nThis can be done by registering error handlers.\n\nWhen Flask catches an exception while handling a request, it is first looked\nup by code. If no handler is registered for the code, Flask looks up the error\nby its class hierarchy; the most specific handler is chosen. If no handler is\nregistered, `HTTPException` subclasses show a generic message about their\ncode, while other exceptions are converted to a generic \u201c500 Internal Server\nError\u201d.\n\nFor example, if an instance of `ConnectionRefusedError` is raised, and a\nhandler is registered for `ConnectionError` and `ConnectionRefusedError`, the\nmore specific `ConnectionRefusedError` handler is called with the exception\ninstance to generate the response.\n\nHandlers registered on the blueprint take precedence over those registered\nglobally on the application, assuming a blueprint is handling the request that\nraises the exception. However, the blueprint cannot handle 404 routing errors\nbecause the 404 occurs at the routing level before the blueprint can be\ndetermined.\n\nIt is possible to register error handlers for very generic base classes such\nas `HTTPException` or even `Exception`. However, be aware that these will\ncatch more than you might expect.\n\nFor example, an error handler for `HTTPException` might be useful for turning\nthe default HTML errors pages into JSON. However, this handler will trigger\nfor things you don\u2019t cause directly, such as 404 and 405 errors during\nrouting. Be sure to craft your handler carefully so you don\u2019t lose information\nabout the HTTP error.\n\nAn error handler for `Exception` might seem useful for changing how all\nerrors, even unhandled ones, are presented to the user. However, this is\nsimilar to doing `except Exception:` in Python, it will capture all otherwise\nunhandled errors, including all HTTP status codes.\n\nIn most cases it will be safer to register handlers for more specific\nexceptions. Since `HTTPException` instances are valid WSGI responses, you\ncould also pass them through directly.\n\nError handlers still respect the exception class hierarchy. If you register\nhandlers for both `HTTPException` and `Exception`, the `Exception` handler\nwill not handle `HTTPException` subclasses because it the `HTTPException`\nhandler is more specific.\n\nWhen there is no error handler registered for an exception, a 500 Internal\nServer Error will be returned instead. See `flask.Flask.handle_exception()`\nfor information about this behavior.\n\nIf there is an error handler registered for `InternalServerError`, this will\nbe invoked. As of Flask 1.1.0, this error handler will always be passed an\ninstance of `InternalServerError`, not the original unhandled error.\n\nThe original error is available as `e.original_exception`.\n\nAn error handler for \u201c500 Internal Server Error\u201d will be passed uncaught\nexceptions in addition to explicit 500 errors. In debug mode, a handler for\n\u201c500 Internal Server Error\u201d will not be used. Instead, the interactive\ndebugger will be shown.\n\nSometimes when building a Flask application, you might want to raise a\n`HTTPException` to signal to the user that something is wrong with the\nrequest. Fortunately, Flask comes with a handy `abort()` function that aborts\na request with a HTTP error from werkzeug as desired. It will also provide a\nplain black and white error page for you with a basic description, but nothing\nfancy.\n\nDepending on the error code it is less or more likely for the user to actually\nsee such an error.\n\nConsider the code below, we might have a user profile route, and if the user\nfails to pass a username we can raise a \u201c400 Bad Request\u201d. If the user passes\na username and we can\u2019t find it, we raise a \u201c404 Not Found\u201d.\n\nHere is another example implementation for a \u201c404 Page Not Found\u201d exception:\n\nWhen using Application Factories:\n\nAn example template might be this:\n\nThe above examples wouldn\u2019t actually be an improvement on the default\nexception pages. We can create a custom 500.html template like this:\n\nIt can be implemented by rendering the template on \u201c500 Internal Server\nError\u201d:\n\nWhen using Application Factories:\n\nWhen using Modular Applications with Blueprints:\n\nIn Modular Applications with Blueprints, most error handlers will work as\nexpected. However, there is a caveat concerning handlers for 404 and 405\nexceptions. These error handlers are only invoked from an appropriate `raise`\nstatement or a call to `abort` in another of the blueprint\u2019s view functions;\nthey are not invoked by, e.g., an invalid URL access.\n\nThis is because the blueprint does not \u201cown\u201d a certain URL space, so the\napplication instance has no way of knowing which blueprint error handler it\nshould run if given an invalid URL. If you would like to execute different\nhandling strategies for these errors based on URL prefixes, they may be\ndefined at the application level using the `request` proxy object.\n\nWhen building APIs in Flask, some developers realise that the built-in\nexceptions are not expressive enough for APIs and that the content type of\ntext/html they are emitting is not very useful for API consumers.\n\nUsing the same techniques as above and `jsonify()` we can return JSON\nresponses to API errors. `abort()` is called with a `description` parameter.\nThe error handler will use that as the JSON error message, and set the status\ncode to 404.\n\nWe can also create custom exception classes. For instance, we can introduce a\nnew custom exception for an API that can take a proper human readable message,\na status code for the error and some optional payload to give more context for\nthe error.\n\nThis is a simple example:\n\nA view can now raise that exception with an error message. Additionally some\nextra payload can be provided as a dictionary through the `payload` parameter.\n\nSee Logging for information about how to log exceptions, such as by emailing\nthem to admins.\n\nSee Debugging Application Errors for information about how to debug errors in\ndevelopment and production.\n\n"}, {"name": "has_app_context()", "path": "api/index#flask.has_app_context", "type": "flask", "text": "\nWorks like `has_request_context()` but for the application context. You can\nalso just do a boolean check on the `current_app` object instead.\n\nNew in version 0.9.\n\nbool\n\n"}, {"name": "has_request_context()", "path": "api/index#flask.has_request_context", "type": "flask", "text": "\nIf you have code that wants to test if a request context is there or not this\nfunction can be used. For instance, you may want to take advantage of request\ninformation if the request object is available, but fail silently if it is\nunavailable.\n\nAlternatively you can also just test any of the context bound objects (such as\n`request` or `g`) for truthness:\n\nNew in version 0.7.\n\nbool\n\n"}, {"name": "HTML/XHTML FAQ", "path": "htmlfaq/index", "type": "Additional Notes", "text": "\nThe Flask documentation and example applications are using HTML5. You may\nnotice that in many situations, when end tags are optional they are not used,\nso that the HTML is cleaner and faster to load. Because there is much\nconfusion about HTML and XHTML among developers, this document tries to answer\nsome of the major questions.\n\nFor a while, it appeared that HTML was about to be replaced by XHTML. However,\nbarely any websites on the Internet are actual XHTML (which is HTML processed\nusing XML rules). There are a couple of major reasons why this is the case.\nOne of them is Internet Explorer\u2019s lack of proper XHTML support. The XHTML\nspec states that XHTML must be served with the MIME type\napplication/xhtml+xml, but Internet Explorer refuses to read files with that\nMIME type. While it is relatively easy to configure Web servers to serve XHTML\nproperly, few people do. This is likely because properly using XHTML can be\nquite painful.\n\nOne of the most important causes of pain is XML\u2019s draconian (strict and\nruthless) error handling. When an XML parsing error is encountered, the\nbrowser is supposed to show the user an ugly error message, instead of\nattempting to recover from the error and display what it can. Most of the\n(X)HTML generation on the web is based on non-XML template engines (such as\nJinja, the one used in Flask) which do not protect you from accidentally\ncreating invalid XHTML. There are XML based template engines, such as Kid and\nthe popular Genshi, but they often come with a larger runtime overhead and are\nnot as straightforward to use because they have to obey XML rules.\n\nThe majority of users, however, assumed they were properly using XHTML. They\nwrote an XHTML doctype at the top of the document and self-closed all the\nnecessary tags (`<br>` becomes `<br/>` or `<br></br>` in XHTML). However, even\nif the document properly validates as XHTML, what really determines XHTML/HTML\nprocessing in browsers is the MIME type, which as said before is often not set\nproperly. So the valid XHTML was being treated as invalid HTML.\n\nXHTML also changed the way JavaScript is used. To properly work with XHTML,\nprogrammers have to use the namespaced DOM interface with the XHTML namespace\nto query for HTML elements.\n\nDevelopment of the HTML5 specification was started in 2004 under the name \u201cWeb\nApplications 1.0\u201d by the Web Hypertext Application Technology Working Group,\nor WHATWG (which was formed by the major browser vendors Apple, Mozilla, and\nOpera) with the goal of writing a new and improved HTML specification, based\non existing browser behavior instead of unrealistic and backwards-incompatible\nspecifications.\n\nFor example, in HTML4 `<title/Hello/` theoretically parses exactly the same as\n`<title>Hello</title>`. However, since people were using XHTML-like tags along\nthe lines of `<link />`, browser vendors implemented the XHTML syntax over the\nsyntax defined by the specification.\n\nIn 2007, the specification was adopted as the basis of a new HTML\nspecification under the umbrella of the W3C, known as HTML5. Currently, it\nappears that XHTML is losing traction, as the XHTML 2 working group has been\ndisbanded and HTML5 is being implemented by all major browser vendors.\n\nThe following table gives you a quick overview of features available in HTML\n4.01, XHTML 1.1 and HTML5. (XHTML 1.0 is not included, as it was superseded by\nXHTML 1.1 and the barely-used XHTML5.)\n\nHTML4.01\n\nXHTML1.1\n\nHTML5\n\n`<tag/value/` == `<tag>value</tag>`\n\n1\n\n`<br/>` supported\n\n2\n\n`<script/>` supported\n\nshould be served as `text/html`\n\n3\n\nshould be served as `application/xhtml+xml`\n\nstrict error handling\n\ninline SVG\n\ninline MathML\n\n`<video>` tag\n\n`<audio>` tag\n\nNew semantic tags like `<article>`\n\nThis is an obscure feature inherited from SGML. It is usually not supported by\nbrowsers, for reasons detailed above.\n\nThis is for compatibility with server code that generates XHTML for tags such\nas `<br>`. It should not be used in new code.\n\nXHTML 1.0 is the last XHTML standard that allows to be served as `text/html`\nfor backwards compatibility reasons.\n\nHTML5 has strictly defined parsing rules, but it also specifies exactly how a\nbrowser should react to parsing errors - unlike XHTML, which simply states\nparsing should abort. Some people are confused by apparently invalid syntax\nthat still generates the expected results (for example, missing end tags or\nunquoted attribute values).\n\nSome of these work because of the lenient error handling most browsers use\nwhen they encounter a markup error, others are actually specified. The\nfollowing constructs are optional in HTML5 by standard, but have to be\nsupported by browsers:\n\nThis means the following page in HTML5 is perfectly valid:\n\nHTML5 adds many new features that make Web applications easier to write and to\nuse.\n\nMany other features have been added, as well. A good guide to new features in\nHTML5 is Mark Pilgrim\u2019s book, Dive Into HTML5. Not all of them are supported\nin browsers yet, however, so use caution.\n\nCurrently, the answer is HTML5. There are very few reasons to use XHTML\nconsidering the latest developments in Web browsers. To summarize the reasons\ngiven above:\n\nFor most applications, it is undoubtedly better to use HTML5 than XHTML.\n\n"}, {"name": "Installation", "path": "installation/index", "type": "User\u2019s Guide", "text": "\nWe recommend using the latest version of Python. Flask supports Python 3.6 and\nnewer.\n\nThese distributions will be installed automatically when installing Flask.\n\nThese distributions will not be installed automatically. Flask will detect and\nuse them if you install them.\n\nUse a virtual environment to manage the dependencies for your project, both in\ndevelopment and in production.\n\nWhat problem does a virtual environment solve? The more Python projects you\nhave, the more likely it is that you need to work with different versions of\nPython libraries, or even Python itself. Newer versions of libraries for one\nproject can break compatibility in another project.\n\nVirtual environments are independent groups of Python libraries, one for each\nproject. Packages installed for one project will not affect other projects or\nthe operating system\u2019s packages.\n\nPython comes bundled with the `venv` module to create virtual environments.\n\nCreate a project folder and a `venv` folder within:\n\nBefore you work on your project, activate the corresponding environment:\n\nYour shell prompt will change to show the name of the activated environment.\n\nWithin the activated environment, use the following command to install Flask:\n\nFlask is now installed. Check out the Quickstart or go to the Documentation\nOverview.\n\n"}, {"name": "JSONDecoder", "path": "api/index#flask.json.JSONDecoder", "type": "flask.json", "text": "\nThe default JSON decoder.\n\nThis does not change any behavior from the built-in `json.JSONDecoder`.\n\nAssign a subclass of this to `flask.Flask.json_decoder` or\n`flask.Blueprint.json_decoder` to override the default.\n\n"}, {"name": "JSONEncoder", "path": "api/index#flask.json.JSONEncoder", "type": "flask.json", "text": "\nThe default JSON encoder. Handles extra types compared to the built-in\n`json.JSONEncoder`.\n\nAssign a subclass of this to `flask.Flask.json_encoder` or\n`flask.Blueprint.json_encoder` to override the default.\n\nConvert `o` to a JSON serializable type. See `json.JSONEncoder.default()`.\nPython does not support overriding how basic types like `str` or `list` are\nserialized, they are handled before this method.\n\no (Any) \u2013\n\nAny\n\n"}, {"name": "JSONEncoder.default()", "path": "api/index#flask.json.JSONEncoder.default", "type": "flask.json", "text": "\nConvert `o` to a JSON serializable type. See `json.JSONEncoder.default()`.\nPython does not support overriding how basic types like `str` or `list` are\nserialized, they are handled before this method.\n\no (Any) \u2013\n\nAny\n\n"}, {"name": "jsonify()", "path": "api/index#flask.json.jsonify", "type": "flask.json", "text": "\nSerialize data to JSON and wrap it in a `Response` with the application/json\nmimetype.\n\nUses `dumps()` to serialize the data, but `args` and `kwargs` are treated as\ndata rather than arguments to `json.dumps()`.\n\nWill return a JSON response like this:\n\nThe default output omits indents and spaces after separators. In debug mode or\nif `JSONIFY_PRETTYPRINT_REGULAR` is `True`, the output will be formatted to be\neasier to read.\n\nChanged in version 0.11: Added support for serializing top-level arrays. This\nintroduces a security risk in ancient browsers. See JSON Security.\n\nNew in version 0.2.\n\nResponse\n\n"}, {"name": "JSONIFY_MIMETYPE", "path": "config/index#JSONIFY_MIMETYPE", "type": "Configuration", "text": "\nThe mimetype of `jsonify` responses.\n\nDefault: `'application/json'`\n\n"}, {"name": "JSONIFY_PRETTYPRINT_REGULAR", "path": "config/index#JSONIFY_PRETTYPRINT_REGULAR", "type": "Configuration", "text": "\n`jsonify` responses will be output with newlines, spaces, and indentation for\neasier reading by humans. Always enabled in debug mode.\n\nDefault: `False`\n\n"}, {"name": "JSONTag", "path": "api/index#flask.json.tag.JSONTag", "type": "flask.json.tag", "text": "\nBase class for defining type tags for `TaggedJSONSerializer`.\n\nserializer (TaggedJSONSerializer) \u2013\n\nNone\n\nCheck if the given value should be tagged by this tag.\n\nvalue (Any) \u2013\n\nbool\n\nThe tag to mark the serialized object with. If `None`, this tag is only used\nas an intermediate step during tagging.\n\nConvert the value to a valid JSON type and add the tag structure around it.\n\nvalue (Any) \u2013\n\nAny\n\nConvert the Python object to an object that is a valid JSON type. The tag will\nbe added later.\n\nvalue (Any) \u2013\n\nAny\n\nConvert the JSON representation back to the correct type. The tag will already\nbe removed.\n\nvalue (Any) \u2013\n\nAny\n\n"}, {"name": "JSONTag.check()", "path": "api/index#flask.json.tag.JSONTag.check", "type": "flask.json.tag", "text": "\nCheck if the given value should be tagged by this tag.\n\nvalue (Any) \u2013\n\nbool\n\n"}, {"name": "JSONTag.key", "path": "api/index#flask.json.tag.JSONTag.key", "type": "flask.json.tag", "text": "\nThe tag to mark the serialized object with. If `None`, this tag is only used\nas an intermediate step during tagging.\n\n"}, {"name": "JSONTag.tag()", "path": "api/index#flask.json.tag.JSONTag.tag", "type": "flask.json.tag", "text": "\nConvert the value to a valid JSON type and add the tag structure around it.\n\nvalue (Any) \u2013\n\nAny\n\n"}, {"name": "JSONTag.to_json()", "path": "api/index#flask.json.tag.JSONTag.to_json", "type": "flask.json.tag", "text": "\nConvert the Python object to an object that is a valid JSON type. The tag will\nbe added later.\n\nvalue (Any) \u2013\n\nAny\n\n"}, {"name": "JSONTag.to_python()", "path": "api/index#flask.json.tag.JSONTag.to_python", "type": "flask.json.tag", "text": "\nConvert the JSON representation back to the correct type. The tag will already\nbe removed.\n\nvalue (Any) \u2013\n\nAny\n\n"}, {"name": "JSON_AS_ASCII", "path": "config/index#JSON_AS_ASCII", "type": "Configuration", "text": "\nSerialize objects to ASCII-encoded JSON. If this is disabled, the JSON\nreturned from `jsonify` will contain Unicode characters. This has security\nimplications when rendering the JSON into JavaScript in templates, and should\ntypically remain enabled.\n\nDefault: `True`\n\n"}, {"name": "JSON_SORT_KEYS", "path": "config/index#JSON_SORT_KEYS", "type": "Configuration", "text": "\nSort the keys of JSON objects alphabetically. This is useful for caching\nbecause it ensures the data is serialized the same way no matter what Python\u2019s\nhash seed is. While not recommended, you can disable this for a possible\nperformance improvement at the cost of caching.\n\nDefault: `True`\n\n"}, {"name": "Large Applications as Packages", "path": "patterns/packages/index", "type": "User's Guide: Design Patterns", "text": "\nImagine a simple flask application structure that looks like this:\n\nWhile this is fine for small applications, for larger applications it\u2019s a good\nidea to use a package instead of a module. The Tutorial is structured to use\nthe package pattern, see the example code.\n\nTo convert that into a larger one, just create a new folder `yourapplication`\ninside the existing one and move everything below it. Then rename\n`yourapplication.py` to `__init__.py`. (Make sure to delete all `.pyc` files\nfirst, otherwise things would most likely break)\n\nYou should then end up with something like that:\n\nBut how do you run your application now? The naive `python\nyourapplication/__init__.py` will not work. Let\u2019s just say that Python does\nnot want modules in packages to be the startup file. But that is not a big\nproblem, just add a new file called `setup.py` next to the inner\n`yourapplication` folder with the following contents:\n\nIn order to run the application you need to export an environment variable\nthat tells Flask where to find the application instance:\n\nIf you are outside of the project directory make sure to provide the exact\npath to your application directory. Similarly you can turn on the development\nfeatures like this:\n\nIn order to install and run the application you need to issue the following\ncommands:\n\nWhat did we gain from this? Now we can restructure the application a bit into\nmultiple modules. The only thing you have to remember is the following quick\nchecklist:\n\nHere\u2019s an example `__init__.py`:\n\nAnd this is what `views.py` would look like:\n\nYou should then end up with something like that:\n\nCircular Imports\n\nEvery Python programmer hates them, and yet we just added some: circular\nimports (That\u2019s when two modules depend on each other. In this case `views.py`\ndepends on `__init__.py`). Be advised that this is a bad idea in general but\nhere it is actually fine. The reason for this is that we are not actually\nusing the views in `__init__.py` and just ensuring the module is imported and\nwe are doing that at the bottom of the file.\n\nThere are still some problems with that approach but if you want to use\ndecorators there is no way around that. Check out the Becoming Big section for\nsome inspiration how to deal with that.\n\nIf you have larger applications it\u2019s recommended to divide them into smaller\ngroups where each group is implemented with the help of a blueprint. For a\ngentle introduction into this topic refer to the Modular Applications with\nBlueprints chapter of the documentation.\n\n"}, {"name": "Lazily Loading Views", "path": "patterns/lazyloading/index", "type": "User's Guide: Design Patterns", "text": "\nFlask is usually used with the decorators. Decorators are simple and you have\nthe URL right next to the function that is called for that specific URL.\nHowever there is a downside to this approach: it means all your code that uses\ndecorators has to be imported upfront or Flask will never actually find your\nfunction.\n\nThis can be a problem if your application has to import quick. It might have\nto do that on systems like Google\u2019s App Engine or other systems. So if you\nsuddenly notice that your application outgrows this approach you can fall back\nto a centralized URL mapping.\n\nThe system that enables having a central URL map is the `add_url_rule()`\nfunction. Instead of using decorators, you have a file that sets up the\napplication with all URLs.\n\nImagine the current application looks somewhat like this:\n\nThen, with the centralized approach you would have one file with the views\n(`views.py`) but without any decorator:\n\nAnd then a file that sets up an application which maps the functions to URLs:\n\nSo far we only split up the views and the routing, but the module is still\nloaded upfront. The trick is to actually load the view function as needed.\nThis can be accomplished with a helper class that behaves just like a function\nbut internally imports the real function on first use:\n\nWhat\u2019s important here is is that `__module__` and `__name__` are properly set.\nThis is used by Flask internally to figure out how to name the URL rules in\ncase you don\u2019t provide a name for the rule yourself.\n\nThen you can define your central place to combine the views like this:\n\nYou can further optimize this in terms of amount of keystrokes needed to write\nthis by having a function that calls into `add_url_rule()` by prefixing a\nstring with the project name and a dot, and by wrapping `view_func` in a\n`LazyView` as needed.\n\nOne thing to keep in mind is that before and after request handlers have to be\nin a file that is imported upfront to work properly on the first request. The\nsame goes for any kind of remaining decorator.\n\n"}, {"name": "load()", "path": "api/index#flask.json.load", "type": "flask.json", "text": "\nDeserialize an object from JSON read from a file object.\n\nTakes the same arguments as the built-in `json.load()`, with some defaults\nfrom application configuration.\n\nAny\n\nChanged in version 2.0: `encoding` is deprecated and will be removed in Flask\n2.1. The file must be text mode, or binary mode with UTF-8 bytes.\n\n"}, {"name": "loads()", "path": "api/index#flask.json.loads", "type": "flask.json", "text": "\nDeserialize an object from a string of JSON.\n\nTakes the same arguments as the built-in `json.loads()`, with some defaults\nfrom application configuration.\n\nAny\n\nChanged in version 2.0: `encoding` is deprecated and will be removed in Flask\n2.1. The data must be a string or UTF-8 bytes.\n\nChanged in version 1.0.3: `app` can be passed directly, rather than requiring\nan app context for configuration.\n\n"}, {"name": "load_dotenv()", "path": "api/index#flask.cli.load_dotenv", "type": "flask.cli", "text": "\nLoad \u201cdotenv\u201d files in order of precedence to set environment variables.\n\nIf an env var is already set it is not overwritten, so earlier files in the\nlist are preferred over later files.\n\nThis is a no-op if python-dotenv is not installed.\n\npath \u2013 Load the file at this location instead of searching.\n\n`True` if a file was loaded.\n\nChanged in version 2.0: When loading the env files, set the default encoding\nto UTF-8.\n\nChanged in version 1.1.0: Returns `False` when python-dotenv is not installed,\nor when the given path isn\u2019t a file.\n\nNew in version 1.0.\n\n"}, {"name": "Logging", "path": "logging/index", "type": "User\u2019s Guide", "text": "\nFlask uses standard Python `logging`. Messages about your Flask application\nare logged with `app.logger`, which takes the same name as `app.name`. This\nlogger can also be used to log your own messages.\n\nIf you don\u2019t configure logging, Python\u2019s default log level is usually\n\u2018warning\u2019. Nothing below the configured level will be visible.\n\nWhen you want to configure logging for your project, you should do it as soon\nas possible when the program starts. If `app.logger` is accessed before\nlogging is configured, it will add a default handler. If possible, configure\nlogging before creating the application object.\n\nThis example uses `dictConfig()` to create a logging configuration similar to\nFlask\u2019s default, except for all logs:\n\nIf you do not configure logging yourself, Flask will add a `StreamHandler` to\n`app.logger` automatically. During requests, it will write to the stream\nspecified by the WSGI server in `environ['wsgi.errors']` (which is usually\n`sys.stderr`). Outside a request, it will log to `sys.stderr`.\n\nIf you configured logging after accessing `app.logger`, and need to remove the\ndefault handler, you can import and remove it:\n\nWhen running the application on a remote server for production, you probably\nwon\u2019t be looking at the log messages very often. The WSGI server will probably\nsend log messages to a file, and you\u2019ll only check that file if a user tells\nyou something went wrong.\n\nTo be proactive about discovering and fixing bugs, you can configure a\n`logging.handlers.SMTPHandler` to send an email when errors and higher are\nlogged.\n\nThis requires that you have an SMTP server set up on the same server. See the\nPython docs for more information about configuring the handler.\n\nSeeing more information about the request, such as the IP address, may help\ndebugging some errors. You can subclass `logging.Formatter` to inject your own\nfields that can be used in messages. You can change the formatter for Flask\u2019s\ndefault handler, the mail handler defined above, or any other handler.\n\nOther libraries may use logging extensively, and you want to see relevant\nmessages from those logs too. The simplest way to do this is to add handlers\nto the root logger instead of only the app logger.\n\nDepending on your project, it may be more useful to configure each logger you\ncare about separately, instead of configuring only the root logger.\n\nWerkzeug logs basic request/response information to the `'werkzeug'` logger.\nIf the root logger has no handlers configured, Werkzeug adds a `StreamHandler`\nto its logger.\n\nDepending on the situation, an extension may choose to log to `app.logger` or\nits own named logger. Consult each extension\u2019s documentation for details.\n\n"}, {"name": "make_response()", "path": "api/index#flask.make_response", "type": "flask", "text": "\nSometimes it is necessary to set additional headers in a view. Because views\ndo not have to return response objects but can return a value that is\nconverted into a response object by Flask itself, it becomes tricky to add\nheaders to it. This function can be called instead of using a return and you\nwill get a response object which you can use to attach headers.\n\nIf view looked like this and you want to add a new header:\n\nYou can now do something like this:\n\nThis function accepts the very same arguments you can return from a view\nfunction. This for example creates a response with a 404 error code:\n\nThe other use case of this function is to force the return value of a view\nfunction into a response which is helpful with view decorators:\n\nInternally this function does the following things:\n\nNew in version 0.6.\n\nargs (Any) \u2013\n\nResponse\n\n"}, {"name": "Markup", "path": "api/index#flask.Markup", "type": "flask", "text": "\nA string that is ready to be safely inserted into an HTML or XML document,\neither because it was escaped or because it was marked safe.\n\nPassing an object to the constructor converts it to text and wraps it to mark\nit safe without escaping. To escape the text, use the `escape()` class method\ninstead.\n\nThis implements the `__html__()` interface that some frameworks use. Passing\nan object that implements `__html__()` will wrap the output of that method,\nmarking it safe.\n\nThis is a subclass of `str`. It has the same methods, but escapes their\narguments and returns a `Markup` instance.\n\nMarkup\n\nEscape a string. Calls `escape()` and ensures that for subclasses the correct\ntype is returned.\n\ns (Any) \u2013\n\nmarkupsafe.Markup\n\n`unescape()` the markup, remove tags, and normalize whitespace to single\nspaces.\n\nstr\n\nConvert escaped markup back into a text string. This replaces HTML entities\nwith the characters they represent.\n\nstr\n\n"}, {"name": "Markup.escape()", "path": "api/index#flask.Markup.escape", "type": "flask", "text": "\nEscape a string. Calls `escape()` and ensures that for subclasses the correct\ntype is returned.\n\ns (Any) \u2013\n\nmarkupsafe.Markup\n\n"}, {"name": "Markup.striptags()", "path": "api/index#flask.Markup.striptags", "type": "flask", "text": "\n`unescape()` the markup, remove tags, and normalize whitespace to single\nspaces.\n\nstr\n\n"}, {"name": "Markup.unescape()", "path": "api/index#flask.Markup.unescape", "type": "flask", "text": "\nConvert escaped markup back into a text string. This replaces HTML entities\nwith the characters they represent.\n\nstr\n\n"}, {"name": "MAX_CONTENT_LENGTH", "path": "config/index#MAX_CONTENT_LENGTH", "type": "Configuration", "text": "\nDon\u2019t read more than this many bytes from the incoming request data. If not\nset and the request does not specify a `CONTENT_LENGTH`, no data will be read\nfor security.\n\nDefault: `None`\n\n"}, {"name": "MAX_COOKIE_SIZE", "path": "config/index#MAX_COOKIE_SIZE", "type": "Configuration", "text": "\nWarn if cookie headers are larger than this many bytes. Defaults to `4093`.\nLarger cookies may be silently ignored by browsers. Set to `0` to disable the\nwarning.\n\n"}, {"name": "Message Flashing", "path": "patterns/flashing/index", "type": "User's Guide: Design Patterns", "text": "\nGood applications and user interfaces are all about feedback. If the user does\nnot get enough feedback they will probably end up hating the application.\nFlask provides a really simple way to give feedback to a user with the\nflashing system. The flashing system basically makes it possible to record a\nmessage at the end of a request and access it next request and only next\nrequest. This is usually combined with a layout template that does this. Note\nthat browsers and sometimes web servers enforce a limit on cookie sizes. This\nmeans that flashing messages that are too large for session cookies causes\nmessage flashing to fail silently.\n\nSo here is a full example:\n\nAnd here is the `layout.html` template which does the magic:\n\nHere is the `index.html` template which inherits from `layout.html`:\n\nAnd here is the `login.html` template which also inherits from `layout.html`:\n\nNew in version 0.3.\n\nIt is also possible to provide categories when flashing a message. The default\ncategory if nothing is provided is `'message'`. Alternative categories can be\nused to give the user better feedback. For example error messages could be\ndisplayed with a red background.\n\nTo flash a message with a different category, just use the second argument to\nthe `flash()` function:\n\nInside the template you then have to tell the `get_flashed_messages()`\nfunction to also return the categories. The loop looks slightly different in\nthat situation then:\n\nThis is just one example of how to render these flashed messages. One might\nalso use the category to add a prefix such as `<strong>Error:</strong>` to the\nmessage.\n\nNew in version 0.9.\n\nOptionally you can pass a list of categories which filters the results of\n`get_flashed_messages()`. This is useful if you wish to render each category\nin a separate block.\n\n"}, {"name": "MethodView", "path": "api/index#flask.views.MethodView", "type": "flask.views", "text": "\nA class-based view that dispatches request methods to the corresponding class\nmethods. For example, if you implement a `get` method, it will be used to\nhandle `GET` requests.\n\nSubclasses have to override this method to implement the actual view function\ncode. This method is called with all the arguments from the URL rule.\n\nUnion[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None],\nTuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]],\nUnion[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]],\nList[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]],\nTuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]],\nint], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None,\nNone]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]],\nList[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], WSGIApplication]\n\n"}, {"name": "MethodView.dispatch_request()", "path": "api/index#flask.views.MethodView.dispatch_request", "type": "flask.views", "text": "\nSubclasses have to override this method to implement the actual view function\ncode. This method is called with all the arguments from the URL rule.\n\nUnion[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None],\nTuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]],\nUnion[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]],\nList[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]],\nTuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]],\nint], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None,\nNone]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]],\nList[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], WSGIApplication]\n\n"}, {"name": "Modular Applications with Blueprints", "path": "blueprints/index", "type": "User\u2019s Guide", "text": "\nNew in version 0.7.\n\nFlask uses a concept of blueprints for making application components and\nsupporting common patterns within an application or across applications.\nBlueprints can greatly simplify how large applications work and provide a\ncentral means for Flask extensions to register operations on applications. A\n`Blueprint` object works similarly to a `Flask` application object, but it is\nnot actually an application. Rather it is a blueprint of how to construct or\nextend an application.\n\nBlueprints in Flask are intended for these cases:\n\nA blueprint in Flask is not a pluggable app because it is not actually an\napplication \u2013 it\u2019s a set of operations which can be registered on an\napplication, even multiple times. Why not have multiple application objects?\nYou can do that (see Application Dispatching), but your applications will have\nseparate configs and will be managed at the WSGI layer.\n\nBlueprints instead provide separation at the Flask level, share application\nconfig, and can change an application object as necessary with being\nregistered. The downside is that you cannot unregister a blueprint once an\napplication was created without having to destroy the whole application\nobject.\n\nThe basic concept of blueprints is that they record operations to execute when\nregistered on an application. Flask associates view functions with blueprints\nwhen dispatching requests and generating URLs from one endpoint to another.\n\nThis is what a very basic blueprint looks like. In this case we want to\nimplement a blueprint that does simple rendering of static templates:\n\nWhen you bind a function with the help of the `@simple_page.route` decorator,\nthe blueprint will record the intention of registering the function `show` on\nthe application when it\u2019s later registered. Additionally it will prefix the\nendpoint of the function with the name of the blueprint which was given to the\n`Blueprint` constructor (in this case also `simple_page`). The blueprint\u2019s\nname does not modify the URL, only the endpoint.\n\nSo how do you register that blueprint? Like this:\n\nIf you check the rules registered on the application, you will find these:\n\nThe first one is obviously from the application itself for the static files.\nThe other two are for the `show` function of the `simple_page` blueprint. As\nyou can see, they are also prefixed with the name of the blueprint and\nseparated by a dot (`.`).\n\nBlueprints however can also be mounted at different locations:\n\nAnd sure enough, these are the generated rules:\n\nOn top of that you can register blueprints multiple times though not every\nblueprint might respond properly to that. In fact it depends on how the\nblueprint is implemented if it can be mounted more than once.\n\nIt is possible to register a blueprint on another blueprint.\n\nThe child blueprint will gain the parent\u2019s name as a prefix to its name, and\nchild URLs will be prefixed with the parent\u2019s URL prefix.\n\nBlueprint-specific before request functions, etc. registered with the parent\nwill trigger for the child. If a child does not have an error handler that can\nhandle a given exception, the parent\u2019s will be tried.\n\nBlueprints can provide resources as well. Sometimes you might want to\nintroduce a blueprint only for the resources it provides.\n\nLike for regular applications, blueprints are considered to be contained in a\nfolder. While multiple blueprints can originate from the same folder, it does\nnot have to be the case and it\u2019s usually not recommended.\n\nThe folder is inferred from the second argument to `Blueprint` which is\nusually `__name__`. This argument specifies what logical Python module or\npackage corresponds to the blueprint. If it points to an actual Python package\nthat package (which is a folder on the filesystem) is the resource folder. If\nit\u2019s a module, the package the module is contained in will be the resource\nfolder. You can access the `Blueprint.root_path` property to see what the\nresource folder is:\n\nTo quickly open sources from this folder you can use the `open_resource()`\nfunction:\n\nA blueprint can expose a folder with static files by providing the path to the\nfolder on the filesystem with the `static_folder` argument. It is either an\nabsolute path or relative to the blueprint\u2019s location:\n\nBy default the rightmost part of the path is where it is exposed on the web.\nThis can be changed with the `static_url_path` argument. Because the folder is\ncalled `static` here it will be available at the `url_prefix` of the blueprint\n+ `/static`. If the blueprint has the prefix `/admin`, the static URL will be\n`/admin/static`.\n\nThe endpoint is named `blueprint_name.static`. You can generate URLs to it\nwith `url_for()` like you would with the static folder of the application:\n\nHowever, if the blueprint does not have a `url_prefix`, it is not possible to\naccess the blueprint\u2019s static folder. This is because the URL would be\n`/static` in this case, and the application\u2019s `/static` route takes\nprecedence. Unlike template folders, blueprint static folders are not searched\nif the file does not exist in the application static folder.\n\nIf you want the blueprint to expose templates you can do that by providing the\n`template_folder` parameter to the `Blueprint` constructor:\n\nFor static files, the path can be absolute or relative to the blueprint\nresource folder.\n\nThe template folder is added to the search path of templates but with a lower\npriority than the actual application\u2019s template folder. That way you can\neasily override templates that a blueprint provides in the actual application.\nThis also means that if you don\u2019t want a blueprint template to be accidentally\noverridden, make sure that no other blueprint or actual application template\nhas the same relative path. When multiple blueprints provide the same relative\ntemplate path the first blueprint registered takes precedence over the others.\n\nSo if you have a blueprint in the folder `yourapplication/admin` and you want\nto render the template `'admin/index.html'` and you have provided `templates`\nas a `template_folder` you will have to create a file like this:\n`yourapplication/admin/templates/admin/index.html`. The reason for the extra\n`admin` folder is to avoid getting our template overridden by a template named\n`index.html` in the actual application template folder.\n\nTo further reiterate this: if you have a blueprint named `admin` and you want\nto render a template called `index.html` which is specific to this blueprint,\nthe best idea is to lay out your templates like this:\n\nAnd then when you want to render the template, use `admin/index.html` as the\nname to look up the template by. If you encounter problems loading the correct\ntemplates enable the `EXPLAIN_TEMPLATE_LOADING` config variable which will\ninstruct Flask to print out the steps it goes through to locate templates on\nevery `render_template` call.\n\nIf you want to link from one page to another you can use the `url_for()`\nfunction just like you normally would do just that you prefix the URL endpoint\nwith the name of the blueprint and a dot (`.`):\n\nAdditionally if you are in a view function of a blueprint or a rendered\ntemplate and you want to link to another endpoint of the same blueprint, you\ncan use relative redirects by prefixing the endpoint with a dot only:\n\nThis will link to `admin.index` for instance in case the current request was\ndispatched to any other admin blueprint endpoint.\n\nBlueprints support the `errorhandler` decorator just like the `Flask`\napplication object, so it is easy to make Blueprint-specific custom error\npages.\n\nHere is an example for a \u201c404 Page Not Found\u201d exception:\n\nMost errorhandlers will simply work as expected; however, there is a caveat\nconcerning handlers for 404 and 405 exceptions. These errorhandlers are only\ninvoked from an appropriate `raise` statement or a call to `abort` in another\nof the blueprint\u2019s view functions; they are not invoked by, e.g., an invalid\nURL access. This is because the blueprint does not \u201cown\u201d a certain URL space,\nso the application instance has no way of knowing which blueprint error\nhandler it should run if given an invalid URL. If you would like to execute\ndifferent handling strategies for these errors based on URL prefixes, they may\nbe defined at the application level using the `request` proxy object:\n\nSee Handling Application Errors.\n\n"}, {"name": "mod_wsgi (Apache)", "path": "deploying/mod_wsgi/index", "type": "User's Guide: Deploying", "text": "\nIf you are using the Apache webserver, consider using mod_wsgi.\n\nWatch Out\n\nPlease make sure in advance that any `app.run()` calls you might have in your\napplication file are inside an `if __name__ == '__main__':` block or moved to\na separate file. Just make sure it\u2019s not called because this will always start\na local WSGI server which we do not want if we deploy that application to\nmod_wsgi.\n\nIf you don\u2019t have `mod_wsgi` installed yet you have to either install it using\na package manager or compile it yourself. The mod_wsgi installation\ninstructions cover source installations on UNIX systems.\n\nIf you are using Ubuntu/Debian you can apt-get it and activate it as follows:\n\nIf you are using a yum based distribution (Fedora, OpenSUSE, etc..) you can\ninstall it as follows:\n\nOn FreeBSD install `mod_wsgi` by compiling the `www/mod_wsgi` port or by using\npkg_add:\n\nIf you are using pkgsrc you can install `mod_wsgi` by compiling the\n`www/ap2-wsgi` package.\n\nIf you encounter segfaulting child processes after the first apache reload you\ncan safely ignore them. Just restart the server.\n\nTo run your application you need a `yourapplication.wsgi` file. This file\ncontains the code `mod_wsgi` is executing on startup to get the application\nobject. The object called `application` in that file is then used as\napplication.\n\nFor most applications the following file should be sufficient:\n\nIf a factory function is used in a `__init__.py` file, then the function\nshould be imported:\n\nIf you don\u2019t have a factory function for application creation but a singleton\ninstance you can directly import that one as `application`.\n\nStore that file somewhere that you will find it again (e.g.:\n`/var/www/yourapplication`) and make sure that `yourapplication` and all the\nlibraries that are in use are on the python load path. If you don\u2019t want to\ninstall it system wide consider using a virtual python instance. Keep in mind\nthat you will have to actually install your application into the virtualenv as\nwell. Alternatively there is the option to just patch the path in the `.wsgi`\nfile before the import:\n\nThe last thing you have to do is to create an Apache configuration file for\nyour application. In this example we are telling `mod_wsgi` to execute the\napplication under a different user for security reasons:\n\nNote: WSGIDaemonProcess isn\u2019t implemented in Windows and Apache will refuse to\nrun with the above configuration. On a Windows system, eliminate those lines:\n\nNote: There have been some changes in access control configuration for Apache\n2.4.\n\nMost notably, the syntax for directory permissions has changed from httpd 2.2\n\nto httpd 2.4 syntax\n\nFor more information consult the mod_wsgi documentation.\n\nIf your application does not run, follow this guide to troubleshoot:\n\nYou have an `app.run()` call in your application file that is not guarded by\nan `if __name__ == '__main__':` condition. Either remove that `run()` call\nfrom the file and move it into a separate `run.py` file or put it into such an\nif block.\n\nProbably caused by your application running as the wrong user. Make sure the\nfolders the application needs access to have the proper privileges set and the\napplication runs as the correct user (`user` and `group` parameter to the\n`WSGIDaemonProcess` directive)\n\nKeep in mind that mod_wsgi disallows doing anything with `sys.stdout` and\n`sys.stderr`. You can disable this protection from the config by setting the\n`WSGIRestrictStdout` to `off`:\n\nAlternatively you can also replace the standard out in the .wsgi file with a\ndifferent stream:\n\nYour application probably is a single .py file you symlinked into the site-\npackages folder. Please be aware that this does not work, instead you either\nhave to put the folder into the pythonpath the file is stored in, or convert\nyour application into a package.\n\nThe reason for this is that for non-installed packages, the module filename is\nused to locate the resources and for symlinks the wrong filename is picked up.\n\nTo help deployment tools you can activate support for automatic reloading.\nWhenever something changes the `.wsgi` file, `mod_wsgi` will reload all the\ndaemon processes for us.\n\nFor that, just add the following directive to your `Directory` section:\n\nVirtual environments have the advantage that they never install the required\ndependencies system wide so you have a better control over what is used where.\nIf you want to use a virtual environment with mod_wsgi you have to modify your\n`.wsgi` file slightly.\n\nAdd the following lines to the top of your `.wsgi` file:\n\nThis sets up the load paths according to the settings of the virtual\nenvironment. Keep in mind that the path has to be absolute.\n\n"}, {"name": "MongoDB with MongoEngine", "path": "patterns/mongoengine/index", "type": "User's Guide: Design Patterns", "text": "\nUsing a document database like MongoDB is a common alternative to relational\nSQL databases. This pattern shows how to use MongoEngine, a document mapper\nlibrary, to integrate with MongoDB.\n\nA running MongoDB server and Flask-MongoEngine are required.\n\nBasic setup can be done by defining `MONGODB_SETTINGS` on `app.config` and\ncreating a `MongoEngine` instance.\n\nTo declare a model that represents a Mongo document, create a class that\ninherits from `Document` and declare each of the fields.\n\nIf the document has nested fields, use `EmbeddedDocument` to defined the\nfields of the embedded document and `EmbeddedDocumentField` to declare it on\nthe parent document.\n\nInstantiate your document class with keyword arguments for the fields. You can\nalso assign values to the field attributes after instantiation. Then call\n`doc.save()`.\n\nUse the class `objects` attribute to make queries. A keyword argument looks\nfor an equal value on the field.\n\nQuery operators may be used by concatenating them with the field name using a\ndouble-underscore. `objects`, and queries returned by calling it, are\niterable.\n\nThere are many more ways to define and query documents with MongoEngine. For\nmore information, check out the official documentation.\n\nFlask-MongoEngine adds helpful utilities on top of MongoEngine. Check out\ntheir documentation as well.\n\n"}, {"name": "Namespace", "path": "api/index#flask.signals.Namespace", "type": "flask.signals", "text": "\nAn alias for `blinker.base.Namespace` if blinker is available, otherwise a\ndummy class that creates fake signals. This class is available for Flask\nextensions that want to provide the same fallback system as Flask itself.\n\nCreates a new signal for this namespace if blinker is available, otherwise\nreturns a fake signal that has a send method that will do nothing but will\nfail with a `RuntimeError` for all other operations, including connecting.\n\n"}, {"name": "Namespace.signal()", "path": "api/index#flask.signals.Namespace.signal", "type": "flask.signals", "text": "\nCreates a new signal for this namespace if blinker is available, otherwise\nreturns a fake signal that has a send method that will do nothing but will\nfail with a `RuntimeError` for all other operations, including connecting.\n\n"}, {"name": "NullSession", "path": "api/index#flask.sessions.NullSession", "type": "flask.sessions", "text": "\nClass used to generate nicer error messages if sessions are not available.\nWill still allow read-only access to the empty session but fail on setting.\n\ninitial (Any) \u2013\n\nNone\n\n"}, {"name": "pass_script_info()", "path": "api/index#flask.cli.pass_script_info", "type": "flask.cli", "text": "\nMarks a function so that an instance of `ScriptInfo` is passed as first\nargument to the click callback.\n\nf (click.decorators.F) \u2013\n\nclick.decorators.F\n\n"}, {"name": "Patterns for Flask", "path": "patterns/index", "type": "User's Guide: Design Patterns", "text": "\nCertain features and interactions are common enough that you will find them in\nmost web applications. For example, many applications use a relational\ndatabase and user authentication. They will open a database connection at the\nbeginning of the request and get the information for the logged in user. At\nthe end of the request, the database connection is closed.\n\nThese types of patterns may be a bit outside the scope of Flask itself, but\nFlask makes it easy to implement them. Some common patterns are collected in\nthe following pages.\n\n"}, {"name": "PERMANENT_SESSION_LIFETIME", "path": "config/index#PERMANENT_SESSION_LIFETIME", "type": "Configuration", "text": "\nIf `session.permanent` is true, the cookie\u2019s expiration will be set this\nnumber of seconds in the future. Can either be a `datetime.timedelta` or an\n`int`.\n\nFlask\u2019s default cookie implementation validates that the cryptographic\nsignature is not older than this value.\n\nDefault: `timedelta(days=31)` (`2678400` seconds)\n\n"}, {"name": "Pluggable Views", "path": "views/index", "type": "User\u2019s Guide", "text": "\nNew in version 0.7.\n\nFlask 0.7 introduces pluggable views inspired by the generic views from Django\nwhich are based on classes instead of functions. The main intention is that\nyou can replace parts of the implementations and this way have customizable\npluggable views.\n\nConsider you have a function that loads a list of objects from the database\nand renders into a template:\n\nThis is simple and flexible, but if you want to provide this view in a generic\nfashion that can be adapted to other models and templates as well you might\nwant more flexibility. This is where pluggable class-based views come into\nplace. As the first step to convert this into a class based view you would do\nthis:\n\nAs you can see what you have to do is to create a subclass of\n`flask.views.View` and implement `dispatch_request()`. Then we have to convert\nthat class into an actual view function by using the `as_view()` class method.\nThe string you pass to that function is the name of the endpoint that view\nwill then have. But this by itself is not helpful, so let\u2019s refactor the code\na bit:\n\nThis of course is not that helpful for such a small example, but it\u2019s good\nenough to explain the basic principle. When you have a class-based view the\nquestion comes up what `self` points to. The way this works is that whenever\nthe request is dispatched a new instance of the class is created and the\n`dispatch_request()` method is called with the parameters from the URL rule.\nThe class itself is instantiated with the parameters passed to the `as_view()`\nfunction. For instance you can write a class like this:\n\nAnd then you can register it like this:\n\nPluggable views are attached to the application like a regular function by\neither using `route()` or better `add_url_rule()`. That however also means\nthat you would have to provide the names of the HTTP methods the view supports\nwhen you attach this. In order to move that information to the class you can\nprovide a `methods` attribute that has this information:\n\nFor RESTful APIs it\u2019s especially helpful to execute a different function for\neach HTTP method. With the `flask.views.MethodView` you can easily do that.\nEach HTTP method maps to a function with the same name (just in lowercase):\n\nThat way you also don\u2019t have to provide the `methods` attribute. It\u2019s\nautomatically set based on the methods defined in the class.\n\nSince the view class itself is not the view function that is added to the\nrouting system it does not make much sense to decorate the class itself.\nInstead you either have to decorate the return value of `as_view()` by hand:\n\nStarting with Flask 0.8 there is also an alternative way where you can specify\na list of decorators to apply in the class declaration:\n\nDue to the implicit self from the caller\u2019s perspective you cannot use regular\nview decorators on the individual methods of the view however, keep this in\nmind.\n\nWeb APIs are often working very closely with HTTP verbs so it makes a lot of\nsense to implement such an API based on the `MethodView`. That said, you will\nnotice that the API will require different URL rules that go to the same\nmethod view most of the time. For instance consider that you are exposing a\nuser object on the web:\n\nURL\n\nMethod\n\nDescription\n\n`/users/`\n\n`GET`\n\nGives a list of all users\n\n`/users/`\n\n`POST`\n\nCreates a new user\n\n`/users/<id>`\n\n`GET`\n\nShows a single user\n\n`/users/<id>`\n\n`PUT`\n\nUpdates a single user\n\n`/users/<id>`\n\n`DELETE`\n\nDeletes a single user\n\nSo how would you go about doing that with the `MethodView`? The trick is to\ntake advantage of the fact that you can provide multiple rules to the same\nview.\n\nLet\u2019s assume for the moment the view would look like this:\n\nSo how do we hook this up with the routing system? By adding two rules and\nexplicitly mentioning the methods for each:\n\nIf you have a lot of APIs that look similar you can refactor that registration\ncode:\n\n"}, {"name": "PREFERRED_URL_SCHEME", "path": "config/index#PREFERRED_URL_SCHEME", "type": "Configuration", "text": "\nUse this scheme for generating external URLs when not in a request context.\n\nDefault: `'http'`\n\n"}, {"name": "PRESERVE_CONTEXT_ON_EXCEPTION", "path": "config/index#PRESERVE_CONTEXT_ON_EXCEPTION", "type": "Configuration", "text": "\nDon\u2019t pop the request context when an exception occurs. If not set, this is\ntrue if `DEBUG` is true. This allows debuggers to introspect the request data\non errors, and should normally not need to be set directly.\n\nDefault: `None`\n\n"}, {"name": "PROPAGATE_EXCEPTIONS", "path": "config/index#PROPAGATE_EXCEPTIONS", "type": "Configuration", "text": "\nExceptions are re-raised rather than being handled by the app\u2019s error\nhandlers. If not set, this is implicitly true if `TESTING` or `DEBUG` is\nenabled.\n\nDefault: `None`\n\n"}, {"name": "Quickstart", "path": "quickstart/index", "type": "User\u2019s Guide", "text": "\nEager to get started? This page gives a good introduction to Flask. Follow\nInstallation to set up a project and install Flask first.\n\nA minimal Flask application looks something like this:\n\nSo what did that code do?\n\nSave it as `hello.py` or something similar. Make sure to not call your\napplication `flask.py` because this would conflict with Flask itself.\n\nTo run the application, use the flask command or python -m flask. Before you\ncan do that you need to tell your terminal the application to work with by\nexporting the `FLASK_APP` environment variable:\n\nApplication Discovery Behavior\n\nAs a shortcut, if the file is named `app.py` or `wsgi.py`, you don\u2019t have to\nset the `FLASK_APP` environment variable. See Command Line Interface for more\ndetails.\n\nThis launches a very simple builtin server, which is good enough for testing\nbut probably not what you want to use in production. For deployment options\nsee Deployment Options.\n\nNow head over to http://127.0.0.1:5000/, and you should see your hello world\ngreeting.\n\nExternally Visible Server\n\nIf you run the server you will notice that the server is only accessible from\nyour own computer, not from any other in the network. This is the default\nbecause in debugging mode a user of the application can execute arbitrary\nPython code on your computer.\n\nIf you have the debugger disabled or trust the users on your network, you can\nmake the server publicly available simply by adding `--host=0.0.0.0` to the\ncommand line:\n\nThis tells your operating system to listen on all public IPs.\n\nIn case the python -m flask fails or flask does not exist, there are multiple\nreasons this might be the case. First of all you need to look at the error\nmessage.\n\nVersions of Flask older than 0.11 used to have different ways to start the\napplication. In short, the flask command did not exist, and neither did python\n-m flask. In that case you have two options: either upgrade to newer Flask\nversions or have a look at Development Server to see the alternative method\nfor running a server.\n\nThe `FLASK_APP` environment variable is the name of the module to import at\nflask run. In case that module is incorrectly named you will get an import\nerror upon start (or if debug is enabled when you navigate to the\napplication). It will tell you what it tried to import and why it failed.\n\nThe most common reason is a typo or because you did not actually create an\n`app` object.\n\nThe `flask run` command can do more than just start the development server. By\nenabling debug mode, the server will automatically reload if code changes, and\nwill show an interactive debugger in the browser if an error occurs during a\nrequest.\n\nWarning\n\nThe debugger allows executing arbitrary Python code from the browser. It is\nprotected by a pin, but still represents a major security risk. Do not run the\ndevelopment server or debugger in a production environment.\n\nTo enable all development features, set the `FLASK_ENV` environment variable\nto `development` before calling `flask run`.\n\nSee also:\n\nWhen returning HTML (the default response type in Flask), any user-provided\nvalues rendered in the output must be escaped to protect from injection\nattacks. HTML templates rendered with Jinja, introduced later, will do this\nautomatically.\n\n`escape()`, shown here, can be used manually. It is omitted in most examples\nfor brevity, but you should always be aware of how you\u2019re using untrusted\ndata.\n\nIf a user managed to submit the name `<script>alert(\"bad\")</script>`, escaping\ncauses it to be rendered as text, rather than running the script in the user\u2019s\nbrowser.\n\n`<name>` in the route captures a value from the URL and passes it to the view\nfunction. These variable rules are explained below.\n\nModern web applications use meaningful URLs to help users. Users are more\nlikely to like a page and come back if the page uses a meaningful URL they can\nremember and use to directly visit a page.\n\nUse the `route()` decorator to bind a function to a URL.\n\nYou can do more! You can make parts of the URL dynamic and attach multiple\nrules to a function.\n\nYou can add variable sections to a URL by marking sections with\n`<variable_name>`. Your function then receives the `<variable_name>` as a\nkeyword argument. Optionally, you can use a converter to specify the type of\nthe argument like `<converter:variable_name>`.\n\nConverter types:\n\n`string`\n\n(default) accepts any text without a slash\n\n`int`\n\naccepts positive integers\n\n`float`\n\naccepts positive floating point values\n\n`path`\n\nlike `string` but also accepts slashes\n\n`uuid`\n\naccepts UUID strings\n\nThe following two rules differ in their use of a trailing slash.\n\nThe canonical URL for the `projects` endpoint has a trailing slash. It\u2019s\nsimilar to a folder in a file system. If you access the URL without a trailing\nslash (`/projects`), Flask redirects you to the canonical URL with the\ntrailing slash (`/projects/`).\n\nThe canonical URL for the `about` endpoint does not have a trailing slash.\nIt\u2019s similar to the pathname of a file. Accessing the URL with a trailing\nslash (`/about/`) produces a 404 \u201cNot Found\u201d error. This helps keep URLs\nunique for these resources, which helps search engines avoid indexing the same\npage twice.\n\nTo build a URL to a specific function, use the `url_for()` function. It\naccepts the name of the function as its first argument and any number of\nkeyword arguments, each corresponding to a variable part of the URL rule.\nUnknown variable parts are appended to the URL as query parameters.\n\nWhy would you want to build URLs using the URL reversing function `url_for()`\ninstead of hard-coding them into your templates?\n\nFor example, here we use the `test_request_context()` method to try out\n`url_for()`. `test_request_context()` tells Flask to behave as though it\u2019s\nhandling a request even while we use a Python shell. See Context Locals.\n\nWeb applications use different HTTP methods when accessing URLs. You should\nfamiliarize yourself with the HTTP methods as you work with Flask. By default,\na route only answers to `GET` requests. You can use the `methods` argument of\nthe `route()` decorator to handle different HTTP methods.\n\nIf `GET` is present, Flask automatically adds support for the `HEAD` method\nand handles `HEAD` requests according to the HTTP RFC. Likewise, `OPTIONS` is\nautomatically implemented for you.\n\nDynamic web applications also need static files. That\u2019s usually where the CSS\nand JavaScript files are coming from. Ideally your web server is configured to\nserve them for you, but during development Flask can do that as well. Just\ncreate a folder called `static` in your package or next to your module and it\nwill be available at `/static` on the application.\n\nTo generate URLs for static files, use the special `'static'` endpoint name:\n\nThe file has to be stored on the filesystem as `static/style.css`.\n\nGenerating HTML from within Python is not fun, and actually pretty cumbersome\nbecause you have to do the HTML escaping on your own to keep the application\nsecure. Because of that Flask configures the Jinja2 template engine for you\nautomatically.\n\nTo render a template you can use the `render_template()` method. All you have\nto do is provide the name of the template and the variables you want to pass\nto the template engine as keyword arguments. Here\u2019s a simple example of how to\nrender a template:\n\nFlask will look for templates in the `templates` folder. So if your\napplication is a module, this folder is next to that module, if it\u2019s a package\nit\u2019s actually inside your package:\n\nCase 1: a module:\n\nCase 2: a package:\n\nFor templates you can use the full power of Jinja2 templates. Head over to the\nofficial Jinja2 Template Documentation for more information.\n\nHere is an example template:\n\nInside templates you also have access to the `request`, `session` and `g` 1\nobjects as well as the `get_flashed_messages()` function.\n\nTemplates are especially useful if inheritance is used. If you want to know\nhow that works, see Template Inheritance. Basically template inheritance makes\nit possible to keep certain elements on each page (like header, navigation and\nfooter).\n\nAutomatic escaping is enabled, so if `name` contains HTML it will be escaped\nautomatically. If you can trust a variable and you know that it will be safe\nHTML (for example because it came from a module that converts wiki markup to\nHTML) you can mark it as safe by using the `Markup` class or by using the\n`|safe` filter in the template. Head over to the Jinja 2 documentation for\nmore examples.\n\nHere is a basic introduction to how the `Markup` class works:\n\nChanged in version 0.5: Autoescaping is no longer enabled for all templates.\nThe following extensions for templates trigger autoescaping: `.html`, `.htm`,\n`.xml`, `.xhtml`. Templates loaded from a string will have autoescaping\ndisabled.\n\nUnsure what that `g` object is? It\u2019s something in which you can store\ninformation for your own needs. See the documentation for `flask.g` and Using\nSQLite 3 with Flask.\n\nFor web applications it\u2019s crucial to react to the data a client sends to the\nserver. In Flask this information is provided by the global `request` object.\nIf you have some experience with Python you might be wondering how that object\ncan be global and how Flask manages to still be threadsafe. The answer is\ncontext locals:\n\nInsider Information\n\nIf you want to understand how that works and how you can implement tests with\ncontext locals, read this section, otherwise just skip it.\n\nCertain objects in Flask are global objects, but not of the usual kind. These\nobjects are actually proxies to objects that are local to a specific context.\nWhat a mouthful. But that is actually quite easy to understand.\n\nImagine the context being the handling thread. A request comes in and the web\nserver decides to spawn a new thread (or something else, the underlying object\nis capable of dealing with concurrency systems other than threads). When Flask\nstarts its internal request handling it figures out that the current thread is\nthe active context and binds the current application and the WSGI environments\nto that context (thread). It does that in an intelligent way so that one\napplication can invoke another application without breaking.\n\nSo what does this mean to you? Basically you can completely ignore that this\nis the case unless you are doing something like unit testing. You will notice\nthat code which depends on a request object will suddenly break because there\nis no request object. The solution is creating a request object yourself and\nbinding it to the context. The easiest solution for unit testing is to use the\n`test_request_context()` context manager. In combination with the `with`\nstatement it will bind a test request so that you can interact with it. Here\nis an example:\n\nThe other possibility is passing a whole WSGI environment to the\n`request_context()` method:\n\nThe request object is documented in the API section and we will not cover it\nhere in detail (see `Request`). Here is a broad overview of some of the most\ncommon operations. First of all you have to import it from the `flask` module:\n\nThe current request method is available by using the `method` attribute. To\naccess form data (data transmitted in a `POST` or `PUT` request) you can use\nthe `form` attribute. Here is a full example of the two attributes mentioned\nabove:\n\nWhat happens if the key does not exist in the `form` attribute? In that case a\nspecial `KeyError` is raised. You can catch it like a standard `KeyError` but\nif you don\u2019t do that, a HTTP 400 Bad Request error page is shown instead. So\nfor many situations you don\u2019t have to deal with that problem.\n\nTo access parameters submitted in the URL (`?key=value`) you can use the\n`args` attribute:\n\nWe recommend accessing URL parameters with `get` or by catching the `KeyError`\nbecause users might change the URL and presenting them a 400 bad request page\nin that case is not user friendly.\n\nFor a full list of methods and attributes of the request object, head over to\nthe `Request` documentation.\n\nYou can handle uploaded files with Flask easily. Just make sure not to forget\nto set the `enctype=\"multipart/form-data\"` attribute on your HTML form,\notherwise the browser will not transmit your files at all.\n\nUploaded files are stored in memory or at a temporary location on the\nfilesystem. You can access those files by looking at the `files` attribute on\nthe request object. Each uploaded file is stored in that dictionary. It\nbehaves just like a standard Python `file` object, but it also has a `save()`\nmethod that allows you to store that file on the filesystem of the server.\nHere is a simple example showing how that works:\n\nIf you want to know how the file was named on the client before it was\nuploaded to your application, you can access the `filename` attribute. However\nplease keep in mind that this value can be forged so never ever trust that\nvalue. If you want to use the filename of the client to store the file on the\nserver, pass it through the `secure_filename()` function that Werkzeug\nprovides for you:\n\nFor some better examples, see Uploading Files.\n\nTo access cookies you can use the `cookies` attribute. To set cookies you can\nuse the `set_cookie` method of response objects. The `cookies` attribute of\nrequest objects is a dictionary with all the cookies the client transmits. If\nyou want to use sessions, do not use the cookies directly but instead use the\nSessions in Flask that add some security on top of cookies for you.\n\nReading cookies:\n\nStoring cookies:\n\nNote that cookies are set on response objects. Since you normally just return\nstrings from the view functions Flask will convert them into response objects\nfor you. If you explicitly want to do that you can use the `make_response()`\nfunction and then modify it.\n\nSometimes you might want to set a cookie at a point where the response object\ndoes not exist yet. This is possible by utilizing the Deferred Request\nCallbacks pattern.\n\nFor this also see About Responses.\n\nTo redirect a user to another endpoint, use the `redirect()` function; to\nabort a request early with an error code, use the `abort()` function:\n\nThis is a rather pointless example because a user will be redirected from the\nindex to a page they cannot access (401 means access denied) but it shows how\nthat works.\n\nBy default a black and white error page is shown for each error code. If you\nwant to customize the error page, you can use the `errorhandler()` decorator:\n\nNote the `404` after the `render_template()` call. This tells Flask that the\nstatus code of that page should be 404 which means not found. By default 200\nis assumed which translates to: all went well.\n\nSee Handling Application Errors for more details.\n\nThe return value from a view function is automatically converted into a\nresponse object for you. If the return value is a string it\u2019s converted into a\nresponse object with the string as response body, a `200 OK` status code and a\ntext/html mimetype. If the return value is a dict, `jsonify()` is called to\nproduce a response. The logic that Flask applies to converting return values\ninto response objects is as follows:\n\nIf you want to get hold of the resulting response object inside the view you\ncan use the `make_response()` function.\n\nImagine you have a view like this:\n\nYou just need to wrap the return expression with `make_response()` and get the\nresponse object to modify it, then return it:\n\nA common response format when writing an API is JSON. It\u2019s easy to get started\nwriting such an API with Flask. If you return a `dict` from a view, it will be\nconverted to a JSON response.\n\nDepending on your API design, you may want to create JSON responses for types\nother than `dict`. In that case, use the `jsonify()` function, which will\nserialize any supported JSON data type. Or look into Flask community\nextensions that support more complex applications.\n\nIn addition to the request object there is also a second object called\n`session` which allows you to store information specific to a user from one\nrequest to the next. This is implemented on top of cookies for you and signs\nthe cookies cryptographically. What this means is that the user could look at\nthe contents of your cookie but not modify it, unless they know the secret key\nused for signing.\n\nIn order to use sessions you have to set a secret key. Here is how sessions\nwork:\n\nHow to generate good secret keys\n\nA secret key should be as random as possible. Your operating system has ways\nto generate pretty random data based on a cryptographic random generator. Use\nthe following command to quickly generate a value for `Flask.secret_key` (or\n`SECRET_KEY`):\n\nA note on cookie-based sessions: Flask will take the values you put into the\nsession object and serialize them into a cookie. If you are finding some\nvalues do not persist across requests, cookies are indeed enabled, and you are\nnot getting a clear error message, check the size of the cookie in your page\nresponses compared to the size supported by web browsers.\n\nBesides the default client-side based sessions, if you want to handle sessions\non the server-side instead, there are several Flask extensions that support\nthis.\n\nGood applications and user interfaces are all about feedback. If the user does\nnot get enough feedback they will probably end up hating the application.\nFlask provides a really simple way to give feedback to a user with the\nflashing system. The flashing system basically makes it possible to record a\nmessage at the end of a request and access it on the next (and only the next)\nrequest. This is usually combined with a layout template to expose the\nmessage.\n\nTo flash a message use the `flash()` method, to get hold of the messages you\ncan use `get_flashed_messages()` which is also available in the templates. See\nMessage Flashing for a full example.\n\nNew in version 0.3.\n\nSometimes you might be in a situation where you deal with data that should be\ncorrect, but actually is not. For example you may have some client-side code\nthat sends an HTTP request to the server but it\u2019s obviously malformed. This\nmight be caused by a user tampering with the data, or the client code failing.\nMost of the time it\u2019s okay to reply with `400 Bad Request` in that situation,\nbut sometimes that won\u2019t do and the code has to continue working.\n\nYou may still want to log that something fishy happened. This is where loggers\ncome in handy. As of Flask 0.3 a logger is preconfigured for you to use.\n\nHere are some example log calls:\n\nThe attached `logger` is a standard logging `Logger`, so head over to the\nofficial `logging` docs for more information.\n\nSee Handling Application Errors.\n\nTo add WSGI middleware to your Flask application, wrap the application\u2019s\n`wsgi_app` attribute. For example, to apply Werkzeug\u2019s `ProxyFix` middleware\nfor running behind Nginx:\n\nWrapping `app.wsgi_app` instead of `app` means that `app` still points at your\nFlask application, not at the middleware, so you can continue to use and\nconfigure `app` directly.\n\nExtensions are packages that help you accomplish common tasks. For example,\nFlask-SQLAlchemy provides SQLAlchemy support that makes it simple and easy to\nuse with Flask.\n\nFor more on Flask extensions, see Extensions.\n\nReady to deploy your new Flask app? See Deployment Options.\n\n"}, {"name": "redirect()", "path": "api/index#flask.redirect", "type": "flask", "text": "\nReturns a response object (a WSGI application) that, if called, redirects the\nclient to the target location. Supported codes are 301, 302, 303, 305, 307,\nand 308. 300 is not supported because it\u2019s not a real redirect and 304 because\nit\u2019s the answer for a request with a request with defined If-Modified-Since\nheaders.\n\nNew in version 0.10: The class used for the Response object can now be passed\nin.\n\nNew in version 0.6: The location can now be a unicode string that is encoded\nusing the `iri_to_uri()` function.\n\nResponse\n\n"}, {"name": "render_template()", "path": "api/index#flask.render_template", "type": "flask", "text": "\nRenders a template from the template folder with the given context.\n\nstr\n\n"}, {"name": "render_template_string()", "path": "api/index#flask.render_template_string", "type": "flask", "text": "\nRenders a template from the given template source string with the given\ncontext. Template variables will be autoescaped.\n\nstr\n\n"}, {"name": "Request", "path": "api/index#flask.Request", "type": "flask", "text": "\nThe request object used by default in Flask. Remembers the matched endpoint\nand view arguments.\n\nIt is what ends up as `request`. If you want to replace the request object\nused you can subclass this and set `request_class` to your subclass.\n\nThe request object is a `Request` subclass and provides all of the attributes\nWerkzeug defines plus a few Flask specific ones.\n\nNone\n\nList of charsets this client supports as `CharsetAccept` object.\n\nList of encodings this client accepts. Encodings in a HTTP term are\ncompression encodings such as gzip. For charsets have a look at\n`accept_charset`.\n\nList of languages this client accepts as `LanguageAccept` object.\n\nList of mimetypes this client supports as `MIMEAccept` object.\n\nSent with a preflight request to indicate which headers will be sent with the\ncross origin request. Set `access_control_allow_headers` on the response to\nindicate which headers are allowed.\n\nSent with a preflight request to indicate which method will be used for the\ncross origin request. Set `access_control_allow_methods` on the response to\nindicate which methods are allowed.\n\nIf a forwarded header exists this is a list of all ip addresses from the\nclient ip to the last proxy server.\n\nDecorate a function as responder that accepts the request as the last\nargument. This works like the `responder()` decorator but the function is\npassed the request object as the last argument and the request object will be\nclosed automatically:\n\nAs of Werkzeug 0.14 HTTP exceptions are automatically caught and converted to\nresponses instead of failing.\n\nf (Callable[[Request], WSGIApplication]) \u2013 the WSGI callable to decorate\n\na new WSGI callable\n\nWSGIApplication\n\nThe parsed URL parameters (the part in the URL after the question mark).\n\nBy default an `ImmutableMultiDict` is returned from this function. This can be\nchanged by setting `parameter_storage_class` to a different type. This might\nbe necessary if the order of the form data is important.\n\nThe `Authorization` object in parsed form.\n\nLike `url` but without the query string.\n\nThe name of the current blueprint\n\nA `RequestCacheControl` object for the incoming cache control headers.\n\nCloses associated resources of this request object. This closes all file\nhandles explicitly. You can also use the request object in a with statement\nwhich will automatically close it.\n\nNew in version 0.9.\n\nNone\n\nThe Content-Encoding entity-header field is used as a modifier to the media-\ntype. When present, its value indicates what additional content codings have\nbeen applied to the entity-body, and thus what decoding mechanisms must be\napplied in order to obtain the media-type referenced by the Content-Type\nheader field.\n\nNew in version 0.9.\n\nThe Content-Length entity-header field indicates the size of the entity-body\nin bytes or, in the case of the HEAD method, the size of the entity-body that\nwould have been sent had the request been a GET.\n\nThe Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest\nof the entity-body for the purpose of providing an end-to-end message\nintegrity check (MIC) of the entity-body. (Note: a MIC is good for detecting\naccidental modification of the entity-body in transit, but is not proof\nagainst malicious attacks.)\n\nNew in version 0.9.\n\nThe Content-Type entity-header field indicates the media type of the entity-\nbody sent to the recipient or, in the case of the HEAD method, the media type\nthat would have been sent had the request been a GET.\n\nA `dict` with the contents of all cookies transmitted with the request.\n\nContains the incoming request data as string in case it came with a mimetype\nWerkzeug does not handle.\n\nThe Date general-header field represents the date and time at which the\nmessage was originated, having the same semantics as orig-date in RFC 822.\n\nChanged in version 2.0: The datetime object is timezone-aware.\n\nalias of `werkzeug.datastructures.ImmutableMultiDict`\n\nThe endpoint that matched the request. This in combination with `view_args`\ncan be used to reconstruct the same or a modified URL. If an exception\nhappened when matching, this will be `None`.\n\nThe WSGI environment containing HTTP headers and information from the WSGI\nserver.\n\n`MultiDict` object containing all uploaded files. Each key in `files` is the\nname from the `<input type=\"file\" name=\"\">`. Each value in `files` is a\nWerkzeug `FileStorage` object.\n\nIt basically behaves like a standard file object you know from Python, with\nthe difference that it also has a `save()` function that can store the file on\nthe filesystem.\n\nNote that `files` will only contain data if the request method was POST, PUT\nor PATCH and the `<form>` that posted to the request had\n`enctype=\"multipart/form-data\"`. It will be empty otherwise.\n\nSee the `MultiDict` / `FileStorage` documentation for more details about the\nused data structure.\n\nThe form parameters. By default an `ImmutableMultiDict` is returned from this\nfunction. This can be changed by setting `parameter_storage_class` to a\ndifferent type. This might be necessary if the order of the form data is\nimportant.\n\nPlease keep in mind that file uploads will not end up here, but instead in the\n`files` attribute.\n\nChanged in version 0.9: Previous to Werkzeug 0.9 this would only contain form\ndata for POST and PUT requests.\n\nalias of `werkzeug.formparser.FormDataParser`\n\nCreate a new request object based on the values provided. If environ is given\nmissing values are filled from there. This method is useful for small scripts\nwhen you need to simulate a request from an URL. Do not use this method for\nunittesting, there is a full featured client object (`Client`) that allows to\ncreate multipart requests, support for cookies etc.\n\nThis accepts the same options as the `EnvironBuilder`.\n\nChanged in version 0.5: This method now accepts the same arguments as\n`EnvironBuilder`. Because of this the `environ` parameter is now called\n`environ_overrides`.\n\nrequest object\n\nwerkzeug.wrappers.request.Request\n\nRequested path, including the query string.\n\nThis reads the buffered incoming data from the client into one bytes object.\nBy default this is cached but that behavior can be changed by setting `cache`\nto `False`.\n\nUsually it\u2019s a bad idea to call this method without checking the content\nlength first as a client could send dozens of megabytes or more to cause\nmemory problems on the server.\n\nNote that if the form data was already parsed this method will not return\nanything as form data parsing does not cache the data like this method does.\nTo implicitly invoke form data parsing function set `parse_form_data` to\n`True`. When this is done the return value of this method will be an empty\nstring if the form parser handles the data. This generally is not necessary as\nif the whole data is cached (which is the default) the form parser will used\nthe cached data to parse the form data. Please be generally aware of checking\nthe content length first in any case before calling this method to avoid\nexhausting server memory.\n\nIf `as_text` is set to `True` the return value will be a decoded string.\n\nNew in version 0.9.\n\nUnion[bytes, str]\n\nParse `data` as JSON.\n\nIf the mimetype does not indicate JSON (application/json, see `is_json()`),\nthis returns `None`.\n\nIf parsing fails, `on_json_loading_failed()` is called and its return value is\nused as the return value.\n\nOptional[Any]\n\nThe headers received with the request.\n\nThe host name the request was made to, including the port if it\u2019s non-\nstandard. Validated with `trusted_hosts`.\n\nThe request URL scheme and host only.\n\nAn object containing all the etags in the `If-Match` header.\n\n`ETags`\n\nThe parsed `If-Modified-Since` header as a datetime object.\n\nChanged in version 2.0: The datetime object is timezone-aware.\n\nAn object containing all the etags in the `If-None-Match` header.\n\n`ETags`\n\nThe parsed `If-Range` header.\n\nChanged in version 2.0: `IfRange.date` is timezone-aware.\n\nNew in version 0.7.\n\nThe parsed `If-Unmodified-Since` header as a datetime object.\n\nChanged in version 2.0: The datetime object is timezone-aware.\n\nThe WSGI input stream.\n\nIn general it\u2019s a bad idea to use this one because you can easily read past\nthe boundary. Use the `stream` instead.\n\nCheck if the mimetype indicates JSON data, either application/json or\napplication/*+json.\n\nboolean that is `True` if the application is served by a WSGI server that\nspawns multiple processes.\n\nboolean that is `True` if the application is served by a multithreaded WSGI\nserver.\n\nboolean that is `True` if the application will be executed only once in a\nprocess lifetime. This is the case for CGI for example, but it\u2019s not\nguaranteed that the execution only happens one time.\n\n`True` if the request was made with a secure protocol (HTTPS or WSS).\n\nThe parsed JSON data if `mimetype` indicates JSON (application/json, see\n`is_json()`).\n\nCalls `get_json()` with default arguments.\n\nalias of `werkzeug.datastructures.ImmutableList`\n\nCreates the form data parser. Instantiates the `form_data_parser_class` with\nsome parameters.\n\nNew in version 0.8.\n\nwerkzeug.formparser.FormDataParser\n\nRead-only view of the `MAX_CONTENT_LENGTH` config key.\n\nThe Max-Forwards request-header field provides a mechanism with the TRACE and\nOPTIONS methods to limit the number of proxies or gateways that can forward\nthe request to the next inbound server.\n\nThe method the request was made with, such as `GET`.\n\nLike `content_type`, but without parameters (eg, without charset, type etc.)\nand always lowercase. For example if the content type is `text/HTML;\ncharset=utf-8` the mimetype would be `'text/html'`.\n\nThe mimetype parameters as dict. For example if the content type is\n`text/html; charset=utf-8` the params would be `{'charset': 'utf-8'}`.\n\nCalled if `get_json()` parsing fails and isn\u2019t silenced. If this method\nreturns a value, it is used as the return value for `get_json()`. The default\nimplementation raises `BadRequest`.\n\ne (Exception) \u2013\n\nNoReturn\n\nThe host that the request originated from. Set `access_control_allow_origin`\non the response to indicate which origins are allowed.\n\nalias of `werkzeug.datastructures.ImmutableMultiDict`\n\nThe path part of the URL after `root_path`. This is the path used for routing\nwithin the application.\n\nThe Pragma general-header field is used to include implementation-specific\ndirectives that might apply to any recipient along the request/response chain.\nAll pragma directives specify optional behavior from the viewpoint of the\nprotocol; however, some systems MAY require that behavior be consistent with\nthe directives.\n\nThe part of the URL after the \u201c?\u201d. This is the raw value, use `args` for the\nparsed values.\n\nThe parsed `Range` header.\n\nNew in version 0.7.\n\n`Range`\n\nThe Referer[sic] request-header field allows the client to specify, for the\nserver\u2019s benefit, the address (URI) of the resource from which the Request-URI\nwas obtained (the \u201creferrer\u201d, although the header field is misspelled).\n\nThe address of the client sending the request.\n\nIf the server supports user authentication, and the script is protected, this\nattribute contains the username the user has authenticated as.\n\nThe prefix that the application is mounted under, without a trailing slash.\n`path` comes after this.\n\nThe request URL scheme, host, and root path. This is the root that the\napplication is accessed from.\n\nIf matching the URL failed, this is the exception that will be raised / was\nraised as part of the request handling. This is usually a `NotFound` exception\nor something similar.\n\nThe URL scheme of the protocol the request used, such as `https` or `wss`.\n\nAlias for `self.root_path`. `environ[\"SCRIPT_ROOT\"]` without a trailing slash.\n\nThe address of the server. `(host, port)`, `(path, None)` for unix sockets, or\n`None` if not known.\n\nSet when creating the request object. If `True`, reading from the request body\nwill cause a `RuntimeException`. Useful to prevent modifying the stream from\nmiddleware.\n\nIf the incoming form data was not encoded with a known mimetype the data is\nstored unmodified in this stream for consumption. Most of the time it is a\nbetter idea to use `data` which will give you that data as a string. The\nstream only returns the data once.\n\nUnlike `input_stream` this stream is properly guarded that you can\u2019t\naccidentally read past the length of the input. Werkzeug will internally\nalways refer to this stream to read data which makes it possible to wrap this\nobject with a stream that does filtering.\n\nChanged in version 0.9: This stream is now always available but might be\nconsumed by the form parser later on. Previously the stream was only set if no\nparsing happened.\n\nThe full request URL with the scheme, host, root path, path, and query string.\n\nThe charset that is assumed for URLs. Defaults to the value of `charset`.\n\nNew in version 0.6.\n\nAlias for `root_url`. The URL with scheme, host, and root path. For example,\n`https://example.com/app/`.\n\nThe internal URL rule that matched the request. This can be useful to inspect\nwhich methods are allowed for the URL from a before/after handler\n(`request.url_rule.methods`) etc. Though if the request\u2019s method was invalid\nfor the URL rule, the valid list is available in\n`routing_exception.valid_methods` instead (an attribute of the Werkzeug\nexception `MethodNotAllowed`) because the request was never internally bound.\n\nNew in version 0.6.\n\nThe user agent. Use `user_agent.string` to get the header value. Set\n`user_agent_class` to a subclass of `UserAgent` to provide parsing for the\nother properties or other extended data.\n\nChanged in version 2.0: The built in parser is deprecated and will be removed\nin Werkzeug 2.1. A `UserAgent` subclass must be set to parse data from the\nstring.\n\nalias of `werkzeug.useragents._UserAgent`\n\nA `werkzeug.datastructures.CombinedMultiDict` that combines `args` and `form`.\n\nFor GET requests, only `args` are present, not `form`.\n\nChanged in version 2.0: For GET requests, only `args` are present, not `form`.\n\nA dict of view arguments that matched the request. If an exception happened\nwhen matching, this will be `None`.\n\n`True` if the request method carries content. By default this is true if a\n`Content-Type` is sent.\n\nNew in version 0.8.\n\n"}, {"name": "Request Content Checksums", "path": "patterns/requestchecksum/index", "type": "User's Guide: Design Patterns", "text": "\nVarious pieces of code can consume the request data and preprocess it. For\ninstance JSON data ends up on the request object already read and processed,\nform data ends up there as well but goes through a different code path. This\nseems inconvenient when you want to calculate the checksum of the incoming\nrequest data. This is necessary sometimes for some APIs.\n\nFortunately this is however very simple to change by wrapping the input\nstream.\n\nThe following example calculates the SHA1 checksum of the incoming data as it\ngets read and stores it in the WSGI environment:\n\nTo use this, all you need to do is to hook the calculating stream in before\nthe request starts consuming data. (Eg: be careful accessing `request.form` or\nanything of that nature. `before_request_handlers` for instance should be\ncareful not to access it).\n\nExample usage:\n\n"}, {"name": "Request.access_control_request_headers", "path": "api/index#flask.Request.access_control_request_headers", "type": "flask", "text": "\nSent with a preflight request to indicate which headers will be sent with the\ncross origin request. Set `access_control_allow_headers` on the response to\nindicate which headers are allowed.\n\n"}, {"name": "Request.access_control_request_method", "path": "api/index#flask.Request.access_control_request_method", "type": "flask", "text": "\nSent with a preflight request to indicate which method will be used for the\ncross origin request. Set `access_control_allow_methods` on the response to\nindicate which methods are allowed.\n\n"}, {"name": "Request.application()", "path": "api/index#flask.Request.application", "type": "flask", "text": "\nDecorate a function as responder that accepts the request as the last\nargument. This works like the `responder()` decorator but the function is\npassed the request object as the last argument and the request object will be\nclosed automatically:\n\nAs of Werkzeug 0.14 HTTP exceptions are automatically caught and converted to\nresponses instead of failing.\n\nf (Callable[[Request], WSGIApplication]) \u2013 the WSGI callable to decorate\n\na new WSGI callable\n\nWSGIApplication\n\n"}, {"name": "Request.close()", "path": "api/index#flask.Request.close", "type": "flask", "text": "\nCloses associated resources of this request object. This closes all file\nhandles explicitly. You can also use the request object in a with statement\nwhich will automatically close it.\n\nNew in version 0.9.\n\nNone\n\n"}, {"name": "Request.content_encoding", "path": "api/index#flask.Request.content_encoding", "type": "flask", "text": "\nThe Content-Encoding entity-header field is used as a modifier to the media-\ntype. When present, its value indicates what additional content codings have\nbeen applied to the entity-body, and thus what decoding mechanisms must be\napplied in order to obtain the media-type referenced by the Content-Type\nheader field.\n\nNew in version 0.9.\n\n"}, {"name": "Request.content_md5", "path": "api/index#flask.Request.content_md5", "type": "flask", "text": "\nThe Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest\nof the entity-body for the purpose of providing an end-to-end message\nintegrity check (MIC) of the entity-body. (Note: a MIC is good for detecting\naccidental modification of the entity-body in transit, but is not proof\nagainst malicious attacks.)\n\nNew in version 0.9.\n\n"}, {"name": "Request.content_type", "path": "api/index#flask.Request.content_type", "type": "flask", "text": "\nThe Content-Type entity-header field indicates the media type of the entity-\nbody sent to the recipient or, in the case of the HEAD method, the media type\nthat would have been sent had the request been a GET.\n\n"}, {"name": "Request.date", "path": "api/index#flask.Request.date", "type": "flask", "text": "\nThe Date general-header field represents the date and time at which the\nmessage was originated, having the same semantics as orig-date in RFC 822.\n\nChanged in version 2.0: The datetime object is timezone-aware.\n\n"}, {"name": "Request.dict_storage_class", "path": "api/index#flask.Request.dict_storage_class", "type": "flask", "text": "\nalias of `werkzeug.datastructures.ImmutableMultiDict`\n\n"}, {"name": "Request.environ", "path": "api/index#flask.Request.environ", "type": "flask", "text": "\nThe WSGI environment containing HTTP headers and information from the WSGI\nserver.\n\n"}, {"name": "Request.form_data_parser_class", "path": "api/index#flask.Request.form_data_parser_class", "type": "flask", "text": "\nalias of `werkzeug.formparser.FormDataParser`\n\n"}, {"name": "Request.from_values()", "path": "api/index#flask.Request.from_values", "type": "flask", "text": "\nCreate a new request object based on the values provided. If environ is given\nmissing values are filled from there. This method is useful for small scripts\nwhen you need to simulate a request from an URL. Do not use this method for\nunittesting, there is a full featured client object (`Client`) that allows to\ncreate multipart requests, support for cookies etc.\n\nThis accepts the same options as the `EnvironBuilder`.\n\nChanged in version 0.5: This method now accepts the same arguments as\n`EnvironBuilder`. Because of this the `environ` parameter is now called\n`environ_overrides`.\n\nrequest object\n\nwerkzeug.wrappers.request.Request\n\n"}, {"name": "Request.get_data()", "path": "api/index#flask.Request.get_data", "type": "flask", "text": "\nThis reads the buffered incoming data from the client into one bytes object.\nBy default this is cached but that behavior can be changed by setting `cache`\nto `False`.\n\nUsually it\u2019s a bad idea to call this method without checking the content\nlength first as a client could send dozens of megabytes or more to cause\nmemory problems on the server.\n\nNote that if the form data was already parsed this method will not return\nanything as form data parsing does not cache the data like this method does.\nTo implicitly invoke form data parsing function set `parse_form_data` to\n`True`. When this is done the return value of this method will be an empty\nstring if the form parser handles the data. This generally is not necessary as\nif the whole data is cached (which is the default) the form parser will used\nthe cached data to parse the form data. Please be generally aware of checking\nthe content length first in any case before calling this method to avoid\nexhausting server memory.\n\nIf `as_text` is set to `True` the return value will be a decoded string.\n\nNew in version 0.9.\n\nUnion[bytes, str]\n\n"}, {"name": "Request.get_json()", "path": "api/index#flask.Request.get_json", "type": "flask", "text": "\nParse `data` as JSON.\n\nIf the mimetype does not indicate JSON (application/json, see `is_json()`),\nthis returns `None`.\n\nIf parsing fails, `on_json_loading_failed()` is called and its return value is\nused as the return value.\n\nOptional[Any]\n\n"}, {"name": "Request.headers", "path": "api/index#flask.Request.headers", "type": "flask", "text": "\nThe headers received with the request.\n\n"}, {"name": "Request.input_stream", "path": "api/index#flask.Request.input_stream", "type": "flask", "text": "\nThe WSGI input stream.\n\nIn general it\u2019s a bad idea to use this one because you can easily read past\nthe boundary. Use the `stream` instead.\n\n"}, {"name": "Request.is_multiprocess", "path": "api/index#flask.Request.is_multiprocess", "type": "flask", "text": "\nboolean that is `True` if the application is served by a WSGI server that\nspawns multiple processes.\n\n"}, {"name": "Request.is_multithread", "path": "api/index#flask.Request.is_multithread", "type": "flask", "text": "\nboolean that is `True` if the application is served by a multithreaded WSGI\nserver.\n\n"}, {"name": "Request.is_run_once", "path": "api/index#flask.Request.is_run_once", "type": "flask", "text": "\nboolean that is `True` if the application will be executed only once in a\nprocess lifetime. This is the case for CGI for example, but it\u2019s not\nguaranteed that the execution only happens one time.\n\n"}, {"name": "Request.list_storage_class", "path": "api/index#flask.Request.list_storage_class", "type": "flask", "text": "\nalias of `werkzeug.datastructures.ImmutableList`\n\n"}, {"name": "Request.make_form_data_parser()", "path": "api/index#flask.Request.make_form_data_parser", "type": "flask", "text": "\nCreates the form data parser. Instantiates the `form_data_parser_class` with\nsome parameters.\n\nNew in version 0.8.\n\nwerkzeug.formparser.FormDataParser\n\n"}, {"name": "Request.max_forwards", "path": "api/index#flask.Request.max_forwards", "type": "flask", "text": "\nThe Max-Forwards request-header field provides a mechanism with the TRACE and\nOPTIONS methods to limit the number of proxies or gateways that can forward\nthe request to the next inbound server.\n\n"}, {"name": "Request.method", "path": "api/index#flask.Request.method", "type": "flask", "text": "\nThe method the request was made with, such as `GET`.\n\n"}, {"name": "Request.on_json_loading_failed()", "path": "api/index#flask.Request.on_json_loading_failed", "type": "flask", "text": "\nCalled if `get_json()` parsing fails and isn\u2019t silenced. If this method\nreturns a value, it is used as the return value for `get_json()`. The default\nimplementation raises `BadRequest`.\n\ne (Exception) \u2013\n\nNoReturn\n\n"}, {"name": "Request.origin", "path": "api/index#flask.Request.origin", "type": "flask", "text": "\nThe host that the request originated from. Set `access_control_allow_origin`\non the response to indicate which origins are allowed.\n\n"}, {"name": "Request.parameter_storage_class", "path": "api/index#flask.Request.parameter_storage_class", "type": "flask", "text": "\nalias of `werkzeug.datastructures.ImmutableMultiDict`\n\n"}, {"name": "Request.path", "path": "api/index#flask.Request.path", "type": "flask", "text": "\nThe path part of the URL after `root_path`. This is the path used for routing\nwithin the application.\n\n"}, {"name": "Request.query_string", "path": "api/index#flask.Request.query_string", "type": "flask", "text": "\nThe part of the URL after the \u201c?\u201d. This is the raw value, use `args` for the\nparsed values.\n\n"}, {"name": "Request.referrer", "path": "api/index#flask.Request.referrer", "type": "flask", "text": "\nThe Referer[sic] request-header field allows the client to specify, for the\nserver\u2019s benefit, the address (URI) of the resource from which the Request-URI\nwas obtained (the \u201creferrer\u201d, although the header field is misspelled).\n\n"}, {"name": "Request.remote_addr", "path": "api/index#flask.Request.remote_addr", "type": "flask", "text": "\nThe address of the client sending the request.\n\n"}, {"name": "Request.remote_user", "path": "api/index#flask.Request.remote_user", "type": "flask", "text": "\nIf the server supports user authentication, and the script is protected, this\nattribute contains the username the user has authenticated as.\n\n"}, {"name": "Request.root_path", "path": "api/index#flask.Request.root_path", "type": "flask", "text": "\nThe prefix that the application is mounted under, without a trailing slash.\n`path` comes after this.\n\n"}, {"name": "Request.routing_exception", "path": "api/index#flask.Request.routing_exception", "type": "flask", "text": "\nIf matching the URL failed, this is the exception that will be raised / was\nraised as part of the request handling. This is usually a `NotFound` exception\nor something similar.\n\n"}, {"name": "Request.scheme", "path": "api/index#flask.Request.scheme", "type": "flask", "text": "\nThe URL scheme of the protocol the request used, such as `https` or `wss`.\n\n"}, {"name": "Request.server", "path": "api/index#flask.Request.server", "type": "flask", "text": "\nThe address of the server. `(host, port)`, `(path, None)` for unix sockets, or\n`None` if not known.\n\n"}, {"name": "Request.shallow", "path": "api/index#flask.Request.shallow", "type": "flask", "text": "\nSet when creating the request object. If `True`, reading from the request body\nwill cause a `RuntimeException`. Useful to prevent modifying the stream from\nmiddleware.\n\n"}, {"name": "Request.url_rule", "path": "api/index#flask.Request.url_rule", "type": "flask", "text": "\nThe internal URL rule that matched the request. This can be useful to inspect\nwhich methods are allowed for the URL from a before/after handler\n(`request.url_rule.methods`) etc. Though if the request\u2019s method was invalid\nfor the URL rule, the valid list is available in\n`routing_exception.valid_methods` instead (an attribute of the Werkzeug\nexception `MethodNotAllowed`) because the request was never internally bound.\n\nNew in version 0.6.\n\n"}, {"name": "Request.user_agent_class", "path": "api/index#flask.Request.user_agent_class", "type": "flask", "text": "\nalias of `werkzeug.useragents._UserAgent`\n\n"}, {"name": "Request.view_args", "path": "api/index#flask.Request.view_args", "type": "flask", "text": "\nA dict of view arguments that matched the request. If an exception happened\nwhen matching, this will be `None`.\n\n"}, {"name": "RequestContext", "path": "api/index#flask.ctx.RequestContext", "type": "flask.ctx", "text": "\nThe request context contains all request relevant information. It is created\nat the beginning of the request and pushed to the `_request_ctx_stack` and\nremoved at the end of it. It will create the URL adapter and request object\nfor the WSGI environment provided.\n\nDo not attempt to use this class directly, instead use\n`test_request_context()` and `request_context()` to create this object.\n\nWhen the request context is popped, it will evaluate all the functions\nregistered on the application for teardown execution (`teardown_request()`).\n\nThe request context is automatically popped at the end of the request for you.\nIn debug mode the request context is kept around if exceptions happen so that\ninteractive debuggers have a chance to introspect the data. With 0.4 this can\nalso be forced for requests that did not fail and outside of `DEBUG` mode. By\nsetting `'flask._preserve_context'` to `True` on the WSGI environment the\ncontext will not pop itself at the end of the request. This is used by the\n`test_client()` for example to implement the deferred cleanup functionality.\n\nYou might find this helpful for unittests where you need the information from\nthe context local around for a little longer. Make sure to properly `pop()`\nthe stack yourself in that situation, otherwise your unittests will leak\nmemory.\n\nNone\n\nCreates a copy of this request context with the same request object. This can\nbe used to move a request context to a different greenlet. Because the actual\nrequest object is the same this cannot be used to move a request context to a\ndifferent thread unless access to the request object is locked.\n\nChanged in version 1.1: The current session object is used instead of\nreloading the original data. This prevents `flask.session` pointing to an out-\nof-date object.\n\nNew in version 0.10.\n\nflask.ctx.RequestContext\n\nCan be overridden by a subclass to hook into the matching of the request.\n\nNone\n\nPops the request context and unbinds it by doing that. This will also trigger\nthe execution of functions registered by the `teardown_request()` decorator.\n\nChanged in version 0.9: Added the `exc` argument.\n\nexc (Optional[BaseException]) \u2013\n\nNone\n\nBinds the request context to the current context.\n\nNone\n\n"}, {"name": "RequestContext.copy()", "path": "api/index#flask.ctx.RequestContext.copy", "type": "flask.ctx", "text": "\nCreates a copy of this request context with the same request object. This can\nbe used to move a request context to a different greenlet. Because the actual\nrequest object is the same this cannot be used to move a request context to a\ndifferent thread unless access to the request object is locked.\n\nChanged in version 1.1: The current session object is used instead of\nreloading the original data. This prevents `flask.session` pointing to an out-\nof-date object.\n\nNew in version 0.10.\n\nflask.ctx.RequestContext\n\n"}, {"name": "RequestContext.match_request()", "path": "api/index#flask.ctx.RequestContext.match_request", "type": "flask.ctx", "text": "\nCan be overridden by a subclass to hook into the matching of the request.\n\nNone\n\n"}, {"name": "RequestContext.pop()", "path": "api/index#flask.ctx.RequestContext.pop", "type": "flask.ctx", "text": "\nPops the request context and unbinds it by doing that. This will also trigger\nthe execution of functions registered by the `teardown_request()` decorator.\n\nChanged in version 0.9: Added the `exc` argument.\n\nexc (Optional[BaseException]) \u2013\n\nNone\n\n"}, {"name": "RequestContext.push()", "path": "api/index#flask.ctx.RequestContext.push", "type": "flask.ctx", "text": "\nBinds the request context to the current context.\n\nNone\n\n"}, {"name": "Response", "path": "api/index#flask.Response", "type": "flask", "text": "\nThe response object that is used by default in Flask. Works like the response\nobject from Werkzeug but is set to have an HTML mimetype by default. Quite\noften you don\u2019t have to create this object yourself because `make_response()`\nwill take care of that for you.\n\nIf you want to replace the response object used you can subclass this and set\n`response_class` to your subclass.\n\nChanged in version 1.0: JSON support is added to the response, like the\nrequest. This is useful when testing to get the test client response data as\nJSON.\n\nChanged in version 1.0: Added `max_cookie_size`.\n\nNone\n\nThe `Accept-Ranges` header. Even though the name would indicate that multiple\nvalues are supported, it must be one string token only.\n\nThe values `'bytes'` and `'none'` are common.\n\nNew in version 0.7.\n\nWhether credentials can be shared by the browser to JavaScript code. As part\nof the preflight request it indicates whether credentials can be used on the\ncross origin request.\n\nWhich headers can be sent with the cross origin request.\n\nWhich methods can be used for the cross origin request.\n\nThe origin or \u2018*\u2019 for any origin that may make cross origin requests.\n\nWhich headers can be shared by the browser to JavaScript code.\n\nThe maximum age in seconds the access control settings can be cached for.\n\nAdd an etag for the current response if there is none yet.\n\nChanged in version 2.0: SHA-1 is used to generate the value. MD5 may not be\navailable in some environments.\n\nNone\n\nThe Age response-header field conveys the sender\u2019s estimate of the amount of\ntime since the response (or its revalidation) was generated at the origin\nserver.\n\nAge values are non-negative decimal integers, representing time in seconds.\n\nThe Allow entity-header field lists the set of methods supported by the\nresource identified by the Request-URI. The purpose of this field is strictly\nto inform the recipient of valid methods associated with the resource. An\nAllow header field MUST be present in a 405 (Method Not Allowed) response.\n\nThe Cache-Control general-header field is used to specify directives that MUST\nbe obeyed by all caching mechanisms along the request/response chain.\n\nReturns the content length if available or `None` otherwise.\n\nOptional[int]\n\nAdds a function to the internal list of functions that should be called as\npart of closing down the response. Since 0.7 this function also returns the\nfunction that was passed so that this can be used as a decorator.\n\nNew in version 0.6.\n\nfunc (Callable[[], Any]) \u2013\n\nCallable[[], Any]\n\nClose the wrapped response if possible. You can also use the object in a with\nstatement which will automatically close it.\n\nNew in version 0.9: Can now be used in a with statement.\n\nNone\n\nThe Content-Encoding entity-header field is used as a modifier to the media-\ntype. When present, its value indicates what additional content codings have\nbeen applied to the entity-body, and thus what decoding mechanisms must be\napplied in order to obtain the media-type referenced by the Content-Type\nheader field.\n\nThe Content-Language entity-header field describes the natural language(s) of\nthe intended audience for the enclosed entity. Note that this might not be\nequivalent to all the languages used within the entity-body.\n\nThe Content-Length entity-header field indicates the size of the entity-body,\nin decimal number of OCTETs, sent to the recipient or, in the case of the HEAD\nmethod, the size of the entity-body that would have been sent had the request\nbeen a GET.\n\nThe Content-Location entity-header field MAY be used to supply the resource\nlocation for the entity enclosed in the message when that entity is accessible\nfrom a location separate from the requested resource\u2019s URI.\n\nThe Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest\nof the entity-body for the purpose of providing an end-to-end message\nintegrity check (MIC) of the entity-body. (Note: a MIC is good for detecting\naccidental modification of the entity-body in transit, but is not proof\nagainst malicious attacks.)\n\nThe `Content-Range` header as a `ContentRange` object. Available even if the\nheader is not set.\n\nNew in version 0.7.\n\nThe Content-Security-Policy header adds an additional layer of security to\nhelp detect and mitigate certain types of attacks.\n\nThe Content-Security-Policy-Report-Only header adds a csp policy that is not\nenforced but is reported thereby helping detect certain types of attacks.\n\nThe Content-Type entity-header field indicates the media type of the entity-\nbody sent to the recipient or, in the case of the HEAD method, the media type\nthat would have been sent had the request been a GET.\n\nPrevents a document from loading any cross-origin resources that do not\nexplicitly grant the document permission. Values must be a member of the\n`werkzeug.http.COEP` enum.\n\nAllows control over sharing of browsing context group with cross-origin\ndocuments. Values must be a member of the `werkzeug.http.COOP` enum.\n\nA descriptor that calls `get_data()` and `set_data()`.\n\nThe Date general-header field represents the date and time at which the\nmessage was originated, having the same semantics as orig-date in RFC 822.\n\nChanged in version 2.0: The datetime object is timezone-aware.\n\nDelete a cookie. Fails silently if key doesn\u2019t exist.\n\nNone\n\nPass the response body directly through as the WSGI iterable. This can be used\nwhen the body is a binary file or other iterator of bytes, to skip some\nunnecessary checks. Use `send_file()` instead of setting this manually.\n\nThe Expires entity-header field gives the date/time after which the response\nis considered stale. A stale cache entry may not normally be returned by a\ncache.\n\nChanged in version 2.0: The datetime object is timezone-aware.\n\nEnforce that the WSGI response is a response object of the current type.\nWerkzeug will use the `Response` internally in many situations like the\nexceptions. If you call `get_response()` on an exception you will get back a\nregular `Response` object, even if you are using a custom subclass.\n\nThis method can enforce a given response type, and it will also convert\narbitrary WSGI callables into response objects if an environ is provided:\n\nThis is especially useful if you want to post-process responses in the main\ndispatcher and use functionality provided by your subclass.\n\nKeep in mind that this will modify response objects in place if possible!\n\na response object.\n\nResponse\n\nMake the response object ready to be pickled. Does the following:\n\nChanged in version 2.0: An `ETag` header is added, the `no_etag` parameter is\ndeprecated and will be removed in Werkzeug 2.1.\n\nChanged in version 0.6: The `Content-Length` header is set.\n\nno_etag (None) \u2013\n\nNone\n\nCreate a new response object from an application output. This works best if\nyou pass it an application that returns a generator all the time. Sometimes\napplications may use the `write()` callable returned by the `start_response`\nfunction. This tries to resolve such edge cases automatically. But if you\ndon\u2019t get the expected output you should set `buffered` to `True` which\nenforces buffering.\n\na response object.\n\nResponse\n\nReturns the application iterator for the given environ. Depending on the\nrequest method and the current status code the return value might be an empty\nresponse rather than the one from the response.\n\nIf the request method is `HEAD` or the status code is in a range where the\nHTTP specification requires an empty response, an empty iterable is returned.\n\nNew in version 0.6.\n\nenviron (WSGIEnvironment) \u2013 the WSGI environment of the request.\n\na response iterable.\n\nIterable[bytes]\n\nThe string representation of the response body. Whenever you call this\nproperty the response iterable is encoded and flattened. This can lead to\nunwanted behavior if you stream big data.\n\nThis behavior can be disabled by setting `implicit_sequence_conversion` to\n`False`.\n\nIf `as_text` is set to `True` the return value will be a decoded string.\n\nNew in version 0.9.\n\nas_text (bool) \u2013\n\nUnion[bytes, str]\n\nReturn a tuple in the form `(etag, is_weak)`. If there is no ETag the return\nvalue is `(None, None)`.\n\nUnion[Tuple[str, bool], Tuple[None, None]]\n\nParse `data` as JSON. Useful during testing.\n\nIf the mimetype does not indicate JSON (application/json, see `is_json()`),\nthis returns `None`.\n\nUnlike `Request.get_json()`, the result is not cached.\n\nOptional[Any]\n\nThis is automatically called right before the response is started and returns\nheaders modified for the given environment. It returns a copy of the headers\nfrom the response with some modifications applied if necessary.\n\nFor example the location header (if present) is joined with the root URL of\nthe environment. Also the content length is automatically set to zero here for\ncertain status codes.\n\nChanged in version 0.6: Previously that function was called `fix_headers` and\nmodified the response object in place. Also since 0.6, IRIs in location and\ncontent-location headers are handled properly.\n\nAlso starting with 0.6, Werkzeug will attempt to set the content length if it\nis able to figure it out on its own. This is the case if all the strings in\nthe response iterable are already encoded and the iterable is buffered.\n\nenviron (WSGIEnvironment) \u2013 the WSGI environment of the request.\n\nreturns a new `Headers` object.\n\nwerkzeug.datastructures.Headers\n\nReturns the final WSGI response as tuple. The first item in the tuple is the\napplication iterator, the second the status and the third the list of headers.\nThe response returned is created specially for the given environment. For\nexample if the request method in the WSGI environment is `'HEAD'` the response\nwill be empty and only the headers and status code will be present.\n\nNew in version 0.6.\n\nenviron (WSGIEnvironment) \u2013 the WSGI environment of the request.\n\nan `(app_iter, status, headers)` tuple.\n\nTuple[Iterable[bytes], str, List[Tuple[str, str]]]\n\nCheck if the mimetype indicates JSON data, either application/json or\napplication/*+json.\n\nIf the iterator is buffered, this property will be `True`. A response object\nwill consider an iterator to be buffered if the response attribute is a list\nor tuple.\n\nNew in version 0.6.\n\nIf the response is streamed (the response is not an iterable with a length\ninformation) this property is `True`. In this case streamed means that there\nis no information about the number of iterations. This is usually `True` if a\ngenerator is passed to the response object.\n\nThis is useful for checking before applying some sort of post filtering that\nshould not take place for streamed responses.\n\nIter the response encoded with the encoding of the response. If the response\nobject is invoked as WSGI application the return value of this method is used\nas application iterator unless `direct_passthrough` was activated.\n\nIterator[bytes]\n\nThe parsed JSON data if `mimetype` indicates JSON (application/json, see\n`is_json()`).\n\nCalls `get_json()` with default arguments.\n\nThe Last-Modified entity-header field indicates the date and time at which the\norigin server believes the variant was last modified.\n\nChanged in version 2.0: The datetime object is timezone-aware.\n\nThe Location response-header field is used to redirect the recipient to a\nlocation other than the Request-URI for completion of the request or\nidentification of a new resource.\n\nMake the response conditional to the request. This method works best if an\netag was defined for the response already. The `add_etag` method can be used\nto do that. If called without etag just the date header is set.\n\nThis does nothing if the request method in the request or environ is anything\nbut GET or HEAD.\n\nFor optimal performance when handling range requests, it\u2019s recommended that\nyour response data object implements `seekable`, `seek` and `tell` methods as\ndescribed by `io.IOBase`. Objects returned by `wrap_file()` automatically\nimplement those methods.\n\nIt does not remove the body of the response because that\u2019s something the\n`__call__()` function does for us automatically.\n\nReturns self so that you can do `return resp.make_conditional(req)` but\nmodifies the object in-place.\n\n`RequestedRangeNotSatisfiable` if `Range` header could not be parsed or\nsatisfied.\n\nResponse\n\nChanged in version 2.0: Range processing is skipped if length is 0 instead of\nraising a 416 Range Not Satisfiable error.\n\nConverts the response iterator in a list. By default this happens\nautomatically if required. If `implicit_sequence_conversion` is disabled, this\nmethod is not automatically called and some properties might raise exceptions.\nThis also encodes all the items.\n\nNew in version 0.6.\n\nNone\n\nRead-only view of the `MAX_COOKIE_SIZE` config key.\n\nSee `max_cookie_size` in Werkzeug\u2019s docs.\n\nThe mimetype (content type without charset etc.)\n\nThe mimetype parameters as dict. For example if the content type is\n`text/html; charset=utf-8` the params would be `{'charset': 'utf-8'}`.\n\nNew in version 0.5.\n\nThe Retry-After response-header field can be used with a 503 (Service\nUnavailable) response to indicate how long the service is expected to be\nunavailable to the requesting client.\n\nTime in seconds until expiration or date.\n\nChanged in version 2.0: The datetime object is timezone-aware.\n\nSets a cookie.\n\nA warning is raised if the size of the cookie header exceeds\n`max_cookie_size`, but the header will still be set.\n\nNone\n\nSets a new string as response. The value must be a string or bytes. If a\nstring is set it\u2019s encoded to the charset of the response (utf-8 by default).\n\nNew in version 0.9.\n\nvalue (Union[bytes, str]) \u2013\n\nNone\n\nSet the etag, and override the old one if there was one.\n\nNone\n\nThe HTTP status code as a string.\n\nThe HTTP status code as a number.\n\nThe response iterable as write-only stream.\n\nThe Vary field value indicates the set of request-header fields that fully\ndetermines, while the response is fresh, whether a cache is permitted to use\nthe response to reply to a subsequent request without revalidation.\n\nThe `WWW-Authenticate` header in a parsed form.\n\n"}, {"name": "Response.accept_ranges", "path": "api/index#flask.Response.accept_ranges", "type": "flask", "text": "\nThe `Accept-Ranges` header. Even though the name would indicate that multiple\nvalues are supported, it must be one string token only.\n\nThe values `'bytes'` and `'none'` are common.\n\nNew in version 0.7.\n\n"}, {"name": "Response.access_control_allow_headers", "path": "api/index#flask.Response.access_control_allow_headers", "type": "flask", "text": "\nWhich headers can be sent with the cross origin request.\n\n"}, {"name": "Response.access_control_allow_methods", "path": "api/index#flask.Response.access_control_allow_methods", "type": "flask", "text": "\nWhich methods can be used for the cross origin request.\n\n"}, {"name": "Response.access_control_allow_origin", "path": "api/index#flask.Response.access_control_allow_origin", "type": "flask", "text": "\nThe origin or \u2018*\u2019 for any origin that may make cross origin requests.\n\n"}, {"name": "Response.access_control_expose_headers", "path": "api/index#flask.Response.access_control_expose_headers", "type": "flask", "text": "\nWhich headers can be shared by the browser to JavaScript code.\n\n"}, {"name": "Response.access_control_max_age", "path": "api/index#flask.Response.access_control_max_age", "type": "flask", "text": "\nThe maximum age in seconds the access control settings can be cached for.\n\n"}, {"name": "Response.add_etag()", "path": "api/index#flask.Response.add_etag", "type": "flask", "text": "\nAdd an etag for the current response if there is none yet.\n\nChanged in version 2.0: SHA-1 is used to generate the value. MD5 may not be\navailable in some environments.\n\nNone\n\n"}, {"name": "Response.age", "path": "api/index#flask.Response.age", "type": "flask", "text": "\nThe Age response-header field conveys the sender\u2019s estimate of the amount of\ntime since the response (or its revalidation) was generated at the origin\nserver.\n\nAge values are non-negative decimal integers, representing time in seconds.\n\n"}, {"name": "Response.calculate_content_length()", "path": "api/index#flask.Response.calculate_content_length", "type": "flask", "text": "\nReturns the content length if available or `None` otherwise.\n\nOptional[int]\n\n"}, {"name": "Response.call_on_close()", "path": "api/index#flask.Response.call_on_close", "type": "flask", "text": "\nAdds a function to the internal list of functions that should be called as\npart of closing down the response. Since 0.7 this function also returns the\nfunction that was passed so that this can be used as a decorator.\n\nNew in version 0.6.\n\nfunc (Callable[[], Any]) \u2013\n\nCallable[[], Any]\n\n"}, {"name": "Response.close()", "path": "api/index#flask.Response.close", "type": "flask", "text": "\nClose the wrapped response if possible. You can also use the object in a with\nstatement which will automatically close it.\n\nNew in version 0.9: Can now be used in a with statement.\n\nNone\n\n"}, {"name": "Response.content_encoding", "path": "api/index#flask.Response.content_encoding", "type": "flask", "text": "\nThe Content-Encoding entity-header field is used as a modifier to the media-\ntype. When present, its value indicates what additional content codings have\nbeen applied to the entity-body, and thus what decoding mechanisms must be\napplied in order to obtain the media-type referenced by the Content-Type\nheader field.\n\n"}, {"name": "Response.content_length", "path": "api/index#flask.Response.content_length", "type": "flask", "text": "\nThe Content-Length entity-header field indicates the size of the entity-body,\nin decimal number of OCTETs, sent to the recipient or, in the case of the HEAD\nmethod, the size of the entity-body that would have been sent had the request\nbeen a GET.\n\n"}, {"name": "Response.content_location", "path": "api/index#flask.Response.content_location", "type": "flask", "text": "\nThe Content-Location entity-header field MAY be used to supply the resource\nlocation for the entity enclosed in the message when that entity is accessible\nfrom a location separate from the requested resource\u2019s URI.\n\n"}, {"name": "Response.content_md5", "path": "api/index#flask.Response.content_md5", "type": "flask", "text": "\nThe Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest\nof the entity-body for the purpose of providing an end-to-end message\nintegrity check (MIC) of the entity-body. (Note: a MIC is good for detecting\naccidental modification of the entity-body in transit, but is not proof\nagainst malicious attacks.)\n\n"}, {"name": "Response.content_security_policy", "path": "api/index#flask.Response.content_security_policy", "type": "flask", "text": "\nThe Content-Security-Policy header adds an additional layer of security to\nhelp detect and mitigate certain types of attacks.\n\n"}, {"name": "Response.content_security_policy_report_only", "path": "api/index#flask.Response.content_security_policy_report_only", "type": "flask", "text": "\nThe Content-Security-Policy-Report-Only header adds a csp policy that is not\nenforced but is reported thereby helping detect certain types of attacks.\n\n"}, {"name": "Response.content_type", "path": "api/index#flask.Response.content_type", "type": "flask", "text": "\nThe Content-Type entity-header field indicates the media type of the entity-\nbody sent to the recipient or, in the case of the HEAD method, the media type\nthat would have been sent had the request been a GET.\n\n"}, {"name": "Response.cross_origin_embedder_policy", "path": "api/index#flask.Response.cross_origin_embedder_policy", "type": "flask", "text": "\nPrevents a document from loading any cross-origin resources that do not\nexplicitly grant the document permission. Values must be a member of the\n`werkzeug.http.COEP` enum.\n\n"}, {"name": "Response.cross_origin_opener_policy", "path": "api/index#flask.Response.cross_origin_opener_policy", "type": "flask", "text": "\nAllows control over sharing of browsing context group with cross-origin\ndocuments. Values must be a member of the `werkzeug.http.COOP` enum.\n\n"}, {"name": "Response.date", "path": "api/index#flask.Response.date", "type": "flask", "text": "\nThe Date general-header field represents the date and time at which the\nmessage was originated, having the same semantics as orig-date in RFC 822.\n\nChanged in version 2.0: The datetime object is timezone-aware.\n\n"}, {"name": "Response.delete_cookie()", "path": "api/index#flask.Response.delete_cookie", "type": "flask", "text": "\nDelete a cookie. Fails silently if key doesn\u2019t exist.\n\nNone\n\n"}, {"name": "Response.direct_passthrough", "path": "api/index#flask.Response.direct_passthrough", "type": "flask", "text": "\nPass the response body directly through as the WSGI iterable. This can be used\nwhen the body is a binary file or other iterator of bytes, to skip some\nunnecessary checks. Use `send_file()` instead of setting this manually.\n\n"}, {"name": "Response.expires", "path": "api/index#flask.Response.expires", "type": "flask", "text": "\nThe Expires entity-header field gives the date/time after which the response\nis considered stale. A stale cache entry may not normally be returned by a\ncache.\n\nChanged in version 2.0: The datetime object is timezone-aware.\n\n"}, {"name": "Response.force_type()", "path": "api/index#flask.Response.force_type", "type": "flask", "text": "\nEnforce that the WSGI response is a response object of the current type.\nWerkzeug will use the `Response` internally in many situations like the\nexceptions. If you call `get_response()` on an exception you will get back a\nregular `Response` object, even if you are using a custom subclass.\n\nThis method can enforce a given response type, and it will also convert\narbitrary WSGI callables into response objects if an environ is provided:\n\nThis is especially useful if you want to post-process responses in the main\ndispatcher and use functionality provided by your subclass.\n\nKeep in mind that this will modify response objects in place if possible!\n\na response object.\n\nResponse\n\n"}, {"name": "Response.freeze()", "path": "api/index#flask.Response.freeze", "type": "flask", "text": "\nMake the response object ready to be pickled. Does the following:\n\nChanged in version 2.0: An `ETag` header is added, the `no_etag` parameter is\ndeprecated and will be removed in Werkzeug 2.1.\n\nChanged in version 0.6: The `Content-Length` header is set.\n\nno_etag (None) \u2013\n\nNone\n\n"}, {"name": "Response.from_app()", "path": "api/index#flask.Response.from_app", "type": "flask", "text": "\nCreate a new response object from an application output. This works best if\nyou pass it an application that returns a generator all the time. Sometimes\napplications may use the `write()` callable returned by the `start_response`\nfunction. This tries to resolve such edge cases automatically. But if you\ndon\u2019t get the expected output you should set `buffered` to `True` which\nenforces buffering.\n\na response object.\n\nResponse\n\n"}, {"name": "Response.get_app_iter()", "path": "api/index#flask.Response.get_app_iter", "type": "flask", "text": "\nReturns the application iterator for the given environ. Depending on the\nrequest method and the current status code the return value might be an empty\nresponse rather than the one from the response.\n\nIf the request method is `HEAD` or the status code is in a range where the\nHTTP specification requires an empty response, an empty iterable is returned.\n\nNew in version 0.6.\n\nenviron (WSGIEnvironment) \u2013 the WSGI environment of the request.\n\na response iterable.\n\nIterable[bytes]\n\n"}, {"name": "Response.get_data()", "path": "api/index#flask.Response.get_data", "type": "flask", "text": "\nThe string representation of the response body. Whenever you call this\nproperty the response iterable is encoded and flattened. This can lead to\nunwanted behavior if you stream big data.\n\nThis behavior can be disabled by setting `implicit_sequence_conversion` to\n`False`.\n\nIf `as_text` is set to `True` the return value will be a decoded string.\n\nNew in version 0.9.\n\nas_text (bool) \u2013\n\nUnion[bytes, str]\n\n"}, {"name": "Response.get_etag()", "path": "api/index#flask.Response.get_etag", "type": "flask", "text": "\nReturn a tuple in the form `(etag, is_weak)`. If there is no ETag the return\nvalue is `(None, None)`.\n\nUnion[Tuple[str, bool], Tuple[None, None]]\n\n"}, {"name": "Response.get_json()", "path": "api/index#flask.Response.get_json", "type": "flask", "text": "\nParse `data` as JSON. Useful during testing.\n\nIf the mimetype does not indicate JSON (application/json, see `is_json()`),\nthis returns `None`.\n\nUnlike `Request.get_json()`, the result is not cached.\n\nOptional[Any]\n\n"}, {"name": "Response.get_wsgi_headers()", "path": "api/index#flask.Response.get_wsgi_headers", "type": "flask", "text": "\nThis is automatically called right before the response is started and returns\nheaders modified for the given environment. It returns a copy of the headers\nfrom the response with some modifications applied if necessary.\n\nFor example the location header (if present) is joined with the root URL of\nthe environment. Also the content length is automatically set to zero here for\ncertain status codes.\n\nChanged in version 0.6: Previously that function was called `fix_headers` and\nmodified the response object in place. Also since 0.6, IRIs in location and\ncontent-location headers are handled properly.\n\nAlso starting with 0.6, Werkzeug will attempt to set the content length if it\nis able to figure it out on its own. This is the case if all the strings in\nthe response iterable are already encoded and the iterable is buffered.\n\nenviron (WSGIEnvironment) \u2013 the WSGI environment of the request.\n\nreturns a new `Headers` object.\n\nwerkzeug.datastructures.Headers\n\n"}, {"name": "Response.get_wsgi_response()", "path": "api/index#flask.Response.get_wsgi_response", "type": "flask", "text": "\nReturns the final WSGI response as tuple. The first item in the tuple is the\napplication iterator, the second the status and the third the list of headers.\nThe response returned is created specially for the given environment. For\nexample if the request method in the WSGI environment is `'HEAD'` the response\nwill be empty and only the headers and status code will be present.\n\nNew in version 0.6.\n\nenviron (WSGIEnvironment) \u2013 the WSGI environment of the request.\n\nan `(app_iter, status, headers)` tuple.\n\nTuple[Iterable[bytes], str, List[Tuple[str, str]]]\n\n"}, {"name": "Response.iter_encoded()", "path": "api/index#flask.Response.iter_encoded", "type": "flask", "text": "\nIter the response encoded with the encoding of the response. If the response\nobject is invoked as WSGI application the return value of this method is used\nas application iterator unless `direct_passthrough` was activated.\n\nIterator[bytes]\n\n"}, {"name": "Response.last_modified", "path": "api/index#flask.Response.last_modified", "type": "flask", "text": "\nThe Last-Modified entity-header field indicates the date and time at which the\norigin server believes the variant was last modified.\n\nChanged in version 2.0: The datetime object is timezone-aware.\n\n"}, {"name": "Response.location", "path": "api/index#flask.Response.location", "type": "flask", "text": "\nThe Location response-header field is used to redirect the recipient to a\nlocation other than the Request-URI for completion of the request or\nidentification of a new resource.\n\n"}, {"name": "Response.make_conditional()", "path": "api/index#flask.Response.make_conditional", "type": "flask", "text": "\nMake the response conditional to the request. This method works best if an\netag was defined for the response already. The `add_etag` method can be used\nto do that. If called without etag just the date header is set.\n\nThis does nothing if the request method in the request or environ is anything\nbut GET or HEAD.\n\nFor optimal performance when handling range requests, it\u2019s recommended that\nyour response data object implements `seekable`, `seek` and `tell` methods as\ndescribed by `io.IOBase`. Objects returned by `wrap_file()` automatically\nimplement those methods.\n\nIt does not remove the body of the response because that\u2019s something the\n`__call__()` function does for us automatically.\n\nReturns self so that you can do `return resp.make_conditional(req)` but\nmodifies the object in-place.\n\n`RequestedRangeNotSatisfiable` if `Range` header could not be parsed or\nsatisfied.\n\nResponse\n\nChanged in version 2.0: Range processing is skipped if length is 0 instead of\nraising a 416 Range Not Satisfiable error.\n\n"}, {"name": "Response.make_sequence()", "path": "api/index#flask.Response.make_sequence", "type": "flask", "text": "\nConverts the response iterator in a list. By default this happens\nautomatically if required. If `implicit_sequence_conversion` is disabled, this\nmethod is not automatically called and some properties might raise exceptions.\nThis also encodes all the items.\n\nNew in version 0.6.\n\nNone\n\n"}, {"name": "Response.set_cookie()", "path": "api/index#flask.Response.set_cookie", "type": "flask", "text": "\nSets a cookie.\n\nA warning is raised if the size of the cookie header exceeds\n`max_cookie_size`, but the header will still be set.\n\nNone\n\n"}, {"name": "Response.set_data()", "path": "api/index#flask.Response.set_data", "type": "flask", "text": "\nSets a new string as response. The value must be a string or bytes. If a\nstring is set it\u2019s encoded to the charset of the response (utf-8 by default).\n\nNew in version 0.9.\n\nvalue (Union[bytes, str]) \u2013\n\nNone\n\n"}, {"name": "Response.set_etag()", "path": "api/index#flask.Response.set_etag", "type": "flask", "text": "\nSet the etag, and override the old one if there was one.\n\nNone\n\n"}, {"name": "safe_join()", "path": "api/index#flask.safe_join", "type": "flask", "text": "\nSafely join zero or more untrusted path components to a base directory to\navoid escaping the base directory.\n\nA safe path, otherwise `None`.\n\nstr\n\n"}, {"name": "ScriptInfo", "path": "api/index#flask.cli.ScriptInfo", "type": "flask.cli", "text": "\nHelper object to deal with Flask applications. This is usually not necessary\nto interface with as it\u2019s used internally in the dispatching to click. In\nfuture versions of Flask this object will most likely play a bigger role.\nTypically it\u2019s created automatically by the `FlaskGroup` but you can also\nmanually create it and pass it onwards as click object.\n\nOptionally the import path for the Flask application.\n\nOptionally a function that is passed the script info to create the instance of\nthe application.\n\nA dictionary with arbitrary data that can be associated with this script info.\n\nLoads the Flask app (if not yet loaded) and returns it. Calling this multiple\ntimes will just result in the already loaded app to be returned.\n\n"}, {"name": "ScriptInfo.app_import_path", "path": "api/index#flask.cli.ScriptInfo.app_import_path", "type": "flask.cli", "text": "\nOptionally the import path for the Flask application.\n\n"}, {"name": "ScriptInfo.create_app", "path": "api/index#flask.cli.ScriptInfo.create_app", "type": "flask.cli", "text": "\nOptionally a function that is passed the script info to create the instance of\nthe application.\n\n"}, {"name": "ScriptInfo.data", "path": "api/index#flask.cli.ScriptInfo.data", "type": "flask.cli", "text": "\nA dictionary with arbitrary data that can be associated with this script info.\n\n"}, {"name": "ScriptInfo.load_app()", "path": "api/index#flask.cli.ScriptInfo.load_app", "type": "flask.cli", "text": "\nLoads the Flask app (if not yet loaded) and returns it. Calling this multiple\ntimes will just result in the already loaded app to be returned.\n\n"}, {"name": "SECRET_KEY", "path": "config/index#SECRET_KEY", "type": "Configuration", "text": "\nA secret key that will be used for securely signing the session cookie and can\nbe used for any other security related needs by extensions or your\napplication. It should be a long random `bytes` or `str`. For example, copy\nthe output of this to your config:\n\nDo not reveal the secret key when posting questions or committing code.\n\nDefault: `None`\n\n"}, {"name": "SecureCookieSession", "path": "api/index#flask.sessions.SecureCookieSession", "type": "flask.sessions", "text": "\nBase class for sessions based on signed cookies.\n\nThis session backend will set the `modified` and `accessed` attributes. It\ncannot reliably track whether a session is new (vs. empty), so `new` remains\nhard coded to `False`.\n\ninitial (Any) \u2013\n\nNone\n\nheader, which allows caching proxies to cache different pages for different\nusers.\n\nReturn the value for key if key is in the dictionary, else default.\n\nAny\n\nWhen data is changed, this is set to `True`. Only the session dictionary\nitself is tracked; if the session contains mutable data (for example a nested\ndict) then this must be set to `True` manually when modifying that data. The\nsession cookie will only be written to the response if this is `True`.\n\nInsert key with a value of default if key is not in the dictionary.\n\nReturn the value for key if key is in the dictionary, else default.\n\nAny\n\n"}, {"name": "SecureCookieSession.accessed", "path": "api/index#flask.sessions.SecureCookieSession.accessed", "type": "flask.sessions", "text": "\nheader, which allows caching proxies to cache different pages for different\nusers.\n\n"}, {"name": "SecureCookieSession.get()", "path": "api/index#flask.sessions.SecureCookieSession.get", "type": "flask.sessions", "text": "\nReturn the value for key if key is in the dictionary, else default.\n\nAny\n\n"}, {"name": "SecureCookieSession.modified", "path": "api/index#flask.sessions.SecureCookieSession.modified", "type": "flask.sessions", "text": "\nWhen data is changed, this is set to `True`. Only the session dictionary\nitself is tracked; if the session contains mutable data (for example a nested\ndict) then this must be set to `True` manually when modifying that data. The\nsession cookie will only be written to the response if this is `True`.\n\n"}, {"name": "SecureCookieSession.setdefault()", "path": "api/index#flask.sessions.SecureCookieSession.setdefault", "type": "flask.sessions", "text": "\nInsert key with a value of default if key is not in the dictionary.\n\nReturn the value for key if key is in the dictionary, else default.\n\nAny\n\n"}, {"name": "SecureCookieSessionInterface", "path": "api/index#flask.sessions.SecureCookieSessionInterface", "type": "flask.sessions", "text": "\nThe default session interface that stores sessions in signed cookies through\nthe `itsdangerous` module.\n\nthe hash function to use for the signature. The default is sha1\n\nthe name of the itsdangerous supported key derivation. The default is hmac.\n\nThis method has to be implemented and must either return `None` in case the\nloading failed because of a configuration error or an instance of a session\nobject which implements a dictionary like interface + the methods and\nattributes on `SessionMixin`.\n\nOptional[flask.sessions.SecureCookieSession]\n\nthe salt that should be applied on top of the secret key for the signing of\ncookie based sessions.\n\nThis is called for actual sessions returned by `open_session()` at the end of\nthe request. This is still called during a request context so if you\nabsolutely need access to the request you can do that.\n\nNone\n\nA python serializer for the payload. The default is a compact JSON derived\nserializer with support for some extra Python types such as datetime objects\nor tuples.\n\nalias of `flask.sessions.SecureCookieSession`\n\n"}, {"name": "SecureCookieSessionInterface.digest_method()", "path": "api/index#flask.sessions.SecureCookieSessionInterface.digest_method", "type": "flask.sessions", "text": "\nthe hash function to use for the signature. The default is sha1\n\n"}, {"name": "SecureCookieSessionInterface.key_derivation", "path": "api/index#flask.sessions.SecureCookieSessionInterface.key_derivation", "type": "flask.sessions", "text": "\nthe name of the itsdangerous supported key derivation. The default is hmac.\n\n"}, {"name": "SecureCookieSessionInterface.open_session()", "path": "api/index#flask.sessions.SecureCookieSessionInterface.open_session", "type": "flask.sessions", "text": "\nThis method has to be implemented and must either return `None` in case the\nloading failed because of a configuration error or an instance of a session\nobject which implements a dictionary like interface + the methods and\nattributes on `SessionMixin`.\n\nOptional[flask.sessions.SecureCookieSession]\n\n"}, {"name": "SecureCookieSessionInterface.salt", "path": "api/index#flask.sessions.SecureCookieSessionInterface.salt", "type": "flask.sessions", "text": "\nthe salt that should be applied on top of the secret key for the signing of\ncookie based sessions.\n\n"}, {"name": "SecureCookieSessionInterface.save_session()", "path": "api/index#flask.sessions.SecureCookieSessionInterface.save_session", "type": "flask.sessions", "text": "\nThis is called for actual sessions returned by `open_session()` at the end of\nthe request. This is still called during a request context so if you\nabsolutely need access to the request you can do that.\n\nNone\n\n"}, {"name": "SecureCookieSessionInterface.serializer", "path": "api/index#flask.sessions.SecureCookieSessionInterface.serializer", "type": "flask.sessions", "text": "\nA python serializer for the payload. The default is a compact JSON derived\nserializer with support for some extra Python types such as datetime objects\nor tuples.\n\n"}, {"name": "SecureCookieSessionInterface.session_class", "path": "api/index#flask.sessions.SecureCookieSessionInterface.session_class", "type": "flask.sessions", "text": "\nalias of `flask.sessions.SecureCookieSession`\n\n"}, {"name": "Security Considerations", "path": "security/index", "type": "Additional Notes", "text": "\nWeb applications usually face all kinds of security problems and it\u2019s very\nhard to get everything right. Flask tries to solve a few of these things for\nyou, but there are a couple more you have to take care of yourself.\n\nCross site scripting is the concept of injecting arbitrary HTML (and with it\nJavaScript) into the context of a website. To remedy this, developers have to\nproperly escape text so that it cannot include arbitrary HTML tags. For more\ninformation on that have a look at the Wikipedia article on Cross-Site\nScripting.\n\nFlask configures Jinja2 to automatically escape all values unless explicitly\ntold otherwise. This should rule out all XSS problems caused in templates, but\nthere are still other places where you have to be careful:\n\nAnother thing that is very important are unquoted attributes. While Jinja2 can\nprotect you from XSS issues by escaping HTML, there is one thing it cannot\nprotect you from: XSS by attribute injection. To counter this possible attack\nvector, be sure to always quote your attributes with either double or single\nquotes when using Jinja expressions in them:\n\nWhy is this necessary? Because if you would not be doing that, an attacker\ncould easily inject custom JavaScript handlers. For example an attacker could\ninject this piece of HTML+JavaScript:\n\nWhen the user would then move with the mouse over the input, the cookie would\nbe presented to the user in an alert window. But instead of showing the cookie\nto the user, a good attacker might also execute any other JavaScript code. In\ncombination with CSS injections the attacker might even make the element fill\nout the entire page so that the user would just have to have the mouse\nanywhere on the page to trigger the attack.\n\nThere is one class of XSS issues that Jinja\u2019s escaping does not protect\nagainst. The `a` tag\u2019s `href` attribute can contain a `javascript:` URI, which\nthe browser will execute when clicked if not secured properly.\n\nTo prevent this, you\u2019ll need to set the Content Security Policy (CSP) response\nheader.\n\nAnother big problem is CSRF. This is a very complex topic and I won\u2019t outline\nit here in detail just mention what it is and how to theoretically prevent it.\n\nIf your authentication information is stored in cookies, you have implicit\nstate management. The state of \u201cbeing logged in\u201d is controlled by a cookie,\nand that cookie is sent with each request to a page. Unfortunately that\nincludes requests triggered by 3rd party sites. If you don\u2019t keep that in\nmind, some people might be able to trick your application\u2019s users with social\nengineering to do stupid things without them knowing.\n\nSay you have a specific URL that, when you sent `POST` requests to will delete\na user\u2019s profile (say `http://example.com/user/delete`). If an attacker now\ncreates a page that sends a post request to that page with some JavaScript\nthey just have to trick some users to load that page and their profiles will\nend up being deleted.\n\nImagine you were to run Facebook with millions of concurrent users and someone\nwould send out links to images of little kittens. When users would go to that\npage, their profiles would get deleted while they are looking at images of\nfluffy cats.\n\nHow can you prevent that? Basically for each request that modifies content on\nthe server you would have to either use a one-time token and store that in the\ncookie and also transmit it with the form data. After receiving the data on\nthe server again, you would then have to compare the two tokens and ensure\nthey are equal.\n\nWhy does Flask not do that for you? The ideal place for this to happen is the\nform validation framework, which does not exist in Flask.\n\nIn Flask 0.10 and lower, `jsonify()` did not serialize top-level arrays to\nJSON. This was because of a security vulnerability in ECMAScript 4.\n\nECMAScript 5 closed this vulnerability, so only extremely old browsers are\nstill vulnerable. All of these browsers have other more serious\nvulnerabilities, so this behavior was changed and `jsonify()` now supports\nserializing arrays.\n\nBrowsers recognize various response headers in order to control security. We\nrecommend reviewing each of the headers below for use in your application. The\nFlask-Talisman extension can be used to manage HTTPS and the security headers\nfor you.\n\nTells the browser to convert all HTTP requests to HTTPS, preventing man-in-\nthe-middle (MITM) attacks.\n\nTell the browser where it can load various types of resource from. This header\nshould be used whenever possible, but requires some work to define the correct\npolicy for your site. A very strict policy would be:\n\nForces the browser to honor the response content type instead of trying to\ndetect it, which can be abused to generate a cross-site scripting (XSS)\nattack.\n\nPrevents external sites from embedding your site in an `iframe`. This prevents\na class of attacks where clicks in the outer frame can be translated invisibly\nto clicks on your page\u2019s elements. This is also known as \u201cclickjacking\u201d.\n\nThe browser will try to prevent reflected XSS attacks by not loading the page\nif the request contains something that looks like JavaScript and the response\ncontains the same data.\n\nThese options can be added to a `Set-Cookie` header to improve their security.\nFlask has configuration options to set these on the session cookie. They can\nbe set on other cookies too.\n\nSpecifying `Expires` or `Max-Age` options, will remove the cookie after the\ngiven time, or the current time plus the age, respectively. If neither option\nis set, the cookie will be removed when the browser is closed.\n\nFor the session cookie, if `session.permanent` is set, then\n`PERMANENT_SESSION_LIFETIME` is used to set the expiration. Flask\u2019s default\ncookie implementation validates that the cryptographic signature is not older\nthan this value. Lowering this value may help mitigate replay attacks, where\nintercepted cookies can be sent at a later time.\n\nUse `itsdangerous.TimedSerializer` to sign and validate other cookie values\n(or any values that need secure signatures).\n\nThis tells the browser to authenticate with the server using only the specific\ncertificate key to prevent MITM attacks.\n\nWarning\n\nBe careful when enabling this, as it is very difficult to undo if you set up\nor upgrade your key incorrectly.\n\nHidden characters such as the backspace character (`\\b`, `^H`) can cause text\nto render differently in HTML than how it is interpreted if pasted into a\nterminal.\n\nFor example, `import y\\bose\\bm\\bi\\bt\\be\\b` renders as `import yosemite` in\nHTML, but the backspaces are applied when pasted into a terminal, and it\nbecomes `import os`.\n\nIf you expect users to copy and paste untrusted code from your site, such as\nfrom comments posted by users on a technical blog, consider applying extra\nfiltering, such as replacing all `\\b` characters.\n\nMost modern terminals will warn about and remove hidden characters when\npasting, so this isn\u2019t strictly necessary. It\u2019s also possible to craft\ndangerous commands in other ways that aren\u2019t possible to filter. Depending on\nyour site\u2019s use case, it may be good to show a warning about copying code in\ngeneral.\n\n"}, {"name": "send_file()", "path": "api/index#flask.send_file", "type": "flask", "text": "\nSend the contents of a file to the client.\n\nThe first argument can be a file path or a file-like object. Paths are\npreferred in most cases because Werkzeug can manage the file and get extra\ninformation from the path. Passing a file-like object requires that the file\nis opened in binary mode, and is mostly useful when building a file in memory\nwith `io.BytesIO`.\n\nNever pass file paths provided by a user. The path is assumed to be trusted,\nso a user could craft a path to access a file you didn\u2019t intend. Use\n`send_from_directory()` to safely serve user-requested paths from within a\ndirectory.\n\nIf the WSGI server sets a `file_wrapper` in `environ`, it is used, otherwise\nWerkzeug\u2019s built-in wrapper is used. Alternatively, if the HTTP server\nsupports `X-Sendfile`, configuring Flask with `USE_X_SENDFILE = True` will\ntell the server to send the given path, which is much more efficient than\nreading it in Python.\n\nChanged in version 2.0: `download_name` replaces the `attachment_filename`\nparameter. If `as_attachment=False`, it is passed with `Content-Disposition:\ninline` instead.\n\nChanged in version 2.0: `max_age` replaces the `cache_timeout` parameter.\n`conditional` is enabled and `max_age` is not set by default.\n\nChanged in version 2.0: `etag` replaces the `add_etags` parameter. It can be a\nstring to use instead of generating one.\n\nChanged in version 2.0: Passing a file-like object that inherits from\n`TextIOBase` will raise a `ValueError` rather than sending an empty file.\n\nNew in version 2.0: Moved the implementation to Werkzeug. This is now a\nwrapper to pass some Flask-specific arguments.\n\nChanged in version 1.1: `filename` may be a `PathLike` object.\n\nChanged in version 1.1: Passing a `BytesIO` object supports range requests.\n\nChanged in version 1.0.3: Filenames are encoded with ASCII instead of Latin-1\nfor broader compatibility with WSGI servers.\n\nChanged in version 1.0: UTF-8 filenames as specified in RFC 2231 are\nsupported.\n\nChanged in version 0.12: The filename is no longer automatically inferred from\nfile objects. If you want to use automatic MIME and etag support, pass a\nfilename via `filename_or_fp` or `attachment_filename`.\n\nChanged in version 0.12: `attachment_filename` is preferred over `filename`\nfor MIME detection.\n\nChanged in version 0.9: `cache_timeout` defaults to\n`Flask.get_send_file_max_age()`.\n\nChanged in version 0.7: MIME guessing and etag support for file-like objects\nwas deprecated because it was unreliable. Pass a filename if you are able to,\notherwise attach an etag yourself.\n\nChanged in version 0.5: The `add_etags`, `cache_timeout` and `conditional`\nparameters were added. The default behavior is to add etags.\n\nNew in version 0.2.\n\n"}, {"name": "SEND_FILE_MAX_AGE_DEFAULT", "path": "config/index#SEND_FILE_MAX_AGE_DEFAULT", "type": "Configuration", "text": "\nWhen serving files, set the cache control max age to this number of seconds.\nCan be a `datetime.timedelta` or an `int`. Override this value on a per-file\nbasis using `get_send_file_max_age()` on the application or blueprint.\n\nIf `None`, `send_file` tells the browser to use conditional requests will be\nused instead of a timed cache, which is usually preferable.\n\nDefault: `None`\n\n"}, {"name": "send_from_directory()", "path": "api/index#flask.send_from_directory", "type": "flask", "text": "\nSend a file from within a directory using `send_file()`.\n\nThis is a secure way to serve files from a folder, such as static files or\nuploads. Uses `safe_join()` to ensure the path coming from the client is not\nmaliciously crafted to point outside the specified directory.\n\nIf the final path does not point to an existing regular file, raises a 404\n`NotFound` error.\n\nResponse\n\nChanged in version 2.0: `path` replaces the `filename` parameter.\n\nNew in version 2.0: Moved the implementation to Werkzeug. This is now a\nwrapper to pass some Flask-specific arguments.\n\nNew in version 0.5.\n\n"}, {"name": "SERVER_NAME", "path": "config/index#SERVER_NAME", "type": "Configuration", "text": "\nInform the application what host and port it is bound to. Required for\nsubdomain route matching support.\n\nIf set, will be used for the session cookie domain if `SESSION_COOKIE_DOMAIN`\nis not set. Modern web browsers will not allow setting cookies for domains\nwithout a dot. To use a domain locally, add any names that should route to the\napp to your `hosts` file.\n\nIf set, `url_for` can generate external URLs with only an application context\ninstead of a request context.\n\nDefault: `None`\n\n"}, {"name": "session", "path": "api/index#flask.session", "type": "flask", "text": "\nThe session object works pretty much like an ordinary dict, with the\ndifference that it keeps track of modifications.\n\nThis is a proxy. See Notes On Proxies for more information.\n\nThe following attributes are interesting:\n\n`True` if the session is new, `False` otherwise.\n\n`True` if the session object detected a modification. Be advised that\nmodifications on mutable structures are not picked up automatically, in that\nsituation you have to explicitly set the attribute to `True` yourself. Here an\nexample:\n\nIf set to `True` the session lives for `permanent_session_lifetime` seconds.\nThe default is 31 days. If set to `False` (which is the default) the session\nwill be deleted when the user closes the browser.\n\n"}, {"name": "session.modified", "path": "api/index#flask.session.modified", "type": "flask", "text": "\n`True` if the session object detected a modification. Be advised that\nmodifications on mutable structures are not picked up automatically, in that\nsituation you have to explicitly set the attribute to `True` yourself. Here an\nexample:\n\n"}, {"name": "session.new", "path": "api/index#flask.session.new", "type": "flask", "text": "\n`True` if the session is new, `False` otherwise.\n\n"}, {"name": "session.permanent", "path": "api/index#flask.session.permanent", "type": "flask", "text": "\nIf set to `True` the session lives for `permanent_session_lifetime` seconds.\nThe default is 31 days. If set to `False` (which is the default) the session\nwill be deleted when the user closes the browser.\n\n"}, {"name": "SessionInterface", "path": "api/index#flask.sessions.SessionInterface", "type": "flask.sessions", "text": "\nThe basic interface you have to implement in order to replace the default\nsession interface which uses werkzeug\u2019s securecookie implementation. The only\nmethods you have to implement are `open_session()` and `save_session()`, the\nothers have useful defaults which you don\u2019t need to change.\n\nThe session object returned by the `open_session()` method has to provide a\ndictionary like interface plus the properties and methods from the\n`SessionMixin`. We recommend just subclassing a dict and adding that mixin:\n\nIf `open_session()` returns `None` Flask will call into `make_null_session()`\nto create a session that acts as replacement if the session support cannot\nwork because some requirement is not fulfilled. The default `NullSession`\nclass that is created will complain that the secret key was not set.\n\nTo replace the session interface on an application all you have to do is to\nassign `flask.Flask.session_interface`:\n\nNew in version 0.8.\n\nReturns the domain that should be set for the session cookie.\n\nUses `SESSION_COOKIE_DOMAIN` if it is configured, otherwise falls back to\ndetecting the domain based on `SERVER_NAME`.\n\nOnce detected (or if not set at all), `SESSION_COOKIE_DOMAIN` is updated to\navoid re-running the logic.\n\napp (Flask) \u2013\n\nOptional[str]\n\nReturns True if the session cookie should be httponly. This currently just\nreturns the value of the `SESSION_COOKIE_HTTPONLY` config var.\n\napp (Flask) \u2013\n\nbool\n\nReturns the name of the session cookie.\n\nUses `app.session_cookie_name` which is set to `SESSION_COOKIE_NAME`\n\napp (Flask) \u2013\n\nstr\n\nReturns the path for which the cookie should be valid. The default\nimplementation uses the value from the `SESSION_COOKIE_PATH` config var if\nit\u2019s set, and falls back to `APPLICATION_ROOT` or uses `/` if it\u2019s `None`.\n\napp (Flask) \u2013\n\nstr\n\nReturn `'Strict'` or `'Lax'` if the cookie should use the `SameSite`\nattribute. This currently just returns the value of the\n`SESSION_COOKIE_SAMESITE` setting.\n\napp (Flask) \u2013\n\nstr\n\nReturns True if the cookie should be secure. This currently just returns the\nvalue of the `SESSION_COOKIE_SECURE` setting.\n\napp (Flask) \u2013\n\nbool\n\nA helper method that returns an expiration date for the session or `None` if\nthe session is linked to the browser session. The default implementation\nreturns now + the permanent session lifetime configured on the application.\n\nOptional[datetime.datetime]\n\nChecks if a given object is a null session. Null sessions are not asked to be\nsaved.\n\nThis checks if the object is an instance of `null_session_class` by default.\n\nobj (object) \u2013\n\nbool\n\nCreates a null session which acts as a replacement object if the real session\nsupport could not be loaded due to a configuration error. This mainly aids the\nuser experience because the job of the null session is to still support lookup\nwithout complaining but modifications are answered with a helpful error\nmessage of what failed.\n\nThis creates an instance of `null_session_class` by default.\n\napp (Flask) \u2013\n\nflask.sessions.NullSession\n\n`make_null_session()` will look here for the class that should be created when\na null session is requested. Likewise the `is_null_session()` method will\nperform a typecheck against this type.\n\nalias of `flask.sessions.NullSession`\n\nThis method has to be implemented and must either return `None` in case the\nloading failed because of a configuration error or an instance of a session\nobject which implements a dictionary like interface + the methods and\nattributes on `SessionMixin`.\n\nOptional[flask.sessions.SessionMixin]\n\nA flag that indicates if the session interface is pickle based. This can be\nused by Flask extensions to make a decision in regards to how to deal with the\nsession object.\n\nNew in version 0.10.\n\nThis is called for actual sessions returned by `open_session()` at the end of\nthe request. This is still called during a request context so if you\nabsolutely need access to the request you can do that.\n\nNone\n\nUsed by session backends to determine if a `Set-Cookie` header should be set\nfor this session cookie for this response. If the session has been modified,\nthe cookie is set. If the session is permanent and the\n`SESSION_REFRESH_EACH_REQUEST` config is true, the cookie is always set.\n\nThis check is usually skipped if the session was deleted.\n\nNew in version 0.11.\n\nbool\n\n"}, {"name": "SessionInterface.get_cookie_domain()", "path": "api/index#flask.sessions.SessionInterface.get_cookie_domain", "type": "flask.sessions", "text": "\nReturns the domain that should be set for the session cookie.\n\nUses `SESSION_COOKIE_DOMAIN` if it is configured, otherwise falls back to\ndetecting the domain based on `SERVER_NAME`.\n\nOnce detected (or if not set at all), `SESSION_COOKIE_DOMAIN` is updated to\navoid re-running the logic.\n\napp (Flask) \u2013\n\nOptional[str]\n\n"}, {"name": "SessionInterface.get_cookie_httponly()", "path": "api/index#flask.sessions.SessionInterface.get_cookie_httponly", "type": "flask.sessions", "text": "\nReturns True if the session cookie should be httponly. This currently just\nreturns the value of the `SESSION_COOKIE_HTTPONLY` config var.\n\napp (Flask) \u2013\n\nbool\n\n"}, {"name": "SessionInterface.get_cookie_name()", "path": "api/index#flask.sessions.SessionInterface.get_cookie_name", "type": "flask.sessions", "text": "\nReturns the name of the session cookie.\n\nUses `app.session_cookie_name` which is set to `SESSION_COOKIE_NAME`\n\napp (Flask) \u2013\n\nstr\n\n"}, {"name": "SessionInterface.get_cookie_path()", "path": "api/index#flask.sessions.SessionInterface.get_cookie_path", "type": "flask.sessions", "text": "\nReturns the path for which the cookie should be valid. The default\nimplementation uses the value from the `SESSION_COOKIE_PATH` config var if\nit\u2019s set, and falls back to `APPLICATION_ROOT` or uses `/` if it\u2019s `None`.\n\napp (Flask) \u2013\n\nstr\n\n"}, {"name": "SessionInterface.get_cookie_samesite()", "path": "api/index#flask.sessions.SessionInterface.get_cookie_samesite", "type": "flask.sessions", "text": "\nReturn `'Strict'` or `'Lax'` if the cookie should use the `SameSite`\nattribute. This currently just returns the value of the\n`SESSION_COOKIE_SAMESITE` setting.\n\napp (Flask) \u2013\n\nstr\n\n"}, {"name": "SessionInterface.get_cookie_secure()", "path": "api/index#flask.sessions.SessionInterface.get_cookie_secure", "type": "flask.sessions", "text": "\nReturns True if the cookie should be secure. This currently just returns the\nvalue of the `SESSION_COOKIE_SECURE` setting.\n\napp (Flask) \u2013\n\nbool\n\n"}, {"name": "SessionInterface.get_expiration_time()", "path": "api/index#flask.sessions.SessionInterface.get_expiration_time", "type": "flask.sessions", "text": "\nA helper method that returns an expiration date for the session or `None` if\nthe session is linked to the browser session. The default implementation\nreturns now + the permanent session lifetime configured on the application.\n\nOptional[datetime.datetime]\n\n"}, {"name": "SessionInterface.is_null_session()", "path": "api/index#flask.sessions.SessionInterface.is_null_session", "type": "flask.sessions", "text": "\nChecks if a given object is a null session. Null sessions are not asked to be\nsaved.\n\nThis checks if the object is an instance of `null_session_class` by default.\n\nobj (object) \u2013\n\nbool\n\n"}, {"name": "SessionInterface.make_null_session()", "path": "api/index#flask.sessions.SessionInterface.make_null_session", "type": "flask.sessions", "text": "\nCreates a null session which acts as a replacement object if the real session\nsupport could not be loaded due to a configuration error. This mainly aids the\nuser experience because the job of the null session is to still support lookup\nwithout complaining but modifications are answered with a helpful error\nmessage of what failed.\n\nThis creates an instance of `null_session_class` by default.\n\napp (Flask) \u2013\n\nflask.sessions.NullSession\n\n"}, {"name": "SessionInterface.null_session_class", "path": "api/index#flask.sessions.SessionInterface.null_session_class", "type": "flask.sessions", "text": "\n`make_null_session()` will look here for the class that should be created when\na null session is requested. Likewise the `is_null_session()` method will\nperform a typecheck against this type.\n\nalias of `flask.sessions.NullSession`\n\n"}, {"name": "SessionInterface.open_session()", "path": "api/index#flask.sessions.SessionInterface.open_session", "type": "flask.sessions", "text": "\nThis method has to be implemented and must either return `None` in case the\nloading failed because of a configuration error or an instance of a session\nobject which implements a dictionary like interface + the methods and\nattributes on `SessionMixin`.\n\nOptional[flask.sessions.SessionMixin]\n\n"}, {"name": "SessionInterface.pickle_based", "path": "api/index#flask.sessions.SessionInterface.pickle_based", "type": "flask.sessions", "text": "\nA flag that indicates if the session interface is pickle based. This can be\nused by Flask extensions to make a decision in regards to how to deal with the\nsession object.\n\nNew in version 0.10.\n\n"}, {"name": "SessionInterface.save_session()", "path": "api/index#flask.sessions.SessionInterface.save_session", "type": "flask.sessions", "text": "\nThis is called for actual sessions returned by `open_session()` at the end of\nthe request. This is still called during a request context so if you\nabsolutely need access to the request you can do that.\n\nNone\n\n"}, {"name": "SessionInterface.should_set_cookie()", "path": "api/index#flask.sessions.SessionInterface.should_set_cookie", "type": "flask.sessions", "text": "\nUsed by session backends to determine if a `Set-Cookie` header should be set\nfor this session cookie for this response. If the session has been modified,\nthe cookie is set. If the session is permanent and the\n`SESSION_REFRESH_EACH_REQUEST` config is true, the cookie is always set.\n\nThis check is usually skipped if the session was deleted.\n\nNew in version 0.11.\n\nbool\n\n"}, {"name": "SessionMixin", "path": "api/index#flask.sessions.SessionMixin", "type": "flask.sessions", "text": "\nExpands a basic dictionary with session attributes.\n\nSome implementations can detect when session data is read or written and set\nthis when that happens. The mixin default is hard coded to `True`.\n\nSome implementations can detect changes to the session and set this when that\nhappens. The mixin default is hard coded to `True`.\n\nThis reflects the `'_permanent'` key in the dict.\n\n"}, {"name": "SessionMixin.accessed", "path": "api/index#flask.sessions.SessionMixin.accessed", "type": "flask.sessions", "text": "\nSome implementations can detect when session data is read or written and set\nthis when that happens. The mixin default is hard coded to `True`.\n\n"}, {"name": "SessionMixin.modified", "path": "api/index#flask.sessions.SessionMixin.modified", "type": "flask.sessions", "text": "\nSome implementations can detect changes to the session and set this when that\nhappens. The mixin default is hard coded to `True`.\n\n"}, {"name": "SESSION_COOKIE_DOMAIN", "path": "config/index#SESSION_COOKIE_DOMAIN", "type": "Configuration", "text": "\nThe domain match rule that the session cookie will be valid for. If not set,\nthe cookie will be valid for all subdomains of `SERVER_NAME`. If `False`, the\ncookie\u2019s domain will not be set.\n\nDefault: `None`\n\n"}, {"name": "SESSION_COOKIE_HTTPONLY", "path": "config/index#SESSION_COOKIE_HTTPONLY", "type": "Configuration", "text": "\nBrowsers will not allow JavaScript access to cookies marked as \u201cHTTP only\u201d for\nsecurity.\n\nDefault: `True`\n\n"}, {"name": "SESSION_COOKIE_NAME", "path": "config/index#SESSION_COOKIE_NAME", "type": "Configuration", "text": "\nThe name of the session cookie. Can be changed in case you already have a\ncookie with the same name.\n\nDefault: `'session'`\n\n"}, {"name": "SESSION_COOKIE_PATH", "path": "config/index#SESSION_COOKIE_PATH", "type": "Configuration", "text": "\nThe path that the session cookie will be valid for. If not set, the cookie\nwill be valid underneath `APPLICATION_ROOT` or `/` if that is not set.\n\nDefault: `None`\n\n"}, {"name": "SESSION_COOKIE_SAMESITE", "path": "config/index#SESSION_COOKIE_SAMESITE", "type": "Configuration", "text": "\nRestrict how cookies are sent with requests from external sites. Can be set to\n`'Lax'` (recommended) or `'Strict'`. See Set-Cookie options.\n\nDefault: `None`\n\nNew in version 1.0.\n\n"}, {"name": "SESSION_COOKIE_SECURE", "path": "config/index#SESSION_COOKIE_SECURE", "type": "Configuration", "text": "\nBrowsers will only send cookies with requests over HTTPS if the cookie is\nmarked \u201csecure\u201d. The application must be served over HTTPS for this to make\nsense.\n\nDefault: `False`\n\n"}, {"name": "SESSION_REFRESH_EACH_REQUEST", "path": "config/index#SESSION_REFRESH_EACH_REQUEST", "type": "Configuration", "text": "\nControl whether the cookie is sent with every response when\n`session.permanent` is true. Sending the cookie every time (the default) can\nmore reliably keep the session from expiring, but uses more bandwidth. Non-\npermanent sessions are not affected.\n\nDefault: `True`\n\n"}, {"name": "Signals", "path": "signals/index", "type": "User\u2019s Guide", "text": "\nNew in version 0.6.\n\nStarting with Flask 0.6, there is integrated support for signalling in Flask.\nThis support is provided by the excellent blinker library and will gracefully\nfall back if it is not available.\n\nWhat are signals? Signals help you decouple applications by sending\nnotifications when actions occur elsewhere in the core framework or another\nFlask extensions. In short, signals allow certain senders to notify\nsubscribers that something happened.\n\nFlask comes with a couple of signals and other extensions might provide more.\nAlso keep in mind that signals are intended to notify subscribers and should\nnot encourage subscribers to modify data. You will notice that there are\nsignals that appear to do the same thing like some of the builtin decorators\ndo (eg: `request_started` is very similar to `before_request()`). However,\nthere are differences in how they work. The core `before_request()` handler,\nfor example, is executed in a specific order and is able to abort the request\nearly by returning a response. In contrast all signal handlers are executed in\nundefined order and do not modify any data.\n\nThe big advantage of signals over handlers is that you can safely subscribe to\nthem for just a split second. These temporary subscriptions are helpful for\nunit testing for example. Say you want to know what templates were rendered as\npart of a request: signals allow you to do exactly that.\n\nTo subscribe to a signal, you can use the `connect()` method of a signal. The\nfirst argument is the function that should be called when the signal is\nemitted, the optional second argument specifies a sender. To unsubscribe from\na signal, you can use the `disconnect()` method.\n\nFor all core Flask signals, the sender is the application that issued the\nsignal. When you subscribe to a signal, be sure to also provide a sender\nunless you really want to listen for signals from all applications. This is\nespecially true if you are developing an extension.\n\nFor example, here is a helper context manager that can be used in a unit test\nto determine which templates were rendered and what variables were passed to\nthe template:\n\nThis can now easily be paired with a test client:\n\nMake sure to subscribe with an extra `**extra` argument so that your calls\ndon\u2019t fail if Flask introduces new arguments to the signals.\n\nAll the template rendering in the code issued by the application `app` in the\nbody of the `with` block will now be recorded in the `templates` variable.\nWhenever a template is rendered, the template object as well as context are\nappended to it.\n\nAdditionally there is a convenient helper method (`connected_to()`) that\nallows you to temporarily subscribe a function to a signal with a context\nmanager on its own. Because the return value of the context manager cannot be\nspecified that way, you have to pass the list in as an argument:\n\nThe example above would then look like this:\n\nBlinker API Changes\n\nThe `connected_to()` method arrived in Blinker with version 1.1.\n\nIf you want to use signals in your own application, you can use the blinker\nlibrary directly. The most common use case are named signals in a custom\n`Namespace`.. This is what is recommended most of the time:\n\nNow you can create new signals like this:\n\nThe name for the signal here makes it unique and also simplifies debugging.\nYou can access the name of the signal with the `name` attribute.\n\nFor Extension Developers\n\nIf you are writing a Flask extension and you want to gracefully degrade for\nmissing blinker installations, you can do so by using the\n`flask.signals.Namespace` class.\n\nIf you want to emit a signal, you can do so by calling the `send()` method. It\naccepts a sender as first argument and optionally some keyword arguments that\nare forwarded to the signal subscribers:\n\nTry to always pick a good sender. If you have a class that is emitting a\nsignal, pass `self` as sender. If you are emitting a signal from a random\nfunction, you can pass `current_app._get_current_object()` as sender.\n\nPassing Proxies as Senders\n\nNever pass `current_app` as sender to a signal. Use\n`current_app._get_current_object()` instead. The reason for this is that\n`current_app` is a proxy and not the real application object.\n\nSignals fully support The Request Context when receiving signals. Context-\nlocal variables are consistently available between `request_started` and\n`request_finished`, so you can rely on `flask.g` and others as needed. Note\nthe limitations described in Sending Signals and the `request_tearing_down`\nsignal.\n\nWith Blinker 1.1 you can also easily subscribe to signals by using the new\n`connect_via()` decorator:\n\nTake a look at Signals for a list of all builtin signals.\n\n"}, {"name": "Single-Page Applications", "path": "patterns/singlepageapplications/index", "type": "User's Guide: Design Patterns", "text": "\nFlask can be used to serve Single-Page Applications (SPA) by placing static\nfiles produced by your frontend framework in a subfolder inside of your\nproject. You will also need to create a catch-all endpoint that routes all\nrequests to your SPA.\n\nThe following example demonstrates how to serve an SPA along with an API:\n\n"}, {"name": "SQLAlchemy in Flask", "path": "patterns/sqlalchemy/index", "type": "User's Guide: Design Patterns", "text": "\nMany people prefer SQLAlchemy for database access. In this case it\u2019s\nencouraged to use a package instead of a module for your flask application and\ndrop the models into a separate module (Large Applications as Packages). While\nthat is not necessary, it makes a lot of sense.\n\nThere are four very common ways to use SQLAlchemy. I will outline each of them\nhere:\n\nBecause SQLAlchemy is a common database abstraction layer and object\nrelational mapper that requires a little bit of configuration effort, there is\na Flask extension that handles that for you. This is recommended if you want\nto get started quickly.\n\nYou can download Flask-SQLAlchemy from PyPI.\n\nThe declarative extension in SQLAlchemy is the most recent method of using\nSQLAlchemy. It allows you to define tables and models in one go, similar to\nhow Django works. In addition to the following text I recommend the official\ndocumentation on the declarative extension.\n\nHere\u2019s the example `database.py` module for your application:\n\nTo define your models, just subclass the `Base` class that was created by the\ncode above. If you are wondering why we don\u2019t have to care about threads here\n(like we did in the SQLite3 example above with the `g` object): that\u2019s because\nSQLAlchemy does that for us already with the `scoped_session`.\n\nTo use SQLAlchemy in a declarative way with your application, you just have to\nput the following code into your application module. Flask will automatically\nremove database sessions at the end of the request or when the application\nshuts down:\n\nHere is an example model (put this into `models.py`, e.g.):\n\nTo create the database you can use the `init_db` function:\n\nYou can insert entries into the database like this:\n\nQuerying is simple as well:\n\nManual object relational mapping has a few upsides and a few downsides versus\nthe declarative approach from above. The main difference is that you define\ntables and classes separately and map them together. It\u2019s more flexible but a\nlittle more to type. In general it works like the declarative approach, so\nmake sure to also split up your application into multiple modules in a\npackage.\n\nHere is an example `database.py` module for your application:\n\nAs in the declarative approach, you need to close the session after each\nrequest or application context shutdown. Put this into your application\nmodule:\n\nHere is an example table and model (put this into `models.py`):\n\nQuerying and inserting works exactly the same as in the example above.\n\nIf you just want to use the database system (and SQL) abstraction layer you\nbasically only need the engine:\n\nThen you can either declare the tables in your code like in the examples\nabove, or automatically load them:\n\nTo insert data you can use the `insert` method. We have to get a connection\nfirst so that we can use a transaction:\n\nSQLAlchemy will automatically commit for us.\n\nTo query your database, you use the engine directly or use a connection:\n\nThese results are also dict-like tuples:\n\nYou can also pass strings of SQL statements to the `execute()` method:\n\nFor more information about SQLAlchemy, head over to the website.\n\n"}, {"name": "Standalone WSGI Containers", "path": "deploying/wsgi-standalone/index", "type": "User's Guide: Deploying", "text": "\nThere are popular servers written in Python that contain WSGI applications and\nserve HTTP. These servers stand alone when they run; you can proxy to them\nfrom your web server. Note the section on Proxy Setups if you run into issues.\n\nGunicorn \u2018Green Unicorn\u2019 is a WSGI HTTP Server for UNIX. It\u2019s a pre-fork\nworker model ported from Ruby\u2019s Unicorn project. It supports both eventlet and\ngreenlet. Running a Flask application on this server is quite simple:\n\nGunicorn provides many command-line options \u2013 see `gunicorn -h`. For example,\nto run a Flask application with 4 worker processes (`-w 4`) binding to\nlocalhost port 4000 (`-b 127.0.0.1:4000`):\n\nThe `gunicorn` command expects the names of your application module or package\nand the application instance within the module. If you use the application\nfactory pattern, you can pass a call to that:\n\nuWSGI is a fast application server written in C. It is very configurable which\nmakes it more complicated to setup than gunicorn.\n\nRunning uWSGI HTTP Router:\n\nFor a more optimized setup, see configuring uWSGI and NGINX.\n\nGevent is a coroutine-based Python networking library that uses greenlet to\nprovide a high-level synchronous API on top of libev event loop:\n\nTwisted Web is the web server shipped with Twisted, a mature, non-blocking\nevent-driven networking library. Twisted Web comes with a standard WSGI\ncontainer which can be controlled from the command line using the `twistd`\nutility:\n\nThis example will run a Flask application called `app` from a module named\n`myproject`.\n\nTwisted Web supports many flags and options, and the `twistd` utility does as\nwell; see `twistd -h` and `twistd web -h` for more information. For example,\nto run a Twisted Web server in the foreground, on port 8080, with an\napplication from `myproject`:\n\nIf you deploy your application using one of these servers behind an HTTP proxy\nyou will need to rewrite a few headers in order for the application to work.\nThe two problematic values in the WSGI environment usually are `REMOTE_ADDR`\nand `HTTP_HOST`. You can configure your httpd to pass these headers, or you\ncan fix them in middleware. Werkzeug ships a fixer that will solve some common\nsetups, but you might want to write your own WSGI middleware for specific\nsetups.\n\nHere\u2019s a simple nginx configuration which proxies to an application served on\nlocalhost at port 8000, setting appropriate headers:\n\nIf your httpd is not providing these headers, the most common setup invokes\nthe host being set from `X-Forwarded-Host` and the remote address from\n`X-Forwarded-For`:\n\nTrusting Headers\n\nPlease keep in mind that it is a security issue to use such a middleware in a\nnon-proxy setup because it will blindly trust the incoming headers which might\nbe forged by malicious clients.\n\nIf you want to rewrite the headers from another header, you might want to use\na fixer like this:\n\n"}, {"name": "Streaming Contents", "path": "patterns/streaming/index", "type": "User's Guide: Design Patterns", "text": "\nSometimes you want to send an enormous amount of data to the client, much more\nthan you want to keep in memory. When you are generating the data on the fly\nthough, how do you send that back to the client without the roundtrip to the\nfilesystem?\n\nThe answer is by using generators and direct responses.\n\nThis is a basic view function that generates a lot of CSV data on the fly. The\ntrick is to have an inner function that uses a generator to generate data and\nto then invoke that function and pass it to a response object:\n\nEach `yield` expression is directly sent to the browser. Note though that some\nWSGI middlewares might break streaming, so be careful there in debug\nenvironments with profilers and other things you might have enabled.\n\nThe Jinja2 template engine also supports rendering templates piece by piece.\nThis functionality is not directly exposed by Flask because it is quite\nuncommon, but you can easily do it yourself:\n\nThe trick here is to get the template object from the Jinja2 environment on\nthe application and to call `stream()` instead of `render()` which returns a\nstream object instead of a string. Since we\u2019re bypassing the Flask template\nrender functions and using the template object itself we have to make sure to\nupdate the render context ourselves by calling `update_template_context()`.\nThe template is then evaluated as the stream is iterated over. Since each time\nyou do a yield the server will flush the content to the client you might want\nto buffer up a few items in the template which you can do with\n`rv.enable_buffering(size)`. `5` is a sane default.\n\nNew in version 0.9.\n\nNote that when you stream data, the request context is already gone the moment\nthe function executes. Flask 0.9 provides you with a helper that can keep the\nrequest context around during the execution of the generator:\n\nWithout the `stream_with_context()` function you would get a `RuntimeError` at\nthat point.\n\n"}, {"name": "stream_with_context()", "path": "api/index#flask.stream_with_context", "type": "flask", "text": "\nRequest contexts disappear when the response is started on the server. This is\ndone for efficiency reasons and to make it less likely to encounter memory\nleaks with badly written WSGI middlewares. The downside is that if you are\nusing streamed responses, the generator cannot access request bound\ninformation any more.\n\nThis function however can help you keep the context around for longer:\n\nAlternatively it can also be used around a specific generator:\n\nNew in version 0.9.\n\ngenerator_or_function (Union[Generator, Callable]) \u2013\n\nGenerator\n\n"}, {"name": "Subclassing Flask", "path": "patterns/subclassing/index", "type": "User's Guide: Design Patterns", "text": "\nThe `Flask` class is designed for subclassing.\n\nFor example, you may want to override how request parameters are handled to\npreserve their order:\n\nThis is the recommended approach for overriding or augmenting Flask\u2019s internal\nfunctionality.\n\n"}, {"name": "TaggedJSONSerializer", "path": "api/index#flask.json.tag.TaggedJSONSerializer", "type": "flask.json.tag", "text": "\nSerializer that uses a tag system to compactly represent objects that are not\nJSON types. Passed as the intermediate serializer to\n`itsdangerous.Serializer`.\n\nThe following extra types are supported:\n\nNone\n\nTag classes to bind when creating the serializer. Other tags can be added\nlater using `register()`.\n\nTag the value and dump it to a compact JSON string.\n\nvalue (Any) \u2013\n\nstr\n\nLoad data from a JSON string and deserialized any tagged objects.\n\nvalue (str) \u2013\n\nAny\n\nRegister a new tag with this serializer.\n\nKeyError \u2013 if the tag key is already registered and `force` is not true.\n\nNone\n\nConvert a value to a tagged representation if necessary.\n\nvalue (Any) \u2013\n\nDict[str, Any]\n\nConvert a tagged representation back to the original type.\n\nvalue (Dict[str, Any]) \u2013\n\nAny\n\n"}, {"name": "TaggedJSONSerializer.default_tags", "path": "api/index#flask.json.tag.TaggedJSONSerializer.default_tags", "type": "flask.json.tag", "text": "\nTag classes to bind when creating the serializer. Other tags can be added\nlater using `register()`.\n\n"}, {"name": "TaggedJSONSerializer.dumps()", "path": "api/index#flask.json.tag.TaggedJSONSerializer.dumps", "type": "flask.json.tag", "text": "\nTag the value and dump it to a compact JSON string.\n\nvalue (Any) \u2013\n\nstr\n\n"}, {"name": "TaggedJSONSerializer.loads()", "path": "api/index#flask.json.tag.TaggedJSONSerializer.loads", "type": "flask.json.tag", "text": "\nLoad data from a JSON string and deserialized any tagged objects.\n\nvalue (str) \u2013\n\nAny\n\n"}, {"name": "TaggedJSONSerializer.register()", "path": "api/index#flask.json.tag.TaggedJSONSerializer.register", "type": "flask.json.tag", "text": "\nRegister a new tag with this serializer.\n\nKeyError \u2013 if the tag key is already registered and `force` is not true.\n\nNone\n\n"}, {"name": "TaggedJSONSerializer.tag()", "path": "api/index#flask.json.tag.TaggedJSONSerializer.tag", "type": "flask.json.tag", "text": "\nConvert a value to a tagged representation if necessary.\n\nvalue (Any) \u2013\n\nDict[str, Any]\n\n"}, {"name": "TaggedJSONSerializer.untag()", "path": "api/index#flask.json.tag.TaggedJSONSerializer.untag", "type": "flask.json.tag", "text": "\nConvert a tagged representation back to the original type.\n\nvalue (Dict[str, Any]) \u2013\n\nAny\n\n"}, {"name": "Template Inheritance", "path": "patterns/templateinheritance/index", "type": "User's Guide: Design Patterns", "text": "\nThe most powerful part of Jinja is template inheritance. Template inheritance\nallows you to build a base \u201cskeleton\u201d template that contains all the common\nelements of your site and defines blocks that child templates can override.\n\nSounds complicated but is very basic. It\u2019s easiest to understand it by\nstarting with an example.\n\nThis template, which we\u2019ll call `layout.html`, defines a simple HTML skeleton\ndocument that you might use for a simple two-column page. It\u2019s the job of\n\u201cchild\u201d templates to fill the empty blocks with content:\n\nIn this example, the `{% block %}` tags define four blocks that child\ntemplates can fill in. All the `block` tag does is tell the template engine\nthat a child template may override those portions of the template.\n\nA child template might look like this:\n\nThe `{% extends %}` tag is the key here. It tells the template engine that\nthis template \u201cextends\u201d another template. When the template system evaluates\nthis template, first it locates the parent. The extends tag must be the first\ntag in the template. To render the contents of a block defined in the parent\ntemplate, use `{{ super() }}`.\n\n"}, {"name": "Templates", "path": "templating/index", "type": "User\u2019s Guide", "text": "\nFlask leverages Jinja2 as its template engine. You are obviously free to use a\ndifferent template engine, but you still have to install Jinja2 to run Flask\nitself. This requirement is necessary to enable rich extensions. An extension\ncan depend on Jinja2 being present.\n\nThis section only gives a very quick introduction into how Jinja2 is\nintegrated into Flask. If you want information on the template engine\u2019s syntax\nitself, head over to the official Jinja2 Template Documentation for more\ninformation.\n\nUnless customized, Jinja2 is configured by Flask as follows:\n\nThe following global variables are available within Jinja2 templates by\ndefault:\n\nThe current configuration object (`flask.config`)\n\nChanged in version 0.10: This is now always available, even in imported\ntemplates.\n\nNew in version 0.6.\n\nThe current request object (`flask.request`). This variable is unavailable if\nthe template was rendered without an active request context.\n\nThe current session object (`flask.session`). This variable is unavailable if\nthe template was rendered without an active request context.\n\nThe request-bound object for global variables (`flask.g`). This variable is\nunavailable if the template was rendered without an active request context.\n\nThe `flask.url_for()` function.\n\nThe `flask.get_flashed_messages()` function.\n\nThe Jinja Context Behavior\n\nThese variables are added to the context of variables, they are not global\nvariables. The difference is that by default these will not show up in the\ncontext of imported templates. This is partially caused by performance\nconsiderations, partially to keep things explicit.\n\nWhat does this mean for you? If you have a macro you want to import, that\nneeds to access the request object you have two possibilities:\n\nImporting with context looks like this:\n\nAutoescaping is the concept of automatically escaping special characters for\nyou. Special characters in the sense of HTML (or XML, and thus XHTML) are `&`,\n`>`, `<`, `\"` as well as `'`. Because these characters carry specific meanings\nin documents on their own you have to replace them by so called \u201centities\u201d if\nyou want to use them for text. Not doing so would not only cause user\nfrustration by the inability to use these characters in text, but can also\nlead to security problems. (see Cross-Site Scripting (XSS))\n\nSometimes however you will need to disable autoescaping in templates. This can\nbe the case if you want to explicitly inject HTML into pages, for example if\nthey come from a system that generates secure HTML like a markdown to HTML\nconverter.\n\nThere are three ways to accomplish that:\n\nTo disable the autoescape system in templates, you can use the `{% autoescape\n%}` block:\n\nWhenever you do this, please be very cautious about the variables you are\nusing in this block.\n\nIf you want to register your own filters in Jinja2 you have two ways to do\nthat. You can either put them by hand into the `jinja_env` of the application\nor use the `template_filter()` decorator.\n\nThe two following examples work the same and both reverse an object:\n\nIn case of the decorator the argument is optional if you want to use the\nfunction name as name of the filter. Once registered, you can use the filter\nin your templates in the same way as Jinja2\u2019s builtin filters, for example if\nyou have a Python list in context called `mylist`:\n\nTo inject new variables automatically into the context of a template, context\nprocessors exist in Flask. Context processors run before the template is\nrendered and have the ability to inject new values into the template context.\nA context processor is a function that returns a dictionary. The keys and\nvalues of this dictionary are then merged with the template context, for all\ntemplates in the app:\n\nThe context processor above makes a variable called `user` available in the\ntemplate with the value of `g.user`. This example is not very interesting\nbecause `g` is available in templates anyways, but it gives an idea how this\nworks.\n\nVariables are not limited to values; a context processor can also make\nfunctions available to templates (since Python allows passing around\nfunctions):\n\nThe context processor above makes the `format_price` function available to all\ntemplates:\n\nYou could also build `format_price` as a template filter (see Registering\nFilters), but this demonstrates how to pass functions in a context processor.\n\n"}, {"name": "TEMPLATES_AUTO_RELOAD", "path": "config/index#TEMPLATES_AUTO_RELOAD", "type": "Configuration", "text": "\nReload templates when they are changed. If not set, it will be enabled in\ndebug mode.\n\nDefault: `None`\n\n"}, {"name": "TESTING", "path": "config/index#TESTING", "type": "Configuration", "text": "\nEnable testing mode. Exceptions are propagated rather than handled by the the\napp\u2019s error handlers. Extensions may also change their behavior to facilitate\neasier testing. You should enable this in your own tests.\n\nDefault: `False`\n\n"}, {"name": "Testing Flask Applications", "path": "testing/index", "type": "User\u2019s Guide", "text": "\nSomething that is untested is broken.\n\nThe origin of this quote is unknown and while it is not entirely correct, it\nis also not far from the truth. Untested applications make it hard to improve\nexisting code and developers of untested applications tend to become pretty\nparanoid. If an application has automated tests, you can safely make changes\nand instantly know if anything breaks.\n\nFlask provides a way to test your application by exposing the Werkzeug test\n`Client` and handling the context locals for you. You can then use that with\nyour favourite testing solution.\n\nIn this documentation we will use the pytest package as the base framework for\nour tests. You can install it with `pip`, like so:\n\nFirst, we need an application to test; we will use the application from the\nTutorial. If you don\u2019t have that application yet, get the source code from the\nexamples.\n\nSo that we can import the module `flaskr` correctly, we need to run `pip\ninstall -e .` in the folder `tutorial`.\n\nWe begin by adding a tests directory under the application root. Then create a\nPython file to store our tests (`test_flaskr.py`). When we format the filename\nlike `test_*.py`, it will be auto-discoverable by pytest.\n\nNext, we create a pytest fixture called `client()` that configures the\napplication for testing and initializes a new database:\n\nThis client fixture will be called by each individual test. It gives us a\nsimple interface to the application, where we can trigger test requests to the\napplication. The client will also keep track of cookies for us.\n\nDuring setup, the `TESTING` config flag is activated. What this does is\ndisable error catching during request handling, so that you get better error\nreports when performing test requests against the application.\n\nBecause SQLite3 is filesystem-based, we can easily use the `tempfile` module\nto create a temporary database and initialize it. The `mkstemp()` function\ndoes two things for us: it returns a low-level file handle and a random file\nname, the latter we use as database name. We just have to keep the `db_fd`\naround so that we can use the `os.close()` function to close the file.\n\nTo delete the database after the test, the fixture closes the file and removes\nit from the filesystem.\n\nIf we now run the test suite, we should see the following output:\n\nEven though it did not run any actual tests, we already know that our `flaskr`\napplication is syntactically valid, otherwise the import would have died with\nan exception.\n\nNow it\u2019s time to start testing the functionality of the application. Let\u2019s\ncheck that the application shows \u201cNo entries here so far\u201d if we access the\nroot of the application (`/`). To do this, we add a new test function to\n`test_flaskr.py`, like this:\n\nNotice that our test functions begin with the word `test`; this allows pytest\nto automatically identify the function as a test to run.\n\nBy using `client.get` we can send an HTTP `GET` request to the application\nwith the given path. The return value will be a `response_class` object. We\ncan now use the `data` attribute to inspect the return value (as string) from\nthe application. In this case, we ensure that `'No entries here so far'` is\npart of the output.\n\nRun it again and you should see one passing test:\n\nThe majority of the functionality of our application is only available for the\nadministrative user, so we need a way to log our test client in and out of the\napplication. To do this, we fire some requests to the login and logout pages\nwith the required form data (username and password). And because the login and\nlogout pages redirect, we tell the client to `follow_redirects`.\n\nAdd the following two functions to your `test_flaskr.py` file:\n\nNow we can easily test that logging in and out works and that it fails with\ninvalid credentials. Add this new test function:\n\nWe should also test that adding messages works. Add a new test function like\nthis:\n\nHere we check that HTML is allowed in the text but not in the title, which is\nthe intended behavior.\n\nRunning that should now give us three passing tests:\n\nBesides using the test client as shown above, there is also the\n`test_request_context()` method that can be used in combination with the\n`with` statement to activate a request context temporarily. With this you can\naccess the `request`, `g` and `session` objects like in view functions. Here\nis a full example that demonstrates this approach:\n\nAll the other objects that are context bound can be used in the same way.\n\nIf you want to test your application with different configurations and there\ndoes not seem to be a good way to do that, consider switching to application\nfactories (see Application Factories).\n\nNote however that if you are using a test request context, the\n`before_request()` and `after_request()` functions are not called\nautomatically. However `teardown_request()` functions are indeed executed when\nthe test request context leaves the `with` block. If you do want the\n`before_request()` functions to be called as well, you need to call\n`preprocess_request()` yourself:\n\nThis can be necessary to open database connections or something similar\ndepending on how your application was designed.\n\nIf you want to call the `after_request()` functions you need to call into\n`process_response()` which however requires that you pass it a response\nobject:\n\nThis in general is less useful because at that point you can directly start\nusing the test client.\n\nNew in version 0.10.\n\nA very common pattern is to store user authorization information and database\nconnections on the application context or the `flask.g` object. The general\npattern for this is to put the object on there on first usage and then to\nremove it on a teardown. Imagine for instance this code to get the current\nuser:\n\nFor a test it would be nice to override this user from the outside without\nhaving to change some code. This can be accomplished with hooking the\n`flask.appcontext_pushed` signal:\n\nAnd then to use it:\n\nNew in version 0.4.\n\nSometimes it is helpful to trigger a regular request but still keep the\ncontext around for a little longer so that additional introspection can\nhappen. With Flask 0.4 this is possible by using the `test_client()` with a\n`with` block:\n\nIf you were to use just the `test_client()` without the `with` block, the\n`assert` would fail with an error because `request` is no longer available\n(because you are trying to use it outside of the actual request).\n\nNew in version 0.8.\n\nSometimes it can be very helpful to access or modify the sessions from the\ntest client. Generally there are two ways for this. If you just want to ensure\nthat a session has certain keys set to certain values you can just keep the\ncontext around and access `flask.session`:\n\nThis however does not make it possible to also modify the session or to access\nthe session before a request was fired. Starting with Flask 0.8 we provide a\nso called \u201csession transaction\u201d which simulates the appropriate calls to open\na session in the context of the test client and to modify it. At the end of\nthe transaction the session is stored and ready to be used by the test client.\nThis works independently of the session backend used:\n\nNote that in this case you have to use the `sess` object instead of the\n`flask.session` proxy. The object however itself will provide the same\ninterface.\n\nNew in version 1.0.\n\nFlask has great support for JSON, and is a popular choice for building JSON\nAPIs. Making requests with JSON data and examining JSON data in responses is\nvery convenient:\n\nPassing the `json` argument in the test client methods sets the request data\nto the JSON-serialized object and sets the content type to `application/json`.\nYou can get the JSON data from the request or response with `get_json`.\n\nClick comes with utilities for testing your CLI commands. A `CliRunner` runs\ncommands in isolation and captures the output in a `Result` object.\n\nFlask provides `test_cli_runner()` to create a `FlaskCliRunner` that passes\nthe Flask app to the CLI automatically. Use its `invoke()` method to call\ncommands in the same way they would be called from the command line.\n\nIn the example above, invoking the command by name is useful because it\nverifies that the command was correctly registered with the app.\n\nIf you want to test how your command parses parameters, without running the\ncommand, use its `make_context()` method. This is useful for testing complex\nvalidation rules and custom types.\n\n"}, {"name": "The Application Context", "path": "appcontext/index", "type": "User\u2019s Guide", "text": "\nThe application context keeps track of the application-level data during a\nrequest, CLI command, or other activity. Rather than passing the application\naround to each function, the `current_app` and `g` proxies are accessed\ninstead.\n\nThis is similar to the The Request Context, which keeps track of request-level\ndata during a request. A corresponding application context is pushed when a\nrequest context is pushed.\n\nThe `Flask` application object has attributes, such as `config`, that are\nuseful to access within views and CLI commands. However, importing the `app`\ninstance within the modules in your project is prone to circular import\nissues. When using the app factory pattern or writing reusable blueprints or\nextensions there won\u2019t be an `app` instance to import at all.\n\nFlask solves this issue with the application context. Rather than referring to\nan `app` directly, you use the `current_app` proxy, which points to the\napplication handling the current activity.\n\nFlask automatically pushes an application context when handling a request.\nView functions, error handlers, and other functions that run during a request\nwill have access to `current_app`.\n\nFlask will also automatically push an app context when running CLI commands\nregistered with `Flask.cli` using `@app.cli.command()`.\n\nThe application context is created and destroyed as necessary. When a Flask\napplication begins handling a request, it pushes an application context and a\nrequest context. When the request ends it pops the request context then the\napplication context. Typically, an application context will have the same\nlifetime as a request.\n\nSee The Request Context for more information about how the contexts work and\nthe full life cycle of a request.\n\nIf you try to access `current_app`, or anything that uses it, outside an\napplication context, you\u2019ll get this error message:\n\nIf you see that error while configuring your application, such as when\ninitializing an extension, you can push a context manually since you have\ndirect access to the `app`. Use `app_context()` in a `with` block, and\neverything that runs in the block will have access to `current_app`.\n\nIf you see that error somewhere else in your code not related to configuring\nthe application, it most likely indicates that you should move that code into\na view function or CLI command.\n\nThe application context is a good place to store common data during a request\nor CLI command. Flask provides the `g object` for this purpose. It is a simple\nnamespace object that has the same lifetime as an application context.\n\nNote\n\nThe `g` name stands for \u201cglobal\u201d, but that is referring to the data being\nglobal within a context. The data on `g` is lost after the context ends, and\nit is not an appropriate place to store data between requests. Use the\n`session` or a database to store data across requests.\n\nA common use for `g` is to manage resources during a request.\n\nFor example, you can manage a database connection using this pattern:\n\nDuring a request, every call to `get_db()` will return the same connection,\nand it will be closed automatically at the end of the request.\n\nYou can use `LocalProxy` to make a new context local from `get_db()`:\n\nAccessing `db` will call `get_db` internally, in the same way that\n`current_app` works.\n\nIf you\u2019re writing an extension, `g` should be reserved for user code. You may\nstore internal data on the context itself, but be sure to use a sufficiently\nunique name. The current context is accessed with `_app_ctx_stack.top`. For\nmore information see Flask Extension Development.\n\nThe application will call functions registered with `teardown_appcontext()`\nwhen the application context is popped.\n\nIf `signals_available` is true, the following signals are sent:\n`appcontext_pushed`, `appcontext_tearing_down`, and `appcontext_popped`.\n\n"}, {"name": "The Request Context", "path": "reqcontext/index", "type": "User\u2019s Guide", "text": "\nThe request context keeps track of the request-level data during a request.\nRather than passing the request object to each function that runs during a\nrequest, the `request` and `session` proxies are accessed instead.\n\nThis is similar to the The Application Context, which keeps track of the\napplication-level data independent of a request. A corresponding application\ncontext is pushed when a request context is pushed.\n\nWhen the `Flask` application handles a request, it creates a `Request` object\nbased on the environment it received from the WSGI server. Because a worker\n(thread, process, or coroutine depending on the server) handles only one\nrequest at a time, the request data can be considered global to that worker\nduring that request. Flask uses the term context local for this.\n\nFlask automatically pushes a request context when handling a request. View\nfunctions, error handlers, and other functions that run during a request will\nhave access to the `request` proxy, which points to the request object for the\ncurrent request.\n\nWhen a Flask application begins handling a request, it pushes a request\ncontext, which also pushes an The Application Context. When the request ends\nit pops the request context then the application context.\n\nThe context is unique to each thread (or other worker type). `request` cannot\nbe passed to another thread, the other thread will have a different context\nstack and will not know about the request the parent thread was pointing to.\n\nContext locals are implemented in Werkzeug. See Context Locals for more\ninformation on how this works internally.\n\nIf you try to access `request`, or anything that uses it, outside a request\ncontext, you\u2019ll get this error message:\n\nThis should typically only happen when testing code that expects an active\nrequest. One option is to use the `test client` to simulate a full request. Or\nyou can use `test_request_context()` in a `with` block, and everything that\nruns in the block will have access to `request`, populated with your test\ndata.\n\nIf you see that error somewhere else in your code not related to testing, it\nmost likely indicates that you should move that code into a view function.\n\nFor information on how to use the request context from the interactive Python\nshell, see Working with the Shell.\n\nThe `Flask.wsgi_app()` method is called to handle each request. It manages the\ncontexts during the request. Internally, the request and application contexts\nwork as stacks, `_request_ctx_stack` and `_app_ctx_stack`. When contexts are\npushed onto the stack, the proxies that depend on them are available and point\nat information from the top context on the stack.\n\nWhen the request starts, a `RequestContext` is created and pushed, which\ncreates and pushes an `AppContext` first if a context for that application is\nnot already the top context. While these contexts are pushed, the\n`current_app`, `g`, `request`, and `session` proxies are available to the\noriginal thread handling the request.\n\nBecause the contexts are stacks, other contexts may be pushed to change the\nproxies during a request. While this is not a common pattern, it can be used\nin advanced applications to, for example, do internal redirects or chain\ndifferent applications together.\n\nAfter the request is dispatched and a response is generated and sent, the\nrequest context is popped, which then pops the application context.\nImmediately before they are popped, the `teardown_request()` and\n`teardown_appcontext()` functions are executed. These execute even if an\nunhandled exception occurred during dispatch.\n\nFlask dispatches a request in multiple stages which can affect the request,\nresponse, and how errors are handled. The contexts are active during all of\nthese stages.\n\nA `Blueprint` can add handlers for these events that are specific to the\nblueprint. The handlers for a blueprint will run if the blueprint owns the\nroute that matches the request.\n\nIf an exception is raised before the teardown functions, Flask tries to match\nit with an `errorhandler()` function to handle the exception and return a\nresponse. If no error handler is found, or the handler itself raises an\nexception, Flask returns a generic `500 Internal Server Error` response. The\nteardown functions are still called, and are passed the exception object.\n\nIf debug mode is enabled, unhandled exceptions are not converted to a `500`\nresponse and instead are propagated to the WSGI server. This allows the\ndevelopment server to present the interactive debugger with the traceback.\n\nThe teardown callbacks are independent of the request dispatch, and are\ninstead called by the contexts when they are popped. The functions are called\neven if there is an unhandled exception during dispatch, and for manually\npushed contexts. This means there is no guarantee that any other parts of the\nrequest dispatch have run first. Be sure to write these functions in a way\nthat does not depend on other callbacks and will not fail.\n\nDuring testing, it can be useful to defer popping the contexts after the\nrequest ends, so that their data can be accessed in the test function. Use the\n`test_client()` as a `with` block to preserve the contexts until the `with`\nblock exits.\n\nIf `signals_available` is true, the following signals are sent:\n\nAt the end of a request, the request context is popped and all data associated\nwith it is destroyed. If an error occurs during development, it is useful to\ndelay destroying the data for debugging purposes.\n\nWhen the development server is running in development mode (the `FLASK_ENV`\nenvironment variable is set to `'development'`), the error and data will be\npreserved and shown in the interactive debugger.\n\nThis behavior can be controlled with the `PRESERVE_CONTEXT_ON_EXCEPTION`\nconfig. As described above, it defaults to `True` in the development\nenvironment.\n\nDo not enable `PRESERVE_CONTEXT_ON_EXCEPTION` in production, as it will cause\nyour application to leak memory on exceptions.\n\nSome of the objects provided by Flask are proxies to other objects. The\nproxies are accessed in the same way for each worker thread, but point to the\nunique object bound to each worker behind the scenes as described on this\npage.\n\nMost of the time you don\u2019t have to care about that, but there are some\nexceptions where it is good to know that this object is actually a proxy:\n\nIf you need to access the underlying object that is proxied, use the\n`_get_current_object()` method:\n\n"}, {"name": "TRAP_BAD_REQUEST_ERRORS", "path": "config/index#TRAP_BAD_REQUEST_ERRORS", "type": "Configuration", "text": "\nTrying to access a key that doesn\u2019t exist from request dicts like `args` and\n`form` will return a 400 Bad Request error page. Enable this to treat the\nerror as an unhandled exception instead so that you get the interactive\ndebugger. This is a more specific version of `TRAP_HTTP_EXCEPTIONS`. If unset,\nit is enabled in debug mode.\n\nDefault: `None`\n\n"}, {"name": "TRAP_HTTP_EXCEPTIONS", "path": "config/index#TRAP_HTTP_EXCEPTIONS", "type": "Configuration", "text": "\nIf there is no handler for an `HTTPException`-type exception, re-raise it to\nbe handled by the interactive debugger instead of returning it as a simple\nerror response.\n\nDefault: `False`\n\n"}, {"name": "Uploading Files", "path": "patterns/fileuploads/index", "type": "User's Guide: Design Patterns", "text": "\nAh yes, the good old problem of file uploads. The basic idea of file uploads\nis actually quite simple. It basically works like this:\n\nLet\u2019s start with a very basic application that uploads a file to a specific\nupload folder and displays a file to the user. Let\u2019s look at the bootstrapping\ncode for our application:\n\nSo first we need a couple of imports. Most should be straightforward, the\n`werkzeug.secure_filename()` is explained a little bit later. The\n`UPLOAD_FOLDER` is where we will store the uploaded files and the\n`ALLOWED_EXTENSIONS` is the set of allowed file extensions.\n\nWhy do we limit the extensions that are allowed? You probably don\u2019t want your\nusers to be able to upload everything there if the server is directly sending\nout the data to the client. That way you can make sure that users are not able\nto upload HTML files that would cause XSS problems (see Cross-Site Scripting\n(XSS)). Also make sure to disallow `.php` files if the server executes them,\nbut who has PHP installed on their server, right? :)\n\nNext the functions that check if an extension is valid and that uploads the\nfile and redirects the user to the URL for the uploaded file:\n\nSo what does that `secure_filename()` function actually do? Now the problem is\nthat there is that principle called \u201cnever trust user input\u201d. This is also\ntrue for the filename of an uploaded file. All submitted form data can be\nforged, and filenames can be dangerous. For the moment just remember: always\nuse that function to secure a filename before storing it directly on the\nfilesystem.\n\nInformation for the Pros\n\nSo you\u2019re interested in what that `secure_filename()` function does and what\nthe problem is if you\u2019re not using it? So just imagine someone would send the\nfollowing information as `filename` to your application:\n\nAssuming the number of `../` is correct and you would join this with the\n`UPLOAD_FOLDER` the user might have the ability to modify a file on the\nserver\u2019s filesystem he or she should not modify. This does require some\nknowledge about how the application looks like, but trust me, hackers are\npatient :)\n\nNow let\u2019s look how that function works:\n\nWe want to be able to serve the uploaded files so they can be downloaded by\nusers. We\u2019ll define a `download_file` view to serve files in the upload folder\nby name. `url_for(\"download_file\", name=name)` generates download URLs.\n\nIf you\u2019re using middleware or the HTTP server to serve files, you can register\nthe `download_file` endpoint as `build_only` so `url_for` will work without a\nview function.\n\nNew in version 0.6.\n\nSo how exactly does Flask handle uploads? Well it will store them in the\nwebserver\u2019s memory if the files are reasonably small, otherwise in a temporary\nlocation (as returned by `tempfile.gettempdir()`). But how do you specify the\nmaximum file size after which an upload is aborted? By default Flask will\nhappily accept file uploads with an unlimited amount of memory, but you can\nlimit that by setting the `MAX_CONTENT_LENGTH` config key:\n\nThe code above will limit the maximum allowed payload to 16 megabytes. If a\nlarger file is transmitted, Flask will raise a `RequestEntityTooLarge`\nexception.\n\nConnection Reset Issue\n\nWhen using the local development server, you may get a connection reset error\ninstead of a 413 response. You will get the correct status response when\nrunning the app with a production WSGI server.\n\nThis feature was added in Flask 0.6 but can be achieved in older versions as\nwell by subclassing the request object. For more information on that consult\nthe Werkzeug documentation on file handling.\n\nA while ago many developers had the idea to read the incoming file in small\nchunks and store the upload progress in the database to be able to poll the\nprogress with JavaScript from the client. The client asks the server every 5\nseconds how much it has transmitted, but this is something it should already\nknow.\n\nNow there are better solutions that work faster and are more reliable. There\nare JavaScript libraries like jQuery that have form plugins to ease the\nconstruction of progress bar.\n\nBecause the common pattern for file uploads exists almost unchanged in all\napplications dealing with uploads, there is also a Flask extension called\nFlask-Uploads that implements a full fledged upload mechanism that allows\ncontrolling which file extensions are allowed to be uploaded.\n\n"}, {"name": "url_for()", "path": "api/index#flask.url_for", "type": "flask", "text": "\nGenerates a URL to the given endpoint with the method provided.\n\nVariable arguments that are unknown to the target endpoint are appended to the\ngenerated URL as query arguments. If the value of a query argument is `None`,\nthe whole pair is skipped. In case blueprints are active you can shortcut\nreferences to the same blueprint by prefixing the local endpoint with a dot\n(`.`).\n\nThis will reference the index function local to the current blueprint:\n\nSee URL Building.\n\nConfiguration values `APPLICATION_ROOT` and `SERVER_NAME` are only used when\ngenerating URLs outside of a request context.\n\nTo integrate applications, `Flask` has a hook to intercept URL build errors\nthrough `Flask.url_build_error_handlers`. The `url_for` function results in a\n`BuildError` when the current app does not have a URL for the given endpoint\nand values. When it does, the `current_app` calls its\n`url_build_error_handlers` if it is not `None`, which can return a string to\nuse as the result of `url_for` (instead of `url_for`\u2019s default to raise the\n`BuildError` exception) or re-raise the exception. An example:\n\nHere, `error` is the instance of `BuildError`, and `endpoint` and `values` are\nthe arguments passed into `url_for`. Note that this is for building URLs\noutside the current application, and not for handling 404 NotFound errors.\n\nNew in version 0.10: The `_scheme` parameter was added.\n\nNew in version 0.9: The `_anchor` and `_method` parameters were added.\n\nNew in version 0.9: Calls `Flask.handle_build_error()` on `BuildError`.\n\nstr\n\n"}, {"name": "USE_X_SENDFILE", "path": "config/index#USE_X_SENDFILE", "type": "Configuration", "text": "\nWhen serving files, set the `X-Sendfile` header instead of serving the data\nwith Flask. Some web servers, such as Apache, recognize this and serve the\ndata more efficiently. This only makes sense when using such a server.\n\nDefault: `False`\n\n"}, {"name": "Using async and await", "path": "async-await/index", "type": "User\u2019s Guide", "text": "\nNew in version 2.0.\n\nRoutes, error handlers, before request, after request, and teardown functions\ncan all be coroutine functions if Flask is installed with the `async` extra\n(`pip install flask[async]`). This allows views to be defined with `async def`\nand use `await`.\n\nUsing `async` on Windows on Python 3.8\n\nPython 3.8 has a bug related to asyncio on Windows. If you encounter something\nlike `ValueError: set_wakeup_fd only works in main thread`, please upgrade to\nPython 3.9.\n\nAsync functions require an event loop to run. Flask, as a WSGI application,\nuses one worker to handle one request/response cycle. When a request comes in\nto an async view, Flask will start an event loop in a thread, run the view\nfunction there, then return the result.\n\nEach request still ties up one worker, even for async views. The upside is\nthat you can run async code within a view, for example to make multiple\nconcurrent database queries, HTTP requests to an external API, etc. However,\nthe number of requests your application can handle at one time will remain the\nsame.\n\nAsync is not inherently faster than sync code. Async is beneficial when\nperforming concurrent IO-bound tasks, but will probably not improve CPU-bound\ntasks. Traditional Flask views will still be appropriate for most use cases,\nbut Flask\u2019s async support enables writing and using code that wasn\u2019t possible\nnatively before.\n\nAsync functions will run in an event loop until they complete, at which stage\nthe event loop will stop. This means any additional spawned tasks that haven\u2019t\ncompleted when the async function completes will be cancelled. Therefore you\ncannot spawn background tasks, for example via `asyncio.create_task`.\n\nIf you wish to use background tasks it is best to use a task queue to trigger\nbackground work, rather than spawn tasks in a view function. With that in mind\nyou can spawn asyncio tasks by serving Flask with an ASGI server and utilising\nthe asgiref WsgiToAsgi adapter as described in ASGI. This works as the adapter\ncreates an event loop that runs continually.\n\nFlask\u2019s async support is less performant than async-first frameworks due to\nthe way it is implemented. If you have a mainly async codebase it would make\nsense to consider Quart. Quart is a reimplementation of Flask based on the\nASGI standard instead of WSGI. This allows it to handle many concurrent\nrequests, long running requests, and websockets without requiring multiple\nworker processes or threads.\n\nIt has also already been possible to run Flask with Gevent or Eventlet to get\nmany of the benefits of async request handling. These libraries patch low-\nlevel Python functions to accomplish this, whereas `async`/ `await` and ASGI\nuse standard, modern Python capabilities. Deciding whether you should use\nFlask, Quart, or something else is ultimately up to understanding the specific\nneeds of your project.\n\nFlask extensions predating Flask\u2019s async support do not expect async views. If\nthey provide decorators to add functionality to views, those will probably not\nwork with async views because they will not await the function or be\nawaitable. Other functions they provide will not be awaitable either and will\nprobably be blocking if called within an async view.\n\nExtension authors can support async functions by utilising the\n`flask.Flask.ensure_sync()` method. For example, if the extension provides a\nview function decorator add `ensure_sync` before calling the decorated\nfunction,\n\nCheck the changelog of the extension you want to use to see if they\u2019ve\nimplemented async support, or make a feature request or PR to them.\n\nAt the moment Flask only supports `asyncio`. It\u2019s possible to override\n`flask.Flask.ensure_sync()` to change how async functions are wrapped to use a\ndifferent library.\n\n"}, {"name": "Using SQLite 3 with Flask", "path": "patterns/sqlite3/index", "type": "User's Guide: Design Patterns", "text": "\nIn Flask you can easily implement the opening of database connections on\ndemand and closing them when the context dies (usually at the end of the\nrequest).\n\nHere is a simple example of how you can use SQLite 3 with Flask:\n\nNow, to use the database, the application must either have an active\napplication context (which is always true if there is a request in flight) or\ncreate an application context itself. At that point the `get_db` function can\nbe used to get the current database connection. Whenever the context is\ndestroyed the database connection will be terminated.\n\nNote: if you use Flask 0.9 or older you need to use `flask._app_ctx_stack.top`\ninstead of `g` as the `flask.g` object was bound to the request and not\napplication context.\n\nExample:\n\nNote\n\nPlease keep in mind that the teardown request and appcontext functions are\nalways executed, even if a before-request handler failed or was never\nexecuted. Because of this we have to make sure here that the database is there\nbefore we close it.\n\nThe upside of this approach (connecting on first use) is that this will only\nopen the connection if truly necessary. If you want to use this code outside a\nrequest context you can use it in a Python shell by opening the application\ncontext by hand:\n\nNow in each request handling function you can access `get_db()` to get the\ncurrent open database connection. To simplify working with SQLite, a row\nfactory function is useful. It is executed for every result returned from the\ndatabase to convert the result. For instance, in order to get dictionaries\ninstead of tuples, this could be inserted into the `get_db` function we\ncreated above:\n\nThis will make the sqlite3 module return dicts for this database connection,\nwhich are much nicer to deal with. Even more simply, we could place this in\n`get_db` instead:\n\nThis would use Row objects rather than dicts to return the results of queries.\nThese are `namedtuple` s, so we can access them either by index or by key. For\nexample, assuming we have a `sqlite3.Row` called `r` for the rows `id`,\n`FirstName`, `LastName`, and `MiddleInitial`:\n\nAdditionally, it is a good idea to provide a query function that combines\ngetting the cursor, executing and fetching the results:\n\nThis handy little function, in combination with a row factory, makes working\nwith the database much more pleasant than it is by just using the raw cursor\nand connection objects.\n\nHere is how you can use it:\n\nOr if you just want a single result:\n\nTo pass variable parts to the SQL statement, use a question mark in the\nstatement and pass in the arguments as a list. Never directly add them to the\nSQL statement with string formatting because this makes it possible to attack\nthe application using SQL Injections.\n\nRelational databases need schemas, so applications often ship a `schema.sql`\nfile that creates the database. It\u2019s a good idea to provide a function that\ncreates the database based on that schema. This function can do that for you:\n\nYou can then create such a database from the Python shell:\n\n"}, {"name": "Using URL Processors", "path": "patterns/urlprocessors/index", "type": "User's Guide: Design Patterns", "text": "\nNew in version 0.7.\n\nFlask 0.7 introduces the concept of URL processors. The idea is that you might\nhave a bunch of resources with common parts in the URL that you don\u2019t always\nexplicitly want to provide. For instance you might have a bunch of URLs that\nhave the language code in it but you don\u2019t want to have to handle it in every\nsingle function yourself.\n\nURL processors are especially helpful when combined with blueprints. We will\nhandle both application specific URL processors here as well as blueprint\nspecifics.\n\nConsider an application like this:\n\nThis is an awful lot of repetition as you have to handle the language code\nsetting on the `g` object yourself in every single function. Sure, a decorator\ncould be used to simplify this, but if you want to generate URLs from one\nfunction to another you would have to still provide the language code\nexplicitly which can be annoying.\n\nFor the latter, this is where `url_defaults()` functions come in. They can\nautomatically inject values into a call to `url_for()`. The code below checks\nif the language code is not yet in the dictionary of URL values and if the\nendpoint wants a value named `'lang_code'`:\n\nThe method `is_endpoint_expecting()` of the URL map can be used to figure out\nif it would make sense to provide a language code for the given endpoint.\n\nThe reverse of that function are `url_value_preprocessor()`s. They are\nexecuted right after the request was matched and can execute code based on the\nURL values. The idea is that they pull information out of the values\ndictionary and put it somewhere else:\n\nThat way you no longer have to do the `lang_code` assignment to `g` in every\nfunction. You can further improve that by writing your own decorator that\nprefixes URLs with the language code, but the more beautiful solution is using\na blueprint. Once the `'lang_code'` is popped from the values dictionary and\nit will no longer be forwarded to the view function reducing the code to this:\n\nBecause blueprints can automatically prefix all URLs with a common string it\u2019s\neasy to automatically do that for every function. Furthermore blueprints can\nhave per-blueprint URL processors which removes a whole lot of logic from the\n`url_defaults()` function because it no longer has to check if the URL is\nreally interested in a `'lang_code'` parameter:\n\n"}, {"name": "uWSGI", "path": "deploying/uwsgi/index", "type": "User's Guide: Deploying", "text": "\nuWSGI is a deployment option on servers like nginx, lighttpd, and cherokee;\nsee FastCGI and Standalone WSGI Containers for other options. To use your WSGI\napplication with uWSGI protocol you will need a uWSGI server first. uWSGI is\nboth a protocol and an application server; the application server can serve\nuWSGI, FastCGI, and HTTP protocols.\n\nThe most popular uWSGI server is uwsgi, which we will use for this guide. Make\nsure to have it installed to follow along.\n\nWatch Out\n\nPlease make sure in advance that any `app.run()` calls you might have in your\napplication file are inside an `if __name__ == '__main__':` block or moved to\na separate file. Just make sure it\u2019s not called because this will always start\na local WSGI server which we do not want if we deploy that application to\nuWSGI.\n\n`uwsgi` is designed to operate on WSGI callables found in python modules.\n\nGiven a flask application in myapp.py, use the following command:\n\nThe `--manage-script-name` will move the handling of `SCRIPT_NAME` to uwsgi,\nsince it is smarter about that. It is used together with the `--mount`\ndirective which will make requests to `/yourapplication` be directed to\n`myapp:app`. If your application is accessible at root level, you can use a\nsingle `/` instead of `/yourapplication`. `myapp` refers to the name of the\nfile of your flask application (without extension) or the module which\nprovides `app`. `app` is the callable inside of your application (usually the\nline reads `app = Flask(__name__)`.\n\nIf you want to deploy your flask application inside of a virtual environment,\nyou need to also add `--virtualenv /path/to/virtual/environment`. You might\nalso need to add `--plugin python` or `--plugin python3` depending on which\npython version you use for your project.\n\nA basic flask nginx configuration looks like this:\n\nThis configuration binds the application to `/yourapplication`. If you want to\nhave it in the URL root its a bit simpler:\n\n"}, {"name": "View", "path": "api/index#flask.views.View", "type": "flask.views", "text": "\nAlternative way to use view functions. A subclass has to implement\n`dispatch_request()` which is called with the view arguments from the URL\nrouting system. If `methods` is provided the methods do not have to be passed\nto the `add_url_rule()` method explicitly:\n\nWhen you want to decorate a pluggable view you will have to either do that\nwhen the view function is created (by wrapping the return value of\n`as_view()`) or you can use the `decorators` attribute:\n\nThe decorators stored in the decorators list are applied one after another\nwhen the view function is created. Note that you can not use the class based\ndecorators since those would decorate the view class and not the generated\nview function!\n\nConverts the class into an actual view function that can be used with the\nrouting system. Internally this generates a function on the fly which will\ninstantiate the `View` on each request and call the `dispatch_request()`\nmethod on it.\n\nThe arguments passed to `as_view()` are forwarded to the constructor of the\nclass.\n\nCallable\n\nThe canonical way to decorate class-based views is to decorate the return\nvalue of as_view(). However since this moves parts of the logic from the class\ndeclaration to the place where it\u2019s hooked into the routing system.\n\nYou can place one or more decorators in this list and whenever the view\nfunction is created the result is automatically decorated.\n\nNew in version 0.8.\n\nSubclasses have to override this method to implement the actual view function\ncode. This method is called with all the arguments from the URL rule.\n\nUnion[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None],\nTuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]],\nUnion[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]],\nList[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]],\nTuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]],\nint], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None,\nNone]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]],\nList[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], WSGIApplication]\n\nA list of methods this view can handle.\n\nSetting this disables or force-enables the automatic options handling.\n\n"}, {"name": "View Decorators", "path": "patterns/viewdecorators/index", "type": "User's Guide: Design Patterns", "text": "\nPython has a really interesting feature called function decorators. This\nallows some really neat things for web applications. Because each view in\nFlask is a function, decorators can be used to inject additional functionality\nto one or more functions. The `route()` decorator is the one you probably used\nalready. But there are use cases for implementing your own decorator. For\ninstance, imagine you have a view that should only be used by people that are\nlogged in. If a user goes to the site and is not logged in, they should be\nredirected to the login page. This is a good example of a use case where a\ndecorator is an excellent solution.\n\nSo let\u2019s implement such a decorator. A decorator is a function that wraps and\nreplaces another function. Since the original function is replaced, you need\nto remember to copy the original function\u2019s information to the new function.\nUse `functools.wraps()` to handle this for you.\n\nThis example assumes that the login page is called `'login'` and that the\ncurrent user is stored in `g.user` and is `None` if there is no-one logged in.\n\nTo use the decorator, apply it as innermost decorator to a view function. When\napplying further decorators, always remember that the `route()` decorator is\nthe outermost.\n\nNote\n\nThe `next` value will exist in `request.args` after a `GET` request for the\nlogin page. You\u2019ll have to pass it along when sending the `POST` request from\nthe login form. You can do this with a hidden input tag, then retrieve it from\n`request.form` when logging the user in.\n\nImagine you have a view function that does an expensive calculation and\nbecause of that you would like to cache the generated results for a certain\namount of time. A decorator would be nice for that. We\u2019re assuming you have\nset up a cache like mentioned in Caching.\n\nHere is an example cache function. It generates the cache key from a specific\nprefix (actually a format string) and the current path of the request. Notice\nthat we are using a function that first creates the decorator that then\ndecorates the function. Sounds awful? Unfortunately it is a little bit more\ncomplex, but the code should still be straightforward to read.\n\nThe decorated function will then work as follows\n\nHere the code:\n\nNotice that this assumes an instantiated `cache` object is available, see\nCaching.\n\nA common pattern invented by the TurboGears guys a while back is a templating\ndecorator. The idea of that decorator is that you return a dictionary with the\nvalues passed to the template from the view function and the template is\nautomatically rendered. With that, the following three examples do exactly the\nsame:\n\nAs you can see, if no template name is provided it will use the endpoint of\nthe URL map with dots converted to slashes + `'.html'`. Otherwise the provided\ntemplate name is used. When the decorated function returns, the dictionary\nreturned is passed to the template rendering function. If `None` is returned,\nan empty dictionary is assumed, if something else than a dictionary is\nreturned we return it from the function unchanged. That way you can still use\nthe redirect function or return simple strings.\n\nHere is the code for that decorator:\n\nWhen you want to use the werkzeug routing system for more flexibility you need\nto map the endpoint as defined in the `Rule` to a view function. This is\npossible with this decorator. For example:\n\n"}, {"name": "View.as_view()", "path": "api/index#flask.views.View.as_view", "type": "flask.views", "text": "\nConverts the class into an actual view function that can be used with the\nrouting system. Internally this generates a function on the fly which will\ninstantiate the `View` on each request and call the `dispatch_request()`\nmethod on it.\n\nThe arguments passed to `as_view()` are forwarded to the constructor of the\nclass.\n\nCallable\n\n"}, {"name": "View.decorators", "path": "api/index#flask.views.View.decorators", "type": "flask.views", "text": "\nThe canonical way to decorate class-based views is to decorate the return\nvalue of as_view(). However since this moves parts of the logic from the class\ndeclaration to the place where it\u2019s hooked into the routing system.\n\nYou can place one or more decorators in this list and whenever the view\nfunction is created the result is automatically decorated.\n\nNew in version 0.8.\n\n"}, {"name": "View.dispatch_request()", "path": "api/index#flask.views.View.dispatch_request", "type": "flask.views", "text": "\nSubclasses have to override this method to implement the actual view function\ncode. This method is called with all the arguments from the URL rule.\n\nUnion[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None],\nTuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]],\nUnion[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]],\nList[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]],\nTuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None, None]],\nint], Tuple[Union[Response, AnyStr, Dict[str, Any], Generator[AnyStr, None,\nNone]], int, Union[Headers, Dict[str, Union[str, List[str], Tuple[str, \u2026]]],\nList[Tuple[str, Union[str, List[str], Tuple[str, \u2026]]]]]], WSGIApplication]\n\n"}, {"name": "View.methods", "path": "api/index#flask.views.View.methods", "type": "flask.views", "text": "\nA list of methods this view can handle.\n\n"}, {"name": "View.provide_automatic_options", "path": "api/index#flask.views.View.provide_automatic_options", "type": "flask.views", "text": "\nSetting this disables or force-enables the automatic options handling.\n\n"}, {"name": "with_appcontext()", "path": "api/index#flask.cli.with_appcontext", "type": "flask.cli", "text": "\nWraps a callback so that it\u2019s guaranteed to be executed with the script\u2019s\napplication context. If callbacks are registered directly to the `app.cli`\nobject then they are wrapped with this function by default unless it\u2019s\ndisabled.\n\n"}, {"name": "Working with the Shell", "path": "shell/index", "type": "User\u2019s Guide", "text": "\nNew in version 0.3.\n\nOne of the reasons everybody loves Python is the interactive shell. It\nbasically allows you to execute Python commands in real time and immediately\nget results back. Flask itself does not come with an interactive shell,\nbecause it does not require any specific setup upfront, just import your\napplication and start playing around.\n\nThere are however some handy helpers to make playing around in the shell a\nmore pleasant experience. The main issue with interactive console sessions is\nthat you\u2019re not triggering a request like a browser does which means that `g`,\n`request` and others are not available. But the code you want to test might\ndepend on them, so what can you do?\n\nThis is where some helper functions come in handy. Keep in mind however that\nthese functions are not only there for interactive shell usage, but also for\nunit testing and other situations that require a faked request context.\n\nGenerally it\u2019s recommended that you read the The Request Context chapter of\nthe documentation first.\n\nStarting with Flask 0.11 the recommended way to work with the shell is the\n`flask shell` command which does a lot of this automatically for you. For\ninstance the shell is automatically initialized with a loaded application\ncontext.\n\nFor more information see Command Line Interface.\n\nThe easiest way to create a proper request context from the shell is by using\nthe `test_request_context` method which creates us a `RequestContext`:\n\nNormally you would use the `with` statement to make this request object\nactive, but in the shell it\u2019s easier to use the `push()` and `pop()` methods\nby hand:\n\nFrom that point onwards you can work with the request object until you call\n`pop`:\n\nBy just creating a request context, you still don\u2019t have run the code that is\nnormally run before a request. This might result in your database being\nunavailable if you are connecting to the database in a before-request callback\nor the current user not being stored on the `g` object etc.\n\nThis however can easily be done yourself. Just call `preprocess_request()`:\n\nKeep in mind that the `preprocess_request()` function might return a response\nobject, in that case just ignore it.\n\nTo shutdown a request, you need to trick a bit before the after request\nfunctions (triggered by `process_response()`) operate on a response object:\n\nThe functions registered as `teardown_request()` are automatically called when\nthe context is popped. So this is the perfect place to automatically tear down\nresources that were needed by the request context (such as database\nconnections).\n\nIf you like the idea of experimenting in a shell, create yourself a module\nwith stuff you want to star import into your interactive session. There you\ncould also define some more helper methods for common things such as\ninitializing the database, dropping tables etc.\n\nJust put them into a module (like `shelltools`) and import from there:\n\n"}, {"name": "_AppCtxGlobals", "path": "api/index#flask.ctx._AppCtxGlobals", "type": "flask.ctx", "text": "\nA plain object. Used as a namespace for storing data during an application\ncontext.\n\nCreating an app context automatically creates this object, which is made\navailable as the `g` proxy.\n\nCheck whether an attribute is present.\n\nNew in version 0.10.\n\nReturn an iterator over the attribute names.\n\nNew in version 0.10.\n\nGet an attribute by name, or a default value. Like `dict.get()`.\n\nAny\n\nNew in version 0.10.\n\nGet and remove an attribute by name. Like `dict.pop()`.\n\nAny\n\nNew in version 0.11.\n\nGet the value of an attribute if it is present, otherwise set and return a\ndefault value. Like `dict.setdefault()`.\n\nAny\n\nNew in version 0.11.\n\n"}, {"name": "_AppCtxGlobals.get()", "path": "api/index#flask.ctx._AppCtxGlobals.get", "type": "flask.ctx", "text": "\nGet an attribute by name, or a default value. Like `dict.get()`.\n\nAny\n\nNew in version 0.10.\n\n"}, {"name": "_AppCtxGlobals.pop()", "path": "api/index#flask.ctx._AppCtxGlobals.pop", "type": "flask.ctx", "text": "\nGet and remove an attribute by name. Like `dict.pop()`.\n\nAny\n\nNew in version 0.11.\n\n"}, {"name": "_AppCtxGlobals.setdefault()", "path": "api/index#flask.ctx._AppCtxGlobals.setdefault", "type": "flask.ctx", "text": "\nGet the value of an attribute if it is present, otherwise set and return a\ndefault value. Like `dict.setdefault()`.\n\nAny\n\nNew in version 0.11.\n\n"}]