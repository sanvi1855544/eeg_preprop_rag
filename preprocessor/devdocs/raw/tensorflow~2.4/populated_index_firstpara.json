[{"name": "tf.AggregationMethod", "path": "aggregationmethod", "type": "tf", "text": "\nA class listing aggregation methods used to combine gradients.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.argsort", "path": "argsort", "type": "tf", "text": "\nReturns the indices of a tensor that give its sorted order along an axis.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.audio", "path": "audio", "type": "tf.audio", "text": "\nPublic API for tf.audio namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.audio.decode_wav", "path": "audio/decode_wav", "type": "tf.audio", "text": "\nDecode a 16-bit PCM WAV file to a float tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.audio.encode_wav", "path": "audio/encode_wav", "type": "tf.audio", "text": "\nEncode audio data using the WAV file format.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.autodiff", "path": "autodiff", "type": "tf.autodiff", "text": "\nPublic API for tf.autodiff namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.autodiff.ForwardAccumulator", "path": "autodiff/forwardaccumulator", "type": "tf.autodiff", "text": "\nComputes Jacobian-vector products (\"JVP\"s) using forward-mode autodiff.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.autograph", "path": "autograph", "type": "tf.autograph", "text": "\nConversion of plain Python into TensorFlow graph code.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.autograph.experimental", "path": "autograph/experimental", "type": "tf.autograph", "text": "\nPublic API for tf.autograph.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.autograph.experimental.do_not_convert", "path": "autograph/experimental/do_not_convert", "type": "tf.autograph", "text": "\nDecorator that suppresses the conversion of a function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.autograph.experimental.Feature", "path": "autograph/experimental/feature", "type": "tf.autograph", "text": "\nThis enumeration represents optional conversion options.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.autograph.experimental.set_loop_options", "path": "autograph/experimental/set_loop_options", "type": "tf.autograph", "text": "\nSpecifies additional arguments to be passed to the enclosing while_loop.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.autograph.set_verbosity", "path": "autograph/set_verbosity", "type": "tf.autograph", "text": "\nSets the AutoGraph verbosity level.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.autograph.to_code", "path": "autograph/to_code", "type": "tf.autograph", "text": "\nReturns the source code generated by AutoGraph, as a string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.autograph.to_graph", "path": "autograph/to_graph", "type": "tf.autograph", "text": "\nConverts a Python entity into a TensorFlow graph.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.autograph.trace", "path": "autograph/trace", "type": "tf.autograph", "text": "\nTraces argument information at compilation time.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.batch_to_space", "path": "batch_to_space", "type": "tf", "text": "\nBatchToSpace for N-D tensors of type T.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.bitcast", "path": "bitcast", "type": "tf", "text": "\nBitcasts a tensor from one type to another without copying data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.bitwise", "path": "bitwise", "type": "tf.bitwise", "text": "\nOperations for manipulating the binary representations of integers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.bitwise.bitwise_and", "path": "bitwise/bitwise_and", "type": "tf.bitwise", "text": "\nElementwise computes the bitwise AND of `x` and `y`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.bitwise.bitwise_or", "path": "bitwise/bitwise_or", "type": "tf.bitwise", "text": "\nElementwise computes the bitwise OR of `x` and `y`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.bitwise.bitwise_xor", "path": "bitwise/bitwise_xor", "type": "tf.bitwise", "text": "\nElementwise computes the bitwise XOR of `x` and `y`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.bitwise.invert", "path": "bitwise/invert", "type": "tf.bitwise", "text": "\nInvert (flip) each bit of supported types; for example, type `uint8` value\n01010101 becomes 10101010.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.bitwise.left_shift", "path": "bitwise/left_shift", "type": "tf.bitwise", "text": "\nElementwise computes the bitwise left-shift of `x` and `y`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.bitwise.right_shift", "path": "bitwise/right_shift", "type": "tf.bitwise", "text": "\nElementwise computes the bitwise right-shift of `x` and `y`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.boolean_mask", "path": "boolean_mask", "type": "tf", "text": "\nApply boolean mask to tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.broadcast_dynamic_shape", "path": "broadcast_dynamic_shape", "type": "tf", "text": "\nComputes the shape of a broadcast given symbolic shapes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.broadcast_static_shape", "path": "broadcast_static_shape", "type": "tf", "text": "\nComputes the shape of a broadcast given known shapes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.broadcast_to", "path": "broadcast_to", "type": "tf", "text": "\nBroadcast an array for a compatible shape.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.case", "path": "case", "type": "tf", "text": "\nCreate a case operation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.cast", "path": "cast", "type": "tf", "text": "\nCasts a tensor to a new type.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.clip_by_global_norm", "path": "clip_by_global_norm", "type": "tf", "text": "\nClips values of multiple tensors by the ratio of the sum of their norms.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.clip_by_norm", "path": "clip_by_norm", "type": "tf", "text": "\nClips tensor values to a maximum L2-norm.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.clip_by_value", "path": "clip_by_value", "type": "tf", "text": "\nClips tensor values to a specified min and max.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat", "path": "compat", "type": "tf.compat", "text": "\nCompatibility functions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.as_bytes", "path": "compat/as_bytes", "type": "tf.compat", "text": "\nConverts `bytearray`, `bytes`, or unicode python input types to `bytes`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.as_str", "path": "compat/as_str", "type": "tf.compat", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.as_str_any", "path": "compat/as_str_any", "type": "tf.compat", "text": "\nConverts input to `str` type.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.as_text", "path": "compat/as_text", "type": "tf.compat", "text": "\nConverts any string-like python input types to unicode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.dimension_at_index", "path": "compat/dimension_at_index", "type": "tf.compat", "text": "\nCompatibility utility required to allow for both V1 and V2 behavior in TF.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.dimension_value", "path": "compat/dimension_value", "type": "tf.compat", "text": "\nCompatibility utility required to allow for both V1 and V2 behavior in TF.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.forward_compatibility_horizon", "path": "compat/forward_compatibility_horizon", "type": "tf.compat", "text": "\nContext manager for testing forward compatibility of generated graphs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.forward_compatible", "path": "compat/forward_compatible", "type": "tf.compat", "text": "\nReturn true if the forward compatibility window has expired.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.path_to_str", "path": "compat/path_to_str", "type": "tf.compat", "text": "\nConverts input which is a `PathLike` object to `str` type.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1", "path": "compat/v1", "type": "tf.compat", "text": "\nBring in all of the public TensorFlow interface into this module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.add_check_numerics_ops", "path": "compat/v1/add_check_numerics_ops", "type": "tf.compat", "text": "\nConnect a `tf.debugging.check_numerics` to every floating point tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.add_to_collection", "path": "compat/v1/add_to_collection", "type": "tf.compat", "text": "\nWrapper for `Graph.add_to_collection()` using the default graph.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.add_to_collections", "path": "compat/v1/add_to_collections", "type": "tf.compat", "text": "\nWrapper for `Graph.add_to_collections()` using the default graph.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.all_variables", "path": "compat/v1/all_variables", "type": "tf.compat", "text": "\nUse `tf.compat.v1.global_variables` instead. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.app", "path": "compat/v1/app", "type": "tf.compat", "text": "\nGeneric entry point script.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.app.run", "path": "compat/v1/app/run", "type": "tf.compat", "text": "\nRuns the program with an optional 'main' function and 'argv' list.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.argmax", "path": "compat/v1/argmax", "type": "tf.compat", "text": "\nReturns the index with the largest value across axes of a tensor. (deprecated\narguments)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.argmin", "path": "compat/v1/argmin", "type": "tf.compat", "text": "\nReturns the index with the smallest value across axes of a tensor. (deprecated\narguments)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.arg_max", "path": "compat/v1/arg_max", "type": "tf.compat", "text": "\nReturns the index with the largest value across dimensions of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.arg_min", "path": "compat/v1/arg_min", "type": "tf.compat", "text": "\nReturns the index with the smallest value across dimensions of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.assert_equal", "path": "compat/v1/assert_equal", "type": "tf.compat", "text": "\nAssert the condition `x == y` holds element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.assert_greater", "path": "compat/v1/assert_greater", "type": "tf.compat", "text": "\nAssert the condition `x > y` holds element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.assert_greater_equal", "path": "compat/v1/assert_greater_equal", "type": "tf.compat", "text": "\nAssert the condition `x >= y` holds element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.assert_integer", "path": "compat/v1/assert_integer", "type": "tf.compat", "text": "\nAssert that `x` is of integer dtype.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.assert_less", "path": "compat/v1/assert_less", "type": "tf.compat", "text": "\nAssert the condition `x < y` holds element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.assert_less_equal", "path": "compat/v1/assert_less_equal", "type": "tf.compat", "text": "\nAssert the condition `x <= y` holds element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.assert_near", "path": "compat/v1/assert_near", "type": "tf.compat", "text": "\nAssert the condition `x` and `y` are close element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.assert_negative", "path": "compat/v1/assert_negative", "type": "tf.compat", "text": "\nAssert the condition `x < 0` holds element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.assert_none_equal", "path": "compat/v1/assert_none_equal", "type": "tf.compat", "text": "\nAssert the condition `x != y` holds element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.assert_non_negative", "path": "compat/v1/assert_non_negative", "type": "tf.compat", "text": "\nAssert the condition `x >= 0` holds element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.assert_non_positive", "path": "compat/v1/assert_non_positive", "type": "tf.compat", "text": "\nAssert the condition `x <= 0` holds element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.assert_positive", "path": "compat/v1/assert_positive", "type": "tf.compat", "text": "\nAssert the condition `x > 0` holds element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.assert_rank", "path": "compat/v1/assert_rank", "type": "tf.compat", "text": "\nAssert `x` has rank equal to `rank`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.assert_rank_at_least", "path": "compat/v1/assert_rank_at_least", "type": "tf.compat", "text": "\nAssert `x` has rank equal to `rank` or higher.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.assert_rank_in", "path": "compat/v1/assert_rank_in", "type": "tf.compat", "text": "\nAssert `x` has rank in `ranks`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.assert_scalar", "path": "compat/v1/assert_scalar", "type": "tf.compat", "text": "\nAsserts that the given `tensor` is a scalar (i.e. zero-dimensional).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.assert_type", "path": "compat/v1/assert_type", "type": "tf.compat", "text": "\nStatically asserts that the given `Tensor` is of the specified type.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.assert_variables_initialized", "path": "compat/v1/assert_variables_initialized", "type": "tf.compat", "text": "\nReturns an Op to check if variables are initialized.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.assign", "path": "compat/v1/assign", "type": "tf.compat", "text": "\nUpdate `ref` by assigning `value` to it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.assign_add", "path": "compat/v1/assign_add", "type": "tf.compat", "text": "\nUpdate `ref` by adding `value` to it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.assign_sub", "path": "compat/v1/assign_sub", "type": "tf.compat", "text": "\nUpdate `ref` by subtracting `value` from it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.AttrValue", "path": "compat/v1/attrvalue", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.AttrValue.ListValue", "path": "compat/v1/attrvalue/listvalue", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.audio", "path": "compat/v1/audio", "type": "tf.compat", "text": "\nPublic API for tf.audio namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.autograph", "path": "compat/v1/autograph", "type": "tf.compat", "text": "\nConversion of plain Python into TensorFlow graph code.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.autograph.experimental", "path": "compat/v1/autograph/experimental", "type": "tf.compat", "text": "\nPublic API for tf.autograph.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.autograph.to_code", "path": "compat/v1/autograph/to_code", "type": "tf.compat", "text": "\nReturns the source code generated by AutoGraph, as a string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.autograph.to_graph", "path": "compat/v1/autograph/to_graph", "type": "tf.compat", "text": "\nConverts a Python entity into a TensorFlow graph.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.batch_gather", "path": "compat/v1/batch_gather", "type": "tf.compat", "text": "\nGather slices from params according to indices with leading batch dims.\n(deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.batch_scatter_update", "path": "compat/v1/batch_scatter_update", "type": "tf.compat", "text": "\nGeneralization of `tf.compat.v1.scatter_update` to axis different than 0.\n(deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.batch_to_space", "path": "compat/v1/batch_to_space", "type": "tf.compat", "text": "\nBatchToSpace for 4-D tensors of type T.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.batch_to_space_nd", "path": "compat/v1/batch_to_space_nd", "type": "tf.compat", "text": "\nBatchToSpace for N-D tensors of type T.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.bincount", "path": "compat/v1/bincount", "type": "tf.compat", "text": "\nCounts the number of occurrences of each value in an integer array.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.bitwise", "path": "compat/v1/bitwise", "type": "tf.compat", "text": "\nOperations for manipulating the binary representations of integers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.boolean_mask", "path": "compat/v1/boolean_mask", "type": "tf.compat", "text": "\nApply boolean mask to tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.case", "path": "compat/v1/case", "type": "tf.compat", "text": "\nCreate a case operation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.clip_by_average_norm", "path": "compat/v1/clip_by_average_norm", "type": "tf.compat", "text": "\nClips tensor values to a maximum average L2-norm. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.colocate_with", "path": "compat/v1/colocate_with", "type": "tf.compat", "text": "\nDEPRECATED FUNCTION\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.compat", "path": "compat/v1/compat", "type": "tf.compat", "text": "\nCompatibility functions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.cond", "path": "compat/v1/cond", "type": "tf.compat", "text": "\nReturn `true_fn()` if the predicate `pred` is true else `false_fn()`.\n(deprecated arguments)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.ConditionalAccumulator", "path": "compat/v1/conditionalaccumulator", "type": "tf.compat", "text": "\nA conditional accumulator for aggregating gradients.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.ConditionalAccumulatorBase", "path": "compat/v1/conditionalaccumulatorbase", "type": "tf.compat", "text": "\nA conditional accumulator for aggregating gradients.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.config", "path": "compat/v1/config", "type": "tf.compat", "text": "\nPublic API for tf.config namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.config.experimental", "path": "compat/v1/config/experimental", "type": "tf.compat", "text": "\nPublic API for tf.config.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.config.optimizer", "path": "compat/v1/config/optimizer", "type": "tf.compat", "text": "\nPublic API for tf.config.optimizer namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.config.threading", "path": "compat/v1/config/threading", "type": "tf.compat", "text": "\nPublic API for tf.config.threading namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.ConfigProto", "path": "compat/v1/configproto", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.ConfigProto.DeviceCountEntry", "path": "compat/v1/configproto/devicecountentry", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.ConfigProto.Experimental", "path": "compat/v1/configproto/experimental", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.confusion_matrix", "path": "compat/v1/confusion_matrix", "type": "tf.compat", "text": "\nComputes the confusion matrix from predictions and labels.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.constant", "path": "compat/v1/constant", "type": "tf.compat", "text": "\nCreates a constant tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.container", "path": "compat/v1/container", "type": "tf.compat", "text": "\nWrapper for `Graph.container()` using the default graph.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.control_flow_v2_enabled", "path": "compat/v1/control_flow_v2_enabled", "type": "tf.compat", "text": "\nReturns `True` if v2 control flow is enabled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.convert_to_tensor", "path": "compat/v1/convert_to_tensor", "type": "tf.compat", "text": "\nConverts the given `value` to a `Tensor`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.convert_to_tensor_or_indexed_slices", "path": "compat/v1/convert_to_tensor_or_indexed_slices", "type": "tf.compat", "text": "\nConverts the given object to a `Tensor` or an `IndexedSlices`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.convert_to_tensor_or_sparse_tensor", "path": "compat/v1/convert_to_tensor_or_sparse_tensor", "type": "tf.compat", "text": "\nConverts value to a `SparseTensor` or `Tensor`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.count_nonzero", "path": "compat/v1/count_nonzero", "type": "tf.compat", "text": "\nComputes number of nonzero elements across dimensions of a tensor. (deprecated\narguments) (deprecated arguments)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.count_up_to", "path": "compat/v1/count_up_to", "type": "tf.compat", "text": "\nIncrements 'ref' until it reaches 'limit'. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.create_partitioned_variables", "path": "compat/v1/create_partitioned_variables", "type": "tf.compat", "text": "\nCreate a list of partitioned variables according to the given `slicing`.\n(deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.data", "path": "compat/v1/data", "type": "tf.compat", "text": "\n`tf.data.Dataset` API for input pipelines.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.data.Dataset", "path": "compat/v1/data/dataset", "type": "tf.compat", "text": "\nRepresents a potentially large set of elements.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.data.experimental", "path": "compat/v1/data/experimental", "type": "tf.compat", "text": "\nExperimental API for building input pipelines.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.data.experimental.choose_from_datasets", "path": "compat/v1/data/experimental/choose_from_datasets", "type": "tf.compat", "text": "\nCreates a dataset that deterministically chooses elements from `datasets`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.data.experimental.Counter", "path": "compat/v1/data/experimental/counter", "type": "tf.compat", "text": "\nCreates a `Dataset` that counts from `start` in steps of size `step`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.data.experimental.CsvDataset", "path": "compat/v1/data/experimental/csvdataset", "type": "tf.compat", "text": "\nA Dataset comprising lines from one or more CSV files.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.data.experimental.make_batched_features_dataset", "path": "compat/v1/data/experimental/make_batched_features_dataset", "type": "tf.compat", "text": "\nReturns a `Dataset` of feature dictionaries from `Example` protos.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.data.experimental.make_csv_dataset", "path": "compat/v1/data/experimental/make_csv_dataset", "type": "tf.compat", "text": "\nReads CSV files into a dataset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.data.experimental.map_and_batch_with_legacy_function", "path": "compat/v1/data/experimental/map_and_batch_with_legacy_function", "type": "tf.compat", "text": "\nFused implementation of `map` and `batch`. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.data.experimental.RaggedTensorStructure", "path": "compat/v1/data/experimental/raggedtensorstructure", "type": "tf.compat", "text": "\nDEPRECATED FUNCTION\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.data.experimental.RandomDataset", "path": "compat/v1/data/experimental/randomdataset", "type": "tf.compat", "text": "\nA `Dataset` of pseudorandom values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.data.experimental.sample_from_datasets", "path": "compat/v1/data/experimental/sample_from_datasets", "type": "tf.compat", "text": "\nSamples elements at random from the datasets in `datasets`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.data.experimental.service", "path": "compat/v1/data/experimental/service", "type": "tf.compat", "text": "\nAPI for using the tf.data service.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.data.experimental.SparseTensorStructure", "path": "compat/v1/data/experimental/sparsetensorstructure", "type": "tf.compat", "text": "\nDEPRECATED FUNCTION\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.data.experimental.SqlDataset", "path": "compat/v1/data/experimental/sqldataset", "type": "tf.compat", "text": "\nA `Dataset` consisting of the results from a SQL query.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.data.experimental.StatsAggregator", "path": "compat/v1/data/experimental/statsaggregator", "type": "tf.compat", "text": "\nA stateful resource that aggregates statistics from one or more iterators.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.data.experimental.TensorArrayStructure", "path": "compat/v1/data/experimental/tensorarraystructure", "type": "tf.compat", "text": "\nDEPRECATED FUNCTION\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.data.experimental.TensorStructure", "path": "compat/v1/data/experimental/tensorstructure", "type": "tf.compat", "text": "\nDEPRECATED FUNCTION\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.data.FixedLengthRecordDataset", "path": "compat/v1/data/fixedlengthrecorddataset", "type": "tf.compat", "text": "\nA `Dataset` of fixed-length records from one or more binary files.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.data.get_output_classes", "path": "compat/v1/data/get_output_classes", "type": "tf.compat", "text": "\nReturns the output classes for elements of the input dataset / iterator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.data.get_output_shapes", "path": "compat/v1/data/get_output_shapes", "type": "tf.compat", "text": "\nReturns the output shapes for elements of the input dataset / iterator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.data.get_output_types", "path": "compat/v1/data/get_output_types", "type": "tf.compat", "text": "\nReturns the output shapes for elements of the input dataset / iterator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.data.Iterator", "path": "compat/v1/data/iterator", "type": "tf.compat", "text": "\nRepresents the state of iterating through a `Dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.data.make_initializable_iterator", "path": "compat/v1/data/make_initializable_iterator", "type": "tf.compat", "text": "\nCreates an iterator for elements of `dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.data.make_one_shot_iterator", "path": "compat/v1/data/make_one_shot_iterator", "type": "tf.compat", "text": "\nCreates an iterator for elements of `dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.data.TextLineDataset", "path": "compat/v1/data/textlinedataset", "type": "tf.compat", "text": "\nA `Dataset` comprising lines from one or more text files.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.data.TFRecordDataset", "path": "compat/v1/data/tfrecorddataset", "type": "tf.compat", "text": "\nA `Dataset` comprising records from one or more TFRecord files.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.debugging", "path": "compat/v1/debugging", "type": "tf.compat", "text": "\nPublic API for tf.debugging namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.debugging.assert_shapes", "path": "compat/v1/debugging/assert_shapes", "type": "tf.compat", "text": "\nAssert tensor shapes and dimension size relationships between tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.debugging.experimental", "path": "compat/v1/debugging/experimental", "type": "tf.compat", "text": "\nPublic API for tf.debugging.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.decode_csv", "path": "compat/v1/decode_csv", "type": "tf.compat", "text": "\nConvert CSV records to tensors. Each column maps to one tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.decode_raw", "path": "compat/v1/decode_raw", "type": "tf.compat", "text": "\nConvert raw byte strings into tensors. (deprecated arguments)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.delete_session_tensor", "path": "compat/v1/delete_session_tensor", "type": "tf.compat", "text": "\nDelete the tensor for the given tensor handle.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.depth_to_space", "path": "compat/v1/depth_to_space", "type": "tf.compat", "text": "\nDepthToSpace for tensors of type T.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.device", "path": "compat/v1/device", "type": "tf.compat", "text": "\nWrapper for `Graph.device()` using the default graph.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.DeviceSpec", "path": "compat/v1/devicespec", "type": "tf.compat", "text": "\nRepresents a (possibly partial) specification for a TensorFlow device.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.Dimension", "path": "compat/v1/dimension", "type": "tf.compat", "text": "\nRepresents the value of one dimension in a TensorShape.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.disable_control_flow_v2", "path": "compat/v1/disable_control_flow_v2", "type": "tf.compat", "text": "\nOpts out of control flow v2.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.disable_eager_execution", "path": "compat/v1/disable_eager_execution", "type": "tf.compat", "text": "\nDisables eager execution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.disable_resource_variables", "path": "compat/v1/disable_resource_variables", "type": "tf.compat", "text": "\nOpts out of resource variables. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.disable_tensor_equality", "path": "compat/v1/disable_tensor_equality", "type": "tf.compat", "text": "\nCompare Tensors by their id and be hashable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.disable_v2_behavior", "path": "compat/v1/disable_v2_behavior", "type": "tf.compat", "text": "\nDisables TensorFlow 2.x behaviors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.disable_v2_tensorshape", "path": "compat/v1/disable_v2_tensorshape", "type": "tf.compat", "text": "\nDisables the V2 TensorShape behavior and reverts to V1 behavior.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.distribute", "path": "compat/v1/distribute", "type": "tf.compat", "text": "\nLibrary for running a computation across multiple devices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.distribute.cluster_resolver", "path": "compat/v1/distribute/cluster_resolver", "type": "tf.compat", "text": "\nLibrary imports for ClusterResolvers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.distribute.experimental", "path": "compat/v1/distribute/experimental", "type": "tf.compat", "text": "\nPublic API for tf.distribute.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.distribute.experimental.CentralStorageStrategy", "path": "compat/v1/distribute/experimental/centralstoragestrategy", "type": "tf.compat", "text": "\nA one-machine strategy that puts all variables on a single device.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.distribute.experimental.MultiWorkerMirroredStrategy", "path": "compat/v1/distribute/experimental/multiworkermirroredstrategy", "type": "tf.compat", "text": "\nA distribution strategy for synchronous training on multiple workers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.distribute.experimental.ParameterServerStrategy", "path": "compat/v1/distribute/experimental/parameterserverstrategy", "type": "tf.compat", "text": "\nAn asynchronous multi-worker parameter server tf.distribute strategy.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.distribute.experimental.TPUStrategy", "path": "compat/v1/distribute/experimental/tpustrategy", "type": "tf.compat", "text": "\nTPU distribution strategy implementation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.distribute.get_loss_reduction", "path": "compat/v1/distribute/get_loss_reduction", "type": "tf.compat", "text": "\n`tf.distribute.ReduceOp` corresponding to the last loss reduction.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.distribute.MirroredStrategy", "path": "compat/v1/distribute/mirroredstrategy", "type": "tf.compat", "text": "\nSynchronous training across multiple replicas on one machine.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.distribute.OneDeviceStrategy", "path": "compat/v1/distribute/onedevicestrategy", "type": "tf.compat", "text": "\nA distribution strategy for running on a single device.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.distribute.ReplicaContext", "path": "compat/v1/distribute/replicacontext", "type": "tf.compat", "text": "\nA class with a collection of APIs that can be called in a replica context.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.distribute.Strategy", "path": "compat/v1/distribute/strategy", "type": "tf.compat", "text": "\nA list of devices with a state & compute distribution policy.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.distribute.StrategyExtended", "path": "compat/v1/distribute/strategyextended", "type": "tf.compat", "text": "\nAdditional APIs for algorithms that need to be distribution-aware.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.distributions", "path": "compat/v1/distributions", "type": "tf.compat", "text": "\nCore module for TensorFlow distribution objects and helpers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.distributions.Bernoulli", "path": "compat/v1/distributions/bernoulli", "type": "tf.compat", "text": "\nBernoulli distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.distributions.Beta", "path": "compat/v1/distributions/beta", "type": "tf.compat", "text": "\nBeta distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.distributions.Categorical", "path": "compat/v1/distributions/categorical", "type": "tf.compat", "text": "\nCategorical distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.distributions.Dirichlet", "path": "compat/v1/distributions/dirichlet", "type": "tf.compat", "text": "\nDirichlet distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.distributions.DirichletMultinomial", "path": "compat/v1/distributions/dirichletmultinomial", "type": "tf.compat", "text": "\nDirichlet-Multinomial compound distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.distributions.Distribution", "path": "compat/v1/distributions/distribution", "type": "tf.compat", "text": "\nA generic probability distribution base class.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.distributions.Exponential", "path": "compat/v1/distributions/exponential", "type": "tf.compat", "text": "\nExponential distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.distributions.Gamma", "path": "compat/v1/distributions/gamma", "type": "tf.compat", "text": "\nGamma distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.distributions.kl_divergence", "path": "compat/v1/distributions/kl_divergence", "type": "tf.compat", "text": "\nGet the KL-divergence KL(distribution_a || distribution_b). (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.distributions.Laplace", "path": "compat/v1/distributions/laplace", "type": "tf.compat", "text": "\nThe Laplace distribution with location `loc` and `scale` parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.distributions.Multinomial", "path": "compat/v1/distributions/multinomial", "type": "tf.compat", "text": "\nMultinomial distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.distributions.Normal", "path": "compat/v1/distributions/normal", "type": "tf.compat", "text": "\nThe Normal distribution with location `loc` and `scale` parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.distributions.RegisterKL", "path": "compat/v1/distributions/registerkl", "type": "tf.compat", "text": "\nDecorator to register a KL divergence implementation function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.distributions.ReparameterizationType", "path": "compat/v1/distributions/reparameterizationtype", "type": "tf.compat", "text": "\nInstances of this class represent how sampling is reparameterized.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.distributions.StudentT", "path": "compat/v1/distributions/studentt", "type": "tf.compat", "text": "\nStudent's t-distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.distributions.Uniform", "path": "compat/v1/distributions/uniform", "type": "tf.compat", "text": "\nUniform distribution with `low` and `high` parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.dtypes", "path": "compat/v1/dtypes", "type": "tf.compat", "text": "\nPublic API for tf.dtypes namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.enable_control_flow_v2", "path": "compat/v1/enable_control_flow_v2", "type": "tf.compat", "text": "\nUse control flow v2.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.enable_eager_execution", "path": "compat/v1/enable_eager_execution", "type": "tf.compat", "text": "\nEnables eager execution for the lifetime of this program.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.enable_resource_variables", "path": "compat/v1/enable_resource_variables", "type": "tf.compat", "text": "\nCreates resource variables by default.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.enable_tensor_equality", "path": "compat/v1/enable_tensor_equality", "type": "tf.compat", "text": "\nCompare Tensors with element-wise comparison and thus be unhashable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.enable_v2_behavior", "path": "compat/v1/enable_v2_behavior", "type": "tf.compat", "text": "\nEnables TensorFlow 2.x behaviors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.enable_v2_tensorshape", "path": "compat/v1/enable_v2_tensorshape", "type": "tf.compat", "text": "\nIn TensorFlow 2.0, iterating over a TensorShape instance returns values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.errors", "path": "compat/v1/errors", "type": "tf.compat", "text": "\nException types for TensorFlow errors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.errors.error_code_from_exception_type", "path": "compat/v1/errors/error_code_from_exception_type", "type": "tf.compat", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.errors.exception_type_from_error_code", "path": "compat/v1/errors/exception_type_from_error_code", "type": "tf.compat", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.errors.raise_exception_on_not_ok_status", "path": "compat/v1/errors/raise_exception_on_not_ok_status", "type": "tf.compat", "text": "\nContext manager to check for C API status.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.estimator", "path": "compat/v1/estimator", "type": "tf.compat", "text": "\nEstimator: High level tools for working with models.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.estimator.BaselineClassifier", "path": "compat/v1/estimator/baselineclassifier", "type": "tf.compat", "text": "\nA classifier that can establish a simple baseline.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.estimator.BaselineEstimator", "path": "compat/v1/estimator/baselineestimator", "type": "tf.compat", "text": "\nAn estimator that can establish a simple baseline.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.estimator.BaselineRegressor", "path": "compat/v1/estimator/baselineregressor", "type": "tf.compat", "text": "\nA regressor that can establish a simple baseline.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.estimator.classifier_parse_example_spec", "path": "compat/v1/estimator/classifier_parse_example_spec", "type": "tf.compat", "text": "\nGenerates parsing spec for tf.parse_example to be used with classifiers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.estimator.DNNClassifier", "path": "compat/v1/estimator/dnnclassifier", "type": "tf.compat", "text": "\nA classifier for TensorFlow DNN models.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.estimator.DNNEstimator", "path": "compat/v1/estimator/dnnestimator", "type": "tf.compat", "text": "\nAn estimator for TensorFlow DNN models with user-specified head.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.estimator.DNNLinearCombinedClassifier", "path": "compat/v1/estimator/dnnlinearcombinedclassifier", "type": "tf.compat", "text": "\nAn estimator for TensorFlow Linear and DNN joined classification models.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.estimator.DNNLinearCombinedEstimator", "path": "compat/v1/estimator/dnnlinearcombinedestimator", "type": "tf.compat", "text": "\nAn estimator for TensorFlow Linear and DNN joined models with custom head.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.estimator.DNNLinearCombinedRegressor", "path": "compat/v1/estimator/dnnlinearcombinedregressor", "type": "tf.compat", "text": "\nAn estimator for TensorFlow Linear and DNN joined models for regression.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.estimator.DNNRegressor", "path": "compat/v1/estimator/dnnregressor", "type": "tf.compat", "text": "\nA regressor for TensorFlow DNN models.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.estimator.Estimator", "path": "compat/v1/estimator/estimator", "type": "tf.compat", "text": "\nEstimator class to train and evaluate TensorFlow models.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.estimator.experimental", "path": "compat/v1/estimator/experimental", "type": "tf.compat", "text": "\nPublic API for tf.estimator.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.estimator.experimental.dnn_logit_fn_builder", "path": "compat/v1/estimator/experimental/dnn_logit_fn_builder", "type": "tf.compat", "text": "\nFunction builder for a dnn logit_fn.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.estimator.experimental.KMeans", "path": "compat/v1/estimator/experimental/kmeans", "type": "tf.compat", "text": "\nAn Estimator for K-Means clustering.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.estimator.experimental.linear_logit_fn_builder", "path": "compat/v1/estimator/experimental/linear_logit_fn_builder", "type": "tf.compat", "text": "\nFunction builder for a linear logit_fn.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.estimator.export", "path": "compat/v1/estimator/export", "type": "tf.compat", "text": "\nAll public utility methods for exporting Estimator to SavedModel.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.estimator.inputs", "path": "compat/v1/estimator/inputs", "type": "tf.compat", "text": "\nUtility methods to create simple input_fns.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.estimator.inputs.numpy_input_fn", "path": "compat/v1/estimator/inputs/numpy_input_fn", "type": "tf.compat", "text": "\nReturns input function that would feed dict of numpy arrays into the model.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.estimator.inputs.pandas_input_fn", "path": "compat/v1/estimator/inputs/pandas_input_fn", "type": "tf.compat", "text": "\nReturns input function that would feed Pandas DataFrame into the model.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.estimator.LinearClassifier", "path": "compat/v1/estimator/linearclassifier", "type": "tf.compat", "text": "\nLinear classifier model.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.estimator.LinearEstimator", "path": "compat/v1/estimator/linearestimator", "type": "tf.compat", "text": "\nAn estimator for TensorFlow linear models with user-specified head.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.estimator.LinearRegressor", "path": "compat/v1/estimator/linearregressor", "type": "tf.compat", "text": "\nAn estimator for TensorFlow Linear regression problems.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.estimator.regressor_parse_example_spec", "path": "compat/v1/estimator/regressor_parse_example_spec", "type": "tf.compat", "text": "\nGenerates parsing spec for tf.parse_example to be used with regressors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.estimator.tpu", "path": "compat/v1/estimator/tpu", "type": "tf.compat", "text": "\nPublic API for tf.estimator.tpu namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.estimator.tpu.experimental", "path": "compat/v1/estimator/tpu/experimental", "type": "tf.compat", "text": "\nPublic API for tf.estimator.tpu.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.estimator.tpu.experimental.EmbeddingConfigSpec", "path": "compat/v1/estimator/tpu/experimental/embeddingconfigspec", "type": "tf.compat", "text": "\nClass to keep track of the specification for TPU embeddings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.estimator.tpu.InputPipelineConfig", "path": "compat/v1/estimator/tpu/inputpipelineconfig", "type": "tf.compat", "text": "\nPlease see the definition of these values in TPUConfig.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.estimator.tpu.RunConfig", "path": "compat/v1/estimator/tpu/runconfig", "type": "tf.compat", "text": "\nRunConfig with TPU support.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.estimator.tpu.TPUConfig", "path": "compat/v1/estimator/tpu/tpuconfig", "type": "tf.compat", "text": "\nTPU related configuration required by `TPUEstimator`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.estimator.tpu.TPUEstimator", "path": "compat/v1/estimator/tpu/tpuestimator", "type": "tf.compat", "text": "\nEstimator with TPU support.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.estimator.tpu.TPUEstimatorSpec", "path": "compat/v1/estimator/tpu/tpuestimatorspec", "type": "tf.compat", "text": "\nOps and objects returned from a `model_fn` and passed to `TPUEstimator`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.Event", "path": "compat/v1/event", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.executing_eagerly", "path": "compat/v1/executing_eagerly", "type": "tf.compat", "text": "\nChecks whether the current thread has eager execution enabled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.executing_eagerly_outside_functions", "path": "compat/v1/executing_eagerly_outside_functions", "type": "tf.compat", "text": "\nReturns True if executing eagerly, even if inside a graph function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.expand_dims", "path": "compat/v1/expand_dims", "type": "tf.compat", "text": "\nReturns a tensor with a length 1 axis inserted at index `axis`. (deprecated\narguments)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.experimental", "path": "compat/v1/experimental", "type": "tf.compat", "text": "\nPublic API for tf.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.experimental.output_all_intermediates", "path": "compat/v1/experimental/output_all_intermediates", "type": "tf.compat", "text": "\nWhether to output all intermediates from functional control flow ops.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.extract_image_patches", "path": "compat/v1/extract_image_patches", "type": "tf.compat", "text": "\nExtract `patches` from `images` and put them in the \"depth\" output dimension.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.feature_column", "path": "compat/v1/feature_column", "type": "tf.compat", "text": "\nPublic API for tf.feature_column namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.feature_column.categorical_column_with_vocabulary_file", "path": "compat/v1/feature_column/categorical_column_with_vocabulary_file", "type": "tf.compat", "text": "\nA `CategoricalColumn` with a vocabulary file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.feature_column.input_layer", "path": "compat/v1/feature_column/input_layer", "type": "tf.compat", "text": "\nReturns a dense `Tensor` as input layer based on given `feature_columns`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.feature_column.linear_model", "path": "compat/v1/feature_column/linear_model", "type": "tf.compat", "text": "\nReturns a linear prediction `Tensor` based on given `feature_columns`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.feature_column.make_parse_example_spec", "path": "compat/v1/feature_column/make_parse_example_spec", "type": "tf.compat", "text": "\nCreates parsing spec dictionary from input feature_columns.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.feature_column.shared_embedding_columns", "path": "compat/v1/feature_column/shared_embedding_columns", "type": "tf.compat", "text": "\nList of dense columns that convert from sparse, categorical input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.FixedLengthRecordReader", "path": "compat/v1/fixedlengthrecordreader", "type": "tf.compat", "text": "\nA Reader that outputs fixed-length records from a file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.fixed_size_partitioner", "path": "compat/v1/fixed_size_partitioner", "type": "tf.compat", "text": "\nPartitioner to specify a fixed number of shards along given axis.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags", "path": "compat/v1/flags", "type": "tf.compat", "text": "\nImport router for absl.flags. See https://github.com/abseil/abseil-py\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.adopt_module_key_flags", "path": "compat/v1/flags/adopt_module_key_flags", "type": "tf.compat", "text": "\nDeclares that all flags key to a module are key to the current module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.ArgumentParser", "path": "compat/v1/flags/argumentparser", "type": "tf.compat", "text": "\nBase class used to parse and convert arguments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.ArgumentSerializer", "path": "compat/v1/flags/argumentserializer", "type": "tf.compat", "text": "\nBase class for generating string representations of a flag value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.BaseListParser", "path": "compat/v1/flags/baselistparser", "type": "tf.compat", "text": "\nBase class for a parser of lists of strings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.BooleanFlag", "path": "compat/v1/flags/booleanflag", "type": "tf.compat", "text": "\nBasic boolean flag.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.BooleanParser", "path": "compat/v1/flags/booleanparser", "type": "tf.compat", "text": "\nParser of boolean values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.CantOpenFlagFileError", "path": "compat/v1/flags/cantopenflagfileerror", "type": "tf.compat", "text": "\nRaised when flagfile fails to open.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.CsvListSerializer", "path": "compat/v1/flags/csvlistserializer", "type": "tf.compat", "text": "\nBase class for generating string representations of a flag value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.declare_key_flag", "path": "compat/v1/flags/declare_key_flag", "type": "tf.compat", "text": "\nDeclares one flag as key to the current module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.DEFINE", "path": "compat/v1/flags/define", "type": "tf.compat", "text": "\nRegisters a generic Flag object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.DEFINE_alias", "path": "compat/v1/flags/define_alias", "type": "tf.compat", "text": "\nDefines an alias flag for an existing one.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.DEFINE_bool", "path": "compat/v1/flags/define_bool", "type": "tf.compat", "text": "\nRegisters a boolean flag.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.DEFINE_enum", "path": "compat/v1/flags/define_enum", "type": "tf.compat", "text": "\nRegisters a flag whose value can be any string from enum_values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.DEFINE_enum_class", "path": "compat/v1/flags/define_enum_class", "type": "tf.compat", "text": "\nRegisters a flag whose value can be the name of enum members.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.DEFINE_flag", "path": "compat/v1/flags/define_flag", "type": "tf.compat", "text": "\nRegisters a 'Flag' object with a 'FlagValues' object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.DEFINE_float", "path": "compat/v1/flags/define_float", "type": "tf.compat", "text": "\nRegisters a flag whose value must be a float.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.DEFINE_integer", "path": "compat/v1/flags/define_integer", "type": "tf.compat", "text": "\nRegisters a flag whose value must be an integer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.DEFINE_list", "path": "compat/v1/flags/define_list", "type": "tf.compat", "text": "\nRegisters a flag whose value is a comma-separated list of strings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.DEFINE_multi", "path": "compat/v1/flags/define_multi", "type": "tf.compat", "text": "\nRegisters a generic MultiFlag that parses its args with a given parser.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.DEFINE_multi_enum", "path": "compat/v1/flags/define_multi_enum", "type": "tf.compat", "text": "\nRegisters a flag whose value can be a list strings from enum_values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.DEFINE_multi_enum_class", "path": "compat/v1/flags/define_multi_enum_class", "type": "tf.compat", "text": "\nRegisters a flag whose value can be a list of enum members.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.DEFINE_multi_float", "path": "compat/v1/flags/define_multi_float", "type": "tf.compat", "text": "\nRegisters a flag whose value can be a list of arbitrary floats.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.DEFINE_multi_integer", "path": "compat/v1/flags/define_multi_integer", "type": "tf.compat", "text": "\nRegisters a flag whose value can be a list of arbitrary integers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.DEFINE_multi_string", "path": "compat/v1/flags/define_multi_string", "type": "tf.compat", "text": "\nRegisters a flag whose value can be a list of any strings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.DEFINE_spaceseplist", "path": "compat/v1/flags/define_spaceseplist", "type": "tf.compat", "text": "\nRegisters a flag whose value is a whitespace-separated list of strings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.DEFINE_string", "path": "compat/v1/flags/define_string", "type": "tf.compat", "text": "\nRegisters a flag whose value can be any string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.disclaim_key_flags", "path": "compat/v1/flags/disclaim_key_flags", "type": "tf.compat", "text": "\nDeclares that the current module will not define any more key flags.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.doc_to_help", "path": "compat/v1/flags/doc_to_help", "type": "tf.compat", "text": "\nTakes a doc string and reformats it as help.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.DuplicateFlagError", "path": "compat/v1/flags/duplicateflagerror", "type": "tf.compat", "text": "\nRaised if there is a flag naming conflict.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.EnumClassFlag", "path": "compat/v1/flags/enumclassflag", "type": "tf.compat", "text": "\nBasic enum flag; its value is an enum class's member.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.EnumClassParser", "path": "compat/v1/flags/enumclassparser", "type": "tf.compat", "text": "\nParser of an Enum class member.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.EnumFlag", "path": "compat/v1/flags/enumflag", "type": "tf.compat", "text": "\nBasic enum flag; its value can be any string from list of enum_values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.EnumParser", "path": "compat/v1/flags/enumparser", "type": "tf.compat", "text": "\nParser of a string enum value (a string value from a given set).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.Error", "path": "compat/v1/flags/error", "type": "tf.compat", "text": "\nThe base class for all flags errors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.Flag", "path": "compat/v1/flags/flag", "type": "tf.compat", "text": "\nInformation about a command-line flag.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.FlagHolder", "path": "compat/v1/flags/flagholder", "type": "tf.compat", "text": "\nHolds a defined flag.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.FlagNameConflictsWithMethodError", "path": "compat/v1/flags/flagnameconflictswithmethoderror", "type": "tf.compat", "text": "\nRaised when a flag name conflicts with FlagValues methods.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.FLAGS", "path": "compat/v1/flags/flags", "type": "tf.compat", "text": "\nRegistry of 'Flag' objects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.FlagValues", "path": "compat/v1/flags/flagvalues", "type": "tf.compat", "text": "\nRegistry of 'Flag' objects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.flag_dict_to_args", "path": "compat/v1/flags/flag_dict_to_args", "type": "tf.compat", "text": "\nConvert a dict of values into process call parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.FloatParser", "path": "compat/v1/flags/floatparser", "type": "tf.compat", "text": "\nParser of floating point values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.get_help_width", "path": "compat/v1/flags/get_help_width", "type": "tf.compat", "text": "\nReturns the integer width of help lines that is used in TextWrap.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.IllegalFlagValueError", "path": "compat/v1/flags/illegalflagvalueerror", "type": "tf.compat", "text": "\nRaised when the flag command line argument is illegal.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.IntegerParser", "path": "compat/v1/flags/integerparser", "type": "tf.compat", "text": "\nParser of an integer value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.ListParser", "path": "compat/v1/flags/listparser", "type": "tf.compat", "text": "\nParser for a comma-separated list of strings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.ListSerializer", "path": "compat/v1/flags/listserializer", "type": "tf.compat", "text": "\nBase class for generating string representations of a flag value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.mark_bool_flags_as_mutual_exclusive", "path": "compat/v1/flags/mark_bool_flags_as_mutual_exclusive", "type": "tf.compat", "text": "\nEnsures that only one flag among flag_names is True.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.mark_flags_as_mutual_exclusive", "path": "compat/v1/flags/mark_flags_as_mutual_exclusive", "type": "tf.compat", "text": "\nEnsures that only one flag among flag_names is not None.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.mark_flags_as_required", "path": "compat/v1/flags/mark_flags_as_required", "type": "tf.compat", "text": "\nEnsures that flags are not None during program execution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.mark_flag_as_required", "path": "compat/v1/flags/mark_flag_as_required", "type": "tf.compat", "text": "\nEnsures that flag is not None during program execution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.MultiEnumClassFlag", "path": "compat/v1/flags/multienumclassflag", "type": "tf.compat", "text": "\nA multi_enum_class flag.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.MultiFlag", "path": "compat/v1/flags/multiflag", "type": "tf.compat", "text": "\nA flag that can appear multiple time on the command-line.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.multi_flags_validator", "path": "compat/v1/flags/multi_flags_validator", "type": "tf.compat", "text": "\nA function decorator for defining a multi-flag validator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.register_multi_flags_validator", "path": "compat/v1/flags/register_multi_flags_validator", "type": "tf.compat", "text": "\nAdds a constraint to multiple flags.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.register_validator", "path": "compat/v1/flags/register_validator", "type": "tf.compat", "text": "\nAdds a constraint, which will be enforced during program execution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.text_wrap", "path": "compat/v1/flags/text_wrap", "type": "tf.compat", "text": "\nWraps a given text to a maximum line length and returns it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.tf_decorator", "path": "compat/v1/flags/tf_decorator", "type": "tf.compat", "text": "\nBase TFDecorator class and utility functions for working with decorators.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.tf_decorator.make_decorator", "path": "compat/v1/flags/tf_decorator/make_decorator", "type": "tf.compat", "text": "\nMake a decorator from a wrapper and a target.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.tf_decorator.rewrap", "path": "compat/v1/flags/tf_decorator/rewrap", "type": "tf.compat", "text": "\nInjects a new target into a function built by make_decorator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.tf_decorator.TFDecorator", "path": "compat/v1/flags/tf_decorator/tfdecorator", "type": "tf.compat", "text": "\nBase class for all TensorFlow decorators.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.tf_decorator.tf_stack", "path": "compat/v1/flags/tf_decorator/tf_stack", "type": "tf.compat", "text": "\nFunctions used to extract and analyze stacks. Faster than Python libs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.tf_decorator.tf_stack.CurrentModuleFilter", "path": "compat/v1/flags/tf_decorator/tf_stack/currentmodulefilter", "type": "tf.compat", "text": "\nFilters stack frames from the module where this is used (best effort).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.tf_decorator.tf_stack.extract_stack", "path": "compat/v1/flags/tf_decorator/tf_stack/extract_stack", "type": "tf.compat", "text": "\nA lightweight, extensible re-implementation of traceback.extract_stack.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.tf_decorator.tf_stack.FrameSummary", "path": "compat/v1/flags/tf_decorator/tf_stack/framesummary", "type": "tf.compat", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.tf_decorator.tf_stack.StackSummary", "path": "compat/v1/flags/tf_decorator/tf_stack/stacksummary", "type": "tf.compat", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.tf_decorator.tf_stack.StackTraceFilter", "path": "compat/v1/flags/tf_decorator/tf_stack/stacktracefilter", "type": "tf.compat", "text": "\nAllows filtering traceback information by removing superfluous frames.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.tf_decorator.tf_stack.StackTraceMapper", "path": "compat/v1/flags/tf_decorator/tf_stack/stacktracemapper", "type": "tf.compat", "text": "\nAllows remapping traceback information to different source code.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.tf_decorator.tf_stack.StackTraceTransform", "path": "compat/v1/flags/tf_decorator/tf_stack/stacktracetransform", "type": "tf.compat", "text": "\nBase class for stack trace transformation functions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.tf_decorator.unwrap", "path": "compat/v1/flags/tf_decorator/unwrap", "type": "tf.compat", "text": "\nUnwraps an object into a list of TFDecorators and a final target.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.UnparsedFlagAccessError", "path": "compat/v1/flags/unparsedflagaccesserror", "type": "tf.compat", "text": "\nRaised when accessing the flag value from unparsed FlagValues.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.UnrecognizedFlagError", "path": "compat/v1/flags/unrecognizedflagerror", "type": "tf.compat", "text": "\nRaised when a flag is unrecognized.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.ValidationError", "path": "compat/v1/flags/validationerror", "type": "tf.compat", "text": "\nRaised when flag validator constraint is not satisfied.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.validator", "path": "compat/v1/flags/validator", "type": "tf.compat", "text": "\nA function decorator for defining a flag validator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.flags.WhitespaceSeparatedListParser", "path": "compat/v1/flags/whitespaceseparatedlistparser", "type": "tf.compat", "text": "\nParser for a whitespace-separated list of strings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.floor_div", "path": "compat/v1/floor_div", "type": "tf.compat", "text": "\nReturns x // y element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.foldl", "path": "compat/v1/foldl", "type": "tf.compat", "text": "\nfoldl on the list of tensors unpacked from `elems` on dimension 0.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.foldr", "path": "compat/v1/foldr", "type": "tf.compat", "text": "\nfoldr on the list of tensors unpacked from `elems` on dimension 0.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.gather", "path": "compat/v1/gather", "type": "tf.compat", "text": "\nGather slices from params axis `axis` according to indices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.gather_nd", "path": "compat/v1/gather_nd", "type": "tf.compat", "text": "\nGather slices from `params` into a Tensor with shape specified by `indices`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.get_collection", "path": "compat/v1/get_collection", "type": "tf.compat", "text": "\nWrapper for `Graph.get_collection()` using the default graph.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.get_collection_ref", "path": "compat/v1/get_collection_ref", "type": "tf.compat", "text": "\nWrapper for `Graph.get_collection_ref()` using the default graph.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.get_default_graph", "path": "compat/v1/get_default_graph", "type": "tf.compat", "text": "\nReturns the default graph for the current thread.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.get_default_session", "path": "compat/v1/get_default_session", "type": "tf.compat", "text": "\nReturns the default session for the current thread.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.get_local_variable", "path": "compat/v1/get_local_variable", "type": "tf.compat", "text": "\nGets an existing local variable or creates a new one.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.get_seed", "path": "compat/v1/get_seed", "type": "tf.compat", "text": "\nReturns the local seeds an operation should use given an op-specific seed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.get_session_handle", "path": "compat/v1/get_session_handle", "type": "tf.compat", "text": "\nReturn the handle of `data`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.get_session_tensor", "path": "compat/v1/get_session_tensor", "type": "tf.compat", "text": "\nGet the tensor of type `dtype` by feeding a tensor handle.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.get_variable", "path": "compat/v1/get_variable", "type": "tf.compat", "text": "\nGets an existing variable with these parameters or create a new one.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.get_variable_scope", "path": "compat/v1/get_variable_scope", "type": "tf.compat", "text": "\nReturns the current variable scope.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.gfile", "path": "compat/v1/gfile", "type": "tf.compat", "text": "\nImport router for file_io.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.gfile.Copy", "path": "compat/v1/gfile/copy", "type": "tf.compat", "text": "\nCopies data from `oldpath` to `newpath`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.gfile.DeleteRecursively", "path": "compat/v1/gfile/deleterecursively", "type": "tf.compat", "text": "\nDeletes everything under dirname recursively.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.gfile.Exists", "path": "compat/v1/gfile/exists", "type": "tf.compat", "text": "\nDetermines whether a path exists or not.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.gfile.FastGFile", "path": "compat/v1/gfile/fastgfile", "type": "tf.compat", "text": "\nFile I/O wrappers without thread locking.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.gfile.Glob", "path": "compat/v1/gfile/glob", "type": "tf.compat", "text": "\nReturns a list of files that match the given pattern(s).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.gfile.IsDirectory", "path": "compat/v1/gfile/isdirectory", "type": "tf.compat", "text": "\nReturns whether the path is a directory or not.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.gfile.ListDirectory", "path": "compat/v1/gfile/listdirectory", "type": "tf.compat", "text": "\nReturns a list of entries contained within a directory.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.gfile.MakeDirs", "path": "compat/v1/gfile/makedirs", "type": "tf.compat", "text": "\nCreates a directory and all parent/intermediate directories.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.gfile.MkDir", "path": "compat/v1/gfile/mkdir", "type": "tf.compat", "text": "\nCreates a directory with the name `dirname`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.gfile.Remove", "path": "compat/v1/gfile/remove", "type": "tf.compat", "text": "\nDeletes the file located at 'filename'.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.gfile.Rename", "path": "compat/v1/gfile/rename", "type": "tf.compat", "text": "\nRename or move a file / directory.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.gfile.Stat", "path": "compat/v1/gfile/stat", "type": "tf.compat", "text": "\nReturns file statistics for a given path.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.gfile.Walk", "path": "compat/v1/gfile/walk", "type": "tf.compat", "text": "\nRecursive directory tree generator for directories.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.global_variables", "path": "compat/v1/global_variables", "type": "tf.compat", "text": "\nReturns global variables.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.global_variables_initializer", "path": "compat/v1/global_variables_initializer", "type": "tf.compat", "text": "\nReturns an Op that initializes global variables.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.GPUOptions", "path": "compat/v1/gpuoptions", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.GPUOptions.Experimental", "path": "compat/v1/gpuoptions/experimental", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.GPUOptions.Experimental.VirtualDevices", "path": "compat/v1/gpuoptions/experimental/virtualdevices", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.gradients", "path": "compat/v1/gradients", "type": "tf.compat", "text": "\nConstructs symbolic derivatives of sum of `ys` w.r.t. x in `xs`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.GraphDef", "path": "compat/v1/graphdef", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.GraphKeys", "path": "compat/v1/graphkeys", "type": "tf.compat", "text": "\nStandard names to use for graph collections.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.GraphOptions", "path": "compat/v1/graphoptions", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.graph_util", "path": "compat/v1/graph_util", "type": "tf.compat", "text": "\nHelpers to manipulate a tensor graph in python.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.graph_util.convert_variables_to_constants", "path": "compat/v1/graph_util/convert_variables_to_constants", "type": "tf.compat", "text": "\nReplaces all the variables in a graph with constants of the same values.\n(deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.graph_util.extract_sub_graph", "path": "compat/v1/graph_util/extract_sub_graph", "type": "tf.compat", "text": "\nExtract the subgraph that can reach any of the nodes in 'dest_nodes'.\n(deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.graph_util.must_run_on_cpu", "path": "compat/v1/graph_util/must_run_on_cpu", "type": "tf.compat", "text": "\nReturns True if the given node_def must run on CPU, otherwise False.\n(deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.graph_util.remove_training_nodes", "path": "compat/v1/graph_util/remove_training_nodes", "type": "tf.compat", "text": "\nPrunes out nodes that aren't needed for inference. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.graph_util.tensor_shape_from_node_def_name", "path": "compat/v1/graph_util/tensor_shape_from_node_def_name", "type": "tf.compat", "text": "\nConvenience function to get a shape from a NodeDef's input string.\n(deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.hessians", "path": "compat/v1/hessians", "type": "tf.compat", "text": "\nConstructs the Hessian of sum of `ys` with respect to `x` in `xs`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.HistogramProto", "path": "compat/v1/histogramproto", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.IdentityReader", "path": "compat/v1/identityreader", "type": "tf.compat", "text": "\nA Reader that outputs the queued work as both the key and value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.image", "path": "compat/v1/image", "type": "tf.compat", "text": "\nImage ops.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.image.crop_and_resize", "path": "compat/v1/image/crop_and_resize", "type": "tf.compat", "text": "\nExtracts crops from the input image tensor and resizes them.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.image.draw_bounding_boxes", "path": "compat/v1/image/draw_bounding_boxes", "type": "tf.compat", "text": "\nDraw bounding boxes on a batch of images.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.image.extract_glimpse", "path": "compat/v1/image/extract_glimpse", "type": "tf.compat", "text": "\nExtracts a glimpse from the input tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.image.resize", "path": "compat/v1/image/resize", "type": "tf.compat", "text": "\nResize `images` to `size` using the specified `method`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.image.ResizeMethod", "path": "compat/v1/image/resizemethod", "type": "tf.compat", "text": "\nSee `v1.image.resize` for details.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.image.resize_area", "path": "compat/v1/image/resize_area", "type": "tf.compat", "text": "\nResize `images` to `size` using area interpolation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.image.resize_bicubic", "path": "compat/v1/image/resize_bicubic", "type": "tf.compat", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.image.resize_bilinear", "path": "compat/v1/image/resize_bilinear", "type": "tf.compat", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.image.resize_image_with_pad", "path": "compat/v1/image/resize_image_with_pad", "type": "tf.compat", "text": "\nResizes and pads an image to a target width and height.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.image.resize_nearest_neighbor", "path": "compat/v1/image/resize_nearest_neighbor", "type": "tf.compat", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.image.sample_distorted_bounding_box", "path": "compat/v1/image/sample_distorted_bounding_box", "type": "tf.compat", "text": "\nGenerate a single randomly distorted bounding box for an image. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.initializers", "path": "compat/v1/initializers", "type": "tf.compat", "text": "\nPublic API for tf.initializers namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.initializers.he_normal", "path": "compat/v1/initializers/he_normal", "type": "tf.compat", "text": "\nHe normal initializer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.initializers.he_uniform", "path": "compat/v1/initializers/he_uniform", "type": "tf.compat", "text": "\nHe uniform variance scaling initializer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.initializers.lecun_normal", "path": "compat/v1/initializers/lecun_normal", "type": "tf.compat", "text": "\nLeCun normal initializer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.initializers.lecun_uniform", "path": "compat/v1/initializers/lecun_uniform", "type": "tf.compat", "text": "\nLeCun uniform initializer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.initialize_all_tables", "path": "compat/v1/initialize_all_tables", "type": "tf.compat", "text": "\nReturns an Op that initializes all tables of the default graph. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.initialize_all_variables", "path": "compat/v1/initialize_all_variables", "type": "tf.compat", "text": "\nSee `tf.compat.v1.global_variables_initializer`. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.initialize_local_variables", "path": "compat/v1/initialize_local_variables", "type": "tf.compat", "text": "\nSee `tf.compat.v1.local_variables_initializer`. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.initialize_variables", "path": "compat/v1/initialize_variables", "type": "tf.compat", "text": "\nSee `tf.compat.v1.variables_initializer`. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.InteractiveSession", "path": "compat/v1/interactivesession", "type": "tf.compat", "text": "\nA TensorFlow `Session` for use in interactive contexts, such as a shell.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.io", "path": "compat/v1/io", "type": "tf.compat", "text": "\nPublic API for tf.io namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.io.gfile", "path": "compat/v1/io/gfile", "type": "tf.compat", "text": "\nPublic API for tf.io.gfile namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.io.TFRecordCompressionType", "path": "compat/v1/io/tfrecordcompressiontype", "type": "tf.compat", "text": "\nThe type of compression for the record.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.io.tf_record_iterator", "path": "compat/v1/io/tf_record_iterator", "type": "tf.compat", "text": "\nAn iterator that read the records from a TFRecords file. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.is_variable_initialized", "path": "compat/v1/is_variable_initialized", "type": "tf.compat", "text": "\nTests if a variable has been initialized.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras", "path": "compat/v1/keras", "type": "tf.compat", "text": "\nImplementation of the Keras API meant to be a high-level API for TensorFlow.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.activations", "path": "compat/v1/keras/activations", "type": "tf.compat", "text": "\nBuilt-in activation functions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.applications", "path": "compat/v1/keras/applications", "type": "tf.compat", "text": "\nKeras Applications are canned architectures with pre-trained weights.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.applications.densenet", "path": "compat/v1/keras/applications/densenet", "type": "tf.compat", "text": "\nDenseNet models for Keras.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.applications.efficientnet", "path": "compat/v1/keras/applications/efficientnet", "type": "tf.compat", "text": "\nEfficientNet models for Keras.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.applications.imagenet_utils", "path": "compat/v1/keras/applications/imagenet_utils", "type": "tf.compat", "text": "\nUtilities for ImageNet data preprocessing & prediction decoding.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.applications.inception_resnet_v2", "path": "compat/v1/keras/applications/inception_resnet_v2", "type": "tf.compat", "text": "\nInception-ResNet V2 model for Keras.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.applications.inception_v3", "path": "compat/v1/keras/applications/inception_v3", "type": "tf.compat", "text": "\nInception V3 model for Keras.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.applications.mobilenet", "path": "compat/v1/keras/applications/mobilenet", "type": "tf.compat", "text": "\nMobileNet v1 models for Keras.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.applications.mobilenet_v2", "path": "compat/v1/keras/applications/mobilenet_v2", "type": "tf.compat", "text": "\nMobileNet v2 models for Keras.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.applications.mobilenet_v3", "path": "compat/v1/keras/applications/mobilenet_v3", "type": "tf.compat", "text": "\nMobileNet v3 models for Keras.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.applications.nasnet", "path": "compat/v1/keras/applications/nasnet", "type": "tf.compat", "text": "\nNASNet-A models for Keras.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.applications.resnet", "path": "compat/v1/keras/applications/resnet", "type": "tf.compat", "text": "\nResNet models for Keras.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.applications.resnet50", "path": "compat/v1/keras/applications/resnet50", "type": "tf.compat", "text": "\nPublic API for tf.keras.applications.resnet50 namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.applications.resnet_v2", "path": "compat/v1/keras/applications/resnet_v2", "type": "tf.compat", "text": "\nResNet v2 models for Keras.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.applications.vgg16", "path": "compat/v1/keras/applications/vgg16", "type": "tf.compat", "text": "\nVGG16 model for Keras.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.applications.vgg19", "path": "compat/v1/keras/applications/vgg19", "type": "tf.compat", "text": "\nVGG19 model for Keras.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.applications.xception", "path": "compat/v1/keras/applications/xception", "type": "tf.compat", "text": "\nXception V1 model for Keras.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.backend", "path": "compat/v1/keras/backend", "type": "tf.compat", "text": "\nKeras backend API.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.backend.get_session", "path": "compat/v1/keras/backend/get_session", "type": "tf.compat", "text": "\nReturns the TF session to be used by the backend.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.backend.name_scope", "path": "compat/v1/keras/backend/name_scope", "type": "tf.compat", "text": "\nA context manager for use when defining a Python op.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.backend.set_session", "path": "compat/v1/keras/backend/set_session", "type": "tf.compat", "text": "\nSets the global TensorFlow session.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.callbacks", "path": "compat/v1/keras/callbacks", "type": "tf.compat", "text": "\nCallbacks: utilities called at certain points during model training.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.callbacks.TensorBoard", "path": "compat/v1/keras/callbacks/tensorboard", "type": "tf.compat", "text": "\nEnable visualizations for TensorBoard.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.constraints", "path": "compat/v1/keras/constraints", "type": "tf.compat", "text": "\nConstraints: functions that impose constraints on weight values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.datasets", "path": "compat/v1/keras/datasets", "type": "tf.compat", "text": "\nPublic API for tf.keras.datasets namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.datasets.boston_housing", "path": "compat/v1/keras/datasets/boston_housing", "type": "tf.compat", "text": "\nBoston housing price regression dataset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.datasets.cifar10", "path": "compat/v1/keras/datasets/cifar10", "type": "tf.compat", "text": "\nCIFAR10 small images classification dataset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.datasets.cifar100", "path": "compat/v1/keras/datasets/cifar100", "type": "tf.compat", "text": "\nCIFAR100 small images classification dataset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.datasets.fashion_mnist", "path": "compat/v1/keras/datasets/fashion_mnist", "type": "tf.compat", "text": "\nFashion-MNIST dataset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.datasets.imdb", "path": "compat/v1/keras/datasets/imdb", "type": "tf.compat", "text": "\nIMDB sentiment classification dataset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.datasets.mnist", "path": "compat/v1/keras/datasets/mnist", "type": "tf.compat", "text": "\nMNIST handwritten digits dataset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.datasets.reuters", "path": "compat/v1/keras/datasets/reuters", "type": "tf.compat", "text": "\nReuters topic classification dataset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.estimator", "path": "compat/v1/keras/estimator", "type": "tf.compat", "text": "\nKeras estimator API.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.estimator.model_to_estimator", "path": "compat/v1/keras/estimator/model_to_estimator", "type": "tf.compat", "text": "\nConstructs an `Estimator` instance from given keras model.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.experimental", "path": "compat/v1/keras/experimental", "type": "tf.compat", "text": "\nPublic API for tf.keras.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.experimental.export_saved_model", "path": "compat/v1/keras/experimental/export_saved_model", "type": "tf.compat", "text": "\nExports a `tf.keras.Model` as a Tensorflow SavedModel.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.experimental.load_from_saved_model", "path": "compat/v1/keras/experimental/load_from_saved_model", "type": "tf.compat", "text": "\nLoads a keras Model from a SavedModel created by `export_saved_model()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.initializers", "path": "compat/v1/keras/initializers", "type": "tf.compat", "text": "\nKeras initializer serialization / deserialization.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.initializers.Constant", "path": "compat/v1/keras/initializers/constant", "type": "tf.compat", "text": "\nInitializer that generates tensors with constant values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.initializers.glorot_normal", "path": "compat/v1/keras/initializers/glorot_normal", "type": "tf.compat", "text": "\nThe Glorot normal initializer, also called Xavier normal initializer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.initializers.glorot_uniform", "path": "compat/v1/keras/initializers/glorot_uniform", "type": "tf.compat", "text": "\nThe Glorot uniform initializer, also called Xavier uniform initializer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.initializers.he_normal", "path": "compat/v1/keras/initializers/he_normal", "type": "tf.compat", "text": "\nInitializer capable of adapting its scale to the shape of weights tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.initializers.he_uniform", "path": "compat/v1/keras/initializers/he_uniform", "type": "tf.compat", "text": "\nInitializer capable of adapting its scale to the shape of weights tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.initializers.Identity", "path": "compat/v1/keras/initializers/identity", "type": "tf.compat", "text": "\nInitializer that generates the identity matrix.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.initializers.lecun_normal", "path": "compat/v1/keras/initializers/lecun_normal", "type": "tf.compat", "text": "\nInitializer capable of adapting its scale to the shape of weights tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.initializers.lecun_uniform", "path": "compat/v1/keras/initializers/lecun_uniform", "type": "tf.compat", "text": "\nInitializer capable of adapting its scale to the shape of weights tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.initializers.Ones", "path": "compat/v1/keras/initializers/ones", "type": "tf.compat", "text": "\nInitializer that generates tensors initialized to 1.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.initializers.Orthogonal", "path": "compat/v1/keras/initializers/orthogonal", "type": "tf.compat", "text": "\nInitializer that generates an orthogonal matrix.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.initializers.RandomNormal", "path": "compat/v1/keras/initializers/randomnormal", "type": "tf.compat", "text": "\nInitializer that generates tensors with a normal distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.initializers.RandomUniform", "path": "compat/v1/keras/initializers/randomuniform", "type": "tf.compat", "text": "\nInitializer that generates tensors with a uniform distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.initializers.TruncatedNormal", "path": "compat/v1/keras/initializers/truncatednormal", "type": "tf.compat", "text": "\nInitializer that generates a truncated normal distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.initializers.VarianceScaling", "path": "compat/v1/keras/initializers/variancescaling", "type": "tf.compat", "text": "\nInitializer capable of adapting its scale to the shape of weights tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.initializers.Zeros", "path": "compat/v1/keras/initializers/zeros", "type": "tf.compat", "text": "\nInitializer that generates tensors initialized to 0.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.layers", "path": "compat/v1/keras/layers", "type": "tf.compat", "text": "\nKeras layers API.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.layers.BatchNormalization", "path": "compat/v1/keras/layers/batchnormalization", "type": "tf.compat", "text": "\nLayer that normalizes its inputs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.layers.CuDNNGRU", "path": "compat/v1/keras/layers/cudnngru", "type": "tf.compat", "text": "\nFast GRU implementation backed by cuDNN.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.layers.CuDNNLSTM", "path": "compat/v1/keras/layers/cudnnlstm", "type": "tf.compat", "text": "\nFast LSTM implementation backed by cuDNN.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.layers.DenseFeatures", "path": "compat/v1/keras/layers/densefeatures", "type": "tf.compat", "text": "\nA layer that produces a dense `Tensor` based on given `feature_columns`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.layers.disable_v2_dtype_behavior", "path": "compat/v1/keras/layers/disable_v2_dtype_behavior", "type": "tf.compat", "text": "\nDisables the V2 dtype behavior for Keras layers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.layers.enable_v2_dtype_behavior", "path": "compat/v1/keras/layers/enable_v2_dtype_behavior", "type": "tf.compat", "text": "\nEnable the V2 dtype behavior for Keras layers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.layers.experimental", "path": "compat/v1/keras/layers/experimental", "type": "tf.compat", "text": "\nPublic API for tf.keras.layers.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.layers.experimental.preprocessing", "path": "compat/v1/keras/layers/experimental/preprocessing", "type": "tf.compat", "text": "\nPublic API for tf.keras.layers.experimental.preprocessing namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.layers.experimental.preprocessing.CategoryEncoding", "path": "compat/v1/keras/layers/experimental/preprocessing/categoryencoding", "type": "tf.compat", "text": "\nCategoryEncoding layer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.layers.experimental.preprocessing.IntegerLookup", "path": "compat/v1/keras/layers/experimental/preprocessing/integerlookup", "type": "tf.compat", "text": "\nMaps integers from a vocabulary to integer indices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.layers.experimental.preprocessing.Normalization", "path": "compat/v1/keras/layers/experimental/preprocessing/normalization", "type": "tf.compat", "text": "\nFeature-wise normalization of the data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.layers.experimental.preprocessing.StringLookup", "path": "compat/v1/keras/layers/experimental/preprocessing/stringlookup", "type": "tf.compat", "text": "\nMaps strings from a vocabulary to integer indices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.layers.experimental.preprocessing.TextVectorization", "path": "compat/v1/keras/layers/experimental/preprocessing/textvectorization", "type": "tf.compat", "text": "\nText vectorization layer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.layers.GRU", "path": "compat/v1/keras/layers/gru", "type": "tf.compat", "text": "\nGated Recurrent Unit - Cho et al. 2014.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.layers.GRUCell", "path": "compat/v1/keras/layers/grucell", "type": "tf.compat", "text": "\nCell class for the GRU layer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.layers.LSTM", "path": "compat/v1/keras/layers/lstm", "type": "tf.compat", "text": "\nLong Short-Term Memory layer - Hochreiter 1997.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.layers.LSTMCell", "path": "compat/v1/keras/layers/lstmcell", "type": "tf.compat", "text": "\nCell class for the LSTM layer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.losses", "path": "compat/v1/keras/losses", "type": "tf.compat", "text": "\nBuilt-in loss functions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.metrics", "path": "compat/v1/keras/metrics", "type": "tf.compat", "text": "\nBuilt-in metrics.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.mixed_precision", "path": "compat/v1/keras/mixed_precision", "type": "tf.compat", "text": "\nKeras mixed precision API.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.mixed_precision.experimental", "path": "compat/v1/keras/mixed_precision/experimental", "type": "tf.compat", "text": "\nPublic API for tf.keras.mixed_precision.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.models", "path": "compat/v1/keras/models", "type": "tf.compat", "text": "\nCode for model cloning, plus model-related API entries.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.optimizers", "path": "compat/v1/keras/optimizers", "type": "tf.compat", "text": "\nBuilt-in optimizer classes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.optimizers.schedules", "path": "compat/v1/keras/optimizers/schedules", "type": "tf.compat", "text": "\nPublic API for tf.keras.optimizers.schedules namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.preprocessing", "path": "compat/v1/keras/preprocessing", "type": "tf.compat", "text": "\nKeras data preprocessing utils.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.preprocessing.image", "path": "compat/v1/keras/preprocessing/image", "type": "tf.compat", "text": "\nSet of tools for real-time data augmentation on image data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.preprocessing.sequence", "path": "compat/v1/keras/preprocessing/sequence", "type": "tf.compat", "text": "\nUtilities for preprocessing sequence data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.preprocessing.text", "path": "compat/v1/keras/preprocessing/text", "type": "tf.compat", "text": "\nUtilities for text input preprocessing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.regularizers", "path": "compat/v1/keras/regularizers", "type": "tf.compat", "text": "\nBuilt-in regularizers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.utils", "path": "compat/v1/keras/utils", "type": "tf.compat", "text": "\nPublic API for tf.keras.utils namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.wrappers", "path": "compat/v1/keras/wrappers", "type": "tf.compat", "text": "\nPublic API for tf.keras.wrappers namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.keras.wrappers.scikit_learn", "path": "compat/v1/keras/wrappers/scikit_learn", "type": "tf.compat", "text": "\nWrapper for using the Scikit-Learn API with Keras models.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.layers", "path": "compat/v1/layers", "type": "tf.compat", "text": "\nPublic API for tf.layers namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.layers.AveragePooling1D", "path": "compat/v1/layers/averagepooling1d", "type": "tf.compat", "text": "\nAverage Pooling layer for 1D inputs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.layers.AveragePooling2D", "path": "compat/v1/layers/averagepooling2d", "type": "tf.compat", "text": "\nAverage pooling layer for 2D inputs (e.g. images).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.layers.AveragePooling3D", "path": "compat/v1/layers/averagepooling3d", "type": "tf.compat", "text": "\nAverage pooling layer for 3D inputs (e.g. volumes).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.layers.average_pooling1d", "path": "compat/v1/layers/average_pooling1d", "type": "tf.compat", "text": "\nAverage Pooling layer for 1D inputs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.layers.average_pooling2d", "path": "compat/v1/layers/average_pooling2d", "type": "tf.compat", "text": "\nAverage pooling layer for 2D inputs (e.g. images).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.layers.average_pooling3d", "path": "compat/v1/layers/average_pooling3d", "type": "tf.compat", "text": "\nAverage pooling layer for 3D inputs (e.g. volumes).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.layers.BatchNormalization", "path": "compat/v1/layers/batchnormalization", "type": "tf.compat", "text": "\nBatch Normalization layer from (Ioffe et al., 2015).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.layers.batch_normalization", "path": "compat/v1/layers/batch_normalization", "type": "tf.compat", "text": "\nFunctional interface for the batch normalization layer from_config(Ioffe et\nal., 2015).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.layers.Conv1D", "path": "compat/v1/layers/conv1d", "type": "tf.compat", "text": "\n1D convolution layer (e.g. temporal convolution).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.layers.Conv2D", "path": "compat/v1/layers/conv2d", "type": "tf.compat", "text": "\n2D convolution layer (e.g. spatial convolution over images).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.layers.Conv2DTranspose", "path": "compat/v1/layers/conv2dtranspose", "type": "tf.compat", "text": "\nTransposed 2D convolution layer (sometimes called 2D Deconvolution).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.layers.conv2d_transpose", "path": "compat/v1/layers/conv2d_transpose", "type": "tf.compat", "text": "\nFunctional interface for transposed 2D convolution layer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.layers.Conv3D", "path": "compat/v1/layers/conv3d", "type": "tf.compat", "text": "\n3D convolution layer (e.g. spatial convolution over volumes).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.layers.Conv3DTranspose", "path": "compat/v1/layers/conv3dtranspose", "type": "tf.compat", "text": "\nTransposed 3D convolution layer (sometimes called 3D Deconvolution).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.layers.conv3d_transpose", "path": "compat/v1/layers/conv3d_transpose", "type": "tf.compat", "text": "\nFunctional interface for transposed 3D convolution layer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.layers.Dense", "path": "compat/v1/layers/dense", "type": "tf.compat", "text": "\nDensely-connected layer class.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.layers.Dropout", "path": "compat/v1/layers/dropout", "type": "tf.compat", "text": "\nApplies Dropout to the input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.layers.experimental", "path": "compat/v1/layers/experimental", "type": "tf.compat", "text": "\nPublic API for tf.layers.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.layers.experimental.keras_style_scope", "path": "compat/v1/layers/experimental/keras_style_scope", "type": "tf.compat", "text": "\nUse Keras-style variable management.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.layers.experimental.set_keras_style", "path": "compat/v1/layers/experimental/set_keras_style", "type": "tf.compat", "text": "\nUse Keras-style variable management.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.layers.Flatten", "path": "compat/v1/layers/flatten", "type": "tf.compat", "text": "\nFlattens an input tensor while preserving the batch axis (axis 0).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.layers.Layer", "path": "compat/v1/layers/layer", "type": "tf.compat", "text": "\nBase layer class.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.layers.MaxPooling1D", "path": "compat/v1/layers/maxpooling1d", "type": "tf.compat", "text": "\nMax Pooling layer for 1D inputs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.layers.MaxPooling2D", "path": "compat/v1/layers/maxpooling2d", "type": "tf.compat", "text": "\nMax pooling layer for 2D inputs (e.g. images).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.layers.MaxPooling3D", "path": "compat/v1/layers/maxpooling3d", "type": "tf.compat", "text": "\nMax pooling layer for 3D inputs (e.g. volumes).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.layers.max_pooling1d", "path": "compat/v1/layers/max_pooling1d", "type": "tf.compat", "text": "\nMax Pooling layer for 1D inputs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.layers.max_pooling2d", "path": "compat/v1/layers/max_pooling2d", "type": "tf.compat", "text": "\nMax pooling layer for 2D inputs (e.g. images).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.layers.max_pooling3d", "path": "compat/v1/layers/max_pooling3d", "type": "tf.compat", "text": "\nMax pooling layer for 3D inputs (e.g.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.layers.SeparableConv1D", "path": "compat/v1/layers/separableconv1d", "type": "tf.compat", "text": "\nDepthwise separable 1D convolution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.layers.SeparableConv2D", "path": "compat/v1/layers/separableconv2d", "type": "tf.compat", "text": "\nDepthwise separable 2D convolution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.layers.separable_conv1d", "path": "compat/v1/layers/separable_conv1d", "type": "tf.compat", "text": "\nFunctional interface for the depthwise separable 1D convolution layer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.layers.separable_conv2d", "path": "compat/v1/layers/separable_conv2d", "type": "tf.compat", "text": "\nFunctional interface for the depthwise separable 2D convolution layer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.linalg", "path": "compat/v1/linalg", "type": "tf.compat", "text": "\nOperations for linear algebra.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.linalg.experimental", "path": "compat/v1/linalg/experimental", "type": "tf.compat", "text": "\nPublic API for tf.linalg.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.linalg.l2_normalize", "path": "compat/v1/linalg/l2_normalize", "type": "tf.compat", "text": "\nNormalizes along dimension `axis` using an L2 norm. (deprecated arguments)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.lite", "path": "compat/v1/lite", "type": "tf.compat", "text": "\nPublic API for tf.lite namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.lite.constants", "path": "compat/v1/lite/constants", "type": "tf.compat", "text": "\nPublic API for tf.lite.constants namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.lite.experimental", "path": "compat/v1/lite/experimental", "type": "tf.compat", "text": "\nPublic API for tf.lite.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.lite.experimental.convert_op_hints_to_stubs", "path": "compat/v1/lite/experimental/convert_op_hints_to_stubs", "type": "tf.compat", "text": "\nConverts a graphdef with LiteOp hints into stub operations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.lite.experimental.get_potentially_supported_ops", "path": "compat/v1/lite/experimental/get_potentially_supported_ops", "type": "tf.compat", "text": "\nReturns operations potentially supported by TensorFlow Lite.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.lite.experimental.nn", "path": "compat/v1/lite/experimental/nn", "type": "tf.compat", "text": "\nPublic API for tf.lite.experimental.nn namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.lite.experimental.nn.dynamic_rnn", "path": "compat/v1/lite/experimental/nn/dynamic_rnn", "type": "tf.compat", "text": "\nCreates a recurrent neural network specified by RNNCell `cell`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.lite.experimental.nn.TFLiteLSTMCell", "path": "compat/v1/lite/experimental/nn/tflitelstmcell", "type": "tf.compat", "text": "\nLong short-term memory unit (LSTM) recurrent network cell.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.lite.experimental.nn.TfLiteRNNCell", "path": "compat/v1/lite/experimental/nn/tfliternncell", "type": "tf.compat", "text": "\nThe most basic RNN cell.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.lite.OpHint", "path": "compat/v1/lite/ophint", "type": "tf.compat", "text": "\nA class that helps build tflite function invocations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.lite.OpHint.OpHintArgumentTracker", "path": "compat/v1/lite/ophint/ophintargumenttracker", "type": "tf.compat", "text": "\nConceptually tracks indices of arguments of \"OpHint functions\".\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.lite.TFLiteConverter", "path": "compat/v1/lite/tfliteconverter", "type": "tf.compat", "text": "\nConvert a TensorFlow model into `output_format`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.lite.TocoConverter", "path": "compat/v1/lite/tococonverter", "type": "tf.compat", "text": "\nConvert a TensorFlow model into `output_format` using TOCO.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.lite.toco_convert", "path": "compat/v1/lite/toco_convert", "type": "tf.compat", "text": "\nConvert a model using TOCO. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.LMDBReader", "path": "compat/v1/lmdbreader", "type": "tf.compat", "text": "\nA Reader that outputs the records from a LMDB file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.load_file_system_library", "path": "compat/v1/load_file_system_library", "type": "tf.compat", "text": "\nLoads a TensorFlow plugin, containing file system implementation. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.local_variables", "path": "compat/v1/local_variables", "type": "tf.compat", "text": "\nReturns local variables.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.local_variables_initializer", "path": "compat/v1/local_variables_initializer", "type": "tf.compat", "text": "\nReturns an Op that initializes all local variables.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.logging", "path": "compat/v1/logging", "type": "tf.compat", "text": "\nLogging and Summary Operations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.logging.debug", "path": "compat/v1/logging/debug", "type": "tf.compat", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.logging.error", "path": "compat/v1/logging/error", "type": "tf.compat", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.logging.fatal", "path": "compat/v1/logging/fatal", "type": "tf.compat", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.logging.flush", "path": "compat/v1/logging/flush", "type": "tf.compat", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.logging.get_verbosity", "path": "compat/v1/logging/get_verbosity", "type": "tf.compat", "text": "\nReturn how much logging output will be produced.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.logging.info", "path": "compat/v1/logging/info", "type": "tf.compat", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.logging.log", "path": "compat/v1/logging/log", "type": "tf.compat", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.logging.log_every_n", "path": "compat/v1/logging/log_every_n", "type": "tf.compat", "text": "\nLog 'msg % args' at level 'level' once per 'n' times.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.logging.log_first_n", "path": "compat/v1/logging/log_first_n", "type": "tf.compat", "text": "\nLog 'msg % args' at level 'level' only first 'n' times.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.logging.log_if", "path": "compat/v1/logging/log_if", "type": "tf.compat", "text": "\nLog 'msg % args' at level 'level' only if condition is fulfilled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.logging.set_verbosity", "path": "compat/v1/logging/set_verbosity", "type": "tf.compat", "text": "\nSets the threshold for what messages will be logged.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.logging.TaskLevelStatusMessage", "path": "compat/v1/logging/tasklevelstatusmessage", "type": "tf.compat", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.logging.vlog", "path": "compat/v1/logging/vlog", "type": "tf.compat", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.logging.warn", "path": "compat/v1/logging/warn", "type": "tf.compat", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.logging.warning", "path": "compat/v1/logging/warning", "type": "tf.compat", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.LogMessage", "path": "compat/v1/logmessage", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.lookup", "path": "compat/v1/lookup", "type": "tf.compat", "text": "\nPublic API for tf.lookup namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.lookup.experimental", "path": "compat/v1/lookup/experimental", "type": "tf.compat", "text": "\nPublic API for tf.lookup.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.lookup.StaticHashTable", "path": "compat/v1/lookup/statichashtable", "type": "tf.compat", "text": "\nA generic hash table that is immutable once initialized.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.lookup.StaticVocabularyTable", "path": "compat/v1/lookup/staticvocabularytable", "type": "tf.compat", "text": "\nString to Id table that assigns out-of-vocabulary keys to hash buckets.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.losses", "path": "compat/v1/losses", "type": "tf.compat", "text": "\nLoss operations for use in neural networks.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.losses.absolute_difference", "path": "compat/v1/losses/absolute_difference", "type": "tf.compat", "text": "\nAdds an Absolute Difference loss to the training procedure.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.losses.add_loss", "path": "compat/v1/losses/add_loss", "type": "tf.compat", "text": "\nAdds a externally defined loss to the collection of losses.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.losses.compute_weighted_loss", "path": "compat/v1/losses/compute_weighted_loss", "type": "tf.compat", "text": "\nComputes the weighted loss.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.losses.cosine_distance", "path": "compat/v1/losses/cosine_distance", "type": "tf.compat", "text": "\nAdds a cosine-distance loss to the training procedure. (deprecated arguments)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.losses.get_losses", "path": "compat/v1/losses/get_losses", "type": "tf.compat", "text": "\nGets the list of losses from the loss_collection.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.losses.get_regularization_loss", "path": "compat/v1/losses/get_regularization_loss", "type": "tf.compat", "text": "\nGets the total regularization loss.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.losses.get_regularization_losses", "path": "compat/v1/losses/get_regularization_losses", "type": "tf.compat", "text": "\nGets the list of regularization losses.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.losses.get_total_loss", "path": "compat/v1/losses/get_total_loss", "type": "tf.compat", "text": "\nReturns a tensor whose value represents the total loss.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.losses.hinge_loss", "path": "compat/v1/losses/hinge_loss", "type": "tf.compat", "text": "\nAdds a hinge loss to the training procedure.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.losses.huber_loss", "path": "compat/v1/losses/huber_loss", "type": "tf.compat", "text": "\nAdds a Huber Loss term to the training procedure.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.losses.log_loss", "path": "compat/v1/losses/log_loss", "type": "tf.compat", "text": "\nAdds a Log Loss term to the training procedure.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.losses.mean_pairwise_squared_error", "path": "compat/v1/losses/mean_pairwise_squared_error", "type": "tf.compat", "text": "\nAdds a pairwise-errors-squared loss to the training procedure.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.losses.mean_squared_error", "path": "compat/v1/losses/mean_squared_error", "type": "tf.compat", "text": "\nAdds a Sum-of-Squares loss to the training procedure.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.losses.Reduction", "path": "compat/v1/losses/reduction", "type": "tf.compat", "text": "\nTypes of loss reduction.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.losses.sigmoid_cross_entropy", "path": "compat/v1/losses/sigmoid_cross_entropy", "type": "tf.compat", "text": "\nCreates a cross-entropy loss using tf.nn.sigmoid_cross_entropy_with_logits.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.losses.softmax_cross_entropy", "path": "compat/v1/losses/softmax_cross_entropy", "type": "tf.compat", "text": "\nCreates a cross-entropy loss using tf.nn.softmax_cross_entropy_with_logits_v2.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.losses.sparse_softmax_cross_entropy", "path": "compat/v1/losses/sparse_softmax_cross_entropy", "type": "tf.compat", "text": "\nCross-entropy loss using `tf.nn.sparse_softmax_cross_entropy_with_logits`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.make_template", "path": "compat/v1/make_template", "type": "tf.compat", "text": "\nGiven an arbitrary function, wrap it so that it does variable sharing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.manip", "path": "compat/v1/manip", "type": "tf.compat", "text": "\nOperators for manipulating tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.map_fn", "path": "compat/v1/map_fn", "type": "tf.compat", "text": "\nTransforms `elems` by applying `fn` to each element unstacked on axis 0.\n(deprecated arguments)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.math", "path": "compat/v1/math", "type": "tf.compat", "text": "\nMath Operations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.math.in_top_k", "path": "compat/v1/math/in_top_k", "type": "tf.compat", "text": "\nSays whether the targets are in the top `K` predictions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.math.log_softmax", "path": "compat/v1/math/log_softmax", "type": "tf.compat", "text": "\nComputes log softmax activations. (deprecated arguments)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.math.softmax", "path": "compat/v1/math/softmax", "type": "tf.compat", "text": "\nComputes softmax activations. (deprecated arguments)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.math.special", "path": "compat/v1/math/special", "type": "tf.compat", "text": "\nPublic API for tf.math.special namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.MetaGraphDef", "path": "compat/v1/metagraphdef", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.MetaGraphDef.CollectionDefEntry", "path": "compat/v1/metagraphdef/collectiondefentry", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.MetaGraphDef.MetaInfoDef", "path": "compat/v1/metagraphdef/metainfodef", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.MetaGraphDef.MetaInfoDef.FunctionAliasesEntry", "path": "compat/v1/metagraphdef/metainfodef/functionaliasesentry", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.MetaGraphDef.SignatureDefEntry", "path": "compat/v1/metagraphdef/signaturedefentry", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.metrics", "path": "compat/v1/metrics", "type": "tf.compat", "text": "\nEvaluation-related metrics.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.metrics.accuracy", "path": "compat/v1/metrics/accuracy", "type": "tf.compat", "text": "\nCalculates how often `predictions` matches `labels`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.metrics.auc", "path": "compat/v1/metrics/auc", "type": "tf.compat", "text": "\nComputes the approximate AUC via a Riemann sum. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.metrics.average_precision_at_k", "path": "compat/v1/metrics/average_precision_at_k", "type": "tf.compat", "text": "\nComputes average precision@k of predictions with respect to sparse labels.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.metrics.false_negatives", "path": "compat/v1/metrics/false_negatives", "type": "tf.compat", "text": "\nComputes the total number of false negatives.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.metrics.false_negatives_at_thresholds", "path": "compat/v1/metrics/false_negatives_at_thresholds", "type": "tf.compat", "text": "\nComputes false negatives at provided threshold values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.metrics.false_positives", "path": "compat/v1/metrics/false_positives", "type": "tf.compat", "text": "\nSum the weights of false positives.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.metrics.false_positives_at_thresholds", "path": "compat/v1/metrics/false_positives_at_thresholds", "type": "tf.compat", "text": "\nComputes false positives at provided threshold values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.metrics.mean", "path": "compat/v1/metrics/mean", "type": "tf.compat", "text": "\nComputes the (weighted) mean of the given values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.metrics.mean_absolute_error", "path": "compat/v1/metrics/mean_absolute_error", "type": "tf.compat", "text": "\nComputes the mean absolute error between the labels and predictions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.metrics.mean_cosine_distance", "path": "compat/v1/metrics/mean_cosine_distance", "type": "tf.compat", "text": "\nComputes the cosine distance between the labels and predictions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.metrics.mean_iou", "path": "compat/v1/metrics/mean_iou", "type": "tf.compat", "text": "\nCalculate per-step mean Intersection-Over-Union (mIOU).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.metrics.mean_per_class_accuracy", "path": "compat/v1/metrics/mean_per_class_accuracy", "type": "tf.compat", "text": "\nCalculates the mean of the per-class accuracies.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.metrics.mean_relative_error", "path": "compat/v1/metrics/mean_relative_error", "type": "tf.compat", "text": "\nComputes the mean relative error by normalizing with the given values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.metrics.mean_squared_error", "path": "compat/v1/metrics/mean_squared_error", "type": "tf.compat", "text": "\nComputes the mean squared error between the labels and predictions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.metrics.mean_tensor", "path": "compat/v1/metrics/mean_tensor", "type": "tf.compat", "text": "\nComputes the element-wise (weighted) mean of the given tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.metrics.percentage_below", "path": "compat/v1/metrics/percentage_below", "type": "tf.compat", "text": "\nComputes the percentage of values less than the given threshold.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.metrics.precision", "path": "compat/v1/metrics/precision", "type": "tf.compat", "text": "\nComputes the precision of the predictions with respect to the labels.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.metrics.precision_at_k", "path": "compat/v1/metrics/precision_at_k", "type": "tf.compat", "text": "\nComputes precision@k of the predictions with respect to sparse labels.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.metrics.precision_at_thresholds", "path": "compat/v1/metrics/precision_at_thresholds", "type": "tf.compat", "text": "\nComputes precision values for different `thresholds` on `predictions`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.metrics.precision_at_top_k", "path": "compat/v1/metrics/precision_at_top_k", "type": "tf.compat", "text": "\nComputes precision@k of the predictions with respect to sparse labels.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.metrics.recall", "path": "compat/v1/metrics/recall", "type": "tf.compat", "text": "\nComputes the recall of the predictions with respect to the labels.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.metrics.recall_at_k", "path": "compat/v1/metrics/recall_at_k", "type": "tf.compat", "text": "\nComputes recall@k of the predictions with respect to sparse labels.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.metrics.recall_at_thresholds", "path": "compat/v1/metrics/recall_at_thresholds", "type": "tf.compat", "text": "\nComputes various recall values for different `thresholds` on `predictions`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.metrics.recall_at_top_k", "path": "compat/v1/metrics/recall_at_top_k", "type": "tf.compat", "text": "\nComputes recall@k of top-k predictions with respect to sparse labels.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.metrics.root_mean_squared_error", "path": "compat/v1/metrics/root_mean_squared_error", "type": "tf.compat", "text": "\nComputes the root mean squared error between the labels and predictions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.metrics.sensitivity_at_specificity", "path": "compat/v1/metrics/sensitivity_at_specificity", "type": "tf.compat", "text": "\nComputes the specificity at a given sensitivity.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.metrics.sparse_average_precision_at_k", "path": "compat/v1/metrics/sparse_average_precision_at_k", "type": "tf.compat", "text": "\nRenamed to `average_precision_at_k`, please use that method instead.\n(deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.metrics.sparse_precision_at_k", "path": "compat/v1/metrics/sparse_precision_at_k", "type": "tf.compat", "text": "\nRenamed to `precision_at_k`, please use that method instead. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.metrics.specificity_at_sensitivity", "path": "compat/v1/metrics/specificity_at_sensitivity", "type": "tf.compat", "text": "\nComputes the specificity at a given sensitivity.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.metrics.true_negatives", "path": "compat/v1/metrics/true_negatives", "type": "tf.compat", "text": "\nSum the weights of true_negatives.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.metrics.true_negatives_at_thresholds", "path": "compat/v1/metrics/true_negatives_at_thresholds", "type": "tf.compat", "text": "\nComputes true negatives at provided threshold values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.metrics.true_positives", "path": "compat/v1/metrics/true_positives", "type": "tf.compat", "text": "\nSum the weights of true_positives.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.metrics.true_positives_at_thresholds", "path": "compat/v1/metrics/true_positives_at_thresholds", "type": "tf.compat", "text": "\nComputes true positives at provided threshold values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.min_max_variable_partitioner", "path": "compat/v1/min_max_variable_partitioner", "type": "tf.compat", "text": "\nPartitioner to allocate minimum size per slice.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.mixed_precision", "path": "compat/v1/mixed_precision", "type": "tf.compat", "text": "\nPublic API for tf.mixed_precision namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.mixed_precision.disable_mixed_precision_graph_rewrite", "path": "compat/v1/mixed_precision/disable_mixed_precision_graph_rewrite", "type": "tf.compat", "text": "\nDisables the mixed precision graph rewrite.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.mixed_precision.enable_mixed_precision_graph_rewrite", "path": "compat/v1/mixed_precision/enable_mixed_precision_graph_rewrite", "type": "tf.compat", "text": "\nEnable mixed precision via a graph rewrite.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.mixed_precision.experimental", "path": "compat/v1/mixed_precision/experimental", "type": "tf.compat", "text": "\nPublic API for tf.mixed_precision.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.mixed_precision.MixedPrecisionLossScaleOptimizer", "path": "compat/v1/mixed_precision/mixedprecisionlossscaleoptimizer", "type": "tf.compat", "text": "\nAn optimizer that applies loss scaling.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.mlir", "path": "compat/v1/mlir", "type": "tf.compat", "text": "\nPublic API for tf.mlir namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.mlir.experimental", "path": "compat/v1/mlir/experimental", "type": "tf.compat", "text": "\nPublic API for tf.mlir.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.model_variables", "path": "compat/v1/model_variables", "type": "tf.compat", "text": "\nReturns all variables in the MODEL_VARIABLES collection.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.moving_average_variables", "path": "compat/v1/moving_average_variables", "type": "tf.compat", "text": "\nReturns all variables that maintain their moving averages.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.multinomial", "path": "compat/v1/multinomial", "type": "tf.compat", "text": "\nDraws samples from a multinomial distribution. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.NameAttrList", "path": "compat/v1/nameattrlist", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.NameAttrList.AttrEntry", "path": "compat/v1/nameattrlist/attrentry", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nest", "path": "compat/v1/nest", "type": "tf.compat", "text": "\nPublic API for tf.nest namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn", "path": "compat/v1/nn", "type": "tf.compat", "text": "\nWrappers for primitive Neural Net (NN) Operations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.avg_pool", "path": "compat/v1/nn/avg_pool", "type": "tf.compat", "text": "\nPerforms the average pooling on the input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.batch_norm_with_global_normalization", "path": "compat/v1/nn/batch_norm_with_global_normalization", "type": "tf.compat", "text": "\nBatch normalization.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.bidirectional_dynamic_rnn", "path": "compat/v1/nn/bidirectional_dynamic_rnn", "type": "tf.compat", "text": "\nCreates a dynamic version of bidirectional recurrent neural network.\n(deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.conv1d", "path": "compat/v1/nn/conv1d", "type": "tf.compat", "text": "\nComputes a 1-D convolution of input with rank `>=3` and a `3-D` filter.\n(deprecated argument values) (deprecated argument values)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.conv2d", "path": "compat/v1/nn/conv2d", "type": "tf.compat", "text": "\nComputes a 2-D convolution given 4-D `input` and `filter` tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.conv2d_backprop_filter", "path": "compat/v1/nn/conv2d_backprop_filter", "type": "tf.compat", "text": "\nComputes the gradients of convolution with respect to the filter.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.conv2d_backprop_input", "path": "compat/v1/nn/conv2d_backprop_input", "type": "tf.compat", "text": "\nComputes the gradients of convolution with respect to the input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.conv2d_transpose", "path": "compat/v1/nn/conv2d_transpose", "type": "tf.compat", "text": "\nThe transpose of `conv2d`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.conv3d", "path": "compat/v1/nn/conv3d", "type": "tf.compat", "text": "\nComputes a 3-D convolution given 5-D `input` and `filter` tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.conv3d_backprop_filter", "path": "compat/v1/nn/conv3d_backprop_filter", "type": "tf.compat", "text": "\nComputes the gradients of 3-D convolution with respect to the filter.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.conv3d_transpose", "path": "compat/v1/nn/conv3d_transpose", "type": "tf.compat", "text": "\nThe transpose of `conv3d`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.convolution", "path": "compat/v1/nn/convolution", "type": "tf.compat", "text": "\nComputes sums of N-D convolutions (actually cross-correlation).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.crelu", "path": "compat/v1/nn/crelu", "type": "tf.compat", "text": "\nComputes Concatenated ReLU.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.ctc_beam_search_decoder", "path": "compat/v1/nn/ctc_beam_search_decoder", "type": "tf.compat", "text": "\nPerforms beam search decoding on the logits given in input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.ctc_loss", "path": "compat/v1/nn/ctc_loss", "type": "tf.compat", "text": "\nComputes the CTC (Connectionist Temporal Classification) Loss.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.ctc_loss_v2", "path": "compat/v1/nn/ctc_loss_v2", "type": "tf.compat", "text": "\nComputes CTC (Connectionist Temporal Classification) loss.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.depthwise_conv2d", "path": "compat/v1/nn/depthwise_conv2d", "type": "tf.compat", "text": "\nDepthwise 2-D convolution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.depthwise_conv2d_native", "path": "compat/v1/nn/depthwise_conv2d_native", "type": "tf.compat", "text": "\nComputes a 2-D depthwise convolution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.dilation2d", "path": "compat/v1/nn/dilation2d", "type": "tf.compat", "text": "\nComputes the grayscale dilation of 4-D `input` and 3-D `filter` tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.dropout", "path": "compat/v1/nn/dropout", "type": "tf.compat", "text": "\nComputes dropout. (deprecated arguments)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.dynamic_rnn", "path": "compat/v1/nn/dynamic_rnn", "type": "tf.compat", "text": "\nCreates a recurrent neural network specified by RNNCell `cell`. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.embedding_lookup", "path": "compat/v1/nn/embedding_lookup", "type": "tf.compat", "text": "\nLooks up embeddings for the given `ids` from a list of tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.embedding_lookup_sparse", "path": "compat/v1/nn/embedding_lookup_sparse", "type": "tf.compat", "text": "\nLooks up embeddings for the given ids and weights from a list of tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.erosion2d", "path": "compat/v1/nn/erosion2d", "type": "tf.compat", "text": "\nComputes the grayscale erosion of 4-D `value` and 3-D `kernel` tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.fractional_avg_pool", "path": "compat/v1/nn/fractional_avg_pool", "type": "tf.compat", "text": "\nPerforms fractional average pooling on the input. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.fractional_max_pool", "path": "compat/v1/nn/fractional_max_pool", "type": "tf.compat", "text": "\nPerforms fractional max pooling on the input. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.fused_batch_norm", "path": "compat/v1/nn/fused_batch_norm", "type": "tf.compat", "text": "\nBatch normalization.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.max_pool", "path": "compat/v1/nn/max_pool", "type": "tf.compat", "text": "\nPerforms the max pooling on the input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.max_pool_with_argmax", "path": "compat/v1/nn/max_pool_with_argmax", "type": "tf.compat", "text": "\nPerforms max pooling on the input and outputs both max values and indices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.moments", "path": "compat/v1/nn/moments", "type": "tf.compat", "text": "\nCalculate the mean and variance of `x`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.nce_loss", "path": "compat/v1/nn/nce_loss", "type": "tf.compat", "text": "\nComputes and returns the noise-contrastive estimation training loss.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.pool", "path": "compat/v1/nn/pool", "type": "tf.compat", "text": "\nPerforms an N-D pooling operation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.quantized_avg_pool", "path": "compat/v1/nn/quantized_avg_pool", "type": "tf.compat", "text": "\nProduces the average pool of the input tensor for quantized types.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.quantized_conv2d", "path": "compat/v1/nn/quantized_conv2d", "type": "tf.compat", "text": "\nComputes a 2D convolution given quantized 4D input and filter tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.quantized_max_pool", "path": "compat/v1/nn/quantized_max_pool", "type": "tf.compat", "text": "\nProduces the max pool of the input tensor for quantized types.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.quantized_relu_x", "path": "compat/v1/nn/quantized_relu_x", "type": "tf.compat", "text": "\nComputes Quantized Rectified Linear X: `min(max(features, 0), max_value)`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.raw_rnn", "path": "compat/v1/nn/raw_rnn", "type": "tf.compat", "text": "\nCreates an `RNN` specified by RNNCell `cell` and loop function `loop_fn`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.relu_layer", "path": "compat/v1/nn/relu_layer", "type": "tf.compat", "text": "\nComputes Relu(x * weight + biases).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.rnn_cell", "path": "compat/v1/nn/rnn_cell", "type": "tf.compat", "text": "\nModule for constructing RNN Cells.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.rnn_cell.BasicLSTMCell", "path": "compat/v1/nn/rnn_cell/basiclstmcell", "type": "tf.compat", "text": "\nDEPRECATED: Please use `tf.compat.v1.nn.rnn_cell.LSTMCell` instead.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.rnn_cell.BasicRNNCell", "path": "compat/v1/nn/rnn_cell/basicrnncell", "type": "tf.compat", "text": "\nThe most basic RNN cell.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.rnn_cell.DeviceWrapper", "path": "compat/v1/nn/rnn_cell/devicewrapper", "type": "tf.compat", "text": "\nOperator that ensures an RNNCell runs on a particular device.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.rnn_cell.DropoutWrapper", "path": "compat/v1/nn/rnn_cell/dropoutwrapper", "type": "tf.compat", "text": "\nOperator adding dropout to inputs and outputs of the given cell.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.rnn_cell.GRUCell", "path": "compat/v1/nn/rnn_cell/grucell", "type": "tf.compat", "text": "\nGated Recurrent Unit cell.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.rnn_cell.LSTMCell", "path": "compat/v1/nn/rnn_cell/lstmcell", "type": "tf.compat", "text": "\nLong short-term memory unit (LSTM) recurrent network cell.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.rnn_cell.LSTMStateTuple", "path": "compat/v1/nn/rnn_cell/lstmstatetuple", "type": "tf.compat", "text": "\nTuple used by LSTM Cells for `state_size`, `zero_state`, and output state.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.rnn_cell.MultiRNNCell", "path": "compat/v1/nn/rnn_cell/multirnncell", "type": "tf.compat", "text": "\nRNN cell composed sequentially of multiple simple cells.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.rnn_cell.ResidualWrapper", "path": "compat/v1/nn/rnn_cell/residualwrapper", "type": "tf.compat", "text": "\nRNNCell wrapper that ensures cell inputs are added to the outputs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.rnn_cell.RNNCell", "path": "compat/v1/nn/rnn_cell/rnncell", "type": "tf.compat", "text": "\nAbstract object representing an RNN cell.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.safe_embedding_lookup_sparse", "path": "compat/v1/nn/safe_embedding_lookup_sparse", "type": "tf.compat", "text": "\nLookup embedding results, accounting for invalid IDs and empty features.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.sampled_softmax_loss", "path": "compat/v1/nn/sampled_softmax_loss", "type": "tf.compat", "text": "\nComputes and returns the sampled softmax training loss.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.separable_conv2d", "path": "compat/v1/nn/separable_conv2d", "type": "tf.compat", "text": "\n2-D convolution with separable filters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.sigmoid_cross_entropy_with_logits", "path": "compat/v1/nn/sigmoid_cross_entropy_with_logits", "type": "tf.compat", "text": "\nComputes sigmoid cross entropy given `logits`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.softmax_cross_entropy_with_logits", "path": "compat/v1/nn/softmax_cross_entropy_with_logits", "type": "tf.compat", "text": "\nComputes softmax cross entropy between `logits` and `labels`. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.softmax_cross_entropy_with_logits_v2", "path": "compat/v1/nn/softmax_cross_entropy_with_logits_v2", "type": "tf.compat", "text": "\nComputes softmax cross entropy between `logits` and `labels`. (deprecated\narguments)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.sparse_softmax_cross_entropy_with_logits", "path": "compat/v1/nn/sparse_softmax_cross_entropy_with_logits", "type": "tf.compat", "text": "\nComputes sparse softmax cross entropy between `logits` and `labels`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.static_bidirectional_rnn", "path": "compat/v1/nn/static_bidirectional_rnn", "type": "tf.compat", "text": "\nCreates a bidirectional recurrent neural network. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.static_rnn", "path": "compat/v1/nn/static_rnn", "type": "tf.compat", "text": "\nCreates a recurrent neural network specified by RNNCell `cell`. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.static_state_saving_rnn", "path": "compat/v1/nn/static_state_saving_rnn", "type": "tf.compat", "text": "\nRNN that accepts a state saver for time-truncated RNN calculation.\n(deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.sufficient_statistics", "path": "compat/v1/nn/sufficient_statistics", "type": "tf.compat", "text": "\nCalculate the sufficient statistics for the mean and variance of `x`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.weighted_cross_entropy_with_logits", "path": "compat/v1/nn/weighted_cross_entropy_with_logits", "type": "tf.compat", "text": "\nComputes a weighted cross entropy. (deprecated arguments)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.weighted_moments", "path": "compat/v1/nn/weighted_moments", "type": "tf.compat", "text": "\nReturns the frequency-weighted mean and variance of `x`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.nn.xw_plus_b", "path": "compat/v1/nn/xw_plus_b", "type": "tf.compat", "text": "\nComputes matmul(x, weights) + biases.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.NodeDef", "path": "compat/v1/nodedef", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.NodeDef.AttrEntry", "path": "compat/v1/nodedef/attrentry", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.NodeDef.ExperimentalDebugInfo", "path": "compat/v1/nodedef/experimentaldebuginfo", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.norm", "path": "compat/v1/norm", "type": "tf.compat", "text": "\nComputes the norm of vectors, matrices, and tensors. (deprecated arguments)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.no_regularizer", "path": "compat/v1/no_regularizer", "type": "tf.compat", "text": "\nUse this function to prevent regularization of variables.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.ones_like", "path": "compat/v1/ones_like", "type": "tf.compat", "text": "\nCreates a tensor with all elements set to 1.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.OptimizerOptions", "path": "compat/v1/optimizeroptions", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.op_scope", "path": "compat/v1/op_scope", "type": "tf.compat", "text": "\nDEPRECATED. Same as name_scope above, just different argument order.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.pad", "path": "compat/v1/pad", "type": "tf.compat", "text": "\nPads a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.parse_example", "path": "compat/v1/parse_example", "type": "tf.compat", "text": "\nParses `Example` protos into a `dict` of tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.parse_single_example", "path": "compat/v1/parse_single_example", "type": "tf.compat", "text": "\nParses a single `Example` proto.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.placeholder", "path": "compat/v1/placeholder", "type": "tf.compat", "text": "\nInserts a placeholder for a tensor that will be always fed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.placeholder_with_default", "path": "compat/v1/placeholder_with_default", "type": "tf.compat", "text": "\nA placeholder op that passes through `input` when its output is not fed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.Print", "path": "compat/v1/print", "type": "tf.compat", "text": "\nPrints a list of tensors. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.profiler", "path": "compat/v1/profiler", "type": "tf.compat", "text": "\nPublic API for tf.profiler namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.profiler.AdviceProto", "path": "compat/v1/profiler/adviceproto", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.profiler.AdviceProto.Checker", "path": "compat/v1/profiler/adviceproto/checker", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.profiler.AdviceProto.CheckersEntry", "path": "compat/v1/profiler/adviceproto/checkersentry", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.profiler.advise", "path": "compat/v1/profiler/advise", "type": "tf.compat", "text": "\nAuto profile and advise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.profiler.GraphNodeProto", "path": "compat/v1/profiler/graphnodeproto", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.profiler.GraphNodeProto.InputShapesEntry", "path": "compat/v1/profiler/graphnodeproto/inputshapesentry", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.profiler.MultiGraphNodeProto", "path": "compat/v1/profiler/multigraphnodeproto", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.profiler.OpLogProto", "path": "compat/v1/profiler/oplogproto", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.profiler.OpLogProto.IdToStringEntry", "path": "compat/v1/profiler/oplogproto/idtostringentry", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.profiler.profile", "path": "compat/v1/profiler/profile", "type": "tf.compat", "text": "\nProfile model.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.profiler.ProfileOptionBuilder", "path": "compat/v1/profiler/profileoptionbuilder", "type": "tf.compat", "text": "\nOption Builder for Profiling API.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.profiler.Profiler", "path": "compat/v1/profiler/profiler", "type": "tf.compat", "text": "\nTensorFlow multi-step profiler.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.profiler.write_op_log", "path": "compat/v1/profiler/write_op_log", "type": "tf.compat", "text": "\nLog provided 'op_log', and add additional model information below.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.python_io", "path": "compat/v1/python_io", "type": "tf.compat", "text": "\nPython functions for directly manipulating TFRecord-formatted files.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.py_func", "path": "compat/v1/py_func", "type": "tf.compat", "text": "\nWraps a python function and uses it as a TensorFlow op.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.quantization", "path": "compat/v1/quantization", "type": "tf.compat", "text": "\nPublic API for tf.quantization namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.quantize_v2", "path": "compat/v1/quantize_v2", "type": "tf.compat", "text": "\nPlease use `tf.quantization.quantize` instead.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.queue", "path": "compat/v1/queue", "type": "tf.compat", "text": "\nPublic API for tf.queue namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.ragged", "path": "compat/v1/ragged", "type": "tf.compat", "text": "\nRagged Tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.ragged.constant_value", "path": "compat/v1/ragged/constant_value", "type": "tf.compat", "text": "\nConstructs a RaggedTensorValue from a nested Python list.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.ragged.placeholder", "path": "compat/v1/ragged/placeholder", "type": "tf.compat", "text": "\nCreates a placeholder for a `tf.RaggedTensor` that will always be fed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.ragged.RaggedTensorValue", "path": "compat/v1/ragged/raggedtensorvalue", "type": "tf.compat", "text": "\nRepresents the value of a `RaggedTensor`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.random", "path": "compat/v1/random", "type": "tf.compat", "text": "\nPublic API for tf.random namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.random.experimental", "path": "compat/v1/random/experimental", "type": "tf.compat", "text": "\nPublic API for tf.random.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.random.stateless_multinomial", "path": "compat/v1/random/stateless_multinomial", "type": "tf.compat", "text": "\nDraws deterministic pseudorandom samples from a multinomial distribution.\n(deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.random_normal_initializer", "path": "compat/v1/random_normal_initializer", "type": "tf.compat", "text": "\nInitializer that generates tensors with a normal distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.random_poisson", "path": "compat/v1/random_poisson", "type": "tf.compat", "text": "\nDraws `shape` samples from each of the given Poisson distribution(s).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.random_uniform_initializer", "path": "compat/v1/random_uniform_initializer", "type": "tf.compat", "text": "\nInitializer that generates tensors with a uniform distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.raw_ops", "path": "compat/v1/raw_ops", "type": "tf.compat", "text": "\nPublic API for tf.raw_ops namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.ReaderBase", "path": "compat/v1/readerbase", "type": "tf.compat", "text": "\nBase class for different Reader types, that produce a record every step.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.reduce_all", "path": "compat/v1/reduce_all", "type": "tf.compat", "text": "\nComputes the \"logical and\" of elements across dimensions of a tensor.\n(deprecated arguments)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.reduce_any", "path": "compat/v1/reduce_any", "type": "tf.compat", "text": "\nComputes the \"logical or\" of elements across dimensions of a tensor.\n(deprecated arguments)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.reduce_join", "path": "compat/v1/reduce_join", "type": "tf.compat", "text": "\nJoins all strings into a single string, or joins along an axis.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.reduce_logsumexp", "path": "compat/v1/reduce_logsumexp", "type": "tf.compat", "text": "\nComputes log(sum(exp(elements across dimensions of a tensor))). (deprecated\narguments)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.reduce_max", "path": "compat/v1/reduce_max", "type": "tf.compat", "text": "\nComputes the maximum of elements across dimensions of a tensor. (deprecated\narguments)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.reduce_mean", "path": "compat/v1/reduce_mean", "type": "tf.compat", "text": "\nComputes the mean of elements across dimensions of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.reduce_min", "path": "compat/v1/reduce_min", "type": "tf.compat", "text": "\nComputes the minimum of elements across dimensions of a tensor. (deprecated\narguments)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.reduce_prod", "path": "compat/v1/reduce_prod", "type": "tf.compat", "text": "\nComputes the product of elements across dimensions of a tensor. (deprecated\narguments)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.reduce_sum", "path": "compat/v1/reduce_sum", "type": "tf.compat", "text": "\nComputes the sum of elements across dimensions of a tensor. (deprecated\narguments)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.report_uninitialized_variables", "path": "compat/v1/report_uninitialized_variables", "type": "tf.compat", "text": "\nAdds ops to list the names of uninitialized variables.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.reset_default_graph", "path": "compat/v1/reset_default_graph", "type": "tf.compat", "text": "\nClears the default graph stack and resets the global default graph.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.resource_loader", "path": "compat/v1/resource_loader", "type": "tf.compat", "text": "\nResource management library.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.resource_loader.get_data_files_path", "path": "compat/v1/resource_loader/get_data_files_path", "type": "tf.compat", "text": "\nGet a direct path to the data files colocated with the script.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.resource_loader.get_path_to_datafile", "path": "compat/v1/resource_loader/get_path_to_datafile", "type": "tf.compat", "text": "\nGet the path to the specified file in the data dependencies.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.resource_loader.get_root_dir_with_all_resources", "path": "compat/v1/resource_loader/get_root_dir_with_all_resources", "type": "tf.compat", "text": "\nGet a root directory containing all the data attributes in the build rule.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.resource_loader.load_resource", "path": "compat/v1/resource_loader/load_resource", "type": "tf.compat", "text": "\nLoad the resource at given path, where path is relative to tensorflow/.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.resource_loader.readahead_file_path", "path": "compat/v1/resource_loader/readahead_file_path", "type": "tf.compat", "text": "\nReadahead files not implemented; simply returns given path.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.resource_variables_enabled", "path": "compat/v1/resource_variables_enabled", "type": "tf.compat", "text": "\nReturns `True` if resource variables are enabled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.reverse_sequence", "path": "compat/v1/reverse_sequence", "type": "tf.compat", "text": "\nReverses variable length slices. (deprecated arguments) (deprecated arguments)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.RunMetadata", "path": "compat/v1/runmetadata", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.RunMetadata.FunctionGraphs", "path": "compat/v1/runmetadata/functiongraphs", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.RunOptions", "path": "compat/v1/runoptions", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.RunOptions.Experimental", "path": "compat/v1/runoptions/experimental", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.RunOptions.Experimental.RunHandlerPoolOptions", "path": "compat/v1/runoptions/experimental/runhandlerpooloptions", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.saved_model", "path": "compat/v1/saved_model", "type": "tf.compat", "text": "\nPublic API for tf.saved_model namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.saved_model.builder", "path": "compat/v1/saved_model/builder", "type": "tf.compat", "text": "\nSavedModel builder.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.saved_model.build_signature_def", "path": "compat/v1/saved_model/build_signature_def", "type": "tf.compat", "text": "\nUtility function to build a SignatureDef protocol buffer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.saved_model.build_tensor_info", "path": "compat/v1/saved_model/build_tensor_info", "type": "tf.compat", "text": "\nUtility function to build TensorInfo proto from a Tensor. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.saved_model.classification_signature_def", "path": "compat/v1/saved_model/classification_signature_def", "type": "tf.compat", "text": "\nCreates classification signature from given examples and predictions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.saved_model.constants", "path": "compat/v1/saved_model/constants", "type": "tf.compat", "text": "\nConstants for SavedModel save and restore operations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.saved_model.contains_saved_model", "path": "compat/v1/saved_model/contains_saved_model", "type": "tf.compat", "text": "\nChecks whether the provided export directory could contain a SavedModel.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.saved_model.experimental", "path": "compat/v1/saved_model/experimental", "type": "tf.compat", "text": "\nPublic API for tf.saved_model.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.saved_model.get_tensor_from_tensor_info", "path": "compat/v1/saved_model/get_tensor_from_tensor_info", "type": "tf.compat", "text": "\nReturns the Tensor or CompositeTensor described by a TensorInfo proto.\n(deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.saved_model.is_valid_signature", "path": "compat/v1/saved_model/is_valid_signature", "type": "tf.compat", "text": "\nDetermine whether a SignatureDef can be served by TensorFlow Serving.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.saved_model.load", "path": "compat/v1/saved_model/load", "type": "tf.compat", "text": "\nLoads the model from a SavedModel as specified by tags. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.saved_model.loader", "path": "compat/v1/saved_model/loader", "type": "tf.compat", "text": "\nLoader functionality for SavedModel with hermetic, language-neutral exports.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.saved_model.main_op", "path": "compat/v1/saved_model/main_op", "type": "tf.compat", "text": "\nSavedModel main op.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.saved_model.main_op.main_op", "path": "compat/v1/saved_model/main_op/main_op", "type": "tf.compat", "text": "\nReturns a main op to init variables and tables. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.saved_model.main_op_with_restore", "path": "compat/v1/saved_model/main_op_with_restore", "type": "tf.compat", "text": "\nReturns a main op to init variables, tables and restore the graph.\n(deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.saved_model.predict_signature_def", "path": "compat/v1/saved_model/predict_signature_def", "type": "tf.compat", "text": "\nCreates prediction signature from given inputs and outputs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.saved_model.regression_signature_def", "path": "compat/v1/saved_model/regression_signature_def", "type": "tf.compat", "text": "\nCreates regression signature from given examples and predictions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.saved_model.signature_constants", "path": "compat/v1/saved_model/signature_constants", "type": "tf.compat", "text": "\nSignature constants for SavedModel save and restore operations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.saved_model.signature_def_utils", "path": "compat/v1/saved_model/signature_def_utils", "type": "tf.compat", "text": "\nSignatureDef utility functions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.saved_model.signature_def_utils.MethodNameUpdater", "path": "compat/v1/saved_model/signature_def_utils/methodnameupdater", "type": "tf.compat", "text": "\nUpdates the method name(s) of the SavedModel stored in the given path.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.saved_model.simple_save", "path": "compat/v1/saved_model/simple_save", "type": "tf.compat", "text": "\nConvenience function to build a SavedModel suitable for serving. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.saved_model.tag_constants", "path": "compat/v1/saved_model/tag_constants", "type": "tf.compat", "text": "\nCommon tags used for graphs in SavedModel.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.saved_model.utils", "path": "compat/v1/saved_model/utils", "type": "tf.compat", "text": "\nSavedModel utility functions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.scalar_mul", "path": "compat/v1/scalar_mul", "type": "tf.compat", "text": "\nMultiplies a scalar times a `Tensor` or `IndexedSlices` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.scan", "path": "compat/v1/scan", "type": "tf.compat", "text": "\nscan on the list of tensors unpacked from `elems` on dimension 0.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.scatter_add", "path": "compat/v1/scatter_add", "type": "tf.compat", "text": "\nAdds sparse updates to the variable referenced by `resource`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.scatter_div", "path": "compat/v1/scatter_div", "type": "tf.compat", "text": "\nDivides a variable reference by sparse updates.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.scatter_max", "path": "compat/v1/scatter_max", "type": "tf.compat", "text": "\nReduces sparse updates into a variable reference using the `max` operation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.scatter_min", "path": "compat/v1/scatter_min", "type": "tf.compat", "text": "\nReduces sparse updates into a variable reference using the `min` operation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.scatter_mul", "path": "compat/v1/scatter_mul", "type": "tf.compat", "text": "\nMultiplies sparse updates into a variable reference.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.scatter_nd_add", "path": "compat/v1/scatter_nd_add", "type": "tf.compat", "text": "\nApplies sparse addition to individual values or slices in a Variable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.scatter_nd_sub", "path": "compat/v1/scatter_nd_sub", "type": "tf.compat", "text": "\nApplies sparse subtraction to individual values or slices in a Variable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.scatter_nd_update", "path": "compat/v1/scatter_nd_update", "type": "tf.compat", "text": "\nApplies sparse `updates` to individual values or slices in a Variable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.scatter_sub", "path": "compat/v1/scatter_sub", "type": "tf.compat", "text": "\nSubtracts sparse updates to a variable reference.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.scatter_update", "path": "compat/v1/scatter_update", "type": "tf.compat", "text": "\nApplies sparse updates to a variable reference.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.serialize_many_sparse", "path": "compat/v1/serialize_many_sparse", "type": "tf.compat", "text": "\nSerialize `N`-minibatch `SparseTensor` into an `[N, 3]` `Tensor`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.serialize_sparse", "path": "compat/v1/serialize_sparse", "type": "tf.compat", "text": "\nSerialize a `SparseTensor` into a 3-vector (1-D `Tensor`) object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.Session", "path": "compat/v1/session", "type": "tf.compat", "text": "\nA class for running TensorFlow operations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.SessionLog", "path": "compat/v1/sessionlog", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.setdiff1d", "path": "compat/v1/setdiff1d", "type": "tf.compat", "text": "\nComputes the difference between two lists of numbers or strings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.sets", "path": "compat/v1/sets", "type": "tf.compat", "text": "\nTensorflow set operations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.set_random_seed", "path": "compat/v1/set_random_seed", "type": "tf.compat", "text": "\nSets the graph-level random seed for the default graph.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.shape", "path": "compat/v1/shape", "type": "tf.compat", "text": "\nReturns the shape of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.signal", "path": "compat/v1/signal", "type": "tf.compat", "text": "\nSignal processing operations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.size", "path": "compat/v1/size", "type": "tf.compat", "text": "\nReturns the size of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.space_to_batch", "path": "compat/v1/space_to_batch", "type": "tf.compat", "text": "\nSpaceToBatch for 4-D tensors of type T.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.space_to_depth", "path": "compat/v1/space_to_depth", "type": "tf.compat", "text": "\nSpaceToDepth for tensors of type T.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.sparse", "path": "compat/v1/sparse", "type": "tf.compat", "text": "\nSparse Tensor Representation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.SparseConditionalAccumulator", "path": "compat/v1/sparseconditionalaccumulator", "type": "tf.compat", "text": "\nA conditional accumulator for aggregating sparse gradients.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.SparseTensorValue", "path": "compat/v1/sparsetensorvalue", "type": "tf.compat", "text": "\nSparseTensorValue(indices, values, dense_shape)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.sparse_add", "path": "compat/v1/sparse_add", "type": "tf.compat", "text": "\nAdds two tensors, at least one of each is a `SparseTensor`. (deprecated\narguments)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.sparse_concat", "path": "compat/v1/sparse_concat", "type": "tf.compat", "text": "\nConcatenates a list of `SparseTensor` along the specified dimension.\n(deprecated arguments)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.sparse_matmul", "path": "compat/v1/sparse_matmul", "type": "tf.compat", "text": "\nMultiply matrix \"a\" by matrix \"b\".\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.sparse_merge", "path": "compat/v1/sparse_merge", "type": "tf.compat", "text": "\nCombines a batch of feature ids and values into a single `SparseTensor`.\n(deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.sparse_placeholder", "path": "compat/v1/sparse_placeholder", "type": "tf.compat", "text": "\nInserts a placeholder for a sparse tensor that will be always fed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.sparse_reduce_max", "path": "compat/v1/sparse_reduce_max", "type": "tf.compat", "text": "\nComputes the max of elements across dimensions of a SparseTensor. (deprecated\narguments) (deprecated arguments)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.sparse_reduce_max_sparse", "path": "compat/v1/sparse_reduce_max_sparse", "type": "tf.compat", "text": "\nComputes the max of elements across dimensions of a SparseTensor. (deprecated\narguments)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.sparse_reduce_sum", "path": "compat/v1/sparse_reduce_sum", "type": "tf.compat", "text": "\nComputes the sum of elements across dimensions of a SparseTensor. (deprecated\narguments) (deprecated arguments)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.sparse_reduce_sum_sparse", "path": "compat/v1/sparse_reduce_sum_sparse", "type": "tf.compat", "text": "\nComputes the sum of elements across dimensions of a SparseTensor. (deprecated\narguments)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.sparse_segment_mean", "path": "compat/v1/sparse_segment_mean", "type": "tf.compat", "text": "\nComputes the mean along sparse segments of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.sparse_segment_sqrt_n", "path": "compat/v1/sparse_segment_sqrt_n", "type": "tf.compat", "text": "\nComputes the sum along sparse segments of a tensor divided by the sqrt(N).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.sparse_segment_sum", "path": "compat/v1/sparse_segment_sum", "type": "tf.compat", "text": "\nComputes the sum along sparse segments of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.sparse_split", "path": "compat/v1/sparse_split", "type": "tf.compat", "text": "\nSplit a `SparseTensor` into `num_split` tensors along `axis`. (deprecated\narguments)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.sparse_to_dense", "path": "compat/v1/sparse_to_dense", "type": "tf.compat", "text": "\nConverts a sparse representation into a dense tensor. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.spectral", "path": "compat/v1/spectral", "type": "tf.compat", "text": "\nPublic API for tf.spectral namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.squeeze", "path": "compat/v1/squeeze", "type": "tf.compat", "text": "\nRemoves dimensions of size 1 from the shape of a tensor. (deprecated\narguments)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.strings", "path": "compat/v1/strings", "type": "tf.compat", "text": "\nOperations for working with string Tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.strings.length", "path": "compat/v1/strings/length", "type": "tf.compat", "text": "\nComputes the length of each string given in the input tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.strings.split", "path": "compat/v1/strings/split", "type": "tf.compat", "text": "\nSplit elements of `input` based on `sep`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.strings.substr", "path": "compat/v1/strings/substr", "type": "tf.compat", "text": "\nReturn substrings from `Tensor` of strings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.string_split", "path": "compat/v1/string_split", "type": "tf.compat", "text": "\nSplit elements of `source` based on `delimiter`. (deprecated arguments)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.string_to_hash_bucket", "path": "compat/v1/string_to_hash_bucket", "type": "tf.compat", "text": "\nConverts each string in the input Tensor to its hash mod by a number of\nbuckets.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.string_to_number", "path": "compat/v1/string_to_number", "type": "tf.compat", "text": "\nConverts each string in the input Tensor to the specified numeric type.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.substr", "path": "compat/v1/substr", "type": "tf.compat", "text": "\nReturn substrings from `Tensor` of strings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.summary", "path": "compat/v1/summary", "type": "tf.compat", "text": "\nOperations for writing summary data, for use in analysis and visualization.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.summary.all_v2_summary_ops", "path": "compat/v1/summary/all_v2_summary_ops", "type": "tf.compat", "text": "\nReturns all V2-style summary ops defined in the current default graph.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.summary.audio", "path": "compat/v1/summary/audio", "type": "tf.compat", "text": "\nOutputs a `Summary` protocol buffer with audio.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.summary.FileWriter", "path": "compat/v1/summary/filewriter", "type": "tf.compat", "text": "\nWrites `Summary` protocol buffers to event files.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.summary.FileWriterCache", "path": "compat/v1/summary/filewritercache", "type": "tf.compat", "text": "\nCache for file writers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.summary.get_summary_description", "path": "compat/v1/summary/get_summary_description", "type": "tf.compat", "text": "\nGiven a TensorSummary node_def, retrieve its SummaryDescription.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.summary.histogram", "path": "compat/v1/summary/histogram", "type": "tf.compat", "text": "\nOutputs a `Summary` protocol buffer with a histogram.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.summary.image", "path": "compat/v1/summary/image", "type": "tf.compat", "text": "\nOutputs a `Summary` protocol buffer with images.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.summary.initialize", "path": "compat/v1/summary/initialize", "type": "tf.compat", "text": "\nInitializes summary writing for graph execution mode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.summary.merge", "path": "compat/v1/summary/merge", "type": "tf.compat", "text": "\nMerges summaries.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.summary.merge_all", "path": "compat/v1/summary/merge_all", "type": "tf.compat", "text": "\nMerges all summaries collected in the default graph.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.summary.scalar", "path": "compat/v1/summary/scalar", "type": "tf.compat", "text": "\nOutputs a `Summary` protocol buffer containing a single scalar value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.summary.SummaryDescription", "path": "compat/v1/summary/summarydescription", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.summary.TaggedRunMetadata", "path": "compat/v1/summary/taggedrunmetadata", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.summary.tensor_summary", "path": "compat/v1/summary/tensor_summary", "type": "tf.compat", "text": "\nOutputs a `Summary` protocol buffer with a serialized tensor.proto.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.summary.text", "path": "compat/v1/summary/text", "type": "tf.compat", "text": "\nSummarizes textual data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.SummaryMetadata", "path": "compat/v1/summarymetadata", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.SummaryMetadata.PluginData", "path": "compat/v1/summarymetadata/plugindata", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.sysconfig", "path": "compat/v1/sysconfig", "type": "tf.compat", "text": "\nSystem configuration library.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.tables_initializer", "path": "compat/v1/tables_initializer", "type": "tf.compat", "text": "\nReturns an Op that initializes all tables of the default graph.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.TensorInfo", "path": "compat/v1/tensorinfo", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.TensorInfo.CompositeTensor", "path": "compat/v1/tensorinfo/compositetensor", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.TensorInfo.CooSparse", "path": "compat/v1/tensorinfo/coosparse", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.test", "path": "compat/v1/test", "type": "tf.compat", "text": "\nTesting.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.test.assert_equal_graph_def", "path": "compat/v1/test/assert_equal_graph_def", "type": "tf.compat", "text": "\nAsserts that two `GraphDef`s are (mostly) the same.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.test.compute_gradient", "path": "compat/v1/test/compute_gradient", "type": "tf.compat", "text": "\nComputes and returns the theoretical and numerical Jacobian. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.test.compute_gradient_error", "path": "compat/v1/test/compute_gradient_error", "type": "tf.compat", "text": "\nComputes the gradient error. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.test.get_temp_dir", "path": "compat/v1/test/get_temp_dir", "type": "tf.compat", "text": "\nReturns a temporary directory for use during tests.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.test.StubOutForTesting", "path": "compat/v1/test/stuboutfortesting", "type": "tf.compat", "text": "\nSupport class for stubbing methods out for unit testing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.test.test_src_dir_path", "path": "compat/v1/test/test_src_dir_path", "type": "tf.compat", "text": "\nCreates an absolute test srcdir path given a relative path.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.TextLineReader", "path": "compat/v1/textlinereader", "type": "tf.compat", "text": "\nA Reader that outputs the lines of a file delimited by newlines.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.TFRecordReader", "path": "compat/v1/tfrecordreader", "type": "tf.compat", "text": "\nA Reader that outputs the records from a TFRecords file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.to_bfloat16", "path": "compat/v1/to_bfloat16", "type": "tf.compat", "text": "\nCasts a tensor to type `bfloat16`. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.to_complex128", "path": "compat/v1/to_complex128", "type": "tf.compat", "text": "\nCasts a tensor to type `complex128`. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.to_complex64", "path": "compat/v1/to_complex64", "type": "tf.compat", "text": "\nCasts a tensor to type `complex64`. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.to_double", "path": "compat/v1/to_double", "type": "tf.compat", "text": "\nCasts a tensor to type `float64`. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.to_float", "path": "compat/v1/to_float", "type": "tf.compat", "text": "\nCasts a tensor to type `float32`. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.to_int32", "path": "compat/v1/to_int32", "type": "tf.compat", "text": "\nCasts a tensor to type `int32`. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.to_int64", "path": "compat/v1/to_int64", "type": "tf.compat", "text": "\nCasts a tensor to type `int64`. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.tpu", "path": "compat/v1/tpu", "type": "tf.compat", "text": "\nOps related to Tensor Processing Units.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.tpu.batch_parallel", "path": "compat/v1/tpu/batch_parallel", "type": "tf.compat", "text": "\nShards `computation` along the batch dimension for parallel execution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.tpu.bfloat16_scope", "path": "compat/v1/tpu/bfloat16_scope", "type": "tf.compat", "text": "\nScope class for bfloat16 variables so that the model uses custom getter.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.tpu.core", "path": "compat/v1/tpu/core", "type": "tf.compat", "text": "\nReturns the device name for a core in a replicated TPU computation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.tpu.CrossShardOptimizer", "path": "compat/v1/tpu/crossshardoptimizer", "type": "tf.compat", "text": "\nAn optimizer that averages gradients across TPU shards.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.tpu.cross_replica_sum", "path": "compat/v1/tpu/cross_replica_sum", "type": "tf.compat", "text": "\nSum the input tensor across replicas according to group_assignment.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.tpu.experimental", "path": "compat/v1/tpu/experimental", "type": "tf.compat", "text": "\nPublic API for tf.tpu.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.tpu.experimental.AdagradParameters", "path": "compat/v1/tpu/experimental/adagradparameters", "type": "tf.compat", "text": "\nOptimization parameters for Adagrad with TPU embeddings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.tpu.experimental.AdamParameters", "path": "compat/v1/tpu/experimental/adamparameters", "type": "tf.compat", "text": "\nOptimization parameters for Adam with TPU embeddings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.tpu.experimental.embedding", "path": "compat/v1/tpu/experimental/embedding", "type": "tf.compat", "text": "\nPublic API for tf.tpu.experimental.embedding namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.tpu.experimental.embedding_column", "path": "compat/v1/tpu/experimental/embedding_column", "type": "tf.compat", "text": "\nTPU version of `tf.compat.v1.feature_column.embedding_column`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.tpu.experimental.FtrlParameters", "path": "compat/v1/tpu/experimental/ftrlparameters", "type": "tf.compat", "text": "\nOptimization parameters for Ftrl with TPU embeddings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.tpu.experimental.shared_embedding_columns", "path": "compat/v1/tpu/experimental/shared_embedding_columns", "type": "tf.compat", "text": "\nTPU version of `tf.compat.v1.feature_column.shared_embedding_columns`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.tpu.experimental.StochasticGradientDescentParameters", "path": "compat/v1/tpu/experimental/stochasticgradientdescentparameters", "type": "tf.compat", "text": "\nOptimization parameters for stochastic gradient descent for TPU embeddings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.tpu.initialize_system", "path": "compat/v1/tpu/initialize_system", "type": "tf.compat", "text": "\nInitializes a distributed TPU system for use with TensorFlow.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.tpu.outside_compilation", "path": "compat/v1/tpu/outside_compilation", "type": "tf.compat", "text": "\nBuilds part of a computation outside any current TPU replicate scope.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.tpu.PaddingSpec", "path": "compat/v1/tpu/paddingspec", "type": "tf.compat", "text": "\nRepresents the type of padding policies for tpu.replicate.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.tpu.replicate", "path": "compat/v1/tpu/replicate", "type": "tf.compat", "text": "\nBuilds a graph operator that runs a replicated TPU computation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.tpu.rewrite", "path": "compat/v1/tpu/rewrite", "type": "tf.compat", "text": "\nRewrites `computation` for execution on a TPU system.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.tpu.shard", "path": "compat/v1/tpu/shard", "type": "tf.compat", "text": "\nShards `computation` for parallel execution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.tpu.shutdown_system", "path": "compat/v1/tpu/shutdown_system", "type": "tf.compat", "text": "\nShuts down a running a distributed TPU system.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.tpu.XLAOptions", "path": "compat/v1/tpu/xlaoptions", "type": "tf.compat", "text": "\nXLA compilation options.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train", "path": "compat/v1/train", "type": "tf.compat", "text": "\nSupport for training models.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.AdadeltaOptimizer", "path": "compat/v1/train/adadeltaoptimizer", "type": "tf.compat", "text": "\nOptimizer that implements the Adadelta algorithm.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.AdagradDAOptimizer", "path": "compat/v1/train/adagraddaoptimizer", "type": "tf.compat", "text": "\nAdagrad Dual Averaging algorithm for sparse linear models.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.AdagradOptimizer", "path": "compat/v1/train/adagradoptimizer", "type": "tf.compat", "text": "\nOptimizer that implements the Adagrad algorithm.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.AdamOptimizer", "path": "compat/v1/train/adamoptimizer", "type": "tf.compat", "text": "\nOptimizer that implements the Adam algorithm.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.add_queue_runner", "path": "compat/v1/train/add_queue_runner", "type": "tf.compat", "text": "\nAdds a `QueueRunner` to a collection in the graph. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.assert_global_step", "path": "compat/v1/train/assert_global_step", "type": "tf.compat", "text": "\nAsserts `global_step_tensor` is a scalar int `Variable` or `Tensor`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.basic_train_loop", "path": "compat/v1/train/basic_train_loop", "type": "tf.compat", "text": "\nBasic loop to train a model.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.batch", "path": "compat/v1/train/batch", "type": "tf.compat", "text": "\nCreates batches of tensors in `tensors`. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.batch_join", "path": "compat/v1/train/batch_join", "type": "tf.compat", "text": "\nRuns a list of tensors to fill a queue to create batches of examples.\n(deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.Checkpoint", "path": "compat/v1/train/checkpoint", "type": "tf.compat", "text": "\nGroups trackable objects, saving and restoring them.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.checkpoint_exists", "path": "compat/v1/train/checkpoint_exists", "type": "tf.compat", "text": "\nChecks whether a V1 or V2 checkpoint exists with the specified prefix.\n(deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.ChiefSessionCreator", "path": "compat/v1/train/chiefsessioncreator", "type": "tf.compat", "text": "\nCreates a tf.compat.v1.Session for a chief.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.cosine_decay", "path": "compat/v1/train/cosine_decay", "type": "tf.compat", "text": "\nApplies cosine decay to the learning rate.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.cosine_decay_restarts", "path": "compat/v1/train/cosine_decay_restarts", "type": "tf.compat", "text": "\nApplies cosine decay with restarts to the learning rate.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.create_global_step", "path": "compat/v1/train/create_global_step", "type": "tf.compat", "text": "\nCreate global step tensor in graph.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.do_quantize_training_on_graphdef", "path": "compat/v1/train/do_quantize_training_on_graphdef", "type": "tf.compat", "text": "\nA general quantization scheme is being developed in `tf.contrib.quantize`.\n(deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.experimental", "path": "compat/v1/train/experimental", "type": "tf.compat", "text": "\nPublic API for tf.train.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.exponential_decay", "path": "compat/v1/train/exponential_decay", "type": "tf.compat", "text": "\nApplies exponential decay to the learning rate.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.export_meta_graph", "path": "compat/v1/train/export_meta_graph", "type": "tf.compat", "text": "\nReturns `MetaGraphDef` proto.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.FtrlOptimizer", "path": "compat/v1/train/ftrloptimizer", "type": "tf.compat", "text": "\nOptimizer that implements the FTRL algorithm.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.generate_checkpoint_state_proto", "path": "compat/v1/train/generate_checkpoint_state_proto", "type": "tf.compat", "text": "\nGenerates a checkpoint state proto.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.get_checkpoint_mtimes", "path": "compat/v1/train/get_checkpoint_mtimes", "type": "tf.compat", "text": "\nReturns the mtimes (modification timestamps) of the checkpoints. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.get_global_step", "path": "compat/v1/train/get_global_step", "type": "tf.compat", "text": "\nGet the global step tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.get_or_create_global_step", "path": "compat/v1/train/get_or_create_global_step", "type": "tf.compat", "text": "\nReturns and create (if necessary) the global step tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.global_step", "path": "compat/v1/train/global_step", "type": "tf.compat", "text": "\nSmall helper to get the global step.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.GradientDescentOptimizer", "path": "compat/v1/train/gradientdescentoptimizer", "type": "tf.compat", "text": "\nOptimizer that implements the gradient descent algorithm.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.import_meta_graph", "path": "compat/v1/train/import_meta_graph", "type": "tf.compat", "text": "\nRecreates a Graph saved in a `MetaGraphDef` proto.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.init_from_checkpoint", "path": "compat/v1/train/init_from_checkpoint", "type": "tf.compat", "text": "\nReplaces `tf.Variable` initializers so they load from a checkpoint file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.input_producer", "path": "compat/v1/train/input_producer", "type": "tf.compat", "text": "\nOutput the rows of `input_tensor` to a queue for an input pipeline.\n(deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.inverse_time_decay", "path": "compat/v1/train/inverse_time_decay", "type": "tf.compat", "text": "\nApplies inverse time decay to the initial learning rate.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.limit_epochs", "path": "compat/v1/train/limit_epochs", "type": "tf.compat", "text": "\nReturns tensor `num_epochs` times and then raises an `OutOfRange` error.\n(deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.linear_cosine_decay", "path": "compat/v1/train/linear_cosine_decay", "type": "tf.compat", "text": "\nApplies linear cosine decay to the learning rate.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.LooperThread", "path": "compat/v1/train/looperthread", "type": "tf.compat", "text": "\nA thread that runs code repeatedly, optionally on a timer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.maybe_batch", "path": "compat/v1/train/maybe_batch", "type": "tf.compat", "text": "\nConditionally creates batches of tensors based on `keep_input`. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.maybe_batch_join", "path": "compat/v1/train/maybe_batch_join", "type": "tf.compat", "text": "\nRuns a list of tensors to conditionally fill a queue to create batches.\n(deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.maybe_shuffle_batch", "path": "compat/v1/train/maybe_shuffle_batch", "type": "tf.compat", "text": "\nCreates batches by randomly shuffling conditionally-enqueued tensors.\n(deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.maybe_shuffle_batch_join", "path": "compat/v1/train/maybe_shuffle_batch_join", "type": "tf.compat", "text": "\nCreate batches by randomly shuffling conditionally-enqueued tensors.\n(deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.MomentumOptimizer", "path": "compat/v1/train/momentumoptimizer", "type": "tf.compat", "text": "\nOptimizer that implements the Momentum algorithm.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.MonitoredSession", "path": "compat/v1/train/monitoredsession", "type": "tf.compat", "text": "\nSession-like object that handles initialization, recovery and hooks.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.MonitoredSession.StepContext", "path": "compat/v1/train/monitoredsession/stepcontext", "type": "tf.compat", "text": "\nControl flow instrument for the `step_fn` from `run_step_fn()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.MonitoredTrainingSession", "path": "compat/v1/train/monitoredtrainingsession", "type": "tf.compat", "text": "\nCreates a `MonitoredSession` for training.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.natural_exp_decay", "path": "compat/v1/train/natural_exp_decay", "type": "tf.compat", "text": "\nApplies natural exponential decay to the initial learning rate.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.NewCheckpointReader", "path": "compat/v1/train/newcheckpointreader", "type": "tf.compat", "text": "\nA function that returns a CheckPointReader.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.noisy_linear_cosine_decay", "path": "compat/v1/train/noisy_linear_cosine_decay", "type": "tf.compat", "text": "\nApplies noisy linear cosine decay to the learning rate.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.Optimizer", "path": "compat/v1/train/optimizer", "type": "tf.compat", "text": "\nBase class for optimizers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.piecewise_constant", "path": "compat/v1/train/piecewise_constant", "type": "tf.compat", "text": "\nPiecewise constant from boundaries and interval values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.polynomial_decay", "path": "compat/v1/train/polynomial_decay", "type": "tf.compat", "text": "\nApplies a polynomial decay to the learning rate.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.ProximalAdagradOptimizer", "path": "compat/v1/train/proximaladagradoptimizer", "type": "tf.compat", "text": "\nOptimizer that implements the Proximal Adagrad algorithm.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.ProximalGradientDescentOptimizer", "path": "compat/v1/train/proximalgradientdescentoptimizer", "type": "tf.compat", "text": "\nOptimizer that implements the proximal gradient descent algorithm.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.QueueRunner", "path": "compat/v1/train/queuerunner", "type": "tf.compat", "text": "\nHolds a list of enqueue operations for a queue, each to be run in a thread.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.queue_runner", "path": "compat/v1/train/queue_runner", "type": "tf.compat", "text": "\nPublic API for tf.train.queue_runner namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.range_input_producer", "path": "compat/v1/train/range_input_producer", "type": "tf.compat", "text": "\nProduces the integers from 0 to limit-1 in a queue. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.remove_checkpoint", "path": "compat/v1/train/remove_checkpoint", "type": "tf.compat", "text": "\nRemoves a checkpoint given by `checkpoint_prefix`. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.replica_device_setter", "path": "compat/v1/train/replica_device_setter", "type": "tf.compat", "text": "\nReturn a `device function` to use when building a Graph for replicas.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.RMSPropOptimizer", "path": "compat/v1/train/rmspropoptimizer", "type": "tf.compat", "text": "\nOptimizer that implements the RMSProp algorithm (Tielemans et al.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.Saver", "path": "compat/v1/train/saver", "type": "tf.compat", "text": "\nSaves and restores variables.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.SaverDef", "path": "compat/v1/train/saverdef", "type": "tf.compat", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.Scaffold", "path": "compat/v1/train/scaffold", "type": "tf.compat", "text": "\nStructure to create or gather pieces commonly needed to train a model.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.sdca_fprint", "path": "compat/v1/train/sdca_fprint", "type": "tf.compat", "text": "\nComputes fingerprints of the input strings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.sdca_optimizer", "path": "compat/v1/train/sdca_optimizer", "type": "tf.compat", "text": "\nDistributed version of Stochastic Dual Coordinate Ascent (SDCA) optimizer for\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.sdca_shrink_l1", "path": "compat/v1/train/sdca_shrink_l1", "type": "tf.compat", "text": "\nApplies L1 regularization shrink step on the parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.SessionCreator", "path": "compat/v1/train/sessioncreator", "type": "tf.compat", "text": "\nA factory for tf.Session.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.SessionManager", "path": "compat/v1/train/sessionmanager", "type": "tf.compat", "text": "\nTraining helper that restores from checkpoint and creates session.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.shuffle_batch", "path": "compat/v1/train/shuffle_batch", "type": "tf.compat", "text": "\nCreates batches by randomly shuffling tensors. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.shuffle_batch_join", "path": "compat/v1/train/shuffle_batch_join", "type": "tf.compat", "text": "\nCreate batches by randomly shuffling tensors. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.SingularMonitoredSession", "path": "compat/v1/train/singularmonitoredsession", "type": "tf.compat", "text": "\nSession-like object that handles initialization, restoring, and hooks.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.slice_input_producer", "path": "compat/v1/train/slice_input_producer", "type": "tf.compat", "text": "\nProduces a slice of each `Tensor` in `tensor_list`. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.start_queue_runners", "path": "compat/v1/train/start_queue_runners", "type": "tf.compat", "text": "\nStarts all queue runners collected in the graph. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.string_input_producer", "path": "compat/v1/train/string_input_producer", "type": "tf.compat", "text": "\nOutput strings (e.g. filenames) to a queue for an input pipeline. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.summary_iterator", "path": "compat/v1/train/summary_iterator", "type": "tf.compat", "text": "\nReturns a iterator for reading `Event` protocol buffers from an event file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.Supervisor", "path": "compat/v1/train/supervisor", "type": "tf.compat", "text": "\nA training helper that checkpoints models and computes summaries.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.SyncReplicasOptimizer", "path": "compat/v1/train/syncreplicasoptimizer", "type": "tf.compat", "text": "\nClass to synchronize, aggregate gradients and pass them to the optimizer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.update_checkpoint_state", "path": "compat/v1/train/update_checkpoint_state", "type": "tf.compat", "text": "\nUpdates the content of the 'checkpoint' file. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.warm_start", "path": "compat/v1/train/warm_start", "type": "tf.compat", "text": "\nWarm-starts a model using the given settings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.train.WorkerSessionCreator", "path": "compat/v1/train/workersessioncreator", "type": "tf.compat", "text": "\nCreates a tf.compat.v1.Session for a worker.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.trainable_variables", "path": "compat/v1/trainable_variables", "type": "tf.compat", "text": "\nReturns all variables created with `trainable=True`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.transpose", "path": "compat/v1/transpose", "type": "tf.compat", "text": "\nTransposes `a`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.truncated_normal_initializer", "path": "compat/v1/truncated_normal_initializer", "type": "tf.compat", "text": "\nInitializer that generates a truncated normal distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.tuple", "path": "compat/v1/tuple", "type": "tf.compat", "text": "\nGroup tensors together.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.types", "path": "compat/v1/types", "type": "tf.compat", "text": "\nPublic TensorFlow type definitions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.types.experimental", "path": "compat/v1/types/experimental", "type": "tf.compat", "text": "\nPublic API for tf.types.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.uniform_unit_scaling_initializer", "path": "compat/v1/uniform_unit_scaling_initializer", "type": "tf.compat", "text": "\nInitializer that generates tensors without scaling variance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.user_ops", "path": "compat/v1/user_ops", "type": "tf.compat", "text": "\nPublic API for tf.user_ops namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.user_ops.my_fact", "path": "compat/v1/user_ops/my_fact", "type": "tf.compat", "text": "\nExample of overriding the generated code for an Op.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.Variable", "path": "compat/v1/variable", "type": "tf.compat", "text": "\nSee the Variables Guide.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.VariableAggregation", "path": "compat/v1/variableaggregation", "type": "tf.compat", "text": "\nIndicates how a distributed variable will be aggregated.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.VariableScope", "path": "compat/v1/variablescope", "type": "tf.compat", "text": "\nVariable scope object to carry defaults to provide to `get_variable`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.variables_initializer", "path": "compat/v1/variables_initializer", "type": "tf.compat", "text": "\nReturns an Op that initializes a list of variables.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.variable_axis_size_partitioner", "path": "compat/v1/variable_axis_size_partitioner", "type": "tf.compat", "text": "\nGet a partitioner for VariableScope to keep shards below `max_shard_bytes`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.variable_creator_scope", "path": "compat/v1/variable_creator_scope", "type": "tf.compat", "text": "\nScope which defines a variable creation function to be used by variable().\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.variable_op_scope", "path": "compat/v1/variable_op_scope", "type": "tf.compat", "text": "\nDeprecated: context manager for defining an op that creates variables.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.variable_scope", "path": "compat/v1/variable_scope", "type": "tf.compat", "text": "\nA context manager for defining ops that creates variables (layers).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.verify_tensor_all_finite", "path": "compat/v1/verify_tensor_all_finite", "type": "tf.compat", "text": "\nAssert that the tensor does not contain any NaN's or Inf's.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.version", "path": "compat/v1/version", "type": "tf.compat", "text": "\nPublic API for tf.version namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.where", "path": "compat/v1/where", "type": "tf.compat", "text": "\nReturn the elements, either from `x` or `y`, depending on the `condition`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.while_loop", "path": "compat/v1/while_loop", "type": "tf.compat", "text": "\nRepeat `body` while the condition `cond` is true.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.WholeFileReader", "path": "compat/v1/wholefilereader", "type": "tf.compat", "text": "\nA Reader that outputs the entire contents of a file as a value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.wrap_function", "path": "compat/v1/wrap_function", "type": "tf.compat", "text": "\nWraps the TF 1.x function fn into a graph function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.xla", "path": "compat/v1/xla", "type": "tf.compat", "text": "\nPublic API for tf.xla namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.xla.experimental", "path": "compat/v1/xla/experimental", "type": "tf.compat", "text": "\nPublic API for tf.xla.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.compat.v1.zeros_like", "path": "compat/v1/zeros_like", "type": "tf.compat", "text": "\nCreates a tensor with all elements set to zero.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.concat", "path": "concat", "type": "tf", "text": "\nConcatenates tensors along one dimension.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.cond", "path": "cond", "type": "tf", "text": "\nReturn `true_fn()` if the predicate `pred` is true else `false_fn()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config", "path": "config", "type": "tf.config", "text": "\nPublic API for tf.config namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config.experimental", "path": "config/experimental", "type": "tf.config", "text": "\nPublic API for tf.config.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config.experimental.ClusterDeviceFilters", "path": "config/experimental/clusterdevicefilters", "type": "tf.config", "text": "\nRepresent a collection of device filters for the remote workers in cluster.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config.experimental.disable_mlir_bridge", "path": "config/experimental/disable_mlir_bridge", "type": "tf.config", "text": "\nDisables experimental MLIR-Based TensorFlow Compiler Bridge.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config.experimental.disable_mlir_graph_optimization", "path": "config/experimental/disable_mlir_graph_optimization", "type": "tf.config", "text": "\nDisables experimental MLIR-Based TensorFlow Compiler Optimizations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config.experimental.enable_mlir_bridge", "path": "config/experimental/enable_mlir_bridge", "type": "tf.config", "text": "\nEnables experimental MLIR-Based TensorFlow Compiler Bridge.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config.experimental.enable_mlir_graph_optimization", "path": "config/experimental/enable_mlir_graph_optimization", "type": "tf.config", "text": "\nEnables experimental MLIR-Based TensorFlow Compiler Optimizations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config.experimental.enable_tensor_float_32_execution", "path": "config/experimental/enable_tensor_float_32_execution", "type": "tf.config", "text": "\nEnable or disable the use of TensorFloat-32 on supported hardware.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config.experimental.get_device_details", "path": "config/experimental/get_device_details", "type": "tf.config", "text": "\nReturns details about a physical devices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config.experimental.get_device_policy", "path": "config/experimental/get_device_policy", "type": "tf.config", "text": "\nGets the current device policy.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config.experimental.get_memory_growth", "path": "config/experimental/get_memory_growth", "type": "tf.config", "text": "\nGet if memory growth is enabled for a `PhysicalDevice`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config.experimental.get_memory_usage", "path": "config/experimental/get_memory_usage", "type": "tf.config", "text": "\nGet the memory usage, in bytes, for the chosen device.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config.experimental.get_synchronous_execution", "path": "config/experimental/get_synchronous_execution", "type": "tf.config", "text": "\nGets whether operations are executed synchronously or asynchronously.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config.experimental.set_device_policy", "path": "config/experimental/set_device_policy", "type": "tf.config", "text": "\nSets the current thread device policy.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config.experimental.set_memory_growth", "path": "config/experimental/set_memory_growth", "type": "tf.config", "text": "\nSet if memory growth should be enabled for a `PhysicalDevice`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config.experimental.set_synchronous_execution", "path": "config/experimental/set_synchronous_execution", "type": "tf.config", "text": "\nSpecifies whether operations are executed synchronously or asynchronously.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config.experimental.tensor_float_32_execution_enabled", "path": "config/experimental/tensor_float_32_execution_enabled", "type": "tf.config", "text": "\nReturns whether TensorFloat-32 is enabled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config.experimental_connect_to_cluster", "path": "config/experimental_connect_to_cluster", "type": "tf.config", "text": "\nConnects to the given cluster.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config.experimental_connect_to_host", "path": "config/experimental_connect_to_host", "type": "tf.config", "text": "\nConnects to a single machine to enable remote execution on it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config.experimental_functions_run_eagerly", "path": "config/experimental_functions_run_eagerly", "type": "tf.config", "text": "\nReturns the value of the `experimental_run_functions_eagerly` setting.\n(deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config.experimental_run_functions_eagerly", "path": "config/experimental_run_functions_eagerly", "type": "tf.config", "text": "\nEnables / disables eager execution of `tf.function`s. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config.functions_run_eagerly", "path": "config/functions_run_eagerly", "type": "tf.config", "text": "\nReturns the value of the `run_functions_eagerly` setting.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config.get_logical_device_configuration", "path": "config/get_logical_device_configuration", "type": "tf.config", "text": "\nGet the virtual device configuration for a `tf.config.PhysicalDevice`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config.get_soft_device_placement", "path": "config/get_soft_device_placement", "type": "tf.config", "text": "\nGet if soft device placement is enabled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config.get_visible_devices", "path": "config/get_visible_devices", "type": "tf.config", "text": "\nGet the list of visible physical devices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config.list_logical_devices", "path": "config/list_logical_devices", "type": "tf.config", "text": "\nReturn a list of logical devices created by runtime.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config.list_physical_devices", "path": "config/list_physical_devices", "type": "tf.config", "text": "\nReturn a list of physical devices visible to the host runtime.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config.LogicalDevice", "path": "config/logicaldevice", "type": "tf.config", "text": "\nAbstraction for a logical device initialized by the runtime.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config.LogicalDeviceConfiguration", "path": "config/logicaldeviceconfiguration", "type": "tf.config", "text": "\nConfiguration class for a logical devices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config.optimizer", "path": "config/optimizer", "type": "tf.config", "text": "\nPublic API for tf.config.optimizer namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config.optimizer.get_experimental_options", "path": "config/optimizer/get_experimental_options", "type": "tf.config", "text": "\nGet experimental optimizer options.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config.optimizer.get_jit", "path": "config/optimizer/get_jit", "type": "tf.config", "text": "\nGet if JIT compilation is enabled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config.optimizer.set_experimental_options", "path": "config/optimizer/set_experimental_options", "type": "tf.config", "text": "\nSet experimental optimizer options.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config.optimizer.set_jit", "path": "config/optimizer/set_jit", "type": "tf.config", "text": "\nSet if JIT compilation is enabled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config.PhysicalDevice", "path": "config/physicaldevice", "type": "tf.config", "text": "\nAbstraction for a locally visible physical device.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config.run_functions_eagerly", "path": "config/run_functions_eagerly", "type": "tf.config", "text": "\nEnables / disables eager execution of `tf.function`s.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config.set_logical_device_configuration", "path": "config/set_logical_device_configuration", "type": "tf.config", "text": "\nSet the logical device configuration for a `tf.config.PhysicalDevice`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config.set_soft_device_placement", "path": "config/set_soft_device_placement", "type": "tf.config", "text": "\nSet if soft device placement is enabled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config.set_visible_devices", "path": "config/set_visible_devices", "type": "tf.config", "text": "\nSet the list of visible devices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config.threading", "path": "config/threading", "type": "tf.config", "text": "\nPublic API for tf.config.threading namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config.threading.get_inter_op_parallelism_threads", "path": "config/threading/get_inter_op_parallelism_threads", "type": "tf.config", "text": "\nGet number of threads used for parallelism between independent operations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config.threading.get_intra_op_parallelism_threads", "path": "config/threading/get_intra_op_parallelism_threads", "type": "tf.config", "text": "\nGet number of threads used within an individual op for parallelism.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config.threading.set_inter_op_parallelism_threads", "path": "config/threading/set_inter_op_parallelism_threads", "type": "tf.config", "text": "\nSet number of threads used for parallelism between independent operations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.config.threading.set_intra_op_parallelism_threads", "path": "config/threading/set_intra_op_parallelism_threads", "type": "tf.config", "text": "\nSet number of threads used within an individual op for parallelism.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.constant", "path": "constant", "type": "tf", "text": "\nCreates a constant tensor from a tensor-like object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.constant_initializer", "path": "constant_initializer", "type": "tf", "text": "\nInitializer that generates tensors with constant values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.control_dependencies", "path": "control_dependencies", "type": "tf", "text": "\nWrapper for `Graph.control_dependencies()` using the default graph.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.convert_to_tensor", "path": "convert_to_tensor", "type": "tf", "text": "\nConverts the given `value` to a `Tensor`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.CriticalSection", "path": "criticalsection", "type": "tf", "text": "\nCritical section.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.custom_gradient", "path": "custom_gradient", "type": "tf", "text": "\nDecorator to define a function with a custom gradient.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data", "path": "data", "type": "tf.data", "text": "\n`tf.data.Dataset` API for input pipelines.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.Dataset", "path": "data/dataset", "type": "tf.data", "text": "\nRepresents a potentially large set of elements.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.DatasetSpec", "path": "data/datasetspec", "type": "tf.data", "text": "\nType specification for `tf.data.Dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental", "path": "data/experimental", "type": "tf.data", "text": "\nExperimental API for building input pipelines.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.assert_cardinality", "path": "data/experimental/assert_cardinality", "type": "tf.data", "text": "\nAsserts the cardinality of the input dataset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.AutoShardPolicy", "path": "data/experimental/autoshardpolicy", "type": "tf.data", "text": "\nRepresents the type of auto-sharding we enable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.bucket_by_sequence_length", "path": "data/experimental/bucket_by_sequence_length", "type": "tf.data", "text": "\nA transformation that buckets elements in a `Dataset` by length.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.bytes_produced_stats", "path": "data/experimental/bytes_produced_stats", "type": "tf.data", "text": "\nRecords the number of bytes produced by each element of the input dataset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.cardinality", "path": "data/experimental/cardinality", "type": "tf.data", "text": "\nReturns the cardinality of `dataset`, if known.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.CheckpointInputPipelineHook", "path": "data/experimental/checkpointinputpipelinehook", "type": "tf.data", "text": "\nCheckpoints input pipeline state every N steps or seconds.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.choose_from_datasets", "path": "data/experimental/choose_from_datasets", "type": "tf.data", "text": "\nCreates a dataset that deterministically chooses elements from `datasets`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.copy_to_device", "path": "data/experimental/copy_to_device", "type": "tf.data", "text": "\nA transformation that copies dataset elements to the given `target_device`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.Counter", "path": "data/experimental/counter", "type": "tf.data", "text": "\nCreates a `Dataset` that counts from `start` in steps of size `step`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.CsvDataset", "path": "data/experimental/csvdataset", "type": "tf.data", "text": "\nA Dataset comprising lines from one or more CSV files.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.dense_to_ragged_batch", "path": "data/experimental/dense_to_ragged_batch", "type": "tf.data", "text": "\nA transformation that batches ragged elements into `tf.RaggedTensor`s.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.dense_to_sparse_batch", "path": "data/experimental/dense_to_sparse_batch", "type": "tf.data", "text": "\nA transformation that batches ragged elements into `tf.sparse.SparseTensor`s.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.DistributeOptions", "path": "data/experimental/distributeoptions", "type": "tf.data", "text": "\nRepresents options for distributed data processing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.enumerate_dataset", "path": "data/experimental/enumerate_dataset", "type": "tf.data", "text": "\nA transformation that enumerates the elements of a dataset. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.from_variant", "path": "data/experimental/from_variant", "type": "tf.data", "text": "\nConstructs a dataset from the given variant and structure.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.get_next_as_optional", "path": "data/experimental/get_next_as_optional", "type": "tf.data", "text": "\nReturns a `tf.experimental.Optional` with the next element of the iterator.\n(deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.get_single_element", "path": "data/experimental/get_single_element", "type": "tf.data", "text": "\nReturns the single element in `dataset` as a nested structure of tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.get_structure", "path": "data/experimental/get_structure", "type": "tf.data", "text": "\nReturns the type signature for elements of the input dataset / iterator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.group_by_reducer", "path": "data/experimental/group_by_reducer", "type": "tf.data", "text": "\nA transformation that groups elements and performs a reduction.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.group_by_window", "path": "data/experimental/group_by_window", "type": "tf.data", "text": "\nA transformation that groups windows of elements by key and reduces them.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.ignore_errors", "path": "data/experimental/ignore_errors", "type": "tf.data", "text": "\nCreates a `Dataset` from another `Dataset` and silently ignores any errors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.latency_stats", "path": "data/experimental/latency_stats", "type": "tf.data", "text": "\nRecords the latency of producing each element of the input dataset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.load", "path": "data/experimental/load", "type": "tf.data", "text": "\nLoads a previously saved dataset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.make_batched_features_dataset", "path": "data/experimental/make_batched_features_dataset", "type": "tf.data", "text": "\nReturns a `Dataset` of feature dictionaries from `Example` protos.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.make_csv_dataset", "path": "data/experimental/make_csv_dataset", "type": "tf.data", "text": "\nReads CSV files into a dataset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.make_saveable_from_iterator", "path": "data/experimental/make_saveable_from_iterator", "type": "tf.data", "text": "\nReturns a SaveableObject for saving/restoring iterator state using Saver.\n(deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.MapVectorizationOptions", "path": "data/experimental/mapvectorizationoptions", "type": "tf.data", "text": "\nRepresents options for the MapVectorization optimization.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.map_and_batch", "path": "data/experimental/map_and_batch", "type": "tf.data", "text": "\nFused implementation of `map` and `batch`. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.OptimizationOptions", "path": "data/experimental/optimizationoptions", "type": "tf.data", "text": "\nRepresents options for dataset optimizations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.parallel_interleave", "path": "data/experimental/parallel_interleave", "type": "tf.data", "text": "\nA parallel version of the `Dataset.interleave()` transformation. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.parse_example_dataset", "path": "data/experimental/parse_example_dataset", "type": "tf.data", "text": "\nA transformation that parses `Example` protos into a `dict` of tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.prefetch_to_device", "path": "data/experimental/prefetch_to_device", "type": "tf.data", "text": "\nA transformation that prefetches dataset values to the given `device`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.RandomDataset", "path": "data/experimental/randomdataset", "type": "tf.data", "text": "\nA `Dataset` of pseudorandom values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.Reducer", "path": "data/experimental/reducer", "type": "tf.data", "text": "\nA reducer is used for reducing a set of elements.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.rejection_resample", "path": "data/experimental/rejection_resample", "type": "tf.data", "text": "\nA transformation that resamples a dataset to achieve a target distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.sample_from_datasets", "path": "data/experimental/sample_from_datasets", "type": "tf.data", "text": "\nSamples elements at random from the datasets in `datasets`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.save", "path": "data/experimental/save", "type": "tf.data", "text": "\nSaves the content of the given dataset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.scan", "path": "data/experimental/scan", "type": "tf.data", "text": "\nA transformation that scans a function across an input dataset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.service", "path": "data/experimental/service", "type": "tf.data", "text": "\nAPI for using the tf.data service.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.service.DispatcherConfig", "path": "data/experimental/service/dispatcherconfig", "type": "tf.data", "text": "\nConfiguration class for tf.data service dispatchers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.service.DispatchServer", "path": "data/experimental/service/dispatchserver", "type": "tf.data", "text": "\nAn in-process tf.data service dispatch server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.service.distribute", "path": "data/experimental/service/distribute", "type": "tf.data", "text": "\nA transformation that moves dataset processing to the tf.data service.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.service.from_dataset_id", "path": "data/experimental/service/from_dataset_id", "type": "tf.data", "text": "\nCreates a dataset which reads data from the tf.data service.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.service.register_dataset", "path": "data/experimental/service/register_dataset", "type": "tf.data", "text": "\nRegisters a dataset with the tf.data service.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.service.WorkerConfig", "path": "data/experimental/service/workerconfig", "type": "tf.data", "text": "\nConfiguration class for tf.data service dispatchers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.service.WorkerServer", "path": "data/experimental/service/workerserver", "type": "tf.data", "text": "\nAn in-process tf.data service worker server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.shuffle_and_repeat", "path": "data/experimental/shuffle_and_repeat", "type": "tf.data", "text": "\nShuffles and repeats a Dataset, reshuffling with each repetition. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.snapshot", "path": "data/experimental/snapshot", "type": "tf.data", "text": "\nAPI to persist the output of the input dataset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.SqlDataset", "path": "data/experimental/sqldataset", "type": "tf.data", "text": "\nA `Dataset` consisting of the results from a SQL query.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.StatsAggregator", "path": "data/experimental/statsaggregator", "type": "tf.data", "text": "\nA stateful resource that aggregates statistics from one or more iterators.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.StatsOptions", "path": "data/experimental/statsoptions", "type": "tf.data", "text": "\nRepresents options for collecting dataset stats using `StatsAggregator`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.take_while", "path": "data/experimental/take_while", "type": "tf.data", "text": "\nA transformation that stops dataset iteration based on a `predicate`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.TFRecordWriter", "path": "data/experimental/tfrecordwriter", "type": "tf.data", "text": "\nWrites a dataset to a TFRecord file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.ThreadingOptions", "path": "data/experimental/threadingoptions", "type": "tf.data", "text": "\nRepresents options for dataset threading.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.to_variant", "path": "data/experimental/to_variant", "type": "tf.data", "text": "\nReturns a variant representing the given dataset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.unbatch", "path": "data/experimental/unbatch", "type": "tf.data", "text": "\nSplits elements of a dataset into multiple elements on the batch dimension.\n(deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.experimental.unique", "path": "data/experimental/unique", "type": "tf.data", "text": "\nCreates a `Dataset` from another `Dataset`, discarding duplicates.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.FixedLengthRecordDataset", "path": "data/fixedlengthrecorddataset", "type": "tf.data", "text": "\nA `Dataset` of fixed-length records from one or more binary files.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.Iterator", "path": "data/iterator", "type": "tf.data", "text": "\nRepresents an iterator of a `tf.data.Dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.IteratorSpec", "path": "data/iteratorspec", "type": "tf.data", "text": "\nType specification for `tf.data.Iterator`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.Options", "path": "data/options", "type": "tf.data", "text": "\nRepresents options for `tf.data.Dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.TextLineDataset", "path": "data/textlinedataset", "type": "tf.data", "text": "\nA `Dataset` comprising lines from one or more text files.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.data.TFRecordDataset", "path": "data/tfrecorddataset", "type": "tf.data", "text": "\nA `Dataset` comprising records from one or more TFRecord files.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.debugging", "path": "debugging", "type": "tf.debugging", "text": "\nPublic API for tf.debugging namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.debugging.Assert", "path": "debugging/assert", "type": "tf.debugging", "text": "\nAsserts that the given condition is true.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.debugging.assert_all_finite", "path": "debugging/assert_all_finite", "type": "tf.debugging", "text": "\nAssert that the tensor does not contain any NaN's or Inf's.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.debugging.assert_equal", "path": "debugging/assert_equal", "type": "tf.debugging", "text": "\nAssert the condition `x == y` holds element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.debugging.assert_greater", "path": "debugging/assert_greater", "type": "tf.debugging", "text": "\nAssert the condition `x > y` holds element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.debugging.assert_greater_equal", "path": "debugging/assert_greater_equal", "type": "tf.debugging", "text": "\nAssert the condition `x >= y` holds element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.debugging.assert_integer", "path": "debugging/assert_integer", "type": "tf.debugging", "text": "\nAssert that `x` is of integer dtype.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.debugging.assert_less", "path": "debugging/assert_less", "type": "tf.debugging", "text": "\nAssert the condition `x < y` holds element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.debugging.assert_less_equal", "path": "debugging/assert_less_equal", "type": "tf.debugging", "text": "\nAssert the condition `x <= y` holds element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.debugging.assert_near", "path": "debugging/assert_near", "type": "tf.debugging", "text": "\nAssert the condition `x` and `y` are close element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.debugging.assert_negative", "path": "debugging/assert_negative", "type": "tf.debugging", "text": "\nAssert the condition `x < 0` holds element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.debugging.assert_none_equal", "path": "debugging/assert_none_equal", "type": "tf.debugging", "text": "\nAssert the condition `x != y` holds for all elements.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.debugging.assert_non_negative", "path": "debugging/assert_non_negative", "type": "tf.debugging", "text": "\nAssert the condition `x >= 0` holds element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.debugging.assert_non_positive", "path": "debugging/assert_non_positive", "type": "tf.debugging", "text": "\nAssert the condition `x <= 0` holds element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.debugging.assert_positive", "path": "debugging/assert_positive", "type": "tf.debugging", "text": "\nAssert the condition `x > 0` holds element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.debugging.assert_proper_iterable", "path": "debugging/assert_proper_iterable", "type": "tf.debugging", "text": "\nStatic assert that values is a \"proper\" iterable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.debugging.assert_rank", "path": "debugging/assert_rank", "type": "tf.debugging", "text": "\nAssert that `x` has rank equal to `rank`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.debugging.assert_rank_at_least", "path": "debugging/assert_rank_at_least", "type": "tf.debugging", "text": "\nAssert that `x` has rank of at least `rank`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.debugging.assert_rank_in", "path": "debugging/assert_rank_in", "type": "tf.debugging", "text": "\nAssert that `x` has a rank in `ranks`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.debugging.assert_same_float_dtype", "path": "debugging/assert_same_float_dtype", "type": "tf.debugging", "text": "\nValidate and return float type based on `tensors` and `dtype`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.debugging.assert_scalar", "path": "debugging/assert_scalar", "type": "tf.debugging", "text": "\nAsserts that the given `tensor` is a scalar.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.debugging.assert_shapes", "path": "debugging/assert_shapes", "type": "tf.debugging", "text": "\nAssert tensor shapes and dimension size relationships between tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.debugging.assert_type", "path": "debugging/assert_type", "type": "tf.debugging", "text": "\nAsserts that the given `Tensor` is of the specified type.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.debugging.check_numerics", "path": "debugging/check_numerics", "type": "tf.debugging", "text": "\nChecks a tensor for NaN and Inf values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.debugging.disable_check_numerics", "path": "debugging/disable_check_numerics", "type": "tf.debugging", "text": "\nDisable the eager/graph unified numerics checking mechanism.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.debugging.enable_check_numerics", "path": "debugging/enable_check_numerics", "type": "tf.debugging", "text": "\nEnable tensor numerics checking in an eager/graph unified fashion.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.debugging.experimental", "path": "debugging/experimental", "type": "tf.debugging", "text": "\nPublic API for tf.debugging.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.debugging.experimental.disable_dump_debug_info", "path": "debugging/experimental/disable_dump_debug_info", "type": "tf.debugging", "text": "\nDisable the currently-enabled debugging dumping.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.debugging.experimental.enable_dump_debug_info", "path": "debugging/experimental/enable_dump_debug_info", "type": "tf.debugging", "text": "\nEnable dumping debugging information from a TensorFlow program.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.debugging.get_log_device_placement", "path": "debugging/get_log_device_placement", "type": "tf.debugging", "text": "\nGet if device placements are logged.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.debugging.is_numeric_tensor", "path": "debugging/is_numeric_tensor", "type": "tf.debugging", "text": "\nReturns `True` if the elements of `tensor` are numbers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.debugging.set_log_device_placement", "path": "debugging/set_log_device_placement", "type": "tf.debugging", "text": "\nSet if device placements should be logged.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.device", "path": "device", "type": "tf", "text": "\nSpecifies the device for ops created/executed in this context.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.DeviceSpec", "path": "devicespec", "type": "tf", "text": "\nRepresents a (possibly partial) specification for a TensorFlow device.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute", "path": "distribute", "type": "tf.distribute", "text": "\nLibrary for running a computation across multiple devices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.cluster_resolver", "path": "distribute/cluster_resolver", "type": "tf.distribute", "text": "\nLibrary imports for ClusterResolvers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.cluster_resolver.ClusterResolver", "path": "distribute/cluster_resolver/clusterresolver", "type": "tf.distribute", "text": "\nAbstract class for all implementations of ClusterResolvers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.cluster_resolver.GCEClusterResolver", "path": "distribute/cluster_resolver/gceclusterresolver", "type": "tf.distribute", "text": "\nClusterResolver for Google Compute Engine.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.cluster_resolver.KubernetesClusterResolver", "path": "distribute/cluster_resolver/kubernetesclusterresolver", "type": "tf.distribute", "text": "\nClusterResolver for Kubernetes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.cluster_resolver.SimpleClusterResolver", "path": "distribute/cluster_resolver/simpleclusterresolver", "type": "tf.distribute", "text": "\nSimple implementation of ClusterResolver that accepts all attributes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.cluster_resolver.SlurmClusterResolver", "path": "distribute/cluster_resolver/slurmclusterresolver", "type": "tf.distribute", "text": "\nClusterResolver for system with Slurm workload manager.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.cluster_resolver.TFConfigClusterResolver", "path": "distribute/cluster_resolver/tfconfigclusterresolver", "type": "tf.distribute", "text": "\nImplementation of a ClusterResolver which reads the TF_CONFIG EnvVar.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.cluster_resolver.TPUClusterResolver", "path": "distribute/cluster_resolver/tpuclusterresolver", "type": "tf.distribute", "text": "\nCluster Resolver for Google Cloud TPUs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.cluster_resolver.UnionResolver", "path": "distribute/cluster_resolver/unionresolver", "type": "tf.distribute", "text": "\nPerforms a union on underlying ClusterResolvers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.CrossDeviceOps", "path": "distribute/crossdeviceops", "type": "tf.distribute", "text": "\nBase class for cross-device reduction and broadcasting algorithms.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.DistributedDataset", "path": "distribute/distributeddataset", "type": "tf.distribute", "text": "\nRepresents a dataset distributed among devices and machines.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.DistributedIterator", "path": "distribute/distributediterator", "type": "tf.distribute", "text": "\nAn iterator over `tf.distribute.DistributedDataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.DistributedValues", "path": "distribute/distributedvalues", "type": "tf.distribute", "text": "\nBase class for representing distributed values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.experimental", "path": "distribute/experimental", "type": "tf.distribute", "text": "\nPublic API for tf.distribute.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.experimental.CentralStorageStrategy", "path": "distribute/experimental/centralstoragestrategy", "type": "tf.distribute", "text": "\nA one-machine strategy that puts all variables on a single device.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.experimental.CollectiveHints", "path": "distribute/experimental/collectivehints", "type": "tf.distribute", "text": "\nHints for collective operations like AllReduce.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.experimental.CommunicationImplementation", "path": "distribute/experimental/communicationimplementation", "type": "tf.distribute", "text": "\nCross device communication implementation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.experimental.CommunicationOptions", "path": "distribute/experimental/communicationoptions", "type": "tf.distribute", "text": "\nOptions for cross device communications like All-reduce.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.experimental.coordinator", "path": "distribute/experimental/coordinator", "type": "tf.distribute", "text": "\nPublic API for tf.distribute.experimental.coordinator namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.experimental.coordinator.ClusterCoordinator", "path": "distribute/experimental/coordinator/clustercoordinator", "type": "tf.distribute", "text": "\nAn object to schedule and coordinate remote function execution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.experimental.coordinator.PerWorkerValues", "path": "distribute/experimental/coordinator/perworkervalues", "type": "tf.distribute", "text": "\nA container that holds a list of values, one value per worker.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.experimental.coordinator.RemoteValue", "path": "distribute/experimental/coordinator/remotevalue", "type": "tf.distribute", "text": "\nAn asynchronously available value of a scheduled function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.experimental.MultiWorkerMirroredStrategy", "path": "distribute/experimental/multiworkermirroredstrategy", "type": "tf.distribute", "text": "\nA distribution strategy for synchronous training on multiple workers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.experimental.ParameterServerStrategy", "path": "distribute/experimental/parameterserverstrategy", "type": "tf.distribute", "text": "\nAn multi-worker tf.distribute strategy with parameter servers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.experimental.partitioners", "path": "distribute/experimental/partitioners", "type": "tf.distribute", "text": "\nPublic API for tf.distribute.experimental.partitioners namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.experimental.partitioners.FixedShardsPartitioner", "path": "distribute/experimental/partitioners/fixedshardspartitioner", "type": "tf.distribute", "text": "\nPartitioner that allocates a fixed number of shards.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.experimental.partitioners.MaxSizePartitioner", "path": "distribute/experimental/partitioners/maxsizepartitioner", "type": "tf.distribute", "text": "\nPartitioner that keeps shards below `max_shard_bytes`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.experimental.partitioners.MinSizePartitioner", "path": "distribute/experimental/partitioners/minsizepartitioner", "type": "tf.distribute", "text": "\nPartitioner that allocates a minimum size per shard.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.experimental.partitioners.Partitioner", "path": "distribute/experimental/partitioners/partitioner", "type": "tf.distribute", "text": "\nPartitioner base class: all partitiners inherit from this class.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.experimental.TPUStrategy", "path": "distribute/experimental/tpustrategy", "type": "tf.distribute", "text": "\nSynchronous training on TPUs and TPU Pods.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.experimental.ValueContext", "path": "distribute/experimental/valuecontext", "type": "tf.distribute", "text": "\nA class wrapping information needed by a distribute function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.experimental_set_strategy", "path": "distribute/experimental_set_strategy", "type": "tf.distribute", "text": "\nSet a `tf.distribute.Strategy` as current without `with strategy.scope()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.get_replica_context", "path": "distribute/get_replica_context", "type": "tf.distribute", "text": "\nReturns the current `tf.distribute.ReplicaContext` or `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.get_strategy", "path": "distribute/get_strategy", "type": "tf.distribute", "text": "\nReturns the current `tf.distribute.Strategy` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.has_strategy", "path": "distribute/has_strategy", "type": "tf.distribute", "text": "\nReturn if there is a current non-default `tf.distribute.Strategy`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.HierarchicalCopyAllReduce", "path": "distribute/hierarchicalcopyallreduce", "type": "tf.distribute", "text": "\nHierarchical copy all-reduce implementation of CrossDeviceOps.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.InputContext", "path": "distribute/inputcontext", "type": "tf.distribute", "text": "\nA class wrapping information needed by an input function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.InputOptions", "path": "distribute/inputoptions", "type": "tf.distribute", "text": "\nRun options for `experimental_distribute_dataset(s_from_function)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.InputReplicationMode", "path": "distribute/inputreplicationmode", "type": "tf.distribute", "text": "\nReplication mode for input function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.in_cross_replica_context", "path": "distribute/in_cross_replica_context", "type": "tf.distribute", "text": "\nReturns `True` if in a cross-replica context.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.MirroredStrategy", "path": "distribute/mirroredstrategy", "type": "tf.distribute", "text": "\nSynchronous training across multiple replicas on one machine.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.MultiWorkerMirroredStrategy", "path": "distribute/multiworkermirroredstrategy", "type": "tf.distribute", "text": "\nA distribution strategy for synchronous training on multiple workers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.NcclAllReduce", "path": "distribute/ncclallreduce", "type": "tf.distribute", "text": "\nNCCL all-reduce implementation of CrossDeviceOps.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.OneDeviceStrategy", "path": "distribute/onedevicestrategy", "type": "tf.distribute", "text": "\nA distribution strategy for running on a single device.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.ReduceOp", "path": "distribute/reduceop", "type": "tf.distribute", "text": "\nIndicates how a set of values should be reduced.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.ReductionToOneDevice", "path": "distribute/reductiontoonedevice", "type": "tf.distribute", "text": "\nA CrossDeviceOps implementation that copies values to one device to reduce.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.ReplicaContext", "path": "distribute/replicacontext", "type": "tf.distribute", "text": "\nA class with a collection of APIs that can be called in a replica context.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.RunOptions", "path": "distribute/runoptions", "type": "tf.distribute", "text": "\nRun options for `strategy.run`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.Server", "path": "distribute/server", "type": "tf.distribute", "text": "\nAn in-process TensorFlow server, for use in distributed training.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.Strategy", "path": "distribute/strategy", "type": "tf.distribute", "text": "\nA state & compute distribution policy on a list of devices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.StrategyExtended", "path": "distribute/strategyextended", "type": "tf.distribute", "text": "\nAdditional APIs for algorithms that need to be distribution-aware.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.distribute.TPUStrategy", "path": "distribute/tpustrategy", "type": "tf.distribute", "text": "\nSynchronous training on TPUs and TPU Pods.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.dtypes", "path": "dtypes", "type": "tf.dtypes", "text": "\nPublic API for tf.dtypes namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.dtypes.as_dtype", "path": "dtypes/as_dtype", "type": "tf.dtypes", "text": "\nConverts the given `type_value` to a `DType`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.dtypes.complex", "path": "dtypes/complex", "type": "tf.dtypes", "text": "\nConverts two real numbers to a complex number.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.dtypes.DType", "path": "dtypes/dtype", "type": "tf.dtypes", "text": "\nRepresents the type of the elements in a `Tensor`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.dtypes.saturate_cast", "path": "dtypes/saturate_cast", "type": "tf.dtypes", "text": "\nPerforms a safe saturating cast of `value` to `dtype`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.dynamic_partition", "path": "dynamic_partition", "type": "tf", "text": "\nPartitions `data` into `num_partitions` tensors using indices from\n`partitions`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.dynamic_stitch", "path": "dynamic_stitch", "type": "tf", "text": "\nInterleave the values from the `data` tensors into a single tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.edit_distance", "path": "edit_distance", "type": "tf", "text": "\nComputes the Levenshtein distance between sequences.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.einsum", "path": "einsum", "type": "tf", "text": "\nTensor contraction over specified indices and outer product.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.ensure_shape", "path": "ensure_shape", "type": "tf", "text": "\nUpdates the shape of a tensor and checks at runtime that the shape holds.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.errors", "path": "errors", "type": "tf.errors", "text": "\nException types for TensorFlow errors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.errors.AbortedError", "path": "errors/abortederror", "type": "tf.errors", "text": "\nThe operation was aborted, typically due to a concurrent action.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.errors.AlreadyExistsError", "path": "errors/alreadyexistserror", "type": "tf.errors", "text": "\nRaised when an entity that we attempted to create already exists.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.errors.CancelledError", "path": "errors/cancellederror", "type": "tf.errors", "text": "\nRaised when an operation or step is cancelled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.errors.DataLossError", "path": "errors/datalosserror", "type": "tf.errors", "text": "\nRaised when unrecoverable data loss or corruption is encountered.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.errors.DeadlineExceededError", "path": "errors/deadlineexceedederror", "type": "tf.errors", "text": "\nRaised when a deadline expires before an operation could complete.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.errors.FailedPreconditionError", "path": "errors/failedpreconditionerror", "type": "tf.errors", "text": "\nOperation was rejected because the system is not in a state to execute it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.errors.InternalError", "path": "errors/internalerror", "type": "tf.errors", "text": "\nRaised when the system experiences an internal error.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.errors.InvalidArgumentError", "path": "errors/invalidargumenterror", "type": "tf.errors", "text": "\nRaised when an operation receives an invalid argument.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.errors.NotFoundError", "path": "errors/notfounderror", "type": "tf.errors", "text": "\nRaised when a requested entity (e.g., a file or directory) was not found.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.errors.OperatorNotAllowedInGraphError", "path": "errors/operatornotallowedingrapherror", "type": "tf.errors", "text": "\nAn error is raised for unsupported operator in Graph execution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.errors.OpError", "path": "errors/operror", "type": "tf.errors", "text": "\nA generic error that is raised when TensorFlow execution fails.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.errors.OutOfRangeError", "path": "errors/outofrangeerror", "type": "tf.errors", "text": "\nRaised when an operation iterates past the valid input range.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.errors.PermissionDeniedError", "path": "errors/permissiondeniederror", "type": "tf.errors", "text": "\nRaised when the caller does not have permission to run an operation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.errors.ResourceExhaustedError", "path": "errors/resourceexhaustederror", "type": "tf.errors", "text": "\nSome resource has been exhausted.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.errors.UnauthenticatedError", "path": "errors/unauthenticatederror", "type": "tf.errors", "text": "\nThe request does not have valid authentication credentials.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.errors.UnavailableError", "path": "errors/unavailableerror", "type": "tf.errors", "text": "\nRaised when the runtime is currently unavailable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.errors.UnimplementedError", "path": "errors/unimplementederror", "type": "tf.errors", "text": "\nRaised when an operation has not been implemented.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.errors.UnknownError", "path": "errors/unknownerror", "type": "tf.errors", "text": "\nUnknown error.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator", "path": "estimator", "type": "tf.estimator", "text": "\nEstimator: High level tools for working with models.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.add_metrics", "path": "estimator/add_metrics", "type": "tf.estimator", "text": "\nCreates a new `tf.estimator.Estimator` which has given metrics.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.BaselineClassifier", "path": "estimator/baselineclassifier", "type": "tf.estimator", "text": "\nA classifier that can establish a simple baseline.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.BaselineEstimator", "path": "estimator/baselineestimator", "type": "tf.estimator", "text": "\nAn estimator that can establish a simple baseline.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.BaselineRegressor", "path": "estimator/baselineregressor", "type": "tf.estimator", "text": "\nA regressor that can establish a simple baseline.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.BestExporter", "path": "estimator/bestexporter", "type": "tf.estimator", "text": "\nThis class exports the serving graph and checkpoints of the best models.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.BinaryClassHead", "path": "estimator/binaryclasshead", "type": "tf.estimator", "text": "\nCreates a `Head` for single label binary classification.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.BoostedTreesClassifier", "path": "estimator/boostedtreesclassifier", "type": "tf.estimator", "text": "\nA Classifier for Tensorflow Boosted Trees models.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.BoostedTreesEstimator", "path": "estimator/boostedtreesestimator", "type": "tf.estimator", "text": "\nAn Estimator for Tensorflow Boosted Trees models.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.BoostedTreesRegressor", "path": "estimator/boostedtreesregressor", "type": "tf.estimator", "text": "\nA Regressor for Tensorflow Boosted Trees models.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.CheckpointSaverHook", "path": "estimator/checkpointsaverhook", "type": "tf.estimator", "text": "\nSaves checkpoints every N steps or seconds.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.CheckpointSaverListener", "path": "estimator/checkpointsaverlistener", "type": "tf.estimator", "text": "\nInterface for listeners that take action before or after checkpoint save.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.classifier_parse_example_spec", "path": "estimator/classifier_parse_example_spec", "type": "tf.estimator", "text": "\nGenerates parsing spec for tf.parse_example to be used with classifiers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.DNNClassifier", "path": "estimator/dnnclassifier", "type": "tf.estimator", "text": "\nA classifier for TensorFlow DNN models.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.DNNEstimator", "path": "estimator/dnnestimator", "type": "tf.estimator", "text": "\nAn estimator for TensorFlow DNN models with user-specified head.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.DNNLinearCombinedClassifier", "path": "estimator/dnnlinearcombinedclassifier", "type": "tf.estimator", "text": "\nAn estimator for TensorFlow Linear and DNN joined classification models.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.DNNLinearCombinedEstimator", "path": "estimator/dnnlinearcombinedestimator", "type": "tf.estimator", "text": "\nAn estimator for TensorFlow Linear and DNN joined models with custom head.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.DNNLinearCombinedRegressor", "path": "estimator/dnnlinearcombinedregressor", "type": "tf.estimator", "text": "\nAn estimator for TensorFlow Linear and DNN joined models for regression.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.DNNRegressor", "path": "estimator/dnnregressor", "type": "tf.estimator", "text": "\nA regressor for TensorFlow DNN models.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.Estimator", "path": "estimator/estimator", "type": "tf.estimator", "text": "\nEstimator class to train and evaluate TensorFlow models.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.EstimatorSpec", "path": "estimator/estimatorspec", "type": "tf.estimator", "text": "\nOps and objects returned from a `model_fn` and passed to an `Estimator`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.EvalSpec", "path": "estimator/evalspec", "type": "tf.estimator", "text": "\nConfiguration for the \"eval\" part for the `train_and_evaluate` call.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.experimental", "path": "estimator/experimental", "type": "tf.estimator", "text": "\nPublic API for tf.estimator.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.experimental.build_raw_supervised_input_receiver_fn", "path": "estimator/experimental/build_raw_supervised_input_receiver_fn", "type": "tf.estimator", "text": "\nBuild a supervised_input_receiver_fn for raw features and labels.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.experimental.call_logit_fn", "path": "estimator/experimental/call_logit_fn", "type": "tf.estimator", "text": "\nCalls logit_fn (experimental).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.experimental.InMemoryEvaluatorHook", "path": "estimator/experimental/inmemoryevaluatorhook", "type": "tf.estimator", "text": "\nHook to run evaluation in training without a checkpoint.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.experimental.LinearSDCA", "path": "estimator/experimental/linearsdca", "type": "tf.estimator", "text": "\nStochastic Dual Coordinate Ascent helper for linear estimators.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.experimental.make_early_stopping_hook", "path": "estimator/experimental/make_early_stopping_hook", "type": "tf.estimator", "text": "\nCreates early-stopping hook.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.experimental.make_stop_at_checkpoint_step_hook", "path": "estimator/experimental/make_stop_at_checkpoint_step_hook", "type": "tf.estimator", "text": "\nCreates a proper StopAtCheckpointStepHook based on chief status.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.experimental.RNNClassifier", "path": "estimator/experimental/rnnclassifier", "type": "tf.estimator", "text": "\nA classifier for TensorFlow RNN models.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.experimental.RNNEstimator", "path": "estimator/experimental/rnnestimator", "type": "tf.estimator", "text": "\nAn Estimator for TensorFlow RNN models with user-specified head.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.experimental.stop_if_higher_hook", "path": "estimator/experimental/stop_if_higher_hook", "type": "tf.estimator", "text": "\nCreates hook to stop if the given metric is higher than the threshold.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.experimental.stop_if_lower_hook", "path": "estimator/experimental/stop_if_lower_hook", "type": "tf.estimator", "text": "\nCreates hook to stop if the given metric is lower than the threshold.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.experimental.stop_if_no_decrease_hook", "path": "estimator/experimental/stop_if_no_decrease_hook", "type": "tf.estimator", "text": "\nCreates hook to stop if metric does not decrease within given max steps.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.experimental.stop_if_no_increase_hook", "path": "estimator/experimental/stop_if_no_increase_hook", "type": "tf.estimator", "text": "\nCreates hook to stop if metric does not increase within given max steps.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.export", "path": "estimator/export", "type": "tf.estimator", "text": "\nAll public utility methods for exporting Estimator to SavedModel.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.export.build_parsing_serving_input_receiver_fn", "path": "estimator/export/build_parsing_serving_input_receiver_fn", "type": "tf.estimator", "text": "\nBuild a serving_input_receiver_fn expecting fed tf.Examples.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.export.build_raw_serving_input_receiver_fn", "path": "estimator/export/build_raw_serving_input_receiver_fn", "type": "tf.estimator", "text": "\nBuild a serving_input_receiver_fn expecting feature Tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.export.ClassificationOutput", "path": "estimator/export/classificationoutput", "type": "tf.estimator", "text": "\nRepresents the output of a classification head.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.export.ExportOutput", "path": "estimator/export/exportoutput", "type": "tf.estimator", "text": "\nRepresents an output of a model that can be served.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.export.PredictOutput", "path": "estimator/export/predictoutput", "type": "tf.estimator", "text": "\nRepresents the output of a generic prediction head.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.export.RegressionOutput", "path": "estimator/export/regressionoutput", "type": "tf.estimator", "text": "\nRepresents the output of a regression head.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.export.ServingInputReceiver", "path": "estimator/export/servinginputreceiver", "type": "tf.estimator", "text": "\nA return type for a serving_input_receiver_fn.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.export.TensorServingInputReceiver", "path": "estimator/export/tensorservinginputreceiver", "type": "tf.estimator", "text": "\nA return type for a serving_input_receiver_fn.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.Exporter", "path": "estimator/exporter", "type": "tf.estimator", "text": "\nA class representing a type of model export.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.FeedFnHook", "path": "estimator/feedfnhook", "type": "tf.estimator", "text": "\nRuns `feed_fn` and sets the `feed_dict` accordingly.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.FinalExporter", "path": "estimator/finalexporter", "type": "tf.estimator", "text": "\nThis class exports the serving graph and checkpoints at the end.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.FinalOpsHook", "path": "estimator/finalopshook", "type": "tf.estimator", "text": "\nA hook which evaluates `Tensors` at the end of a session.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.GlobalStepWaiterHook", "path": "estimator/globalstepwaiterhook", "type": "tf.estimator", "text": "\nDelays execution until global step reaches `wait_until_step`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.Head", "path": "estimator/head", "type": "tf.estimator", "text": "\nInterface for the head/top of a model.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.LatestExporter", "path": "estimator/latestexporter", "type": "tf.estimator", "text": "\nThis class regularly exports the serving graph and checkpoints.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.LinearClassifier", "path": "estimator/linearclassifier", "type": "tf.estimator", "text": "\nLinear classifier model.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.LinearEstimator", "path": "estimator/linearestimator", "type": "tf.estimator", "text": "\nAn estimator for TensorFlow linear models with user-specified head.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.LinearRegressor", "path": "estimator/linearregressor", "type": "tf.estimator", "text": "\nAn estimator for TensorFlow Linear regression problems.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.LoggingTensorHook", "path": "estimator/loggingtensorhook", "type": "tf.estimator", "text": "\nPrints the given tensors every N local steps, every N seconds, or at end.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.LogisticRegressionHead", "path": "estimator/logisticregressionhead", "type": "tf.estimator", "text": "\nCreates a `Head` for logistic regression.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.ModeKeys", "path": "estimator/modekeys", "type": "tf.estimator", "text": "\nStandard names for Estimator model modes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.MultiClassHead", "path": "estimator/multiclasshead", "type": "tf.estimator", "text": "\nCreates a `Head` for multi class classification.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.MultiHead", "path": "estimator/multihead", "type": "tf.estimator", "text": "\nCreates a `Head` for multi-objective learning.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.MultiLabelHead", "path": "estimator/multilabelhead", "type": "tf.estimator", "text": "\nCreates a `Head` for multi-label classification.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.NanLossDuringTrainingError", "path": "estimator/nanlossduringtrainingerror", "type": "tf.estimator", "text": "\nUnspecified run-time error.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.NanTensorHook", "path": "estimator/nantensorhook", "type": "tf.estimator", "text": "\nMonitors the loss tensor and stops training if loss is NaN.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.PoissonRegressionHead", "path": "estimator/poissonregressionhead", "type": "tf.estimator", "text": "\nCreates a `Head` for poisson regression using `tf.nn.log_poisson_loss`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.ProfilerHook", "path": "estimator/profilerhook", "type": "tf.estimator", "text": "\nCaptures CPU/GPU profiling information every N steps or seconds.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.RegressionHead", "path": "estimator/regressionhead", "type": "tf.estimator", "text": "\nCreates a `Head` for regression using the `mean_squared_error` loss.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.regressor_parse_example_spec", "path": "estimator/regressor_parse_example_spec", "type": "tf.estimator", "text": "\nGenerates parsing spec for tf.parse_example to be used with regressors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.RunConfig", "path": "estimator/runconfig", "type": "tf.estimator", "text": "\nThis class specifies the configurations for an `Estimator` run.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.SecondOrStepTimer", "path": "estimator/secondorsteptimer", "type": "tf.estimator", "text": "\nTimer that triggers at most once every N seconds or once every N steps.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.SessionRunArgs", "path": "estimator/sessionrunargs", "type": "tf.estimator", "text": "\nRepresents arguments to be added to a `Session.run()` call.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.SessionRunContext", "path": "estimator/sessionruncontext", "type": "tf.estimator", "text": "\nProvides information about the `session.run()` call being made.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.SessionRunHook", "path": "estimator/sessionrunhook", "type": "tf.estimator", "text": "\nHook to extend calls to MonitoredSession.run().\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.SessionRunValues", "path": "estimator/sessionrunvalues", "type": "tf.estimator", "text": "\nContains the results of `Session.run()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.StepCounterHook", "path": "estimator/stepcounterhook", "type": "tf.estimator", "text": "\nHook that counts steps per second.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.StopAtStepHook", "path": "estimator/stopatstephook", "type": "tf.estimator", "text": "\nHook that requests stop at a specified step.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.SummarySaverHook", "path": "estimator/summarysaverhook", "type": "tf.estimator", "text": "\nSaves summaries every N steps.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.TrainSpec", "path": "estimator/trainspec", "type": "tf.estimator", "text": "\nConfiguration for the \"train\" part for the `train_and_evaluate` call.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.train_and_evaluate", "path": "estimator/train_and_evaluate", "type": "tf.estimator", "text": "\nTrain and evaluate the `estimator`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.VocabInfo", "path": "estimator/vocabinfo", "type": "tf.estimator", "text": "\nVocabulary information for warm-starting.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.estimator.WarmStartSettings", "path": "estimator/warmstartsettings", "type": "tf.estimator", "text": "\nSettings for warm-starting in `tf.estimator.Estimators`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.executing_eagerly", "path": "executing_eagerly", "type": "tf", "text": "\nChecks whether the current thread has eager execution enabled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.expand_dims", "path": "expand_dims", "type": "tf", "text": "\nReturns a tensor with a length 1 axis inserted at index `axis`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental", "path": "experimental", "type": "tf.experimental", "text": "\nPublic API for tf.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.async_clear_error", "path": "experimental/async_clear_error", "type": "tf.experimental", "text": "\nClear pending operations and error statuses in async execution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.async_scope", "path": "experimental/async_scope", "type": "tf.experimental", "text": "\nContext manager for grouping async operations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.dlpack", "path": "experimental/dlpack", "type": "tf.experimental", "text": "\nPublic API for tf.experimental.dlpack namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.dlpack.from_dlpack", "path": "experimental/dlpack/from_dlpack", "type": "tf.experimental", "text": "\nReturns the Tensorflow eager tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.dlpack.to_dlpack", "path": "experimental/dlpack/to_dlpack", "type": "tf.experimental", "text": "\nReturns the dlpack capsule representing the tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.function_executor_type", "path": "experimental/function_executor_type", "type": "tf.experimental", "text": "\nContext manager for setting the executor of eager defined functions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy", "path": "experimental/numpy", "type": "tf.experimental", "text": "\nThis module provides a subset of NumPy API, built on top of TensorFlow\noperations. APIs are based on and have been tested with NumPy 1.16 version.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.abs", "path": "experimental/numpy/abs", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `abs`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.absolute", "path": "experimental/numpy/absolute", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `absolute`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.add", "path": "experimental/numpy/add", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `add`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.all", "path": "experimental/numpy/all", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `all`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.allclose", "path": "experimental/numpy/allclose", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `allclose`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.amax", "path": "experimental/numpy/amax", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `amax`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.amin", "path": "experimental/numpy/amin", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `amin`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.angle", "path": "experimental/numpy/angle", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `angle`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.any", "path": "experimental/numpy/any", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `any`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.append", "path": "experimental/numpy/append", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `append`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.arange", "path": "experimental/numpy/arange", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `arange`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.arccos", "path": "experimental/numpy/arccos", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `arccos`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.arccosh", "path": "experimental/numpy/arccosh", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `arccosh`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.arcsin", "path": "experimental/numpy/arcsin", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `arcsin`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.arcsinh", "path": "experimental/numpy/arcsinh", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `arcsinh`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.arctan", "path": "experimental/numpy/arctan", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `arctan`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.arctan2", "path": "experimental/numpy/arctan2", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `arctan2`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.arctanh", "path": "experimental/numpy/arctanh", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `arctanh`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.argmax", "path": "experimental/numpy/argmax", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `argmax`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.argmin", "path": "experimental/numpy/argmin", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `argmin`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.argsort", "path": "experimental/numpy/argsort", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `argsort`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.around", "path": "experimental/numpy/around", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `around`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.array", "path": "experimental/numpy/array", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `array`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.array_equal", "path": "experimental/numpy/array_equal", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `array_equal`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.asanyarray", "path": "experimental/numpy/asanyarray", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `asanyarray`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.asarray", "path": "experimental/numpy/asarray", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `asarray`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.ascontiguousarray", "path": "experimental/numpy/ascontiguousarray", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `ascontiguousarray`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.atleast_1d", "path": "experimental/numpy/atleast_1d", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `atleast_1d`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.atleast_2d", "path": "experimental/numpy/atleast_2d", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `atleast_2d`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.atleast_3d", "path": "experimental/numpy/atleast_3d", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `atleast_3d`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.average", "path": "experimental/numpy/average", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `average`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.bitwise_and", "path": "experimental/numpy/bitwise_and", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `bitwise_and`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.bitwise_not", "path": "experimental/numpy/bitwise_not", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `bitwise_not`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.bitwise_or", "path": "experimental/numpy/bitwise_or", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `bitwise_or`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.bitwise_xor", "path": "experimental/numpy/bitwise_xor", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `bitwise_xor`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.bool_", "path": "experimental/numpy/bool_", "type": "tf.experimental", "text": "\nBoolean type (True or False), stored as a byte.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.broadcast_arrays", "path": "experimental/numpy/broadcast_arrays", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `broadcast_arrays`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.broadcast_to", "path": "experimental/numpy/broadcast_to", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `broadcast_to`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.cbrt", "path": "experimental/numpy/cbrt", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `cbrt`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.ceil", "path": "experimental/numpy/ceil", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `ceil`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.clip", "path": "experimental/numpy/clip", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `clip`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.complex128", "path": "experimental/numpy/complex128", "type": "tf.experimental", "text": "\nComplex number type composed of two double-precision floating-point\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.complex64", "path": "experimental/numpy/complex64", "type": "tf.experimental", "text": "\nComplex number type composed of two single-precision floating-point\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.compress", "path": "experimental/numpy/compress", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `compress`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.concatenate", "path": "experimental/numpy/concatenate", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `concatenate`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.conj", "path": "experimental/numpy/conj", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `conj`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.conjugate", "path": "experimental/numpy/conjugate", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `conjugate`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.copy", "path": "experimental/numpy/copy", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `copy`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.cos", "path": "experimental/numpy/cos", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `cos`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.cosh", "path": "experimental/numpy/cosh", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `cosh`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.count_nonzero", "path": "experimental/numpy/count_nonzero", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `count_nonzero`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.cross", "path": "experimental/numpy/cross", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `cross`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.cumprod", "path": "experimental/numpy/cumprod", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `cumprod`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.cumsum", "path": "experimental/numpy/cumsum", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `cumsum`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.deg2rad", "path": "experimental/numpy/deg2rad", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `deg2rad`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.diag", "path": "experimental/numpy/diag", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `diag`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.diagflat", "path": "experimental/numpy/diagflat", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `diagflat`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.diagonal", "path": "experimental/numpy/diagonal", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `diagonal`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.diag_indices", "path": "experimental/numpy/diag_indices", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `diag_indices`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.diff", "path": "experimental/numpy/diff", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `diff`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.divide", "path": "experimental/numpy/divide", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `divide`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.divmod", "path": "experimental/numpy/divmod", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `divmod`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.dot", "path": "experimental/numpy/dot", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `dot`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.dsplit", "path": "experimental/numpy/dsplit", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `dsplit`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.dstack", "path": "experimental/numpy/dstack", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `dstack`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.einsum", "path": "experimental/numpy/einsum", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `einsum`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.empty", "path": "experimental/numpy/empty", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `empty`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.empty_like", "path": "experimental/numpy/empty_like", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `empty_like`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.equal", "path": "experimental/numpy/equal", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `equal`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.exp", "path": "experimental/numpy/exp", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `exp`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.exp2", "path": "experimental/numpy/exp2", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `exp2`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.expand_dims", "path": "experimental/numpy/expand_dims", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `expand_dims`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.expm1", "path": "experimental/numpy/expm1", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `expm1`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.eye", "path": "experimental/numpy/eye", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `eye`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.fabs", "path": "experimental/numpy/fabs", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `fabs`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.finfo", "path": "experimental/numpy/finfo", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `finfo`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.fix", "path": "experimental/numpy/fix", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `fix`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.flip", "path": "experimental/numpy/flip", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `flip`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.fliplr", "path": "experimental/numpy/fliplr", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `fliplr`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.flipud", "path": "experimental/numpy/flipud", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `flipud`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.float16", "path": "experimental/numpy/float16", "type": "tf.experimental", "text": "\nHalf-precision floating-point number type.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.float32", "path": "experimental/numpy/float32", "type": "tf.experimental", "text": "\nSingle-precision floating-point number type, compatible with C `float`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.float64", "path": "experimental/numpy/float64", "type": "tf.experimental", "text": "\nDouble-precision floating-point number type, compatible with Python `float`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.float_power", "path": "experimental/numpy/float_power", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `float_power`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.floor", "path": "experimental/numpy/floor", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `floor`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.floor_divide", "path": "experimental/numpy/floor_divide", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `floor_divide`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.full", "path": "experimental/numpy/full", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `full`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.full_like", "path": "experimental/numpy/full_like", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `full_like`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.gcd", "path": "experimental/numpy/gcd", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `gcd`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.geomspace", "path": "experimental/numpy/geomspace", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `geomspace`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.greater", "path": "experimental/numpy/greater", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `greater`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.greater_equal", "path": "experimental/numpy/greater_equal", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `greater_equal`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.heaviside", "path": "experimental/numpy/heaviside", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `heaviside`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.hsplit", "path": "experimental/numpy/hsplit", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `hsplit`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.hstack", "path": "experimental/numpy/hstack", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `hstack`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.hypot", "path": "experimental/numpy/hypot", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `hypot`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.identity", "path": "experimental/numpy/identity", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `identity`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.iinfo", "path": "experimental/numpy/iinfo", "type": "tf.experimental", "text": "\niinfo(type)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.imag", "path": "experimental/numpy/imag", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `imag`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.inexact", "path": "experimental/numpy/inexact", "type": "tf.experimental", "text": "\nAbstract base class of all numeric scalar types with a (potentially)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.inner", "path": "experimental/numpy/inner", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `inner`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.int16", "path": "experimental/numpy/int16", "type": "tf.experimental", "text": "\nSigned integer type, compatible with C `short`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.int32", "path": "experimental/numpy/int32", "type": "tf.experimental", "text": "\nSigned integer type, compatible with C `int`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.int64", "path": "experimental/numpy/int64", "type": "tf.experimental", "text": "\nSigned integer type, compatible with Python `int` anc C `long`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.int8", "path": "experimental/numpy/int8", "type": "tf.experimental", "text": "\nSigned integer type, compatible with C `char`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.isclose", "path": "experimental/numpy/isclose", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `isclose`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.iscomplex", "path": "experimental/numpy/iscomplex", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `iscomplex`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.iscomplexobj", "path": "experimental/numpy/iscomplexobj", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `iscomplexobj`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.isfinite", "path": "experimental/numpy/isfinite", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `isfinite`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.isinf", "path": "experimental/numpy/isinf", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `isinf`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.isnan", "path": "experimental/numpy/isnan", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `isnan`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.isneginf", "path": "experimental/numpy/isneginf", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `isneginf`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.isposinf", "path": "experimental/numpy/isposinf", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `isposinf`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.isreal", "path": "experimental/numpy/isreal", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `isreal`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.isrealobj", "path": "experimental/numpy/isrealobj", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `isrealobj`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.isscalar", "path": "experimental/numpy/isscalar", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `isscalar`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.issubdtype", "path": "experimental/numpy/issubdtype", "type": "tf.experimental", "text": "\nReturns True if first argument is a typecode lower/equal in type hierarchy.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.ix_", "path": "experimental/numpy/ix_", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `ix_`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.kron", "path": "experimental/numpy/kron", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `kron`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.lcm", "path": "experimental/numpy/lcm", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `lcm`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.less", "path": "experimental/numpy/less", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `less`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.less_equal", "path": "experimental/numpy/less_equal", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `less_equal`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.linspace", "path": "experimental/numpy/linspace", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `linspace`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.log", "path": "experimental/numpy/log", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `log`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.log10", "path": "experimental/numpy/log10", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `log10`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.log1p", "path": "experimental/numpy/log1p", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `log1p`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.log2", "path": "experimental/numpy/log2", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `log2`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.logaddexp", "path": "experimental/numpy/logaddexp", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `logaddexp`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.logaddexp2", "path": "experimental/numpy/logaddexp2", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `logaddexp2`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.logical_and", "path": "experimental/numpy/logical_and", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `logical_and`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.logical_not", "path": "experimental/numpy/logical_not", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `logical_not`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.logical_or", "path": "experimental/numpy/logical_or", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `logical_or`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.logical_xor", "path": "experimental/numpy/logical_xor", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `logical_xor`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.logspace", "path": "experimental/numpy/logspace", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `logspace`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.matmul", "path": "experimental/numpy/matmul", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `matmul`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.max", "path": "experimental/numpy/max", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `max`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.maximum", "path": "experimental/numpy/maximum", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `maximum`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.mean", "path": "experimental/numpy/mean", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `mean`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.meshgrid", "path": "experimental/numpy/meshgrid", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `meshgrid`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.min", "path": "experimental/numpy/min", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `min`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.minimum", "path": "experimental/numpy/minimum", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `minimum`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.mod", "path": "experimental/numpy/mod", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `mod`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.moveaxis", "path": "experimental/numpy/moveaxis", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `moveaxis`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.multiply", "path": "experimental/numpy/multiply", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `multiply`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.nanmean", "path": "experimental/numpy/nanmean", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `nanmean`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.nanprod", "path": "experimental/numpy/nanprod", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `nanprod`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.nansum", "path": "experimental/numpy/nansum", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `nansum`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.ndarray", "path": "experimental/numpy/ndarray", "type": "tf.experimental", "text": "\nEquivalent of numpy.ndarray backed by TensorFlow tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.ndim", "path": "experimental/numpy/ndim", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `ndim`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.negative", "path": "experimental/numpy/negative", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `negative`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.nextafter", "path": "experimental/numpy/nextafter", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `nextafter`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.nonzero", "path": "experimental/numpy/nonzero", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `nonzero`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.not_equal", "path": "experimental/numpy/not_equal", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `not_equal`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.object_", "path": "experimental/numpy/object_", "type": "tf.experimental", "text": "\nAny Python object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.ones", "path": "experimental/numpy/ones", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `ones`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.ones_like", "path": "experimental/numpy/ones_like", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `ones_like`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.outer", "path": "experimental/numpy/outer", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `outer`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.pad", "path": "experimental/numpy/pad", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `pad`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.polyval", "path": "experimental/numpy/polyval", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `polyval`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.positive", "path": "experimental/numpy/positive", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `positive`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.power", "path": "experimental/numpy/power", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `power`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.prod", "path": "experimental/numpy/prod", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `prod`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.promote_types", "path": "experimental/numpy/promote_types", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `promote_types`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.ptp", "path": "experimental/numpy/ptp", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `ptp`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.rad2deg", "path": "experimental/numpy/rad2deg", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `rad2deg`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.random", "path": "experimental/numpy/random", "type": "tf.experimental", "text": "\nPublic API for tf.experimental.numpy.random namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.random.rand", "path": "experimental/numpy/random/rand", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `random.rand`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.random.randint", "path": "experimental/numpy/random/randint", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `random.randint`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.random.randn", "path": "experimental/numpy/random/randn", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `random.randn`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.random.random", "path": "experimental/numpy/random/random", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `random.random`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.random.seed", "path": "experimental/numpy/random/seed", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `random.seed`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.random.uniform", "path": "experimental/numpy/random/uniform", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `random.uniform`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.ravel", "path": "experimental/numpy/ravel", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `ravel`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.real", "path": "experimental/numpy/real", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `real`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.reciprocal", "path": "experimental/numpy/reciprocal", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `reciprocal`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.remainder", "path": "experimental/numpy/remainder", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `remainder`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.repeat", "path": "experimental/numpy/repeat", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `repeat`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.reshape", "path": "experimental/numpy/reshape", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `reshape`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.result_type", "path": "experimental/numpy/result_type", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `result_type`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.roll", "path": "experimental/numpy/roll", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `roll`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.rot90", "path": "experimental/numpy/rot90", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `rot90`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.round", "path": "experimental/numpy/round", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `round`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.select", "path": "experimental/numpy/select", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `select`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.shape", "path": "experimental/numpy/shape", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `shape`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.sign", "path": "experimental/numpy/sign", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `sign`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.signbit", "path": "experimental/numpy/signbit", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `signbit`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.sin", "path": "experimental/numpy/sin", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `sin`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.sinc", "path": "experimental/numpy/sinc", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `sinc`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.sinh", "path": "experimental/numpy/sinh", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `sinh`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.size", "path": "experimental/numpy/size", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `size`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.sort", "path": "experimental/numpy/sort", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `sort`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.split", "path": "experimental/numpy/split", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `split`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.sqrt", "path": "experimental/numpy/sqrt", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `sqrt`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.square", "path": "experimental/numpy/square", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `square`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.squeeze", "path": "experimental/numpy/squeeze", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `squeeze`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.stack", "path": "experimental/numpy/stack", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `stack`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.std", "path": "experimental/numpy/std", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `std`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.string_", "path": "experimental/numpy/string_", "type": "tf.experimental", "text": "\nbytes(iterable_of_ints) -> bytes\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.subtract", "path": "experimental/numpy/subtract", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `subtract`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.sum", "path": "experimental/numpy/sum", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `sum`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.swapaxes", "path": "experimental/numpy/swapaxes", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `swapaxes`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.take", "path": "experimental/numpy/take", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `take`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.take_along_axis", "path": "experimental/numpy/take_along_axis", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `take_along_axis`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.tan", "path": "experimental/numpy/tan", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `tan`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.tanh", "path": "experimental/numpy/tanh", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `tanh`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.tensordot", "path": "experimental/numpy/tensordot", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `tensordot`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.tile", "path": "experimental/numpy/tile", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `tile`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.trace", "path": "experimental/numpy/trace", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `trace`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.transpose", "path": "experimental/numpy/transpose", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `transpose`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.tri", "path": "experimental/numpy/tri", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `tri`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.tril", "path": "experimental/numpy/tril", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `tril`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.triu", "path": "experimental/numpy/triu", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `triu`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.true_divide", "path": "experimental/numpy/true_divide", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `true_divide`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.uint16", "path": "experimental/numpy/uint16", "type": "tf.experimental", "text": "\nUnsigned integer type, compatible with C `unsigned short`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.uint32", "path": "experimental/numpy/uint32", "type": "tf.experimental", "text": "\nUnsigned integer type, compatible with C `unsigned int`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.uint64", "path": "experimental/numpy/uint64", "type": "tf.experimental", "text": "\nUnsigned integer type, compatible with C `unsigned long`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.uint8", "path": "experimental/numpy/uint8", "type": "tf.experimental", "text": "\nUnsigned integer type, compatible with C `unsigned char`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.unicode_", "path": "experimental/numpy/unicode_", "type": "tf.experimental", "text": "\nstr(object='') -> str\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.vander", "path": "experimental/numpy/vander", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `vander`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.var", "path": "experimental/numpy/var", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `var`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.vdot", "path": "experimental/numpy/vdot", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `vdot`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.vsplit", "path": "experimental/numpy/vsplit", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `vsplit`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.vstack", "path": "experimental/numpy/vstack", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `vstack`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.where", "path": "experimental/numpy/where", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `where`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.zeros", "path": "experimental/numpy/zeros", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `zeros`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.numpy.zeros_like", "path": "experimental/numpy/zeros_like", "type": "tf.experimental", "text": "\nTensorFlow variant of NumPy's `zeros_like`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.Optional", "path": "experimental/optional", "type": "tf.experimental", "text": "\nRepresents a value that may or may not be present.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.register_filesystem_plugin", "path": "experimental/register_filesystem_plugin", "type": "tf.experimental", "text": "\nLoads a TensorFlow FileSystem plugin.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.tensorrt", "path": "experimental/tensorrt", "type": "tf.experimental", "text": "\nPublic API for tf.experimental.tensorrt namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.tensorrt.ConversionParams", "path": "experimental/tensorrt/conversionparams", "type": "tf.experimental", "text": "\nParameters that are used for TF-TRT conversion.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.experimental.tensorrt.Converter", "path": "experimental/tensorrt/converter", "type": "tf.experimental", "text": "\nAn offline converter for TF-TRT transformation for TF 2.0 SavedModels.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.extract_volume_patches", "path": "extract_volume_patches", "type": "tf", "text": "\nExtract `patches` from `input` and put them in the `\"depth\"` output dimension.\n3D extension of `extract_image_patches`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.eye", "path": "eye", "type": "tf", "text": "\nConstruct an identity matrix, or a batch of matrices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.feature_column", "path": "feature_column", "type": "tf.feature_column", "text": "\nPublic API for tf.feature_column namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.feature_column.bucketized_column", "path": "feature_column/bucketized_column", "type": "tf.feature_column", "text": "\nRepresents discretized dense input bucketed by `boundaries`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.feature_column.categorical_column_with_hash_bucket", "path": "feature_column/categorical_column_with_hash_bucket", "type": "tf.feature_column", "text": "\nRepresents sparse feature where ids are set by hashing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.feature_column.categorical_column_with_identity", "path": "feature_column/categorical_column_with_identity", "type": "tf.feature_column", "text": "\nA `CategoricalColumn` that returns identity values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.feature_column.categorical_column_with_vocabulary_file", "path": "feature_column/categorical_column_with_vocabulary_file", "type": "tf.feature_column", "text": "\nA `CategoricalColumn` with a vocabulary file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.feature_column.categorical_column_with_vocabulary_list", "path": "feature_column/categorical_column_with_vocabulary_list", "type": "tf.feature_column", "text": "\nA `CategoricalColumn` with in-memory vocabulary.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.feature_column.crossed_column", "path": "feature_column/crossed_column", "type": "tf.feature_column", "text": "\nReturns a column for performing crosses of categorical features.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.feature_column.embedding_column", "path": "feature_column/embedding_column", "type": "tf.feature_column", "text": "\n`DenseColumn` that converts from sparse, categorical input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.feature_column.indicator_column", "path": "feature_column/indicator_column", "type": "tf.feature_column", "text": "\nRepresents multi-hot representation of given categorical column.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.feature_column.make_parse_example_spec", "path": "feature_column/make_parse_example_spec", "type": "tf.feature_column", "text": "\nCreates parsing spec dictionary from input feature_columns.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.feature_column.numeric_column", "path": "feature_column/numeric_column", "type": "tf.feature_column", "text": "\nRepresents real valued or numerical features.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.feature_column.sequence_categorical_column_with_hash_bucket", "path": "feature_column/sequence_categorical_column_with_hash_bucket", "type": "tf.feature_column", "text": "\nA sequence of categorical terms where ids are set by hashing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.feature_column.sequence_categorical_column_with_identity", "path": "feature_column/sequence_categorical_column_with_identity", "type": "tf.feature_column", "text": "\nReturns a feature column that represents sequences of integers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.feature_column.sequence_categorical_column_with_vocabulary_file", "path": "feature_column/sequence_categorical_column_with_vocabulary_file", "type": "tf.feature_column", "text": "\nA sequence of categorical terms where ids use a vocabulary file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.feature_column.sequence_categorical_column_with_vocabulary_list", "path": "feature_column/sequence_categorical_column_with_vocabulary_list", "type": "tf.feature_column", "text": "\nA sequence of categorical terms where ids use an in-memory list.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.feature_column.sequence_numeric_column", "path": "feature_column/sequence_numeric_column", "type": "tf.feature_column", "text": "\nReturns a feature column that represents sequences of numeric data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.feature_column.shared_embeddings", "path": "feature_column/shared_embeddings", "type": "tf.feature_column", "text": "\nList of dense columns that convert from sparse, categorical input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.feature_column.weighted_categorical_column", "path": "feature_column/weighted_categorical_column", "type": "tf.feature_column", "text": "\nApplies weight values to a `CategoricalColumn`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.fill", "path": "fill", "type": "tf", "text": "\nCreates a tensor filled with a scalar value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.fingerprint", "path": "fingerprint", "type": "tf", "text": "\nGenerates fingerprint values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.foldl", "path": "foldl", "type": "tf", "text": "\nfoldl on the list of tensors unpacked from `elems` on dimension 0. (deprecated\nargument values)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.foldr", "path": "foldr", "type": "tf", "text": "\nfoldr on the list of tensors unpacked from `elems` on dimension 0. (deprecated\nargument values)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.function", "path": "function", "type": "tf", "text": "\nCompiles a function into a callable TensorFlow graph.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.gather", "path": "gather", "type": "tf", "text": "\nGather slices from params axis `axis` according to indices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.gather_nd", "path": "gather_nd", "type": "tf", "text": "\nGather slices from `params` into a Tensor with shape specified by `indices`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.get_logger", "path": "get_logger", "type": "tf", "text": "\nReturn TF logger instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.get_static_value", "path": "get_static_value", "type": "tf", "text": "\nReturns the constant value of the given tensor, if efficiently calculable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.gradients", "path": "gradients", "type": "tf", "text": "\nConstructs symbolic derivatives of sum of `ys` w.r.t. x in `xs`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.GradientTape", "path": "gradienttape", "type": "tf", "text": "\nRecord operations for automatic differentiation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.grad_pass_through", "path": "grad_pass_through", "type": "tf", "text": "\nCreates a grad-pass-through op with the forward behavior provided in f.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.Graph", "path": "graph", "type": "tf", "text": "\nA TensorFlow computation, represented as a dataflow graph.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.graph_util", "path": "graph_util", "type": "tf.graph_util", "text": "\nHelpers to manipulate a tensor graph in python.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.graph_util.import_graph_def", "path": "graph_util/import_graph_def", "type": "tf.graph_util", "text": "\nImports the graph from `graph_def` into the current default `Graph`.\n(deprecated arguments)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.group", "path": "group", "type": "tf", "text": "\nCreate an op that groups multiple operations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.guarantee_const", "path": "guarantee_const", "type": "tf", "text": "\nGives a guarantee to the TF runtime that the input tensor is a constant.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.hessians", "path": "hessians", "type": "tf", "text": "\nConstructs the Hessian of sum of `ys` with respect to `x` in `xs`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.histogram_fixed_width", "path": "histogram_fixed_width", "type": "tf", "text": "\nReturn histogram of values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.histogram_fixed_width_bins", "path": "histogram_fixed_width_bins", "type": "tf", "text": "\nBins the given values for use in a histogram.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.identity", "path": "identity", "type": "tf", "text": "\nReturn a Tensor with the same shape and contents as input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.identity_n", "path": "identity_n", "type": "tf", "text": "\nReturns a list of tensors with the same shapes and contents as the input\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image", "path": "image", "type": "tf.image", "text": "\nImage ops.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.adjust_brightness", "path": "image/adjust_brightness", "type": "tf.image", "text": "\nAdjust the brightness of RGB or Grayscale images.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.adjust_contrast", "path": "image/adjust_contrast", "type": "tf.image", "text": "\nAdjust contrast of RGB or grayscale images.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.adjust_gamma", "path": "image/adjust_gamma", "type": "tf.image", "text": "\nPerforms Gamma Correction.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.adjust_hue", "path": "image/adjust_hue", "type": "tf.image", "text": "\nAdjust hue of RGB images.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.adjust_jpeg_quality", "path": "image/adjust_jpeg_quality", "type": "tf.image", "text": "\nAdjust jpeg encoding quality of an image.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.adjust_saturation", "path": "image/adjust_saturation", "type": "tf.image", "text": "\nAdjust saturation of RGB images.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.central_crop", "path": "image/central_crop", "type": "tf.image", "text": "\nCrop the central region of the image(s).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.combined_non_max_suppression", "path": "image/combined_non_max_suppression", "type": "tf.image", "text": "\nGreedily selects a subset of bounding boxes in descending order of score.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.convert_image_dtype", "path": "image/convert_image_dtype", "type": "tf.image", "text": "\nConvert `image` to `dtype`, scaling its values if needed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.crop_and_resize", "path": "image/crop_and_resize", "type": "tf.image", "text": "\nExtracts crops from the input image tensor and resizes them.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.crop_to_bounding_box", "path": "image/crop_to_bounding_box", "type": "tf.image", "text": "\nCrops an image to a specified bounding box.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.draw_bounding_boxes", "path": "image/draw_bounding_boxes", "type": "tf.image", "text": "\nDraw bounding boxes on a batch of images.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.extract_glimpse", "path": "image/extract_glimpse", "type": "tf.image", "text": "\nExtracts a glimpse from the input tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.extract_patches", "path": "image/extract_patches", "type": "tf.image", "text": "\nExtract `patches` from `images`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.flip_left_right", "path": "image/flip_left_right", "type": "tf.image", "text": "\nFlip an image horizontally (left to right).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.flip_up_down", "path": "image/flip_up_down", "type": "tf.image", "text": "\nFlip an image vertically (upside down).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.generate_bounding_box_proposals", "path": "image/generate_bounding_box_proposals", "type": "tf.image", "text": "\nGenerate bounding box proposals from encoded bounding boxes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.grayscale_to_rgb", "path": "image/grayscale_to_rgb", "type": "tf.image", "text": "\nConverts one or more images from Grayscale to RGB.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.hsv_to_rgb", "path": "image/hsv_to_rgb", "type": "tf.image", "text": "\nConvert one or more images from HSV to RGB.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.image_gradients", "path": "image/image_gradients", "type": "tf.image", "text": "\nReturns image gradients (dy, dx) for each color channel.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.non_max_suppression", "path": "image/non_max_suppression", "type": "tf.image", "text": "\nGreedily selects a subset of bounding boxes in descending order of score.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.non_max_suppression_overlaps", "path": "image/non_max_suppression_overlaps", "type": "tf.image", "text": "\nGreedily selects a subset of bounding boxes in descending order of score.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.non_max_suppression_padded", "path": "image/non_max_suppression_padded", "type": "tf.image", "text": "\nGreedily selects a subset of bounding boxes in descending order of score.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.non_max_suppression_with_scores", "path": "image/non_max_suppression_with_scores", "type": "tf.image", "text": "\nGreedily selects a subset of bounding boxes in descending order of score.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.pad_to_bounding_box", "path": "image/pad_to_bounding_box", "type": "tf.image", "text": "\nPad `image` with zeros to the specified `height` and `width`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.per_image_standardization", "path": "image/per_image_standardization", "type": "tf.image", "text": "\nLinearly scales each image in `image` to have mean 0 and variance 1.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.psnr", "path": "image/psnr", "type": "tf.image", "text": "\nReturns the Peak Signal-to-Noise Ratio between a and b.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.random_brightness", "path": "image/random_brightness", "type": "tf.image", "text": "\nAdjust the brightness of images by a random factor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.random_contrast", "path": "image/random_contrast", "type": "tf.image", "text": "\nAdjust the contrast of an image or images by a random factor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.random_crop", "path": "image/random_crop", "type": "tf.image", "text": "\nRandomly crops a tensor to a given size.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.random_flip_left_right", "path": "image/random_flip_left_right", "type": "tf.image", "text": "\nRandomly flip an image horizontally (left to right).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.random_flip_up_down", "path": "image/random_flip_up_down", "type": "tf.image", "text": "\nRandomly flips an image vertically (upside down).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.random_hue", "path": "image/random_hue", "type": "tf.image", "text": "\nAdjust the hue of RGB images by a random factor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.random_jpeg_quality", "path": "image/random_jpeg_quality", "type": "tf.image", "text": "\nRandomly changes jpeg encoding quality for inducing jpeg noise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.random_saturation", "path": "image/random_saturation", "type": "tf.image", "text": "\nAdjust the saturation of RGB images by a random factor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.resize", "path": "image/resize", "type": "tf.image", "text": "\nResize `images` to `size` using the specified `method`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.ResizeMethod", "path": "image/resizemethod", "type": "tf.image", "text": "\nSee `tf.image.resize` for details.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.resize_with_crop_or_pad", "path": "image/resize_with_crop_or_pad", "type": "tf.image", "text": "\nCrops and/or pads an image to a target width and height.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.resize_with_pad", "path": "image/resize_with_pad", "type": "tf.image", "text": "\nResizes and pads an image to a target width and height.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.rgb_to_grayscale", "path": "image/rgb_to_grayscale", "type": "tf.image", "text": "\nConverts one or more images from RGB to Grayscale.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.rgb_to_hsv", "path": "image/rgb_to_hsv", "type": "tf.image", "text": "\nConverts one or more images from RGB to HSV.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.rgb_to_yiq", "path": "image/rgb_to_yiq", "type": "tf.image", "text": "\nConverts one or more images from RGB to YIQ.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.rgb_to_yuv", "path": "image/rgb_to_yuv", "type": "tf.image", "text": "\nConverts one or more images from RGB to YUV.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.rot90", "path": "image/rot90", "type": "tf.image", "text": "\nRotate image(s) counter-clockwise by 90 degrees.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.sample_distorted_bounding_box", "path": "image/sample_distorted_bounding_box", "type": "tf.image", "text": "\nGenerate a single randomly distorted bounding box for an image.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.sobel_edges", "path": "image/sobel_edges", "type": "tf.image", "text": "\nReturns a tensor holding Sobel edge maps.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.ssim", "path": "image/ssim", "type": "tf.image", "text": "\nComputes SSIM index between img1 and img2.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.ssim_multiscale", "path": "image/ssim_multiscale", "type": "tf.image", "text": "\nComputes the MS-SSIM between img1 and img2.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.stateless_random_brightness", "path": "image/stateless_random_brightness", "type": "tf.image", "text": "\nAdjust the brightness of images by a random factor deterministically.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.stateless_random_contrast", "path": "image/stateless_random_contrast", "type": "tf.image", "text": "\nAdjust the contrast of images by a random factor deterministically.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.stateless_random_crop", "path": "image/stateless_random_crop", "type": "tf.image", "text": "\nRandomly crops a tensor to a given size in a deterministic manner.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.stateless_random_flip_left_right", "path": "image/stateless_random_flip_left_right", "type": "tf.image", "text": "\nRandomly flip an image horizontally (left to right) deterministically.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.stateless_random_flip_up_down", "path": "image/stateless_random_flip_up_down", "type": "tf.image", "text": "\nRandomly flip an image vertically (upside down) deterministically.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.stateless_random_hue", "path": "image/stateless_random_hue", "type": "tf.image", "text": "\nAdjust the hue of RGB images by a random factor deterministically.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.stateless_random_jpeg_quality", "path": "image/stateless_random_jpeg_quality", "type": "tf.image", "text": "\nDeterministically radomize jpeg encoding quality for inducing jpeg noise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.stateless_random_saturation", "path": "image/stateless_random_saturation", "type": "tf.image", "text": "\nAdjust the saturation of RGB images by a random factor deterministically.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.stateless_sample_distorted_bounding_box", "path": "image/stateless_sample_distorted_bounding_box", "type": "tf.image", "text": "\nGenerate a randomly distorted bounding box for an image deterministically.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.total_variation", "path": "image/total_variation", "type": "tf.image", "text": "\nCalculate and return the total variation for one or more images.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.transpose", "path": "image/transpose", "type": "tf.image", "text": "\nTranspose image(s) by swapping the height and width dimension.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.yiq_to_rgb", "path": "image/yiq_to_rgb", "type": "tf.image", "text": "\nConverts one or more images from YIQ to RGB.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.image.yuv_to_rgb", "path": "image/yuv_to_rgb", "type": "tf.image", "text": "\nConverts one or more images from YUV to RGB.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.IndexedSlices", "path": "indexedslices", "type": "tf", "text": "\nA sparse representation of a set of tensor slices at given indices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.IndexedSlicesSpec", "path": "indexedslicesspec", "type": "tf", "text": "\nType specification for a `tf.IndexedSlices`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.init_scope", "path": "init_scope", "type": "tf", "text": "\nA context manager that lifts ops out of control-flow scopes and function-\nbuilding graphs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.inside_function", "path": "inside_function", "type": "tf", "text": "\nIndicates whether the caller code is executing inside a `tf.function`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io", "path": "io", "type": "tf.io", "text": "\nPublic API for tf.io namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.decode_and_crop_jpeg", "path": "io/decode_and_crop_jpeg", "type": "tf.io", "text": "\nDecode and Crop a JPEG-encoded image to a uint8 tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.decode_base64", "path": "io/decode_base64", "type": "tf.io", "text": "\nDecode web-safe base64-encoded strings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.decode_bmp", "path": "io/decode_bmp", "type": "tf.io", "text": "\nDecode the first frame of a BMP-encoded image to a uint8 tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.decode_compressed", "path": "io/decode_compressed", "type": "tf.io", "text": "\nDecompress strings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.decode_csv", "path": "io/decode_csv", "type": "tf.io", "text": "\nConvert CSV records to tensors. Each column maps to one tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.decode_gif", "path": "io/decode_gif", "type": "tf.io", "text": "\nDecode the frame(s) of a GIF-encoded image to a uint8 tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.decode_image", "path": "io/decode_image", "type": "tf.io", "text": "\nFunction for `decode_bmp`, `decode_gif`, `decode_jpeg`, and `decode_png`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.decode_jpeg", "path": "io/decode_jpeg", "type": "tf.io", "text": "\nDecode a JPEG-encoded image to a uint8 tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.decode_json_example", "path": "io/decode_json_example", "type": "tf.io", "text": "\nConvert JSON-encoded Example records to binary protocol buffer strings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.decode_png", "path": "io/decode_png", "type": "tf.io", "text": "\nDecode a PNG-encoded image to a uint8 or uint16 tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.decode_proto", "path": "io/decode_proto", "type": "tf.io", "text": "\nThe op extracts fields from a serialized protocol buffers message into\ntensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.decode_raw", "path": "io/decode_raw", "type": "tf.io", "text": "\nConvert raw byte strings into tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.deserialize_many_sparse", "path": "io/deserialize_many_sparse", "type": "tf.io", "text": "\nDeserialize and concatenate `SparseTensors` from a serialized minibatch.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.encode_base64", "path": "io/encode_base64", "type": "tf.io", "text": "\nEncode strings into web-safe base64 format.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.encode_jpeg", "path": "io/encode_jpeg", "type": "tf.io", "text": "\nJPEG-encode an image.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.encode_png", "path": "io/encode_png", "type": "tf.io", "text": "\nPNG-encode an image.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.encode_proto", "path": "io/encode_proto", "type": "tf.io", "text": "\nThe op serializes protobuf messages provided in the input tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.extract_jpeg_shape", "path": "io/extract_jpeg_shape", "type": "tf.io", "text": "\nExtract the shape information of a JPEG-encoded image.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.FixedLenFeature", "path": "io/fixedlenfeature", "type": "tf.io", "text": "\nConfiguration for parsing a fixed-length input feature.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.FixedLenSequenceFeature", "path": "io/fixedlensequencefeature", "type": "tf.io", "text": "\nConfiguration for parsing a variable-length input feature into a `Tensor`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.gfile", "path": "io/gfile", "type": "tf.io", "text": "\nPublic API for tf.io.gfile namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.gfile.copy", "path": "io/gfile/copy", "type": "tf.io", "text": "\nCopies data from `src` to `dst`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.gfile.exists", "path": "io/gfile/exists", "type": "tf.io", "text": "\nDetermines whether a path exists or not.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.gfile.GFile", "path": "io/gfile/gfile", "type": "tf.io", "text": "\nFile I/O wrappers without thread locking.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.gfile.glob", "path": "io/gfile/glob", "type": "tf.io", "text": "\nReturns a list of files that match the given pattern(s).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.gfile.isdir", "path": "io/gfile/isdir", "type": "tf.io", "text": "\nReturns whether the path is a directory or not.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.gfile.listdir", "path": "io/gfile/listdir", "type": "tf.io", "text": "\nReturns a list of entries contained within a directory.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.gfile.makedirs", "path": "io/gfile/makedirs", "type": "tf.io", "text": "\nCreates a directory and all parent/intermediate directories.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.gfile.mkdir", "path": "io/gfile/mkdir", "type": "tf.io", "text": "\nCreates a directory with the name given by `path`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.gfile.remove", "path": "io/gfile/remove", "type": "tf.io", "text": "\nDeletes the path located at 'path'.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.gfile.rename", "path": "io/gfile/rename", "type": "tf.io", "text": "\nRename or move a file / directory.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.gfile.rmtree", "path": "io/gfile/rmtree", "type": "tf.io", "text": "\nDeletes everything under path recursively.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.gfile.stat", "path": "io/gfile/stat", "type": "tf.io", "text": "\nReturns file statistics for a given path.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.gfile.walk", "path": "io/gfile/walk", "type": "tf.io", "text": "\nRecursive directory tree generator for directories.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.is_jpeg", "path": "io/is_jpeg", "type": "tf.io", "text": "\nConvenience function to check if the 'contents' encodes a JPEG image.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.matching_files", "path": "io/matching_files", "type": "tf.io", "text": "\nReturns the set of files matching one or more glob patterns.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.match_filenames_once", "path": "io/match_filenames_once", "type": "tf.io", "text": "\nSave the list of files matching pattern, so it is only computed once.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.parse_example", "path": "io/parse_example", "type": "tf.io", "text": "\nParses `Example` protos into a `dict` of tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.parse_sequence_example", "path": "io/parse_sequence_example", "type": "tf.io", "text": "\nParses a batch of `SequenceExample` protos.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.parse_single_example", "path": "io/parse_single_example", "type": "tf.io", "text": "\nParses a single `Example` proto.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.parse_single_sequence_example", "path": "io/parse_single_sequence_example", "type": "tf.io", "text": "\nParses a single `SequenceExample` proto.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.parse_tensor", "path": "io/parse_tensor", "type": "tf.io", "text": "\nTransforms a serialized tensorflow.TensorProto proto into a Tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.RaggedFeature", "path": "io/raggedfeature", "type": "tf.io", "text": "\nConfiguration for passing a RaggedTensor input feature.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.RaggedFeature.RowLengths", "path": "io/raggedfeature/rowlengths", "type": "tf.io", "text": "\nRowLengths(key,)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.RaggedFeature.RowLimits", "path": "io/raggedfeature/rowlimits", "type": "tf.io", "text": "\nRowLimits(key,)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.RaggedFeature.RowSplits", "path": "io/raggedfeature/rowsplits", "type": "tf.io", "text": "\nRowSplits(key,)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.RaggedFeature.RowStarts", "path": "io/raggedfeature/rowstarts", "type": "tf.io", "text": "\nRowStarts(key,)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.RaggedFeature.UniformRowLength", "path": "io/raggedfeature/uniformrowlength", "type": "tf.io", "text": "\nUniformRowLength(length,)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.RaggedFeature.ValueRowIds", "path": "io/raggedfeature/valuerowids", "type": "tf.io", "text": "\nValueRowIds(key,)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.read_file", "path": "io/read_file", "type": "tf.io", "text": "\nReads and outputs the entire contents of the input filename.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.serialize_many_sparse", "path": "io/serialize_many_sparse", "type": "tf.io", "text": "\nSerialize `N`-minibatch `SparseTensor` into an `[N, 3]` `Tensor`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.serialize_sparse", "path": "io/serialize_sparse", "type": "tf.io", "text": "\nSerialize a `SparseTensor` into a 3-vector (1-D `Tensor`) object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.serialize_tensor", "path": "io/serialize_tensor", "type": "tf.io", "text": "\nTransforms a Tensor into a serialized TensorProto proto.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.SparseFeature", "path": "io/sparsefeature", "type": "tf.io", "text": "\nConfiguration for parsing a sparse input feature from an `Example`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.TFRecordOptions", "path": "io/tfrecordoptions", "type": "tf.io", "text": "\nOptions used for manipulating TFRecord files.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.TFRecordWriter", "path": "io/tfrecordwriter", "type": "tf.io", "text": "\nA class to write records to a TFRecords file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.VarLenFeature", "path": "io/varlenfeature", "type": "tf.io", "text": "\nConfiguration for parsing a variable-length input feature.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.write_file", "path": "io/write_file", "type": "tf.io", "text": "\nWrites contents to the file at input filename. Creates file and recursively\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.io.write_graph", "path": "io/write_graph", "type": "tf.io", "text": "\nWrites a graph proto to a file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.is_tensor", "path": "is_tensor", "type": "tf", "text": "\nChecks whether `x` is a TF-native type that can be passed to many TF ops.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras", "path": "keras", "type": "tf.keras", "text": "\nImplementation of the Keras API meant to be a high-level API for TensorFlow.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.activations", "path": "keras/activations", "type": "tf.keras", "text": "\nBuilt-in activation functions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.activations.deserialize", "path": "keras/activations/deserialize", "type": "tf.keras", "text": "\nReturns activation function given a string identifier.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.activations.elu", "path": "keras/activations/elu", "type": "tf.keras", "text": "\nExponential Linear Unit.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.activations.exponential", "path": "keras/activations/exponential", "type": "tf.keras", "text": "\nExponential activation function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.activations.gelu", "path": "keras/activations/gelu", "type": "tf.keras", "text": "\nApplies the Gaussian error linear unit (GELU) activation function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.activations.get", "path": "keras/activations/get", "type": "tf.keras", "text": "\nReturns function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.activations.hard_sigmoid", "path": "keras/activations/hard_sigmoid", "type": "tf.keras", "text": "\nHard sigmoid activation function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.activations.linear", "path": "keras/activations/linear", "type": "tf.keras", "text": "\nLinear activation function (pass-through).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.activations.relu", "path": "keras/activations/relu", "type": "tf.keras", "text": "\nApplies the rectified linear unit activation function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.activations.selu", "path": "keras/activations/selu", "type": "tf.keras", "text": "\nScaled Exponential Linear Unit (SELU).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.activations.serialize", "path": "keras/activations/serialize", "type": "tf.keras", "text": "\nReturns the string identifier of an activation function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.activations.sigmoid", "path": "keras/activations/sigmoid", "type": "tf.keras", "text": "\nSigmoid activation function, `sigmoid(x) = 1 / (1 + exp(-x))`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.activations.softmax", "path": "keras/activations/softmax", "type": "tf.keras", "text": "\nSoftmax converts a real vector to a vector of categorical probabilities.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.activations.softplus", "path": "keras/activations/softplus", "type": "tf.keras", "text": "\nSoftplus activation function, `softplus(x) = log(exp(x) + 1)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.activations.softsign", "path": "keras/activations/softsign", "type": "tf.keras", "text": "\nSoftsign activation function, `softsign(x) = x / (abs(x) + 1)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.activations.swish", "path": "keras/activations/swish", "type": "tf.keras", "text": "\nSwish activation function, `swish(x) = x * sigmoid(x)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.activations.tanh", "path": "keras/activations/tanh", "type": "tf.keras", "text": "\nHyperbolic tangent activation function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications", "path": "keras/applications", "type": "tf.keras", "text": "\nKeras Applications are canned architectures with pre-trained weights.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.densenet", "path": "keras/applications/densenet", "type": "tf.keras", "text": "\nDenseNet models for Keras.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.densenet.decode_predictions", "path": "keras/applications/densenet/decode_predictions", "type": "tf.keras", "text": "\nDecodes the prediction of an ImageNet model.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.densenet.preprocess_input", "path": "keras/applications/densenet/preprocess_input", "type": "tf.keras", "text": "\nPreprocesses a tensor or Numpy array encoding a batch of images.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.DenseNet121", "path": "keras/applications/densenet121", "type": "tf.keras", "text": "\nInstantiates the Densenet121 architecture.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.DenseNet169", "path": "keras/applications/densenet169", "type": "tf.keras", "text": "\nInstantiates the Densenet169 architecture.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.DenseNet201", "path": "keras/applications/densenet201", "type": "tf.keras", "text": "\nInstantiates the Densenet201 architecture.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.efficientnet", "path": "keras/applications/efficientnet", "type": "tf.keras", "text": "\nEfficientNet models for Keras.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.efficientnet.decode_predictions", "path": "keras/applications/efficientnet/decode_predictions", "type": "tf.keras", "text": "\nDecodes the prediction of an ImageNet model.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.efficientnet.preprocess_input", "path": "keras/applications/efficientnet/preprocess_input", "type": "tf.keras", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.EfficientNetB0", "path": "keras/applications/efficientnetb0", "type": "tf.keras", "text": "\nInstantiates the EfficientNetB0 architecture.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.EfficientNetB1", "path": "keras/applications/efficientnetb1", "type": "tf.keras", "text": "\nInstantiates the EfficientNetB1 architecture.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.EfficientNetB2", "path": "keras/applications/efficientnetb2", "type": "tf.keras", "text": "\nInstantiates the EfficientNetB2 architecture.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.EfficientNetB3", "path": "keras/applications/efficientnetb3", "type": "tf.keras", "text": "\nInstantiates the EfficientNetB3 architecture.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.EfficientNetB4", "path": "keras/applications/efficientnetb4", "type": "tf.keras", "text": "\nInstantiates the EfficientNetB4 architecture.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.EfficientNetB5", "path": "keras/applications/efficientnetb5", "type": "tf.keras", "text": "\nInstantiates the EfficientNetB5 architecture.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.EfficientNetB6", "path": "keras/applications/efficientnetb6", "type": "tf.keras", "text": "\nInstantiates the EfficientNetB6 architecture.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.EfficientNetB7", "path": "keras/applications/efficientnetb7", "type": "tf.keras", "text": "\nInstantiates the EfficientNetB7 architecture.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.imagenet_utils", "path": "keras/applications/imagenet_utils", "type": "tf.keras", "text": "\nUtilities for ImageNet data preprocessing & prediction decoding.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.imagenet_utils.decode_predictions", "path": "keras/applications/imagenet_utils/decode_predictions", "type": "tf.keras", "text": "\nDecodes the prediction of an ImageNet model.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.imagenet_utils.preprocess_input", "path": "keras/applications/imagenet_utils/preprocess_input", "type": "tf.keras", "text": "\nPreprocesses a tensor or Numpy array encoding a batch of images.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.InceptionResNetV2", "path": "keras/applications/inceptionresnetv2", "type": "tf.keras", "text": "\nInstantiates the Inception-ResNet v2 architecture.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.InceptionV3", "path": "keras/applications/inceptionv3", "type": "tf.keras", "text": "\nInstantiates the Inception v3 architecture.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.inception_resnet_v2", "path": "keras/applications/inception_resnet_v2", "type": "tf.keras", "text": "\nInception-ResNet V2 model for Keras.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.inception_resnet_v2.decode_predictions", "path": "keras/applications/inception_resnet_v2/decode_predictions", "type": "tf.keras", "text": "\nDecodes the prediction of an ImageNet model.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.inception_resnet_v2.preprocess_input", "path": "keras/applications/inception_resnet_v2/preprocess_input", "type": "tf.keras", "text": "\nPreprocesses a tensor or Numpy array encoding a batch of images.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.inception_v3", "path": "keras/applications/inception_v3", "type": "tf.keras", "text": "\nInception V3 model for Keras.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.inception_v3.decode_predictions", "path": "keras/applications/inception_v3/decode_predictions", "type": "tf.keras", "text": "\nDecodes the prediction of an ImageNet model.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.inception_v3.preprocess_input", "path": "keras/applications/inception_v3/preprocess_input", "type": "tf.keras", "text": "\nPreprocesses a tensor or Numpy array encoding a batch of images.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.mobilenet", "path": "keras/applications/mobilenet", "type": "tf.keras", "text": "\nMobileNet v1 models for Keras.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.mobilenet.decode_predictions", "path": "keras/applications/mobilenet/decode_predictions", "type": "tf.keras", "text": "\nDecodes the prediction of an ImageNet model.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.mobilenet.preprocess_input", "path": "keras/applications/mobilenet/preprocess_input", "type": "tf.keras", "text": "\nPreprocesses a tensor or Numpy array encoding a batch of images.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.MobileNetV2", "path": "keras/applications/mobilenetv2", "type": "tf.keras", "text": "\nInstantiates the MobileNetV2 architecture.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.MobileNetV3Large", "path": "keras/applications/mobilenetv3large", "type": "tf.keras", "text": "\nInstantiates the MobileNetV3Large architecture.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.MobileNetV3Small", "path": "keras/applications/mobilenetv3small", "type": "tf.keras", "text": "\nInstantiates the MobileNetV3Small architecture.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.mobilenet_v2", "path": "keras/applications/mobilenet_v2", "type": "tf.keras", "text": "\nMobileNet v2 models for Keras.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.mobilenet_v2.decode_predictions", "path": "keras/applications/mobilenet_v2/decode_predictions", "type": "tf.keras", "text": "\nDecodes the prediction of an ImageNet model.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.mobilenet_v2.preprocess_input", "path": "keras/applications/mobilenet_v2/preprocess_input", "type": "tf.keras", "text": "\nPreprocesses a tensor or Numpy array encoding a batch of images.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.mobilenet_v3", "path": "keras/applications/mobilenet_v3", "type": "tf.keras", "text": "\nMobileNet v3 models for Keras.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.mobilenet_v3.decode_predictions", "path": "keras/applications/mobilenet_v3/decode_predictions", "type": "tf.keras", "text": "\nDecodes the prediction of an ImageNet model.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.mobilenet_v3.preprocess_input", "path": "keras/applications/mobilenet_v3/preprocess_input", "type": "tf.keras", "text": "\nPreprocesses a tensor or Numpy array encoding a batch of images.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.nasnet", "path": "keras/applications/nasnet", "type": "tf.keras", "text": "\nNASNet-A models for Keras.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.nasnet.decode_predictions", "path": "keras/applications/nasnet/decode_predictions", "type": "tf.keras", "text": "\nDecodes the prediction of an ImageNet model.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.nasnet.preprocess_input", "path": "keras/applications/nasnet/preprocess_input", "type": "tf.keras", "text": "\nPreprocesses a tensor or Numpy array encoding a batch of images.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.NASNetLarge", "path": "keras/applications/nasnetlarge", "type": "tf.keras", "text": "\nInstantiates a NASNet model in ImageNet mode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.NASNetMobile", "path": "keras/applications/nasnetmobile", "type": "tf.keras", "text": "\nInstantiates a Mobile NASNet model in ImageNet mode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.resnet", "path": "keras/applications/resnet", "type": "tf.keras", "text": "\nResNet models for Keras.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.resnet.decode_predictions", "path": "keras/applications/resnet/decode_predictions", "type": "tf.keras", "text": "\nDecodes the prediction of an ImageNet model.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.resnet.preprocess_input", "path": "keras/applications/resnet/preprocess_input", "type": "tf.keras", "text": "\nPreprocesses a tensor or Numpy array encoding a batch of images.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.ResNet101", "path": "keras/applications/resnet101", "type": "tf.keras", "text": "\nInstantiates the ResNet101 architecture.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.ResNet101V2", "path": "keras/applications/resnet101v2", "type": "tf.keras", "text": "\nInstantiates the ResNet101V2 architecture.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.ResNet152", "path": "keras/applications/resnet152", "type": "tf.keras", "text": "\nInstantiates the ResNet152 architecture.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.ResNet152V2", "path": "keras/applications/resnet152v2", "type": "tf.keras", "text": "\nInstantiates the ResNet152V2 architecture.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.resnet50", "path": "keras/applications/resnet50", "type": "tf.keras", "text": "\nPublic API for tf.keras.applications.resnet50 namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.ResNet50V2", "path": "keras/applications/resnet50v2", "type": "tf.keras", "text": "\nInstantiates the ResNet50V2 architecture.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.resnet_v2", "path": "keras/applications/resnet_v2", "type": "tf.keras", "text": "\nResNet v2 models for Keras.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.resnet_v2.decode_predictions", "path": "keras/applications/resnet_v2/decode_predictions", "type": "tf.keras", "text": "\nDecodes the prediction of an ImageNet model.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.resnet_v2.preprocess_input", "path": "keras/applications/resnet_v2/preprocess_input", "type": "tf.keras", "text": "\nPreprocesses a tensor or Numpy array encoding a batch of images.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.vgg16", "path": "keras/applications/vgg16", "type": "tf.keras", "text": "\nVGG16 model for Keras.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.vgg16.decode_predictions", "path": "keras/applications/vgg16/decode_predictions", "type": "tf.keras", "text": "\nDecodes the prediction of an ImageNet model.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.vgg16.preprocess_input", "path": "keras/applications/vgg16/preprocess_input", "type": "tf.keras", "text": "\nPreprocesses a tensor or Numpy array encoding a batch of images.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.vgg19", "path": "keras/applications/vgg19", "type": "tf.keras", "text": "\nVGG19 model for Keras.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.vgg19.decode_predictions", "path": "keras/applications/vgg19/decode_predictions", "type": "tf.keras", "text": "\nDecodes the prediction of an ImageNet model.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.vgg19.preprocess_input", "path": "keras/applications/vgg19/preprocess_input", "type": "tf.keras", "text": "\nPreprocesses a tensor or Numpy array encoding a batch of images.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.xception", "path": "keras/applications/xception", "type": "tf.keras", "text": "\nXception V1 model for Keras.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.xception.decode_predictions", "path": "keras/applications/xception/decode_predictions", "type": "tf.keras", "text": "\nDecodes the prediction of an ImageNet model.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.applications.xception.preprocess_input", "path": "keras/applications/xception/preprocess_input", "type": "tf.keras", "text": "\nPreprocesses a tensor or Numpy array encoding a batch of images.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.backend", "path": "keras/backend", "type": "tf.keras", "text": "\nKeras backend API.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.backend.clear_session", "path": "keras/backend/clear_session", "type": "tf.keras", "text": "\nResets all state generated by Keras.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.backend.epsilon", "path": "keras/backend/epsilon", "type": "tf.keras", "text": "\nReturns the value of the fuzz factor used in numeric expressions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.backend.floatx", "path": "keras/backend/floatx", "type": "tf.keras", "text": "\nReturns the default float type, as a string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.backend.get_uid", "path": "keras/backend/get_uid", "type": "tf.keras", "text": "\nAssociates a string prefix with an integer counter in a TensorFlow graph.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.backend.image_data_format", "path": "keras/backend/image_data_format", "type": "tf.keras", "text": "\nReturns the default image data format convention.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.backend.is_keras_tensor", "path": "keras/backend/is_keras_tensor", "type": "tf.keras", "text": "\nReturns whether `x` is a Keras tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.backend.reset_uids", "path": "keras/backend/reset_uids", "type": "tf.keras", "text": "\nResets graph identifiers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.backend.rnn", "path": "keras/backend/rnn", "type": "tf.keras", "text": "\nIterates over the time dimension of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.backend.set_epsilon", "path": "keras/backend/set_epsilon", "type": "tf.keras", "text": "\nSets the value of the fuzz factor used in numeric expressions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.backend.set_floatx", "path": "keras/backend/set_floatx", "type": "tf.keras", "text": "\nSets the default float type.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.backend.set_image_data_format", "path": "keras/backend/set_image_data_format", "type": "tf.keras", "text": "\nSets the value of the image data format convention.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.callbacks", "path": "keras/callbacks", "type": "tf.keras", "text": "\nCallbacks: utilities called at certain points during model training.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.callbacks.BaseLogger", "path": "keras/callbacks/baselogger", "type": "tf.keras", "text": "\nCallback that accumulates epoch averages of metrics.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.callbacks.Callback", "path": "keras/callbacks/callback", "type": "tf.keras", "text": "\nAbstract base class used to build new callbacks.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.callbacks.CallbackList", "path": "keras/callbacks/callbacklist", "type": "tf.keras", "text": "\nContainer abstracting a list of callbacks.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.callbacks.CSVLogger", "path": "keras/callbacks/csvlogger", "type": "tf.keras", "text": "\nCallback that streams epoch results to a CSV file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.callbacks.EarlyStopping", "path": "keras/callbacks/earlystopping", "type": "tf.keras", "text": "\nStop training when a monitored metric has stopped improving.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.callbacks.experimental", "path": "keras/callbacks/experimental", "type": "tf.keras", "text": "\nPublic API for tf.keras.callbacks.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.callbacks.experimental.BackupAndRestore", "path": "keras/callbacks/experimental/backupandrestore", "type": "tf.keras", "text": "\nCallback to back up and restore the training state.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.callbacks.History", "path": "keras/callbacks/history", "type": "tf.keras", "text": "\nCallback that records events into a `History` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.callbacks.LambdaCallback", "path": "keras/callbacks/lambdacallback", "type": "tf.keras", "text": "\nCallback for creating simple, custom callbacks on-the-fly.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.callbacks.LearningRateScheduler", "path": "keras/callbacks/learningratescheduler", "type": "tf.keras", "text": "\nLearning rate scheduler.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.callbacks.ModelCheckpoint", "path": "keras/callbacks/modelcheckpoint", "type": "tf.keras", "text": "\nCallback to save the Keras model or model weights at some frequency.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.callbacks.ProgbarLogger", "path": "keras/callbacks/progbarlogger", "type": "tf.keras", "text": "\nCallback that prints metrics to stdout.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.callbacks.ReduceLROnPlateau", "path": "keras/callbacks/reducelronplateau", "type": "tf.keras", "text": "\nReduce learning rate when a metric has stopped improving.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.callbacks.RemoteMonitor", "path": "keras/callbacks/remotemonitor", "type": "tf.keras", "text": "\nCallback used to stream events to a server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.callbacks.TensorBoard", "path": "keras/callbacks/tensorboard", "type": "tf.keras", "text": "\nEnable visualizations for TensorBoard.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.callbacks.TerminateOnNaN", "path": "keras/callbacks/terminateonnan", "type": "tf.keras", "text": "\nCallback that terminates training when a NaN loss is encountered.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.constraints", "path": "keras/constraints", "type": "tf.keras", "text": "\nConstraints: functions that impose constraints on weight values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.constraints.Constraint", "path": "keras/constraints/constraint", "type": "tf.keras", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.constraints.deserialize", "path": "keras/constraints/deserialize", "type": "tf.keras", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.constraints.get", "path": "keras/constraints/get", "type": "tf.keras", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.constraints.MaxNorm", "path": "keras/constraints/maxnorm", "type": "tf.keras", "text": "\nMaxNorm weight constraint.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.constraints.MinMaxNorm", "path": "keras/constraints/minmaxnorm", "type": "tf.keras", "text": "\nMinMaxNorm weight constraint.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.constraints.NonNeg", "path": "keras/constraints/nonneg", "type": "tf.keras", "text": "\nConstrains the weights to be non-negative.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.constraints.RadialConstraint", "path": "keras/constraints/radialconstraint", "type": "tf.keras", "text": "\nConstrains `Conv2D` kernel weights to be the same for each radius.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.constraints.serialize", "path": "keras/constraints/serialize", "type": "tf.keras", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.constraints.UnitNorm", "path": "keras/constraints/unitnorm", "type": "tf.keras", "text": "\nConstrains the weights incident to each hidden unit to have unit norm.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.datasets", "path": "keras/datasets", "type": "tf.keras", "text": "\nPublic API for tf.keras.datasets namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.datasets.boston_housing", "path": "keras/datasets/boston_housing", "type": "tf.keras", "text": "\nBoston housing price regression dataset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.datasets.boston_housing.load_data", "path": "keras/datasets/boston_housing/load_data", "type": "tf.keras", "text": "\nLoads the Boston Housing dataset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.datasets.cifar10", "path": "keras/datasets/cifar10", "type": "tf.keras", "text": "\nCIFAR10 small images classification dataset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.datasets.cifar10.load_data", "path": "keras/datasets/cifar10/load_data", "type": "tf.keras", "text": "\nLoads CIFAR10 dataset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.datasets.cifar100", "path": "keras/datasets/cifar100", "type": "tf.keras", "text": "\nCIFAR100 small images classification dataset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.datasets.cifar100.load_data", "path": "keras/datasets/cifar100/load_data", "type": "tf.keras", "text": "\nLoads CIFAR100 dataset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.datasets.fashion_mnist", "path": "keras/datasets/fashion_mnist", "type": "tf.keras", "text": "\nFashion-MNIST dataset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.datasets.fashion_mnist.load_data", "path": "keras/datasets/fashion_mnist/load_data", "type": "tf.keras", "text": "\nLoads the Fashion-MNIST dataset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.datasets.imdb", "path": "keras/datasets/imdb", "type": "tf.keras", "text": "\nIMDB sentiment classification dataset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.datasets.imdb.get_word_index", "path": "keras/datasets/imdb/get_word_index", "type": "tf.keras", "text": "\nRetrieves a dict mapping words to their index in the IMDB dataset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.datasets.imdb.load_data", "path": "keras/datasets/imdb/load_data", "type": "tf.keras", "text": "\nLoads the IMDB dataset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.datasets.mnist", "path": "keras/datasets/mnist", "type": "tf.keras", "text": "\nMNIST handwritten digits dataset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.datasets.mnist.load_data", "path": "keras/datasets/mnist/load_data", "type": "tf.keras", "text": "\nLoads the MNIST dataset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.datasets.reuters", "path": "keras/datasets/reuters", "type": "tf.keras", "text": "\nReuters topic classification dataset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.datasets.reuters.get_word_index", "path": "keras/datasets/reuters/get_word_index", "type": "tf.keras", "text": "\nRetrieves a dict mapping words to their index in the Reuters dataset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.datasets.reuters.load_data", "path": "keras/datasets/reuters/load_data", "type": "tf.keras", "text": "\nLoads the Reuters newswire classification dataset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.estimator", "path": "keras/estimator", "type": "tf.keras", "text": "\nKeras estimator API.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.estimator.model_to_estimator", "path": "keras/estimator/model_to_estimator", "type": "tf.keras", "text": "\nConstructs an `Estimator` instance from given keras model.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.experimental", "path": "keras/experimental", "type": "tf.keras", "text": "\nPublic API for tf.keras.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.experimental.CosineDecay", "path": "keras/experimental/cosinedecay", "type": "tf.keras", "text": "\nA LearningRateSchedule that uses a cosine decay schedule.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.experimental.CosineDecayRestarts", "path": "keras/experimental/cosinedecayrestarts", "type": "tf.keras", "text": "\nA LearningRateSchedule that uses a cosine decay schedule with restarts.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.experimental.LinearCosineDecay", "path": "keras/experimental/linearcosinedecay", "type": "tf.keras", "text": "\nA LearningRateSchedule that uses a linear cosine decay schedule.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.experimental.LinearModel", "path": "keras/experimental/linearmodel", "type": "tf.keras", "text": "\nLinear Model for regression and classification problems.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.experimental.NoisyLinearCosineDecay", "path": "keras/experimental/noisylinearcosinedecay", "type": "tf.keras", "text": "\nA LearningRateSchedule that uses a noisy linear cosine decay schedule.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.experimental.PeepholeLSTMCell", "path": "keras/experimental/peepholelstmcell", "type": "tf.keras", "text": "\nEquivalent to LSTMCell class but adds peephole connections.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.experimental.SequenceFeatures", "path": "keras/experimental/sequencefeatures", "type": "tf.keras", "text": "\nA layer for sequence input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.experimental.WideDeepModel", "path": "keras/experimental/widedeepmodel", "type": "tf.keras", "text": "\nWide & Deep Model for regression and classification problems.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.initializers", "path": "keras/initializers", "type": "tf.keras", "text": "\nKeras initializer serialization / deserialization.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.initializers.Constant", "path": "keras/initializers/constant", "type": "tf.keras", "text": "\nInitializer that generates tensors with constant values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.initializers.deserialize", "path": "keras/initializers/deserialize", "type": "tf.keras", "text": "\nReturn an `Initializer` object from its config.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.initializers.get", "path": "keras/initializers/get", "type": "tf.keras", "text": "\nMain aliases\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.initializers.GlorotNormal", "path": "keras/initializers/glorotnormal", "type": "tf.keras", "text": "\nThe Glorot normal initializer, also called Xavier normal initializer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.initializers.GlorotUniform", "path": "keras/initializers/glorotuniform", "type": "tf.keras", "text": "\nThe Glorot uniform initializer, also called Xavier uniform initializer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.initializers.HeNormal", "path": "keras/initializers/henormal", "type": "tf.keras", "text": "\nHe normal initializer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.initializers.HeUniform", "path": "keras/initializers/heuniform", "type": "tf.keras", "text": "\nHe uniform variance scaling initializer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.initializers.Identity", "path": "keras/initializers/identity", "type": "tf.keras", "text": "\nInitializer that generates the identity matrix.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.initializers.Initializer", "path": "keras/initializers/initializer", "type": "tf.keras", "text": "\nInitializer base class: all Keras initializers inherit from this class.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.initializers.LecunNormal", "path": "keras/initializers/lecunnormal", "type": "tf.keras", "text": "\nLecun normal initializer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.initializers.LecunUniform", "path": "keras/initializers/lecununiform", "type": "tf.keras", "text": "\nLecun uniform initializer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.initializers.Ones", "path": "keras/initializers/ones", "type": "tf.keras", "text": "\nInitializer that generates tensors initialized to 1.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.initializers.Orthogonal", "path": "keras/initializers/orthogonal", "type": "tf.keras", "text": "\nInitializer that generates an orthogonal matrix.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.initializers.RandomNormal", "path": "keras/initializers/randomnormal", "type": "tf.keras", "text": "\nInitializer that generates tensors with a normal distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.initializers.RandomUniform", "path": "keras/initializers/randomuniform", "type": "tf.keras", "text": "\nInitializer that generates tensors with a uniform distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.initializers.serialize", "path": "keras/initializers/serialize", "type": "tf.keras", "text": "\nMain aliases\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.initializers.TruncatedNormal", "path": "keras/initializers/truncatednormal", "type": "tf.keras", "text": "\nInitializer that generates a truncated normal distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.initializers.VarianceScaling", "path": "keras/initializers/variancescaling", "type": "tf.keras", "text": "\nInitializer capable of adapting its scale to the shape of weights tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.initializers.Zeros", "path": "keras/initializers/zeros", "type": "tf.keras", "text": "\nInitializer that generates tensors initialized to 0.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.Input", "path": "keras/input", "type": "tf.keras", "text": "\n`Input()` is used to instantiate a Keras tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers", "path": "keras/layers", "type": "tf.keras", "text": "\nKeras layers API.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.AbstractRNNCell", "path": "keras/layers/abstractrnncell", "type": "tf.keras", "text": "\nAbstract object representing an RNN cell.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.Activation", "path": "keras/layers/activation", "type": "tf.keras", "text": "\nApplies an activation function to an output.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.ActivityRegularization", "path": "keras/layers/activityregularization", "type": "tf.keras", "text": "\nLayer that applies an update to the cost function based input activity.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.Add", "path": "keras/layers/add", "type": "tf.keras", "text": "\nLayer that adds a list of inputs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.AdditiveAttention", "path": "keras/layers/additiveattention", "type": "tf.keras", "text": "\nAdditive attention layer, a.k.a. Bahdanau-style attention.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.AlphaDropout", "path": "keras/layers/alphadropout", "type": "tf.keras", "text": "\nApplies Alpha Dropout to the input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.Attention", "path": "keras/layers/attention", "type": "tf.keras", "text": "\nDot-product attention layer, a.k.a. Luong-style attention.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.Average", "path": "keras/layers/average", "type": "tf.keras", "text": "\nLayer that averages a list of inputs element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.AveragePooling1D", "path": "keras/layers/averagepooling1d", "type": "tf.keras", "text": "\nAverage pooling for temporal data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.AveragePooling2D", "path": "keras/layers/averagepooling2d", "type": "tf.keras", "text": "\nAverage pooling operation for spatial data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.AveragePooling3D", "path": "keras/layers/averagepooling3d", "type": "tf.keras", "text": "\nAverage pooling operation for 3D data (spatial or spatio-temporal).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.BatchNormalization", "path": "keras/layers/batchnormalization", "type": "tf.keras", "text": "\nLayer that normalizes its inputs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.Bidirectional", "path": "keras/layers/bidirectional", "type": "tf.keras", "text": "\nBidirectional wrapper for RNNs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.Concatenate", "path": "keras/layers/concatenate", "type": "tf.keras", "text": "\nLayer that concatenates a list of inputs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.Conv1D", "path": "keras/layers/conv1d", "type": "tf.keras", "text": "\n1D convolution layer (e.g. temporal convolution).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.Conv1DTranspose", "path": "keras/layers/conv1dtranspose", "type": "tf.keras", "text": "\nTransposed convolution layer (sometimes called Deconvolution).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.Conv2D", "path": "keras/layers/conv2d", "type": "tf.keras", "text": "\n2D convolution layer (e.g. spatial convolution over images).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.Conv2DTranspose", "path": "keras/layers/conv2dtranspose", "type": "tf.keras", "text": "\nTransposed convolution layer (sometimes called Deconvolution).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.Conv3D", "path": "keras/layers/conv3d", "type": "tf.keras", "text": "\n3D convolution layer (e.g. spatial convolution over volumes).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.Conv3DTranspose", "path": "keras/layers/conv3dtranspose", "type": "tf.keras", "text": "\nTransposed convolution layer (sometimes called Deconvolution).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.ConvLSTM2D", "path": "keras/layers/convlstm2d", "type": "tf.keras", "text": "\nConvolutional LSTM.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.Cropping1D", "path": "keras/layers/cropping1d", "type": "tf.keras", "text": "\nCropping layer for 1D input (e.g. temporal sequence).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.Cropping2D", "path": "keras/layers/cropping2d", "type": "tf.keras", "text": "\nCropping layer for 2D input (e.g. picture).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.Cropping3D", "path": "keras/layers/cropping3d", "type": "tf.keras", "text": "\nCropping layer for 3D data (e.g. spatial or spatio-temporal).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.Dense", "path": "keras/layers/dense", "type": "tf.keras", "text": "\nJust your regular densely-connected NN layer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.DenseFeatures", "path": "keras/layers/densefeatures", "type": "tf.keras", "text": "\nA layer that produces a dense `Tensor` based on given `feature_columns`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.DepthwiseConv2D", "path": "keras/layers/depthwiseconv2d", "type": "tf.keras", "text": "\nDepthwise separable 2D convolution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.deserialize", "path": "keras/layers/deserialize", "type": "tf.keras", "text": "\nInstantiates a layer from a config dictionary.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.Dot", "path": "keras/layers/dot", "type": "tf.keras", "text": "\nLayer that computes a dot product between samples in two tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.Dropout", "path": "keras/layers/dropout", "type": "tf.keras", "text": "\nApplies Dropout to the input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.ELU", "path": "keras/layers/elu", "type": "tf.keras", "text": "\nExponential Linear Unit.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.Embedding", "path": "keras/layers/embedding", "type": "tf.keras", "text": "\nTurns positive integers (indexes) into dense vectors of fixed size.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.experimental", "path": "keras/layers/experimental", "type": "tf.keras", "text": "\nPublic API for tf.keras.layers.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.experimental.EinsumDense", "path": "keras/layers/experimental/einsumdense", "type": "tf.keras", "text": "\nA layer that uses tf.einsum as the backing computation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.experimental.preprocessing", "path": "keras/layers/experimental/preprocessing", "type": "tf.keras", "text": "\nPublic API for tf.keras.layers.experimental.preprocessing namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.experimental.preprocessing.CategoryCrossing", "path": "keras/layers/experimental/preprocessing/categorycrossing", "type": "tf.keras", "text": "\nCategory crossing layer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.experimental.preprocessing.CategoryEncoding", "path": "keras/layers/experimental/preprocessing/categoryencoding", "type": "tf.keras", "text": "\nCategory encoding layer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.experimental.preprocessing.CenterCrop", "path": "keras/layers/experimental/preprocessing/centercrop", "type": "tf.keras", "text": "\nCrop the central portion of the images to target height and width.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.experimental.preprocessing.Discretization", "path": "keras/layers/experimental/preprocessing/discretization", "type": "tf.keras", "text": "\nBuckets data into discrete ranges.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.experimental.preprocessing.Hashing", "path": "keras/layers/experimental/preprocessing/hashing", "type": "tf.keras", "text": "\nImplements categorical feature hashing, also known as \"hashing trick\".\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.experimental.preprocessing.IntegerLookup", "path": "keras/layers/experimental/preprocessing/integerlookup", "type": "tf.keras", "text": "\nMaps integers from a vocabulary to integer indices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.experimental.preprocessing.Normalization", "path": "keras/layers/experimental/preprocessing/normalization", "type": "tf.keras", "text": "\nFeature-wise normalization of the data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.experimental.preprocessing.PreprocessingLayer", "path": "keras/layers/experimental/preprocessing/preprocessinglayer", "type": "tf.keras", "text": "\nBase class for PreprocessingLayers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.experimental.preprocessing.RandomContrast", "path": "keras/layers/experimental/preprocessing/randomcontrast", "type": "tf.keras", "text": "\nAdjust the contrast of an image or images by a random factor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.experimental.preprocessing.RandomCrop", "path": "keras/layers/experimental/preprocessing/randomcrop", "type": "tf.keras", "text": "\nRandomly crop the images to target height and width.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.experimental.preprocessing.RandomFlip", "path": "keras/layers/experimental/preprocessing/randomflip", "type": "tf.keras", "text": "\nRandomly flip each image horizontally and vertically.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.experimental.preprocessing.RandomHeight", "path": "keras/layers/experimental/preprocessing/randomheight", "type": "tf.keras", "text": "\nRandomly vary the height of a batch of images during training.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.experimental.preprocessing.RandomRotation", "path": "keras/layers/experimental/preprocessing/randomrotation", "type": "tf.keras", "text": "\nRandomly rotate each image.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.experimental.preprocessing.RandomTranslation", "path": "keras/layers/experimental/preprocessing/randomtranslation", "type": "tf.keras", "text": "\nRandomly translate each image during training.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.experimental.preprocessing.RandomWidth", "path": "keras/layers/experimental/preprocessing/randomwidth", "type": "tf.keras", "text": "\nRandomly vary the width of a batch of images during training.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.experimental.preprocessing.RandomZoom", "path": "keras/layers/experimental/preprocessing/randomzoom", "type": "tf.keras", "text": "\nRandomly zoom each image during training.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.experimental.preprocessing.Rescaling", "path": "keras/layers/experimental/preprocessing/rescaling", "type": "tf.keras", "text": "\nMultiply inputs by `scale` and adds `offset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.experimental.preprocessing.Resizing", "path": "keras/layers/experimental/preprocessing/resizing", "type": "tf.keras", "text": "\nImage resizing layer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.experimental.preprocessing.StringLookup", "path": "keras/layers/experimental/preprocessing/stringlookup", "type": "tf.keras", "text": "\nMaps strings from a vocabulary to integer indices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.experimental.preprocessing.TextVectorization", "path": "keras/layers/experimental/preprocessing/textvectorization", "type": "tf.keras", "text": "\nText vectorization layer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.experimental.RandomFourierFeatures", "path": "keras/layers/experimental/randomfourierfeatures", "type": "tf.keras", "text": "\nLayer that projects its inputs into a random feature space.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.experimental.SyncBatchNormalization", "path": "keras/layers/experimental/syncbatchnormalization", "type": "tf.keras", "text": "\nNormalize and scale inputs or activations synchronously across replicas.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.Flatten", "path": "keras/layers/flatten", "type": "tf.keras", "text": "\nFlattens the input. Does not affect the batch size.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.GaussianDropout", "path": "keras/layers/gaussiandropout", "type": "tf.keras", "text": "\nApply multiplicative 1-centered Gaussian noise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.GaussianNoise", "path": "keras/layers/gaussiannoise", "type": "tf.keras", "text": "\nApply additive zero-centered Gaussian noise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.GlobalAveragePooling1D", "path": "keras/layers/globalaveragepooling1d", "type": "tf.keras", "text": "\nGlobal average pooling operation for temporal data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.GlobalAveragePooling2D", "path": "keras/layers/globalaveragepooling2d", "type": "tf.keras", "text": "\nGlobal average pooling operation for spatial data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.GlobalAveragePooling3D", "path": "keras/layers/globalaveragepooling3d", "type": "tf.keras", "text": "\nGlobal Average pooling operation for 3D data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.GlobalMaxPool1D", "path": "keras/layers/globalmaxpool1d", "type": "tf.keras", "text": "\nGlobal max pooling operation for 1D temporal data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.GlobalMaxPool2D", "path": "keras/layers/globalmaxpool2d", "type": "tf.keras", "text": "\nGlobal max pooling operation for spatial data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.GlobalMaxPool3D", "path": "keras/layers/globalmaxpool3d", "type": "tf.keras", "text": "\nGlobal Max pooling operation for 3D data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.GRU", "path": "keras/layers/gru", "type": "tf.keras", "text": "\nGated Recurrent Unit - Cho et al. 2014.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.GRUCell", "path": "keras/layers/grucell", "type": "tf.keras", "text": "\nCell class for the GRU layer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.InputLayer", "path": "keras/layers/inputlayer", "type": "tf.keras", "text": "\nLayer to be used as an entry point into a Network (a graph of layers).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.InputSpec", "path": "keras/layers/inputspec", "type": "tf.keras", "text": "\nSpecifies the rank, dtype and shape of every input to a layer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.Lambda", "path": "keras/layers/lambda", "type": "tf.keras", "text": "\nWraps arbitrary expressions as a `Layer` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.Layer", "path": "keras/layers/layer", "type": "tf.keras", "text": "\nThis is the class from which all layers inherit.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.LayerNormalization", "path": "keras/layers/layernormalization", "type": "tf.keras", "text": "\nLayer normalization layer (Ba et al., 2016).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.LeakyReLU", "path": "keras/layers/leakyrelu", "type": "tf.keras", "text": "\nLeaky version of a Rectified Linear Unit.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.LocallyConnected1D", "path": "keras/layers/locallyconnected1d", "type": "tf.keras", "text": "\nLocally-connected layer for 1D inputs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.LocallyConnected2D", "path": "keras/layers/locallyconnected2d", "type": "tf.keras", "text": "\nLocally-connected layer for 2D inputs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.LSTM", "path": "keras/layers/lstm", "type": "tf.keras", "text": "\nLong Short-Term Memory layer - Hochreiter 1997.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.LSTMCell", "path": "keras/layers/lstmcell", "type": "tf.keras", "text": "\nCell class for the LSTM layer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.Masking", "path": "keras/layers/masking", "type": "tf.keras", "text": "\nMasks a sequence by using a mask value to skip timesteps.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.Maximum", "path": "keras/layers/maximum", "type": "tf.keras", "text": "\nLayer that computes the maximum (element-wise) a list of inputs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.MaxPool1D", "path": "keras/layers/maxpool1d", "type": "tf.keras", "text": "\nMax pooling operation for 1D temporal data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.MaxPool2D", "path": "keras/layers/maxpool2d", "type": "tf.keras", "text": "\nMax pooling operation for 2D spatial data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.MaxPool3D", "path": "keras/layers/maxpool3d", "type": "tf.keras", "text": "\nMax pooling operation for 3D data (spatial or spatio-temporal).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.Minimum", "path": "keras/layers/minimum", "type": "tf.keras", "text": "\nLayer that computes the minimum (element-wise) a list of inputs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.MultiHeadAttention", "path": "keras/layers/multiheadattention", "type": "tf.keras", "text": "\nMultiHeadAttention layer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.Multiply", "path": "keras/layers/multiply", "type": "tf.keras", "text": "\nLayer that multiplies (element-wise) a list of inputs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.Permute", "path": "keras/layers/permute", "type": "tf.keras", "text": "\nPermutes the dimensions of the input according to a given pattern.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.PReLU", "path": "keras/layers/prelu", "type": "tf.keras", "text": "\nParametric Rectified Linear Unit.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.ReLU", "path": "keras/layers/relu", "type": "tf.keras", "text": "\nRectified Linear Unit activation function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.RepeatVector", "path": "keras/layers/repeatvector", "type": "tf.keras", "text": "\nRepeats the input n times.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.Reshape", "path": "keras/layers/reshape", "type": "tf.keras", "text": "\nLayer that reshapes inputs into the given shape.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.RNN", "path": "keras/layers/rnn", "type": "tf.keras", "text": "\nBase class for recurrent layers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.SeparableConv1D", "path": "keras/layers/separableconv1d", "type": "tf.keras", "text": "\nDepthwise separable 1D convolution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.SeparableConv2D", "path": "keras/layers/separableconv2d", "type": "tf.keras", "text": "\nDepthwise separable 2D convolution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.serialize", "path": "keras/layers/serialize", "type": "tf.keras", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.SimpleRNN", "path": "keras/layers/simplernn", "type": "tf.keras", "text": "\nFully-connected RNN where the output is to be fed back to input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.SimpleRNNCell", "path": "keras/layers/simplernncell", "type": "tf.keras", "text": "\nCell class for SimpleRNN.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.Softmax", "path": "keras/layers/softmax", "type": "tf.keras", "text": "\nSoftmax activation function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.SpatialDropout1D", "path": "keras/layers/spatialdropout1d", "type": "tf.keras", "text": "\nSpatial 1D version of Dropout.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.SpatialDropout2D", "path": "keras/layers/spatialdropout2d", "type": "tf.keras", "text": "\nSpatial 2D version of Dropout.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.SpatialDropout3D", "path": "keras/layers/spatialdropout3d", "type": "tf.keras", "text": "\nSpatial 3D version of Dropout.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.StackedRNNCells", "path": "keras/layers/stackedrnncells", "type": "tf.keras", "text": "\nWrapper allowing a stack of RNN cells to behave as a single cell.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.Subtract", "path": "keras/layers/subtract", "type": "tf.keras", "text": "\nLayer that subtracts two inputs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.ThresholdedReLU", "path": "keras/layers/thresholdedrelu", "type": "tf.keras", "text": "\nThresholded Rectified Linear Unit.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.TimeDistributed", "path": "keras/layers/timedistributed", "type": "tf.keras", "text": "\nThis wrapper allows to apply a layer to every temporal slice of an input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.UpSampling1D", "path": "keras/layers/upsampling1d", "type": "tf.keras", "text": "\nUpsampling layer for 1D inputs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.UpSampling2D", "path": "keras/layers/upsampling2d", "type": "tf.keras", "text": "\nUpsampling layer for 2D inputs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.UpSampling3D", "path": "keras/layers/upsampling3d", "type": "tf.keras", "text": "\nUpsampling layer for 3D inputs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.Wrapper", "path": "keras/layers/wrapper", "type": "tf.keras", "text": "\nAbstract wrapper base class.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.ZeroPadding1D", "path": "keras/layers/zeropadding1d", "type": "tf.keras", "text": "\nZero-padding layer for 1D input (e.g. temporal sequence).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.ZeroPadding2D", "path": "keras/layers/zeropadding2d", "type": "tf.keras", "text": "\nZero-padding layer for 2D input (e.g. picture).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.layers.ZeroPadding3D", "path": "keras/layers/zeropadding3d", "type": "tf.keras", "text": "\nZero-padding layer for 3D data (spatial or spatio-temporal).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.losses", "path": "keras/losses", "type": "tf.keras", "text": "\nBuilt-in loss functions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.losses.BinaryCrossentropy", "path": "keras/losses/binarycrossentropy", "type": "tf.keras", "text": "\nComputes the cross-entropy loss between true labels and predicted labels.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.losses.binary_crossentropy", "path": "keras/losses/binary_crossentropy", "type": "tf.keras", "text": "\nComputes the binary crossentropy loss.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.losses.CategoricalCrossentropy", "path": "keras/losses/categoricalcrossentropy", "type": "tf.keras", "text": "\nComputes the crossentropy loss between the labels and predictions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.losses.CategoricalHinge", "path": "keras/losses/categoricalhinge", "type": "tf.keras", "text": "\nComputes the categorical hinge loss between `y_true` and `y_pred`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.losses.categorical_crossentropy", "path": "keras/losses/categorical_crossentropy", "type": "tf.keras", "text": "\nComputes the categorical crossentropy loss.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.losses.categorical_hinge", "path": "keras/losses/categorical_hinge", "type": "tf.keras", "text": "\nComputes the categorical hinge loss between `y_true` and `y_pred`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.losses.CosineSimilarity", "path": "keras/losses/cosinesimilarity", "type": "tf.keras", "text": "\nComputes the cosine similarity between labels and predictions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.losses.cosine_similarity", "path": "keras/losses/cosine_similarity", "type": "tf.keras", "text": "\nComputes the cosine similarity between labels and predictions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.losses.deserialize", "path": "keras/losses/deserialize", "type": "tf.keras", "text": "\nDeserializes a serialized loss class/function instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.losses.get", "path": "keras/losses/get", "type": "tf.keras", "text": "\nRetrieves a Keras loss as a `function`/`Loss` class instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.losses.Hinge", "path": "keras/losses/hinge", "type": "tf.keras", "text": "\nComputes the hinge loss between `y_true` and `y_pred`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.losses.Huber", "path": "keras/losses/huber", "type": "tf.keras", "text": "\nComputes the Huber loss between `y_true` and `y_pred`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.losses.KLD", "path": "keras/losses/kld", "type": "tf.keras", "text": "\nComputes Kullback-Leibler divergence loss between `y_true` and `y_pred`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.losses.KLDivergence", "path": "keras/losses/kldivergence", "type": "tf.keras", "text": "\nComputes Kullback-Leibler divergence loss between `y_true` and `y_pred`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.losses.LogCosh", "path": "keras/losses/logcosh", "type": "tf.keras", "text": "\nComputes the logarithm of the hyperbolic cosine of the prediction error.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.losses.log_cosh", "path": "keras/losses/log_cosh", "type": "tf.keras", "text": "\nLogarithm of the hyperbolic cosine of the prediction error.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.losses.Loss", "path": "keras/losses/loss", "type": "tf.keras", "text": "\nLoss base class.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.losses.MAE", "path": "keras/losses/mae", "type": "tf.keras", "text": "\nComputes the mean absolute error between labels and predictions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.losses.MAPE", "path": "keras/losses/mape", "type": "tf.keras", "text": "\nComputes the mean absolute percentage error between `y_true` and `y_pred`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.losses.MeanAbsoluteError", "path": "keras/losses/meanabsoluteerror", "type": "tf.keras", "text": "\nComputes the mean of absolute difference between labels and predictions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.losses.MeanAbsolutePercentageError", "path": "keras/losses/meanabsolutepercentageerror", "type": "tf.keras", "text": "\nComputes the mean absolute percentage error between `y_true` and `y_pred`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.losses.MeanSquaredError", "path": "keras/losses/meansquarederror", "type": "tf.keras", "text": "\nComputes the mean of squares of errors between labels and predictions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.losses.MeanSquaredLogarithmicError", "path": "keras/losses/meansquaredlogarithmicerror", "type": "tf.keras", "text": "\nComputes the mean squared logarithmic error between `y_true` and `y_pred`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.losses.MSE", "path": "keras/losses/mse", "type": "tf.keras", "text": "\nComputes the mean squared error between labels and predictions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.losses.MSLE", "path": "keras/losses/msle", "type": "tf.keras", "text": "\nComputes the mean squared logarithmic error between `y_true` and `y_pred`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.losses.Poisson", "path": "keras/losses/poisson", "type": "tf.keras", "text": "\nComputes the Poisson loss between `y_true` and `y_pred`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.losses.Reduction", "path": "keras/losses/reduction", "type": "tf.keras", "text": "\nTypes of loss reduction.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.losses.serialize", "path": "keras/losses/serialize", "type": "tf.keras", "text": "\nSerializes loss function or `Loss` instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.losses.SparseCategoricalCrossentropy", "path": "keras/losses/sparsecategoricalcrossentropy", "type": "tf.keras", "text": "\nComputes the crossentropy loss between the labels and predictions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.losses.sparse_categorical_crossentropy", "path": "keras/losses/sparse_categorical_crossentropy", "type": "tf.keras", "text": "\nComputes the sparse categorical crossentropy loss.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.losses.SquaredHinge", "path": "keras/losses/squaredhinge", "type": "tf.keras", "text": "\nComputes the squared hinge loss between `y_true` and `y_pred`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.losses.squared_hinge", "path": "keras/losses/squared_hinge", "type": "tf.keras", "text": "\nComputes the squared hinge loss between `y_true` and `y_pred`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics", "path": "keras/metrics", "type": "tf.keras", "text": "\nBuilt-in metrics.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.Accuracy", "path": "keras/metrics/accuracy", "type": "tf.keras", "text": "\nCalculates how often predictions equal labels.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.AUC", "path": "keras/metrics/auc", "type": "tf.keras", "text": "\nComputes the approximate AUC (Area under the curve) via a Riemann sum.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.BinaryAccuracy", "path": "keras/metrics/binaryaccuracy", "type": "tf.keras", "text": "\nCalculates how often predictions match binary labels.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.BinaryCrossentropy", "path": "keras/metrics/binarycrossentropy", "type": "tf.keras", "text": "\nComputes the crossentropy metric between the labels and predictions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.binary_accuracy", "path": "keras/metrics/binary_accuracy", "type": "tf.keras", "text": "\nCalculates how often predictions matches binary labels.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.CategoricalAccuracy", "path": "keras/metrics/categoricalaccuracy", "type": "tf.keras", "text": "\nCalculates how often predictions matches one-hot labels.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.CategoricalCrossentropy", "path": "keras/metrics/categoricalcrossentropy", "type": "tf.keras", "text": "\nComputes the crossentropy metric between the labels and predictions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.CategoricalHinge", "path": "keras/metrics/categoricalhinge", "type": "tf.keras", "text": "\nComputes the categorical hinge metric between `y_true` and `y_pred`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.categorical_accuracy", "path": "keras/metrics/categorical_accuracy", "type": "tf.keras", "text": "\nCalculates how often predictions matches one-hot labels.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.CosineSimilarity", "path": "keras/metrics/cosinesimilarity", "type": "tf.keras", "text": "\nComputes the cosine similarity between the labels and predictions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.deserialize", "path": "keras/metrics/deserialize", "type": "tf.keras", "text": "\nDeserializes a serialized metric class/function instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.FalseNegatives", "path": "keras/metrics/falsenegatives", "type": "tf.keras", "text": "\nCalculates the number of false negatives.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.FalsePositives", "path": "keras/metrics/falsepositives", "type": "tf.keras", "text": "\nCalculates the number of false positives.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.get", "path": "keras/metrics/get", "type": "tf.keras", "text": "\nRetrieves a Keras metric as a `function`/`Metric` class instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.Hinge", "path": "keras/metrics/hinge", "type": "tf.keras", "text": "\nComputes the hinge metric between `y_true` and `y_pred`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.KLDivergence", "path": "keras/metrics/kldivergence", "type": "tf.keras", "text": "\nComputes Kullback-Leibler divergence metric between `y_true` and `y_pred`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.LogCoshError", "path": "keras/metrics/logcosherror", "type": "tf.keras", "text": "\nComputes the logarithm of the hyperbolic cosine of the prediction error.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.Mean", "path": "keras/metrics/mean", "type": "tf.keras", "text": "\nComputes the (weighted) mean of the given values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.MeanAbsoluteError", "path": "keras/metrics/meanabsoluteerror", "type": "tf.keras", "text": "\nComputes the mean absolute error between the labels and predictions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.MeanAbsolutePercentageError", "path": "keras/metrics/meanabsolutepercentageerror", "type": "tf.keras", "text": "\nComputes the mean absolute percentage error between `y_true` and `y_pred`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.MeanIoU", "path": "keras/metrics/meaniou", "type": "tf.keras", "text": "\nComputes the mean Intersection-Over-Union metric.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.MeanRelativeError", "path": "keras/metrics/meanrelativeerror", "type": "tf.keras", "text": "\nComputes the mean relative error by normalizing with the given values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.MeanSquaredError", "path": "keras/metrics/meansquarederror", "type": "tf.keras", "text": "\nComputes the mean squared error between `y_true` and `y_pred`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.MeanSquaredLogarithmicError", "path": "keras/metrics/meansquaredlogarithmicerror", "type": "tf.keras", "text": "\nComputes the mean squared logarithmic error between `y_true` and `y_pred`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.MeanTensor", "path": "keras/metrics/meantensor", "type": "tf.keras", "text": "\nComputes the element-wise (weighted) mean of the given tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.Metric", "path": "keras/metrics/metric", "type": "tf.keras", "text": "\nEncapsulates metric logic and state.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.Poisson", "path": "keras/metrics/poisson", "type": "tf.keras", "text": "\nComputes the Poisson metric between `y_true` and `y_pred`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.Precision", "path": "keras/metrics/precision", "type": "tf.keras", "text": "\nComputes the precision of the predictions with respect to the labels.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.PrecisionAtRecall", "path": "keras/metrics/precisionatrecall", "type": "tf.keras", "text": "\nComputes best precision where recall is >= specified value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.Recall", "path": "keras/metrics/recall", "type": "tf.keras", "text": "\nComputes the recall of the predictions with respect to the labels.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.RecallAtPrecision", "path": "keras/metrics/recallatprecision", "type": "tf.keras", "text": "\nComputes best recall where precision is >= specified value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.RootMeanSquaredError", "path": "keras/metrics/rootmeansquarederror", "type": "tf.keras", "text": "\nComputes root mean squared error metric between `y_true` and `y_pred`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.SensitivityAtSpecificity", "path": "keras/metrics/sensitivityatspecificity", "type": "tf.keras", "text": "\nComputes best sensitivity where specificity is >= specified value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.serialize", "path": "keras/metrics/serialize", "type": "tf.keras", "text": "\nSerializes metric function or `Metric` instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.SparseCategoricalAccuracy", "path": "keras/metrics/sparsecategoricalaccuracy", "type": "tf.keras", "text": "\nCalculates how often predictions matches integer labels.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.SparseCategoricalCrossentropy", "path": "keras/metrics/sparsecategoricalcrossentropy", "type": "tf.keras", "text": "\nComputes the crossentropy metric between the labels and predictions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.SparseTopKCategoricalAccuracy", "path": "keras/metrics/sparsetopkcategoricalaccuracy", "type": "tf.keras", "text": "\nComputes how often integer targets are in the top `K` predictions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.sparse_categorical_accuracy", "path": "keras/metrics/sparse_categorical_accuracy", "type": "tf.keras", "text": "\nCalculates how often predictions matches integer labels.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.sparse_top_k_categorical_accuracy", "path": "keras/metrics/sparse_top_k_categorical_accuracy", "type": "tf.keras", "text": "\nComputes how often integer targets are in the top `K` predictions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.SpecificityAtSensitivity", "path": "keras/metrics/specificityatsensitivity", "type": "tf.keras", "text": "\nComputes best specificity where sensitivity is >= specified value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.SquaredHinge", "path": "keras/metrics/squaredhinge", "type": "tf.keras", "text": "\nComputes the squared hinge metric between `y_true` and `y_pred`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.Sum", "path": "keras/metrics/sum", "type": "tf.keras", "text": "\nComputes the (weighted) sum of the given values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.TopKCategoricalAccuracy", "path": "keras/metrics/topkcategoricalaccuracy", "type": "tf.keras", "text": "\nComputes how often targets are in the top `K` predictions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.top_k_categorical_accuracy", "path": "keras/metrics/top_k_categorical_accuracy", "type": "tf.keras", "text": "\nComputes how often targets are in the top `K` predictions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.TrueNegatives", "path": "keras/metrics/truenegatives", "type": "tf.keras", "text": "\nCalculates the number of true negatives.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.metrics.TruePositives", "path": "keras/metrics/truepositives", "type": "tf.keras", "text": "\nCalculates the number of true positives.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.mixed_precision", "path": "keras/mixed_precision", "type": "tf.keras", "text": "\nKeras mixed precision API.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.mixed_precision.experimental", "path": "keras/mixed_precision/experimental", "type": "tf.keras", "text": "\nPublic API for tf.keras.mixed_precision.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.mixed_precision.experimental.get_layer_policy", "path": "keras/mixed_precision/experimental/get_layer_policy", "type": "tf.keras", "text": "\nReturns the dtype policy of a layer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.mixed_precision.experimental.LossScaleOptimizer", "path": "keras/mixed_precision/experimental/lossscaleoptimizer", "type": "tf.keras", "text": "\nAn deprecated optimizer that applies loss scaling.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.mixed_precision.experimental.Policy", "path": "keras/mixed_precision/experimental/policy", "type": "tf.keras", "text": "\nA deprecated dtype policy for a Keras layer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.mixed_precision.global_policy", "path": "keras/mixed_precision/global_policy", "type": "tf.keras", "text": "\nReturns the global dtype policy.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.mixed_precision.LossScaleOptimizer", "path": "keras/mixed_precision/lossscaleoptimizer", "type": "tf.keras", "text": "\nAn optimizer that applies loss scaling to prevent numeric underflow.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.mixed_precision.Policy", "path": "keras/mixed_precision/policy", "type": "tf.keras", "text": "\nA dtype policy for a Keras layer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.mixed_precision.set_global_policy", "path": "keras/mixed_precision/set_global_policy", "type": "tf.keras", "text": "\nSets the global dtype policy.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.Model", "path": "keras/model", "type": "tf.keras", "text": "\n`Model` groups layers into an object with training and inference features.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.models", "path": "keras/models", "type": "tf.keras", "text": "\nCode for model cloning, plus model-related API entries.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.models.clone_model", "path": "keras/models/clone_model", "type": "tf.keras", "text": "\nClone any `Model` instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.models.load_model", "path": "keras/models/load_model", "type": "tf.keras", "text": "\nLoads a model saved via `model.save()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.models.model_from_config", "path": "keras/models/model_from_config", "type": "tf.keras", "text": "\nInstantiates a Keras model from its config.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.models.model_from_json", "path": "keras/models/model_from_json", "type": "tf.keras", "text": "\nParses a JSON model configuration string and returns a model instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.models.model_from_yaml", "path": "keras/models/model_from_yaml", "type": "tf.keras", "text": "\nParses a yaml model configuration file and returns a model instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.models.save_model", "path": "keras/models/save_model", "type": "tf.keras", "text": "\nSaves a model as a TensorFlow SavedModel or HDF5 file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.optimizers", "path": "keras/optimizers", "type": "tf.keras", "text": "\nBuilt-in optimizer classes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.optimizers.Adadelta", "path": "keras/optimizers/adadelta", "type": "tf.keras", "text": "\nOptimizer that implements the Adadelta algorithm.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.optimizers.Adagrad", "path": "keras/optimizers/adagrad", "type": "tf.keras", "text": "\nOptimizer that implements the Adagrad algorithm.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.optimizers.Adam", "path": "keras/optimizers/adam", "type": "tf.keras", "text": "\nOptimizer that implements the Adam algorithm.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.optimizers.Adamax", "path": "keras/optimizers/adamax", "type": "tf.keras", "text": "\nOptimizer that implements the Adamax algorithm.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.optimizers.deserialize", "path": "keras/optimizers/deserialize", "type": "tf.keras", "text": "\nInverse of the `serialize` function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.optimizers.Ftrl", "path": "keras/optimizers/ftrl", "type": "tf.keras", "text": "\nOptimizer that implements the FTRL algorithm.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.optimizers.get", "path": "keras/optimizers/get", "type": "tf.keras", "text": "\nRetrieves a Keras Optimizer instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.optimizers.Nadam", "path": "keras/optimizers/nadam", "type": "tf.keras", "text": "\nOptimizer that implements the NAdam algorithm.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.optimizers.Optimizer", "path": "keras/optimizers/optimizer", "type": "tf.keras", "text": "\nBase class for Keras optimizers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.optimizers.RMSprop", "path": "keras/optimizers/rmsprop", "type": "tf.keras", "text": "\nOptimizer that implements the RMSprop algorithm.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.optimizers.schedules", "path": "keras/optimizers/schedules", "type": "tf.keras", "text": "\nPublic API for tf.keras.optimizers.schedules namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.optimizers.schedules.deserialize", "path": "keras/optimizers/schedules/deserialize", "type": "tf.keras", "text": "\nMain aliases\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.optimizers.schedules.ExponentialDecay", "path": "keras/optimizers/schedules/exponentialdecay", "type": "tf.keras", "text": "\nA LearningRateSchedule that uses an exponential decay schedule.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.optimizers.schedules.InverseTimeDecay", "path": "keras/optimizers/schedules/inversetimedecay", "type": "tf.keras", "text": "\nA LearningRateSchedule that uses an inverse time decay schedule.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.optimizers.schedules.LearningRateSchedule", "path": "keras/optimizers/schedules/learningrateschedule", "type": "tf.keras", "text": "\nA serializable learning rate decay schedule.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.optimizers.schedules.PiecewiseConstantDecay", "path": "keras/optimizers/schedules/piecewiseconstantdecay", "type": "tf.keras", "text": "\nA LearningRateSchedule that uses a piecewise constant decay schedule.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.optimizers.schedules.PolynomialDecay", "path": "keras/optimizers/schedules/polynomialdecay", "type": "tf.keras", "text": "\nA LearningRateSchedule that uses a polynomial decay schedule.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.optimizers.schedules.serialize", "path": "keras/optimizers/schedules/serialize", "type": "tf.keras", "text": "\nMain aliases\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.optimizers.serialize", "path": "keras/optimizers/serialize", "type": "tf.keras", "text": "\nMain aliases\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.optimizers.SGD", "path": "keras/optimizers/sgd", "type": "tf.keras", "text": "\nGradient descent (with momentum) optimizer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.preprocessing", "path": "keras/preprocessing", "type": "tf.keras", "text": "\nKeras data preprocessing utils.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.preprocessing.image", "path": "keras/preprocessing/image", "type": "tf.keras", "text": "\nSet of tools for real-time data augmentation on image data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.preprocessing.image.apply_affine_transform", "path": "keras/preprocessing/image/apply_affine_transform", "type": "tf.keras", "text": "\nApplies an affine transformation specified by the parameters given.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.preprocessing.image.apply_brightness_shift", "path": "keras/preprocessing/image/apply_brightness_shift", "type": "tf.keras", "text": "\nPerforms a brightness shift.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.preprocessing.image.apply_channel_shift", "path": "keras/preprocessing/image/apply_channel_shift", "type": "tf.keras", "text": "\nPerforms a channel shift.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.preprocessing.image.array_to_img", "path": "keras/preprocessing/image/array_to_img", "type": "tf.keras", "text": "\nConverts a 3D Numpy array to a PIL Image instance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.preprocessing.image.DirectoryIterator", "path": "keras/preprocessing/image/directoryiterator", "type": "tf.keras", "text": "\nIterator capable of reading images from a directory on disk.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.preprocessing.image.ImageDataGenerator", "path": "keras/preprocessing/image/imagedatagenerator", "type": "tf.keras", "text": "\nGenerate batches of tensor image data with real-time data augmentation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.preprocessing.image.img_to_array", "path": "keras/preprocessing/image/img_to_array", "type": "tf.keras", "text": "\nConverts a PIL Image instance to a Numpy array.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.preprocessing.image.Iterator", "path": "keras/preprocessing/image/iterator", "type": "tf.keras", "text": "\nBase class for image data iterators.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.preprocessing.image.load_img", "path": "keras/preprocessing/image/load_img", "type": "tf.keras", "text": "\nLoads an image into PIL format.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.preprocessing.image.NumpyArrayIterator", "path": "keras/preprocessing/image/numpyarrayiterator", "type": "tf.keras", "text": "\nIterator yielding data from a Numpy array.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.preprocessing.image.random_brightness", "path": "keras/preprocessing/image/random_brightness", "type": "tf.keras", "text": "\nPerforms a random brightness shift.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.preprocessing.image.random_channel_shift", "path": "keras/preprocessing/image/random_channel_shift", "type": "tf.keras", "text": "\nPerforms a random channel shift.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.preprocessing.image.random_rotation", "path": "keras/preprocessing/image/random_rotation", "type": "tf.keras", "text": "\nPerforms a random rotation of a Numpy image tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.preprocessing.image.random_shear", "path": "keras/preprocessing/image/random_shear", "type": "tf.keras", "text": "\nPerforms a random spatial shear of a Numpy image tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.preprocessing.image.random_shift", "path": "keras/preprocessing/image/random_shift", "type": "tf.keras", "text": "\nPerforms a random spatial shift of a Numpy image tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.preprocessing.image.random_zoom", "path": "keras/preprocessing/image/random_zoom", "type": "tf.keras", "text": "\nPerforms a random spatial zoom of a Numpy image tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.preprocessing.image.save_img", "path": "keras/preprocessing/image/save_img", "type": "tf.keras", "text": "\nSaves an image stored as a Numpy array to a path or file object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.preprocessing.image.smart_resize", "path": "keras/preprocessing/image/smart_resize", "type": "tf.keras", "text": "\nResize images to a target size without aspect ratio distortion.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.preprocessing.image_dataset_from_directory", "path": "keras/preprocessing/image_dataset_from_directory", "type": "tf.keras", "text": "\nGenerates a `tf.data.Dataset` from image files in a directory.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.preprocessing.sequence", "path": "keras/preprocessing/sequence", "type": "tf.keras", "text": "\nUtilities for preprocessing sequence data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.preprocessing.sequence.make_sampling_table", "path": "keras/preprocessing/sequence/make_sampling_table", "type": "tf.keras", "text": "\nGenerates a word rank-based probabilistic sampling table.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.preprocessing.sequence.pad_sequences", "path": "keras/preprocessing/sequence/pad_sequences", "type": "tf.keras", "text": "\nPads sequences to the same length.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.preprocessing.sequence.skipgrams", "path": "keras/preprocessing/sequence/skipgrams", "type": "tf.keras", "text": "\nGenerates skipgram word pairs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.preprocessing.sequence.TimeseriesGenerator", "path": "keras/preprocessing/sequence/timeseriesgenerator", "type": "tf.keras", "text": "\nUtility class for generating batches of temporal data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.preprocessing.text", "path": "keras/preprocessing/text", "type": "tf.keras", "text": "\nUtilities for text input preprocessing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.preprocessing.text.hashing_trick", "path": "keras/preprocessing/text/hashing_trick", "type": "tf.keras", "text": "\nConverts a text to a sequence of indexes in a fixed-size hashing space.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.preprocessing.text.one_hot", "path": "keras/preprocessing/text/one_hot", "type": "tf.keras", "text": "\nOne-hot encodes a text into a list of word indexes of size `n`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.preprocessing.text.text_to_word_sequence", "path": "keras/preprocessing/text/text_to_word_sequence", "type": "tf.keras", "text": "\nConverts a text to a sequence of words (or tokens).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.preprocessing.text.Tokenizer", "path": "keras/preprocessing/text/tokenizer", "type": "tf.keras", "text": "\nText tokenization utility class.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.preprocessing.text.tokenizer_from_json", "path": "keras/preprocessing/text/tokenizer_from_json", "type": "tf.keras", "text": "\nParses a JSON tokenizer configuration file and returns a\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.preprocessing.text_dataset_from_directory", "path": "keras/preprocessing/text_dataset_from_directory", "type": "tf.keras", "text": "\nGenerates a `tf.data.Dataset` from text files in a directory.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.preprocessing.timeseries_dataset_from_array", "path": "keras/preprocessing/timeseries_dataset_from_array", "type": "tf.keras", "text": "\nCreates a dataset of sliding windows over a timeseries provided as array.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.regularizers", "path": "keras/regularizers", "type": "tf.keras", "text": "\nBuilt-in regularizers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.regularizers.deserialize", "path": "keras/regularizers/deserialize", "type": "tf.keras", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.regularizers.get", "path": "keras/regularizers/get", "type": "tf.keras", "text": "\nRetrieve a regularizer instance from a config or identifier.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.regularizers.L1", "path": "keras/regularizers/l1", "type": "tf.keras", "text": "\nA regularizer that applies a L1 regularization penalty.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.regularizers.L1L2", "path": "keras/regularizers/l1l2", "type": "tf.keras", "text": "\nA regularizer that applies both L1 and L2 regularization penalties.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.regularizers.l1_l2", "path": "keras/regularizers/l1_l2", "type": "tf.keras", "text": "\nCreate a regularizer that applies both L1 and L2 penalties.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.regularizers.L2", "path": "keras/regularizers/l2", "type": "tf.keras", "text": "\nA regularizer that applies a L2 regularization penalty.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.regularizers.Regularizer", "path": "keras/regularizers/regularizer", "type": "tf.keras", "text": "\nRegularizer base class.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.regularizers.serialize", "path": "keras/regularizers/serialize", "type": "tf.keras", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.Sequential", "path": "keras/sequential", "type": "tf.keras", "text": "\n`Sequential` groups a linear stack of layers into a `tf.keras.Model`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.utils", "path": "keras/utils", "type": "tf.keras", "text": "\nPublic API for tf.keras.utils namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.utils.CustomObjectScope", "path": "keras/utils/customobjectscope", "type": "tf.keras", "text": "\nExposes custom classes/functions to Keras deserialization internals.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.utils.deserialize_keras_object", "path": "keras/utils/deserialize_keras_object", "type": "tf.keras", "text": "\nTurns the serialized form of a Keras object back into an actual object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.utils.GeneratorEnqueuer", "path": "keras/utils/generatorenqueuer", "type": "tf.keras", "text": "\nBuilds a queue out of a data generator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.utils.get_custom_objects", "path": "keras/utils/get_custom_objects", "type": "tf.keras", "text": "\nRetrieves a live reference to the global dictionary of custom objects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.utils.get_file", "path": "keras/utils/get_file", "type": "tf.keras", "text": "\nDownloads a file from a URL if it not already in the cache.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.utils.get_registered_name", "path": "keras/utils/get_registered_name", "type": "tf.keras", "text": "\nReturns the name registered to an object within the Keras framework.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.utils.get_registered_object", "path": "keras/utils/get_registered_object", "type": "tf.keras", "text": "\nReturns the class associated with `name` if it is registered with Keras.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.utils.get_source_inputs", "path": "keras/utils/get_source_inputs", "type": "tf.keras", "text": "\nReturns the list of input tensors necessary to compute `tensor`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.utils.model_to_dot", "path": "keras/utils/model_to_dot", "type": "tf.keras", "text": "\nConvert a Keras model to dot format.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.utils.normalize", "path": "keras/utils/normalize", "type": "tf.keras", "text": "\nNormalizes a Numpy array.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.utils.OrderedEnqueuer", "path": "keras/utils/orderedenqueuer", "type": "tf.keras", "text": "\nBuilds a Enqueuer from a Sequence.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.utils.pack_x_y_sample_weight", "path": "keras/utils/pack_x_y_sample_weight", "type": "tf.keras", "text": "\nPacks user-provided data into a tuple.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.utils.plot_model", "path": "keras/utils/plot_model", "type": "tf.keras", "text": "\nConverts a Keras model to dot format and save to a file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.utils.Progbar", "path": "keras/utils/progbar", "type": "tf.keras", "text": "\nDisplays a progress bar.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.utils.register_keras_serializable", "path": "keras/utils/register_keras_serializable", "type": "tf.keras", "text": "\nRegisters an object with the Keras serialization framework.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.utils.Sequence", "path": "keras/utils/sequence", "type": "tf.keras", "text": "\nBase object for fitting to a sequence of data, such as a dataset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.utils.SequenceEnqueuer", "path": "keras/utils/sequenceenqueuer", "type": "tf.keras", "text": "\nBase class to enqueue inputs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.utils.serialize_keras_object", "path": "keras/utils/serialize_keras_object", "type": "tf.keras", "text": "\nSerialize a Keras object into a JSON-compatible representation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.utils.to_categorical", "path": "keras/utils/to_categorical", "type": "tf.keras", "text": "\nConverts a class vector (integers) to binary class matrix.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.utils.unpack_x_y_sample_weight", "path": "keras/utils/unpack_x_y_sample_weight", "type": "tf.keras", "text": "\nUnpacks user-provided data tuple.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.wrappers", "path": "keras/wrappers", "type": "tf.keras", "text": "\nPublic API for tf.keras.wrappers namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.wrappers.scikit_learn", "path": "keras/wrappers/scikit_learn", "type": "tf.keras", "text": "\nWrapper for using the Scikit-Learn API with Keras models.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.wrappers.scikit_learn.KerasClassifier", "path": "keras/wrappers/scikit_learn/kerasclassifier", "type": "tf.keras", "text": "\nImplementation of the scikit-learn classifier API for Keras.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.keras.wrappers.scikit_learn.KerasRegressor", "path": "keras/wrappers/scikit_learn/kerasregressor", "type": "tf.keras", "text": "\nImplementation of the scikit-learn regressor API for Keras.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg", "path": "linalg", "type": "tf.linalg", "text": "\nOperations for linear algebra.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.adjoint", "path": "linalg/adjoint", "type": "tf.linalg", "text": "\nTransposes the last two dimensions of and conjugates tensor `matrix`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.banded_triangular_solve", "path": "linalg/banded_triangular_solve", "type": "tf.linalg", "text": "\nSolve triangular systems of equations with a banded solver.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.band_part", "path": "linalg/band_part", "type": "tf.linalg", "text": "\nCopy a tensor setting everything outside a central band in each innermost\nmatrix to zero.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.cholesky", "path": "linalg/cholesky", "type": "tf.linalg", "text": "\nComputes the Cholesky decomposition of one or more square matrices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.cholesky_solve", "path": "linalg/cholesky_solve", "type": "tf.linalg", "text": "\nSolves systems of linear eqns `A X = RHS`, given Cholesky factorizations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.cross", "path": "linalg/cross", "type": "tf.linalg", "text": "\nCompute the pairwise cross product.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.det", "path": "linalg/det", "type": "tf.linalg", "text": "\nComputes the determinant of one or more square matrices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.diag", "path": "linalg/diag", "type": "tf.linalg", "text": "\nReturns a batched diagonal tensor with given batched diagonal values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.diag_part", "path": "linalg/diag_part", "type": "tf.linalg", "text": "\nReturns the batched diagonal part of a batched tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.eig", "path": "linalg/eig", "type": "tf.linalg", "text": "\nComputes the eigen decomposition of a batch of matrices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.eigh", "path": "linalg/eigh", "type": "tf.linalg", "text": "\nComputes the eigen decomposition of a batch of self-adjoint matrices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.eigvals", "path": "linalg/eigvals", "type": "tf.linalg", "text": "\nComputes the eigenvalues of one or more matrices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.eigvalsh", "path": "linalg/eigvalsh", "type": "tf.linalg", "text": "\nComputes the eigenvalues of one or more self-adjoint matrices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.experimental", "path": "linalg/experimental", "type": "tf.linalg", "text": "\nPublic API for tf.linalg.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.experimental.conjugate_gradient", "path": "linalg/experimental/conjugate_gradient", "type": "tf.linalg", "text": "\nConjugate gradient solver.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.expm", "path": "linalg/expm", "type": "tf.linalg", "text": "\nComputes the matrix exponential of one or more square matrices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.global_norm", "path": "linalg/global_norm", "type": "tf.linalg", "text": "\nComputes the global norm of multiple tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.inv", "path": "linalg/inv", "type": "tf.linalg", "text": "\nComputes the inverse of one or more square invertible matrices or their\nadjoints (conjugate transposes).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.LinearOperator", "path": "linalg/linearoperator", "type": "tf.linalg", "text": "\nBase class defining a [batch of] linear operator[s].\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.LinearOperatorAdjoint", "path": "linalg/linearoperatoradjoint", "type": "tf.linalg", "text": "\n`LinearOperator` representing the adjoint of another operator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.LinearOperatorBlockDiag", "path": "linalg/linearoperatorblockdiag", "type": "tf.linalg", "text": "\nCombines one or more `LinearOperators` in to a Block Diagonal matrix.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.LinearOperatorBlockLowerTriangular", "path": "linalg/linearoperatorblocklowertriangular", "type": "tf.linalg", "text": "\nCombines `LinearOperators` into a blockwise lower-triangular matrix.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.LinearOperatorCirculant", "path": "linalg/linearoperatorcirculant", "type": "tf.linalg", "text": "\n`LinearOperator` acting like a circulant matrix.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.LinearOperatorCirculant2D", "path": "linalg/linearoperatorcirculant2d", "type": "tf.linalg", "text": "\n`LinearOperator` acting like a block circulant matrix.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.LinearOperatorCirculant3D", "path": "linalg/linearoperatorcirculant3d", "type": "tf.linalg", "text": "\n`LinearOperator` acting like a nested block circulant matrix.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.LinearOperatorComposition", "path": "linalg/linearoperatorcomposition", "type": "tf.linalg", "text": "\nComposes one or more `LinearOperators`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.LinearOperatorDiag", "path": "linalg/linearoperatordiag", "type": "tf.linalg", "text": "\n`LinearOperator` acting like a [batch] square diagonal matrix.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.LinearOperatorFullMatrix", "path": "linalg/linearoperatorfullmatrix", "type": "tf.linalg", "text": "\n`LinearOperator` that wraps a [batch] matrix.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.LinearOperatorHouseholder", "path": "linalg/linearoperatorhouseholder", "type": "tf.linalg", "text": "\n`LinearOperator` acting like a [batch] of Householder transformations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.LinearOperatorIdentity", "path": "linalg/linearoperatoridentity", "type": "tf.linalg", "text": "\n`LinearOperator` acting like a [batch] square identity matrix.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.LinearOperatorInversion", "path": "linalg/linearoperatorinversion", "type": "tf.linalg", "text": "\n`LinearOperator` representing the inverse of another operator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.LinearOperatorKronecker", "path": "linalg/linearoperatorkronecker", "type": "tf.linalg", "text": "\nKronecker product between two `LinearOperators`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.LinearOperatorLowerTriangular", "path": "linalg/linearoperatorlowertriangular", "type": "tf.linalg", "text": "\n`LinearOperator` acting like a [batch] square lower triangular matrix.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.LinearOperatorLowRankUpdate", "path": "linalg/linearoperatorlowrankupdate", "type": "tf.linalg", "text": "\nPerturb a `LinearOperator` with a rank `K` update.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.LinearOperatorPermutation", "path": "linalg/linearoperatorpermutation", "type": "tf.linalg", "text": "\n`LinearOperator` acting like a [batch] of permutation matrices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.LinearOperatorScaledIdentity", "path": "linalg/linearoperatorscaledidentity", "type": "tf.linalg", "text": "\n`LinearOperator` acting like a scaled [batch] identity matrix `A = c I`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.LinearOperatorToeplitz", "path": "linalg/linearoperatortoeplitz", "type": "tf.linalg", "text": "\n`LinearOperator` acting like a [batch] of toeplitz matrices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.LinearOperatorTridiag", "path": "linalg/linearoperatortridiag", "type": "tf.linalg", "text": "\n`LinearOperator` acting like a [batch] square tridiagonal matrix.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.LinearOperatorZeros", "path": "linalg/linearoperatorzeros", "type": "tf.linalg", "text": "\n`LinearOperator` acting like a [batch] zero matrix.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.logdet", "path": "linalg/logdet", "type": "tf.linalg", "text": "\nComputes log of the determinant of a hermitian positive definite matrix.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.logm", "path": "linalg/logm", "type": "tf.linalg", "text": "\nComputes the matrix logarithm of one or more square matrices:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.lstsq", "path": "linalg/lstsq", "type": "tf.linalg", "text": "\nSolves one or more linear least-squares problems.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.lu", "path": "linalg/lu", "type": "tf.linalg", "text": "\nComputes the LU decomposition of one or more square matrices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.lu_matrix_inverse", "path": "linalg/lu_matrix_inverse", "type": "tf.linalg", "text": "\nComputes the inverse given the LU decomposition(s) of one or more matrices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.lu_reconstruct", "path": "linalg/lu_reconstruct", "type": "tf.linalg", "text": "\nThe reconstruct one or more matrices from their LU decomposition(s).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.lu_solve", "path": "linalg/lu_solve", "type": "tf.linalg", "text": "\nSolves systems of linear eqns `A X = RHS`, given LU factorizations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.matmul", "path": "linalg/matmul", "type": "tf.linalg", "text": "\nMultiplies matrix `a` by matrix `b`, producing `a` * `b`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.matrix_rank", "path": "linalg/matrix_rank", "type": "tf.linalg", "text": "\nCompute the matrix rank of one or more matrices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.matrix_transpose", "path": "linalg/matrix_transpose", "type": "tf.linalg", "text": "\nTransposes last two dimensions of tensor `a`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.matvec", "path": "linalg/matvec", "type": "tf.linalg", "text": "\nMultiplies matrix `a` by vector `b`, producing `a` * `b`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.normalize", "path": "linalg/normalize", "type": "tf.linalg", "text": "\nNormalizes `tensor` along dimension `axis` using specified norm.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.pinv", "path": "linalg/pinv", "type": "tf.linalg", "text": "\nCompute the Moore-Penrose pseudo-inverse of one or more matrices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.qr", "path": "linalg/qr", "type": "tf.linalg", "text": "\nComputes the QR decompositions of one or more matrices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.set_diag", "path": "linalg/set_diag", "type": "tf.linalg", "text": "\nReturns a batched matrix tensor with new batched diagonal values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.slogdet", "path": "linalg/slogdet", "type": "tf.linalg", "text": "\nComputes the sign and the log of the absolute value of the determinant of\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.solve", "path": "linalg/solve", "type": "tf.linalg", "text": "\nSolves systems of linear equations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.sqrtm", "path": "linalg/sqrtm", "type": "tf.linalg", "text": "\nComputes the matrix square root of one or more square matrices:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.svd", "path": "linalg/svd", "type": "tf.linalg", "text": "\nComputes the singular value decompositions of one or more matrices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.tensor_diag", "path": "linalg/tensor_diag", "type": "tf.linalg", "text": "\nReturns a diagonal tensor with a given diagonal values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.tensor_diag_part", "path": "linalg/tensor_diag_part", "type": "tf.linalg", "text": "\nReturns the diagonal part of the tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.trace", "path": "linalg/trace", "type": "tf.linalg", "text": "\nCompute the trace of a tensor `x`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.triangular_solve", "path": "linalg/triangular_solve", "type": "tf.linalg", "text": "\nSolve systems of linear equations with upper or lower triangular matrices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.tridiagonal_matmul", "path": "linalg/tridiagonal_matmul", "type": "tf.linalg", "text": "\nMultiplies tridiagonal matrix by matrix.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linalg.tridiagonal_solve", "path": "linalg/tridiagonal_solve", "type": "tf.linalg", "text": "\nSolves tridiagonal systems of equations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.linspace", "path": "linspace", "type": "tf", "text": "\nGenerates evenly-spaced values in an interval along a given axis.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.lite", "path": "lite", "type": "tf.lite", "text": "\nPublic API for tf.lite namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.lite.experimental", "path": "lite/experimental", "type": "tf.lite", "text": "\nPublic API for tf.lite.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.lite.experimental.load_delegate", "path": "lite/experimental/load_delegate", "type": "tf.lite", "text": "\nReturns loaded Delegate object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.lite.Interpreter", "path": "lite/interpreter", "type": "tf.lite", "text": "\nInterpreter interface for TensorFlow Lite Models.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.lite.OpsSet", "path": "lite/opsset", "type": "tf.lite", "text": "\nEnum class defining the sets of ops available to generate TFLite models.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.lite.Optimize", "path": "lite/optimize", "type": "tf.lite", "text": "\nEnum defining the optimizations to apply when generating tflite graphs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.lite.RepresentativeDataset", "path": "lite/representativedataset", "type": "tf.lite", "text": "\nRepresentative dataset to evaluate optimizations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.lite.TargetSpec", "path": "lite/targetspec", "type": "tf.lite", "text": "\nSpecification of target device.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.lite.TFLiteConverter", "path": "lite/tfliteconverter", "type": "tf.lite", "text": "\nConverts a TensorFlow model into TensorFlow Lite model.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.load_library", "path": "load_library", "type": "tf", "text": "\nLoads a TensorFlow plugin.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.load_op_library", "path": "load_op_library", "type": "tf", "text": "\nLoads a TensorFlow plugin, containing custom ops and kernels.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.lookup", "path": "lookup", "type": "tf.lookup", "text": "\nPublic API for tf.lookup namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.lookup.experimental", "path": "lookup/experimental", "type": "tf.lookup", "text": "\nPublic API for tf.lookup.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.lookup.experimental.DatasetInitializer", "path": "lookup/experimental/datasetinitializer", "type": "tf.lookup", "text": "\nCreates a table initializer from a `tf.data.Dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.lookup.experimental.DenseHashTable", "path": "lookup/experimental/densehashtable", "type": "tf.lookup", "text": "\nA generic mutable hash table implementation using tensors as backing store.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.lookup.KeyValueTensorInitializer", "path": "lookup/keyvaluetensorinitializer", "type": "tf.lookup", "text": "\nTable initializers given `keys` and `values` tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.lookup.StaticHashTable", "path": "lookup/statichashtable", "type": "tf.lookup", "text": "\nA generic hash table that is immutable once initialized.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.lookup.StaticVocabularyTable", "path": "lookup/staticvocabularytable", "type": "tf.lookup", "text": "\nString to Id table that assigns out-of-vocabulary keys to hash buckets.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.lookup.TextFileIndex", "path": "lookup/textfileindex", "type": "tf.lookup", "text": "\nThe key and value content to get from each line.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.lookup.TextFileInitializer", "path": "lookup/textfileinitializer", "type": "tf.lookup", "text": "\nTable initializers from a text file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.make_ndarray", "path": "make_ndarray", "type": "tf", "text": "\nCreate a numpy ndarray from a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.make_tensor_proto", "path": "make_tensor_proto", "type": "tf", "text": "\nCreate a TensorProto.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.map_fn", "path": "map_fn", "type": "tf", "text": "\nTransforms `elems` by applying `fn` to each element unstacked on axis 0.\n(deprecated arguments)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math", "path": "math", "type": "tf.math", "text": "\nMath Operations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.abs", "path": "math/abs", "type": "tf.math", "text": "\nComputes the absolute value of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.accumulate_n", "path": "math/accumulate_n", "type": "tf.math", "text": "\nReturns the element-wise sum of a list of tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.acos", "path": "math/acos", "type": "tf.math", "text": "\nComputes acos of x element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.acosh", "path": "math/acosh", "type": "tf.math", "text": "\nComputes inverse hyperbolic cosine of x element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.add", "path": "math/add", "type": "tf.math", "text": "\nReturns x + y element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.add_n", "path": "math/add_n", "type": "tf.math", "text": "\nAdds all input tensors element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.angle", "path": "math/angle", "type": "tf.math", "text": "\nReturns the element-wise argument of a complex (or real) tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.argmax", "path": "math/argmax", "type": "tf.math", "text": "\nReturns the index with the largest value across axes of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.argmin", "path": "math/argmin", "type": "tf.math", "text": "\nReturns the index with the smallest value across axes of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.asin", "path": "math/asin", "type": "tf.math", "text": "\nComputes the trignometric inverse sine of x element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.asinh", "path": "math/asinh", "type": "tf.math", "text": "\nComputes inverse hyperbolic sine of x element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.atan", "path": "math/atan", "type": "tf.math", "text": "\nComputes the trignometric inverse tangent of x element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.atan2", "path": "math/atan2", "type": "tf.math", "text": "\nComputes arctangent of `y/x` element-wise, respecting signs of the arguments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.atanh", "path": "math/atanh", "type": "tf.math", "text": "\nComputes inverse hyperbolic tangent of x element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.bessel_i0", "path": "math/bessel_i0", "type": "tf.math", "text": "\nComputes the Bessel i0 function of `x` element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.bessel_i0e", "path": "math/bessel_i0e", "type": "tf.math", "text": "\nComputes the Bessel i0e function of `x` element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.bessel_i1", "path": "math/bessel_i1", "type": "tf.math", "text": "\nComputes the Bessel i1 function of `x` element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.bessel_i1e", "path": "math/bessel_i1e", "type": "tf.math", "text": "\nComputes the Bessel i1e function of `x` element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.betainc", "path": "math/betainc", "type": "tf.math", "text": "\nCompute the regularized incomplete beta integral \\\\(I_x(a, b)\\\\).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.bincount", "path": "math/bincount", "type": "tf.math", "text": "\nCounts the number of occurrences of each value in an integer array.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.ceil", "path": "math/ceil", "type": "tf.math", "text": "\nReturn the ceiling of the input, element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.confusion_matrix", "path": "math/confusion_matrix", "type": "tf.math", "text": "\nComputes the confusion matrix from predictions and labels.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.conj", "path": "math/conj", "type": "tf.math", "text": "\nReturns the complex conjugate of a complex number.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.cos", "path": "math/cos", "type": "tf.math", "text": "\nComputes cos of x element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.cosh", "path": "math/cosh", "type": "tf.math", "text": "\nComputes hyperbolic cosine of x element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.count_nonzero", "path": "math/count_nonzero", "type": "tf.math", "text": "\nComputes number of nonzero elements across dimensions of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.cumprod", "path": "math/cumprod", "type": "tf.math", "text": "\nCompute the cumulative product of the tensor `x` along `axis`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.cumsum", "path": "math/cumsum", "type": "tf.math", "text": "\nCompute the cumulative sum of the tensor `x` along `axis`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.cumulative_logsumexp", "path": "math/cumulative_logsumexp", "type": "tf.math", "text": "\nCompute the cumulative log-sum-exp of the tensor `x` along `axis`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.digamma", "path": "math/digamma", "type": "tf.math", "text": "\nComputes Psi, the derivative of Lgamma (the log of the absolute value of\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.divide", "path": "math/divide", "type": "tf.math", "text": "\nComputes Python style division of `x` by `y`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.divide_no_nan", "path": "math/divide_no_nan", "type": "tf.math", "text": "\nComputes a safe divide which returns 0 if the y is zero.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.equal", "path": "math/equal", "type": "tf.math", "text": "\nReturns the truth value of (x == y) element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.erf", "path": "math/erf", "type": "tf.math", "text": "\nComputes the Gauss error function of `x` element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.erfc", "path": "math/erfc", "type": "tf.math", "text": "\nComputes the complementary error function of `x` element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.erfcinv", "path": "math/erfcinv", "type": "tf.math", "text": "\nComputes the inverse of complementary error function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.erfinv", "path": "math/erfinv", "type": "tf.math", "text": "\nCompute inverse error function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.exp", "path": "math/exp", "type": "tf.math", "text": "\nComputes exponential of x element-wise. \\\\(y = e^x\\\\).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.expm1", "path": "math/expm1", "type": "tf.math", "text": "\nComputes `exp(x) - 1` element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.floor", "path": "math/floor", "type": "tf.math", "text": "\nReturns element-wise largest integer not greater than x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.floordiv", "path": "math/floordiv", "type": "tf.math", "text": "\nDivides `x / y` elementwise, rounding toward the most negative integer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.floormod", "path": "math/floormod", "type": "tf.math", "text": "\nReturns element-wise remainder of division. When `x < 0` xor `y < 0` is\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.greater", "path": "math/greater", "type": "tf.math", "text": "\nReturns the truth value of (x > y) element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.greater_equal", "path": "math/greater_equal", "type": "tf.math", "text": "\nReturns the truth value of (x >= y) element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.igamma", "path": "math/igamma", "type": "tf.math", "text": "\nCompute the lower regularized incomplete Gamma function `P(a, x)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.igammac", "path": "math/igammac", "type": "tf.math", "text": "\nCompute the upper regularized incomplete Gamma function `Q(a, x)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.imag", "path": "math/imag", "type": "tf.math", "text": "\nReturns the imaginary part of a complex (or real) tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.invert_permutation", "path": "math/invert_permutation", "type": "tf.math", "text": "\nComputes the inverse permutation of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.in_top_k", "path": "math/in_top_k", "type": "tf.math", "text": "\nSays whether the targets are in the top `K` predictions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.is_finite", "path": "math/is_finite", "type": "tf.math", "text": "\nReturns which elements of x are finite.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.is_inf", "path": "math/is_inf", "type": "tf.math", "text": "\nReturns which elements of x are Inf.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.is_nan", "path": "math/is_nan", "type": "tf.math", "text": "\nReturns which elements of x are NaN.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.is_non_decreasing", "path": "math/is_non_decreasing", "type": "tf.math", "text": "\nReturns `True` if `x` is non-decreasing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.is_strictly_increasing", "path": "math/is_strictly_increasing", "type": "tf.math", "text": "\nReturns `True` if `x` is strictly increasing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.l2_normalize", "path": "math/l2_normalize", "type": "tf.math", "text": "\nNormalizes along dimension `axis` using an L2 norm.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.lbeta", "path": "math/lbeta", "type": "tf.math", "text": "\nComputes \\\\(ln(|Beta(x)|)\\\\), reducing along the last dimension.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.less", "path": "math/less", "type": "tf.math", "text": "\nReturns the truth value of (x < y) element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.less_equal", "path": "math/less_equal", "type": "tf.math", "text": "\nReturns the truth value of (x <= y) element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.lgamma", "path": "math/lgamma", "type": "tf.math", "text": "\nComputes the log of the absolute value of `Gamma(x)` element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.log", "path": "math/log", "type": "tf.math", "text": "\nComputes natural logarithm of x element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.log1p", "path": "math/log1p", "type": "tf.math", "text": "\nComputes natural logarithm of (1 + x) element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.logical_and", "path": "math/logical_and", "type": "tf.math", "text": "\nLogical AND function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.logical_not", "path": "math/logical_not", "type": "tf.math", "text": "\nReturns the truth value of `NOT x` element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.logical_or", "path": "math/logical_or", "type": "tf.math", "text": "\nReturns the truth value of x OR y element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.logical_xor", "path": "math/logical_xor", "type": "tf.math", "text": "\nLogical XOR function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.log_sigmoid", "path": "math/log_sigmoid", "type": "tf.math", "text": "\nComputes log sigmoid of `x` element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.maximum", "path": "math/maximum", "type": "tf.math", "text": "\nReturns the max of x and y (i.e. x > y ? x : y) element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.minimum", "path": "math/minimum", "type": "tf.math", "text": "\nReturns the min of x and y (i.e. x < y ? x : y) element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.multiply", "path": "math/multiply", "type": "tf.math", "text": "\nReturns an element-wise x * y.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.multiply_no_nan", "path": "math/multiply_no_nan", "type": "tf.math", "text": "\nComputes the product of x and y and returns 0 if the y is zero, even if x is\nNaN or infinite.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.ndtri", "path": "math/ndtri", "type": "tf.math", "text": "\nCompute quantile of Standard Normal.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.negative", "path": "math/negative", "type": "tf.math", "text": "\nComputes numerical negative value element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.nextafter", "path": "math/nextafter", "type": "tf.math", "text": "\nReturns the next representable value of `x1` in the direction of `x2`,\nelement-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.not_equal", "path": "math/not_equal", "type": "tf.math", "text": "\nReturns the truth value of (x != y) element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.polygamma", "path": "math/polygamma", "type": "tf.math", "text": "\nCompute the polygamma function \\\\(\\psi^{(n)}(x)\\\\).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.polyval", "path": "math/polyval", "type": "tf.math", "text": "\nComputes the elementwise value of a polynomial.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.pow", "path": "math/pow", "type": "tf.math", "text": "\nComputes the power of one value to another.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.real", "path": "math/real", "type": "tf.math", "text": "\nReturns the real part of a complex (or real) tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.reciprocal", "path": "math/reciprocal", "type": "tf.math", "text": "\nComputes the reciprocal of x element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.reciprocal_no_nan", "path": "math/reciprocal_no_nan", "type": "tf.math", "text": "\nPerforms a safe reciprocal operation, element wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.reduce_all", "path": "math/reduce_all", "type": "tf.math", "text": "\nComputes the \"logical and\" of elements across dimensions of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.reduce_any", "path": "math/reduce_any", "type": "tf.math", "text": "\nComputes the \"logical or\" of elements across dimensions of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.reduce_euclidean_norm", "path": "math/reduce_euclidean_norm", "type": "tf.math", "text": "\nComputes the Euclidean norm of elements across dimensions of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.reduce_logsumexp", "path": "math/reduce_logsumexp", "type": "tf.math", "text": "\nComputes log(sum(exp(elements across dimensions of a tensor))).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.reduce_max", "path": "math/reduce_max", "type": "tf.math", "text": "\nComputes the maximum of elements across dimensions of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.reduce_mean", "path": "math/reduce_mean", "type": "tf.math", "text": "\nComputes the mean of elements across dimensions of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.reduce_min", "path": "math/reduce_min", "type": "tf.math", "text": "\nComputes the minimum of elements across dimensions of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.reduce_prod", "path": "math/reduce_prod", "type": "tf.math", "text": "\nComputes the product of elements across dimensions of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.reduce_std", "path": "math/reduce_std", "type": "tf.math", "text": "\nComputes the standard deviation of elements across dimensions of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.reduce_sum", "path": "math/reduce_sum", "type": "tf.math", "text": "\nComputes the sum of elements across dimensions of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.reduce_variance", "path": "math/reduce_variance", "type": "tf.math", "text": "\nComputes the variance of elements across dimensions of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.rint", "path": "math/rint", "type": "tf.math", "text": "\nReturns element-wise integer closest to x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.round", "path": "math/round", "type": "tf.math", "text": "\nRounds the values of a tensor to the nearest integer, element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.rsqrt", "path": "math/rsqrt", "type": "tf.math", "text": "\nComputes reciprocal of square root of x element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.scalar_mul", "path": "math/scalar_mul", "type": "tf.math", "text": "\nMultiplies a scalar times a `Tensor` or `IndexedSlices` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.segment_max", "path": "math/segment_max", "type": "tf.math", "text": "\nComputes the maximum along segments of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.segment_mean", "path": "math/segment_mean", "type": "tf.math", "text": "\nComputes the mean along segments of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.segment_min", "path": "math/segment_min", "type": "tf.math", "text": "\nComputes the minimum along segments of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.segment_prod", "path": "math/segment_prod", "type": "tf.math", "text": "\nComputes the product along segments of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.segment_sum", "path": "math/segment_sum", "type": "tf.math", "text": "\nComputes the sum along segments of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.sigmoid", "path": "math/sigmoid", "type": "tf.math", "text": "\nComputes sigmoid of `x` element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.sign", "path": "math/sign", "type": "tf.math", "text": "\nReturns an element-wise indication of the sign of a number.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.sin", "path": "math/sin", "type": "tf.math", "text": "\nComputes sine of x element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.sinh", "path": "math/sinh", "type": "tf.math", "text": "\nComputes hyperbolic sine of x element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.sobol_sample", "path": "math/sobol_sample", "type": "tf.math", "text": "\nGenerates points from the Sobol sequence.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.softplus", "path": "math/softplus", "type": "tf.math", "text": "\nComputes softplus: `log(exp(features) + 1)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.special", "path": "math/special", "type": "tf.math", "text": "\nPublic API for tf.math.special namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.special.bessel_j0", "path": "math/special/bessel_j0", "type": "tf.math", "text": "\nComputes the Bessel j0 function of `x` element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.special.bessel_j1", "path": "math/special/bessel_j1", "type": "tf.math", "text": "\nComputes the Bessel j1 function of `x` element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.special.bessel_k0", "path": "math/special/bessel_k0", "type": "tf.math", "text": "\nComputes the Bessel k0 function of `x` element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.special.bessel_k0e", "path": "math/special/bessel_k0e", "type": "tf.math", "text": "\nComputes the Bessel k0e function of `x` element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.special.bessel_k1", "path": "math/special/bessel_k1", "type": "tf.math", "text": "\nComputes the Bessel k1 function of `x` element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.special.bessel_k1e", "path": "math/special/bessel_k1e", "type": "tf.math", "text": "\nComputes the Bessel k1e function of `x` element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.special.bessel_y0", "path": "math/special/bessel_y0", "type": "tf.math", "text": "\nComputes the Bessel y0 function of `x` element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.special.bessel_y1", "path": "math/special/bessel_y1", "type": "tf.math", "text": "\nComputes the Bessel y1 function of `x` element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.special.dawsn", "path": "math/special/dawsn", "type": "tf.math", "text": "\nComputes Dawson's integral of `x` element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.special.expint", "path": "math/special/expint", "type": "tf.math", "text": "\nComputes the Exponential integral of `x` element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.special.fresnel_cos", "path": "math/special/fresnel_cos", "type": "tf.math", "text": "\nComputes Fresnel's cosine integral of `x` element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.special.fresnel_sin", "path": "math/special/fresnel_sin", "type": "tf.math", "text": "\nComputes Fresnel's sine integral of `x` element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.special.spence", "path": "math/special/spence", "type": "tf.math", "text": "\nComputes Spence's integral of `x` element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.sqrt", "path": "math/sqrt", "type": "tf.math", "text": "\nComputes element-wise square root of the input tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.square", "path": "math/square", "type": "tf.math", "text": "\nComputes square of x element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.squared_difference", "path": "math/squared_difference", "type": "tf.math", "text": "\nReturns conj(x - y)(x - y) element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.subtract", "path": "math/subtract", "type": "tf.math", "text": "\nReturns x - y element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.tan", "path": "math/tan", "type": "tf.math", "text": "\nComputes tan of x element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.tanh", "path": "math/tanh", "type": "tf.math", "text": "\nComputes hyperbolic tangent of `x` element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.top_k", "path": "math/top_k", "type": "tf.math", "text": "\nFinds values and indices of the `k` largest entries for the last dimension.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.truediv", "path": "math/truediv", "type": "tf.math", "text": "\nDivides x / y elementwise (using Python 3 division operator semantics).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.unsorted_segment_max", "path": "math/unsorted_segment_max", "type": "tf.math", "text": "\nComputes the maximum along segments of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.unsorted_segment_mean", "path": "math/unsorted_segment_mean", "type": "tf.math", "text": "\nComputes the mean along segments of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.unsorted_segment_min", "path": "math/unsorted_segment_min", "type": "tf.math", "text": "\nComputes the minimum along segments of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.unsorted_segment_prod", "path": "math/unsorted_segment_prod", "type": "tf.math", "text": "\nComputes the product along segments of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.unsorted_segment_sqrt_n", "path": "math/unsorted_segment_sqrt_n", "type": "tf.math", "text": "\nComputes the sum along segments of a tensor divided by the sqrt(N).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.unsorted_segment_sum", "path": "math/unsorted_segment_sum", "type": "tf.math", "text": "\nComputes the sum along segments of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.xdivy", "path": "math/xdivy", "type": "tf.math", "text": "\nReturns 0 if x == 0, and x / y otherwise, elementwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.xlog1py", "path": "math/xlog1py", "type": "tf.math", "text": "\nCompute x * log1p(y).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.xlogy", "path": "math/xlogy", "type": "tf.math", "text": "\nReturns 0 if x == 0, and x * log(y) otherwise, elementwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.zero_fraction", "path": "math/zero_fraction", "type": "tf.math", "text": "\nReturns the fraction of zeros in `value`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.math.zeta", "path": "math/zeta", "type": "tf.math", "text": "\nCompute the Hurwitz zeta function \\\\(\\zeta(x, q)\\\\).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.meshgrid", "path": "meshgrid", "type": "tf", "text": "\nBroadcasts parameters for evaluation on an N-D grid.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.mixed_precision", "path": "mixed_precision", "type": "tf.mixed_precision", "text": "\nPublic API for tf.mixed_precision namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.mixed_precision.experimental", "path": "mixed_precision/experimental", "type": "tf.mixed_precision", "text": "\nPublic API for tf.mixed_precision.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.mixed_precision.experimental.DynamicLossScale", "path": "mixed_precision/experimental/dynamiclossscale", "type": "tf.mixed_precision", "text": "\nLoss scale that dynamically adjusts itself.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.mixed_precision.experimental.FixedLossScale", "path": "mixed_precision/experimental/fixedlossscale", "type": "tf.mixed_precision", "text": "\nLoss scale with a fixed value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.mixed_precision.experimental.LossScale", "path": "mixed_precision/experimental/lossscale", "type": "tf.mixed_precision", "text": "\nBase class for all TF1 loss scales.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.mlir", "path": "mlir", "type": "tf.mlir", "text": "\nPublic API for tf.mlir namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.mlir.experimental", "path": "mlir/experimental", "type": "tf.mlir", "text": "\nPublic API for tf.mlir.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.mlir.experimental.convert_function", "path": "mlir/experimental/convert_function", "type": "tf.mlir", "text": "\nImport a ConcreteFunction and convert it to a textual MLIR module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.mlir.experimental.convert_graph_def", "path": "mlir/experimental/convert_graph_def", "type": "tf.mlir", "text": "\nImport a GraphDef and convert it to a textual MLIR module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.Module", "path": "module", "type": "tf", "text": "\nBase neural network module class.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.name_scope", "path": "name_scope", "type": "tf", "text": "\nA context manager for use when defining a Python op.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nest", "path": "nest", "type": "tf.nest", "text": "\nPublic API for tf.nest namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nest.assert_same_structure", "path": "nest/assert_same_structure", "type": "tf.nest", "text": "\nAsserts that two structures are nested in the same way.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nest.flatten", "path": "nest/flatten", "type": "tf.nest", "text": "\nReturns a flat list from a given nested structure.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nest.is_nested", "path": "nest/is_nested", "type": "tf.nest", "text": "\nReturns true if its input is a collections.abc.Sequence (except strings).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nest.map_structure", "path": "nest/map_structure", "type": "tf.nest", "text": "\nApplies `func` to each entry in `structure` and returns a new structure.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nest.pack_sequence_as", "path": "nest/pack_sequence_as", "type": "tf.nest", "text": "\nReturns a given flattened sequence packed into a given structure.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn", "path": "nn", "type": "tf.nn", "text": "\nWrappers for primitive Neural Net (NN) Operations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.atrous_conv2d", "path": "nn/atrous_conv2d", "type": "tf.nn", "text": "\nAtrous convolution (a.k.a. convolution with holes or dilated convolution).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.atrous_conv2d_transpose", "path": "nn/atrous_conv2d_transpose", "type": "tf.nn", "text": "\nThe transpose of `atrous_conv2d`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.avg_pool", "path": "nn/avg_pool", "type": "tf.nn", "text": "\nPerforms the avg pooling on the input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.avg_pool1d", "path": "nn/avg_pool1d", "type": "tf.nn", "text": "\nPerforms the average pooling on the input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.avg_pool2d", "path": "nn/avg_pool2d", "type": "tf.nn", "text": "\nPerforms the average pooling on the input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.avg_pool3d", "path": "nn/avg_pool3d", "type": "tf.nn", "text": "\nPerforms the average pooling on the input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.batch_normalization", "path": "nn/batch_normalization", "type": "tf.nn", "text": "\nBatch normalization.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.batch_norm_with_global_normalization", "path": "nn/batch_norm_with_global_normalization", "type": "tf.nn", "text": "\nBatch normalization.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.bias_add", "path": "nn/bias_add", "type": "tf.nn", "text": "\nAdds `bias` to `value`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.collapse_repeated", "path": "nn/collapse_repeated", "type": "tf.nn", "text": "\nMerge repeated labels into single labels.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.compute_accidental_hits", "path": "nn/compute_accidental_hits", "type": "tf.nn", "text": "\nCompute the position ids in `sampled_candidates` matching `true_classes`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.compute_average_loss", "path": "nn/compute_average_loss", "type": "tf.nn", "text": "\nScales per-example losses with sample_weights and computes their average.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.conv1d", "path": "nn/conv1d", "type": "tf.nn", "text": "\nComputes a 1-D convolution given 3-D input and filter tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.conv1d_transpose", "path": "nn/conv1d_transpose", "type": "tf.nn", "text": "\nThe transpose of `conv1d`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.conv2d", "path": "nn/conv2d", "type": "tf.nn", "text": "\nComputes a 2-D convolution given `input` and 4-D `filters` tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.conv2d_transpose", "path": "nn/conv2d_transpose", "type": "tf.nn", "text": "\nThe transpose of `conv2d`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.conv3d", "path": "nn/conv3d", "type": "tf.nn", "text": "\nComputes a 3-D convolution given 5-D `input` and `filters` tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.conv3d_transpose", "path": "nn/conv3d_transpose", "type": "tf.nn", "text": "\nThe transpose of `conv3d`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.convolution", "path": "nn/convolution", "type": "tf.nn", "text": "\nComputes sums of N-D convolutions (actually cross-correlation).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.conv_transpose", "path": "nn/conv_transpose", "type": "tf.nn", "text": "\nThe transpose of `convolution`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.crelu", "path": "nn/crelu", "type": "tf.nn", "text": "\nComputes Concatenated ReLU.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.ctc_beam_search_decoder", "path": "nn/ctc_beam_search_decoder", "type": "tf.nn", "text": "\nPerforms beam search decoding on the logits given in input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.ctc_greedy_decoder", "path": "nn/ctc_greedy_decoder", "type": "tf.nn", "text": "\nPerforms greedy decoding on the logits given in input (best path).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.ctc_loss", "path": "nn/ctc_loss", "type": "tf.nn", "text": "\nComputes CTC (Connectionist Temporal Classification) loss.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.ctc_unique_labels", "path": "nn/ctc_unique_labels", "type": "tf.nn", "text": "\nGet unique labels and indices for batched labels for `tf.nn.ctc_loss`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.depthwise_conv2d", "path": "nn/depthwise_conv2d", "type": "tf.nn", "text": "\nDepthwise 2-D convolution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.depthwise_conv2d_backprop_filter", "path": "nn/depthwise_conv2d_backprop_filter", "type": "tf.nn", "text": "\nComputes the gradients of depthwise convolution with respect to the filter.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.depthwise_conv2d_backprop_input", "path": "nn/depthwise_conv2d_backprop_input", "type": "tf.nn", "text": "\nComputes the gradients of depthwise convolution with respect to the input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.depth_to_space", "path": "nn/depth_to_space", "type": "tf.nn", "text": "\nDepthToSpace for tensors of type T.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.dilation2d", "path": "nn/dilation2d", "type": "tf.nn", "text": "\nComputes the grayscale dilation of 4-D `input` and 3-D `filters` tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.dropout", "path": "nn/dropout", "type": "tf.nn", "text": "\nComputes dropout: randomly sets elements to zero to prevent overfitting.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.elu", "path": "nn/elu", "type": "tf.nn", "text": "\nComputes exponential linear: `exp(features) - 1` if < 0, `features` otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.embedding_lookup", "path": "nn/embedding_lookup", "type": "tf.nn", "text": "\nLooks up embeddings for the given `ids` from a list of tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.embedding_lookup_sparse", "path": "nn/embedding_lookup_sparse", "type": "tf.nn", "text": "\nLooks up embeddings for the given ids and weights from a list of tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.erosion2d", "path": "nn/erosion2d", "type": "tf.nn", "text": "\nComputes the grayscale erosion of 4-D `value` and 3-D `filters` tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.fractional_avg_pool", "path": "nn/fractional_avg_pool", "type": "tf.nn", "text": "\nPerforms fractional average pooling on the input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.fractional_max_pool", "path": "nn/fractional_max_pool", "type": "tf.nn", "text": "\nPerforms fractional max pooling on the input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.gelu", "path": "nn/gelu", "type": "tf.nn", "text": "\nCompute the Gaussian Error Linear Unit (GELU) activation function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.isotonic_regression", "path": "nn/isotonic_regression", "type": "tf.nn", "text": "\nSolves isotonic regression problems along the given axis.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.l2_loss", "path": "nn/l2_loss", "type": "tf.nn", "text": "\nL2 Loss.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.leaky_relu", "path": "nn/leaky_relu", "type": "tf.nn", "text": "\nCompute the Leaky ReLU activation function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.local_response_normalization", "path": "nn/local_response_normalization", "type": "tf.nn", "text": "\nLocal Response Normalization.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.log_poisson_loss", "path": "nn/log_poisson_loss", "type": "tf.nn", "text": "\nComputes log Poisson loss given `log_input`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.log_softmax", "path": "nn/log_softmax", "type": "tf.nn", "text": "\nComputes log softmax activations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.max_pool", "path": "nn/max_pool", "type": "tf.nn", "text": "\nPerforms the max pooling on the input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.max_pool1d", "path": "nn/max_pool1d", "type": "tf.nn", "text": "\nPerforms the max pooling on the input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.max_pool2d", "path": "nn/max_pool2d", "type": "tf.nn", "text": "\nPerforms the max pooling on the input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.max_pool3d", "path": "nn/max_pool3d", "type": "tf.nn", "text": "\nPerforms the max pooling on the input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.max_pool_with_argmax", "path": "nn/max_pool_with_argmax", "type": "tf.nn", "text": "\nPerforms max pooling on the input and outputs both max values and indices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.moments", "path": "nn/moments", "type": "tf.nn", "text": "\nCalculates the mean and variance of `x`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.nce_loss", "path": "nn/nce_loss", "type": "tf.nn", "text": "\nComputes and returns the noise-contrastive estimation training loss.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.normalize_moments", "path": "nn/normalize_moments", "type": "tf.nn", "text": "\nCalculate the mean and variance of based on the sufficient statistics.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.pool", "path": "nn/pool", "type": "tf.nn", "text": "\nPerforms an N-D pooling operation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.relu", "path": "nn/relu", "type": "tf.nn", "text": "\nComputes rectified linear: `max(features, 0)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.relu6", "path": "nn/relu6", "type": "tf.nn", "text": "\nComputes Rectified Linear 6: `min(max(features, 0), 6)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.RNNCellDeviceWrapper", "path": "nn/rnncelldevicewrapper", "type": "tf.nn", "text": "\nOperator that ensures an RNNCell runs on a particular device.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.RNNCellDropoutWrapper", "path": "nn/rnncelldropoutwrapper", "type": "tf.nn", "text": "\nOperator adding dropout to inputs and outputs of the given cell.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.RNNCellResidualWrapper", "path": "nn/rnncellresidualwrapper", "type": "tf.nn", "text": "\nRNNCell wrapper that ensures cell inputs are added to the outputs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.safe_embedding_lookup_sparse", "path": "nn/safe_embedding_lookup_sparse", "type": "tf.nn", "text": "\nLookup embedding results, accounting for invalid IDs and empty features.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.sampled_softmax_loss", "path": "nn/sampled_softmax_loss", "type": "tf.nn", "text": "\nComputes and returns the sampled softmax training loss.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.scale_regularization_loss", "path": "nn/scale_regularization_loss", "type": "tf.nn", "text": "\nScales the sum of the given regularization losses by number of replicas.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.selu", "path": "nn/selu", "type": "tf.nn", "text": "\nComputes scaled exponential linear: `scale * alpha * (exp(features) - 1)`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.separable_conv2d", "path": "nn/separable_conv2d", "type": "tf.nn", "text": "\n2-D convolution with separable filters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.sigmoid_cross_entropy_with_logits", "path": "nn/sigmoid_cross_entropy_with_logits", "type": "tf.nn", "text": "\nComputes sigmoid cross entropy given `logits`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.silu", "path": "nn/silu", "type": "tf.nn", "text": "\nComputes the SiLU or Swish activation function: `x * sigmoid(x)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.softmax", "path": "nn/softmax", "type": "tf.nn", "text": "\nComputes softmax activations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.softmax_cross_entropy_with_logits", "path": "nn/softmax_cross_entropy_with_logits", "type": "tf.nn", "text": "\nComputes softmax cross entropy between `logits` and `labels`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.softsign", "path": "nn/softsign", "type": "tf.nn", "text": "\nComputes softsign: `features / (abs(features) + 1)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.space_to_depth", "path": "nn/space_to_depth", "type": "tf.nn", "text": "\nSpaceToDepth for tensors of type T.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.sparse_softmax_cross_entropy_with_logits", "path": "nn/sparse_softmax_cross_entropy_with_logits", "type": "tf.nn", "text": "\nComputes sparse softmax cross entropy between `logits` and `labels`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.sufficient_statistics", "path": "nn/sufficient_statistics", "type": "tf.nn", "text": "\nCalculate the sufficient statistics for the mean and variance of `x`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.weighted_cross_entropy_with_logits", "path": "nn/weighted_cross_entropy_with_logits", "type": "tf.nn", "text": "\nComputes a weighted cross entropy.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.weighted_moments", "path": "nn/weighted_moments", "type": "tf.nn", "text": "\nReturns the frequency-weighted mean and variance of `x`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nn.with_space_to_batch", "path": "nn/with_space_to_batch", "type": "tf.nn", "text": "\nPerforms `op` on the space-to-batch representation of `input`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.nondifferentiable_batch_function", "path": "nondifferentiable_batch_function", "type": "tf", "text": "\nBatches the computation done by the decorated function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.norm", "path": "norm", "type": "tf", "text": "\nComputes the norm of vectors, matrices, and tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.no_gradient", "path": "no_gradient", "type": "tf", "text": "\nSpecifies that ops of type `op_type` is not differentiable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.no_op", "path": "no_op", "type": "tf", "text": "\nDoes nothing. Only useful as a placeholder for control edges.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.numpy_function", "path": "numpy_function", "type": "tf", "text": "\nWraps a python function and uses it as a TensorFlow op.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.ones", "path": "ones", "type": "tf", "text": "\nCreates a tensor with all elements set to one (1).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.ones_initializer", "path": "ones_initializer", "type": "tf", "text": "\nInitializer that generates tensors initialized to 1.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.ones_like", "path": "ones_like", "type": "tf", "text": "\nCreates a tensor of all ones that has the same shape as the input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.one_hot", "path": "one_hot", "type": "tf", "text": "\nReturns a one-hot tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.Operation", "path": "operation", "type": "tf", "text": "\nRepresents a graph node that performs computation on tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.OptionalSpec", "path": "optionalspec", "type": "tf", "text": "\nType specification for `tf.experimental.Optional`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.pad", "path": "pad", "type": "tf", "text": "\nPads a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.parallel_stack", "path": "parallel_stack", "type": "tf", "text": "\nStacks a list of rank-`R` tensors into one rank-`(R+1)` tensor in parallel.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.print", "path": "print", "type": "tf", "text": "\nPrint the specified inputs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.profiler", "path": "profiler", "type": "tf.profiler", "text": "\nPublic API for tf.profiler namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.profiler.experimental", "path": "profiler/experimental", "type": "tf.profiler", "text": "\nPublic API for tf.profiler.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.profiler.experimental.client", "path": "profiler/experimental/client", "type": "tf.profiler", "text": "\nPublic API for tf.profiler.experimental.client namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.profiler.experimental.client.monitor", "path": "profiler/experimental/client/monitor", "type": "tf.profiler", "text": "\nSends grpc requests to profiler server to perform on-demand monitoring.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.profiler.experimental.client.trace", "path": "profiler/experimental/client/trace", "type": "tf.profiler", "text": "\nSends gRPC requests to one or more profiler servers to perform on-demand\nprofiling.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.profiler.experimental.Profile", "path": "profiler/experimental/profile", "type": "tf.profiler", "text": "\nContext-manager profile API.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.profiler.experimental.ProfilerOptions", "path": "profiler/experimental/profileroptions", "type": "tf.profiler", "text": "\nOptions for finer control over the profiler.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.profiler.experimental.server", "path": "profiler/experimental/server", "type": "tf.profiler", "text": "\nPublic API for tf.profiler.experimental.server namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.profiler.experimental.server.start", "path": "profiler/experimental/server/start", "type": "tf.profiler", "text": "\nStart a profiler grpc server that listens to given port.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.profiler.experimental.start", "path": "profiler/experimental/start", "type": "tf.profiler", "text": "\nStart profiling TensorFlow performance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.profiler.experimental.stop", "path": "profiler/experimental/stop", "type": "tf.profiler", "text": "\nStops the current profiling session.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.profiler.experimental.Trace", "path": "profiler/experimental/trace", "type": "tf.profiler", "text": "\nContext manager that generates a trace event in the profiler.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.py_function", "path": "py_function", "type": "tf", "text": "\nWraps a python function into a TensorFlow op that executes it eagerly.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.quantization", "path": "quantization", "type": "tf.quantization", "text": "\nPublic API for tf.quantization namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.quantization.dequantize", "path": "quantization/dequantize", "type": "tf.quantization", "text": "\nDequantize the 'input' tensor into a float or bfloat16 Tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.quantization.fake_quant_with_min_max_args", "path": "quantization/fake_quant_with_min_max_args", "type": "tf.quantization", "text": "\nFake-quantize the 'inputs' tensor, type float to 'outputs' tensor of same\ntype.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.quantization.fake_quant_with_min_max_args_gradient", "path": "quantization/fake_quant_with_min_max_args_gradient", "type": "tf.quantization", "text": "\nCompute gradients for a FakeQuantWithMinMaxArgs operation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.quantization.fake_quant_with_min_max_vars", "path": "quantization/fake_quant_with_min_max_vars", "type": "tf.quantization", "text": "\nFake-quantize the 'inputs' tensor of type float via global float scalars\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.quantization.fake_quant_with_min_max_vars_gradient", "path": "quantization/fake_quant_with_min_max_vars_gradient", "type": "tf.quantization", "text": "\nCompute gradients for a FakeQuantWithMinMaxVars operation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.quantization.fake_quant_with_min_max_vars_per_channel", "path": "quantization/fake_quant_with_min_max_vars_per_channel", "type": "tf.quantization", "text": "\nFake-quantize the 'inputs' tensor of type float via per-channel floats\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.quantization.fake_quant_with_min_max_vars_per_channel_gradient", "path": "quantization/fake_quant_with_min_max_vars_per_channel_gradient", "type": "tf.quantization", "text": "\nCompute gradients for a FakeQuantWithMinMaxVarsPerChannel operation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.quantization.quantize", "path": "quantization/quantize", "type": "tf.quantization", "text": "\nQuantize the 'input' tensor of type float to 'output' tensor of type 'T'.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.quantization.quantized_concat", "path": "quantization/quantized_concat", "type": "tf.quantization", "text": "\nConcatenates quantized tensors along one dimension.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.quantization.quantize_and_dequantize", "path": "quantization/quantize_and_dequantize", "type": "tf.quantization", "text": "\nQuantizes then dequantizes a tensor. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.quantization.quantize_and_dequantize_v2", "path": "quantization/quantize_and_dequantize_v2", "type": "tf.quantization", "text": "\nQuantizes then dequantizes a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.quantize_and_dequantize_v4", "path": "quantize_and_dequantize_v4", "type": "tf", "text": "\nReturns the gradient of `QuantizeAndDequantizeV4`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.queue", "path": "queue", "type": "tf.queue", "text": "\nPublic API for tf.queue namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.queue.FIFOQueue", "path": "queue/fifoqueue", "type": "tf.queue", "text": "\nA queue implementation that dequeues elements in first-in first-out order.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.queue.PaddingFIFOQueue", "path": "queue/paddingfifoqueue", "type": "tf.queue", "text": "\nA FIFOQueue that supports batching variable-sized tensors by padding.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.queue.PriorityQueue", "path": "queue/priorityqueue", "type": "tf.queue", "text": "\nA queue implementation that dequeues elements in prioritized order.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.queue.QueueBase", "path": "queue/queuebase", "type": "tf.queue", "text": "\nBase class for queue implementations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.queue.RandomShuffleQueue", "path": "queue/randomshufflequeue", "type": "tf.queue", "text": "\nA queue implementation that dequeues elements in a random order.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.ragged", "path": "ragged", "type": "tf.ragged", "text": "\nRagged Tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.ragged.boolean_mask", "path": "ragged/boolean_mask", "type": "tf.ragged", "text": "\nApplies a boolean mask to `data` without flattening the mask dimensions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.ragged.constant", "path": "compat/v1/ragged/constant", "type": "tf.compat", "text": "\nConstructs a constant RaggedTensor from a nested Python list.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.ragged.constant", "path": "ragged/constant", "type": "tf.ragged", "text": "\nConstructs a constant RaggedTensor from a nested Python list.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.ragged.cross", "path": "ragged/cross", "type": "tf.ragged", "text": "\nGenerates feature cross from a list of tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.ragged.cross_hashed", "path": "ragged/cross_hashed", "type": "tf.ragged", "text": "\nGenerates hashed feature cross from a list of tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.ragged.map_flat_values", "path": "ragged/map_flat_values", "type": "tf.ragged", "text": "\nApplies `op` to the values of one or more RaggedTensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.ragged.range", "path": "ragged/range", "type": "tf.ragged", "text": "\nReturns a `RaggedTensor` containing the specified sequences of numbers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.ragged.row_splits_to_segment_ids", "path": "ragged/row_splits_to_segment_ids", "type": "tf.ragged", "text": "\nGenerates the segmentation corresponding to a RaggedTensor `row_splits`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.ragged.segment_ids_to_row_splits", "path": "ragged/segment_ids_to_row_splits", "type": "tf.ragged", "text": "\nGenerates the RaggedTensor `row_splits` corresponding to a segmentation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.ragged.stack", "path": "ragged/stack", "type": "tf.ragged", "text": "\nStacks a list of rank-`R` tensors into one rank-`(R+1)` `RaggedTensor`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.ragged.stack_dynamic_partitions", "path": "ragged/stack_dynamic_partitions", "type": "tf.ragged", "text": "\nStacks dynamic partitions of a Tensor or RaggedTensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.RaggedTensor", "path": "raggedtensor", "type": "tf", "text": "\nRepresents a ragged tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.RaggedTensorSpec", "path": "raggedtensorspec", "type": "tf", "text": "\nType specification for a `tf.RaggedTensor`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.random", "path": "random", "type": "tf.random", "text": "\nPublic API for tf.random namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.random.Algorithm", "path": "random/algorithm", "type": "tf.random", "text": "\nAn enumeration.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.random.all_candidate_sampler", "path": "random/all_candidate_sampler", "type": "tf.random", "text": "\nGenerate the set of all classes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.random.categorical", "path": "random/categorical", "type": "tf.random", "text": "\nDraws samples from a categorical distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.random.create_rng_state", "path": "random/create_rng_state", "type": "tf.random", "text": "\nCreates a RNG state from an integer or a vector.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.random.experimental", "path": "random/experimental", "type": "tf.random", "text": "\nPublic API for tf.random.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.random.experimental.stateless_fold_in", "path": "random/experimental/stateless_fold_in", "type": "tf.random", "text": "\nFolds in data to an RNG seed to form a new RNG seed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.random.experimental.stateless_split", "path": "random/experimental/stateless_split", "type": "tf.random", "text": "\nSplits an RNG seed into `num` new seeds by adding a leading axis.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.random.fixed_unigram_candidate_sampler", "path": "random/fixed_unigram_candidate_sampler", "type": "tf.random", "text": "\nSamples a set of classes using the provided (fixed) base distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.random.gamma", "path": "random/gamma", "type": "tf.random", "text": "\nDraws `shape` samples from each of the given Gamma distribution(s).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.random.Generator", "path": "random/generator", "type": "tf.random", "text": "\nRandom-number generator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.random.get_global_generator", "path": "random/get_global_generator", "type": "tf.random", "text": "\nRetrieves the global generator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.random.learned_unigram_candidate_sampler", "path": "random/learned_unigram_candidate_sampler", "type": "tf.random", "text": "\nSamples a set of classes from a distribution learned during training.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.random.log_uniform_candidate_sampler", "path": "random/log_uniform_candidate_sampler", "type": "tf.random", "text": "\nSamples a set of classes using a log-uniform (Zipfian) base distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.random.normal", "path": "random/normal", "type": "tf.random", "text": "\nOutputs random values from a normal distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.random.poisson", "path": "random/poisson", "type": "tf.random", "text": "\nDraws `shape` samples from each of the given Poisson distribution(s).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.random.set_global_generator", "path": "random/set_global_generator", "type": "tf.random", "text": "\nReplaces the global generator with another `Generator` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.random.set_seed", "path": "random/set_seed", "type": "tf.random", "text": "\nSets the global random seed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.random.shuffle", "path": "random/shuffle", "type": "tf.random", "text": "\nRandomly shuffles a tensor along its first dimension.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.random.stateless_binomial", "path": "random/stateless_binomial", "type": "tf.random", "text": "\nOutputs deterministic pseudorandom values from a binomial distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.random.stateless_categorical", "path": "random/stateless_categorical", "type": "tf.random", "text": "\nDraws deterministic pseudorandom samples from a categorical distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.random.stateless_gamma", "path": "random/stateless_gamma", "type": "tf.random", "text": "\nOutputs deterministic pseudorandom values from a gamma distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.random.stateless_normal", "path": "random/stateless_normal", "type": "tf.random", "text": "\nOutputs deterministic pseudorandom values from a normal distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.random.stateless_parameterized_truncated_normal", "path": "random/stateless_parameterized_truncated_normal", "type": "tf.random", "text": "\nOutputs random values from a truncated normal distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.random.stateless_poisson", "path": "random/stateless_poisson", "type": "tf.random", "text": "\nOutputs deterministic pseudorandom values from a Poisson distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.random.stateless_truncated_normal", "path": "random/stateless_truncated_normal", "type": "tf.random", "text": "\nOutputs deterministic pseudorandom values, truncated normally distributed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.random.stateless_uniform", "path": "random/stateless_uniform", "type": "tf.random", "text": "\nOutputs deterministic pseudorandom values from a uniform distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.random.truncated_normal", "path": "random/truncated_normal", "type": "tf.random", "text": "\nOutputs random values from a truncated normal distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.random.uniform", "path": "random/uniform", "type": "tf.random", "text": "\nOutputs random values from a uniform distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.random.uniform_candidate_sampler", "path": "random/uniform_candidate_sampler", "type": "tf.random", "text": "\nSamples a set of classes using a uniform base distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.random_normal_initializer", "path": "random_normal_initializer", "type": "tf.random", "text": "\nInitializer that generates tensors with a normal distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.random_uniform_initializer", "path": "random_uniform_initializer", "type": "tf.random", "text": "\nInitializer that generates tensors with a uniform distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.range", "path": "range", "type": "tf", "text": "\nCreates a sequence of numbers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.rank", "path": "rank", "type": "tf", "text": "\nReturns the rank of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops", "path": "raw_ops", "type": "tf.raw_ops", "text": "\nPublic API for tf.raw_ops namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Abort", "path": "raw_ops/abort", "type": "tf.raw_ops", "text": "\nRaise a exception to abort the process when called.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Abs", "path": "raw_ops/abs", "type": "tf.raw_ops", "text": "\nComputes the absolute value of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.AccumulateNV2", "path": "raw_ops/accumulatenv2", "type": "tf.raw_ops", "text": "\nReturns the element-wise sum of a list of tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.AccumulatorApplyGradient", "path": "raw_ops/accumulatorapplygradient", "type": "tf.raw_ops", "text": "\nApplies a gradient to a given accumulator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.AccumulatorNumAccumulated", "path": "raw_ops/accumulatornumaccumulated", "type": "tf.raw_ops", "text": "\nReturns the number of gradients aggregated in the given accumulators.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.AccumulatorSetGlobalStep", "path": "raw_ops/accumulatorsetglobalstep", "type": "tf.raw_ops", "text": "\nUpdates the accumulator with a new value for global_step.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.AccumulatorTakeGradient", "path": "raw_ops/accumulatortakegradient", "type": "tf.raw_ops", "text": "\nExtracts the average gradient in the given ConditionalAccumulator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Acos", "path": "raw_ops/acos", "type": "tf.raw_ops", "text": "\nComputes acos of x element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Acosh", "path": "raw_ops/acosh", "type": "tf.raw_ops", "text": "\nComputes inverse hyperbolic cosine of x element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Add", "path": "raw_ops/add", "type": "tf.raw_ops", "text": "\nReturns x + y element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.AddManySparseToTensorsMap", "path": "raw_ops/addmanysparsetotensorsmap", "type": "tf.raw_ops", "text": "\nAdd an `N`-minibatch `SparseTensor` to a `SparseTensorsMap`, return `N`\nhandles.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.AddN", "path": "raw_ops/addn", "type": "tf.raw_ops", "text": "\nAdd all input tensors element wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.AddSparseToTensorsMap", "path": "raw_ops/addsparsetotensorsmap", "type": "tf.raw_ops", "text": "\nAdd a `SparseTensor` to a `SparseTensorsMap` return its handle.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.AddV2", "path": "raw_ops/addv2", "type": "tf.raw_ops", "text": "\nReturns x + y element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.AdjustContrast", "path": "raw_ops/adjustcontrast", "type": "tf.raw_ops", "text": "\nDeprecated. Disallowed in GraphDef version >= 2.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.AdjustContrastv2", "path": "raw_ops/adjustcontrastv2", "type": "tf.raw_ops", "text": "\nAdjust the contrast of one or more images.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.AdjustHue", "path": "raw_ops/adjusthue", "type": "tf.raw_ops", "text": "\nAdjust the hue of one or more images.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.AdjustSaturation", "path": "raw_ops/adjustsaturation", "type": "tf.raw_ops", "text": "\nAdjust the saturation of one or more images.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.All", "path": "raw_ops/all", "type": "tf.raw_ops", "text": "\nComputes the \"logical and\" of elements across dimensions of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.AllCandidateSampler", "path": "raw_ops/allcandidatesampler", "type": "tf.raw_ops", "text": "\nGenerates labels for candidate sampling with a learned unigram distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.AllToAll", "path": "raw_ops/alltoall", "type": "tf.raw_ops", "text": "\nAn Op to exchange data across TPU replicas.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Angle", "path": "raw_ops/angle", "type": "tf.raw_ops", "text": "\nReturns the argument of a complex number.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.AnonymousIterator", "path": "raw_ops/anonymousiterator", "type": "tf.raw_ops", "text": "\nA container for an iterator resource.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.AnonymousIteratorV2", "path": "raw_ops/anonymousiteratorv2", "type": "tf.raw_ops", "text": "\nA container for an iterator resource.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.AnonymousMemoryCache", "path": "raw_ops/anonymousmemorycache", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.AnonymousMultiDeviceIterator", "path": "raw_ops/anonymousmultideviceiterator", "type": "tf.raw_ops", "text": "\nA container for a multi device iterator resource.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.AnonymousRandomSeedGenerator", "path": "raw_ops/anonymousrandomseedgenerator", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.AnonymousSeedGenerator", "path": "raw_ops/anonymousseedgenerator", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Any", "path": "raw_ops/any", "type": "tf.raw_ops", "text": "\nComputes the \"logical or\" of elements across dimensions of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ApplyAdadelta", "path": "raw_ops/applyadadelta", "type": "tf.raw_ops", "text": "\nUpdate '*var' according to the adadelta scheme.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ApplyAdagrad", "path": "raw_ops/applyadagrad", "type": "tf.raw_ops", "text": "\nUpdate '*var' according to the adagrad scheme.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ApplyAdagradDA", "path": "raw_ops/applyadagradda", "type": "tf.raw_ops", "text": "\nUpdate '*var' according to the proximal adagrad scheme.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ApplyAdagradV2", "path": "raw_ops/applyadagradv2", "type": "tf.raw_ops", "text": "\nUpdate '*var' according to the adagrad scheme.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ApplyAdam", "path": "raw_ops/applyadam", "type": "tf.raw_ops", "text": "\nUpdate '*var' according to the Adam algorithm.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ApplyAdaMax", "path": "raw_ops/applyadamax", "type": "tf.raw_ops", "text": "\nUpdate '*var' according to the AdaMax algorithm.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ApplyAddSign", "path": "raw_ops/applyaddsign", "type": "tf.raw_ops", "text": "\nUpdate '*var' according to the AddSign update.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ApplyCenteredRMSProp", "path": "raw_ops/applycenteredrmsprop", "type": "tf.raw_ops", "text": "\nUpdate '*var' according to the centered RMSProp algorithm.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ApplyFtrl", "path": "raw_ops/applyftrl", "type": "tf.raw_ops", "text": "\nUpdate '*var' according to the Ftrl-proximal scheme.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ApplyFtrlV2", "path": "raw_ops/applyftrlv2", "type": "tf.raw_ops", "text": "\nUpdate '*var' according to the Ftrl-proximal scheme.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ApplyGradientDescent", "path": "raw_ops/applygradientdescent", "type": "tf.raw_ops", "text": "\nUpdate '*var' by subtracting 'alpha' * 'delta' from it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ApplyMomentum", "path": "raw_ops/applymomentum", "type": "tf.raw_ops", "text": "\nUpdate '*var' according to the momentum scheme.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ApplyPowerSign", "path": "raw_ops/applypowersign", "type": "tf.raw_ops", "text": "\nUpdate '*var' according to the AddSign update.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ApplyProximalAdagrad", "path": "raw_ops/applyproximaladagrad", "type": "tf.raw_ops", "text": "\nUpdate 'var' and 'accum' according to FOBOS with Adagrad learning rate.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ApplyProximalGradientDescent", "path": "raw_ops/applyproximalgradientdescent", "type": "tf.raw_ops", "text": "\nUpdate '*var' as FOBOS algorithm with fixed learning rate.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ApplyRMSProp", "path": "raw_ops/applyrmsprop", "type": "tf.raw_ops", "text": "\nUpdate '*var' according to the RMSProp algorithm.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ApproximateEqual", "path": "raw_ops/approximateequal", "type": "tf.raw_ops", "text": "\nReturns the truth value of abs(x-y) < tolerance element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ArgMax", "path": "raw_ops/argmax", "type": "tf.raw_ops", "text": "\nReturns the index with the largest value across dimensions of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ArgMin", "path": "raw_ops/argmin", "type": "tf.raw_ops", "text": "\nReturns the index with the smallest value across dimensions of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Asin", "path": "raw_ops/asin", "type": "tf.raw_ops", "text": "\nComputes the trignometric inverse sine of x element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Asinh", "path": "raw_ops/asinh", "type": "tf.raw_ops", "text": "\nComputes inverse hyperbolic sine of x element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Assert", "path": "raw_ops/assert", "type": "tf.raw_ops", "text": "\nAsserts that the given condition is true.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.AssertCardinalityDataset", "path": "raw_ops/assertcardinalitydataset", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.AssertNextDataset", "path": "raw_ops/assertnextdataset", "type": "tf.raw_ops", "text": "\nA transformation that asserts which transformations happen next.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Assign", "path": "raw_ops/assign", "type": "tf.raw_ops", "text": "\nUpdate 'ref' by assigning 'value' to it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.AssignAdd", "path": "raw_ops/assignadd", "type": "tf.raw_ops", "text": "\nUpdate 'ref' by adding 'value' to it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.AssignAddVariableOp", "path": "raw_ops/assignaddvariableop", "type": "tf.raw_ops", "text": "\nAdds a value to the current value of a variable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.AssignSub", "path": "raw_ops/assignsub", "type": "tf.raw_ops", "text": "\nUpdate 'ref' by subtracting 'value' from it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.AssignSubVariableOp", "path": "raw_ops/assignsubvariableop", "type": "tf.raw_ops", "text": "\nSubtracts a value from the current value of a variable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.AssignVariableOp", "path": "raw_ops/assignvariableop", "type": "tf.raw_ops", "text": "\nAssigns a new value to a variable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.AsString", "path": "raw_ops/asstring", "type": "tf.raw_ops", "text": "\nConverts each entry in the given tensor to strings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Atan", "path": "raw_ops/atan", "type": "tf.raw_ops", "text": "\nComputes the trignometric inverse tangent of x element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Atan2", "path": "raw_ops/atan2", "type": "tf.raw_ops", "text": "\nComputes arctangent of `y/x` element-wise, respecting signs of the arguments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Atanh", "path": "raw_ops/atanh", "type": "tf.raw_ops", "text": "\nComputes inverse hyperbolic tangent of x element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.AudioSpectrogram", "path": "raw_ops/audiospectrogram", "type": "tf.raw_ops", "text": "\nProduces a visualization of audio data over time.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.AudioSummary", "path": "raw_ops/audiosummary", "type": "tf.raw_ops", "text": "\nOutputs a `Summary` protocol buffer with audio.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.AudioSummaryV2", "path": "raw_ops/audiosummaryv2", "type": "tf.raw_ops", "text": "\nOutputs a `Summary` protocol buffer with audio.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.AutoShardDataset", "path": "raw_ops/autosharddataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that shards the input dataset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.AvgPool", "path": "raw_ops/avgpool", "type": "tf.raw_ops", "text": "\nPerforms average pooling on the input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.AvgPool3D", "path": "raw_ops/avgpool3d", "type": "tf.raw_ops", "text": "\nPerforms 3D average pooling on the input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.AvgPool3DGrad", "path": "raw_ops/avgpool3dgrad", "type": "tf.raw_ops", "text": "\nComputes gradients of average pooling function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.AvgPoolGrad", "path": "raw_ops/avgpoolgrad", "type": "tf.raw_ops", "text": "\nComputes gradients of the average pooling function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BandedTriangularSolve", "path": "raw_ops/bandedtriangularsolve", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Barrier", "path": "raw_ops/barrier", "type": "tf.raw_ops", "text": "\nDefines a barrier that persists across different graph executions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BarrierClose", "path": "raw_ops/barrierclose", "type": "tf.raw_ops", "text": "\nCloses the given barrier.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BarrierIncompleteSize", "path": "raw_ops/barrierincompletesize", "type": "tf.raw_ops", "text": "\nComputes the number of incomplete elements in the given barrier.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BarrierInsertMany", "path": "raw_ops/barrierinsertmany", "type": "tf.raw_ops", "text": "\nFor each key, assigns the respective value to the specified component.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BarrierReadySize", "path": "raw_ops/barrierreadysize", "type": "tf.raw_ops", "text": "\nComputes the number of complete elements in the given barrier.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BarrierTakeMany", "path": "raw_ops/barriertakemany", "type": "tf.raw_ops", "text": "\nTakes the given number of completed elements from a barrier.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Batch", "path": "raw_ops/batch", "type": "tf.raw_ops", "text": "\nBatches all input tensors nondeterministically.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BatchCholesky", "path": "raw_ops/batchcholesky", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BatchCholeskyGrad", "path": "raw_ops/batchcholeskygrad", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BatchDataset", "path": "raw_ops/batchdataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that batches `batch_size` elements from `input_dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BatchDatasetV2", "path": "raw_ops/batchdatasetv2", "type": "tf.raw_ops", "text": "\nCreates a dataset that batches `batch_size` elements from `input_dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BatchFFT", "path": "raw_ops/batchfft", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BatchFFT2D", "path": "raw_ops/batchfft2d", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BatchFFT3D", "path": "raw_ops/batchfft3d", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BatchFunction", "path": "raw_ops/batchfunction", "type": "tf.raw_ops", "text": "\nBatches all the inputs tensors to the computation done by the function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BatchIFFT", "path": "raw_ops/batchifft", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BatchIFFT2D", "path": "raw_ops/batchifft2d", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BatchIFFT3D", "path": "raw_ops/batchifft3d", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BatchMatMul", "path": "raw_ops/batchmatmul", "type": "tf.raw_ops", "text": "\nMultiplies slices of two tensors in batches.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BatchMatMulV2", "path": "raw_ops/batchmatmulv2", "type": "tf.raw_ops", "text": "\nMultiplies slices of two tensors in batches.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BatchMatrixBandPart", "path": "raw_ops/batchmatrixbandpart", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BatchMatrixDeterminant", "path": "raw_ops/batchmatrixdeterminant", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BatchMatrixDiag", "path": "raw_ops/batchmatrixdiag", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BatchMatrixDiagPart", "path": "raw_ops/batchmatrixdiagpart", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BatchMatrixInverse", "path": "raw_ops/batchmatrixinverse", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BatchMatrixSetDiag", "path": "raw_ops/batchmatrixsetdiag", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BatchMatrixSolve", "path": "raw_ops/batchmatrixsolve", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BatchMatrixSolveLs", "path": "raw_ops/batchmatrixsolvels", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BatchMatrixTriangularSolve", "path": "raw_ops/batchmatrixtriangularsolve", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BatchNormWithGlobalNormalization", "path": "raw_ops/batchnormwithglobalnormalization", "type": "tf.raw_ops", "text": "\nBatch normalization.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BatchNormWithGlobalNormalizationGrad", "path": "raw_ops/batchnormwithglobalnormalizationgrad", "type": "tf.raw_ops", "text": "\nGradients for batch normalization.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BatchSelfAdjointEig", "path": "raw_ops/batchselfadjointeig", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BatchSelfAdjointEigV2", "path": "raw_ops/batchselfadjointeigv2", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BatchSvd", "path": "raw_ops/batchsvd", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BatchToSpace", "path": "raw_ops/batchtospace", "type": "tf.raw_ops", "text": "\nBatchToSpace for 4-D tensors of type T.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BatchToSpaceND", "path": "raw_ops/batchtospacend", "type": "tf.raw_ops", "text": "\nBatchToSpace for N-D tensors of type T.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BesselI0", "path": "raw_ops/besseli0", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BesselI0e", "path": "raw_ops/besseli0e", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BesselI1", "path": "raw_ops/besseli1", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BesselI1e", "path": "raw_ops/besseli1e", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BesselJ0", "path": "raw_ops/besselj0", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BesselJ1", "path": "raw_ops/besselj1", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BesselK0", "path": "raw_ops/besselk0", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BesselK0e", "path": "raw_ops/besselk0e", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BesselK1", "path": "raw_ops/besselk1", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BesselK1e", "path": "raw_ops/besselk1e", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BesselY0", "path": "raw_ops/bessely0", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BesselY1", "path": "raw_ops/bessely1", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Betainc", "path": "raw_ops/betainc", "type": "tf.raw_ops", "text": "\nCompute the regularized incomplete beta integral \\\\(I_x(a, b)\\\\).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BiasAdd", "path": "raw_ops/biasadd", "type": "tf.raw_ops", "text": "\nAdds `bias` to `value`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BiasAddGrad", "path": "raw_ops/biasaddgrad", "type": "tf.raw_ops", "text": "\nThe backward operation for \"BiasAdd\" on the \"bias\" tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BiasAddV1", "path": "raw_ops/biasaddv1", "type": "tf.raw_ops", "text": "\nAdds `bias` to `value`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Bincount", "path": "raw_ops/bincount", "type": "tf.raw_ops", "text": "\nCounts the number of occurrences of each value in an integer array.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Bitcast", "path": "raw_ops/bitcast", "type": "tf.raw_ops", "text": "\nBitcasts a tensor from one type to another without copying data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BitwiseAnd", "path": "raw_ops/bitwiseand", "type": "tf.raw_ops", "text": "\nElementwise computes the bitwise AND of `x` and `y`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BitwiseOr", "path": "raw_ops/bitwiseor", "type": "tf.raw_ops", "text": "\nElementwise computes the bitwise OR of `x` and `y`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BitwiseXor", "path": "raw_ops/bitwisexor", "type": "tf.raw_ops", "text": "\nElementwise computes the bitwise XOR of `x` and `y`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BlockLSTM", "path": "raw_ops/blocklstm", "type": "tf.raw_ops", "text": "\nComputes the LSTM cell forward propagation for all the time steps.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BlockLSTMGrad", "path": "raw_ops/blocklstmgrad", "type": "tf.raw_ops", "text": "\nComputes the LSTM cell backward propagation for the entire time sequence.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BlockLSTMGradV2", "path": "raw_ops/blocklstmgradv2", "type": "tf.raw_ops", "text": "\nComputes the LSTM cell backward propagation for the entire time sequence.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BlockLSTMV2", "path": "raw_ops/blocklstmv2", "type": "tf.raw_ops", "text": "\nComputes the LSTM cell forward propagation for all the time steps.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BoostedTreesAggregateStats", "path": "raw_ops/boostedtreesaggregatestats", "type": "tf.raw_ops", "text": "\nAggregates the summary of accumulated stats for the batch.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BoostedTreesBucketize", "path": "raw_ops/boostedtreesbucketize", "type": "tf.raw_ops", "text": "\nBucketize each feature based on bucket boundaries.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BoostedTreesCalculateBestFeatureSplit", "path": "raw_ops/boostedtreescalculatebestfeaturesplit", "type": "tf.raw_ops", "text": "\nCalculates gains for each feature and returns the best possible split\ninformation for the feature.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BoostedTreesCalculateBestFeatureSplitV2", "path": "raw_ops/boostedtreescalculatebestfeaturesplitv2", "type": "tf.raw_ops", "text": "\nCalculates gains for each feature and returns the best possible split\ninformation for each node. However, if no split is found, then no split\ninformation is returned for that node.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BoostedTreesCalculateBestGainsPerFeature", "path": "raw_ops/boostedtreescalculatebestgainsperfeature", "type": "tf.raw_ops", "text": "\nCalculates gains for each feature and returns the best possible split\ninformation for the feature.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BoostedTreesCenterBias", "path": "raw_ops/boostedtreescenterbias", "type": "tf.raw_ops", "text": "\nCalculates the prior from the training data (the bias) and fills in the first\nnode with the logits' prior. Returns a boolean indicating whether to continue\ncentering.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BoostedTreesCreateEnsemble", "path": "raw_ops/boostedtreescreateensemble", "type": "tf.raw_ops", "text": "\nCreates a tree ensemble model and returns a handle to it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BoostedTreesCreateQuantileStreamResource", "path": "raw_ops/boostedtreescreatequantilestreamresource", "type": "tf.raw_ops", "text": "\nCreate the Resource for Quantile Streams.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BoostedTreesDeserializeEnsemble", "path": "raw_ops/boostedtreesdeserializeensemble", "type": "tf.raw_ops", "text": "\nDeserializes a serialized tree ensemble config and replaces current tree\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BoostedTreesEnsembleResourceHandleOp", "path": "raw_ops/boostedtreesensembleresourcehandleop", "type": "tf.raw_ops", "text": "\nCreates a handle to a BoostedTreesEnsembleResource\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BoostedTreesExampleDebugOutputs", "path": "raw_ops/boostedtreesexampledebugoutputs", "type": "tf.raw_ops", "text": "\nDebugging/model interpretability outputs for each example.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BoostedTreesFlushQuantileSummaries", "path": "raw_ops/boostedtreesflushquantilesummaries", "type": "tf.raw_ops", "text": "\nFlush the quantile summaries from each quantile stream resource.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BoostedTreesGetEnsembleStates", "path": "raw_ops/boostedtreesgetensemblestates", "type": "tf.raw_ops", "text": "\nRetrieves the tree ensemble resource stamp token, number of trees and growing\nstatistics.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BoostedTreesMakeQuantileSummaries", "path": "raw_ops/boostedtreesmakequantilesummaries", "type": "tf.raw_ops", "text": "\nMakes the summary of quantiles for the batch.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BoostedTreesMakeStatsSummary", "path": "raw_ops/boostedtreesmakestatssummary", "type": "tf.raw_ops", "text": "\nMakes the summary of accumulated stats for the batch.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BoostedTreesPredict", "path": "raw_ops/boostedtreespredict", "type": "tf.raw_ops", "text": "\nRuns multiple additive regression ensemble predictors on input instances and\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BoostedTreesQuantileStreamResourceAddSummaries", "path": "raw_ops/boostedtreesquantilestreamresourceaddsummaries", "type": "tf.raw_ops", "text": "\nAdd the quantile summaries to each quantile stream resource.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BoostedTreesQuantileStreamResourceDeserialize", "path": "raw_ops/boostedtreesquantilestreamresourcedeserialize", "type": "tf.raw_ops", "text": "\nDeserialize bucket boundaries and ready flag into current QuantileAccumulator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BoostedTreesQuantileStreamResourceFlush", "path": "raw_ops/boostedtreesquantilestreamresourceflush", "type": "tf.raw_ops", "text": "\nFlush the summaries for a quantile stream resource.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BoostedTreesQuantileStreamResourceGetBucketBoundaries", "path": "raw_ops/boostedtreesquantilestreamresourcegetbucketboundaries", "type": "tf.raw_ops", "text": "\nGenerate the bucket boundaries for each feature based on accumulated\nsummaries.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BoostedTreesQuantileStreamResourceHandleOp", "path": "raw_ops/boostedtreesquantilestreamresourcehandleop", "type": "tf.raw_ops", "text": "\nCreates a handle to a BoostedTreesQuantileStreamResource.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BoostedTreesSerializeEnsemble", "path": "raw_ops/boostedtreesserializeensemble", "type": "tf.raw_ops", "text": "\nSerializes the tree ensemble to a proto.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BoostedTreesSparseAggregateStats", "path": "raw_ops/boostedtreessparseaggregatestats", "type": "tf.raw_ops", "text": "\nAggregates the summary of accumulated stats for the batch.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BoostedTreesSparseCalculateBestFeatureSplit", "path": "raw_ops/boostedtreessparsecalculatebestfeaturesplit", "type": "tf.raw_ops", "text": "\nCalculates gains for each feature and returns the best possible split\ninformation for the feature.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BoostedTreesTrainingPredict", "path": "raw_ops/boostedtreestrainingpredict", "type": "tf.raw_ops", "text": "\nRuns multiple additive regression ensemble predictors on input instances and\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BoostedTreesUpdateEnsemble", "path": "raw_ops/boostedtreesupdateensemble", "type": "tf.raw_ops", "text": "\nUpdates the tree ensemble by either adding a layer to the last tree being\ngrown\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BoostedTreesUpdateEnsembleV2", "path": "raw_ops/boostedtreesupdateensemblev2", "type": "tf.raw_ops", "text": "\nUpdates the tree ensemble by adding a layer to the last tree being grown\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BroadcastArgs", "path": "raw_ops/broadcastargs", "type": "tf.raw_ops", "text": "\nReturn the shape of s0 op s1 with broadcast.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BroadcastGradientArgs", "path": "raw_ops/broadcastgradientargs", "type": "tf.raw_ops", "text": "\nReturn the reduction indices for computing gradients of s0 op s1 with\nbroadcast.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BroadcastTo", "path": "raw_ops/broadcastto", "type": "tf.raw_ops", "text": "\nBroadcast an array for a compatible shape.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Bucketize", "path": "raw_ops/bucketize", "type": "tf.raw_ops", "text": "\nBucketizes 'input' based on 'boundaries'.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.BytesProducedStatsDataset", "path": "raw_ops/bytesproducedstatsdataset", "type": "tf.raw_ops", "text": "\nRecords the bytes size of each element of `input_dataset` in a\nStatsAggregator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CacheDataset", "path": "raw_ops/cachedataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that caches elements from `input_dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CacheDatasetV2", "path": "raw_ops/cachedatasetv2", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Case", "path": "raw_ops/case", "type": "tf.raw_ops", "text": "\nAn n-way switch statement which calls a single branch function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Cast", "path": "raw_ops/cast", "type": "tf.raw_ops", "text": "\nCast x of type SrcT to y of DstT.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Ceil", "path": "raw_ops/ceil", "type": "tf.raw_ops", "text": "\nReturns element-wise smallest integer not less than x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CheckNumerics", "path": "raw_ops/checknumerics", "type": "tf.raw_ops", "text": "\nChecks a tensor for NaN and Inf values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CheckNumericsV2", "path": "raw_ops/checknumericsv2", "type": "tf.raw_ops", "text": "\nChecks a tensor for NaN, -Inf and +Inf values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Cholesky", "path": "raw_ops/cholesky", "type": "tf.raw_ops", "text": "\nComputes the Cholesky decomposition of one or more square matrices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CholeskyGrad", "path": "raw_ops/choleskygrad", "type": "tf.raw_ops", "text": "\nComputes the reverse mode backpropagated gradient of the Cholesky algorithm.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ChooseFastestBranchDataset", "path": "raw_ops/choosefastestbranchdataset", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ChooseFastestDataset", "path": "raw_ops/choosefastestdataset", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ClipByValue", "path": "raw_ops/clipbyvalue", "type": "tf.raw_ops", "text": "\nClips tensor values to a specified min and max.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CloseSummaryWriter", "path": "raw_ops/closesummarywriter", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CollectiveBcastRecv", "path": "raw_ops/collectivebcastrecv", "type": "tf.raw_ops", "text": "\nReceives a tensor value broadcast from another device.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CollectiveBcastSend", "path": "raw_ops/collectivebcastsend", "type": "tf.raw_ops", "text": "\nBroadcasts a tensor value to one or more other devices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CollectiveGather", "path": "raw_ops/collectivegather", "type": "tf.raw_ops", "text": "\nMutually accumulates multiple tensors of identical type and shape.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CollectiveGatherV2", "path": "raw_ops/collectivegatherv2", "type": "tf.raw_ops", "text": "\nMutually accumulates multiple tensors of identical type and shape.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CollectivePermute", "path": "raw_ops/collectivepermute", "type": "tf.raw_ops", "text": "\nAn Op to permute tensors across replicated TPU instances.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CollectiveReduce", "path": "raw_ops/collectivereduce", "type": "tf.raw_ops", "text": "\nMutually reduces multiple tensors of identical type and shape.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CollectiveReduceV2", "path": "raw_ops/collectivereducev2", "type": "tf.raw_ops", "text": "\nMutually reduces multiple tensors of identical type and shape.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CombinedNonMaxSuppression", "path": "raw_ops/combinednonmaxsuppression", "type": "tf.raw_ops", "text": "\nGreedily selects a subset of bounding boxes in descending order of score,\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CompareAndBitpack", "path": "raw_ops/compareandbitpack", "type": "tf.raw_ops", "text": "\nCompare values of `input` to `threshold` and pack resulting bits into a\n`uint8`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Complex", "path": "raw_ops/complex", "type": "tf.raw_ops", "text": "\nConverts two real numbers to a complex number.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ComplexAbs", "path": "raw_ops/complexabs", "type": "tf.raw_ops", "text": "\nComputes the complex absolute value of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CompressElement", "path": "raw_ops/compresselement", "type": "tf.raw_ops", "text": "\nCompresses a dataset element.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ComputeAccidentalHits", "path": "raw_ops/computeaccidentalhits", "type": "tf.raw_ops", "text": "\nComputes the ids of the positions in sampled_candidates that match\ntrue_labels.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ComputeBatchSize", "path": "raw_ops/computebatchsize", "type": "tf.raw_ops", "text": "\nComputes the static batch size of a dataset sans partial batches.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Concat", "path": "raw_ops/concat", "type": "tf.raw_ops", "text": "\nConcatenates tensors along one dimension.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ConcatenateDataset", "path": "raw_ops/concatenatedataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that concatenates `input_dataset` with `another_dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ConcatOffset", "path": "raw_ops/concatoffset", "type": "tf.raw_ops", "text": "\nComputes offsets of concat inputs within its output.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ConcatV2", "path": "raw_ops/concatv2", "type": "tf.raw_ops", "text": "\nConcatenates tensors along one dimension.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ConditionalAccumulator", "path": "raw_ops/conditionalaccumulator", "type": "tf.raw_ops", "text": "\nA conditional accumulator for aggregating gradients.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ConfigureDistributedTPU", "path": "raw_ops/configuredistributedtpu", "type": "tf.raw_ops", "text": "\nSets up the centralized structures for a distributed TPU system.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ConfigureTPUEmbedding", "path": "raw_ops/configuretpuembedding", "type": "tf.raw_ops", "text": "\nSets up TPUEmbedding in a distributed TPU system.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Conj", "path": "raw_ops/conj", "type": "tf.raw_ops", "text": "\nReturns the complex conjugate of a complex number.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ConjugateTranspose", "path": "raw_ops/conjugatetranspose", "type": "tf.raw_ops", "text": "\nShuffle dimensions of x according to a permutation and conjugate the result.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Const", "path": "raw_ops/const", "type": "tf.raw_ops", "text": "\nReturns a constant tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ConsumeMutexLock", "path": "raw_ops/consumemutexlock", "type": "tf.raw_ops", "text": "\nThis op consumes a lock created by `MutexLock`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ControlTrigger", "path": "raw_ops/controltrigger", "type": "tf.raw_ops", "text": "\nDoes nothing. Serves as a control trigger for scheduling.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Conv2D", "path": "raw_ops/conv2d", "type": "tf.raw_ops", "text": "\nComputes a 2-D convolution given 4-D `input` and `filter` tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Conv2DBackpropFilter", "path": "raw_ops/conv2dbackpropfilter", "type": "tf.raw_ops", "text": "\nComputes the gradients of convolution with respect to the filter.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Conv2DBackpropInput", "path": "raw_ops/conv2dbackpropinput", "type": "tf.raw_ops", "text": "\nComputes the gradients of convolution with respect to the input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Conv3D", "path": "raw_ops/conv3d", "type": "tf.raw_ops", "text": "\nComputes a 3-D convolution given 5-D `input` and `filter` tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Conv3DBackpropFilter", "path": "raw_ops/conv3dbackpropfilter", "type": "tf.raw_ops", "text": "\nComputes the gradients of 3-D convolution with respect to the filter.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Conv3DBackpropFilterV2", "path": "raw_ops/conv3dbackpropfilterv2", "type": "tf.raw_ops", "text": "\nComputes the gradients of 3-D convolution with respect to the filter.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Conv3DBackpropInput", "path": "raw_ops/conv3dbackpropinput", "type": "tf.raw_ops", "text": "\nComputes the gradients of 3-D convolution with respect to the input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Conv3DBackpropInputV2", "path": "raw_ops/conv3dbackpropinputv2", "type": "tf.raw_ops", "text": "\nComputes the gradients of 3-D convolution with respect to the input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Copy", "path": "raw_ops/copy", "type": "tf.raw_ops", "text": "\nCopy a tensor from CPU-to-CPU or GPU-to-GPU.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CopyHost", "path": "raw_ops/copyhost", "type": "tf.raw_ops", "text": "\nCopy a tensor to host.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Cos", "path": "raw_ops/cos", "type": "tf.raw_ops", "text": "\nComputes cos of x element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Cosh", "path": "raw_ops/cosh", "type": "tf.raw_ops", "text": "\nComputes hyperbolic cosine of x element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CountUpTo", "path": "raw_ops/countupto", "type": "tf.raw_ops", "text": "\nIncrements 'ref' until it reaches 'limit'.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CreateSummaryDbWriter", "path": "raw_ops/createsummarydbwriter", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CreateSummaryFileWriter", "path": "raw_ops/createsummaryfilewriter", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CropAndResize", "path": "raw_ops/cropandresize", "type": "tf.raw_ops", "text": "\nExtracts crops from the input image tensor and resizes them.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CropAndResizeGradBoxes", "path": "raw_ops/cropandresizegradboxes", "type": "tf.raw_ops", "text": "\nComputes the gradient of the crop_and_resize op wrt the input boxes tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CropAndResizeGradImage", "path": "raw_ops/cropandresizegradimage", "type": "tf.raw_ops", "text": "\nComputes the gradient of the crop_and_resize op wrt the input image tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Cross", "path": "raw_ops/cross", "type": "tf.raw_ops", "text": "\nCompute the pairwise cross product.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CrossReplicaSum", "path": "raw_ops/crossreplicasum", "type": "tf.raw_ops", "text": "\nAn Op to sum inputs across replicated TPU instances.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CSRSparseMatrixComponents", "path": "raw_ops/csrsparsematrixcomponents", "type": "tf.raw_ops", "text": "\nReads out the CSR components at batch `index`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CSRSparseMatrixToDense", "path": "raw_ops/csrsparsematrixtodense", "type": "tf.raw_ops", "text": "\nConvert a (possibly batched) CSRSparseMatrix to dense.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CSRSparseMatrixToSparseTensor", "path": "raw_ops/csrsparsematrixtosparsetensor", "type": "tf.raw_ops", "text": "\nConverts a (possibly batched) CSRSparesMatrix to a SparseTensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CSVDataset", "path": "raw_ops/csvdataset", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CSVDatasetV2", "path": "raw_ops/csvdatasetv2", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CTCBeamSearchDecoder", "path": "raw_ops/ctcbeamsearchdecoder", "type": "tf.raw_ops", "text": "\nPerforms beam search decoding on the logits given in input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CTCGreedyDecoder", "path": "raw_ops/ctcgreedydecoder", "type": "tf.raw_ops", "text": "\nPerforms greedy decoding on the logits given in inputs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CTCLoss", "path": "raw_ops/ctcloss", "type": "tf.raw_ops", "text": "\nCalculates the CTC Loss (log probability) for each batch entry. Also\ncalculates\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CTCLossV2", "path": "raw_ops/ctclossv2", "type": "tf.raw_ops", "text": "\nCalculates the CTC Loss (log probability) for each batch entry. Also\ncalculates\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CudnnRNN", "path": "raw_ops/cudnnrnn", "type": "tf.raw_ops", "text": "\nA RNN backed by cuDNN.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CudnnRNNBackprop", "path": "raw_ops/cudnnrnnbackprop", "type": "tf.raw_ops", "text": "\nBackprop step of CudnnRNN.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CudnnRNNBackpropV2", "path": "raw_ops/cudnnrnnbackpropv2", "type": "tf.raw_ops", "text": "\nBackprop step of CudnnRNN.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CudnnRNNBackpropV3", "path": "raw_ops/cudnnrnnbackpropv3", "type": "tf.raw_ops", "text": "\nBackprop step of CudnnRNNV3.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CudnnRNNCanonicalToParams", "path": "raw_ops/cudnnrnncanonicaltoparams", "type": "tf.raw_ops", "text": "\nConverts CudnnRNN params from canonical form to usable form.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CudnnRNNCanonicalToParamsV2", "path": "raw_ops/cudnnrnncanonicaltoparamsv2", "type": "tf.raw_ops", "text": "\nConverts CudnnRNN params from canonical form to usable form. It supports the\nprojection in LSTM.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CudnnRNNParamsSize", "path": "raw_ops/cudnnrnnparamssize", "type": "tf.raw_ops", "text": "\nComputes size of weights that can be used by a Cudnn RNN model.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CudnnRNNParamsToCanonical", "path": "raw_ops/cudnnrnnparamstocanonical", "type": "tf.raw_ops", "text": "\nRetrieves CudnnRNN params in canonical form.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CudnnRNNParamsToCanonicalV2", "path": "raw_ops/cudnnrnnparamstocanonicalv2", "type": "tf.raw_ops", "text": "\nRetrieves CudnnRNN params in canonical form. It supports the projection in\nLSTM.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CudnnRNNV2", "path": "raw_ops/cudnnrnnv2", "type": "tf.raw_ops", "text": "\nA RNN backed by cuDNN.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CudnnRNNV3", "path": "raw_ops/cudnnrnnv3", "type": "tf.raw_ops", "text": "\nA RNN backed by cuDNN.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Cumprod", "path": "raw_ops/cumprod", "type": "tf.raw_ops", "text": "\nCompute the cumulative product of the tensor `x` along `axis`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Cumsum", "path": "raw_ops/cumsum", "type": "tf.raw_ops", "text": "\nCompute the cumulative sum of the tensor `x` along `axis`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.CumulativeLogsumexp", "path": "raw_ops/cumulativelogsumexp", "type": "tf.raw_ops", "text": "\nCompute the cumulative product of the tensor `x` along `axis`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DataFormatDimMap", "path": "raw_ops/dataformatdimmap", "type": "tf.raw_ops", "text": "\nReturns the dimension index in the destination data format given the one in\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DataFormatVecPermute", "path": "raw_ops/dataformatvecpermute", "type": "tf.raw_ops", "text": "\nPermute input tensor from `src_format` to `dst_format`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DataServiceDataset", "path": "raw_ops/dataservicedataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that reads data from the tf.data service.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DatasetCardinality", "path": "raw_ops/datasetcardinality", "type": "tf.raw_ops", "text": "\nReturns the cardinality of `input_dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DatasetFromGraph", "path": "raw_ops/datasetfromgraph", "type": "tf.raw_ops", "text": "\nCreates a dataset from the given `graph_def`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DatasetToGraph", "path": "raw_ops/datasettograph", "type": "tf.raw_ops", "text": "\nReturns a serialized GraphDef representing `input_dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DatasetToGraphV2", "path": "raw_ops/datasettographv2", "type": "tf.raw_ops", "text": "\nReturns a serialized GraphDef representing `input_dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DatasetToSingleElement", "path": "raw_ops/datasettosingleelement", "type": "tf.raw_ops", "text": "\nOutputs the single element from the given dataset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DatasetToTFRecord", "path": "raw_ops/datasettotfrecord", "type": "tf.raw_ops", "text": "\nWrites the given dataset to the given file using the TFRecord format.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Dawsn", "path": "raw_ops/dawsn", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DebugGradientIdentity", "path": "raw_ops/debuggradientidentity", "type": "tf.raw_ops", "text": "\nIdentity op for gradient debugging.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DebugGradientRefIdentity", "path": "raw_ops/debuggradientrefidentity", "type": "tf.raw_ops", "text": "\nIdentity op for gradient debugging.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DebugIdentity", "path": "raw_ops/debugidentity", "type": "tf.raw_ops", "text": "\nProvides an identity mapping of the non-Ref type input tensor for debugging.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DebugIdentityV2", "path": "raw_ops/debugidentityv2", "type": "tf.raw_ops", "text": "\nDebug Identity V2 Op.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DebugNanCount", "path": "raw_ops/debugnancount", "type": "tf.raw_ops", "text": "\nDebug NaN Value Counter Op.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DebugNumericSummary", "path": "raw_ops/debugnumericsummary", "type": "tf.raw_ops", "text": "\nDebug Numeric Summary Op.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DebugNumericSummaryV2", "path": "raw_ops/debugnumericsummaryv2", "type": "tf.raw_ops", "text": "\nDebug Numeric Summary V2 Op.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DecodeAndCropJpeg", "path": "raw_ops/decodeandcropjpeg", "type": "tf.raw_ops", "text": "\nDecode and Crop a JPEG-encoded image to a uint8 tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DecodeBase64", "path": "raw_ops/decodebase64", "type": "tf.raw_ops", "text": "\nDecode web-safe base64-encoded strings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DecodeBmp", "path": "raw_ops/decodebmp", "type": "tf.raw_ops", "text": "\nDecode the first frame of a BMP-encoded image to a uint8 tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DecodeCompressed", "path": "raw_ops/decodecompressed", "type": "tf.raw_ops", "text": "\nDecompress strings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DecodeCSV", "path": "raw_ops/decodecsv", "type": "tf.raw_ops", "text": "\nConvert CSV records to tensors. Each column maps to one tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DecodeGif", "path": "raw_ops/decodegif", "type": "tf.raw_ops", "text": "\nDecode the frame(s) of a GIF-encoded image to a uint8 tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DecodeImage", "path": "raw_ops/decodeimage", "type": "tf.raw_ops", "text": "\nFunction for decode_bmp, decode_gif, decode_jpeg, and decode_png.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DecodeJpeg", "path": "raw_ops/decodejpeg", "type": "tf.raw_ops", "text": "\nDecode a JPEG-encoded image to a uint8 tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DecodeJSONExample", "path": "raw_ops/decodejsonexample", "type": "tf.raw_ops", "text": "\nConvert JSON-encoded Example records to binary protocol buffer strings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DecodePaddedRaw", "path": "raw_ops/decodepaddedraw", "type": "tf.raw_ops", "text": "\nReinterpret the bytes of a string as a vector of numbers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DecodePng", "path": "raw_ops/decodepng", "type": "tf.raw_ops", "text": "\nDecode a PNG-encoded image to a uint8 or uint16 tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DecodeProtoV2", "path": "raw_ops/decodeprotov2", "type": "tf.raw_ops", "text": "\nThe op extracts fields from a serialized protocol buffers message into\ntensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DecodeRaw", "path": "raw_ops/decoderaw", "type": "tf.raw_ops", "text": "\nReinterpret the bytes of a string as a vector of numbers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DecodeWav", "path": "raw_ops/decodewav", "type": "tf.raw_ops", "text": "\nDecode a 16-bit PCM WAV file to a float tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DeepCopy", "path": "raw_ops/deepcopy", "type": "tf.raw_ops", "text": "\nMakes a copy of `x`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DeleteIterator", "path": "raw_ops/deleteiterator", "type": "tf.raw_ops", "text": "\nA container for an iterator resource.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DeleteMemoryCache", "path": "raw_ops/deletememorycache", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DeleteMultiDeviceIterator", "path": "raw_ops/deletemultideviceiterator", "type": "tf.raw_ops", "text": "\nA container for an iterator resource.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DeleteRandomSeedGenerator", "path": "raw_ops/deleterandomseedgenerator", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DeleteSeedGenerator", "path": "raw_ops/deleteseedgenerator", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DeleteSessionTensor", "path": "raw_ops/deletesessiontensor", "type": "tf.raw_ops", "text": "\nDelete the tensor specified by its handle in the session.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DenseBincount", "path": "raw_ops/densebincount", "type": "tf.raw_ops", "text": "\nCounts the number of occurrences of each value in an integer array.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DenseCountSparseOutput", "path": "raw_ops/densecountsparseoutput", "type": "tf.raw_ops", "text": "\nPerforms sparse-output bin counting for a tf.tensor input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DenseToCSRSparseMatrix", "path": "raw_ops/densetocsrsparsematrix", "type": "tf.raw_ops", "text": "\nConverts a dense tensor to a (possibly batched) CSRSparseMatrix.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DenseToDenseSetOperation", "path": "raw_ops/densetodensesetoperation", "type": "tf.raw_ops", "text": "\nApplies set operation along last dimension of 2 `Tensor` inputs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DenseToSparseBatchDataset", "path": "raw_ops/densetosparsebatchdataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that batches input elements into a SparseTensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DenseToSparseSetOperation", "path": "raw_ops/densetosparsesetoperation", "type": "tf.raw_ops", "text": "\nApplies set operation along last dimension of `Tensor` and `SparseTensor`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DepthToSpace", "path": "raw_ops/depthtospace", "type": "tf.raw_ops", "text": "\nDepthToSpace for tensors of type T.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DepthwiseConv2dNative", "path": "raw_ops/depthwiseconv2dnative", "type": "tf.raw_ops", "text": "\nComputes a 2-D depthwise convolution given 4-D `input` and `filter` tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DepthwiseConv2dNativeBackpropFilter", "path": "raw_ops/depthwiseconv2dnativebackpropfilter", "type": "tf.raw_ops", "text": "\nComputes the gradients of depthwise convolution with respect to the filter.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DepthwiseConv2dNativeBackpropInput", "path": "raw_ops/depthwiseconv2dnativebackpropinput", "type": "tf.raw_ops", "text": "\nComputes the gradients of depthwise convolution with respect to the input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Dequantize", "path": "raw_ops/dequantize", "type": "tf.raw_ops", "text": "\nDequantize the 'input' tensor into a float or bfloat16 Tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DeserializeIterator", "path": "raw_ops/deserializeiterator", "type": "tf.raw_ops", "text": "\nConverts the given variant tensor to an iterator and stores it in the given\nresource.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DeserializeManySparse", "path": "raw_ops/deserializemanysparse", "type": "tf.raw_ops", "text": "\nDeserialize and concatenate `SparseTensors` from a serialized minibatch.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DeserializeSparse", "path": "raw_ops/deserializesparse", "type": "tf.raw_ops", "text": "\nDeserialize `SparseTensor` objects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DestroyResourceOp", "path": "raw_ops/destroyresourceop", "type": "tf.raw_ops", "text": "\nDeletes the resource specified by the handle.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DestroyTemporaryVariable", "path": "raw_ops/destroytemporaryvariable", "type": "tf.raw_ops", "text": "\nDestroys the temporary variable and returns its final value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DeviceIndex", "path": "raw_ops/deviceindex", "type": "tf.raw_ops", "text": "\nReturn the index of device the op runs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Diag", "path": "raw_ops/diag", "type": "tf.raw_ops", "text": "\nReturns a diagonal tensor with a given diagonal values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DiagPart", "path": "raw_ops/diagpart", "type": "tf.raw_ops", "text": "\nReturns the diagonal part of the tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Digamma", "path": "raw_ops/digamma", "type": "tf.raw_ops", "text": "\nComputes Psi, the derivative of Lgamma (the log of the absolute value of\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Dilation2D", "path": "raw_ops/dilation2d", "type": "tf.raw_ops", "text": "\nComputes the grayscale dilation of 4-D `input` and 3-D `filter` tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Dilation2DBackpropFilter", "path": "raw_ops/dilation2dbackpropfilter", "type": "tf.raw_ops", "text": "\nComputes the gradient of morphological 2-D dilation with respect to the\nfilter.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Dilation2DBackpropInput", "path": "raw_ops/dilation2dbackpropinput", "type": "tf.raw_ops", "text": "\nComputes the gradient of morphological 2-D dilation with respect to the input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DirectedInterleaveDataset", "path": "raw_ops/directedinterleavedataset", "type": "tf.raw_ops", "text": "\nA substitute for `InterleaveDataset` on a fixed list of `N` datasets.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Div", "path": "raw_ops/div", "type": "tf.raw_ops", "text": "\nReturns x / y element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DivNoNan", "path": "raw_ops/divnonan", "type": "tf.raw_ops", "text": "\nReturns 0 if the denominator is zero.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DrawBoundingBoxes", "path": "raw_ops/drawboundingboxes", "type": "tf.raw_ops", "text": "\nDraw bounding boxes on a batch of images.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DrawBoundingBoxesV2", "path": "raw_ops/drawboundingboxesv2", "type": "tf.raw_ops", "text": "\nDraw bounding boxes on a batch of images.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DummyIterationCounter", "path": "raw_ops/dummyiterationcounter", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DummyMemoryCache", "path": "raw_ops/dummymemorycache", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DummySeedGenerator", "path": "raw_ops/dummyseedgenerator", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DynamicPartition", "path": "raw_ops/dynamicpartition", "type": "tf.raw_ops", "text": "\nPartitions `data` into `num_partitions` tensors using indices from\n`partitions`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.DynamicStitch", "path": "raw_ops/dynamicstitch", "type": "tf.raw_ops", "text": "\nInterleave the values from the `data` tensors into a single tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.EagerPyFunc", "path": "raw_ops/eagerpyfunc", "type": "tf.raw_ops", "text": "\nEagerly executes a python function to compute func(input)->output. The\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.EditDistance", "path": "raw_ops/editdistance", "type": "tf.raw_ops", "text": "\nComputes the (possibly normalized) Levenshtein Edit Distance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Eig", "path": "raw_ops/eig", "type": "tf.raw_ops", "text": "\nComputes the eigen decomposition of one or more square matrices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Einsum", "path": "raw_ops/einsum", "type": "tf.raw_ops", "text": "\nTensor contraction according to Einstein summation convention.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Elu", "path": "raw_ops/elu", "type": "tf.raw_ops", "text": "\nComputes exponential linear: `exp(features) - 1` if < 0, `features` otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.EluGrad", "path": "raw_ops/elugrad", "type": "tf.raw_ops", "text": "\nComputes gradients for the exponential linear (Elu) operation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Empty", "path": "raw_ops/empty", "type": "tf.raw_ops", "text": "\nCreates a tensor with the given shape.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.EmptyTensorList", "path": "raw_ops/emptytensorlist", "type": "tf.raw_ops", "text": "\nCreates and returns an empty tensor list.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.EncodeBase64", "path": "raw_ops/encodebase64", "type": "tf.raw_ops", "text": "\nEncode strings into web-safe base64 format.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.EncodeJpeg", "path": "raw_ops/encodejpeg", "type": "tf.raw_ops", "text": "\nJPEG-encode an image.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.EncodeJpegVariableQuality", "path": "raw_ops/encodejpegvariablequality", "type": "tf.raw_ops", "text": "\nJPEG encode input image with provided compression quality.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.EncodePng", "path": "raw_ops/encodepng", "type": "tf.raw_ops", "text": "\nPNG-encode an image.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.EncodeProto", "path": "raw_ops/encodeproto", "type": "tf.raw_ops", "text": "\nThe op serializes protobuf messages provided in the input tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.EncodeWav", "path": "raw_ops/encodewav", "type": "tf.raw_ops", "text": "\nEncode audio data using the WAV file format.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.EnqueueTPUEmbeddingIntegerBatch", "path": "raw_ops/enqueuetpuembeddingintegerbatch", "type": "tf.raw_ops", "text": "\nAn op that enqueues a list of input batch tensors to TPUEmbedding.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.EnqueueTPUEmbeddingRaggedTensorBatch", "path": "raw_ops/enqueuetpuembeddingraggedtensorbatch", "type": "tf.raw_ops", "text": "\nEases the porting of code that uses tf.nn.embedding_lookup().\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.EnqueueTPUEmbeddingSparseBatch", "path": "raw_ops/enqueuetpuembeddingsparsebatch", "type": "tf.raw_ops", "text": "\nAn op that enqueues TPUEmbedding input indices from a SparseTensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.EnqueueTPUEmbeddingSparseTensorBatch", "path": "raw_ops/enqueuetpuembeddingsparsetensorbatch", "type": "tf.raw_ops", "text": "\nEases the porting of code that uses tf.nn.embedding_lookup_sparse().\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.EnsureShape", "path": "raw_ops/ensureshape", "type": "tf.raw_ops", "text": "\nEnsures that the tensor's shape matches the expected shape.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Enter", "path": "raw_ops/enter", "type": "tf.raw_ops", "text": "\nCreates or finds a child frame, and makes `data` available to the child frame.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Equal", "path": "raw_ops/equal", "type": "tf.raw_ops", "text": "\nReturns the truth value of (x == y) element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Erf", "path": "raw_ops/erf", "type": "tf.raw_ops", "text": "\nComputes the Gauss error function of `x` element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Erfc", "path": "raw_ops/erfc", "type": "tf.raw_ops", "text": "\nComputes the complementary error function of `x` element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Erfinv", "path": "raw_ops/erfinv", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.EuclideanNorm", "path": "raw_ops/euclideannorm", "type": "tf.raw_ops", "text": "\nComputes the euclidean norm of elements across dimensions of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Exit", "path": "raw_ops/exit", "type": "tf.raw_ops", "text": "\nExits the current frame to its parent frame.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Exp", "path": "raw_ops/exp", "type": "tf.raw_ops", "text": "\nComputes exponential of x element-wise. \\\\(y = e^x\\\\).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ExpandDims", "path": "raw_ops/expanddims", "type": "tf.raw_ops", "text": "\nInserts a dimension of 1 into a tensor's shape.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ExperimentalAssertNextDataset", "path": "raw_ops/experimentalassertnextdataset", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ExperimentalAutoShardDataset", "path": "raw_ops/experimentalautosharddataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that shards the input dataset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ExperimentalBytesProducedStatsDataset", "path": "raw_ops/experimentalbytesproducedstatsdataset", "type": "tf.raw_ops", "text": "\nRecords the bytes size of each element of `input_dataset` in a\nStatsAggregator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ExperimentalChooseFastestDataset", "path": "raw_ops/experimentalchoosefastestdataset", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ExperimentalCSVDataset", "path": "raw_ops/experimentalcsvdataset", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ExperimentalDatasetCardinality", "path": "raw_ops/experimentaldatasetcardinality", "type": "tf.raw_ops", "text": "\nReturns the cardinality of `input_dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ExperimentalDatasetToTFRecord", "path": "raw_ops/experimentaldatasettotfrecord", "type": "tf.raw_ops", "text": "\nWrites the given dataset to the given file using the TFRecord format.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ExperimentalDenseToSparseBatchDataset", "path": "raw_ops/experimentaldensetosparsebatchdataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that batches input elements into a SparseTensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ExperimentalDirectedInterleaveDataset", "path": "raw_ops/experimentaldirectedinterleavedataset", "type": "tf.raw_ops", "text": "\nA substitute for `InterleaveDataset` on a fixed list of `N` datasets.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ExperimentalGroupByReducerDataset", "path": "raw_ops/experimentalgroupbyreducerdataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that computes a group-by on `input_dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ExperimentalGroupByWindowDataset", "path": "raw_ops/experimentalgroupbywindowdataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that computes a windowed group-by on `input_dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ExperimentalIgnoreErrorsDataset", "path": "raw_ops/experimentalignoreerrorsdataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that contains the elements of `input_dataset` ignoring\nerrors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ExperimentalIteratorGetDevice", "path": "raw_ops/experimentaliteratorgetdevice", "type": "tf.raw_ops", "text": "\nReturns the name of the device on which `resource` has been placed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ExperimentalLatencyStatsDataset", "path": "raw_ops/experimentallatencystatsdataset", "type": "tf.raw_ops", "text": "\nRecords the latency of producing `input_dataset` elements in a\nStatsAggregator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ExperimentalLMDBDataset", "path": "raw_ops/experimentallmdbdataset", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ExperimentalMapAndBatchDataset", "path": "raw_ops/experimentalmapandbatchdataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that fuses mapping with batching.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ExperimentalMapDataset", "path": "raw_ops/experimentalmapdataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that applies `f` to the outputs of `input_dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ExperimentalMatchingFilesDataset", "path": "raw_ops/experimentalmatchingfilesdataset", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ExperimentalMaxIntraOpParallelismDataset", "path": "raw_ops/experimentalmaxintraopparallelismdataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that overrides the maximum intra-op parallelism.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ExperimentalNonSerializableDataset", "path": "raw_ops/experimentalnonserializabledataset", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ExperimentalParallelInterleaveDataset", "path": "raw_ops/experimentalparallelinterleavedataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that applies `f` to the outputs of `input_dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ExperimentalParseExampleDataset", "path": "raw_ops/experimentalparseexampledataset", "type": "tf.raw_ops", "text": "\nTransforms `input_dataset` containing `Example` protos as vectors of DT_STRING\ninto a dataset of `Tensor` or `SparseTensor` objects representing the parsed\nfeatures.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ExperimentalPrivateThreadPoolDataset", "path": "raw_ops/experimentalprivatethreadpooldataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that uses a custom thread pool to compute `input_dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ExperimentalRandomDataset", "path": "raw_ops/experimentalrandomdataset", "type": "tf.raw_ops", "text": "\nCreates a Dataset that returns pseudorandom numbers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ExperimentalRebatchDataset", "path": "raw_ops/experimentalrebatchdataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that changes the batch size.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ExperimentalScanDataset", "path": "raw_ops/experimentalscandataset", "type": "tf.raw_ops", "text": "\nCreates a dataset successively reduces `f` over the elements of\n`input_dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ExperimentalSetStatsAggregatorDataset", "path": "raw_ops/experimentalsetstatsaggregatordataset", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ExperimentalSleepDataset", "path": "raw_ops/experimentalsleepdataset", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ExperimentalSlidingWindowDataset", "path": "raw_ops/experimentalslidingwindowdataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that passes a sliding window over `input_dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ExperimentalSqlDataset", "path": "raw_ops/experimentalsqldataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that executes a SQL query and emits rows of the result set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ExperimentalStatsAggregatorHandle", "path": "raw_ops/experimentalstatsaggregatorhandle", "type": "tf.raw_ops", "text": "\nCreates a statistics manager resource.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ExperimentalStatsAggregatorSummary", "path": "raw_ops/experimentalstatsaggregatorsummary", "type": "tf.raw_ops", "text": "\nProduces a summary of any statistics recorded by the given statistics manager.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ExperimentalTakeWhileDataset", "path": "raw_ops/experimentaltakewhiledataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that stops iteration when predicate` is false.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ExperimentalThreadPoolDataset", "path": "raw_ops/experimentalthreadpooldataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that uses a custom thread pool to compute `input_dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ExperimentalThreadPoolHandle", "path": "raw_ops/experimentalthreadpoolhandle", "type": "tf.raw_ops", "text": "\nCreates a dataset that uses a custom thread pool to compute `input_dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ExperimentalUnbatchDataset", "path": "raw_ops/experimentalunbatchdataset", "type": "tf.raw_ops", "text": "\nA dataset that splits the elements of its input into multiple elements.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ExperimentalUniqueDataset", "path": "raw_ops/experimentaluniquedataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that contains the unique elements of `input_dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Expint", "path": "raw_ops/expint", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Expm1", "path": "raw_ops/expm1", "type": "tf.raw_ops", "text": "\nComputes `exp(x) - 1` element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ExtractGlimpse", "path": "raw_ops/extractglimpse", "type": "tf.raw_ops", "text": "\nExtracts a glimpse from the input tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ExtractGlimpseV2", "path": "raw_ops/extractglimpsev2", "type": "tf.raw_ops", "text": "\nExtracts a glimpse from the input tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ExtractImagePatches", "path": "raw_ops/extractimagepatches", "type": "tf.raw_ops", "text": "\nExtract `patches` from `images` and put them in the \"depth\" output dimension.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ExtractJpegShape", "path": "raw_ops/extractjpegshape", "type": "tf.raw_ops", "text": "\nExtract the shape information of a JPEG-encoded image.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ExtractVolumePatches", "path": "raw_ops/extractvolumepatches", "type": "tf.raw_ops", "text": "\nExtract `patches` from `input` and put them in the `\"depth\"` output dimension.\n3D extension of `extract_image_patches`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Fact", "path": "raw_ops/fact", "type": "tf.raw_ops", "text": "\nOutput a fact about factorials.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.FakeParam", "path": "raw_ops/fakeparam", "type": "tf.raw_ops", "text": "\nThis op is used as a placeholder in If branch functions. It doesn't provide a\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.FakeQuantWithMinMaxArgs", "path": "raw_ops/fakequantwithminmaxargs", "type": "tf.raw_ops", "text": "\nFake-quantize the 'inputs' tensor, type float to 'outputs' tensor of same\ntype.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.FakeQuantWithMinMaxArgsGradient", "path": "raw_ops/fakequantwithminmaxargsgradient", "type": "tf.raw_ops", "text": "\nCompute gradients for a FakeQuantWithMinMaxArgs operation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.FakeQuantWithMinMaxVars", "path": "raw_ops/fakequantwithminmaxvars", "type": "tf.raw_ops", "text": "\nFake-quantize the 'inputs' tensor of type float via global float scalars\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.FakeQuantWithMinMaxVarsGradient", "path": "raw_ops/fakequantwithminmaxvarsgradient", "type": "tf.raw_ops", "text": "\nCompute gradients for a FakeQuantWithMinMaxVars operation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.FakeQuantWithMinMaxVarsPerChannel", "path": "raw_ops/fakequantwithminmaxvarsperchannel", "type": "tf.raw_ops", "text": "\nFake-quantize the 'inputs' tensor of type float via per-channel floats\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.FakeQuantWithMinMaxVarsPerChannelGradient", "path": "raw_ops/fakequantwithminmaxvarsperchannelgradient", "type": "tf.raw_ops", "text": "\nCompute gradients for a FakeQuantWithMinMaxVarsPerChannel operation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.FakeQueue", "path": "raw_ops/fakequeue", "type": "tf.raw_ops", "text": "\nDeprecated. Do not use.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.FFT", "path": "raw_ops/fft", "type": "tf.raw_ops", "text": "\nFast Fourier transform.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.FFT2D", "path": "raw_ops/fft2d", "type": "tf.raw_ops", "text": "\n2D fast Fourier transform.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.FFT3D", "path": "raw_ops/fft3d", "type": "tf.raw_ops", "text": "\n3D fast Fourier transform.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.FIFOQueue", "path": "raw_ops/fifoqueue", "type": "tf.raw_ops", "text": "\nA queue that produces elements in first-in first-out order.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.FIFOQueueV2", "path": "raw_ops/fifoqueuev2", "type": "tf.raw_ops", "text": "\nA queue that produces elements in first-in first-out order.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Fill", "path": "raw_ops/fill", "type": "tf.raw_ops", "text": "\nCreates a tensor filled with a scalar value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.FilterByLastComponentDataset", "path": "raw_ops/filterbylastcomponentdataset", "type": "tf.raw_ops", "text": "\nCreates a dataset containing elements of first component of `input_dataset`\nhaving true in the last component.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.FilterDataset", "path": "raw_ops/filterdataset", "type": "tf.raw_ops", "text": "\nCreates a dataset containing elements of `input_dataset` matching `predicate`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Fingerprint", "path": "raw_ops/fingerprint", "type": "tf.raw_ops", "text": "\nGenerates fingerprint values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.FixedLengthRecordDataset", "path": "raw_ops/fixedlengthrecorddataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that emits the records from one or more binary files.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.FixedLengthRecordDatasetV2", "path": "raw_ops/fixedlengthrecorddatasetv2", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.FixedLengthRecordReader", "path": "raw_ops/fixedlengthrecordreader", "type": "tf.raw_ops", "text": "\nA Reader that outputs fixed-length records from a file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.FixedLengthRecordReaderV2", "path": "raw_ops/fixedlengthrecordreaderv2", "type": "tf.raw_ops", "text": "\nA Reader that outputs fixed-length records from a file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.FixedUnigramCandidateSampler", "path": "raw_ops/fixedunigramcandidatesampler", "type": "tf.raw_ops", "text": "\nGenerates labels for candidate sampling with a learned unigram distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.FlatMapDataset", "path": "raw_ops/flatmapdataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that applies `f` to the outputs of `input_dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Floor", "path": "raw_ops/floor", "type": "tf.raw_ops", "text": "\nReturns element-wise largest integer not greater than x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.FloorDiv", "path": "raw_ops/floordiv", "type": "tf.raw_ops", "text": "\nReturns x // y element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.FloorMod", "path": "raw_ops/floormod", "type": "tf.raw_ops", "text": "\nReturns element-wise remainder of division. When `x < 0` xor `y < 0` is\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.FlushSummaryWriter", "path": "raw_ops/flushsummarywriter", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.For", "path": "raw_ops/for", "type": "tf.raw_ops", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.FractionalAvgPool", "path": "raw_ops/fractionalavgpool", "type": "tf.raw_ops", "text": "\nPerforms fractional average pooling on the input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.FractionalAvgPoolGrad", "path": "raw_ops/fractionalavgpoolgrad", "type": "tf.raw_ops", "text": "\nComputes gradient of the FractionalAvgPool function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.FractionalMaxPool", "path": "raw_ops/fractionalmaxpool", "type": "tf.raw_ops", "text": "\nPerforms fractional max pooling on the input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.FractionalMaxPoolGrad", "path": "raw_ops/fractionalmaxpoolgrad", "type": "tf.raw_ops", "text": "\nComputes gradient of the FractionalMaxPool function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.FresnelCos", "path": "raw_ops/fresnelcos", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.FresnelSin", "path": "raw_ops/fresnelsin", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.FusedBatchNorm", "path": "raw_ops/fusedbatchnorm", "type": "tf.raw_ops", "text": "\nBatch normalization.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.FusedBatchNormGrad", "path": "raw_ops/fusedbatchnormgrad", "type": "tf.raw_ops", "text": "\nGradient for batch normalization.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.FusedBatchNormGradV2", "path": "raw_ops/fusedbatchnormgradv2", "type": "tf.raw_ops", "text": "\nGradient for batch normalization.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.FusedBatchNormGradV3", "path": "raw_ops/fusedbatchnormgradv3", "type": "tf.raw_ops", "text": "\nGradient for batch normalization.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.FusedBatchNormV2", "path": "raw_ops/fusedbatchnormv2", "type": "tf.raw_ops", "text": "\nBatch normalization.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.FusedBatchNormV3", "path": "raw_ops/fusedbatchnormv3", "type": "tf.raw_ops", "text": "\nBatch normalization.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.FusedPadConv2D", "path": "raw_ops/fusedpadconv2d", "type": "tf.raw_ops", "text": "\nPerforms a padding as a preprocess during a convolution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.FusedResizeAndPadConv2D", "path": "raw_ops/fusedresizeandpadconv2d", "type": "tf.raw_ops", "text": "\nPerforms a resize and padding as a preprocess during a convolution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Gather", "path": "raw_ops/gather", "type": "tf.raw_ops", "text": "\nGather slices from `params` according to `indices`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.GatherNd", "path": "raw_ops/gathernd", "type": "tf.raw_ops", "text": "\nGather slices from `params` into a Tensor with shape specified by `indices`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.GatherV2", "path": "raw_ops/gatherv2", "type": "tf.raw_ops", "text": "\nGather slices from `params` axis `axis` according to `indices`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.GenerateBoundingBoxProposals", "path": "raw_ops/generateboundingboxproposals", "type": "tf.raw_ops", "text": "\nThis op produces Region of Interests from given bounding boxes(bbox_deltas)\nencoded wrt anchors according to eq.2 in arXiv:1506.01497\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.GenerateVocabRemapping", "path": "raw_ops/generatevocabremapping", "type": "tf.raw_ops", "text": "\nGiven a path to new and old vocabulary files, returns a remapping Tensor of\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.GeneratorDataset", "path": "raw_ops/generatordataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that invokes a function to generate elements.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.GetSessionHandle", "path": "raw_ops/getsessionhandle", "type": "tf.raw_ops", "text": "\nStore the input tensor in the state of the current session.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.GetSessionHandleV2", "path": "raw_ops/getsessionhandlev2", "type": "tf.raw_ops", "text": "\nStore the input tensor in the state of the current session.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.GetSessionTensor", "path": "raw_ops/getsessiontensor", "type": "tf.raw_ops", "text": "\nGet the value of the tensor specified by its handle.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Greater", "path": "raw_ops/greater", "type": "tf.raw_ops", "text": "\nReturns the truth value of (x > y) element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.GreaterEqual", "path": "raw_ops/greaterequal", "type": "tf.raw_ops", "text": "\nReturns the truth value of (x >= y) element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.GroupByReducerDataset", "path": "raw_ops/groupbyreducerdataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that computes a group-by on `input_dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.GroupByWindowDataset", "path": "raw_ops/groupbywindowdataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that computes a windowed group-by on `input_dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.GRUBlockCell", "path": "raw_ops/grublockcell", "type": "tf.raw_ops", "text": "\nComputes the GRU cell forward propagation for 1 time step.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.GRUBlockCellGrad", "path": "raw_ops/grublockcellgrad", "type": "tf.raw_ops", "text": "\nComputes the GRU cell back-propagation for 1 time step.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.GuaranteeConst", "path": "raw_ops/guaranteeconst", "type": "tf.raw_ops", "text": "\nGives a guarantee to the TF runtime that the input tensor is a constant.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.HashTable", "path": "raw_ops/hashtable", "type": "tf.raw_ops", "text": "\nCreates a non-initialized hash table.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.HashTableV2", "path": "raw_ops/hashtablev2", "type": "tf.raw_ops", "text": "\nCreates a non-initialized hash table.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.HistogramFixedWidth", "path": "raw_ops/histogramfixedwidth", "type": "tf.raw_ops", "text": "\nReturn histogram of values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.HistogramSummary", "path": "raw_ops/histogramsummary", "type": "tf.raw_ops", "text": "\nOutputs a `Summary` protocol buffer with a histogram.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.HSVToRGB", "path": "raw_ops/hsvtorgb", "type": "tf.raw_ops", "text": "\nConvert one or more images from HSV to RGB.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Identity", "path": "raw_ops/identity", "type": "tf.raw_ops", "text": "\nReturn a tensor with the same shape and contents as the input tensor or value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.IdentityN", "path": "raw_ops/identityn", "type": "tf.raw_ops", "text": "\nReturns a list of tensors with the same shapes and contents as the input\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.IdentityReader", "path": "raw_ops/identityreader", "type": "tf.raw_ops", "text": "\nA Reader that outputs the queued work as both the key and value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.IdentityReaderV2", "path": "raw_ops/identityreaderv2", "type": "tf.raw_ops", "text": "\nA Reader that outputs the queued work as both the key and value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.If", "path": "raw_ops/if", "type": "tf.raw_ops", "text": "\noutput = cond ? then_branch(input) : else_branch(input)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.IFFT", "path": "raw_ops/ifft", "type": "tf.raw_ops", "text": "\nInverse fast Fourier transform.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.IFFT2D", "path": "raw_ops/ifft2d", "type": "tf.raw_ops", "text": "\nInverse 2D fast Fourier transform.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.IFFT3D", "path": "raw_ops/ifft3d", "type": "tf.raw_ops", "text": "\nInverse 3D fast Fourier transform.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Igamma", "path": "raw_ops/igamma", "type": "tf.raw_ops", "text": "\nCompute the lower regularized incomplete Gamma function `P(a, x)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Igammac", "path": "raw_ops/igammac", "type": "tf.raw_ops", "text": "\nCompute the upper regularized incomplete Gamma function `Q(a, x)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.IgammaGradA", "path": "raw_ops/igammagrada", "type": "tf.raw_ops", "text": "\nComputes the gradient of `igamma(a, x)` wrt `a`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.IgnoreErrorsDataset", "path": "raw_ops/ignoreerrorsdataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that contains the elements of `input_dataset` ignoring\nerrors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Imag", "path": "raw_ops/imag", "type": "tf.raw_ops", "text": "\nReturns the imaginary part of a complex number.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ImageProjectiveTransformV2", "path": "raw_ops/imageprojectivetransformv2", "type": "tf.raw_ops", "text": "\nApplies the given transform to each of the images.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ImageProjectiveTransformV3", "path": "raw_ops/imageprojectivetransformv3", "type": "tf.raw_ops", "text": "\nApplies the given transform to each of the images.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ImageSummary", "path": "raw_ops/imagesummary", "type": "tf.raw_ops", "text": "\nOutputs a `Summary` protocol buffer with images.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ImmutableConst", "path": "raw_ops/immutableconst", "type": "tf.raw_ops", "text": "\nReturns immutable tensor from memory region.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ImportEvent", "path": "raw_ops/importevent", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.InfeedDequeue", "path": "raw_ops/infeeddequeue", "type": "tf.raw_ops", "text": "\nA placeholder op for a value that will be fed into the computation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.InfeedDequeueTuple", "path": "raw_ops/infeeddequeuetuple", "type": "tf.raw_ops", "text": "\nFetches multiple values from infeed as an XLA tuple.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.InfeedEnqueue", "path": "raw_ops/infeedenqueue", "type": "tf.raw_ops", "text": "\nAn op which feeds a single Tensor value into the computation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.InfeedEnqueuePrelinearizedBuffer", "path": "raw_ops/infeedenqueueprelinearizedbuffer", "type": "tf.raw_ops", "text": "\nAn op which enqueues prelinearized buffer into TPU infeed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.InfeedEnqueueTuple", "path": "raw_ops/infeedenqueuetuple", "type": "tf.raw_ops", "text": "\nFeeds multiple Tensor values into the computation as an XLA tuple.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.InitializeTable", "path": "raw_ops/initializetable", "type": "tf.raw_ops", "text": "\nTable initializer that takes two tensors for keys and values respectively.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.InitializeTableFromDataset", "path": "raw_ops/initializetablefromdataset", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.InitializeTableFromTextFile", "path": "raw_ops/initializetablefromtextfile", "type": "tf.raw_ops", "text": "\nInitializes a table from a text file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.InitializeTableFromTextFileV2", "path": "raw_ops/initializetablefromtextfilev2", "type": "tf.raw_ops", "text": "\nInitializes a table from a text file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.InitializeTableV2", "path": "raw_ops/initializetablev2", "type": "tf.raw_ops", "text": "\nTable initializer that takes two tensors for keys and values respectively.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.InplaceAdd", "path": "raw_ops/inplaceadd", "type": "tf.raw_ops", "text": "\nAdds v into specified rows of x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.InplaceSub", "path": "raw_ops/inplacesub", "type": "tf.raw_ops", "text": "\nSubtracts `v` into specified rows of `x`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.InplaceUpdate", "path": "raw_ops/inplaceupdate", "type": "tf.raw_ops", "text": "\nUpdates specified rows 'i' with values 'v'.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.InterleaveDataset", "path": "raw_ops/interleavedataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that applies `f` to the outputs of `input_dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.InTopK", "path": "raw_ops/intopk", "type": "tf.raw_ops", "text": "\nSays whether the targets are in the top `K` predictions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.InTopKV2", "path": "raw_ops/intopkv2", "type": "tf.raw_ops", "text": "\nSays whether the targets are in the top `K` predictions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Inv", "path": "raw_ops/inv", "type": "tf.raw_ops", "text": "\nComputes the reciprocal of x element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Invert", "path": "raw_ops/invert", "type": "tf.raw_ops", "text": "\nInvert (flip) each bit of supported types; for example, type `uint8` value\n01010101 becomes 10101010.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.InvertPermutation", "path": "raw_ops/invertpermutation", "type": "tf.raw_ops", "text": "\nComputes the inverse permutation of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.InvGrad", "path": "raw_ops/invgrad", "type": "tf.raw_ops", "text": "\nComputes the gradient for the inverse of `x` wrt its input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.IRFFT", "path": "raw_ops/irfft", "type": "tf.raw_ops", "text": "\nInverse real-valued fast Fourier transform.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.IRFFT2D", "path": "raw_ops/irfft2d", "type": "tf.raw_ops", "text": "\nInverse 2D real-valued fast Fourier transform.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.IRFFT3D", "path": "raw_ops/irfft3d", "type": "tf.raw_ops", "text": "\nInverse 3D real-valued fast Fourier transform.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.IsBoostedTreesEnsembleInitialized", "path": "raw_ops/isboostedtreesensembleinitialized", "type": "tf.raw_ops", "text": "\nChecks whether a tree ensemble has been initialized.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.IsBoostedTreesQuantileStreamResourceInitialized", "path": "raw_ops/isboostedtreesquantilestreamresourceinitialized", "type": "tf.raw_ops", "text": "\nChecks whether a quantile stream has been initialized.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.IsFinite", "path": "raw_ops/isfinite", "type": "tf.raw_ops", "text": "\nReturns which elements of x are finite.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.IsInf", "path": "raw_ops/isinf", "type": "tf.raw_ops", "text": "\nReturns which elements of x are Inf.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.IsNan", "path": "raw_ops/isnan", "type": "tf.raw_ops", "text": "\nReturns which elements of x are NaN.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.IsotonicRegression", "path": "raw_ops/isotonicregression", "type": "tf.raw_ops", "text": "\nSolves a batch of isotonic regression problems.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.IsVariableInitialized", "path": "raw_ops/isvariableinitialized", "type": "tf.raw_ops", "text": "\nChecks whether a tensor has been initialized.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Iterator", "path": "raw_ops/iterator", "type": "tf.raw_ops", "text": "\nA container for an iterator resource.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.IteratorFromStringHandle", "path": "raw_ops/iteratorfromstringhandle", "type": "tf.raw_ops", "text": "\nConverts the given string representing a handle to an iterator to a resource.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.IteratorFromStringHandleV2", "path": "raw_ops/iteratorfromstringhandlev2", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.IteratorGetDevice", "path": "raw_ops/iteratorgetdevice", "type": "tf.raw_ops", "text": "\nReturns the name of the device on which `resource` has been placed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.IteratorGetNext", "path": "raw_ops/iteratorgetnext", "type": "tf.raw_ops", "text": "\nGets the next output from the given iterator .\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.IteratorGetNextAsOptional", "path": "raw_ops/iteratorgetnextasoptional", "type": "tf.raw_ops", "text": "\nGets the next output from the given iterator as an Optional variant.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.IteratorGetNextSync", "path": "raw_ops/iteratorgetnextsync", "type": "tf.raw_ops", "text": "\nGets the next output from the given iterator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.IteratorToStringHandle", "path": "raw_ops/iteratortostringhandle", "type": "tf.raw_ops", "text": "\nConverts the given `resource_handle` representing an iterator to a string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.IteratorV2", "path": "raw_ops/iteratorv2", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.L2Loss", "path": "raw_ops/l2loss", "type": "tf.raw_ops", "text": "\nL2 Loss.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LatencyStatsDataset", "path": "raw_ops/latencystatsdataset", "type": "tf.raw_ops", "text": "\nRecords the latency of producing `input_dataset` elements in a\nStatsAggregator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LeakyRelu", "path": "raw_ops/leakyrelu", "type": "tf.raw_ops", "text": "\nComputes rectified linear: `max(features, features * alpha)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LeakyReluGrad", "path": "raw_ops/leakyrelugrad", "type": "tf.raw_ops", "text": "\nComputes rectified linear gradients for a LeakyRelu operation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LearnedUnigramCandidateSampler", "path": "raw_ops/learnedunigramcandidatesampler", "type": "tf.raw_ops", "text": "\nGenerates labels for candidate sampling with a learned unigram distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LeftShift", "path": "raw_ops/leftshift", "type": "tf.raw_ops", "text": "\nElementwise computes the bitwise left-shift of `x` and `y`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LegacyParallelInterleaveDatasetV2", "path": "raw_ops/legacyparallelinterleavedatasetv2", "type": "tf.raw_ops", "text": "\nCreates a dataset that applies `f` to the outputs of `input_dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Less", "path": "raw_ops/less", "type": "tf.raw_ops", "text": "\nReturns the truth value of (x < y) element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LessEqual", "path": "raw_ops/lessequal", "type": "tf.raw_ops", "text": "\nReturns the truth value of (x <= y) element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Lgamma", "path": "raw_ops/lgamma", "type": "tf.raw_ops", "text": "\nComputes the log of the absolute value of `Gamma(x)` element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LinSpace", "path": "raw_ops/linspace", "type": "tf.raw_ops", "text": "\nGenerates values in an interval.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ListDiff", "path": "raw_ops/listdiff", "type": "tf.raw_ops", "text": "\nComputes the difference between two lists of numbers or strings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LMDBDataset", "path": "raw_ops/lmdbdataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that emits the key-value pairs in one or more LMDB files.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LMDBReader", "path": "raw_ops/lmdbreader", "type": "tf.raw_ops", "text": "\nA Reader that outputs the records from a LMDB file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LoadAndRemapMatrix", "path": "raw_ops/loadandremapmatrix", "type": "tf.raw_ops", "text": "\nLoads a 2-D (matrix) `Tensor` with name `old_tensor_name` from the checkpoint\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LoadDataset", "path": "raw_ops/loaddataset", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LoadTPUEmbeddingAdadeltaParameters", "path": "raw_ops/loadtpuembeddingadadeltaparameters", "type": "tf.raw_ops", "text": "\nLoad Adadelta embedding parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LoadTPUEmbeddingAdadeltaParametersGradAccumDebug", "path": "raw_ops/loadtpuembeddingadadeltaparametersgradaccumdebug", "type": "tf.raw_ops", "text": "\nLoad Adadelta parameters with debug support.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LoadTPUEmbeddingAdagradParameters", "path": "raw_ops/loadtpuembeddingadagradparameters", "type": "tf.raw_ops", "text": "\nLoad Adagrad embedding parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LoadTPUEmbeddingAdagradParametersGradAccumDebug", "path": "raw_ops/loadtpuembeddingadagradparametersgradaccumdebug", "type": "tf.raw_ops", "text": "\nLoad Adagrad embedding parameters with debug support.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LoadTPUEmbeddingADAMParameters", "path": "raw_ops/loadtpuembeddingadamparameters", "type": "tf.raw_ops", "text": "\nLoad ADAM embedding parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LoadTPUEmbeddingADAMParametersGradAccumDebug", "path": "raw_ops/loadtpuembeddingadamparametersgradaccumdebug", "type": "tf.raw_ops", "text": "\nLoad ADAM embedding parameters with debug support.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LoadTPUEmbeddingCenteredRMSPropParameters", "path": "raw_ops/loadtpuembeddingcenteredrmspropparameters", "type": "tf.raw_ops", "text": "\nLoad centered RMSProp embedding parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LoadTPUEmbeddingFTRLParameters", "path": "raw_ops/loadtpuembeddingftrlparameters", "type": "tf.raw_ops", "text": "\nLoad FTRL embedding parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LoadTPUEmbeddingFTRLParametersGradAccumDebug", "path": "raw_ops/loadtpuembeddingftrlparametersgradaccumdebug", "type": "tf.raw_ops", "text": "\nLoad FTRL embedding parameters with debug support.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LoadTPUEmbeddingMDLAdagradLightParameters", "path": "raw_ops/loadtpuembeddingmdladagradlightparameters", "type": "tf.raw_ops", "text": "\nLoad MDL Adagrad Light embedding parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LoadTPUEmbeddingMomentumParameters", "path": "raw_ops/loadtpuembeddingmomentumparameters", "type": "tf.raw_ops", "text": "\nLoad Momentum embedding parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LoadTPUEmbeddingMomentumParametersGradAccumDebug", "path": "raw_ops/loadtpuembeddingmomentumparametersgradaccumdebug", "type": "tf.raw_ops", "text": "\nLoad Momentum embedding parameters with debug support.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LoadTPUEmbeddingProximalAdagradParameters", "path": "raw_ops/loadtpuembeddingproximaladagradparameters", "type": "tf.raw_ops", "text": "\nLoad proximal Adagrad embedding parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LoadTPUEmbeddingProximalAdagradParametersGradAccumDebug", "path": "raw_ops/loadtpuembeddingproximaladagradparametersgradaccumdebug", "type": "tf.raw_ops", "text": "\nLoad proximal Adagrad embedding parameters with debug support.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LoadTPUEmbeddingProximalYogiParameters", "path": "raw_ops/loadtpuembeddingproximalyogiparameters", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LoadTPUEmbeddingProximalYogiParametersGradAccumDebug", "path": "raw_ops/loadtpuembeddingproximalyogiparametersgradaccumdebug", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LoadTPUEmbeddingRMSPropParameters", "path": "raw_ops/loadtpuembeddingrmspropparameters", "type": "tf.raw_ops", "text": "\nLoad RMSProp embedding parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LoadTPUEmbeddingRMSPropParametersGradAccumDebug", "path": "raw_ops/loadtpuembeddingrmspropparametersgradaccumdebug", "type": "tf.raw_ops", "text": "\nLoad RMSProp embedding parameters with debug support.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LoadTPUEmbeddingStochasticGradientDescentParameters", "path": "raw_ops/loadtpuembeddingstochasticgradientdescentparameters", "type": "tf.raw_ops", "text": "\nLoad SGD embedding parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LoadTPUEmbeddingStochasticGradientDescentParametersGradAccumDebug", "path": "raw_ops/loadtpuembeddingstochasticgradientdescentparametersgradaccumdebug", "type": "tf.raw_ops", "text": "\nLoad SGD embedding parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Log", "path": "raw_ops/log", "type": "tf.raw_ops", "text": "\nComputes natural logarithm of x element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Log1p", "path": "raw_ops/log1p", "type": "tf.raw_ops", "text": "\nComputes natural logarithm of (1 + x) element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LogicalAnd", "path": "raw_ops/logicaland", "type": "tf.raw_ops", "text": "\nReturns the truth value of x AND y element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LogicalNot", "path": "raw_ops/logicalnot", "type": "tf.raw_ops", "text": "\nReturns the truth value of `NOT x` element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LogicalOr", "path": "raw_ops/logicalor", "type": "tf.raw_ops", "text": "\nReturns the truth value of x OR y element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LogMatrixDeterminant", "path": "raw_ops/logmatrixdeterminant", "type": "tf.raw_ops", "text": "\nComputes the sign and the log of the absolute value of the determinant of\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LogSoftmax", "path": "raw_ops/logsoftmax", "type": "tf.raw_ops", "text": "\nComputes log softmax activations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LogUniformCandidateSampler", "path": "raw_ops/loguniformcandidatesampler", "type": "tf.raw_ops", "text": "\nGenerates labels for candidate sampling with a log-uniform distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LookupTableExport", "path": "raw_ops/lookuptableexport", "type": "tf.raw_ops", "text": "\nOutputs all keys and values in the table.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LookupTableExportV2", "path": "raw_ops/lookuptableexportv2", "type": "tf.raw_ops", "text": "\nOutputs all keys and values in the table.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LookupTableFind", "path": "raw_ops/lookuptablefind", "type": "tf.raw_ops", "text": "\nLooks up keys in a table, outputs the corresponding values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LookupTableFindV2", "path": "raw_ops/lookuptablefindv2", "type": "tf.raw_ops", "text": "\nLooks up keys in a table, outputs the corresponding values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LookupTableImport", "path": "raw_ops/lookuptableimport", "type": "tf.raw_ops", "text": "\nReplaces the contents of the table with the specified keys and values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LookupTableImportV2", "path": "raw_ops/lookuptableimportv2", "type": "tf.raw_ops", "text": "\nReplaces the contents of the table with the specified keys and values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LookupTableInsert", "path": "raw_ops/lookuptableinsert", "type": "tf.raw_ops", "text": "\nUpdates the table to associates keys with values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LookupTableInsertV2", "path": "raw_ops/lookuptableinsertv2", "type": "tf.raw_ops", "text": "\nUpdates the table to associates keys with values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LookupTableRemoveV2", "path": "raw_ops/lookuptableremovev2", "type": "tf.raw_ops", "text": "\nRemoves keys and its associated values from a table.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LookupTableSize", "path": "raw_ops/lookuptablesize", "type": "tf.raw_ops", "text": "\nComputes the number of elements in the given table.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LookupTableSizeV2", "path": "raw_ops/lookuptablesizev2", "type": "tf.raw_ops", "text": "\nComputes the number of elements in the given table.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LoopCond", "path": "raw_ops/loopcond", "type": "tf.raw_ops", "text": "\nForwards the input to the output.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LowerBound", "path": "raw_ops/lowerbound", "type": "tf.raw_ops", "text": "\nApplies lower_bound(sorted_search_values, values) along each row.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LRN", "path": "raw_ops/lrn", "type": "tf.raw_ops", "text": "\nLocal Response Normalization.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LRNGrad", "path": "raw_ops/lrngrad", "type": "tf.raw_ops", "text": "\nGradients for Local Response Normalization.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LSTMBlockCell", "path": "raw_ops/lstmblockcell", "type": "tf.raw_ops", "text": "\nComputes the LSTM cell forward propagation for 1 time step.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.LSTMBlockCellGrad", "path": "raw_ops/lstmblockcellgrad", "type": "tf.raw_ops", "text": "\nComputes the LSTM cell backward propagation for 1 timestep.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Lu", "path": "raw_ops/lu", "type": "tf.raw_ops", "text": "\nComputes the LU decomposition of one or more square matrices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MakeIterator", "path": "raw_ops/makeiterator", "type": "tf.raw_ops", "text": "\nMakes a new iterator from the given `dataset` and stores it in `iterator`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MapAndBatchDataset", "path": "raw_ops/mapandbatchdataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that fuses mapping with batching.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MapClear", "path": "raw_ops/mapclear", "type": "tf.raw_ops", "text": "\nOp removes all elements in the underlying container.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MapDataset", "path": "raw_ops/mapdataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that applies `f` to the outputs of `input_dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MapDefun", "path": "raw_ops/mapdefun", "type": "tf.raw_ops", "text": "\nMaps a function on the list of tensors unpacked from arguments on dimension 0.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MapIncompleteSize", "path": "raw_ops/mapincompletesize", "type": "tf.raw_ops", "text": "\nOp returns the number of incomplete elements in the underlying container.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MapPeek", "path": "raw_ops/mappeek", "type": "tf.raw_ops", "text": "\nOp peeks at the values at the specified key. If the\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MapSize", "path": "raw_ops/mapsize", "type": "tf.raw_ops", "text": "\nOp returns the number of elements in the underlying container.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MapStage", "path": "raw_ops/mapstage", "type": "tf.raw_ops", "text": "\nStage (key, values) in the underlying container which behaves like a\nhashtable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MapUnstage", "path": "raw_ops/mapunstage", "type": "tf.raw_ops", "text": "\nOp removes and returns the values associated with the key\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MapUnstageNoKey", "path": "raw_ops/mapunstagenokey", "type": "tf.raw_ops", "text": "\nOp removes and returns a random (key, value)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MatchingFiles", "path": "raw_ops/matchingfiles", "type": "tf.raw_ops", "text": "\nReturns the set of files matching one or more glob patterns.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MatchingFilesDataset", "path": "raw_ops/matchingfilesdataset", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MatMul", "path": "raw_ops/matmul", "type": "tf.raw_ops", "text": "\nMultiply the matrix \"a\" by the matrix \"b\".\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MatrixBandPart", "path": "raw_ops/matrixbandpart", "type": "tf.raw_ops", "text": "\nCopy a tensor setting everything outside a central band in each innermost\nmatrix to zero.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MatrixDeterminant", "path": "raw_ops/matrixdeterminant", "type": "tf.raw_ops", "text": "\nComputes the determinant of one or more square matrices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MatrixDiag", "path": "raw_ops/matrixdiag", "type": "tf.raw_ops", "text": "\nReturns a batched diagonal tensor with a given batched diagonal values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MatrixDiagPart", "path": "raw_ops/matrixdiagpart", "type": "tf.raw_ops", "text": "\nReturns the batched diagonal part of a batched tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MatrixDiagPartV2", "path": "raw_ops/matrixdiagpartv2", "type": "tf.raw_ops", "text": "\nReturns the batched diagonal part of a batched tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MatrixDiagPartV3", "path": "raw_ops/matrixdiagpartv3", "type": "tf.raw_ops", "text": "\nReturns the batched diagonal part of a batched tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MatrixDiagV2", "path": "raw_ops/matrixdiagv2", "type": "tf.raw_ops", "text": "\nReturns a batched diagonal tensor with given batched diagonal values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MatrixDiagV3", "path": "raw_ops/matrixdiagv3", "type": "tf.raw_ops", "text": "\nReturns a batched diagonal tensor with given batched diagonal values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MatrixExponential", "path": "raw_ops/matrixexponential", "type": "tf.raw_ops", "text": "\nDeprecated, use python implementation tf.linalg.matrix_exponential.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MatrixInverse", "path": "raw_ops/matrixinverse", "type": "tf.raw_ops", "text": "\nComputes the inverse of one or more square invertible matrices or their\nadjoints (conjugate transposes).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MatrixLogarithm", "path": "raw_ops/matrixlogarithm", "type": "tf.raw_ops", "text": "\nComputes the matrix logarithm of one or more square matrices:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MatrixSetDiag", "path": "raw_ops/matrixsetdiag", "type": "tf.raw_ops", "text": "\nReturns a batched matrix tensor with new batched diagonal values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MatrixSetDiagV2", "path": "raw_ops/matrixsetdiagv2", "type": "tf.raw_ops", "text": "\nReturns a batched matrix tensor with new batched diagonal values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MatrixSetDiagV3", "path": "raw_ops/matrixsetdiagv3", "type": "tf.raw_ops", "text": "\nReturns a batched matrix tensor with new batched diagonal values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MatrixSolve", "path": "raw_ops/matrixsolve", "type": "tf.raw_ops", "text": "\nSolves systems of linear equations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MatrixSolveLs", "path": "raw_ops/matrixsolvels", "type": "tf.raw_ops", "text": "\nSolves one or more linear least-squares problems.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MatrixSquareRoot", "path": "raw_ops/matrixsquareroot", "type": "tf.raw_ops", "text": "\nComputes the matrix square root of one or more square matrices:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MatrixTriangularSolve", "path": "raw_ops/matrixtriangularsolve", "type": "tf.raw_ops", "text": "\nSolves systems of linear equations with upper or lower triangular matrices by\nbacksubstitution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Max", "path": "raw_ops/max", "type": "tf.raw_ops", "text": "\nComputes the maximum of elements across dimensions of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Maximum", "path": "raw_ops/maximum", "type": "tf.raw_ops", "text": "\nReturns the max of x and y (i.e. x > y ? x : y) element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MaxIntraOpParallelismDataset", "path": "raw_ops/maxintraopparallelismdataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that overrides the maximum intra-op parallelism.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MaxPool", "path": "raw_ops/maxpool", "type": "tf.raw_ops", "text": "\nPerforms max pooling on the input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MaxPool3D", "path": "raw_ops/maxpool3d", "type": "tf.raw_ops", "text": "\nPerforms 3D max pooling on the input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MaxPool3DGrad", "path": "raw_ops/maxpool3dgrad", "type": "tf.raw_ops", "text": "\nComputes gradients of 3D max pooling function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MaxPool3DGradGrad", "path": "raw_ops/maxpool3dgradgrad", "type": "tf.raw_ops", "text": "\nComputes second-order gradients of the maxpooling function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MaxPoolGrad", "path": "raw_ops/maxpoolgrad", "type": "tf.raw_ops", "text": "\nComputes gradients of the maxpooling function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MaxPoolGradGrad", "path": "raw_ops/maxpoolgradgrad", "type": "tf.raw_ops", "text": "\nComputes second-order gradients of the maxpooling function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MaxPoolGradGradV2", "path": "raw_ops/maxpoolgradgradv2", "type": "tf.raw_ops", "text": "\nComputes second-order gradients of the maxpooling function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MaxPoolGradGradWithArgmax", "path": "raw_ops/maxpoolgradgradwithargmax", "type": "tf.raw_ops", "text": "\nComputes second-order gradients of the maxpooling function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MaxPoolGradV2", "path": "raw_ops/maxpoolgradv2", "type": "tf.raw_ops", "text": "\nComputes gradients of the maxpooling function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MaxPoolGradWithArgmax", "path": "raw_ops/maxpoolgradwithargmax", "type": "tf.raw_ops", "text": "\nComputes gradients of the maxpooling function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MaxPoolV2", "path": "raw_ops/maxpoolv2", "type": "tf.raw_ops", "text": "\nPerforms max pooling on the input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MaxPoolWithArgmax", "path": "raw_ops/maxpoolwithargmax", "type": "tf.raw_ops", "text": "\nPerforms max pooling on the input and outputs both max values and indices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Mean", "path": "raw_ops/mean", "type": "tf.raw_ops", "text": "\nComputes the mean of elements across dimensions of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Merge", "path": "raw_ops/merge", "type": "tf.raw_ops", "text": "\nForwards the value of an available tensor from `inputs` to `output`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MergeSummary", "path": "raw_ops/mergesummary", "type": "tf.raw_ops", "text": "\nMerges summaries.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MergeV2Checkpoints", "path": "raw_ops/mergev2checkpoints", "type": "tf.raw_ops", "text": "\nV2 format specific: merges the metadata files of sharded checkpoints. The\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Mfcc", "path": "raw_ops/mfcc", "type": "tf.raw_ops", "text": "\nTransforms a spectrogram into a form that's useful for speech recognition.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Min", "path": "raw_ops/min", "type": "tf.raw_ops", "text": "\nComputes the minimum of elements across dimensions of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Minimum", "path": "raw_ops/minimum", "type": "tf.raw_ops", "text": "\nReturns the min of x and y (i.e. x < y ? x : y) element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MirrorPad", "path": "raw_ops/mirrorpad", "type": "tf.raw_ops", "text": "\nPads a tensor with mirrored values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MirrorPadGrad", "path": "raw_ops/mirrorpadgrad", "type": "tf.raw_ops", "text": "\nGradient op for `MirrorPad` op. This op folds a mirror-padded tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Mod", "path": "raw_ops/mod", "type": "tf.raw_ops", "text": "\nReturns element-wise remainder of division. This emulates C semantics in that\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ModelDataset", "path": "raw_ops/modeldataset", "type": "tf.raw_ops", "text": "\nIdentity transformation that models performance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Mul", "path": "raw_ops/mul", "type": "tf.raw_ops", "text": "\nReturns x * y element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MulNoNan", "path": "raw_ops/mulnonan", "type": "tf.raw_ops", "text": "\nReturns x * y element-wise. Returns zero if y is zero, even if x if infinite\nor NaN.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MultiDeviceIterator", "path": "raw_ops/multideviceiterator", "type": "tf.raw_ops", "text": "\nCreates a MultiDeviceIterator resource.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MultiDeviceIteratorFromStringHandle", "path": "raw_ops/multideviceiteratorfromstringhandle", "type": "tf.raw_ops", "text": "\nGenerates a MultiDeviceIterator resource from its provided string handle.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MultiDeviceIteratorGetNextFromShard", "path": "raw_ops/multideviceiteratorgetnextfromshard", "type": "tf.raw_ops", "text": "\nGets next element for the provided shard number.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MultiDeviceIteratorInit", "path": "raw_ops/multideviceiteratorinit", "type": "tf.raw_ops", "text": "\nInitializes the multi device iterator with the given dataset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MultiDeviceIteratorToStringHandle", "path": "raw_ops/multideviceiteratortostringhandle", "type": "tf.raw_ops", "text": "\nProduces a string handle for the given MultiDeviceIterator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Multinomial", "path": "raw_ops/multinomial", "type": "tf.raw_ops", "text": "\nDraws samples from a multinomial distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MutableDenseHashTable", "path": "raw_ops/mutabledensehashtable", "type": "tf.raw_ops", "text": "\nCreates an empty hash table that uses tensors as the backing store.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MutableDenseHashTableV2", "path": "raw_ops/mutabledensehashtablev2", "type": "tf.raw_ops", "text": "\nCreates an empty hash table that uses tensors as the backing store.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MutableHashTable", "path": "raw_ops/mutablehashtable", "type": "tf.raw_ops", "text": "\nCreates an empty hash table.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MutableHashTableOfTensors", "path": "raw_ops/mutablehashtableoftensors", "type": "tf.raw_ops", "text": "\nCreates an empty hash table.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MutableHashTableOfTensorsV2", "path": "raw_ops/mutablehashtableoftensorsv2", "type": "tf.raw_ops", "text": "\nCreates an empty hash table.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MutableHashTableV2", "path": "raw_ops/mutablehashtablev2", "type": "tf.raw_ops", "text": "\nCreates an empty hash table.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MutexLock", "path": "raw_ops/mutexlock", "type": "tf.raw_ops", "text": "\nLocks a mutex resource. The output is the lock. So long as the lock tensor\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.MutexV2", "path": "raw_ops/mutexv2", "type": "tf.raw_ops", "text": "\nCreates a Mutex resource that can be locked by `MutexLock`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.NcclAllReduce", "path": "raw_ops/ncclallreduce", "type": "tf.raw_ops", "text": "\nOutputs a tensor containing the reduction across all input tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.NcclBroadcast", "path": "raw_ops/ncclbroadcast", "type": "tf.raw_ops", "text": "\nSends `input` to all devices that are connected to the output.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.NcclReduce", "path": "raw_ops/ncclreduce", "type": "tf.raw_ops", "text": "\nReduces `input` from `num_devices` using `reduction` to a single device.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Ndtri", "path": "raw_ops/ndtri", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Neg", "path": "raw_ops/neg", "type": "tf.raw_ops", "text": "\nComputes numerical negative value element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.NextAfter", "path": "raw_ops/nextafter", "type": "tf.raw_ops", "text": "\nReturns the next representable value of `x1` in the direction of `x2`,\nelement-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.NextIteration", "path": "raw_ops/nextiteration", "type": "tf.raw_ops", "text": "\nMakes its input available to the next iteration.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.NonDeterministicInts", "path": "raw_ops/nondeterministicints", "type": "tf.raw_ops", "text": "\nNon-deterministically generates some integers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.NonMaxSuppression", "path": "raw_ops/nonmaxsuppression", "type": "tf.raw_ops", "text": "\nGreedily selects a subset of bounding boxes in descending order of score,\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.NonMaxSuppressionV2", "path": "raw_ops/nonmaxsuppressionv2", "type": "tf.raw_ops", "text": "\nGreedily selects a subset of bounding boxes in descending order of score,\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.NonMaxSuppressionV3", "path": "raw_ops/nonmaxsuppressionv3", "type": "tf.raw_ops", "text": "\nGreedily selects a subset of bounding boxes in descending order of score,\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.NonMaxSuppressionV4", "path": "raw_ops/nonmaxsuppressionv4", "type": "tf.raw_ops", "text": "\nGreedily selects a subset of bounding boxes in descending order of score,\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.NonMaxSuppressionV5", "path": "raw_ops/nonmaxsuppressionv5", "type": "tf.raw_ops", "text": "\nGreedily selects a subset of bounding boxes in descending order of score,\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.NonMaxSuppressionWithOverlaps", "path": "raw_ops/nonmaxsuppressionwithoverlaps", "type": "tf.raw_ops", "text": "\nGreedily selects a subset of bounding boxes in descending order of score,\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.NonSerializableDataset", "path": "raw_ops/nonserializabledataset", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.NoOp", "path": "raw_ops/noop", "type": "tf.raw_ops", "text": "\nDoes nothing. Only useful as a placeholder for control edges.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.NotEqual", "path": "raw_ops/notequal", "type": "tf.raw_ops", "text": "\nReturns the truth value of (x != y) element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.NthElement", "path": "raw_ops/nthelement", "type": "tf.raw_ops", "text": "\nFinds values of the `n`-th order statistic for the last dimension.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.OneHot", "path": "raw_ops/onehot", "type": "tf.raw_ops", "text": "\nReturns a one-hot tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.OneShotIterator", "path": "raw_ops/oneshotiterator", "type": "tf.raw_ops", "text": "\nMakes a \"one-shot\" iterator that can be iterated only once.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.OnesLike", "path": "raw_ops/oneslike", "type": "tf.raw_ops", "text": "\nReturns a tensor of ones with the same shape and type as x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.OptimizeDataset", "path": "raw_ops/optimizedataset", "type": "tf.raw_ops", "text": "\nCreates a dataset by applying optimizations to `input_dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.OptimizeDatasetV2", "path": "raw_ops/optimizedatasetv2", "type": "tf.raw_ops", "text": "\nCreates a dataset by applying related optimizations to `input_dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.OptionalFromValue", "path": "raw_ops/optionalfromvalue", "type": "tf.raw_ops", "text": "\nConstructs an Optional variant from a tuple of tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.OptionalGetValue", "path": "raw_ops/optionalgetvalue", "type": "tf.raw_ops", "text": "\nReturns the value stored in an Optional variant or raises an error if none\nexists.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.OptionalHasValue", "path": "raw_ops/optionalhasvalue", "type": "tf.raw_ops", "text": "\nReturns true if and only if the given Optional variant has a value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.OptionalNone", "path": "raw_ops/optionalnone", "type": "tf.raw_ops", "text": "\nCreates an Optional variant with no value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.OrderedMapClear", "path": "raw_ops/orderedmapclear", "type": "tf.raw_ops", "text": "\nOp removes all elements in the underlying container.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.OrderedMapIncompleteSize", "path": "raw_ops/orderedmapincompletesize", "type": "tf.raw_ops", "text": "\nOp returns the number of incomplete elements in the underlying container.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.OrderedMapPeek", "path": "raw_ops/orderedmappeek", "type": "tf.raw_ops", "text": "\nOp peeks at the values at the specified key. If the\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.OrderedMapSize", "path": "raw_ops/orderedmapsize", "type": "tf.raw_ops", "text": "\nOp returns the number of elements in the underlying container.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.OrderedMapStage", "path": "raw_ops/orderedmapstage", "type": "tf.raw_ops", "text": "\nStage (key, values) in the underlying container which behaves like a ordered\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.OrderedMapUnstage", "path": "raw_ops/orderedmapunstage", "type": "tf.raw_ops", "text": "\nOp removes and returns the values associated with the key\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.OrderedMapUnstageNoKey", "path": "raw_ops/orderedmapunstagenokey", "type": "tf.raw_ops", "text": "\nOp removes and returns the (key, value) element with the smallest\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.OutfeedDequeue", "path": "raw_ops/outfeeddequeue", "type": "tf.raw_ops", "text": "\nRetrieves a single tensor from the computation outfeed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.OutfeedDequeueTuple", "path": "raw_ops/outfeeddequeuetuple", "type": "tf.raw_ops", "text": "\nRetrieve multiple values from the computation outfeed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.OutfeedDequeueTupleV2", "path": "raw_ops/outfeeddequeuetuplev2", "type": "tf.raw_ops", "text": "\nRetrieve multiple values from the computation outfeed. Device ordinal is a\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.OutfeedDequeueV2", "path": "raw_ops/outfeeddequeuev2", "type": "tf.raw_ops", "text": "\nRetrieves a single tensor from the computation outfeed. Device ordinal is a\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.OutfeedEnqueue", "path": "raw_ops/outfeedenqueue", "type": "tf.raw_ops", "text": "\nEnqueue a Tensor on the computation outfeed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.OutfeedEnqueueTuple", "path": "raw_ops/outfeedenqueuetuple", "type": "tf.raw_ops", "text": "\nEnqueue multiple Tensor values on the computation outfeed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Pack", "path": "raw_ops/pack", "type": "tf.raw_ops", "text": "\nPacks a list of `N` rank-`R` tensors into one rank-`(R+1)` tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Pad", "path": "raw_ops/pad", "type": "tf.raw_ops", "text": "\nPads a tensor with zeros.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.PaddedBatchDataset", "path": "raw_ops/paddedbatchdataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that batches and pads `batch_size` elements from the input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.PaddedBatchDatasetV2", "path": "raw_ops/paddedbatchdatasetv2", "type": "tf.raw_ops", "text": "\nCreates a dataset that batches and pads `batch_size` elements from the input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.PaddingFIFOQueue", "path": "raw_ops/paddingfifoqueue", "type": "tf.raw_ops", "text": "\nA queue that produces elements in first-in first-out order.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.PaddingFIFOQueueV2", "path": "raw_ops/paddingfifoqueuev2", "type": "tf.raw_ops", "text": "\nA queue that produces elements in first-in first-out order.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.PadV2", "path": "raw_ops/padv2", "type": "tf.raw_ops", "text": "\nPads a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ParallelConcat", "path": "raw_ops/parallelconcat", "type": "tf.raw_ops", "text": "\nConcatenates a list of `N` tensors along the first dimension.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ParallelDynamicStitch", "path": "raw_ops/paralleldynamicstitch", "type": "tf.raw_ops", "text": "\nInterleave the values from the `data` tensors into a single tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ParallelInterleaveDataset", "path": "raw_ops/parallelinterleavedataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that applies `f` to the outputs of `input_dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ParallelInterleaveDatasetV2", "path": "raw_ops/parallelinterleavedatasetv2", "type": "tf.raw_ops", "text": "\nCreates a dataset that applies `f` to the outputs of `input_dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ParallelInterleaveDatasetV3", "path": "raw_ops/parallelinterleavedatasetv3", "type": "tf.raw_ops", "text": "\nCreates a dataset that applies `f` to the outputs of `input_dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ParallelInterleaveDatasetV4", "path": "raw_ops/parallelinterleavedatasetv4", "type": "tf.raw_ops", "text": "\nCreates a dataset that applies `f` to the outputs of `input_dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ParallelMapDataset", "path": "raw_ops/parallelmapdataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that applies `f` to the outputs of `input_dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ParallelMapDatasetV2", "path": "raw_ops/parallelmapdatasetv2", "type": "tf.raw_ops", "text": "\nCreates a dataset that applies `f` to the outputs of `input_dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ParameterizedTruncatedNormal", "path": "raw_ops/parameterizedtruncatednormal", "type": "tf.raw_ops", "text": "\nOutputs random values from a normal distribution. The parameters may each be a\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ParseExample", "path": "raw_ops/parseexample", "type": "tf.raw_ops", "text": "\nTransforms a vector of brain.Example protos (as strings) into typed tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ParseExampleDataset", "path": "raw_ops/parseexampledataset", "type": "tf.raw_ops", "text": "\nTransforms `input_dataset` containing `Example` protos as vectors of DT_STRING\ninto a dataset of `Tensor` or `SparseTensor` objects representing the parsed\nfeatures.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ParseExampleDatasetV2", "path": "raw_ops/parseexampledatasetv2", "type": "tf.raw_ops", "text": "\nTransforms `input_dataset` containing `Example` protos as vectors of DT_STRING\ninto a dataset of `Tensor` or `SparseTensor` objects representing the parsed\nfeatures.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ParseExampleV2", "path": "raw_ops/parseexamplev2", "type": "tf.raw_ops", "text": "\nTransforms a vector of tf.Example protos (as strings) into typed tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ParseSequenceExample", "path": "raw_ops/parsesequenceexample", "type": "tf.raw_ops", "text": "\nTransforms a vector of brain.SequenceExample protos (as strings) into typed\ntensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ParseSequenceExampleV2", "path": "raw_ops/parsesequenceexamplev2", "type": "tf.raw_ops", "text": "\nTransforms a vector of tf.io.SequenceExample protos (as strings) into\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ParseSingleExample", "path": "raw_ops/parsesingleexample", "type": "tf.raw_ops", "text": "\nTransforms a tf.Example proto (as a string) into typed tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ParseSingleSequenceExample", "path": "raw_ops/parsesinglesequenceexample", "type": "tf.raw_ops", "text": "\nTransforms a scalar brain.SequenceExample proto (as strings) into typed\ntensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ParseTensor", "path": "raw_ops/parsetensor", "type": "tf.raw_ops", "text": "\nTransforms a serialized tensorflow.TensorProto proto into a Tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.PartitionedCall", "path": "raw_ops/partitionedcall", "type": "tf.raw_ops", "text": "\nreturns `f(inputs)`, where `f`'s body is placed and partitioned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Placeholder", "path": "raw_ops/placeholder", "type": "tf.raw_ops", "text": "\nA placeholder op for a value that will be fed into the computation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.PlaceholderV2", "path": "raw_ops/placeholderv2", "type": "tf.raw_ops", "text": "\nA placeholder op for a value that will be fed into the computation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.PlaceholderWithDefault", "path": "raw_ops/placeholderwithdefault", "type": "tf.raw_ops", "text": "\nA placeholder op that passes through `input` when its output is not fed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Polygamma", "path": "raw_ops/polygamma", "type": "tf.raw_ops", "text": "\nCompute the polygamma function \\\\(\\psi^{(n)}(x)\\\\).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.PopulationCount", "path": "raw_ops/populationcount", "type": "tf.raw_ops", "text": "\nComputes element-wise population count (a.k.a. popcount, bitsum, bitcount).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Pow", "path": "raw_ops/pow", "type": "tf.raw_ops", "text": "\nComputes the power of one value to another.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.PrefetchDataset", "path": "raw_ops/prefetchdataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that asynchronously prefetches elements from\n`input_dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Prelinearize", "path": "raw_ops/prelinearize", "type": "tf.raw_ops", "text": "\nAn op which linearizes one Tensor value to an opaque variant tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.PrelinearizeTuple", "path": "raw_ops/prelinearizetuple", "type": "tf.raw_ops", "text": "\nAn op which linearizes multiple Tensor values to an opaque variant tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.PreventGradient", "path": "raw_ops/preventgradient", "type": "tf.raw_ops", "text": "\nAn identity op that triggers an error if a gradient is requested.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Print", "path": "raw_ops/print", "type": "tf.raw_ops", "text": "\nPrints a list of tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.PrintV2", "path": "raw_ops/printv2", "type": "tf.raw_ops", "text": "\nPrints a string scalar.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.PriorityQueue", "path": "raw_ops/priorityqueue", "type": "tf.raw_ops", "text": "\nA queue that produces elements sorted by the first component value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.PriorityQueueV2", "path": "raw_ops/priorityqueuev2", "type": "tf.raw_ops", "text": "\nA queue that produces elements sorted by the first component value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.PrivateThreadPoolDataset", "path": "raw_ops/privatethreadpooldataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that uses a custom thread pool to compute `input_dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Prod", "path": "raw_ops/prod", "type": "tf.raw_ops", "text": "\nComputes the product of elements across dimensions of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.PyFunc", "path": "raw_ops/pyfunc", "type": "tf.raw_ops", "text": "\nInvokes a python function to compute func(input)->output.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.PyFuncStateless", "path": "raw_ops/pyfuncstateless", "type": "tf.raw_ops", "text": "\nA stateless version of PyFunc.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Qr", "path": "raw_ops/qr", "type": "tf.raw_ops", "text": "\nComputes the QR decompositions of one or more matrices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QuantizeAndDequantize", "path": "raw_ops/quantizeanddequantize", "type": "tf.raw_ops", "text": "\nUse QuantizeAndDequantizeV2 instead.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QuantizeAndDequantizeV2", "path": "raw_ops/quantizeanddequantizev2", "type": "tf.raw_ops", "text": "\nQuantizes then dequantizes a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QuantizeAndDequantizeV3", "path": "raw_ops/quantizeanddequantizev3", "type": "tf.raw_ops", "text": "\nQuantizes then dequantizes a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QuantizeAndDequantizeV4", "path": "raw_ops/quantizeanddequantizev4", "type": "tf.raw_ops", "text": "\nReturns the gradient of `QuantizeAndDequantizeV4`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QuantizeAndDequantizeV4Grad", "path": "raw_ops/quantizeanddequantizev4grad", "type": "tf.raw_ops", "text": "\nReturns the gradient of `QuantizeAndDequantizeV4`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QuantizedAdd", "path": "raw_ops/quantizedadd", "type": "tf.raw_ops", "text": "\nReturns x + y element-wise, working on quantized buffers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QuantizedAvgPool", "path": "raw_ops/quantizedavgpool", "type": "tf.raw_ops", "text": "\nProduces the average pool of the input tensor for quantized types.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QuantizedBatchNormWithGlobalNormalization", "path": "raw_ops/quantizedbatchnormwithglobalnormalization", "type": "tf.raw_ops", "text": "\nQuantized Batch normalization.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QuantizedBiasAdd", "path": "raw_ops/quantizedbiasadd", "type": "tf.raw_ops", "text": "\nAdds Tensor 'bias' to Tensor 'input' for Quantized types.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QuantizedConcat", "path": "raw_ops/quantizedconcat", "type": "tf.raw_ops", "text": "\nConcatenates quantized tensors along one dimension.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QuantizedConv2D", "path": "raw_ops/quantizedconv2d", "type": "tf.raw_ops", "text": "\nComputes a 2D convolution given quantized 4D input and filter tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QuantizedConv2DAndRelu", "path": "raw_ops/quantizedconv2dandrelu", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QuantizedConv2DAndReluAndRequantize", "path": "raw_ops/quantizedconv2dandreluandrequantize", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QuantizedConv2DAndRequantize", "path": "raw_ops/quantizedconv2dandrequantize", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QuantizedConv2DPerChannel", "path": "raw_ops/quantizedconv2dperchannel", "type": "tf.raw_ops", "text": "\nComputes QuantizedConv2D per channel.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QuantizedConv2DWithBias", "path": "raw_ops/quantizedconv2dwithbias", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QuantizedConv2DWithBiasAndRelu", "path": "raw_ops/quantizedconv2dwithbiasandrelu", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QuantizedConv2DWithBiasAndReluAndRequantize", "path": "raw_ops/quantizedconv2dwithbiasandreluandrequantize", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QuantizedConv2DWithBiasAndRequantize", "path": "raw_ops/quantizedconv2dwithbiasandrequantize", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QuantizedConv2DWithBiasSignedSumAndReluAndRequantize", "path": "raw_ops/quantizedconv2dwithbiassignedsumandreluandrequantize", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QuantizedConv2DWithBiasSumAndRelu", "path": "raw_ops/quantizedconv2dwithbiassumandrelu", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QuantizedConv2DWithBiasSumAndReluAndRequantize", "path": "raw_ops/quantizedconv2dwithbiassumandreluandrequantize", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QuantizedDepthwiseConv2D", "path": "raw_ops/quantizeddepthwiseconv2d", "type": "tf.raw_ops", "text": "\nComputes quantized depthwise Conv2D.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QuantizedDepthwiseConv2DWithBias", "path": "raw_ops/quantizeddepthwiseconv2dwithbias", "type": "tf.raw_ops", "text": "\nComputes quantized depthwise Conv2D with Bias.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QuantizedDepthwiseConv2DWithBiasAndRelu", "path": "raw_ops/quantizeddepthwiseconv2dwithbiasandrelu", "type": "tf.raw_ops", "text": "\nComputes quantized depthwise Conv2D with Bias and Relu.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QuantizedDepthwiseConv2DWithBiasAndReluAndRequantize", "path": "raw_ops/quantizeddepthwiseconv2dwithbiasandreluandrequantize", "type": "tf.raw_ops", "text": "\nComputes quantized depthwise Conv2D with Bias, Relu and Requantize.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QuantizedInstanceNorm", "path": "raw_ops/quantizedinstancenorm", "type": "tf.raw_ops", "text": "\nQuantized Instance normalization.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QuantizedMatMul", "path": "raw_ops/quantizedmatmul", "type": "tf.raw_ops", "text": "\nPerform a quantized matrix multiplication of `a` by the matrix `b`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QuantizedMatMulWithBias", "path": "raw_ops/quantizedmatmulwithbias", "type": "tf.raw_ops", "text": "\nPerforms a quantized matrix multiplication of `a` by the matrix `b` with bias\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QuantizedMatMulWithBiasAndDequantize", "path": "raw_ops/quantizedmatmulwithbiasanddequantize", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QuantizedMatMulWithBiasAndRelu", "path": "raw_ops/quantizedmatmulwithbiasandrelu", "type": "tf.raw_ops", "text": "\nPerform a quantized matrix multiplication of `a` by the matrix `b` with bias\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QuantizedMatMulWithBiasAndReluAndRequantize", "path": "raw_ops/quantizedmatmulwithbiasandreluandrequantize", "type": "tf.raw_ops", "text": "\nPerform a quantized matrix multiplication of `a` by the matrix `b` with bias\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QuantizedMatMulWithBiasAndRequantize", "path": "raw_ops/quantizedmatmulwithbiasandrequantize", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QuantizedMaxPool", "path": "raw_ops/quantizedmaxpool", "type": "tf.raw_ops", "text": "\nProduces the max pool of the input tensor for quantized types.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QuantizedMul", "path": "raw_ops/quantizedmul", "type": "tf.raw_ops", "text": "\nReturns x * y element-wise, working on quantized buffers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QuantizeDownAndShrinkRange", "path": "raw_ops/quantizedownandshrinkrange", "type": "tf.raw_ops", "text": "\nConvert the quantized 'input' tensor into a lower-precision 'output', using\nthe\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QuantizedRelu", "path": "raw_ops/quantizedrelu", "type": "tf.raw_ops", "text": "\nComputes Quantized Rectified Linear: `max(features, 0)`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QuantizedRelu6", "path": "raw_ops/quantizedrelu6", "type": "tf.raw_ops", "text": "\nComputes Quantized Rectified Linear 6: `min(max(features, 0), 6)`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QuantizedReluX", "path": "raw_ops/quantizedrelux", "type": "tf.raw_ops", "text": "\nComputes Quantized Rectified Linear X: `min(max(features, 0), max_value)`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QuantizedReshape", "path": "raw_ops/quantizedreshape", "type": "tf.raw_ops", "text": "\nReshapes a quantized tensor as per the Reshape op.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QuantizedResizeBilinear", "path": "raw_ops/quantizedresizebilinear", "type": "tf.raw_ops", "text": "\nResize quantized `images` to `size` using quantized bilinear interpolation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QuantizeV2", "path": "raw_ops/quantizev2", "type": "tf.raw_ops", "text": "\nQuantize the 'input' tensor of type float to 'output' tensor of type 'T'.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QueueClose", "path": "raw_ops/queueclose", "type": "tf.raw_ops", "text": "\nCloses the given queue.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QueueCloseV2", "path": "raw_ops/queueclosev2", "type": "tf.raw_ops", "text": "\nCloses the given queue.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QueueDequeue", "path": "raw_ops/queuedequeue", "type": "tf.raw_ops", "text": "\nDequeues a tuple of one or more tensors from the given queue.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QueueDequeueMany", "path": "raw_ops/queuedequeuemany", "type": "tf.raw_ops", "text": "\nDequeues `n` tuples of one or more tensors from the given queue.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QueueDequeueManyV2", "path": "raw_ops/queuedequeuemanyv2", "type": "tf.raw_ops", "text": "\nDequeues `n` tuples of one or more tensors from the given queue.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QueueDequeueUpTo", "path": "raw_ops/queuedequeueupto", "type": "tf.raw_ops", "text": "\nDequeues `n` tuples of one or more tensors from the given queue.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QueueDequeueUpToV2", "path": "raw_ops/queuedequeueuptov2", "type": "tf.raw_ops", "text": "\nDequeues `n` tuples of one or more tensors from the given queue.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QueueDequeueV2", "path": "raw_ops/queuedequeuev2", "type": "tf.raw_ops", "text": "\nDequeues a tuple of one or more tensors from the given queue.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QueueEnqueue", "path": "raw_ops/queueenqueue", "type": "tf.raw_ops", "text": "\nEnqueues a tuple of one or more tensors in the given queue.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QueueEnqueueMany", "path": "raw_ops/queueenqueuemany", "type": "tf.raw_ops", "text": "\nEnqueues zero or more tuples of one or more tensors in the given queue.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QueueEnqueueManyV2", "path": "raw_ops/queueenqueuemanyv2", "type": "tf.raw_ops", "text": "\nEnqueues zero or more tuples of one or more tensors in the given queue.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QueueEnqueueV2", "path": "raw_ops/queueenqueuev2", "type": "tf.raw_ops", "text": "\nEnqueues a tuple of one or more tensors in the given queue.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QueueIsClosed", "path": "raw_ops/queueisclosed", "type": "tf.raw_ops", "text": "\nReturns true if queue is closed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QueueIsClosedV2", "path": "raw_ops/queueisclosedv2", "type": "tf.raw_ops", "text": "\nReturns true if queue is closed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QueueSize", "path": "raw_ops/queuesize", "type": "tf.raw_ops", "text": "\nComputes the number of elements in the given queue.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.QueueSizeV2", "path": "raw_ops/queuesizev2", "type": "tf.raw_ops", "text": "\nComputes the number of elements in the given queue.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RaggedBincount", "path": "raw_ops/raggedbincount", "type": "tf.raw_ops", "text": "\nCounts the number of occurrences of each value in an integer array.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RaggedCountSparseOutput", "path": "raw_ops/raggedcountsparseoutput", "type": "tf.raw_ops", "text": "\nPerforms sparse-output bin counting for a ragged tensor input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RaggedCross", "path": "raw_ops/raggedcross", "type": "tf.raw_ops", "text": "\nGenerates a feature cross from a list of tensors, and returns it as a\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RaggedGather", "path": "raw_ops/raggedgather", "type": "tf.raw_ops", "text": "\nGather ragged slices from `params` axis `0` according to `indices`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RaggedRange", "path": "raw_ops/raggedrange", "type": "tf.raw_ops", "text": "\nReturns a `RaggedTensor` containing the specified sequences of numbers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RaggedTensorFromVariant", "path": "raw_ops/raggedtensorfromvariant", "type": "tf.raw_ops", "text": "\nDecodes a `variant` Tensor into a `RaggedTensor`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RaggedTensorToSparse", "path": "raw_ops/raggedtensortosparse", "type": "tf.raw_ops", "text": "\nConverts a `RaggedTensor` into a `SparseTensor` with the same values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RaggedTensorToTensor", "path": "raw_ops/raggedtensortotensor", "type": "tf.raw_ops", "text": "\nCreate a dense tensor from a ragged tensor, possibly altering its shape.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RaggedTensorToVariant", "path": "raw_ops/raggedtensortovariant", "type": "tf.raw_ops", "text": "\nEncodes a `RaggedTensor` into a `variant` Tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RaggedTensorToVariantGradient", "path": "raw_ops/raggedtensortovariantgradient", "type": "tf.raw_ops", "text": "\nHelper used to compute the gradient for `RaggedTensorToVariant`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RandomCrop", "path": "raw_ops/randomcrop", "type": "tf.raw_ops", "text": "\nRandomly crop `image`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RandomDataset", "path": "raw_ops/randomdataset", "type": "tf.raw_ops", "text": "\nCreates a Dataset that returns pseudorandom numbers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RandomGamma", "path": "raw_ops/randomgamma", "type": "tf.raw_ops", "text": "\nOutputs random values from the Gamma distribution(s) described by alpha.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RandomGammaGrad", "path": "raw_ops/randomgammagrad", "type": "tf.raw_ops", "text": "\nComputes the derivative of a Gamma random sample w.r.t. `alpha`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RandomPoisson", "path": "raw_ops/randompoisson", "type": "tf.raw_ops", "text": "\nUse RandomPoissonV2 instead.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RandomPoissonV2", "path": "raw_ops/randompoissonv2", "type": "tf.raw_ops", "text": "\nOutputs random values from the Poisson distribution(s) described by rate.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RandomShuffle", "path": "raw_ops/randomshuffle", "type": "tf.raw_ops", "text": "\nRandomly shuffles a tensor along its first dimension.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RandomShuffleQueue", "path": "raw_ops/randomshufflequeue", "type": "tf.raw_ops", "text": "\nA queue that randomizes the order of elements.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RandomShuffleQueueV2", "path": "raw_ops/randomshufflequeuev2", "type": "tf.raw_ops", "text": "\nA queue that randomizes the order of elements.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RandomStandardNormal", "path": "raw_ops/randomstandardnormal", "type": "tf.raw_ops", "text": "\nOutputs random values from a normal distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RandomUniform", "path": "raw_ops/randomuniform", "type": "tf.raw_ops", "text": "\nOutputs random values from a uniform distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RandomUniformInt", "path": "raw_ops/randomuniformint", "type": "tf.raw_ops", "text": "\nOutputs random integers from a uniform distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Range", "path": "raw_ops/range", "type": "tf.raw_ops", "text": "\nCreates a sequence of numbers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RangeDataset", "path": "raw_ops/rangedataset", "type": "tf.raw_ops", "text": "\nCreates a dataset with a range of values. Corresponds to python's xrange.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Rank", "path": "raw_ops/rank", "type": "tf.raw_ops", "text": "\nReturns the rank of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ReaderNumRecordsProduced", "path": "raw_ops/readernumrecordsproduced", "type": "tf.raw_ops", "text": "\nReturns the number of records this Reader has produced.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ReaderNumRecordsProducedV2", "path": "raw_ops/readernumrecordsproducedv2", "type": "tf.raw_ops", "text": "\nReturns the number of records this Reader has produced.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ReaderNumWorkUnitsCompleted", "path": "raw_ops/readernumworkunitscompleted", "type": "tf.raw_ops", "text": "\nReturns the number of work units this Reader has finished processing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ReaderNumWorkUnitsCompletedV2", "path": "raw_ops/readernumworkunitscompletedv2", "type": "tf.raw_ops", "text": "\nReturns the number of work units this Reader has finished processing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ReaderRead", "path": "raw_ops/readerread", "type": "tf.raw_ops", "text": "\nReturns the next record (key, value pair) produced by a Reader.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ReaderReadUpTo", "path": "raw_ops/readerreadupto", "type": "tf.raw_ops", "text": "\nReturns up to `num_records` (key, value) pairs produced by a Reader.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ReaderReadUpToV2", "path": "raw_ops/readerreaduptov2", "type": "tf.raw_ops", "text": "\nReturns up to `num_records` (key, value) pairs produced by a Reader.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ReaderReadV2", "path": "raw_ops/readerreadv2", "type": "tf.raw_ops", "text": "\nReturns the next record (key, value pair) produced by a Reader.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ReaderReset", "path": "raw_ops/readerreset", "type": "tf.raw_ops", "text": "\nRestore a Reader to its initial clean state.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ReaderResetV2", "path": "raw_ops/readerresetv2", "type": "tf.raw_ops", "text": "\nRestore a Reader to its initial clean state.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ReaderRestoreState", "path": "raw_ops/readerrestorestate", "type": "tf.raw_ops", "text": "\nRestore a reader to a previously saved state.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ReaderRestoreStateV2", "path": "raw_ops/readerrestorestatev2", "type": "tf.raw_ops", "text": "\nRestore a reader to a previously saved state.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ReaderSerializeState", "path": "raw_ops/readerserializestate", "type": "tf.raw_ops", "text": "\nProduce a string tensor that encodes the state of a Reader.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ReaderSerializeStateV2", "path": "raw_ops/readerserializestatev2", "type": "tf.raw_ops", "text": "\nProduce a string tensor that encodes the state of a Reader.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ReadFile", "path": "raw_ops/readfile", "type": "tf.raw_ops", "text": "\nReads and outputs the entire contents of the input filename.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ReadVariableOp", "path": "raw_ops/readvariableop", "type": "tf.raw_ops", "text": "\nReads the value of a variable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Real", "path": "raw_ops/real", "type": "tf.raw_ops", "text": "\nReturns the real part of a complex number.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RealDiv", "path": "raw_ops/realdiv", "type": "tf.raw_ops", "text": "\nReturns x / y element-wise for real types.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RebatchDataset", "path": "raw_ops/rebatchdataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that changes the batch size.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RebatchDatasetV2", "path": "raw_ops/rebatchdatasetv2", "type": "tf.raw_ops", "text": "\nCreates a dataset that changes the batch size.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Reciprocal", "path": "raw_ops/reciprocal", "type": "tf.raw_ops", "text": "\nComputes the reciprocal of x element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ReciprocalGrad", "path": "raw_ops/reciprocalgrad", "type": "tf.raw_ops", "text": "\nComputes the gradient for the inverse of `x` wrt its input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RecordInput", "path": "raw_ops/recordinput", "type": "tf.raw_ops", "text": "\nEmits randomized records.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Recv", "path": "raw_ops/recv", "type": "tf.raw_ops", "text": "\nReceives the named tensor from send_device on recv_device.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RecvTPUEmbeddingActivations", "path": "raw_ops/recvtpuembeddingactivations", "type": "tf.raw_ops", "text": "\nAn op that receives embedding activations on the TPU.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ReduceDataset", "path": "raw_ops/reducedataset", "type": "tf.raw_ops", "text": "\nReduces the input dataset to a singleton using a reduce function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ReduceJoin", "path": "raw_ops/reducejoin", "type": "tf.raw_ops", "text": "\nJoins a string Tensor across the given dimensions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RefEnter", "path": "raw_ops/refenter", "type": "tf.raw_ops", "text": "\nCreates or finds a child frame, and makes `data` available to the child frame.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RefExit", "path": "raw_ops/refexit", "type": "tf.raw_ops", "text": "\nExits the current frame to its parent frame.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RefIdentity", "path": "raw_ops/refidentity", "type": "tf.raw_ops", "text": "\nReturn the same ref tensor as the input ref tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RefMerge", "path": "raw_ops/refmerge", "type": "tf.raw_ops", "text": "\nForwards the value of an available tensor from `inputs` to `output`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RefNextIteration", "path": "raw_ops/refnextiteration", "type": "tf.raw_ops", "text": "\nMakes its input available to the next iteration.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RefSelect", "path": "raw_ops/refselect", "type": "tf.raw_ops", "text": "\nForwards the `index`th element of `inputs` to `output`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RefSwitch", "path": "raw_ops/refswitch", "type": "tf.raw_ops", "text": "\nForwards the ref tensor `data` to the output port determined by `pred`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RegexFullMatch", "path": "raw_ops/regexfullmatch", "type": "tf.raw_ops", "text": "\nCheck if the input matches the regex pattern.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RegexReplace", "path": "raw_ops/regexreplace", "type": "tf.raw_ops", "text": "\nReplaces matches of the `pattern` regular expression in `input` with the\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RegisterDataset", "path": "raw_ops/registerdataset", "type": "tf.raw_ops", "text": "\nRegisters a dataset with the tf.data service.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Relu", "path": "raw_ops/relu", "type": "tf.raw_ops", "text": "\nComputes rectified linear: `max(features, 0)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Relu6", "path": "raw_ops/relu6", "type": "tf.raw_ops", "text": "\nComputes rectified linear 6: `min(max(features, 0), 6)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Relu6Grad", "path": "raw_ops/relu6grad", "type": "tf.raw_ops", "text": "\nComputes rectified linear 6 gradients for a Relu6 operation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ReluGrad", "path": "raw_ops/relugrad", "type": "tf.raw_ops", "text": "\nComputes rectified linear gradients for a Relu operation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RemoteCall", "path": "raw_ops/remotecall", "type": "tf.raw_ops", "text": "\nRuns function `f` on a remote device indicated by `target`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RepeatDataset", "path": "raw_ops/repeatdataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that emits the outputs of `input_dataset` `count` times.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RequantizationRange", "path": "raw_ops/requantizationrange", "type": "tf.raw_ops", "text": "\nComputes a range that covers the actual values present in a quantized tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RequantizationRangePerChannel", "path": "raw_ops/requantizationrangeperchannel", "type": "tf.raw_ops", "text": "\nComputes requantization range per channel.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Requantize", "path": "raw_ops/requantize", "type": "tf.raw_ops", "text": "\nConverts the quantized `input` tensor into a lower-precision `output`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RequantizePerChannel", "path": "raw_ops/requantizeperchannel", "type": "tf.raw_ops", "text": "\nRequantizes input with min and max values known per channel.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Reshape", "path": "raw_ops/reshape", "type": "tf.raw_ops", "text": "\nReshapes a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResizeArea", "path": "raw_ops/resizearea", "type": "tf.raw_ops", "text": "\nResize `images` to `size` using area interpolation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResizeBicubic", "path": "raw_ops/resizebicubic", "type": "tf.raw_ops", "text": "\nResize `images` to `size` using bicubic interpolation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResizeBicubicGrad", "path": "raw_ops/resizebicubicgrad", "type": "tf.raw_ops", "text": "\nComputes the gradient of bicubic interpolation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResizeBilinear", "path": "raw_ops/resizebilinear", "type": "tf.raw_ops", "text": "\nResize `images` to `size` using bilinear interpolation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResizeBilinearGrad", "path": "raw_ops/resizebilineargrad", "type": "tf.raw_ops", "text": "\nComputes the gradient of bilinear interpolation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResizeNearestNeighbor", "path": "raw_ops/resizenearestneighbor", "type": "tf.raw_ops", "text": "\nResize `images` to `size` using nearest neighbor interpolation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResizeNearestNeighborGrad", "path": "raw_ops/resizenearestneighborgrad", "type": "tf.raw_ops", "text": "\nComputes the gradient of nearest neighbor interpolation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceAccumulatorApplyGradient", "path": "raw_ops/resourceaccumulatorapplygradient", "type": "tf.raw_ops", "text": "\nApplies a gradient to a given accumulator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceAccumulatorNumAccumulated", "path": "raw_ops/resourceaccumulatornumaccumulated", "type": "tf.raw_ops", "text": "\nReturns the number of gradients aggregated in the given accumulators.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceAccumulatorSetGlobalStep", "path": "raw_ops/resourceaccumulatorsetglobalstep", "type": "tf.raw_ops", "text": "\nUpdates the accumulator with a new value for global_step.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceAccumulatorTakeGradient", "path": "raw_ops/resourceaccumulatortakegradient", "type": "tf.raw_ops", "text": "\nExtracts the average gradient in the given ConditionalAccumulator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceApplyAdadelta", "path": "raw_ops/resourceapplyadadelta", "type": "tf.raw_ops", "text": "\nUpdate '*var' according to the adadelta scheme.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceApplyAdagrad", "path": "raw_ops/resourceapplyadagrad", "type": "tf.raw_ops", "text": "\nUpdate '*var' according to the adagrad scheme.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceApplyAdagradDA", "path": "raw_ops/resourceapplyadagradda", "type": "tf.raw_ops", "text": "\nUpdate '*var' according to the proximal adagrad scheme.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceApplyAdagradV2", "path": "raw_ops/resourceapplyadagradv2", "type": "tf.raw_ops", "text": "\nUpdate '*var' according to the adagrad scheme.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceApplyAdam", "path": "raw_ops/resourceapplyadam", "type": "tf.raw_ops", "text": "\nUpdate '*var' according to the Adam algorithm.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceApplyAdaMax", "path": "raw_ops/resourceapplyadamax", "type": "tf.raw_ops", "text": "\nUpdate '*var' according to the AdaMax algorithm.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceApplyAdamWithAmsgrad", "path": "raw_ops/resourceapplyadamwithamsgrad", "type": "tf.raw_ops", "text": "\nUpdate '*var' according to the Adam algorithm.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceApplyAddSign", "path": "raw_ops/resourceapplyaddsign", "type": "tf.raw_ops", "text": "\nUpdate '*var' according to the AddSign update.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceApplyCenteredRMSProp", "path": "raw_ops/resourceapplycenteredrmsprop", "type": "tf.raw_ops", "text": "\nUpdate '*var' according to the centered RMSProp algorithm.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceApplyFtrl", "path": "raw_ops/resourceapplyftrl", "type": "tf.raw_ops", "text": "\nUpdate '*var' according to the Ftrl-proximal scheme.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceApplyFtrlV2", "path": "raw_ops/resourceapplyftrlv2", "type": "tf.raw_ops", "text": "\nUpdate '*var' according to the Ftrl-proximal scheme.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceApplyGradientDescent", "path": "raw_ops/resourceapplygradientdescent", "type": "tf.raw_ops", "text": "\nUpdate '*var' by subtracting 'alpha' * 'delta' from it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceApplyKerasMomentum", "path": "raw_ops/resourceapplykerasmomentum", "type": "tf.raw_ops", "text": "\nUpdate '*var' according to the momentum scheme.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceApplyMomentum", "path": "raw_ops/resourceapplymomentum", "type": "tf.raw_ops", "text": "\nUpdate '*var' according to the momentum scheme.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceApplyPowerSign", "path": "raw_ops/resourceapplypowersign", "type": "tf.raw_ops", "text": "\nUpdate '*var' according to the AddSign update.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceApplyProximalAdagrad", "path": "raw_ops/resourceapplyproximaladagrad", "type": "tf.raw_ops", "text": "\nUpdate 'var' and 'accum' according to FOBOS with Adagrad learning rate.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceApplyProximalGradientDescent", "path": "raw_ops/resourceapplyproximalgradientdescent", "type": "tf.raw_ops", "text": "\nUpdate '*var' as FOBOS algorithm with fixed learning rate.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceApplyRMSProp", "path": "raw_ops/resourceapplyrmsprop", "type": "tf.raw_ops", "text": "\nUpdate '*var' according to the RMSProp algorithm.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceConditionalAccumulator", "path": "raw_ops/resourceconditionalaccumulator", "type": "tf.raw_ops", "text": "\nA conditional accumulator for aggregating gradients.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceCountUpTo", "path": "raw_ops/resourcecountupto", "type": "tf.raw_ops", "text": "\nIncrements variable pointed to by 'resource' until it reaches 'limit'.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceGather", "path": "raw_ops/resourcegather", "type": "tf.raw_ops", "text": "\nGather slices from the variable pointed to by `resource` according to\n`indices`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceGatherNd", "path": "raw_ops/resourcegathernd", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceScatterAdd", "path": "raw_ops/resourcescatteradd", "type": "tf.raw_ops", "text": "\nAdds sparse updates to the variable referenced by `resource`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceScatterDiv", "path": "raw_ops/resourcescatterdiv", "type": "tf.raw_ops", "text": "\nDivides sparse updates into the variable referenced by `resource`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceScatterMax", "path": "raw_ops/resourcescattermax", "type": "tf.raw_ops", "text": "\nReduces sparse updates into the variable referenced by `resource` using the\n`max` operation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceScatterMin", "path": "raw_ops/resourcescattermin", "type": "tf.raw_ops", "text": "\nReduces sparse updates into the variable referenced by `resource` using the\n`min` operation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceScatterMul", "path": "raw_ops/resourcescattermul", "type": "tf.raw_ops", "text": "\nMultiplies sparse updates into the variable referenced by `resource`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceScatterNdAdd", "path": "raw_ops/resourcescatterndadd", "type": "tf.raw_ops", "text": "\nApplies sparse addition to individual values or slices in a Variable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceScatterNdMax", "path": "raw_ops/resourcescatterndmax", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceScatterNdMin", "path": "raw_ops/resourcescatterndmin", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceScatterNdSub", "path": "raw_ops/resourcescatterndsub", "type": "tf.raw_ops", "text": "\nApplies sparse subtraction to individual values or slices in a Variable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceScatterNdUpdate", "path": "raw_ops/resourcescatterndupdate", "type": "tf.raw_ops", "text": "\nApplies sparse `updates` to individual values or slices within a given\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceScatterSub", "path": "raw_ops/resourcescattersub", "type": "tf.raw_ops", "text": "\nSubtracts sparse updates from the variable referenced by `resource`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceScatterUpdate", "path": "raw_ops/resourcescatterupdate", "type": "tf.raw_ops", "text": "\nAssigns sparse updates to the variable referenced by `resource`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceSparseApplyAdadelta", "path": "raw_ops/resourcesparseapplyadadelta", "type": "tf.raw_ops", "text": "\nvar: Should be from a Variable().\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceSparseApplyAdagrad", "path": "raw_ops/resourcesparseapplyadagrad", "type": "tf.raw_ops", "text": "\nUpdate relevant entries in 'var' and 'accum' according to the adagrad scheme.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceSparseApplyAdagradDA", "path": "raw_ops/resourcesparseapplyadagradda", "type": "tf.raw_ops", "text": "\nUpdate entries in 'var' and 'accum' according to the proximal adagrad scheme.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceSparseApplyAdagradV2", "path": "raw_ops/resourcesparseapplyadagradv2", "type": "tf.raw_ops", "text": "\nUpdate relevant entries in 'var' and 'accum' according to the adagrad scheme.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceSparseApplyCenteredRMSProp", "path": "raw_ops/resourcesparseapplycenteredrmsprop", "type": "tf.raw_ops", "text": "\nUpdate '*var' according to the centered RMSProp algorithm.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceSparseApplyFtrl", "path": "raw_ops/resourcesparseapplyftrl", "type": "tf.raw_ops", "text": "\nUpdate relevant entries in '*var' according to the Ftrl-proximal scheme.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceSparseApplyFtrlV2", "path": "raw_ops/resourcesparseapplyftrlv2", "type": "tf.raw_ops", "text": "\nUpdate relevant entries in '*var' according to the Ftrl-proximal scheme.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceSparseApplyKerasMomentum", "path": "raw_ops/resourcesparseapplykerasmomentum", "type": "tf.raw_ops", "text": "\nUpdate relevant entries in 'var' and 'accum' according to the momentum scheme.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceSparseApplyMomentum", "path": "raw_ops/resourcesparseapplymomentum", "type": "tf.raw_ops", "text": "\nUpdate relevant entries in 'var' and 'accum' according to the momentum scheme.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceSparseApplyProximalAdagrad", "path": "raw_ops/resourcesparseapplyproximaladagrad", "type": "tf.raw_ops", "text": "\nSparse update entries in 'var' and 'accum' according to FOBOS algorithm.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceSparseApplyProximalGradientDescent", "path": "raw_ops/resourcesparseapplyproximalgradientdescent", "type": "tf.raw_ops", "text": "\nSparse update '*var' as FOBOS algorithm with fixed learning rate.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceSparseApplyRMSProp", "path": "raw_ops/resourcesparseapplyrmsprop", "type": "tf.raw_ops", "text": "\nUpdate '*var' according to the RMSProp algorithm.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ResourceStridedSliceAssign", "path": "raw_ops/resourcestridedsliceassign", "type": "tf.raw_ops", "text": "\nAssign `value` to the sliced l-value reference of `ref`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Restore", "path": "raw_ops/restore", "type": "tf.raw_ops", "text": "\nRestores a tensor from checkpoint files.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RestoreSlice", "path": "raw_ops/restoreslice", "type": "tf.raw_ops", "text": "\nRestores a tensor from checkpoint files.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RestoreV2", "path": "raw_ops/restorev2", "type": "tf.raw_ops", "text": "\nRestores tensors from a V2 checkpoint.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RetrieveTPUEmbeddingAdadeltaParameters", "path": "raw_ops/retrievetpuembeddingadadeltaparameters", "type": "tf.raw_ops", "text": "\nRetrieve Adadelta embedding parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RetrieveTPUEmbeddingAdadeltaParametersGradAccumDebug", "path": "raw_ops/retrievetpuembeddingadadeltaparametersgradaccumdebug", "type": "tf.raw_ops", "text": "\nRetrieve Adadelta embedding parameters with debug support.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RetrieveTPUEmbeddingAdagradParameters", "path": "raw_ops/retrievetpuembeddingadagradparameters", "type": "tf.raw_ops", "text": "\nRetrieve Adagrad embedding parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RetrieveTPUEmbeddingAdagradParametersGradAccumDebug", "path": "raw_ops/retrievetpuembeddingadagradparametersgradaccumdebug", "type": "tf.raw_ops", "text": "\nRetrieve Adagrad embedding parameters with debug support.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RetrieveTPUEmbeddingADAMParameters", "path": "raw_ops/retrievetpuembeddingadamparameters", "type": "tf.raw_ops", "text": "\nRetrieve ADAM embedding parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RetrieveTPUEmbeddingADAMParametersGradAccumDebug", "path": "raw_ops/retrievetpuembeddingadamparametersgradaccumdebug", "type": "tf.raw_ops", "text": "\nRetrieve ADAM embedding parameters with debug support.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RetrieveTPUEmbeddingCenteredRMSPropParameters", "path": "raw_ops/retrievetpuembeddingcenteredrmspropparameters", "type": "tf.raw_ops", "text": "\nRetrieve centered RMSProp embedding parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RetrieveTPUEmbeddingFTRLParameters", "path": "raw_ops/retrievetpuembeddingftrlparameters", "type": "tf.raw_ops", "text": "\nRetrieve FTRL embedding parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RetrieveTPUEmbeddingFTRLParametersGradAccumDebug", "path": "raw_ops/retrievetpuembeddingftrlparametersgradaccumdebug", "type": "tf.raw_ops", "text": "\nRetrieve FTRL embedding parameters with debug support.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RetrieveTPUEmbeddingMDLAdagradLightParameters", "path": "raw_ops/retrievetpuembeddingmdladagradlightparameters", "type": "tf.raw_ops", "text": "\nRetrieve MDL Adagrad Light embedding parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RetrieveTPUEmbeddingMomentumParameters", "path": "raw_ops/retrievetpuembeddingmomentumparameters", "type": "tf.raw_ops", "text": "\nRetrieve Momentum embedding parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RetrieveTPUEmbeddingMomentumParametersGradAccumDebug", "path": "raw_ops/retrievetpuembeddingmomentumparametersgradaccumdebug", "type": "tf.raw_ops", "text": "\nRetrieve Momentum embedding parameters with debug support.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RetrieveTPUEmbeddingProximalAdagradParameters", "path": "raw_ops/retrievetpuembeddingproximaladagradparameters", "type": "tf.raw_ops", "text": "\nRetrieve proximal Adagrad embedding parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RetrieveTPUEmbeddingProximalAdagradParametersGradAccumDebug", "path": "raw_ops/retrievetpuembeddingproximaladagradparametersgradaccumdebug", "type": "tf.raw_ops", "text": "\nRetrieve proximal Adagrad embedding parameters with debug support.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RetrieveTPUEmbeddingProximalYogiParameters", "path": "raw_ops/retrievetpuembeddingproximalyogiparameters", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RetrieveTPUEmbeddingProximalYogiParametersGradAccumDebug", "path": "raw_ops/retrievetpuembeddingproximalyogiparametersgradaccumdebug", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RetrieveTPUEmbeddingRMSPropParameters", "path": "raw_ops/retrievetpuembeddingrmspropparameters", "type": "tf.raw_ops", "text": "\nRetrieve RMSProp embedding parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RetrieveTPUEmbeddingRMSPropParametersGradAccumDebug", "path": "raw_ops/retrievetpuembeddingrmspropparametersgradaccumdebug", "type": "tf.raw_ops", "text": "\nRetrieve RMSProp embedding parameters with debug support.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RetrieveTPUEmbeddingStochasticGradientDescentParameters", "path": "raw_ops/retrievetpuembeddingstochasticgradientdescentparameters", "type": "tf.raw_ops", "text": "\nRetrieve SGD embedding parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RetrieveTPUEmbeddingStochasticGradientDescentParametersGradAccumDebug", "path": "raw_ops/retrievetpuembeddingstochasticgradientdescentparametersgradaccumdebug", "type": "tf.raw_ops", "text": "\nRetrieve SGD embedding parameters with debug support.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Reverse", "path": "raw_ops/reverse", "type": "tf.raw_ops", "text": "\nReverses specific dimensions of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ReverseSequence", "path": "raw_ops/reversesequence", "type": "tf.raw_ops", "text": "\nReverses variable length slices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ReverseV2", "path": "raw_ops/reversev2", "type": "tf.raw_ops", "text": "\nReverses specific dimensions of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RFFT", "path": "raw_ops/rfft", "type": "tf.raw_ops", "text": "\nReal-valued fast Fourier transform.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RFFT2D", "path": "raw_ops/rfft2d", "type": "tf.raw_ops", "text": "\n2D real-valued fast Fourier transform.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RFFT3D", "path": "raw_ops/rfft3d", "type": "tf.raw_ops", "text": "\n3D real-valued fast Fourier transform.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RGBToHSV", "path": "raw_ops/rgbtohsv", "type": "tf.raw_ops", "text": "\nConverts one or more images from RGB to HSV.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RightShift", "path": "raw_ops/rightshift", "type": "tf.raw_ops", "text": "\nElementwise computes the bitwise right-shift of `x` and `y`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Rint", "path": "raw_ops/rint", "type": "tf.raw_ops", "text": "\nReturns element-wise integer closest to x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RngReadAndSkip", "path": "raw_ops/rngreadandskip", "type": "tf.raw_ops", "text": "\nAdvance the counter of a counter-based RNG.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RngSkip", "path": "raw_ops/rngskip", "type": "tf.raw_ops", "text": "\nAdvance the counter of a counter-based RNG.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Roll", "path": "raw_ops/roll", "type": "tf.raw_ops", "text": "\nRolls the elements of a tensor along an axis.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Round", "path": "raw_ops/round", "type": "tf.raw_ops", "text": "\nRounds the values of a tensor to the nearest integer, element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Rsqrt", "path": "raw_ops/rsqrt", "type": "tf.raw_ops", "text": "\nComputes reciprocal of square root of x element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.RsqrtGrad", "path": "raw_ops/rsqrtgrad", "type": "tf.raw_ops", "text": "\nComputes the gradient for the rsqrt of `x` wrt its input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SampleDistortedBoundingBox", "path": "raw_ops/sampledistortedboundingbox", "type": "tf.raw_ops", "text": "\nGenerate a single randomly distorted bounding box for an image.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SampleDistortedBoundingBoxV2", "path": "raw_ops/sampledistortedboundingboxv2", "type": "tf.raw_ops", "text": "\nGenerate a single randomly distorted bounding box for an image.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SamplingDataset", "path": "raw_ops/samplingdataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that takes a Bernoulli sample of the contents of another\ndataset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Save", "path": "raw_ops/save", "type": "tf.raw_ops", "text": "\nSaves the input tensors to disk.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SaveDataset", "path": "raw_ops/savedataset", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SaveSlices", "path": "raw_ops/saveslices", "type": "tf.raw_ops", "text": "\nSaves input tensors slices to disk.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SaveV2", "path": "raw_ops/savev2", "type": "tf.raw_ops", "text": "\nSaves tensors in V2 checkpoint format.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ScalarSummary", "path": "raw_ops/scalarsummary", "type": "tf.raw_ops", "text": "\nOutputs a `Summary` protocol buffer with scalar values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ScaleAndTranslate", "path": "raw_ops/scaleandtranslate", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ScaleAndTranslateGrad", "path": "raw_ops/scaleandtranslategrad", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ScanDataset", "path": "raw_ops/scandataset", "type": "tf.raw_ops", "text": "\nCreates a dataset successively reduces `f` over the elements of\n`input_dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ScatterAdd", "path": "raw_ops/scatteradd", "type": "tf.raw_ops", "text": "\nAdds sparse updates to a variable reference.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ScatterDiv", "path": "raw_ops/scatterdiv", "type": "tf.raw_ops", "text": "\nDivides a variable reference by sparse updates.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ScatterMax", "path": "raw_ops/scattermax", "type": "tf.raw_ops", "text": "\nReduces sparse updates into a variable reference using the `max` operation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ScatterMin", "path": "raw_ops/scattermin", "type": "tf.raw_ops", "text": "\nReduces sparse updates into a variable reference using the `min` operation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ScatterMul", "path": "raw_ops/scattermul", "type": "tf.raw_ops", "text": "\nMultiplies sparse updates into a variable reference.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ScatterNd", "path": "raw_ops/scatternd", "type": "tf.raw_ops", "text": "\nScatter `updates` into a new tensor according to `indices`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ScatterNdAdd", "path": "raw_ops/scatterndadd", "type": "tf.raw_ops", "text": "\nApplies sparse addition to individual values or slices in a Variable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ScatterNdMax", "path": "raw_ops/scatterndmax", "type": "tf.raw_ops", "text": "\nComputes element-wise maximum.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ScatterNdMin", "path": "raw_ops/scatterndmin", "type": "tf.raw_ops", "text": "\nComputes element-wise minimum.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ScatterNdNonAliasingAdd", "path": "raw_ops/scatterndnonaliasingadd", "type": "tf.raw_ops", "text": "\nApplies sparse addition to `input` using individual values or slices\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ScatterNdSub", "path": "raw_ops/scatterndsub", "type": "tf.raw_ops", "text": "\nApplies sparse subtraction to individual values or slices in a Variable.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ScatterNdUpdate", "path": "raw_ops/scatterndupdate", "type": "tf.raw_ops", "text": "\nApplies sparse `updates` to individual values or slices within a given\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ScatterSub", "path": "raw_ops/scattersub", "type": "tf.raw_ops", "text": "\nSubtracts sparse updates to a variable reference.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ScatterUpdate", "path": "raw_ops/scatterupdate", "type": "tf.raw_ops", "text": "\nApplies sparse updates to a variable reference.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SdcaFprint", "path": "raw_ops/sdcafprint", "type": "tf.raw_ops", "text": "\nComputes fingerprints of the input strings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SdcaOptimizer", "path": "raw_ops/sdcaoptimizer", "type": "tf.raw_ops", "text": "\nDistributed version of Stochastic Dual Coordinate Ascent (SDCA) optimizer for\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SdcaOptimizerV2", "path": "raw_ops/sdcaoptimizerv2", "type": "tf.raw_ops", "text": "\nDistributed version of Stochastic Dual Coordinate Ascent (SDCA) optimizer for\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SdcaShrinkL1", "path": "raw_ops/sdcashrinkl1", "type": "tf.raw_ops", "text": "\nApplies L1 regularization shrink step on the parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SegmentMax", "path": "raw_ops/segmentmax", "type": "tf.raw_ops", "text": "\nComputes the maximum along segments of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SegmentMean", "path": "raw_ops/segmentmean", "type": "tf.raw_ops", "text": "\nComputes the mean along segments of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SegmentMin", "path": "raw_ops/segmentmin", "type": "tf.raw_ops", "text": "\nComputes the minimum along segments of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SegmentProd", "path": "raw_ops/segmentprod", "type": "tf.raw_ops", "text": "\nComputes the product along segments of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SegmentSum", "path": "raw_ops/segmentsum", "type": "tf.raw_ops", "text": "\nComputes the sum along segments of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Select", "path": "raw_ops/select", "type": "tf.raw_ops", "text": "\nSelects elements from `x` or `y`, depending on `condition`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SelectV2", "path": "raw_ops/selectv2", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SelfAdjointEig", "path": "raw_ops/selfadjointeig", "type": "tf.raw_ops", "text": "\nComputes the Eigen Decomposition of a batch of square self-adjoint matrices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SelfAdjointEigV2", "path": "raw_ops/selfadjointeigv2", "type": "tf.raw_ops", "text": "\nComputes the eigen decomposition of one or more square self-adjoint matrices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Selu", "path": "raw_ops/selu", "type": "tf.raw_ops", "text": "\nComputes scaled exponential linear: `scale * alpha * (exp(features) - 1)`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SeluGrad", "path": "raw_ops/selugrad", "type": "tf.raw_ops", "text": "\nComputes gradients for the scaled exponential linear (Selu) operation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Send", "path": "raw_ops/send", "type": "tf.raw_ops", "text": "\nSends the named tensor from send_device to recv_device.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SendTPUEmbeddingGradients", "path": "raw_ops/sendtpuembeddinggradients", "type": "tf.raw_ops", "text": "\nPerforms gradient updates of embedding tables.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SerializeIterator", "path": "raw_ops/serializeiterator", "type": "tf.raw_ops", "text": "\nConverts the given `resource_handle` representing an iterator to a variant\ntensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SerializeManySparse", "path": "raw_ops/serializemanysparse", "type": "tf.raw_ops", "text": "\nSerialize an `N`-minibatch `SparseTensor` into an `[N, 3]` `Tensor` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SerializeSparse", "path": "raw_ops/serializesparse", "type": "tf.raw_ops", "text": "\nSerialize a `SparseTensor` into a `[3]` `Tensor` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SerializeTensor", "path": "raw_ops/serializetensor", "type": "tf.raw_ops", "text": "\nTransforms a Tensor into a serialized TensorProto proto.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SetSize", "path": "raw_ops/setsize", "type": "tf.raw_ops", "text": "\nNumber of unique elements along last dimension of input `set`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SetStatsAggregatorDataset", "path": "raw_ops/setstatsaggregatordataset", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Shape", "path": "raw_ops/shape", "type": "tf.raw_ops", "text": "\nReturns the shape of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ShapeN", "path": "raw_ops/shapen", "type": "tf.raw_ops", "text": "\nReturns shape of tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ShardDataset", "path": "raw_ops/sharddataset", "type": "tf.raw_ops", "text": "\nCreates a `Dataset` that includes only 1/`num_shards` of this dataset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ShardedFilename", "path": "raw_ops/shardedfilename", "type": "tf.raw_ops", "text": "\nGenerate a sharded filename. The filename is printf formatted as\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ShardedFilespec", "path": "raw_ops/shardedfilespec", "type": "tf.raw_ops", "text": "\nGenerate a glob pattern matching all sharded file names.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ShuffleAndRepeatDataset", "path": "raw_ops/shuffleandrepeatdataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that shuffles and repeats elements from `input_dataset`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ShuffleAndRepeatDatasetV2", "path": "raw_ops/shuffleandrepeatdatasetv2", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ShuffleDataset", "path": "raw_ops/shuffledataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that shuffles elements from `input_dataset` pseudorandomly.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ShuffleDatasetV2", "path": "raw_ops/shuffledatasetv2", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ShuffleDatasetV3", "path": "raw_ops/shuffledatasetv3", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ShutdownDistributedTPU", "path": "raw_ops/shutdowndistributedtpu", "type": "tf.raw_ops", "text": "\nShuts down a running distributed TPU system.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Sigmoid", "path": "raw_ops/sigmoid", "type": "tf.raw_ops", "text": "\nComputes sigmoid of `x` element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SigmoidGrad", "path": "raw_ops/sigmoidgrad", "type": "tf.raw_ops", "text": "\nComputes the gradient of the sigmoid of `x` wrt its input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Sign", "path": "raw_ops/sign", "type": "tf.raw_ops", "text": "\nReturns an element-wise indication of the sign of a number.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Sin", "path": "raw_ops/sin", "type": "tf.raw_ops", "text": "\nComputes sine of x element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Sinh", "path": "raw_ops/sinh", "type": "tf.raw_ops", "text": "\nComputes hyperbolic sine of x element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Size", "path": "raw_ops/size", "type": "tf.raw_ops", "text": "\nReturns the size of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SkipDataset", "path": "raw_ops/skipdataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that skips `count` elements from the `input_dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SleepDataset", "path": "raw_ops/sleepdataset", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Slice", "path": "raw_ops/slice", "type": "tf.raw_ops", "text": "\nReturn a slice from 'input'.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SlidingWindowDataset", "path": "raw_ops/slidingwindowdataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that passes a sliding window over `input_dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Snapshot", "path": "raw_ops/snapshot", "type": "tf.raw_ops", "text": "\nReturns a copy of the input tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SnapshotDataset", "path": "raw_ops/snapshotdataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that will write to / read from a snapshot.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SnapshotDatasetV2", "path": "raw_ops/snapshotdatasetv2", "type": "tf.raw_ops", "text": "\nCreates a dataset that will write to / read from a snapshot.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SobolSample", "path": "raw_ops/sobolsample", "type": "tf.raw_ops", "text": "\nGenerates points from the Sobol sequence.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Softmax", "path": "raw_ops/softmax", "type": "tf.raw_ops", "text": "\nComputes softmax activations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SoftmaxCrossEntropyWithLogits", "path": "raw_ops/softmaxcrossentropywithlogits", "type": "tf.raw_ops", "text": "\nComputes softmax cross entropy cost and gradients to backpropagate.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Softplus", "path": "raw_ops/softplus", "type": "tf.raw_ops", "text": "\nComputes softplus: `log(exp(features) + 1)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SoftplusGrad", "path": "raw_ops/softplusgrad", "type": "tf.raw_ops", "text": "\nComputes softplus gradients for a softplus operation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Softsign", "path": "raw_ops/softsign", "type": "tf.raw_ops", "text": "\nComputes softsign: `features / (abs(features) + 1)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SoftsignGrad", "path": "raw_ops/softsigngrad", "type": "tf.raw_ops", "text": "\nComputes softsign gradients for a softsign operation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SpaceToBatch", "path": "raw_ops/spacetobatch", "type": "tf.raw_ops", "text": "\nSpaceToBatch for 4-D tensors of type T.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SpaceToBatchND", "path": "raw_ops/spacetobatchnd", "type": "tf.raw_ops", "text": "\nSpaceToBatch for N-D tensors of type T.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SpaceToDepth", "path": "raw_ops/spacetodepth", "type": "tf.raw_ops", "text": "\nSpaceToDepth for tensors of type T.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseAccumulatorApplyGradient", "path": "raw_ops/sparseaccumulatorapplygradient", "type": "tf.raw_ops", "text": "\nApplies a sparse gradient to a given accumulator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseAccumulatorTakeGradient", "path": "raw_ops/sparseaccumulatortakegradient", "type": "tf.raw_ops", "text": "\nExtracts the average sparse gradient in a SparseConditionalAccumulator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseAdd", "path": "raw_ops/sparseadd", "type": "tf.raw_ops", "text": "\nAdds two `SparseTensor` objects to produce another `SparseTensor`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseAddGrad", "path": "raw_ops/sparseaddgrad", "type": "tf.raw_ops", "text": "\nThe gradient operator for the SparseAdd op.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseApplyAdadelta", "path": "raw_ops/sparseapplyadadelta", "type": "tf.raw_ops", "text": "\nvar: Should be from a Variable().\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseApplyAdagrad", "path": "raw_ops/sparseapplyadagrad", "type": "tf.raw_ops", "text": "\nUpdate relevant entries in 'var' and 'accum' according to the adagrad scheme.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseApplyAdagradDA", "path": "raw_ops/sparseapplyadagradda", "type": "tf.raw_ops", "text": "\nUpdate entries in 'var' and 'accum' according to the proximal adagrad scheme.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseApplyAdagradV2", "path": "raw_ops/sparseapplyadagradv2", "type": "tf.raw_ops", "text": "\nUpdate relevant entries in 'var' and 'accum' according to the adagrad scheme.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseApplyCenteredRMSProp", "path": "raw_ops/sparseapplycenteredrmsprop", "type": "tf.raw_ops", "text": "\nUpdate '*var' according to the centered RMSProp algorithm.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseApplyFtrl", "path": "raw_ops/sparseapplyftrl", "type": "tf.raw_ops", "text": "\nUpdate relevant entries in '*var' according to the Ftrl-proximal scheme.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseApplyFtrlV2", "path": "raw_ops/sparseapplyftrlv2", "type": "tf.raw_ops", "text": "\nUpdate relevant entries in '*var' according to the Ftrl-proximal scheme.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseApplyMomentum", "path": "raw_ops/sparseapplymomentum", "type": "tf.raw_ops", "text": "\nUpdate relevant entries in 'var' and 'accum' according to the momentum scheme.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseApplyProximalAdagrad", "path": "raw_ops/sparseapplyproximaladagrad", "type": "tf.raw_ops", "text": "\nSparse update entries in 'var' and 'accum' according to FOBOS algorithm.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseApplyProximalGradientDescent", "path": "raw_ops/sparseapplyproximalgradientdescent", "type": "tf.raw_ops", "text": "\nSparse update '*var' as FOBOS algorithm with fixed learning rate.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseApplyRMSProp", "path": "raw_ops/sparseapplyrmsprop", "type": "tf.raw_ops", "text": "\nUpdate '*var' according to the RMSProp algorithm.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseBincount", "path": "raw_ops/sparsebincount", "type": "tf.raw_ops", "text": "\nCounts the number of occurrences of each value in an integer array.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseConcat", "path": "raw_ops/sparseconcat", "type": "tf.raw_ops", "text": "\nConcatenates a list of `SparseTensor` along the specified dimension.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseConditionalAccumulator", "path": "raw_ops/sparseconditionalaccumulator", "type": "tf.raw_ops", "text": "\nA conditional accumulator for aggregating sparse gradients.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseCountSparseOutput", "path": "raw_ops/sparsecountsparseoutput", "type": "tf.raw_ops", "text": "\nPerforms sparse-output bin counting for a sparse tensor input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseCross", "path": "raw_ops/sparsecross", "type": "tf.raw_ops", "text": "\nGenerates sparse cross from a list of sparse and dense tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseCrossHashed", "path": "raw_ops/sparsecrosshashed", "type": "tf.raw_ops", "text": "\nGenerates sparse cross from a list of sparse and dense tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseCrossV2", "path": "raw_ops/sparsecrossv2", "type": "tf.raw_ops", "text": "\nGenerates sparse cross from a list of sparse and dense tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseDenseCwiseAdd", "path": "raw_ops/sparsedensecwiseadd", "type": "tf.raw_ops", "text": "\nAdds up a SparseTensor and a dense Tensor, using these special rules:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseDenseCwiseDiv", "path": "raw_ops/sparsedensecwisediv", "type": "tf.raw_ops", "text": "\nComponent-wise divides a SparseTensor by a dense Tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseDenseCwiseMul", "path": "raw_ops/sparsedensecwisemul", "type": "tf.raw_ops", "text": "\nComponent-wise multiplies a SparseTensor by a dense Tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseFillEmptyRows", "path": "raw_ops/sparsefillemptyrows", "type": "tf.raw_ops", "text": "\nFills empty rows in the input 2-D `SparseTensor` with a default value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseFillEmptyRowsGrad", "path": "raw_ops/sparsefillemptyrowsgrad", "type": "tf.raw_ops", "text": "\nThe gradient of SparseFillEmptyRows.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseMatMul", "path": "raw_ops/sparsematmul", "type": "tf.raw_ops", "text": "\nMultiply matrix \"a\" by matrix \"b\".\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseMatrixAdd", "path": "raw_ops/sparsematrixadd", "type": "tf.raw_ops", "text": "\nSparse addition of two CSR matrices, C = alpha * A + beta * B.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseMatrixMatMul", "path": "raw_ops/sparsematrixmatmul", "type": "tf.raw_ops", "text": "\nMatrix-multiplies a sparse matrix with a dense matrix.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseMatrixMul", "path": "raw_ops/sparsematrixmul", "type": "tf.raw_ops", "text": "\nElement-wise multiplication of a sparse matrix with a dense tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseMatrixNNZ", "path": "raw_ops/sparsematrixnnz", "type": "tf.raw_ops", "text": "\nReturns the number of nonzeroes of `sparse_matrix`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseMatrixOrderingAMD", "path": "raw_ops/sparsematrixorderingamd", "type": "tf.raw_ops", "text": "\nComputes the Approximate Minimum Degree (AMD) ordering of `input`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseMatrixSoftmax", "path": "raw_ops/sparsematrixsoftmax", "type": "tf.raw_ops", "text": "\nCalculates the softmax of a CSRSparseMatrix.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseMatrixSoftmaxGrad", "path": "raw_ops/sparsematrixsoftmaxgrad", "type": "tf.raw_ops", "text": "\nCalculates the gradient of the SparseMatrixSoftmax op.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseMatrixSparseCholesky", "path": "raw_ops/sparsematrixsparsecholesky", "type": "tf.raw_ops", "text": "\nComputes the sparse Cholesky decomposition of `input`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseMatrixSparseMatMul", "path": "raw_ops/sparsematrixsparsematmul", "type": "tf.raw_ops", "text": "\nSparse-matrix-multiplies two CSR matrices `a` and `b`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseMatrixTranspose", "path": "raw_ops/sparsematrixtranspose", "type": "tf.raw_ops", "text": "\nTransposes the inner (matrix) dimensions of a CSRSparseMatrix.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseMatrixZeros", "path": "raw_ops/sparsematrixzeros", "type": "tf.raw_ops", "text": "\nCreates an all-zeros CSRSparseMatrix with shape `dense_shape`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseReduceMax", "path": "raw_ops/sparsereducemax", "type": "tf.raw_ops", "text": "\nComputes the max of elements across dimensions of a SparseTensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseReduceMaxSparse", "path": "raw_ops/sparsereducemaxsparse", "type": "tf.raw_ops", "text": "\nComputes the max of elements across dimensions of a SparseTensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseReduceSum", "path": "raw_ops/sparsereducesum", "type": "tf.raw_ops", "text": "\nComputes the sum of elements across dimensions of a SparseTensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseReduceSumSparse", "path": "raw_ops/sparsereducesumsparse", "type": "tf.raw_ops", "text": "\nComputes the sum of elements across dimensions of a SparseTensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseReorder", "path": "raw_ops/sparsereorder", "type": "tf.raw_ops", "text": "\nReorders a SparseTensor into the canonical, row-major ordering.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseReshape", "path": "raw_ops/sparsereshape", "type": "tf.raw_ops", "text": "\nReshapes a SparseTensor to represent values in a new dense shape.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseSegmentMean", "path": "raw_ops/sparsesegmentmean", "type": "tf.raw_ops", "text": "\nComputes the mean along sparse segments of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseSegmentMeanGrad", "path": "raw_ops/sparsesegmentmeangrad", "type": "tf.raw_ops", "text": "\nComputes gradients for SparseSegmentMean.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseSegmentMeanWithNumSegments", "path": "raw_ops/sparsesegmentmeanwithnumsegments", "type": "tf.raw_ops", "text": "\nComputes the mean along sparse segments of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseSegmentSqrtN", "path": "raw_ops/sparsesegmentsqrtn", "type": "tf.raw_ops", "text": "\nComputes the sum along sparse segments of a tensor divided by the sqrt of N.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseSegmentSqrtNGrad", "path": "raw_ops/sparsesegmentsqrtngrad", "type": "tf.raw_ops", "text": "\nComputes gradients for SparseSegmentSqrtN.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseSegmentSqrtNWithNumSegments", "path": "raw_ops/sparsesegmentsqrtnwithnumsegments", "type": "tf.raw_ops", "text": "\nComputes the sum along sparse segments of a tensor divided by the sqrt of N.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseSegmentSum", "path": "raw_ops/sparsesegmentsum", "type": "tf.raw_ops", "text": "\nComputes the sum along sparse segments of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseSegmentSumWithNumSegments", "path": "raw_ops/sparsesegmentsumwithnumsegments", "type": "tf.raw_ops", "text": "\nComputes the sum along sparse segments of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseSlice", "path": "raw_ops/sparseslice", "type": "tf.raw_ops", "text": "\nSlice a `SparseTensor` based on the `start` and `size`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseSliceGrad", "path": "raw_ops/sparseslicegrad", "type": "tf.raw_ops", "text": "\nThe gradient operator for the SparseSlice op.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseSoftmax", "path": "raw_ops/sparsesoftmax", "type": "tf.raw_ops", "text": "\nApplies softmax to a batched N-D `SparseTensor`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseSoftmaxCrossEntropyWithLogits", "path": "raw_ops/sparsesoftmaxcrossentropywithlogits", "type": "tf.raw_ops", "text": "\nComputes softmax cross entropy cost and gradients to backpropagate.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseSparseMaximum", "path": "raw_ops/sparsesparsemaximum", "type": "tf.raw_ops", "text": "\nReturns the element-wise max of two SparseTensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseSparseMinimum", "path": "raw_ops/sparsesparseminimum", "type": "tf.raw_ops", "text": "\nReturns the element-wise min of two SparseTensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseSplit", "path": "raw_ops/sparsesplit", "type": "tf.raw_ops", "text": "\nSplit a `SparseTensor` into `num_split` tensors along one dimension.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseTensorDenseAdd", "path": "raw_ops/sparsetensordenseadd", "type": "tf.raw_ops", "text": "\nAdds up a `SparseTensor` and a dense `Tensor`, producing a dense `Tensor`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseTensorDenseMatMul", "path": "raw_ops/sparsetensordensematmul", "type": "tf.raw_ops", "text": "\nMultiply SparseTensor (of rank 2) \"A\" by dense matrix \"B\".\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseTensorSliceDataset", "path": "raw_ops/sparsetensorslicedataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that splits a SparseTensor into elements row-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseTensorToCSRSparseMatrix", "path": "raw_ops/sparsetensortocsrsparsematrix", "type": "tf.raw_ops", "text": "\nConverts a SparseTensor to a (possibly batched) CSRSparseMatrix.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseToDense", "path": "raw_ops/sparsetodense", "type": "tf.raw_ops", "text": "\nConverts a sparse representation into a dense tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SparseToSparseSetOperation", "path": "raw_ops/sparsetosparsesetoperation", "type": "tf.raw_ops", "text": "\nApplies set operation along last dimension of 2 `SparseTensor` inputs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Spence", "path": "raw_ops/spence", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Split", "path": "raw_ops/split", "type": "tf.raw_ops", "text": "\nSplits a tensor into `num_split` tensors along one dimension.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SplitV", "path": "raw_ops/splitv", "type": "tf.raw_ops", "text": "\nSplits a tensor into `num_split` tensors along one dimension.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SqlDataset", "path": "raw_ops/sqldataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that executes a SQL query and emits rows of the result set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Sqrt", "path": "raw_ops/sqrt", "type": "tf.raw_ops", "text": "\nComputes square root of x element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SqrtGrad", "path": "raw_ops/sqrtgrad", "type": "tf.raw_ops", "text": "\nComputes the gradient for the sqrt of `x` wrt its input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Square", "path": "raw_ops/square", "type": "tf.raw_ops", "text": "\nComputes square of x element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SquaredDifference", "path": "raw_ops/squareddifference", "type": "tf.raw_ops", "text": "\nReturns conj(x - y)(x - y) element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Squeeze", "path": "raw_ops/squeeze", "type": "tf.raw_ops", "text": "\nRemoves dimensions of size 1 from the shape of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Stack", "path": "raw_ops/stack", "type": "tf.raw_ops", "text": "\nDeprecated, use StackV2.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StackClose", "path": "raw_ops/stackclose", "type": "tf.raw_ops", "text": "\nDeprecated, use StackCloseV2.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StackCloseV2", "path": "raw_ops/stackclosev2", "type": "tf.raw_ops", "text": "\nDelete the stack from its resource container.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StackPop", "path": "raw_ops/stackpop", "type": "tf.raw_ops", "text": "\nDeprecated, use StackPopV2.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StackPopV2", "path": "raw_ops/stackpopv2", "type": "tf.raw_ops", "text": "\nPop the element at the top of the stack.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StackPush", "path": "raw_ops/stackpush", "type": "tf.raw_ops", "text": "\nDeprecated, use StackPushV2.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StackPushV2", "path": "raw_ops/stackpushv2", "type": "tf.raw_ops", "text": "\nPush an element onto the stack.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StackV2", "path": "raw_ops/stackv2", "type": "tf.raw_ops", "text": "\nA stack that produces elements in first-in last-out order.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Stage", "path": "raw_ops/stage", "type": "tf.raw_ops", "text": "\nStage values similar to a lightweight Enqueue.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StageClear", "path": "raw_ops/stageclear", "type": "tf.raw_ops", "text": "\nOp removes all elements in the underlying container.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StagePeek", "path": "raw_ops/stagepeek", "type": "tf.raw_ops", "text": "\nOp peeks at the values at the specified index. If the\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StageSize", "path": "raw_ops/stagesize", "type": "tf.raw_ops", "text": "\nOp returns the number of elements in the underlying container.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StatefulPartitionedCall", "path": "raw_ops/statefulpartitionedcall", "type": "tf.raw_ops", "text": "\nreturns `f(inputs)`, where `f`'s body is placed and partitioned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StatefulRandomBinomial", "path": "raw_ops/statefulrandombinomial", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StatefulStandardNormal", "path": "raw_ops/statefulstandardnormal", "type": "tf.raw_ops", "text": "\nOutputs random values from a normal distribution. This op is deprecated in\nfavor of op 'StatefulStandardNormalV2'\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StatefulStandardNormalV2", "path": "raw_ops/statefulstandardnormalv2", "type": "tf.raw_ops", "text": "\nOutputs random values from a normal distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StatefulTruncatedNormal", "path": "raw_ops/statefultruncatednormal", "type": "tf.raw_ops", "text": "\nOutputs random values from a truncated normal distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StatefulUniform", "path": "raw_ops/statefuluniform", "type": "tf.raw_ops", "text": "\nOutputs random values from a uniform distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StatefulUniformFullInt", "path": "raw_ops/statefuluniformfullint", "type": "tf.raw_ops", "text": "\nOutputs random integers from a uniform distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StatefulUniformInt", "path": "raw_ops/statefuluniformint", "type": "tf.raw_ops", "text": "\nOutputs random integers from a uniform distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StatelessCase", "path": "raw_ops/statelesscase", "type": "tf.raw_ops", "text": "\nAn n-way switch statement which calls a single branch function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StatelessIf", "path": "raw_ops/statelessif", "type": "tf.raw_ops", "text": "\noutput = cond ? then_branch(input) : else_branch(input)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StatelessMultinomial", "path": "raw_ops/statelessmultinomial", "type": "tf.raw_ops", "text": "\nDraws samples from a multinomial distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StatelessParameterizedTruncatedNormal", "path": "raw_ops/statelessparameterizedtruncatednormal", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StatelessRandomBinomial", "path": "raw_ops/statelessrandombinomial", "type": "tf.raw_ops", "text": "\nOutputs deterministic pseudorandom random numbers from a binomial\ndistribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StatelessRandomGammaV2", "path": "raw_ops/statelessrandomgammav2", "type": "tf.raw_ops", "text": "\nOutputs deterministic pseudorandom random numbers from a gamma distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StatelessRandomGetKeyCounterAlg", "path": "raw_ops/statelessrandomgetkeycounteralg", "type": "tf.raw_ops", "text": "\nPicks the best algorithm based on device, and scrambles seed into key and\ncounter.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StatelessRandomNormal", "path": "raw_ops/statelessrandomnormal", "type": "tf.raw_ops", "text": "\nOutputs deterministic pseudorandom values from a normal distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StatelessRandomNormalV2", "path": "raw_ops/statelessrandomnormalv2", "type": "tf.raw_ops", "text": "\nOutputs deterministic pseudorandom values from a normal distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StatelessRandomPoisson", "path": "raw_ops/statelessrandompoisson", "type": "tf.raw_ops", "text": "\nOutputs deterministic pseudorandom random numbers from a Poisson distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StatelessRandomUniform", "path": "raw_ops/statelessrandomuniform", "type": "tf.raw_ops", "text": "\nOutputs deterministic pseudorandom random values from a uniform distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StatelessRandomUniformFullInt", "path": "raw_ops/statelessrandomuniformfullint", "type": "tf.raw_ops", "text": "\nOutputs deterministic pseudorandom random integers from a uniform\ndistribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StatelessRandomUniformFullIntV2", "path": "raw_ops/statelessrandomuniformfullintv2", "type": "tf.raw_ops", "text": "\nOutputs deterministic pseudorandom random integers from a uniform\ndistribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StatelessRandomUniformInt", "path": "raw_ops/statelessrandomuniformint", "type": "tf.raw_ops", "text": "\nOutputs deterministic pseudorandom random integers from a uniform\ndistribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StatelessRandomUniformIntV2", "path": "raw_ops/statelessrandomuniformintv2", "type": "tf.raw_ops", "text": "\nOutputs deterministic pseudorandom random integers from a uniform\ndistribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StatelessRandomUniformV2", "path": "raw_ops/statelessrandomuniformv2", "type": "tf.raw_ops", "text": "\nOutputs deterministic pseudorandom random values from a uniform distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StatelessSampleDistortedBoundingBox", "path": "raw_ops/statelesssampledistortedboundingbox", "type": "tf.raw_ops", "text": "\nGenerate a randomly distorted bounding box for an image deterministically.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StatelessTruncatedNormal", "path": "raw_ops/statelesstruncatednormal", "type": "tf.raw_ops", "text": "\nOutputs deterministic pseudorandom values from a truncated normal\ndistribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StatelessTruncatedNormalV2", "path": "raw_ops/statelesstruncatednormalv2", "type": "tf.raw_ops", "text": "\nOutputs deterministic pseudorandom values from a truncated normal\ndistribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StatelessWhile", "path": "raw_ops/statelesswhile", "type": "tf.raw_ops", "text": "\noutput = input; While (Cond(output)) { output = Body(output) }\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StaticRegexFullMatch", "path": "raw_ops/staticregexfullmatch", "type": "tf.raw_ops", "text": "\nCheck if the input matches the regex pattern.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StaticRegexReplace", "path": "raw_ops/staticregexreplace", "type": "tf.raw_ops", "text": "\nReplaces the match of pattern in input with rewrite.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StatsAggregatorHandle", "path": "raw_ops/statsaggregatorhandle", "type": "tf.raw_ops", "text": "\nCreates a statistics manager resource.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StatsAggregatorHandleV2", "path": "raw_ops/statsaggregatorhandlev2", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StatsAggregatorSetSummaryWriter", "path": "raw_ops/statsaggregatorsetsummarywriter", "type": "tf.raw_ops", "text": "\nSet a summary_writer_interface to record statistics using given\nstats_aggregator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StatsAggregatorSummary", "path": "raw_ops/statsaggregatorsummary", "type": "tf.raw_ops", "text": "\nProduces a summary of any statistics recorded by the given statistics manager.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StopGradient", "path": "raw_ops/stopgradient", "type": "tf.raw_ops", "text": "\nStops gradient computation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StridedSlice", "path": "raw_ops/stridedslice", "type": "tf.raw_ops", "text": "\nReturn a strided slice from `input`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StridedSliceAssign", "path": "raw_ops/stridedsliceassign", "type": "tf.raw_ops", "text": "\nAssign `value` to the sliced l-value reference of `ref`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StridedSliceGrad", "path": "raw_ops/stridedslicegrad", "type": "tf.raw_ops", "text": "\nReturns the gradient of `StridedSlice`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StringFormat", "path": "raw_ops/stringformat", "type": "tf.raw_ops", "text": "\nFormats a string template using a list of tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StringJoin", "path": "raw_ops/stringjoin", "type": "tf.raw_ops", "text": "\nJoins the strings in the given list of string tensors into one tensor;\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StringLength", "path": "raw_ops/stringlength", "type": "tf.raw_ops", "text": "\nString lengths of `input`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StringLower", "path": "raw_ops/stringlower", "type": "tf.raw_ops", "text": "\nConverts all uppercase characters into their respective lowercase\nreplacements.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StringNGrams", "path": "raw_ops/stringngrams", "type": "tf.raw_ops", "text": "\nCreates ngrams from ragged string data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StringSplit", "path": "raw_ops/stringsplit", "type": "tf.raw_ops", "text": "\nSplit elements of `input` based on `delimiter` into a `SparseTensor`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StringSplitV2", "path": "raw_ops/stringsplitv2", "type": "tf.raw_ops", "text": "\nSplit elements of `source` based on `sep` into a `SparseTensor`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StringStrip", "path": "raw_ops/stringstrip", "type": "tf.raw_ops", "text": "\nStrip leading and trailing whitespaces from the Tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StringToHashBucket", "path": "raw_ops/stringtohashbucket", "type": "tf.raw_ops", "text": "\nConverts each string in the input Tensor to its hash mod by a number of\nbuckets.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StringToHashBucketFast", "path": "raw_ops/stringtohashbucketfast", "type": "tf.raw_ops", "text": "\nConverts each string in the input Tensor to its hash mod by a number of\nbuckets.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StringToHashBucketStrong", "path": "raw_ops/stringtohashbucketstrong", "type": "tf.raw_ops", "text": "\nConverts each string in the input Tensor to its hash mod by a number of\nbuckets.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StringToNumber", "path": "raw_ops/stringtonumber", "type": "tf.raw_ops", "text": "\nConverts each string in the input Tensor to the specified numeric type.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.StringUpper", "path": "raw_ops/stringupper", "type": "tf.raw_ops", "text": "\nConverts all lowercase characters into their respective uppercase\nreplacements.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Sub", "path": "raw_ops/sub", "type": "tf.raw_ops", "text": "\nReturns x - y element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Substr", "path": "raw_ops/substr", "type": "tf.raw_ops", "text": "\nReturn substrings from `Tensor` of strings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Sum", "path": "raw_ops/sum", "type": "tf.raw_ops", "text": "\nComputes the sum of elements across dimensions of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SummaryWriter", "path": "raw_ops/summarywriter", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Svd", "path": "raw_ops/svd", "type": "tf.raw_ops", "text": "\nComputes the singular value decompositions of one or more matrices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Switch", "path": "raw_ops/switch", "type": "tf.raw_ops", "text": "\nForwards `data` to the output port determined by `pred`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.SymbolicGradient", "path": "raw_ops/symbolicgradient", "type": "tf.raw_ops", "text": "\nComputes the gradient function for function f via backpropagation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TakeDataset", "path": "raw_ops/takedataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that contains `count` elements from the `input_dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TakeManySparseFromTensorsMap", "path": "raw_ops/takemanysparsefromtensorsmap", "type": "tf.raw_ops", "text": "\nRead `SparseTensors` from a `SparseTensorsMap` and concatenate them.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TakeWhileDataset", "path": "raw_ops/takewhiledataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that stops iteration when predicate` is false.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Tan", "path": "raw_ops/tan", "type": "tf.raw_ops", "text": "\nComputes tan of x element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Tanh", "path": "raw_ops/tanh", "type": "tf.raw_ops", "text": "\nComputes hyperbolic tangent of `x` element-wise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TanhGrad", "path": "raw_ops/tanhgrad", "type": "tf.raw_ops", "text": "\nComputes the gradient for the tanh of `x` wrt its input.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TemporaryVariable", "path": "raw_ops/temporaryvariable", "type": "tf.raw_ops", "text": "\nReturns a tensor that may be mutated, but only persists within a single step.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorArray", "path": "raw_ops/tensorarray", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorArrayClose", "path": "raw_ops/tensorarrayclose", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorArrayCloseV2", "path": "raw_ops/tensorarrayclosev2", "type": "tf.raw_ops", "text": "\nDeprecated. Use TensorArrayCloseV3\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorArrayCloseV3", "path": "raw_ops/tensorarrayclosev3", "type": "tf.raw_ops", "text": "\nDelete the TensorArray from its resource container.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorArrayConcat", "path": "raw_ops/tensorarrayconcat", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorArrayConcatV2", "path": "raw_ops/tensorarrayconcatv2", "type": "tf.raw_ops", "text": "\nDeprecated. Use TensorArrayConcatV3\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorArrayConcatV3", "path": "raw_ops/tensorarrayconcatv3", "type": "tf.raw_ops", "text": "\nConcat the elements from the TensorArray into value `value`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorArrayGather", "path": "raw_ops/tensorarraygather", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorArrayGatherV2", "path": "raw_ops/tensorarraygatherv2", "type": "tf.raw_ops", "text": "\nDeprecated. Use TensorArrayGatherV3\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorArrayGatherV3", "path": "raw_ops/tensorarraygatherv3", "type": "tf.raw_ops", "text": "\nGather specific elements from the TensorArray into output `value`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorArrayGrad", "path": "raw_ops/tensorarraygrad", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorArrayGradV2", "path": "raw_ops/tensorarraygradv2", "type": "tf.raw_ops", "text": "\nDeprecated. Use TensorArrayGradV3\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorArrayGradV3", "path": "raw_ops/tensorarraygradv3", "type": "tf.raw_ops", "text": "\nCreates a TensorArray for storing the gradients of values in the given handle.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorArrayGradWithShape", "path": "raw_ops/tensorarraygradwithshape", "type": "tf.raw_ops", "text": "\nCreates a TensorArray for storing multiple gradients of values in the given\nhandle.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorArrayPack", "path": "raw_ops/tensorarraypack", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorArrayRead", "path": "raw_ops/tensorarrayread", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorArrayReadV2", "path": "raw_ops/tensorarrayreadv2", "type": "tf.raw_ops", "text": "\nDeprecated. Use TensorArrayReadV3\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorArrayReadV3", "path": "raw_ops/tensorarrayreadv3", "type": "tf.raw_ops", "text": "\nRead an element from the TensorArray into output `value`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorArrayScatter", "path": "raw_ops/tensorarrayscatter", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorArrayScatterV2", "path": "raw_ops/tensorarrayscatterv2", "type": "tf.raw_ops", "text": "\nDeprecated. Use TensorArrayScatterV3\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorArrayScatterV3", "path": "raw_ops/tensorarrayscatterv3", "type": "tf.raw_ops", "text": "\nScatter the data from the input value into specific TensorArray elements.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorArraySize", "path": "raw_ops/tensorarraysize", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorArraySizeV2", "path": "raw_ops/tensorarraysizev2", "type": "tf.raw_ops", "text": "\nDeprecated. Use TensorArraySizeV3\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorArraySizeV3", "path": "raw_ops/tensorarraysizev3", "type": "tf.raw_ops", "text": "\nGet the current size of the TensorArray.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorArraySplit", "path": "raw_ops/tensorarraysplit", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorArraySplitV2", "path": "raw_ops/tensorarraysplitv2", "type": "tf.raw_ops", "text": "\nDeprecated. Use TensorArraySplitV3\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorArraySplitV3", "path": "raw_ops/tensorarraysplitv3", "type": "tf.raw_ops", "text": "\nSplit the data from the input value into TensorArray elements.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorArrayUnpack", "path": "raw_ops/tensorarrayunpack", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorArrayV2", "path": "raw_ops/tensorarrayv2", "type": "tf.raw_ops", "text": "\nDeprecated. Use TensorArrayV3\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorArrayV3", "path": "raw_ops/tensorarrayv3", "type": "tf.raw_ops", "text": "\nAn array of Tensors of given size.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorArrayWrite", "path": "raw_ops/tensorarraywrite", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorArrayWriteV2", "path": "raw_ops/tensorarraywritev2", "type": "tf.raw_ops", "text": "\nDeprecated. Use TensorArrayGradV3\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorArrayWriteV3", "path": "raw_ops/tensorarraywritev3", "type": "tf.raw_ops", "text": "\nPush an element onto the tensor_array.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorDataset", "path": "raw_ops/tensordataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that emits `components` as a tuple of tensors once.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorListConcat", "path": "raw_ops/tensorlistconcat", "type": "tf.raw_ops", "text": "\nConcats all tensors in the list along the 0th dimension.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorListConcatLists", "path": "raw_ops/tensorlistconcatlists", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorListConcatV2", "path": "raw_ops/tensorlistconcatv2", "type": "tf.raw_ops", "text": "\nConcats all tensors in the list along the 0th dimension.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorListElementShape", "path": "raw_ops/tensorlistelementshape", "type": "tf.raw_ops", "text": "\nThe shape of the elements of the given list, as a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorListFromTensor", "path": "raw_ops/tensorlistfromtensor", "type": "tf.raw_ops", "text": "\nCreates a TensorList which, when stacked, has the value of `tensor`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorListGather", "path": "raw_ops/tensorlistgather", "type": "tf.raw_ops", "text": "\nCreates a Tensor by indexing into the TensorList.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorListGetItem", "path": "raw_ops/tensorlistgetitem", "type": "tf.raw_ops", "text": "\nReturns the item in the list with the given index.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorListLength", "path": "raw_ops/tensorlistlength", "type": "tf.raw_ops", "text": "\nReturns the number of tensors in the input tensor list.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorListPopBack", "path": "raw_ops/tensorlistpopback", "type": "tf.raw_ops", "text": "\nReturns the last element of the input list as well as a list with all but that\nelement.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorListPushBack", "path": "raw_ops/tensorlistpushback", "type": "tf.raw_ops", "text": "\nReturns a list which has the passed-in `Tensor` as last element and the other\nelements of the given list in `input_handle`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorListPushBackBatch", "path": "raw_ops/tensorlistpushbackbatch", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorListReserve", "path": "raw_ops/tensorlistreserve", "type": "tf.raw_ops", "text": "\nList of the given size with empty elements.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorListResize", "path": "raw_ops/tensorlistresize", "type": "tf.raw_ops", "text": "\nResizes the list.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorListScatter", "path": "raw_ops/tensorlistscatter", "type": "tf.raw_ops", "text": "\nCreates a TensorList by indexing into a Tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorListScatterIntoExistingList", "path": "raw_ops/tensorlistscatterintoexistinglist", "type": "tf.raw_ops", "text": "\nScatters tensor at indices in an input list.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorListScatterV2", "path": "raw_ops/tensorlistscatterv2", "type": "tf.raw_ops", "text": "\nCreates a TensorList by indexing into a Tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorListSetItem", "path": "raw_ops/tensorlistsetitem", "type": "tf.raw_ops", "text": "\nSets the index-th position of the list to contain the given tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorListSplit", "path": "raw_ops/tensorlistsplit", "type": "tf.raw_ops", "text": "\nSplits a tensor into a list.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorListStack", "path": "raw_ops/tensorliststack", "type": "tf.raw_ops", "text": "\nStacks all tensors in the list.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorScatterAdd", "path": "raw_ops/tensorscatteradd", "type": "tf.raw_ops", "text": "\nAdds sparse `updates` to an existing tensor according to `indices`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorScatterMax", "path": "raw_ops/tensorscattermax", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorScatterMin", "path": "raw_ops/tensorscattermin", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorScatterSub", "path": "raw_ops/tensorscattersub", "type": "tf.raw_ops", "text": "\nSubtracts sparse `updates` from an existing tensor according to `indices`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorScatterUpdate", "path": "raw_ops/tensorscatterupdate", "type": "tf.raw_ops", "text": "\nScatter `updates` into an existing tensor according to `indices`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorSliceDataset", "path": "raw_ops/tensorslicedataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that emits each dim-0 slice of `components` once.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorStridedSliceUpdate", "path": "raw_ops/tensorstridedsliceupdate", "type": "tf.raw_ops", "text": "\nAssign `value` to the sliced l-value reference of `input`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorSummary", "path": "raw_ops/tensorsummary", "type": "tf.raw_ops", "text": "\nOutputs a `Summary` protocol buffer with a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TensorSummaryV2", "path": "raw_ops/tensorsummaryv2", "type": "tf.raw_ops", "text": "\nOutputs a `Summary` protocol buffer with a tensor and per-plugin data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TextLineDataset", "path": "raw_ops/textlinedataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that emits the lines of one or more text files.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TextLineReader", "path": "raw_ops/textlinereader", "type": "tf.raw_ops", "text": "\nA Reader that outputs the lines of a file delimited by '\\n'.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TextLineReaderV2", "path": "raw_ops/textlinereaderv2", "type": "tf.raw_ops", "text": "\nA Reader that outputs the lines of a file delimited by '\\n'.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TFRecordDataset", "path": "raw_ops/tfrecorddataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that emits the records from one or more TFRecord files.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TFRecordReader", "path": "raw_ops/tfrecordreader", "type": "tf.raw_ops", "text": "\nA Reader that outputs the records from a TensorFlow Records file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TFRecordReaderV2", "path": "raw_ops/tfrecordreaderv2", "type": "tf.raw_ops", "text": "\nA Reader that outputs the records from a TensorFlow Records file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ThreadPoolDataset", "path": "raw_ops/threadpooldataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that uses a custom thread pool to compute `input_dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ThreadPoolHandle", "path": "raw_ops/threadpoolhandle", "type": "tf.raw_ops", "text": "\nCreates a dataset that uses a custom thread pool to compute `input_dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ThreadUnsafeUnigramCandidateSampler", "path": "raw_ops/threadunsafeunigramcandidatesampler", "type": "tf.raw_ops", "text": "\nGenerates labels for candidate sampling with a learned unigram distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Tile", "path": "raw_ops/tile", "type": "tf.raw_ops", "text": "\nConstructs a tensor by tiling a given tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TileGrad", "path": "raw_ops/tilegrad", "type": "tf.raw_ops", "text": "\nReturns the gradient of `Tile`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Timestamp", "path": "raw_ops/timestamp", "type": "tf.raw_ops", "text": "\nProvides the time since epoch in seconds.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ToBool", "path": "raw_ops/tobool", "type": "tf.raw_ops", "text": "\nConverts a tensor to a scalar predicate.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TopK", "path": "raw_ops/topk", "type": "tf.raw_ops", "text": "\nFinds values and indices of the `k` largest elements for the last dimension.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TopKV2", "path": "raw_ops/topkv2", "type": "tf.raw_ops", "text": "\nFinds values and indices of the `k` largest elements for the last dimension.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TPUCompilationResult", "path": "raw_ops/tpucompilationresult", "type": "tf.raw_ops", "text": "\nReturns the result of a TPU compilation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TPUEmbeddingActivations", "path": "raw_ops/tpuembeddingactivations", "type": "tf.raw_ops", "text": "\nAn op enabling differentiation of TPU Embeddings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TPUOrdinalSelector", "path": "raw_ops/tpuordinalselector", "type": "tf.raw_ops", "text": "\nA TPU core selector Op.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TPUPartitionedCall", "path": "raw_ops/tpupartitionedcall", "type": "tf.raw_ops", "text": "\nCalls a function placed on a specified TPU device.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TPUReplicatedInput", "path": "raw_ops/tpureplicatedinput", "type": "tf.raw_ops", "text": "\nConnects N inputs to an N-way replicated TPU computation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TPUReplicatedOutput", "path": "raw_ops/tpureplicatedoutput", "type": "tf.raw_ops", "text": "\nConnects N outputs from an N-way replicated TPU computation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TPUReplicateMetadata", "path": "raw_ops/tpureplicatemetadata", "type": "tf.raw_ops", "text": "\nMetadata indicating how the TPU computation should be replicated.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Transpose", "path": "raw_ops/transpose", "type": "tf.raw_ops", "text": "\nShuffle dimensions of x according to a permutation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TridiagonalMatMul", "path": "raw_ops/tridiagonalmatmul", "type": "tf.raw_ops", "text": "\nCalculate product with tridiagonal matrix.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TridiagonalSolve", "path": "raw_ops/tridiagonalsolve", "type": "tf.raw_ops", "text": "\nSolves tridiagonal systems of equations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TruncateDiv", "path": "raw_ops/truncatediv", "type": "tf.raw_ops", "text": "\nReturns x / y element-wise for integer types.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TruncatedNormal", "path": "raw_ops/truncatednormal", "type": "tf.raw_ops", "text": "\nOutputs random values from a truncated normal distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.TruncateMod", "path": "raw_ops/truncatemod", "type": "tf.raw_ops", "text": "\nReturns element-wise remainder of division. This emulates C semantics in that\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Unbatch", "path": "raw_ops/unbatch", "type": "tf.raw_ops", "text": "\nReverses the operation of Batch for a single output Tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.UnbatchDataset", "path": "raw_ops/unbatchdataset", "type": "tf.raw_ops", "text": "\nA dataset that splits the elements of its input into multiple elements.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.UnbatchGrad", "path": "raw_ops/unbatchgrad", "type": "tf.raw_ops", "text": "\nGradient of Unbatch.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.UncompressElement", "path": "raw_ops/uncompresselement", "type": "tf.raw_ops", "text": "\nUncompresses a compressed dataset element.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.UnicodeDecode", "path": "raw_ops/unicodedecode", "type": "tf.raw_ops", "text": "\nDecodes each string in `input` into a sequence of Unicode code points.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.UnicodeDecodeWithOffsets", "path": "raw_ops/unicodedecodewithoffsets", "type": "tf.raw_ops", "text": "\nDecodes each string in `input` into a sequence of Unicode code points.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.UnicodeEncode", "path": "raw_ops/unicodeencode", "type": "tf.raw_ops", "text": "\nEncode a tensor of ints into unicode strings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.UnicodeScript", "path": "raw_ops/unicodescript", "type": "tf.raw_ops", "text": "\nDetermine the script codes of a given tensor of Unicode integer code points.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.UnicodeTranscode", "path": "raw_ops/unicodetranscode", "type": "tf.raw_ops", "text": "\nTranscode the input text from a source encoding to a destination encoding.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.UniformCandidateSampler", "path": "raw_ops/uniformcandidatesampler", "type": "tf.raw_ops", "text": "\nGenerates labels for candidate sampling with a uniform distribution.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Unique", "path": "raw_ops/unique", "type": "tf.raw_ops", "text": "\nFinds unique elements in a 1-D tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.UniqueDataset", "path": "raw_ops/uniquedataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that contains the unique elements of `input_dataset`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.UniqueV2", "path": "raw_ops/uniquev2", "type": "tf.raw_ops", "text": "\nFinds unique elements along an axis of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.UniqueWithCounts", "path": "raw_ops/uniquewithcounts", "type": "tf.raw_ops", "text": "\nFinds unique elements in a 1-D tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.UniqueWithCountsV2", "path": "raw_ops/uniquewithcountsv2", "type": "tf.raw_ops", "text": "\nFinds unique elements along an axis of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Unpack", "path": "raw_ops/unpack", "type": "tf.raw_ops", "text": "\nUnpacks a given dimension of a rank-`R` tensor into `num` rank-`(R-1)`\ntensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.UnravelIndex", "path": "raw_ops/unravelindex", "type": "tf.raw_ops", "text": "\nConverts an array of flat indices into a tuple of coordinate arrays.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.UnsortedSegmentJoin", "path": "raw_ops/unsortedsegmentjoin", "type": "tf.raw_ops", "text": "\nJoins the elements of `inputs` based on `segment_ids`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.UnsortedSegmentMax", "path": "raw_ops/unsortedsegmentmax", "type": "tf.raw_ops", "text": "\nComputes the maximum along segments of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.UnsortedSegmentMin", "path": "raw_ops/unsortedsegmentmin", "type": "tf.raw_ops", "text": "\nComputes the minimum along segments of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.UnsortedSegmentProd", "path": "raw_ops/unsortedsegmentprod", "type": "tf.raw_ops", "text": "\nComputes the product along segments of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.UnsortedSegmentSum", "path": "raw_ops/unsortedsegmentsum", "type": "tf.raw_ops", "text": "\nComputes the sum along segments of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Unstage", "path": "raw_ops/unstage", "type": "tf.raw_ops", "text": "\nOp is similar to a lightweight Dequeue.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.UnwrapDatasetVariant", "path": "raw_ops/unwrapdatasetvariant", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.UpperBound", "path": "raw_ops/upperbound", "type": "tf.raw_ops", "text": "\nApplies upper_bound(sorted_search_values, values) along each row.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.VarHandleOp", "path": "raw_ops/varhandleop", "type": "tf.raw_ops", "text": "\nCreates a handle to a Variable resource.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Variable", "path": "raw_ops/variable", "type": "tf.raw_ops", "text": "\nUse VariableV2 instead.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.VariableShape", "path": "raw_ops/variableshape", "type": "tf.raw_ops", "text": "\nReturns the shape of the variable pointed to by `resource`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.VariableV2", "path": "raw_ops/variablev2", "type": "tf.raw_ops", "text": "\nHolds state in the form of a tensor that persists across steps.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.VarIsInitializedOp", "path": "raw_ops/varisinitializedop", "type": "tf.raw_ops", "text": "\nChecks whether a resource handle-based variable has been initialized.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Where", "path": "raw_ops/where", "type": "tf.raw_ops", "text": "\nReturns locations of nonzero / true values in a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.While", "path": "raw_ops/while", "type": "tf.raw_ops", "text": "\noutput = input; While (Cond(output)) { output = Body(output) }\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.WholeFileReader", "path": "raw_ops/wholefilereader", "type": "tf.raw_ops", "text": "\nA Reader that outputs the entire contents of a file as a value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.WholeFileReaderV2", "path": "raw_ops/wholefilereaderv2", "type": "tf.raw_ops", "text": "\nA Reader that outputs the entire contents of a file as a value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.WindowDataset", "path": "raw_ops/windowdataset", "type": "tf.raw_ops", "text": "\nCombines (nests of) input elements into a dataset of (nests of) windows.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.WorkerHeartbeat", "path": "raw_ops/workerheartbeat", "type": "tf.raw_ops", "text": "\nWorker heartbeat op.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.WrapDatasetVariant", "path": "raw_ops/wrapdatasetvariant", "type": "tf.raw_ops", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.WriteAudioSummary", "path": "raw_ops/writeaudiosummary", "type": "tf.raw_ops", "text": "\nWrites an audio summary.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.WriteFile", "path": "raw_ops/writefile", "type": "tf.raw_ops", "text": "\nWrites contents to the file at input filename. Creates file and recursively\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.WriteGraphSummary", "path": "raw_ops/writegraphsummary", "type": "tf.raw_ops", "text": "\nWrites a graph summary.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.WriteHistogramSummary", "path": "raw_ops/writehistogramsummary", "type": "tf.raw_ops", "text": "\nWrites a histogram summary.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.WriteImageSummary", "path": "raw_ops/writeimagesummary", "type": "tf.raw_ops", "text": "\nWrites an image summary.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.WriteRawProtoSummary", "path": "raw_ops/writerawprotosummary", "type": "tf.raw_ops", "text": "\nWrites a serialized proto summary.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.WriteScalarSummary", "path": "raw_ops/writescalarsummary", "type": "tf.raw_ops", "text": "\nWrites a scalar summary.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.WriteSummary", "path": "raw_ops/writesummary", "type": "tf.raw_ops", "text": "\nWrites a tensor summary.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Xdivy", "path": "raw_ops/xdivy", "type": "tf.raw_ops", "text": "\nReturns 0 if x == 0, and x / y otherwise, elementwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Xlog1py", "path": "raw_ops/xlog1py", "type": "tf.raw_ops", "text": "\nReturns 0 if x == 0, and x * log1p(y) otherwise, elementwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Xlogy", "path": "raw_ops/xlogy", "type": "tf.raw_ops", "text": "\nReturns 0 if x == 0, and x * log(y) otherwise, elementwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ZerosLike", "path": "raw_ops/zeroslike", "type": "tf.raw_ops", "text": "\nReturns a tensor of zeros with the same shape and type as x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.Zeta", "path": "raw_ops/zeta", "type": "tf.raw_ops", "text": "\nCompute the Hurwitz zeta function \\\\(\\zeta(x, q)\\\\).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.raw_ops.ZipDataset", "path": "raw_ops/zipdataset", "type": "tf.raw_ops", "text": "\nCreates a dataset that zips together `input_datasets`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.realdiv", "path": "realdiv", "type": "tf", "text": "\nReturns x / y element-wise for real types.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.recompute_grad", "path": "recompute_grad", "type": "tf", "text": "\nAn eager-compatible version of recompute_grad.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.RegisterGradient", "path": "registergradient", "type": "tf", "text": "\nA decorator for registering the gradient function for an op type.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.register_tensor_conversion_function", "path": "register_tensor_conversion_function", "type": "tf", "text": "\nRegisters a function for converting objects of `base_type` to `Tensor`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.repeat", "path": "repeat", "type": "tf", "text": "\nRepeat elements of `input`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.required_space_to_batch_paddings", "path": "required_space_to_batch_paddings", "type": "tf", "text": "\nCalculate padding required to make block_shape divide input_shape.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.reshape", "path": "reshape", "type": "tf", "text": "\nReshapes a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.reverse", "path": "reverse", "type": "tf", "text": "\nReverses specific dimensions of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.reverse_sequence", "path": "reverse_sequence", "type": "tf", "text": "\nReverses variable length slices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.roll", "path": "roll", "type": "tf", "text": "\nRolls the elements of a tensor along an axis.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.saved_model", "path": "saved_model", "type": "tf.saved_model", "text": "\nPublic API for tf.saved_model namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.saved_model.Asset", "path": "saved_model/asset", "type": "tf.saved_model", "text": "\nRepresents a file asset to hermetically include in a SavedModel.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.saved_model.contains_saved_model", "path": "saved_model/contains_saved_model", "type": "tf.saved_model", "text": "\nChecks whether the provided export directory could contain a SavedModel.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.saved_model.experimental", "path": "saved_model/experimental", "type": "tf.saved_model", "text": "\nPublic API for tf.saved_model.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.saved_model.experimental.VariablePolicy", "path": "saved_model/experimental/variablepolicy", "type": "tf.saved_model", "text": "\nEnum defining options for variable handling when saving.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.saved_model.load", "path": "saved_model/load", "type": "tf.saved_model", "text": "\nLoad a SavedModel from `export_dir`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.saved_model.LoadOptions", "path": "saved_model/loadoptions", "type": "tf.saved_model", "text": "\nOptions for loading a SavedModel.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.saved_model.save", "path": "saved_model/save", "type": "tf.saved_model", "text": "\nExports the Trackable object `obj` to SavedModel format.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.saved_model.SaveOptions", "path": "saved_model/saveoptions", "type": "tf.saved_model", "text": "\nOptions for saving to SavedModel.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.scan", "path": "scan", "type": "tf", "text": "\nscan on the list of tensors unpacked from `elems` on dimension 0. (deprecated\nargument values)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.scatter_nd", "path": "scatter_nd", "type": "tf", "text": "\nScatter `updates` into a new tensor according to `indices`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.searchsorted", "path": "searchsorted", "type": "tf", "text": "\nSearches input tensor for values on the innermost dimension.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sequence_mask", "path": "sequence_mask", "type": "tf", "text": "\nReturns a mask tensor representing the first N positions of each cell.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sets", "path": "sets", "type": "tf.sets", "text": "\nTensorflow set operations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sets.difference", "path": "sets/difference", "type": "tf.sets", "text": "\nCompute set difference of elements in last dimension of `a` and `b`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sets.intersection", "path": "sets/intersection", "type": "tf.sets", "text": "\nCompute set intersection of elements in last dimension of `a` and `b`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sets.size", "path": "sets/size", "type": "tf.sets", "text": "\nCompute number of unique elements along last dimension of `a`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sets.union", "path": "sets/union", "type": "tf.sets", "text": "\nCompute set union of elements in last dimension of `a` and `b`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.shape", "path": "shape", "type": "tf", "text": "\nReturns a tensor containing the shape of the input tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.shape_n", "path": "shape_n", "type": "tf", "text": "\nReturns shape of tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.signal", "path": "signal", "type": "tf.signal", "text": "\nSignal processing operations.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.signal.dct", "path": "signal/dct", "type": "tf.signal", "text": "\nComputes the 1D Discrete Cosine Transform (DCT) of `input`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.signal.fft", "path": "signal/fft", "type": "tf.signal", "text": "\nFast Fourier transform.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.signal.fft2d", "path": "signal/fft2d", "type": "tf.signal", "text": "\n2D fast Fourier transform.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.signal.fft3d", "path": "signal/fft3d", "type": "tf.signal", "text": "\n3D fast Fourier transform.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.signal.fftshift", "path": "signal/fftshift", "type": "tf.signal", "text": "\nShift the zero-frequency component to the center of the spectrum.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.signal.frame", "path": "signal/frame", "type": "tf.signal", "text": "\nExpands `signal`'s `axis` dimension into frames of `frame_length`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.signal.hamming_window", "path": "signal/hamming_window", "type": "tf.signal", "text": "\nGenerate a Hamming window.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.signal.hann_window", "path": "signal/hann_window", "type": "tf.signal", "text": "\nGenerate a Hann window.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.signal.idct", "path": "signal/idct", "type": "tf.signal", "text": "\nComputes the 1D Inverse Discrete Cosine Transform (DCT) of `input`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.signal.ifft", "path": "signal/ifft", "type": "tf.signal", "text": "\nInverse fast Fourier transform.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.signal.ifft2d", "path": "signal/ifft2d", "type": "tf.signal", "text": "\nInverse 2D fast Fourier transform.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.signal.ifft3d", "path": "signal/ifft3d", "type": "tf.signal", "text": "\nInverse 3D fast Fourier transform.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.signal.ifftshift", "path": "signal/ifftshift", "type": "tf.signal", "text": "\nThe inverse of fftshift.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.signal.inverse_mdct", "path": "signal/inverse_mdct", "type": "tf.signal", "text": "\nComputes the inverse modified DCT of `mdcts`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.signal.inverse_stft", "path": "signal/inverse_stft", "type": "tf.signal", "text": "\nComputes the inverse Short-time Fourier Transform of `stfts`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.signal.inverse_stft_window_fn", "path": "signal/inverse_stft_window_fn", "type": "tf.signal", "text": "\nGenerates a window function that can be used in `inverse_stft`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.signal.irfft", "path": "signal/irfft", "type": "tf.signal", "text": "\nInverse real-valued fast Fourier transform.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.signal.irfft2d", "path": "signal/irfft2d", "type": "tf.signal", "text": "\nInverse 2D real-valued fast Fourier transform.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.signal.irfft3d", "path": "signal/irfft3d", "type": "tf.signal", "text": "\nInverse 3D real-valued fast Fourier transform.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.signal.kaiser_bessel_derived_window", "path": "signal/kaiser_bessel_derived_window", "type": "tf.signal", "text": "\nGenerate a Kaiser Bessel derived window.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.signal.kaiser_window", "path": "signal/kaiser_window", "type": "tf.signal", "text": "\nGenerate a Kaiser window.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.signal.linear_to_mel_weight_matrix", "path": "signal/linear_to_mel_weight_matrix", "type": "tf.signal", "text": "\nReturns a matrix to warp linear scale spectrograms to the mel scale.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.signal.mdct", "path": "signal/mdct", "type": "tf.signal", "text": "\nComputes the Modified Discrete Cosine Transform of `signals`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.signal.mfccs_from_log_mel_spectrograms", "path": "signal/mfccs_from_log_mel_spectrograms", "type": "tf.signal", "text": "\nComputes MFCCs of `log_mel_spectrograms`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.signal.overlap_and_add", "path": "signal/overlap_and_add", "type": "tf.signal", "text": "\nReconstructs a signal from a framed representation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.signal.rfft", "path": "signal/rfft", "type": "tf.signal", "text": "\nReal-valued fast Fourier transform.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.signal.rfft2d", "path": "signal/rfft2d", "type": "tf.signal", "text": "\n2D real-valued fast Fourier transform.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.signal.rfft3d", "path": "signal/rfft3d", "type": "tf.signal", "text": "\n3D real-valued fast Fourier transform.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.signal.stft", "path": "signal/stft", "type": "tf.signal", "text": "\nComputes the Short-time Fourier Transform of `signals`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.signal.vorbis_window", "path": "signal/vorbis_window", "type": "tf.signal", "text": "\nGenerate a Vorbis power complementary window.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.size", "path": "size", "type": "tf", "text": "\nReturns the size of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.slice", "path": "slice", "type": "tf", "text": "\nExtracts a slice from a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sort", "path": "sort", "type": "tf", "text": "\nSorts a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.space_to_batch", "path": "space_to_batch", "type": "tf", "text": "\nSpaceToBatch for N-D tensors of type T.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.space_to_batch_nd", "path": "space_to_batch_nd", "type": "tf", "text": "\nSpaceToBatch for N-D tensors of type T.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sparse", "path": "sparse", "type": "tf.sparse", "text": "\nSparse Tensor Representation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sparse.add", "path": "sparse/add", "type": "tf.sparse", "text": "\nAdds two tensors, at least one of each is a `SparseTensor`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sparse.bincount", "path": "sparse/bincount", "type": "tf.sparse", "text": "\nCount the number of times an integer value appears in a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sparse.concat", "path": "sparse/concat", "type": "tf.sparse", "text": "\nConcatenates a list of `SparseTensor` along the specified dimension.\n(deprecated arguments)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sparse.cross", "path": "sparse/cross", "type": "tf.sparse", "text": "\nGenerates sparse cross from a list of sparse and dense tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sparse.cross_hashed", "path": "sparse/cross_hashed", "type": "tf.sparse", "text": "\nGenerates hashed sparse cross from a list of sparse and dense tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sparse.expand_dims", "path": "sparse/expand_dims", "type": "tf.sparse", "text": "\nReturns a tensor with an length 1 axis inserted at index `axis`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sparse.eye", "path": "sparse/eye", "type": "tf.sparse", "text": "\nCreates a two-dimensional sparse tensor with ones along the diagonal.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sparse.fill_empty_rows", "path": "sparse/fill_empty_rows", "type": "tf.sparse", "text": "\nFills empty rows in the input 2-D `SparseTensor` with a default value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sparse.from_dense", "path": "sparse/from_dense", "type": "tf.sparse", "text": "\nConverts a dense tensor into a sparse tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sparse.map_values", "path": "sparse/map_values", "type": "tf.sparse", "text": "\nApplies `op` to the `.values` tensor of one or more `SparseTensor`s.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sparse.mask", "path": "sparse/mask", "type": "tf.sparse", "text": "\nMasks elements of `IndexedSlices`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sparse.maximum", "path": "sparse/maximum", "type": "tf.sparse", "text": "\nReturns the element-wise max of two SparseTensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sparse.minimum", "path": "sparse/minimum", "type": "tf.sparse", "text": "\nReturns the element-wise min of two SparseTensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sparse.reduce_max", "path": "sparse/reduce_max", "type": "tf.sparse", "text": "\nComputes the max of elements across dimensions of a SparseTensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sparse.reduce_sum", "path": "sparse/reduce_sum", "type": "tf.sparse", "text": "\nComputes the sum of elements across dimensions of a SparseTensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sparse.reorder", "path": "sparse/reorder", "type": "tf.sparse", "text": "\nReorders a `SparseTensor` into the canonical, row-major ordering.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sparse.reset_shape", "path": "sparse/reset_shape", "type": "tf.sparse", "text": "\nResets the shape of a `SparseTensor` with indices and values unchanged.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sparse.reshape", "path": "sparse/reshape", "type": "tf.sparse", "text": "\nReshapes a `SparseTensor` to represent values in a new dense shape.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sparse.retain", "path": "sparse/retain", "type": "tf.sparse", "text": "\nRetains specified non-empty values within a `SparseTensor`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sparse.segment_mean", "path": "sparse/segment_mean", "type": "tf.sparse", "text": "\nComputes the mean along sparse segments of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sparse.segment_sqrt_n", "path": "sparse/segment_sqrt_n", "type": "tf.sparse", "text": "\nComputes the sum along sparse segments of a tensor divided by the sqrt(N).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sparse.segment_sum", "path": "sparse/segment_sum", "type": "tf.sparse", "text": "\nComputes the sum along sparse segments of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sparse.slice", "path": "sparse/slice", "type": "tf.sparse", "text": "\nSlice a `SparseTensor` based on the `start` and `size.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sparse.softmax", "path": "sparse/softmax", "type": "tf.sparse", "text": "\nApplies softmax to a batched N-D `SparseTensor`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sparse.SparseTensor", "path": "sparse/sparsetensor", "type": "tf.sparse", "text": "\nRepresents a sparse tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sparse.sparse_dense_matmul", "path": "sparse/sparse_dense_matmul", "type": "tf.sparse", "text": "\nMultiply SparseTensor (or dense Matrix) (of rank 2) \"A\" by dense matrix\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sparse.split", "path": "sparse/split", "type": "tf.sparse", "text": "\nSplit a `SparseTensor` into `num_split` tensors along `axis`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sparse.to_dense", "path": "sparse/to_dense", "type": "tf.sparse", "text": "\nConverts a `SparseTensor` into a dense tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sparse.to_indicator", "path": "sparse/to_indicator", "type": "tf.sparse", "text": "\nConverts a `SparseTensor` of ids into a dense bool indicator tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sparse.transpose", "path": "sparse/transpose", "type": "tf.sparse", "text": "\nTransposes a `SparseTensor`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.SparseTensorSpec", "path": "sparsetensorspec", "type": "tf", "text": "\nType specification for a `tf.sparse.SparseTensor`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.split", "path": "split", "type": "tf", "text": "\nSplits a tensor `value` into a list of sub tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.squeeze", "path": "squeeze", "type": "tf", "text": "\nRemoves dimensions of size 1 from the shape of a tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.stack", "path": "stack", "type": "tf", "text": "\nStacks a list of rank-`R` tensors into one rank-`(R+1)` tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.stop_gradient", "path": "stop_gradient", "type": "tf", "text": "\nStops gradient computation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.strided_slice", "path": "strided_slice", "type": "tf", "text": "\nExtracts a strided slice of a tensor (generalized Python array indexing).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.strings", "path": "strings", "type": "tf.strings", "text": "\nOperations for working with string Tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.strings.as_string", "path": "strings/as_string", "type": "tf.strings", "text": "\nConverts each entry in the given tensor to strings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.strings.bytes_split", "path": "strings/bytes_split", "type": "tf.strings", "text": "\nSplit string elements of `input` into bytes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.strings.format", "path": "strings/format", "type": "tf.strings", "text": "\nFormats a string template using a list of tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.strings.join", "path": "strings/join", "type": "tf.strings", "text": "\nPerform element-wise concatenation of a list of string tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.strings.length", "path": "strings/length", "type": "tf.strings", "text": "\nString lengths of `input`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.strings.lower", "path": "strings/lower", "type": "tf.strings", "text": "\nConverts all uppercase characters into their respective lowercase\nreplacements.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.strings.ngrams", "path": "strings/ngrams", "type": "tf.strings", "text": "\nCreate a tensor of n-grams based on `data`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.strings.reduce_join", "path": "strings/reduce_join", "type": "tf.strings", "text": "\nJoins all strings into a single string, or joins along an axis.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.strings.regex_full_match", "path": "strings/regex_full_match", "type": "tf.strings", "text": "\nCheck if the input matches the regex pattern.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.strings.regex_replace", "path": "strings/regex_replace", "type": "tf.strings", "text": "\nReplace elements of `input` matching regex `pattern` with `rewrite`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.strings.split", "path": "strings/split", "type": "tf.strings", "text": "\nSplit elements of `input` based on `sep` into a `RaggedTensor`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.strings.strip", "path": "strings/strip", "type": "tf.strings", "text": "\nStrip leading and trailing whitespaces from the Tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.strings.substr", "path": "strings/substr", "type": "tf.strings", "text": "\nReturn substrings from `Tensor` of strings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.strings.to_hash_bucket", "path": "strings/to_hash_bucket", "type": "tf.strings", "text": "\nConverts each string in the input Tensor to its hash mod by a number of\nbuckets.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.strings.to_hash_bucket_fast", "path": "strings/to_hash_bucket_fast", "type": "tf.strings", "text": "\nConverts each string in the input Tensor to its hash mod by a number of\nbuckets.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.strings.to_hash_bucket_strong", "path": "strings/to_hash_bucket_strong", "type": "tf.strings", "text": "\nConverts each string in the input Tensor to its hash mod by a number of\nbuckets.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.strings.to_number", "path": "strings/to_number", "type": "tf.strings", "text": "\nConverts each string in the input Tensor to the specified numeric type.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.strings.unicode_decode", "path": "strings/unicode_decode", "type": "tf.strings", "text": "\nDecodes each string in `input` into a sequence of Unicode code points.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.strings.unicode_decode_with_offsets", "path": "strings/unicode_decode_with_offsets", "type": "tf.strings", "text": "\nDecodes each string into a sequence of code points with start offsets.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.strings.unicode_encode", "path": "strings/unicode_encode", "type": "tf.strings", "text": "\nEncodes each sequence of Unicode code points in `input` into a string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.strings.unicode_script", "path": "strings/unicode_script", "type": "tf.strings", "text": "\nDetermine the script codes of a given tensor of Unicode integer code points.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.strings.unicode_split", "path": "strings/unicode_split", "type": "tf.strings", "text": "\nSplits each string in `input` into a sequence of Unicode code points.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.strings.unicode_split_with_offsets", "path": "strings/unicode_split_with_offsets", "type": "tf.strings", "text": "\nSplits each string into a sequence of code points with start offsets.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.strings.unicode_transcode", "path": "strings/unicode_transcode", "type": "tf.strings", "text": "\nTranscode the input text from a source encoding to a destination encoding.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.strings.unsorted_segment_join", "path": "strings/unsorted_segment_join", "type": "tf.strings", "text": "\nJoins the elements of `inputs` based on `segment_ids`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.strings.upper", "path": "strings/upper", "type": "tf.strings", "text": "\nConverts all lowercase characters into their respective uppercase\nreplacements.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.summary", "path": "summary", "type": "tf.summary", "text": "\nOperations for writing summary data, for use in analysis and visualization.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.summary.audio", "path": "summary/audio", "type": "tf.summary", "text": "\nWrite an audio summary.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.summary.create_file_writer", "path": "summary/create_file_writer", "type": "tf.summary", "text": "\nCreates a summary file writer for the given log directory.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.summary.create_noop_writer", "path": "summary/create_noop_writer", "type": "tf.summary", "text": "\nReturns a summary writer that does nothing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.summary.experimental", "path": "summary/experimental", "type": "tf.summary", "text": "\nPublic API for tf.summary.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.summary.experimental.get_step", "path": "summary/experimental/get_step", "type": "tf.summary", "text": "\nReturns the default summary step for the current thread.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.summary.experimental.set_step", "path": "summary/experimental/set_step", "type": "tf.summary", "text": "\nSets the default summary step for the current thread.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.summary.experimental.summary_scope", "path": "summary/experimental/summary_scope", "type": "tf.summary", "text": "\nExperimental context manager for use when defining a custom summary op.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.summary.experimental.write_raw_pb", "path": "summary/experimental/write_raw_pb", "type": "tf.summary", "text": "\nWrites a summary using raw `tf.compat.v1.Summary` protocol buffers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.summary.flush", "path": "summary/flush", "type": "tf.summary", "text": "\nForces summary writer to send any buffered data to storage.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.summary.histogram", "path": "summary/histogram", "type": "tf.summary", "text": "\nWrite a histogram summary.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.summary.image", "path": "summary/image", "type": "tf.summary", "text": "\nWrite an image summary.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.summary.record_if", "path": "summary/record_if", "type": "tf.summary", "text": "\nSets summary recording on or off per the provided boolean value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.summary.scalar", "path": "summary/scalar", "type": "tf.summary", "text": "\nWrite a scalar summary.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.summary.should_record_summaries", "path": "summary/should_record_summaries", "type": "tf.summary", "text": "\nReturns boolean Tensor which is true if summaries should be recorded.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.summary.SummaryWriter", "path": "summary/summarywriter", "type": "tf.summary", "text": "\nInterface representing a stateful summary writer object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.summary.text", "path": "summary/text", "type": "tf.summary", "text": "\nWrite a text summary.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.summary.trace_export", "path": "summary/trace_export", "type": "tf.summary", "text": "\nStops and exports the active trace as a Summary and/or profile file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.summary.trace_off", "path": "summary/trace_off", "type": "tf.summary", "text": "\nStops the current trace and discards any collected information.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.summary.trace_on", "path": "summary/trace_on", "type": "tf.summary", "text": "\nStarts a trace to record computation graphs and profiling information.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.summary.write", "path": "summary/write", "type": "tf.summary", "text": "\nWrites a generic summary to the default SummaryWriter if one exists.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.switch_case", "path": "switch_case", "type": "tf", "text": "\nCreate a switch/case operation, i.e. an integer-indexed conditional.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sysconfig", "path": "sysconfig", "type": "tf.sysconfig", "text": "\nSystem configuration library.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sysconfig.get_build_info", "path": "sysconfig/get_build_info", "type": "tf.sysconfig", "text": "\nGet a dictionary describing TensorFlow's build environment.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sysconfig.get_compile_flags", "path": "sysconfig/get_compile_flags", "type": "tf.sysconfig", "text": "\nGet the compilation flags for custom operators.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sysconfig.get_include", "path": "sysconfig/get_include", "type": "tf.sysconfig", "text": "\nGet the directory containing the TensorFlow C++ header files.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sysconfig.get_lib", "path": "sysconfig/get_lib", "type": "tf.sysconfig", "text": "\nGet the directory containing the TensorFlow framework library.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.sysconfig.get_link_flags", "path": "sysconfig/get_link_flags", "type": "tf.sysconfig", "text": "\nGet the link flags for custom operators.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.Tensor", "path": "tensor", "type": "tf", "text": "\nA tensor is a multidimensional array of elements represented by a\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.TensorArray", "path": "tensorarray", "type": "tf", "text": "\nClass wrapping dynamic-sized, per-time-step, write-once Tensor arrays.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.TensorArraySpec", "path": "tensorarrayspec", "type": "tf", "text": "\nType specification for a `tf.TensorArray`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.tensordot", "path": "tensordot", "type": "tf", "text": "\nTensor contraction of a and b along specified axes and outer product.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.TensorShape", "path": "tensorshape", "type": "tf", "text": "\nRepresents the shape of a `Tensor`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.TensorSpec", "path": "tensorspec", "type": "tf", "text": "\nDescribes a tf.Tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.tensor_scatter_nd_add", "path": "tensor_scatter_nd_add", "type": "tf", "text": "\nAdds sparse `updates` to an existing tensor according to `indices`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.tensor_scatter_nd_max", "path": "tensor_scatter_nd_max", "type": "tf", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.tensor_scatter_nd_min", "path": "tensor_scatter_nd_min", "type": "tf", "text": "\nCompat aliases for migration\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.tensor_scatter_nd_sub", "path": "tensor_scatter_nd_sub", "type": "tf", "text": "\nSubtracts sparse `updates` from an existing tensor according to `indices`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.tensor_scatter_nd_update", "path": "tensor_scatter_nd_update", "type": "tf", "text": "\n\"Scatter `updates` into an existing tensor according to `indices`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.test", "path": "test", "type": "tf.test", "text": "\nTesting.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.test.assert_equal_graph_def", "path": "test/assert_equal_graph_def", "type": "tf.test", "text": "\nAsserts that two `GraphDef`s are (mostly) the same.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.test.Benchmark", "path": "test/benchmark", "type": "tf.test", "text": "\nAbstract class that provides helpers for TensorFlow benchmarks.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.test.benchmark_config", "path": "test/benchmark_config", "type": "tf.test", "text": "\nReturns a tf.compat.v1.ConfigProto for disabling the dependency optimizer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.test.compute_gradient", "path": "test/compute_gradient", "type": "tf.test", "text": "\nComputes the theoretical and numeric Jacobian of `f`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.test.create_local_cluster", "path": "test/create_local_cluster", "type": "tf.test", "text": "\nCreate and start local servers and return the associated `Server` objects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.test.gpu_device_name", "path": "test/gpu_device_name", "type": "tf.test", "text": "\nReturns the name of a GPU device if available or the empty string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.test.is_built_with_cuda", "path": "test/is_built_with_cuda", "type": "tf.test", "text": "\nReturns whether TensorFlow was built with CUDA (GPU) support.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.test.is_built_with_gpu_support", "path": "test/is_built_with_gpu_support", "type": "tf.test", "text": "\nReturns whether TensorFlow was built with GPU (i.e. CUDA or ROCm) support.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.test.is_built_with_rocm", "path": "test/is_built_with_rocm", "type": "tf.test", "text": "\nReturns whether TensorFlow was built with ROCm (GPU) support.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.test.is_built_with_xla", "path": "test/is_built_with_xla", "type": "tf.test", "text": "\nReturns whether TensorFlow was built with XLA support.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.test.is_gpu_available", "path": "test/is_gpu_available", "type": "tf.test", "text": "\nReturns whether TensorFlow can access a GPU. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.test.main", "path": "test/main", "type": "tf.test", "text": "\nRuns all unit tests.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.test.TestCase", "path": "test/testcase", "type": "tf.test", "text": "\nBase class for tests that need to test TensorFlow.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.test.TestCase.failureException", "path": "test/testcase/failureexception", "type": "tf.test", "text": "\nAssertion failed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.tile", "path": "tile", "type": "tf", "text": "\nConstructs a tensor by tiling a given tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.timestamp", "path": "timestamp", "type": "tf", "text": "\nProvides the time since epoch in seconds.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.tpu", "path": "tpu", "type": "tf.tpu", "text": "\nOps related to Tensor Processing Units.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.tpu.experimental", "path": "tpu/experimental", "type": "tf.tpu", "text": "\nPublic API for tf.tpu.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.tpu.experimental.DeviceAssignment", "path": "tpu/experimental/deviceassignment", "type": "tf.tpu", "text": "\nMapping from logical cores in a computation to the physical TPU topology.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.tpu.experimental.embedding", "path": "tpu/experimental/embedding", "type": "tf.tpu", "text": "\nPublic API for tf.tpu.experimental.embedding namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.tpu.experimental.embedding.Adagrad", "path": "tpu/experimental/embedding/adagrad", "type": "tf.tpu", "text": "\nOptimization parameters for Adagrad with TPU embeddings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.tpu.experimental.embedding.Adam", "path": "tpu/experimental/embedding/adam", "type": "tf.tpu", "text": "\nOptimization parameters for Adam with TPU embeddings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.tpu.experimental.embedding.FeatureConfig", "path": "tpu/experimental/embedding/featureconfig", "type": "tf.tpu", "text": "\nConfiguration data for one embedding feature.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.tpu.experimental.embedding.serving_embedding_lookup", "path": "tpu/experimental/embedding/serving_embedding_lookup", "type": "tf.tpu", "text": "\nApply standard lookup ops with `tf.tpu.experimental.embedding` configs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.tpu.experimental.embedding.SGD", "path": "tpu/experimental/embedding/sgd", "type": "tf.tpu", "text": "\nOptimization parameters for stochastic gradient descent for TPU embeddings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.tpu.experimental.embedding.TableConfig", "path": "tpu/experimental/embedding/tableconfig", "type": "tf.tpu", "text": "\nConfiguration data for one embedding table.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.tpu.experimental.embedding.TPUEmbedding", "path": "tpu/experimental/embedding/tpuembedding", "type": "tf.tpu", "text": "\nThe TPUEmbedding mid level API.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.tpu.experimental.initialize_tpu_system", "path": "tpu/experimental/initialize_tpu_system", "type": "tf.tpu", "text": "\nInitialize the TPU devices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.tpu.experimental.shutdown_tpu_system", "path": "tpu/experimental/shutdown_tpu_system", "type": "tf.tpu", "text": "\nShuts down the TPU devices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.tpu.experimental.Topology", "path": "tpu/experimental/topology", "type": "tf.tpu", "text": "\nDescribes a set of TPU devices.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.tpu.experimental.TPUSystemMetadata", "path": "tpu/experimental/tpusystemmetadata", "type": "tf.tpu", "text": "\nDescribes some metadata about the TPU system.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.train", "path": "train", "type": "tf.train", "text": "\nSupport for training models.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.train.BytesList", "path": "train/byteslist", "type": "tf.train", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.train.Checkpoint", "path": "train/checkpoint", "type": "tf.train", "text": "\nManages saving/restoring trackable values to disk.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.train.CheckpointManager", "path": "train/checkpointmanager", "type": "tf.train", "text": "\nManages multiple checkpoints by keeping some and deleting unneeded ones.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.train.CheckpointOptions", "path": "train/checkpointoptions", "type": "tf.train", "text": "\nOptions for constructing a Checkpoint.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.train.checkpoints_iterator", "path": "train/checkpoints_iterator", "type": "tf.train", "text": "\nContinuously yield new checkpoint files as they appear.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.train.ClusterDef", "path": "train/clusterdef", "type": "tf.train", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.train.ClusterSpec", "path": "train/clusterspec", "type": "tf.train", "text": "\nRepresents a cluster as a set of \"tasks\", organized into \"jobs\".\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.train.Coordinator", "path": "train/coordinator", "type": "tf.train", "text": "\nA coordinator for threads.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.train.Example", "path": "train/example", "type": "tf.train", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.train.experimental", "path": "train/experimental", "type": "tf.train", "text": "\nPublic API for tf.train.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.train.experimental.disable_mixed_precision_graph_rewrite", "path": "train/experimental/disable_mixed_precision_graph_rewrite", "type": "tf.train", "text": "\nDisables the mixed precision graph rewrite. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.train.experimental.enable_mixed_precision_graph_rewrite", "path": "train/experimental/enable_mixed_precision_graph_rewrite", "type": "tf.train", "text": "\nEnable mixed precision via a graph rewrite. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.train.experimental.PythonState", "path": "train/experimental/pythonstate", "type": "tf.train", "text": "\nA mixin for putting Python state in an object-based checkpoint.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.train.ExponentialMovingAverage", "path": "train/exponentialmovingaverage", "type": "tf.train", "text": "\nMaintains moving averages of variables by employing an exponential decay.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.train.Feature", "path": "train/feature", "type": "tf.train", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.train.FeatureList", "path": "train/featurelist", "type": "tf.train", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.train.FeatureLists", "path": "train/featurelists", "type": "tf.train", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.train.FeatureLists.FeatureListEntry", "path": "train/featurelists/featurelistentry", "type": "tf.train", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.train.Features", "path": "train/features", "type": "tf.train", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.train.Features.FeatureEntry", "path": "train/features/featureentry", "type": "tf.train", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.train.FloatList", "path": "train/floatlist", "type": "tf.train", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.train.get_checkpoint_state", "path": "train/get_checkpoint_state", "type": "tf.train", "text": "\nReturns CheckpointState proto from the \"checkpoint\" file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.train.Int64List", "path": "train/int64list", "type": "tf.train", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.train.JobDef", "path": "train/jobdef", "type": "tf.train", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.train.JobDef.TasksEntry", "path": "train/jobdef/tasksentry", "type": "tf.train", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.train.latest_checkpoint", "path": "train/latest_checkpoint", "type": "tf.train", "text": "\nFinds the filename of latest saved checkpoint file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.train.list_variables", "path": "train/list_variables", "type": "tf.train", "text": "\nLists the checkpoint keys and shapes of variables in a checkpoint.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.train.load_checkpoint", "path": "train/load_checkpoint", "type": "tf.train", "text": "\nReturns `CheckpointReader` for checkpoint found in `ckpt_dir_or_file`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.train.load_variable", "path": "train/load_variable", "type": "tf.train", "text": "\nReturns the tensor value of the given variable in the checkpoint.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.train.SequenceExample", "path": "train/sequenceexample", "type": "tf.train", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.train.ServerDef", "path": "train/serverdef", "type": "tf.train", "text": "\nA ProtocolMessage\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.transpose", "path": "transpose", "type": "tf", "text": "\nTransposes `a`, where `a` is a Tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.truncatediv", "path": "truncatediv", "type": "tf", "text": "\nReturns x / y element-wise for integer types.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.truncatemod", "path": "truncatemod", "type": "tf", "text": "\nReturns element-wise remainder of division. This emulates C semantics in that\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.tuple", "path": "tuple", "type": "tf", "text": "\nGroup tensors together.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.types", "path": "types", "type": "tf", "text": "\nPublic TensorFlow type definitions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.types.experimental", "path": "types/experimental", "type": "tf", "text": "\nPublic API for tf.types.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.types.experimental.TensorLike", "path": "types/experimental/tensorlike", "type": "tf", "text": "\nThis symbol is a type alias.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.TypeSpec", "path": "typespec", "type": "tf", "text": "\nSpecifies a TensorFlow value type.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.type_spec_from_value", "path": "type_spec_from_value", "type": "tf", "text": "\nReturns a `tf.TypeSpec` that represents the given `value`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.UnconnectedGradients", "path": "unconnectedgradients", "type": "tf", "text": "\nControls how gradient computation behaves when y does not depend on x.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.unique", "path": "unique", "type": "tf", "text": "\nFinds unique elements in a 1-D tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.unique_with_counts", "path": "unique_with_counts", "type": "tf", "text": "\nFinds unique elements in a 1-D tensor.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.unravel_index", "path": "unravel_index", "type": "tf", "text": "\nConverts an array of flat indices into a tuple of coordinate arrays.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.unstack", "path": "unstack", "type": "tf", "text": "\nUnpacks the given dimension of a rank-`R` tensor into rank-`(R-1)` tensors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.Variable", "path": "variable", "type": "tf", "text": "\nSee the variable guide.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.Variable.SaveSliceInfo", "path": "variable/savesliceinfo", "type": "tf", "text": "\nInformation on how to save this Variable as a slice.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.VariableAggregation", "path": "variableaggregation", "type": "tf", "text": "\nIndicates how a distributed variable will be aggregated.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.VariableSynchronization", "path": "variablesynchronization", "type": "tf", "text": "\nIndicates when a distributed variable will be synced.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.variable_creator_scope", "path": "variable_creator_scope", "type": "tf", "text": "\nScope which defines a variable creation function to be used by variable().\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.vectorized_map", "path": "vectorized_map", "type": "tf", "text": "\nParallel map on the list of tensors unpacked from `elems` on dimension 0.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.version", "path": "version", "type": "tf.version", "text": "\nPublic API for tf.version namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.where", "path": "where", "type": "tf", "text": "\nReturn the elements where `condition` is `True` (multiplexing `x` and `y`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.while_loop", "path": "while_loop", "type": "tf", "text": "\nRepeat `body` while the condition `cond` is true. (deprecated argument values)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.xla", "path": "xla", "type": "tf.xla", "text": "\nPublic API for tf.xla namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.xla.experimental", "path": "xla/experimental", "type": "tf.xla", "text": "\nPublic API for tf.xla.experimental namespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.xla.experimental.compile", "path": "xla/experimental/compile", "type": "tf.xla", "text": "\nBuilds an operator that compiles and runs `computation` with XLA. (deprecated)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.xla.experimental.jit_scope", "path": "xla/experimental/jit_scope", "type": "tf.xla", "text": "\nEnable or disable JIT compilation of operators within the scope.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.zeros", "path": "zeros", "type": "tf", "text": "\nCreates a tensor with all elements set to zero.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.zeros_initializer", "path": "zeros_initializer", "type": "tf", "text": "\nInitializer that generates tensors initialized to 0.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "tf.zeros_like", "path": "zeros_like", "type": "tf", "text": "\nCreates a tensor with all elements set to zero.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}]