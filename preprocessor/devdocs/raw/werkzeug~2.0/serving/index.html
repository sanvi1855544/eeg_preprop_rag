<h1 id="serving-wsgi-applications">Serving WSGI Applications</h1> <p>There are many ways to serve a WSGI application. While you’re developing it, you usually don’t want to have a full-blown webserver like Apache up and running, but instead a simple standalone one. Because of that Werkzeug comes with a builtin development server.</p> <p>The easiest way is creating a small <code>start-myproject.py</code> file that runs the application using the builtin server:</p> <pre data-language="python">from werkzeug.serving import run_simple
from myproject import make_app

app = make_app(...)
run_simple('localhost', 8080, app, use_reloader=True)
</pre> <p>You can also pass it the <code>extra_files</code> keyword argument with a list of additional files (like configuration files) you want to observe.</p> <dl class="py function"> <dt class="sig sig-object py" id="werkzeug.serving.run_simple">
<code>werkzeug.serving.run_simple(hostname, port, application, use_reloader=False, use_debugger=False, use_evalex=True, extra_files=None, exclude_patterns=None, reloader_interval=1, reloader_type='auto', threaded=False, processes=1, request_handler=None, static_files=None, passthrough_errors=False, ssl_context=None)</code> </dt> <dd>
<p>Start a WSGI application. Optional features include a reloader, multithreading and fork support.</p> <p>This function has a command-line interface too:</p> <pre data-language="python">python -m werkzeug.serving --help
</pre> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.0: </span>Added <code>exclude_patterns</code> parameter.</p> </div> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.15: </span>Bind to a Unix socket by passing a path that starts with <code>unix://</code> as the <code>hostname</code>.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.10: </span>Improved the reloader and added support for changing the backend through the <code>reloader_type</code> parameter. See <a class="reference internal" href="#reloader"><span class="std std-ref">Reloader</span></a> for more information.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.9: </span>Added command-line interface.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.8: </span>Added support for automatically loading a SSL context from certificate file and private key.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.6: </span>support for SSL was added.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.5: </span><code>static_files</code> was added to simplify serving of static files as well as <code>passthrough_errors</code>.</p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>hostname</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a>) – The host to bind to, for example <code>'localhost'</code>. If the value is a path that starts with <code>unix://</code> it will bind to a Unix socket instead of a TCP socket..</li> <li>
<strong>port</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a>) – The port for the server. eg: <code>8080</code>
</li> <li>
<strong>application</strong> (<em>WSGIApplication</em>) – the WSGI application to execute</li> <li>
<strong>use_reloader</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – should the server automatically restart the python process if modules were changed?</li> <li>
<strong>use_debugger</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – should the werkzeug debugging system be used?</li> <li>
<strong>use_evalex</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – should the exception evaluation feature be enabled?</li> <li>
<strong>extra_files</strong> (<em>Optional</em><em>[</em><em>Iterable</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a><em>]</em><em>]</em>) – a list of files the reloader should watch additionally to the modules. For example configuration files.</li> <li>
<strong>exclude_patterns</strong> (<em>Optional</em><em>[</em><em>Iterable</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a><em>]</em><em>]</em>) – List of <a class="reference external" href="https://docs.python.org/3/library/fnmatch.html#module-fnmatch" title="(in Python v3.9)"><code>fnmatch</code></a> patterns to ignore when running the reloader. For example, ignore cache files that shouldn’t reload when updated.</li> <li>
<strong>reloader_interval</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a>) – the interval for the reloader in seconds.</li> <li>
<strong>reloader_type</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a>) – the type of reloader to use. The default is auto detection. Valid values are <code>'stat'</code> and <code>'watchdog'</code>. See <a class="reference internal" href="#reloader"><span class="std std-ref">Reloader</span></a> for more information.</li> <li>
<strong>threaded</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – should the process handle each request in a separate thread?</li> <li>
<strong>processes</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.9)">int</a>) – if greater than 1 then handle each request in a new process up to this maximum number of concurrent processes.</li> <li>
<strong>request_handler</strong> (<em>Optional</em><em>[</em><em>Type</em><em>[</em><em>werkzeug.serving.WSGIRequestHandler</em><em>]</em><em>]</em>) – optional parameter that can be used to replace the default one. You can use this to replace it with a different <code>BaseHTTPRequestHandler</code> subclass.</li> <li>
<strong>static_files</strong> (<em>Optional</em><em>[</em><em>Dict</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a><em>, </em><em>Union</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a><em>, </em><em>Tuple</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a><em>]</em><em>]</em><em>]</em><em>]</em>) – a list or dict of paths for static files. This works exactly like <code>SharedDataMiddleware</code>, it’s actually just wrapping the application in that middleware before serving.</li> <li>
<strong>passthrough_errors</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a>) – set this to <code>True</code> to disable the error catching. This means that the server will die on errors but it can be useful to hook debuggers in (pdb etc.)</li> <li>
<strong>ssl_context</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLContext" title="(in Python v3.9)">ssl.SSLContext</a><em>, </em><em>Tuple</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a><em>, </em><em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a><em>]</em><em>]</em><em>, </em><em>te.Literal</em><em>[</em><em>'adhoc'</em><em>]</em><em>]</em><em>]</em>) – an SSL context for the connection. Either an <a class="reference external" href="https://docs.python.org/3/library/ssl.html#ssl.SSLContext" title="(in Python v3.9)"><code>ssl.SSLContext</code></a>, a tuple in the form <code>(cert_file, pkey_file)</code>, the string <code>'adhoc'</code> if the server should automatically create one, or <code>None</code> to disable SSL (which is the default).</li> </ul> </dd> <dt class="field-even">Return type</dt> <dd class="field-even">
<p><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.9)">None</a></p> </dd> </dl> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="werkzeug.serving.is_running_from_reloader">
<code>werkzeug.serving.is_running_from_reloader()</code> </dt> <dd>
<p>Checks if the application is running from within the Werkzeug reloader subprocess.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.10.</span></p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Return type</dt> <dd class="field-odd">
<p><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.9)">bool</a></p> </dd> </dl> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="werkzeug.serving.make_ssl_devcert">
<code>werkzeug.serving.make_ssl_devcert(base_path, host=None, cn=None)</code> </dt> <dd>
<p>Creates an SSL key for development. This should be used instead of the <code>'adhoc'</code> key which generates a new cert on each server start. It accepts a path for where it should store the key and cert and either a host or CN. If a host is given it will use the CN <code>*.host/CN=host</code>.</p> <p>For more information see <a class="reference internal" href="#werkzeug.serving.run_simple" title="werkzeug.serving.run_simple"><code>run_simple()</code></a>.</p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.9.</span></p> </div> </details><dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>base_path</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a>) – the path to the certificate and key. The extension <code>.crt</code> is added for the certificate, <code>.key</code> is added for the key.</li> <li>
<strong>host</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a><em>]</em>) – the name of the host. This can be used as an alternative for the <code>cn</code>.</li> <li>
<strong>cn</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a><em>]</em>) – the <code>CN</code> to use.</li> </ul> </dd> <dt class="field-even">Return type</dt> <dd class="field-even">
<p>Tuple[<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a>, <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.9)">str</a>]</p> </dd> </dl> </dd>
</dl> <div class="admonition-information admonition"> <p class="admonition-title">Information</p> <p>The development server is not intended to be used on production systems. It was designed especially for development purposes and performs poorly under high load. For deployment setups have a look at the <a class="reference internal" href="../deployment/index"><span class="doc">Application Deployment</span></a> pages.</p> </div> <section id="reloader"> <h2 id="id1">Reloader</h2> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.10.</span></p> </div> </details><p>The Werkzeug reloader constantly monitors modules and paths of your web application, and restarts the server if any of the observed files change.</p> <p>Since version 0.10, there are two backends the reloader supports: <code>stat</code> and <code>watchdog</code>.</p> <ul class="simple"> <li>The default <code>stat</code> backend simply checks the <code>mtime</code> of all files in a regular interval. This is sufficient for most cases, however, it is known to drain a laptop’s battery.</li> <li>The <code>watchdog</code> backend uses filesystem events, and is much faster than <code>stat</code>. It requires the <a class="reference external" href="https://pypi.org/project/watchdog/">watchdog</a> module to be installed. The recommended way to achieve this is to add <code>Werkzeug[watchdog]</code> to your requirements file.</li> </ul> <p>If <code>watchdog</code> is installed and available it will automatically be used instead of the builtin <code>stat</code> reloader.</p> <p>To switch between the backends you can use the <code>reloader_type</code> parameter of the <a class="reference internal" href="#werkzeug.serving.run_simple" title="werkzeug.serving.run_simple"><code>run_simple()</code></a> function. <code>'stat'</code> sets it to the default stat based polling and <code>'watchdog'</code> forces it to the watchdog backend.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Some edge cases, like modules that failed to import correctly, are not handled by the stat reloader for performance reasons. The watchdog reloader monitors such files too.</p> </div> </section> <section id="colored-logging"> <h2>Colored Logging</h2> <p>The development server highlights the request logs in different colors based on the status code. On Windows, <a class="reference external" href="https://pypi.org/project/colorama/">Colorama</a> must be installed as well to enable this.</p> </section> <section id="virtual-hosts"> <h2>Virtual Hosts</h2> <p>Many web applications utilize multiple subdomains. This can be a bit tricky to simulate locally. Fortunately there is the <a class="reference external" href="https://en.wikipedia.org/wiki/Hosts_file">hosts file</a> that can be used to assign the local computer multiple names.</p> <p>This allows you to call your local computer <code>yourapplication.local</code> and <code>api.yourapplication.local</code> (or anything else) in addition to <code>localhost</code>.</p> <p>You can find the hosts file on the following location:</p>  <table class="docutils align-default">   <tr>
<td><p>Windows</p></td> <td><p><code>%SystemRoot%\system32\drivers\etc\hosts</code></p></td> </tr> <tr>
<td><p>Linux / OS X</p></td> <td><p><code>/etc/hosts</code></p></td> </tr>  </table>  <p>You can open the file with your favorite text editor and add a new name after <code>localhost</code>:</p> <pre data-language="python">127.0.0.1       localhost yourapplication.local api.yourapplication.local
</pre> <p>Save the changes and after a while you should be able to access the development server on these host names as well. You can use the <a class="reference internal" href="../routing/index"><span class="doc">URL Routing</span></a> system to dispatch between different hosts or parse <code>request.host</code> yourself.</p> </section> <section id="shutting-down-the-server"> <h2>Shutting Down The Server</h2> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.7.</span></p> </div> </details><p>Starting with Werkzeug 0.7 the development server provides a way to shut down the server after a request. This currently only works with Python 2.6 and later and will only work with the development server. To initiate the shutdown you have to call a function named <code>'werkzeug.server.shutdown'</code> in the WSGI environment:</p> <pre data-language="python">def shutdown_server(environ):
    if not 'werkzeug.server.shutdown' in environ:
        raise RuntimeError('Not running the development server')
    environ['werkzeug.server.shutdown']()
</pre> </section> <section id="troubleshooting"> <h2>Troubleshooting</h2> <p>On operating systems that support ipv6 and have it configured such as modern Linux systems, OS X 10.4 or higher as well as Windows Vista some browsers can be painfully slow if accessing your local server. The reason for this is that sometimes “localhost” is configured to be available on both ipv4 and ipv6 sockets and some browsers will try to access ipv6 first and then ipv4.</p> <p>At the current time the integrated webserver does not support ipv6 and ipv4 at the same time and for better portability ipv4 is the default.</p> <p>If you notice that the web browser takes ages to load the page there are two ways around this issue. If you don’t need ipv6 support you can disable the ipv6 entry in the <a class="reference external" href="https://en.wikipedia.org/wiki/Hosts_file">hosts file</a> by removing this line:</p> <pre data-language="python">::1             localhost
</pre> <p>Alternatively you can also disable ipv6 support in your browser. For example if Firefox shows this behavior you can disable it by going to <code>about:config</code> and disabling the <code>network.dns.disableIPv6</code> key. This however is not recommended as of Werkzeug 0.6.1!</p> <p>Starting with Werkzeug 0.6.1, the server will now switch between ipv4 and ipv6 based on your operating system’s configuration. This means if that you disabled ipv6 support in your browser but your operating system is preferring ipv6, you will be unable to connect to your server. In that situation, you can either remove the localhost entry for <code>::1</code> or explicitly bind the hostname to an ipv4 address (<code>127.0.0.1</code>)</p> </section> <section id="ssl"> <h2>SSL</h2> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 0.6.</span></p> </div> </details><p>The builtin server supports SSL for testing purposes. If an SSL context is provided it will be used. That means a server can either run in HTTP or HTTPS mode, but not both.</p> <section id="quickstart"> <h3>Quickstart</h3> <p>The easiest way to do SSL based development with Werkzeug is by using it to generate an SSL certificate and private key and storing that somewhere and to then put it there. For the certificate you need to provide the name of your server on generation or a <code>CN</code>.</p> <ol class="arabic"> <li>
<p>Generate an SSL key and store it somewhere:</p> <pre data-language="python">&gt;&gt;&gt; from werkzeug.serving import make_ssl_devcert
&gt;&gt;&gt; make_ssl_devcert('/path/to/the/key', host='localhost')
('/path/to/the/key.crt', '/path/to/the/key.key')
</pre> </li> <li>
<p>Now this tuple can be passed as <code>ssl_context</code> to the <a class="reference internal" href="#werkzeug.serving.run_simple" title="werkzeug.serving.run_simple"><code>run_simple()</code></a> method:</p> <pre data-language="python">run_simple('localhost', 4000, application,
           ssl_context=('/path/to/the/key.crt',
                        '/path/to/the/key.key'))
</pre> </li> </ol> <p>You will have to acknowledge the certificate in your browser once then.</p> </section> <section id="loading-contexts-by-hand"> <h3>Loading Contexts by Hand</h3> <p>You can use a <code>ssl.SSLContext</code> object instead of a tuple for full control over the TLS configuration.</p> <pre data-language="python">import ssl
ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
ctx.load_cert_chain('ssl.cert', 'ssl.key')
run_simple('localhost', 4000, application, ssl_context=ctx)
</pre> </section> <section id="generating-certificates"> <h3>Generating Certificates</h3> <p>A key and certificate can be created in advance using the openssl tool instead of the <a class="reference internal" href="#werkzeug.serving.make_ssl_devcert" title="werkzeug.serving.make_ssl_devcert"><code>make_ssl_devcert()</code></a>. This requires that you have the <code>openssl</code> command installed on your system:</p> <pre data-language="python">$ openssl genrsa 1024 &gt; ssl.key
$ openssl req -new -x509 -nodes -sha1 -days 365 -key ssl.key &gt; ssl.cert
</pre> </section> <section id="adhoc-certificates"> <h3>Adhoc Certificates</h3> <p>The easiest way to enable SSL is to start the server in adhoc-mode. In that case Werkzeug will generate an SSL certificate for you:</p> <pre data-language="python">run_simple('localhost', 4000, application,
           ssl_context='adhoc')
</pre> <p>The downside of this of course is that you will have to acknowledge the certificate each time the server is reloaded. Adhoc certificates are discouraged because modern browsers do a bad job at supporting them for security reasons.</p> <p>This feature requires the cryptography library to be installed.</p> </section> </section> <section id="unix-sockets"> <h2>Unix Sockets</h2> <p>The dev server can bind to a Unix socket instead of a TCP socket. <a class="reference internal" href="#werkzeug.serving.run_simple" title="werkzeug.serving.run_simple"><code>run_simple()</code></a> will bind to a Unix socket if the <code>hostname</code> parameter starts with <code>'unix://'</code>.</p> <pre data-language="python">from werkzeug.serving import run_simple
run_simple('unix://example.sock', 0, app)
</pre> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2007&ndash;2021 Pallets<br>Licensed under the BSD 3-clause License.<br>
    <a href="https://werkzeug.palletsprojects.com/en/2.0.x/serving/" class="_attribution-link">https://werkzeug.palletsprojects.com/en/2.0.x/serving/</a>
  </p>
</div>
