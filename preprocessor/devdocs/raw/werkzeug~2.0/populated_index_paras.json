[{"name": "abort()", "path": "exceptions/index#werkzeug.exceptions.abort", "type": "werkzeug.exceptions", "text": ["Raises an HTTPException for the given status code or WSGI application.", "If a status code is given, it will be looked up in the list of exceptions and will raise that exception. If passed a WSGI application, it will wrap it in a proxy WSGI exception and raise that:", "NoReturn"]}, {"name": "Aborter", "path": "exceptions/index#werkzeug.exceptions.Aborter", "type": "werkzeug.exceptions", "text": ["When passed a dict of code -> exception items it can be used as callable that raises exceptions. If the first argument to the callable is an integer it will be looked up in the mapping, if it\u2019s a WSGI application it will be raised in a proxy exception.", "The rest of the arguments are forwarded to the exception constructor.", "None"]}, {"name": "Accept", "path": "datastructures/index#werkzeug.datastructures.Accept", "type": "werkzeug.datastructures", "text": ["An Accept object is just a list subclass for lists of (value, quality) tuples. It is automatically sorted by specificity and quality.", "All Accept objects work similar to a list but provide extra functionality for working with the data. Containment checks are normalized to the rules of that header:", "To get the quality for an item you can use normal item lookup:", "Changed in version 1.0.0: Accept internal values are no longer ordered alphabetically for equal quality tags. Instead the initial order is preserved.", "Changed in version 0.5: Accept objects are forced immutable now.", "The best match as value.", "Returns the best match from a list of possible matches based on the specificity and quality of the client. If two items have the same quality and specificity, the one is returned that comes first.", "Get the position of an entry or return -1.", "key \u2013 The key to be looked up.", "Get the position of an entry or raise ValueError.", "key \u2013 The key to be looked up.", "Changed in version 0.5: This used to raise IndexError, which was inconsistent with the list API.", "Returns the quality of the key.", "New in version 0.6: In previous versions you had to use the item-lookup syntax (eg: obj[key] instead of obj.quality(key))", "Convert the header set into an HTTP header string.", "Iterate over all values."]}, {"name": "Accept.best_match()", "path": "datastructures/index#werkzeug.datastructures.Accept.best_match", "type": "werkzeug.datastructures", "text": ["Returns the best match from a list of possible matches based on the specificity and quality of the client. If two items have the same quality and specificity, the one is returned that comes first."]}, {"name": "Accept.find()", "path": "datastructures/index#werkzeug.datastructures.Accept.find", "type": "werkzeug.datastructures", "text": ["Get the position of an entry or return -1.", "key \u2013 The key to be looked up."]}, {"name": "Accept.index()", "path": "datastructures/index#werkzeug.datastructures.Accept.index", "type": "werkzeug.datastructures", "text": ["Get the position of an entry or raise ValueError.", "key \u2013 The key to be looked up.", "Changed in version 0.5: This used to raise IndexError, which was inconsistent with the list API."]}, {"name": "Accept.quality()", "path": "datastructures/index#werkzeug.datastructures.Accept.quality", "type": "werkzeug.datastructures", "text": ["Returns the quality of the key.", "New in version 0.6: In previous versions you had to use the item-lookup syntax (eg: obj[key] instead of obj.quality(key))"]}, {"name": "Accept.to_header()", "path": "datastructures/index#werkzeug.datastructures.Accept.to_header", "type": "werkzeug.datastructures", "text": ["Convert the header set into an HTTP header string."]}, {"name": "Accept.values()", "path": "datastructures/index#werkzeug.datastructures.Accept.values", "type": "werkzeug.datastructures", "text": ["Iterate over all values."]}, {"name": "AnyConverter", "path": "routing/index#werkzeug.routing.AnyConverter", "type": "werkzeug.routing", "text": ["Matches one of the items provided. Items can either be Python identifiers or strings:", "None"]}, {"name": "API Levels", "path": "levels/index", "type": "Other", "text": ["Werkzeug is intended to be a utility rather than a framework. Because of that the user-friendly API is separated from the lower-level API so that Werkzeug can easily be used to extend another system.", "All the functionality the Request and Response objects (aka the \u201cwrappers\u201d) provide is also available in small utility functions.", "This example implements a small Hello World application that greets the user with the name entered.", "Alternatively the same application could be used without request and response objects but by taking advantage of the parsing functions werkzeug provides:", "Usually you want to use the high-level layer (the request and response objects). But there are situations where this might not be what you want.", "For example you might be maintaining code for an application written in Django or another framework and you have to parse HTTP headers. You can utilize Werkzeug for that by accessing the lower-level HTTP header parsing functions.", "Another situation where the low level parsing functions can be useful are custom WSGI frameworks, unit-testing or modernizing an old CGI/mod_python application to WSGI as well as WSGI middlewares where you want to keep the overhead low."]}, {"name": "append_slash_redirect()", "path": "utils/index#werkzeug.utils.append_slash_redirect", "type": "werkzeug.utils", "text": ["Redirects to the same URL but with a slash appended. The behavior of this function is undefined if the path ends with a slash already.", "Response"]}, {"name": "Application Deployment", "path": "deployment/index", "type": "Other", "text": ["This section covers running your application in production on a web server such as Apache or lighttpd."]}, {"name": "Application Dispatcher", "path": "middleware/dispatcher/index", "type": "Other", "text": ["This middleware creates a single WSGI application that dispatches to multiple other WSGI applications mounted at different URL paths.", "A common example is writing a Single Page Application, where you have a backend API and a frontend written in JavaScript that does the routing in the browser rather than requesting different pages from the server. The frontend is a single HTML and JS file that should be served for any path besides \u201c/api\u201d.", "This example dispatches to an API app under \u201c/api\u201d, an admin app under \u201c/admin\u201d, and an app that serves frontend files for all other requests:", "In production, you might instead handle this at the HTTP server level, serving files or proxying to application servers based on location. The API and admin apps would each be deployed with a separate WSGI server, and the static files would be served directly by the HTTP server.", "Combine multiple applications as a single WSGI application. Requests are dispatched to an application based on the path it is mounted under.", "None"]}, {"name": "Application Profiler", "path": "middleware/profiler/index", "type": "Other", "text": ["This module provides a middleware that profiles each request with the cProfile module. This can help identify bottlenecks in your code that may be slowing down your application.", "Wrap a WSGI application and profile the execution of each request. Responses are buffered so that timings are more exact.", "If stream is given, pstats.Stats are written to it after each request. If profile_dir is given, cProfile data files are saved to that directory, one file per request.", "The filename can be customized by passing filename_format. If it is a string, it will be formatted using str.format() with the following fields available:", "If it is a callable, it will be called with the WSGI environ dict and should return a filename.", "None", "Changed in version 0.15: Stats are written even if profile_dir is given, and can be disable by passing stream=None.", "New in version 0.15: Added filename_format.", "New in version 0.9: Added restrictions and profile_dir."]}, {"name": "Authorization", "path": "datastructures/index#werkzeug.datastructures.Authorization", "type": "werkzeug.datastructures", "text": ["Represents an Authorization header sent by the client.", "This is returned by parse_authorization_header(). It can be useful to create the object manually to pass to the test Client.", "Changed in version 0.5: This object became immutable.", "If the server sent a qop-header in the WWW-Authenticate header, the client has to provide this value for HTTP digest auth. See the RFC for more details.", "The nonce count value transmitted by clients if a qop-header is also transmitted. HTTP digest auth only.", "The nonce the server sent for digest auth, sent back by the client. A nonce should be unique for every 401 response for HTTP digest auth.", "The opaque header from the server returned unchanged by the client. It is recommended that this string be base64 or hexadecimal data. Digest auth only.", "When the authentication type is basic this is the password transmitted by the client, else None.", "Indicates what \u201cquality of protection\u201d the client has applied to the message for HTTP digest auth. Note that this is a single token, not a quoted list of alternatives as in WWW-Authenticate.", "This is the server realm sent back for HTTP digest auth.", "A string of 32 hex digits computed as defined in RFC 2617, which proves that the user knows a password. Digest auth only.", "Convert to a string value for an Authorization header.", "New in version 2.0: Added to support passing authorization to the test client.", "The URI from Request-URI of the Request-Line; duplicated because proxies are allowed to change the Request-Line in transit. HTTP digest auth only.", "The username transmitted. This is set for both basic and digest auth all the time."]}, {"name": "Authorization.to_header()", "path": "datastructures/index#werkzeug.datastructures.Authorization.to_header", "type": "werkzeug.datastructures", "text": ["Convert to a string value for an Authorization header.", "New in version 2.0: Added to support passing authorization to the test client."]}, {"name": "BaseURL", "path": "urls/index#werkzeug.urls.BaseURL", "type": "werkzeug.urls", "text": ["Superclass of URL and BytesURL.", "Create new instance of _URLTuple(scheme, netloc, path, query, fragment)", "Works exactly like host but will return a result that is restricted to ASCII. If it finds a netloc that is not ASCII it will attempt to idna decode it. This is useful for socket operations when the URL might include internationalized characters.", "The authentication part in the URL if available, None otherwise.", "Decodes the netloc part into a string.", "str", "Decodes the query part of the URL. Ths is a shortcut for calling url_decode() on the query argument. The arguments and keyword arguments are forwarded to url_decode() unchanged.", "ds.MultiDict[str, str]", "Encodes the netloc part to an ASCII safe URL as bytes.", "str", "Returns a tuple with the location of the file in the form (server, location). If the netloc is empty in the URL or points to localhost, it\u2019s represented as None.", "The pathformat by default is autodetection but needs to be set when working with URLs of a specific system. The supported values are 'windows' when working with Windows or DOS paths and 'posix' when working with posix paths.", "If the URL does not point to a local file, the server and location are both represented as None.", "pathformat (Optional[str]) \u2013 The expected format of the path component. Currently 'windows' and 'posix' are supported. Defaults to None which is autodetect.", "Tuple[Optional[str], Optional[str]]", "The host part of the URL if available, otherwise None. The host is either the hostname or the IP address mentioned in the URL. It will not contain the port.", "Joins this URL with another one. This is just a convenience function for calling into url_join() and then parsing the return value again.", "werkzeug.urls.BaseURL", "The password if it was part of the URL, None otherwise. This undergoes URL decoding and will always be a string.", "The port in the URL as an integer if it was present, None otherwise. This does not fill in default ports.", "The password if it was part of the URL, None otherwise. Unlike password this one is not being decoded.", "The username if it was part of the URL, None otherwise. Unlike username this one is not being decoded.", "Return an URL with the same values, except for those parameters given new values by whichever keyword arguments are specified.", "kwargs (Any) \u2013 ", "werkzeug.urls.BaseURL", "Returns a URL tuple that holds a IRI. This will try to decode as much information as possible in the URL without losing information similar to how a web browser does it for the URL bar.", "It\u2019s usually more interesting to directly call uri_to_iri() which will return a string.", "werkzeug.urls.BaseURL", "Returns a BytesURL tuple that holds a URI. This will encode all the information in the URL properly to ASCII using the rules a web browser would follow.", "It\u2019s usually more interesting to directly call iri_to_uri() which will return a string.", "werkzeug.urls.BaseURL", "Returns a URL string or bytes depending on the type of the information stored. This is just a convenience function for calling url_unparse() for this URL.", "str", "The username if it was part of the URL, None otherwise. This undergoes URL decoding and will always be a string."]}, {"name": "BaseURL.decode_netloc()", "path": "urls/index#werkzeug.urls.BaseURL.decode_netloc", "type": "werkzeug.urls", "text": ["Decodes the netloc part into a string.", "str"]}, {"name": "BaseURL.decode_query()", "path": "urls/index#werkzeug.urls.BaseURL.decode_query", "type": "werkzeug.urls", "text": ["Decodes the query part of the URL. Ths is a shortcut for calling url_decode() on the query argument. The arguments and keyword arguments are forwarded to url_decode() unchanged.", "ds.MultiDict[str, str]"]}, {"name": "BaseURL.encode_netloc()", "path": "urls/index#werkzeug.urls.BaseURL.encode_netloc", "type": "werkzeug.urls", "text": ["Encodes the netloc part to an ASCII safe URL as bytes.", "str"]}, {"name": "BaseURL.get_file_location()", "path": "urls/index#werkzeug.urls.BaseURL.get_file_location", "type": "werkzeug.urls", "text": ["Returns a tuple with the location of the file in the form (server, location). If the netloc is empty in the URL or points to localhost, it\u2019s represented as None.", "The pathformat by default is autodetection but needs to be set when working with URLs of a specific system. The supported values are 'windows' when working with Windows or DOS paths and 'posix' when working with posix paths.", "If the URL does not point to a local file, the server and location are both represented as None.", "pathformat (Optional[str]) \u2013 The expected format of the path component. Currently 'windows' and 'posix' are supported. Defaults to None which is autodetect.", "Tuple[Optional[str], Optional[str]]"]}, {"name": "BaseURL.join()", "path": "urls/index#werkzeug.urls.BaseURL.join", "type": "werkzeug.urls", "text": ["Joins this URL with another one. This is just a convenience function for calling into url_join() and then parsing the return value again.", "werkzeug.urls.BaseURL"]}, {"name": "BaseURL.replace()", "path": "urls/index#werkzeug.urls.BaseURL.replace", "type": "werkzeug.urls", "text": ["Return an URL with the same values, except for those parameters given new values by whichever keyword arguments are specified.", "kwargs (Any) \u2013 ", "werkzeug.urls.BaseURL"]}, {"name": "BaseURL.to_iri_tuple()", "path": "urls/index#werkzeug.urls.BaseURL.to_iri_tuple", "type": "werkzeug.urls", "text": ["Returns a URL tuple that holds a IRI. This will try to decode as much information as possible in the URL without losing information similar to how a web browser does it for the URL bar.", "It\u2019s usually more interesting to directly call uri_to_iri() which will return a string.", "werkzeug.urls.BaseURL"]}, {"name": "BaseURL.to_uri_tuple()", "path": "urls/index#werkzeug.urls.BaseURL.to_uri_tuple", "type": "werkzeug.urls", "text": ["Returns a BytesURL tuple that holds a URI. This will encode all the information in the URL properly to ASCII using the rules a web browser would follow.", "It\u2019s usually more interesting to directly call iri_to_uri() which will return a string.", "werkzeug.urls.BaseURL"]}, {"name": "BaseURL.to_url()", "path": "urls/index#werkzeug.urls.BaseURL.to_url", "type": "werkzeug.urls", "text": ["Returns a URL string or bytes depending on the type of the information stored. This is just a convenience function for calling url_unparse() for this URL.", "str"]}, {"name": "Basic HTTP Proxy", "path": "middleware/http_proxy/index", "type": "Other", "text": ["Proxy requests under a path to an external server, routing other requests to the app.", "This middleware can only proxy HTTP requests, as HTTP is the only protocol handled by the WSGI server. Other protocols, such as WebSocket requests, cannot be proxied at this layer. This should only be used for development, in production a real proxy server should be used.", "The middleware takes a dict mapping a path prefix to a dict describing the host to be proxied to:", "Each host has the following options:", "The target URL to dispatch to. This is required.", "Whether to remove the prefix from the URL before dispatching it to the target. The default is False.", "The host header is automatically rewritten to the URL of the target.", "The host header is unmodified from the client request.", "The host header is overwritten with the value.", "A dictionary of headers to be sent with the request to the target. The default is {}.", "A ssl.SSLContext defining how to verify requests if the target is HTTPS. The default is None.", "In the example above, everything under \"/static/\" is proxied to the server on port 5001. The host header is rewritten to the target, and the \"/static/\" prefix is removed from the URLs.", "None", "New in version 0.14."]}, {"name": "bind_arguments()", "path": "utils/index#werkzeug.utils.bind_arguments", "type": "werkzeug.utils", "text": ["Bind the arguments provided into a dict. When passed a function, a tuple of arguments and a dict of keyword arguments bind_arguments returns a dict of names as the function would see it. This can be useful to implement a cache decorator that uses the function arguments to build the cache key based on the values of the arguments.", "a dict of bound keyword arguments.", "Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use Signature.bind() instead."]}, {"name": "BrokenFilesystemWarning", "path": "filesystem/index#werkzeug.filesystem.BrokenFilesystemWarning", "type": "werkzeug.filesystem", "text": ["The warning used by Werkzeug to signal a broken filesystem. Will only be used once per runtime."]}, {"name": "BSD-3-Clause License", "path": "license/index", "type": "Other", "text": ["Copyright 2007 Pallets", "Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:", "THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u201cAS IS\u201d AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE."]}, {"name": "BytesURL", "path": "urls/index#werkzeug.urls.BytesURL", "type": "werkzeug.urls", "text": ["Represents a parsed URL in bytes.", "Create new instance of _URLTuple(scheme, netloc, path, query, fragment)", "Decodes the URL to a tuple made out of strings. The charset is only being used for the path, query and fragment.", "werkzeug.urls.URL", "Returns the netloc unchanged as bytes.", "bytes"]}, {"name": "BytesURL.decode()", "path": "urls/index#werkzeug.urls.BytesURL.decode", "type": "werkzeug.urls", "text": ["Decodes the URL to a tuple made out of strings. The charset is only being used for the path, query and fragment.", "werkzeug.urls.URL"]}, {"name": "BytesURL.encode_netloc()", "path": "urls/index#werkzeug.urls.BytesURL.encode_netloc", "type": "werkzeug.urls", "text": ["Returns the netloc unchanged as bytes.", "bytes"]}, {"name": "cached_property", "path": "utils/index#werkzeug.utils.cached_property", "type": "werkzeug.utils", "text": ["A property() that is only evaluated once. Subsequent access returns the cached value. Setting the property sets the cached value. Deleting the property clears the cached value, accessing it again will evaluate it again.", "The class must have a __dict__ for this to work.", "Changed in version 2.0: del obj.name clears the cached value.", "None"]}, {"name": "CGI", "path": "deployment/cgi/index", "type": "Other", "text": ["If all other deployment methods do not work, CGI will work for sure. CGI is supported by all major servers but usually has a less-than-optimal performance.", "This is also the way you can use a Werkzeug application on Google\u2019s AppEngine, there however the execution does happen in a CGI-like environment. The application\u2019s performance is unaffected because of that.", "First you need to create the CGI application file. Let\u2019s call it yourapplication.cgi:", "Usually there are two ways to configure the server. Either just copy the .cgi into a cgi-bin (and use mod_rewrite or something similar to rewrite the URL) or let the server point to the file directly.", "In Apache for example you can put something like this into the config:", "For more information consult the documentation of your webserver."]}, {"name": "CharsetAccept", "path": "datastructures/index#werkzeug.datastructures.CharsetAccept", "type": "werkzeug.datastructures", "text": ["Like Accept but with normalization for charsets."]}, {"name": "check_password_hash()", "path": "utils/index#werkzeug.security.check_password_hash", "type": "werkzeug.security", "text": ["Check a password against a given salted and hashed password value. In order to support unsalted legacy passwords this method supports plain text passwords, md5 and sha1 hashes (both salted and unsalted).", "Returns True if the password matched, False otherwise.", "bool"]}, {"name": "Client", "path": "test/index#werkzeug.test.Client", "type": "werkzeug.test", "text": ["This class allows you to send requests to a wrapped application.", "The use_cookies parameter indicates whether cookies should be stored and sent for subsequent requests. This is True by default, but passing False will disable this behaviour.", "If you want to request some subdomain of your application you may set allow_subdomain_redirects to True as if not no external redirects are allowed.", "Changed in version 2.0: response_wrapper is always a subclass of :class:TestResponse.", "Changed in version 0.5: Added the use_cookies parameter.", "None", "Sets a cookie in the client\u2019s cookie jar. The server name is required and has to match the one that is also passed to the open call.", "None", "Deletes a cookie in the test client.", "None", "Generate an environ dict from the given arguments, make a request to the application using it, and return the response.", "werkzeug.test.TestResponse", "Changed in version 2.0: as_tuple is deprecated and will be removed in Werkzeug 2.1. Use TestResponse.request and request.environ instead.", "Changed in version 2.0: The request input stream is closed when calling response.close(). Input streams for redirects are automatically closed.", "Changed in version 0.5: If a dict is provided as file in the dict for the data parameter the content type has to be called content_type instead of mimetype. This change was made for consistency with werkzeug.FileWrapper.", "Changed in version 0.5: Added the follow_redirects parameter.", "Call open() with method set to GET.", "werkzeug.test.TestResponse", "Call open() with method set to POST.", "werkzeug.test.TestResponse", "Call open() with method set to PUT.", "werkzeug.test.TestResponse", "Call open() with method set to DELETE.", "werkzeug.test.TestResponse", "Call open() with method set to PATCH.", "werkzeug.test.TestResponse", "Call open() with method set to OPTIONS.", "werkzeug.test.TestResponse", "Call open() with method set to HEAD.", "werkzeug.test.TestResponse", "Call open() with method set to TRACE.", "werkzeug.test.TestResponse"]}, {"name": "Client.delete()", "path": "test/index#werkzeug.test.Client.delete", "type": "werkzeug.test", "text": ["Call open() with method set to DELETE.", "werkzeug.test.TestResponse"]}, {"name": "Client.delete_cookie()", "path": "test/index#werkzeug.test.Client.delete_cookie", "type": "werkzeug.test", "text": ["Deletes a cookie in the test client.", "None"]}, {"name": "Client.get()", "path": "test/index#werkzeug.test.Client.get", "type": "werkzeug.test", "text": ["Call open() with method set to GET.", "werkzeug.test.TestResponse"]}, {"name": "Client.head()", "path": "test/index#werkzeug.test.Client.head", "type": "werkzeug.test", "text": ["Call open() with method set to HEAD.", "werkzeug.test.TestResponse"]}, {"name": "Client.open()", "path": "test/index#werkzeug.test.Client.open", "type": "werkzeug.test", "text": ["Generate an environ dict from the given arguments, make a request to the application using it, and return the response.", "werkzeug.test.TestResponse", "Changed in version 2.0: as_tuple is deprecated and will be removed in Werkzeug 2.1. Use TestResponse.request and request.environ instead.", "Changed in version 2.0: The request input stream is closed when calling response.close(). Input streams for redirects are automatically closed.", "Changed in version 0.5: If a dict is provided as file in the dict for the data parameter the content type has to be called content_type instead of mimetype. This change was made for consistency with werkzeug.FileWrapper.", "Changed in version 0.5: Added the follow_redirects parameter."]}, {"name": "Client.options()", "path": "test/index#werkzeug.test.Client.options", "type": "werkzeug.test", "text": ["Call open() with method set to OPTIONS.", "werkzeug.test.TestResponse"]}, {"name": "Client.patch()", "path": "test/index#werkzeug.test.Client.patch", "type": "werkzeug.test", "text": ["Call open() with method set to PATCH.", "werkzeug.test.TestResponse"]}, {"name": "Client.post()", "path": "test/index#werkzeug.test.Client.post", "type": "werkzeug.test", "text": ["Call open() with method set to POST.", "werkzeug.test.TestResponse"]}, {"name": "Client.put()", "path": "test/index#werkzeug.test.Client.put", "type": "werkzeug.test", "text": ["Call open() with method set to PUT.", "werkzeug.test.TestResponse"]}, {"name": "Client.set_cookie()", "path": "test/index#werkzeug.test.Client.set_cookie", "type": "werkzeug.test", "text": ["Sets a cookie in the client\u2019s cookie jar. The server name is required and has to match the one that is also passed to the open call.", "None"]}, {"name": "Client.trace()", "path": "test/index#werkzeug.test.Client.trace", "type": "werkzeug.test", "text": ["Call open() with method set to TRACE.", "werkzeug.test.TestResponse"]}, {"name": "ClosingIterator", "path": "wsgi/index#werkzeug.wsgi.ClosingIterator", "type": "werkzeug.wsgi", "text": ["The WSGI specification requires that all middlewares and gateways respect the close callback of the iterable returned by the application. Because it is useful to add another close action to a returned iterable and adding a custom iterable is a boring task this class can be used for that:", "If there is just one close function it can be passed instead of the list.", "A closing iterator is not needed if the application uses response objects and finishes the processing if the response is started:", "None"]}, {"name": "CombinedMultiDict", "path": "datastructures/index#werkzeug.datastructures.CombinedMultiDict", "type": "werkzeug.datastructures", "text": ["A read only MultiDict that you can pass multiple MultiDict instances as sequence and it will combine the return values of all wrapped dicts:", "This works for all read operations and will raise a TypeError for methods that usually change data which isn\u2019t possible.", "From Werkzeug 0.3 onwards, the KeyError raised by this class is also a subclass of the BadRequest HTTP exception and will render a page for a 400 BAD REQUEST if caught in a catch-all for HTTP exceptions."]}, {"name": "ContentRange", "path": "datastructures/index#werkzeug.datastructures.ContentRange", "type": "werkzeug.datastructures", "text": ["Represents the content range header.", "New in version 0.7.", "The length of the range or None.", "Simple method to update the ranges.", "The start point of the range or None.", "The stop point of the range (non-inclusive) or None. Can only be None if also start is None.", "The units to use, usually \u201cbytes\u201d", "Sets the units to None which indicates that the header should no longer be used."]}, {"name": "ContentRange.set()", "path": "datastructures/index#werkzeug.datastructures.ContentRange.set", "type": "werkzeug.datastructures", "text": ["Simple method to update the ranges."]}, {"name": "ContentRange.unset()", "path": "datastructures/index#werkzeug.datastructures.ContentRange.unset", "type": "werkzeug.datastructures", "text": ["Sets the units to None which indicates that the header should no longer be used."]}, {"name": "Context Locals", "path": "local/index", "type": "Other", "text": ["Sooner or later you have some things you want to have in every single view or helper function or whatever. In PHP the way to go are global variables. However, that isn\u2019t possible in WSGI applications without a major drawback: As soon as you operate on the global namespace your application isn\u2019t thread-safe any longer.", "The Python standard library has a concept called \u201cthread locals\u201d (or thread-local data). A thread local is a global object in which you can put stuff in and get back later in a thread-safe and thread-specific way. That means that whenever you set or get a value on a thread local object, the thread local object checks in which thread you are and retrieves the value corresponding to your thread (if one exists). So, you won\u2019t accidentally get another thread\u2019s data.", "This approach, however, has a few disadvantages. For example, besides threads, there are other types of concurrency in Python. A very popular one is greenlets. Also, whether every request gets its own thread is not guaranteed in WSGI. It could be that a request is reusing a thread from a previous request, and hence data is left over in the thread local object.", "Werkzeug provides its own implementation of local data storage called werkzeug.local. This approach provides a similar functionality to thread locals but also works with greenlets.", "Here\u2019s a simple example of how one could use werkzeug.local:", "This binds the request to local.request. Every other piece of code executed after this assignment in the same context can safely access local.request and will get the same request object. The make_middleware method on the local manager ensures that all references to the local objects are cleared up after the request.", "The same context means the same greenlet (if you\u2019re using greenlets) in the same thread and same process.", "If a request object is not yet set on the local object and you try to access it, you will get an AttributeError. You can use getattr to avoid that:", "This will try to get the request or return None if the request is not (yet?) available.", "Note that local objects cannot manage themselves, for that you need a local manager. You can pass a local manager multiple locals or add additionals later by appending them to manager.locals and every time the manager cleans up it will clean up all the data left in the locals for this context.", "Releases the contents of the local for the current context. This makes it possible to use locals without a manager.", "Example:", "With this function one can release Local objects as well as LocalStack objects. However it is not possible to release data held by proxies that way, one always has to retain a reference to the underlying local object in order to be able to release it.", "New in version 0.6.1.", "local (Union[werkzeug.local.Local, werkzeug.local.LocalStack]) \u2013 ", "None", "Local objects cannot manage themselves. For that you need a local manager. You can pass a local manager multiple locals or add them later y appending them to manager.locals. Every time the manager cleans up, it will clean up all the data left in the locals for this context.", "Changed in version 2.0: ident_func is deprecated and will be removed in Werkzeug 2.1.", "Changed in version 0.7: The ident_func parameter was added.", "Changed in version 0.6.1: The release_local() function can be used instead of a manager.", "None", "Manually clean up the data in the locals for this context. Call this at the end of the request or use make_middleware().", "None", "Return the context identifier the local objects use internally for this context. You cannot override this method to change the behavior but use it to link other context local objects (such as SQLAlchemy\u2019s scoped sessions) to the Werkzeug locals.", "Deprecated since version 2.0: Will be removed in Werkzeug 2.1.", "Changed in version 0.7: You can pass a different ident function to the local manager that will then be propagated to all the locals passed to the constructor.", "int", "Wrap a WSGI application so that cleaning up happens after request end.", "app (WSGIApplication) \u2013 ", "WSGIApplication", "Like make_middleware but for decorating functions.", "Example usage:", "The difference to make_middleware is that the function passed will have all the arguments copied from the inner application (name, docstring, module).", "func (WSGIApplication) \u2013 ", "WSGIApplication", "This class works similar to a Local but keeps a stack of objects instead. This is best explained with an example:", "They can be force released by using a LocalManager or with the release_local() function but the correct way is to pop the item from the stack after using. When the stack is empty it will no longer be bound to the current context (and as such released).", "By calling the stack without arguments it returns a proxy that resolves to the topmost item on the stack.", "New in version 0.6.1.", "None", "Removes the topmost item from the stack, will return the old value or None if the stack was already empty.", "Any", "Pushes a new item to the stack", "obj (Any) \u2013 ", "List[Any]", "The topmost item on the stack. If the stack is empty, None is returned.", "A proxy to the object bound to a Local. All operations on the proxy are forwarded to the bound object. If no object is bound, a RuntimeError is raised.", "__repr__ and __class__ are forwarded, so repr(x) and isinstance(x, cls) will look like the proxied object. Use issubclass(type(x), LocalProxy) to check if an object is a proxy.", "Changed in version 2.0: Updated proxied attributes and methods to reflect the current data model.", "Changed in version 0.6.1: The class can be instantiated with a callable.", "Return the current object. This is useful if you want the real object behind the proxy at a time for performance reasons or because you want to pass the object into a different context.", "Any"]}, {"name": "cookie_date()", "path": "http/index#werkzeug.http.cookie_date", "type": "werkzeug.http", "text": ["Format a datetime object or timestamp into an RFC 2822 date string for Set-Cookie expires.", "Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use http_date() instead.", "expires (Optional[Union[datetime.datetime, datetime.date, int, float, time.struct_time]]) \u2013 ", "str"]}, {"name": "create_environ()", "path": "test/index#werkzeug.test.create_environ", "type": "werkzeug.test", "text": ["Create a new WSGI environ dict based on the values passed. The first parameter should be the path of the request which defaults to \u2018/\u2019. The second one can either be an absolute path (in that case the host is localhost:80) or a full path to the request with scheme, netloc port and the path to the script.", "This accepts the same arguments as the EnvironBuilder constructor.", "Changed in version 0.5: This function is now a thin wrapper over EnvironBuilder which was added in 0.5. The headers, environ_base, environ_overrides and charset parameters were added.", "WSGIEnvironment"]}, {"name": "Data Structures", "path": "datastructures/index", "type": "Other", "text": ["Werkzeug provides some subclasses of common Python objects to extend them with additional features. Some of them are used to make them immutable, others are used to change some semantics to better work with HTTP.", "Changed in version 0.6: The general purpose classes are now pickleable in each protocol as long as the contained objects are pickleable. This means that the FileMultiDict won\u2019t be pickleable as soon as it contains a file.", "Works like a regular dict but the get() method can perform type conversions. MultiDict and CombinedMultiDict are subclasses of this class and provide the same feature.", "New in version 0.5.", "Return the default value if the requested data doesn\u2019t exist. If type is provided and is a callable it should convert the value, return it or raise a ValueError if that is not possible. In this case the function will return the default as if the value was not found:", "Works like a TypeConversionDict but does not support modifications.", "New in version 0.5.", "Return a shallow mutable copy of this object. Keep in mind that the standard library\u2019s copy() function is a no-op for this class like for any other python immutable type (eg: tuple).", "A MultiDict is a dictionary subclass customized to deal with multiple values for the same key which is for example used by the parsing functions in the wrappers. This is necessary because some HTML form elements pass multiple values for the same key.", "MultiDict implements all standard dictionary methods. Internally, it saves all values for a key as a list, but the standard dict access methods will only return the first value for a key. If you want to gain access to the other values, too, you have to use the list methods as explained below.", "Basic Usage:", "It behaves like a normal dict thus all dict functions will only return the first value when multiple values for one key are found.", "From Werkzeug 0.3 onwards, the KeyError raised by this class is also a subclass of the BadRequest HTTP exception and will render a page for a 400 BAD REQUEST if caught in a catch-all for HTTP exceptions.", "A MultiDict can be constructed from an iterable of (key, value) tuples, a dict, a MultiDict or from Werkzeug 0.2 onwards some keyword parameters.", "mapping \u2013 the initial value for the MultiDict. Either a regular dict, an iterable of (key, value) tuples or None.", "Adds a new value for the key.", "New in version 0.6.", "Return a shallow copy of this object.", "Return a deep copy of this object.", "Create a new dictionary with keys from iterable and values set to value.", "Return the default value if the requested data doesn\u2019t exist. If type is provided and is a callable it should convert the value, return it or raise a ValueError if that is not possible. In this case the function will return the default as if the value was not found:", "Return the list of items for a given key. If that key is not in the MultiDict, the return value will be an empty list. Just like get, getlist accepts a type parameter. All items will be converted with the callable defined there.", "a list of all the values for the key.", "Return an iterator of (key, value) pairs.", "multi \u2013 If set to True the iterator returned will have a pair for each value of each key. Otherwise it will only contain pairs for the first value of each key.", "Return a iterator of (key, values) pairs, where values is the list of all values associated with the key.", "Return an iterator of all values associated with a key. Zipping keys() and this is the same as calling lists():", "Pop the first item for a list on the dict. Afterwards the key is removed from the dict, so additional values are discarded:", "Pop an item from the dict.", "Pop a (key, list) tuple from the dict.", "Pop the list for a key from the dict. If the key is not in the dict an empty list is returned.", "Changed in version 0.5: If the key does no longer exist a list is returned instead of raising an error.", "Returns the value for the key if it is in the dict, otherwise it returns default and sets that value for key.", "Remove the old values for a key and add new ones. Note that the list you pass the values in will be shallow-copied before it is inserted in the dictionary.", "Like setdefault but sets multiple values. The list returned is not a copy, but the list that is actually used internally. This means that you can put new values into the dict by appending items to the list:", "a list", "Return the contents as regular dict. If flat is True the returned dict will only have the first item present, if flat is False all values will be returned as lists.", "flat \u2013 If set to False the dict returned will have lists with all the values in it. Otherwise it will only contain the first value for each key.", "a dict", "update() extends rather than replaces existing key lists:", "If the value list for a key in other_dict is empty, no new values will be added to the dict and the key will not be created:", "Returns an iterator of the first value on every key\u2019s value list.", "Works like a regular MultiDict but preserves the order of the fields. To convert the ordered multi dict into a list you can use the items() method and pass it multi=True.", "In general an OrderedMultiDict is an order of magnitude slower than a MultiDict.", "note", "Due to a limitation in Python you cannot convert an ordered multi dict into a regular dict by using dict(multidict). Instead you have to use the to_dict() method, otherwise the internal bucket objects are exposed.", "An immutable MultiDict.", "New in version 0.5.", "Return a shallow mutable copy of this object. Keep in mind that the standard library\u2019s copy() function is a no-op for this class like for any other python immutable type (eg: tuple).", "An immutable OrderedMultiDict.", "New in version 0.6.", "Return a shallow mutable copy of this object. Keep in mind that the standard library\u2019s copy() function is a no-op for this class like for any other python immutable type (eg: tuple).", "A read only MultiDict that you can pass multiple MultiDict instances as sequence and it will combine the return values of all wrapped dicts:", "This works for all read operations and will raise a TypeError for methods that usually change data which isn\u2019t possible.", "From Werkzeug 0.3 onwards, the KeyError raised by this class is also a subclass of the BadRequest HTTP exception and will render a page for a 400 BAD REQUEST if caught in a catch-all for HTTP exceptions.", "An immutable dict.", "New in version 0.5.", "Return a shallow mutable copy of this object. Keep in mind that the standard library\u2019s copy() function is a no-op for this class like for any other python immutable type (eg: tuple).", "An immutable list.", "New in version 0.5.", "A special MultiDict that has convenience methods to add files to it. This is used for EnvironBuilder and generally useful for unittesting.", "New in version 0.5.", "Adds a new file to the dict. file can be a file name or a file-like or a FileStorage object.", "An object that stores some headers. It has a dict-like interface, but is ordered, can store the same key multiple times, and iterating yields (key, value) pairs instead of only keys.", "This data structure is useful if you want a nicer way to handle WSGI headers which are stored as tuples in a list.", "From Werkzeug 0.3 onwards, the KeyError raised by this class is also a subclass of the BadRequest HTTP exception and will render a page for a 400 BAD REQUEST if caught in a catch-all for HTTP exceptions.", "Headers is mostly compatible with the Python wsgiref.headers.Headers class, with the exception of __getitem__. wsgiref will return None for headers['missing'], whereas Headers will raise a KeyError.", "To create a new Headers object pass it a list or dict of headers which are used as default values. This does not reuse the list passed to the constructor for internal usage.", "defaults \u2013 The list of default values for the Headers.", "Changed in version 0.9: This data structure now stores unicode values similar to how the multi dicts do it. The main difference is that bytes can be set as well which will automatically be latin1 decoded.", "Changed in version 0.9: The linked() function was removed without replacement as it was an API that does not support the changes to the encoding model.", "Add a new header tuple to the list.", "Keyword arguments can specify additional parameters for the header value, with underscores converted to dashes:", "The keyword argument dumping uses dump_options_header() behind the scenes.", "New in version 0.4.1: keyword arguments were added for wsgiref compatibility.", "Add a new header tuple to the list.", "An alias for add() for compatibility with the wsgiref add_header() method.", "Clears all headers.", "Extend headers in this object with items from another object containing header items as well as keyword arguments.", "To replace existing keys instead of extending, use update() instead.", "If provided, the first argument can be another Headers object, a MultiDict, dict, or iterable of pairs.", "Changed in version 1.0: Support MultiDict. Allow passing kwargs.", "Return the default value if the requested data doesn\u2019t exist. If type is provided and is a callable it should convert the value, return it or raise a ValueError if that is not possible. In this case the function will return the default as if the value was not found:", "New in version 0.9: Added support for as_bytes.", "Return a list of all the values for the named field.", "This method is compatible with the wsgiref get_all() method.", "Return the list of items for a given key. If that key is not in the Headers, the return value will be an empty list. Just like get(), getlist() accepts a type parameter. All items will be converted with the callable defined there.", "New in version 0.9: Added support for as_bytes.", "a list of all the values for the key.", "Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use key in data instead.", "Removes and returns a key or index.", "key \u2013 The key to be popped. If this is an integer the item at that position is removed, if it\u2019s a string the value for that key is. If the key is omitted or None the last item is removed.", "an item.", "Removes a key or index and returns a (key, value) item.", "Remove a key.", "key \u2013 The key to be removed.", "Remove all header tuples for key and add a new one. The newly added key either appears at the end of the list if there was no entry or replaces the first one.", "Keyword arguments can specify additional parameters for the header value, with underscores converted to dashes. See add() for more information.", "Changed in version 0.6.1: set() now accepts the same arguments as add().", "Return the first value for the key if it is in the headers, otherwise set the header to the value given by default and return that.", "Remove any existing values for a header and add new ones.", "New in version 1.0.", "Return the list of values for the key if it is in the headers, otherwise set the header to the list of values given by default and return that.", "Unlike MultiDict.setlistdefault(), modifying the returned list will not affect the headers.", "New in version 1.0.", "Convert the headers into a list suitable for WSGI.", "list", "Replace headers in this object with items from another headers object and keyword arguments.", "To extend existing keys instead of replacing, use extend() instead.", "If provided, the first argument can be another Headers object, a MultiDict, dict, or iterable of pairs.", "New in version 1.0.", "Read only version of the headers from a WSGI environment. This provides the same interface as Headers and is constructed from a WSGI environment.", "From Werkzeug 0.3 onwards, the KeyError raised by this class is also a subclass of the BadRequest HTTP exception and will render a page for a 400 BAD REQUEST if caught in a catch-all for HTTP exceptions.", "Similar to the ETags class this implements a set-like structure. Unlike ETags this is case insensitive and used for vary, allow, and content-language headers.", "If not constructed using the parse_set_header() function the instantiation works like this:", "Add a new header to the set.", "Return the set as real python set type. When calling this, all the items are converted to lowercase and the ordering is lost.", "preserve_casing \u2013 if set to True the items in the set returned will have the original case like in the HeaderSet, otherwise they will be lowercase.", "Clear the set.", "Like remove() but ignores errors.", "header \u2013 the header to be discarded.", "Return the index of the header in the set or return -1 if not found.", "header \u2013 the header to be looked up.", "Return the index of the header in the set or raise an IndexError.", "header \u2013 the header to be looked up.", "Remove a header from the set. This raises an KeyError if the header is not in the set.", "Changed in version 0.5: In older versions a IndexError was raised instead of a KeyError if the object was missing.", "header \u2013 the header to be removed.", "Convert the header set into an HTTP header string.", "Add all the headers from the iterable to the set.", "iterable \u2013 updates the set with the items from the iterable.", "An Accept object is just a list subclass for lists of (value, quality) tuples. It is automatically sorted by specificity and quality.", "All Accept objects work similar to a list but provide extra functionality for working with the data. Containment checks are normalized to the rules of that header:", "To get the quality for an item you can use normal item lookup:", "Changed in version 1.0.0: Accept internal values are no longer ordered alphabetically for equal quality tags. Instead the initial order is preserved.", "Changed in version 0.5: Accept objects are forced immutable now.", "The best match as value.", "Returns the best match from a list of possible matches based on the specificity and quality of the client. If two items have the same quality and specificity, the one is returned that comes first.", "Get the position of an entry or return -1.", "key \u2013 The key to be looked up.", "Get the position of an entry or raise ValueError.", "key \u2013 The key to be looked up.", "Changed in version 0.5: This used to raise IndexError, which was inconsistent with the list API.", "Returns the quality of the key.", "New in version 0.6: In previous versions you had to use the item-lookup syntax (eg: obj[key] instead of obj.quality(key))", "Convert the header set into an HTTP header string.", "Iterate over all values.", "Like Accept but with special methods and behavior for mimetypes.", "True if this object accepts HTML.", "True if this object accepts JSON.", "True if this object accepts XHTML.", "Like Accept but with normalization for charsets.", "Like Accept but with normalization for language tags.", "A cache control for requests. This is immutable and gives access to all the request-relevant cache control headers.", "To get a header of the RequestCacheControl object again you can convert the object into a string or call the to_header() method. If you plan to subclass it and add your own items have a look at the sourcecode for that class.", "New in version 0.5: In previous versions a CacheControl class existed that was used both for request and response.", "accessor for \u2018no-cache\u2019", "accessor for \u2018no-store\u2019", "accessor for \u2018max-age\u2019", "accessor for \u2018no-transform\u2019", "accessor for \u2018max-stale\u2019", "accessor for \u2018min-fresh\u2019", "accessor for \u2018only-if-cached\u2019", "A cache control for responses. Unlike RequestCacheControl this is mutable and gives access to response-relevant cache control headers.", "To get a header of the ResponseCacheControl object again you can convert the object into a string or call the to_header() method. If you plan to subclass it and add your own items have a look at the sourcecode for that class.", "New in version 0.5: In previous versions a CacheControl class existed that was used both for request and response.", "accessor for \u2018no-cache\u2019", "accessor for \u2018no-store\u2019", "accessor for \u2018max-age\u2019", "accessor for \u2018no-transform\u2019", "accessor for \u2018immutable\u2019", "accessor for \u2018must-revalidate\u2019", "accessor for \u2018private\u2019", "accessor for \u2018proxy-revalidate\u2019", "accessor for \u2018public\u2019", "accessor for \u2018s-maxage\u2019", "A set that can be used to check if one etag is present in a collection of etags.", "Convert the ETags object into a python set. Per default all the weak etags are not part of this set.", "Check if an etag is part of the set ignoring weak tags. It is also possible to use the in operator.", "When passed a quoted tag it will check if this tag is part of the set. If the tag is weak it is checked against weak and strong tags, otherwise strong only.", "Check if an etag is part of the set including weak and strong tags.", "Check if an etag is strong.", "Check if an etag is weak.", "Convert the etags set into a HTTP header string.", "Represents an Authorization header sent by the client.", "This is returned by parse_authorization_header(). It can be useful to create the object manually to pass to the test Client.", "Changed in version 0.5: This object became immutable.", "If the server sent a qop-header in the WWW-Authenticate header, the client has to provide this value for HTTP digest auth. See the RFC for more details.", "The nonce count value transmitted by clients if a qop-header is also transmitted. HTTP digest auth only.", "The nonce the server sent for digest auth, sent back by the client. A nonce should be unique for every 401 response for HTTP digest auth.", "The opaque header from the server returned unchanged by the client. It is recommended that this string be base64 or hexadecimal data. Digest auth only.", "When the authentication type is basic this is the password transmitted by the client, else None.", "Indicates what \u201cquality of protection\u201d the client has applied to the message for HTTP digest auth. Note that this is a single token, not a quoted list of alternatives as in WWW-Authenticate.", "This is the server realm sent back for HTTP digest auth.", "A string of 32 hex digits computed as defined in RFC 2617, which proves that the user knows a password. Digest auth only.", "Convert to a string value for an Authorization header.", "New in version 2.0: Added to support passing authorization to the test client.", "The URI from Request-URI of the Request-Line; duplicated because proxies are allowed to change the Request-Line in transit. HTTP digest auth only.", "The username transmitted. This is set for both basic and digest auth all the time.", "Provides simple access to WWW-Authenticate headers.", "A string indicating a pair of algorithms used to produce the digest and a checksum. If this is not present it is assumed to be \u201cMD5\u201d. If the algorithm is not understood, the challenge should be ignored (and a different one used, if there is more than one).", "A static helper function for Authentication subclasses to add extra authentication system properties onto a class:", "For more information have a look at the sourcecode to see how the regular properties (realm etc.) are implemented.", "A list of URIs that define the protection space. If a URI is an absolute path, it is relative to the canonical root URL of the server being accessed.", "A server-specified data string which should be uniquely generated each time a 401 response is made. It is recommended that this string be base64 or hexadecimal data.", "A string of data, specified by the server, which should be returned by the client unchanged in the Authorization header of subsequent requests with URIs in the same protection space. It is recommended that this string be base64 or hexadecimal data.", "A set of quality-of-privacy directives such as auth and auth-int.", "A string to be displayed to users so they know which username and password to use. This string should contain at least the name of the host performing the authentication and might additionally indicate the collection of users who might have access.", "Clear the auth info and enable basic auth.", "Clear the auth info and enable digest auth.", "A flag, indicating that the previous request from the client was rejected because the nonce value was stale.", "Convert the stored values into a WWW-Authenticate header.", "The type of the auth mechanism. HTTP currently specifies Basic and Digest.", "Very simple object that represents the If-Range header in parsed form. It will either have neither a etag or date or one of either but never both.", "New in version 0.7.", "The date in parsed format or None.", "The etag parsed and unquoted. Ranges always operate on strong etags so the weakness information is not necessary.", "Converts the object back into an HTTP header.", "Represents a Range header. All methods only support only bytes as the unit. Stores a list of ranges if given, but the methods only work if only one range is provided.", "ValueError \u2013 If the ranges provided are invalid.", "Changed in version 0.15: The ranges passed in are validated.", "New in version 0.7.", "Creates a ContentRange object from the current range and given content length.", "If the range is for bytes, the length is not None and there is exactly one range and it is satisfiable it returns a (start, stop) tuple, otherwise None.", "A list of (begin, end) tuples for the range header provided. The ranges are non-inclusive.", "Converts the object into Content-Range HTTP header, based on given length", "Converts the object back into an HTTP header.", "The units of this range. Usually \u201cbytes\u201d.", "Represents the content range header.", "New in version 0.7.", "The length of the range or None.", "Simple method to update the ranges.", "The start point of the range or None.", "The stop point of the range (non-inclusive) or None. Can only be None if also start is None.", "The units to use, usually \u201cbytes\u201d", "Sets the units to None which indicates that the header should no longer be used.", "The FileStorage class is a thin wrapper over incoming files. It is used by the request object to represent uploaded files. All the attributes of the wrapper stream are proxied by the file storage so it\u2019s possible to do storage.read() instead of the long form storage.stream.read().", "The input stream for the uploaded file. This usually points to an open temporary file.", "The filename of the file on the client.", "The name of the form field.", "The multipart headers as Headers object. This usually contains irrelevant information but in combination with custom multipart requests the raw headers might be interesting.", "New in version 0.6.", "Close the underlying file if possible.", "The content-length sent in the header. Usually not available", "The content-type sent in the header. Usually not available", "Like content_type, but without parameters (eg, without charset, type etc.) and always lowercase. For example if the content type is text/HTML; charset=utf-8 the mimetype would be 'text/html'.", "New in version 0.7.", "The mimetype parameters as dict. For example if the content type is text/html; charset=utf-8 the params would be {'charset': 'utf-8'}.", "New in version 0.7.", "Save the file to a destination path or file object. If the destination is a file object you have to close it yourself after the call. The buffer size is the number of bytes held in memory during the copy process. It defaults to 16KB.", "For secure file saving also have a look at secure_filename().", "Changed in version 1.0: Supports pathlib."]}, {"name": "Dealing with Request Data", "path": "request_data/index", "type": "Other", "text": ["The most important rule about web development is \u201cDo not trust the user\u201d. This is especially true for incoming request data on the input stream. With WSGI this is actually a bit harder than you would expect. Because of that Werkzeug wraps the request stream for you to save you from the most prominent problems with it.", "The input stream has no end-of-file marker. If you would call the read() method on the wsgi.input stream you would cause your application to hang on conforming servers. This is actually intentional however painful. Werkzeug solves that problem by wrapping the input stream in a special LimitedStream. The input stream is exposed on the request objects as stream. This one is either an empty stream (if the form data was parsed) or a limited stream with the contents of the input stream.", "Werkzeug parses the incoming data under the following situations:", "These calls are not interchangeable. If you invoke parse_form_data() you must not use the request object or at least not the attributes that trigger the parsing process.", "This is also true if you read from the wsgi.input stream before the parsing.", "General rule: Leave the WSGI input stream alone. Especially in WSGI middlewares. Use either the parsing functions or the request object. Do not mix multiple WSGI utility libraries for form data parsing or anything else that works on the input stream.", "The standard Werkzeug parsing behavior handles three cases:", "Special note on the get_data method: Calling this loads the full request data into memory. This is only safe to do if the max_content_length is set. Also you can either read the stream or call get_data().", "To avoid being the victim of a DDOS attack you can set the maximum accepted content length and request field sizes. The Request class has two attributes for that: max_content_length and max_form_memory_size.", "The first one can be used to limit the total content length. For example by setting it to 1024 * 1024 * 16 the request won\u2019t accept more than 16MB of transmitted data.", "Because certain data can\u2019t be moved to the hard disk (regular post data) whereas temporary files can, there is a second limit you can set. The max_form_memory_size limits the size of POST transmitted form data. By setting it to 1024 * 1024 * 2 you can make sure that all in memory-stored fields are not more than 2MB in size.", "This however does not affect in-memory stored files if the stream_factory used returns a in-memory file.", "Modern web applications transmit a lot more than multipart form data or url encoded data. To extend the capabilities, subclass Request or Request and add or extend methods."]}, {"name": "DebuggedApplication", "path": "debug/index#werkzeug.debug.DebuggedApplication", "type": "werkzeug.debug", "text": ["Enables debugging support for a given application:", "The evalex keyword argument allows evaluating expressions in a traceback\u2019s frame context.", "None"]}, {"name": "Debugging Applications", "path": "debug/index", "type": "Other", "text": ["Depending on the WSGI gateway/server, exceptions are handled differently. Most of the time, exceptions go to stderr or the error log, and a generic \u201c500 Internal Server Error\u201d message is displayed.", "Since this is not the best debugging environment, Werkzeug provides a WSGI middleware that renders nice tracebacks, optionally with an interactive debug console to execute code in any frame.", "Danger", "The debugger allows the execution of arbitrary code which makes it a major security risk. The debugger must never be used on production machines. We cannot stress this enough. Do not enable the debugger in production.", "Note", "The interactive debugger does not work in forking environments, such as a server that starts multiple processes. Most such environments are production servers, where the debugger should not be enabled anyway.", "Enable the debugger by wrapping the application with the DebuggedApplication middleware. Alternatively, you can pass use_debugger=True to run_simple() and it will do that for you.", "Enables debugging support for a given application:", "The evalex keyword argument allows evaluating expressions in a traceback\u2019s frame context.", "None", "Once enabled and an error happens during a request you will see a detailed traceback instead of a generic \u201cinternal server error\u201d. The traceback is still output to the terminal as well.", "The error message is displayed at the top. Clicking it jumps to the bottom of the traceback. Frames that represent user code, as opposed to built-ins or installed packages, are highlighted blue. Clicking a frame will show more lines for context, clicking again will hide them.", "If you have the evalex feature enabled you can get a console for every frame in the traceback by hovering over a frame and clicking the console icon that appears at the right. Once clicked a console opens where you can execute Python code in:", "Inside the interactive consoles you can execute any kind of Python code. Unlike regular Python consoles the output of the object reprs is colored and stripped to a reasonable size by default. If the output is longer than what the console decides to display a small plus sign is added to the repr and a click will expand the repr.", "To display all variables that are defined in the current frame you can use the dump() function. You can call it without arguments to get a detailed list of all variables and their values, or with an object as argument to get a detailed list of all the attributes it has.", "Starting with Werkzeug 0.11 the debug console is protected by a PIN. This is a security helper to make it less likely for the debugger to be exploited if you forget to disable it when deploying to production. The PIN based authentication is enabled by default.", "The first time a console is opened, a dialog will prompt for a PIN that is printed to the command line. The PIN is generated in a stable way that is specific to the project. An explicit PIN can be provided through the environment variable WERKZEUG_DEBUG_PIN. This can be set to a number and will become the PIN. This variable can also be set to the value off to disable the PIN check entirely.", "If an incorrect PIN is entered too many times the server needs to be restarted.", "This feature is not meant to entirely secure the debugger. It is intended to make it harder for an attacker to exploit the debugger. Never enable the debugger in production.", "If you click on the \u201cTraceback (most recent call last)\u201d header, the view switches to a traditional text-based traceback. You can copy and paste this in order to provide information when asking a question or reporting an issue."]}, {"name": "DispatcherMiddleware", "path": "middleware/dispatcher/index#werkzeug.middleware.dispatcher.DispatcherMiddleware", "type": "werkzeug.middleware.dispatcher", "text": ["Combine multiple applications as a single WSGI application. Requests are dispatched to an application based on the path it is mounted under.", "None"]}, {"name": "dump_cookie()", "path": "http/index#werkzeug.http.dump_cookie", "type": "werkzeug.http", "text": ["Create a Set-Cookie header without the Set-Cookie prefix.", "The return value is usually restricted to ascii as the vast majority of values are properly escaped, but that is no guarantee. It\u2019s tunneled through latin1 as required by PEP 3333.", "The return value is not ASCII safe if the key contains unicode characters. This is technically against the specification but happens in the wild. It\u2019s strongly recommended to not use non-ASCII values for the keys.", "str", "Changed in version 1.0.0: The string 'None' is accepted for samesite."]}, {"name": "dump_header()", "path": "http/index#werkzeug.http.dump_header", "type": "werkzeug.http", "text": ["Dump an HTTP header again. This is the reversal of parse_list_header(), parse_set_header() and parse_dict_header(). This also quotes strings that include an equals sign unless you pass it as dict of key, value pairs.", "str"]}, {"name": "EndpointPrefix", "path": "routing/index#werkzeug.routing.EndpointPrefix", "type": "werkzeug.routing", "text": ["Prefixes all endpoints (which must be strings for this factory) with another string. This can be useful for sub applications:", "None"]}, {"name": "EnvironBuilder", "path": "test/index#werkzeug.test.EnvironBuilder", "type": "werkzeug.test", "text": ["This class can be used to conveniently create a WSGI environment for testing purposes. It can be used to quickly create WSGI environments or request objects from arbitrary data.", "The signature of this class is also used in some other places as of Werkzeug 0.5 (create_environ(), Response.from_values(), Client.open()). Because of this most of the functionality is available through the constructor alone.", "Files and regular form data can be manipulated independently of each other with the form and files attributes, but are passed with the same argument to the constructor: data.", "data can be any of these values:", "a dict or MultiDict: The keys have to be strings. The values have to be either any of the following objects, or a list of any of the following objects:", "None", "Changed in version 2.0: REQUEST_URI and RAW_URI is the full raw URI including the query string, not only the path.", "Changed in version 2.0: The default request_class is Request instead of BaseRequest.", "New in version 2.0: Added the auth parameter.", "New in version 0.15: The json param and json_dumps() method.", "New in version 0.15: The environ has keys REQUEST_URI and RAW_URI containing the path before perecent-decoding. This is not part of the WSGI PEP, but many WSGI servers include it.", "Changed in version 0.6: path and base_url can now be unicode strings that are encoded with iri_to_uri().", "the server protocol to use. defaults to HTTP/1.1", "the wsgi version to use. defaults to (1, 0)", "alias of werkzeug.wrappers.request.Request", "The serialization function used when json is passed.", "Turn an environ dict back into a builder. Any extra kwargs override the args extracted from the environ.", "Changed in version 2.0: Path and query values are passed through the WSGI decoding dance to avoid double encoding.", "New in version 0.15.", "EnvironBuilder", "The base URL is used to extract the URL scheme, host name, port, and root path.", "The content type for the request. Reflected from and to the headers. Do not set if you set files or form for auto detection.", "The mimetype (content type without charset etc.)", "New in version 0.14.", "The mimetype parameters as dict. For example if the content type is text/html; charset=utf-8 the params would be {'charset': 'utf-8'}.", "New in version 0.14.", "The content length as integer. Reflected from and to the headers. Do not set if you set files or form for auto detection.", "A MultiDict of form values.", "A FileMultiDict of uploaded files. Use add_file() to add new files.", "An optional input stream. This is mutually exclusive with setting form and files, setting it will clear those. Do not provide this if the method is not POST or another method that has a body.", "The query string. If you set this to a string args will no longer be available.", "The URL arguments as MultiDict.", "The server name (read-only, use host to set)", "The server port as integer (read-only, use host to set)", "Closes all files. If you put real file objects into the files dict you can call this method to automatically close them all in one go.", "None", "Return the built environ.", "Changed in version 0.15: The content type and length headers are set based on input stream detection. Previously this only set the WSGI keys.", "WSGIEnvironment", "Returns a request with the data. If the request class is not specified request_class is used.", "cls (Optional[Type[werkzeug.wrappers.request.Request]]) \u2013 The request wrapper to use.", "werkzeug.wrappers.request.Request"]}, {"name": "EnvironBuilder.close()", "path": "test/index#werkzeug.test.EnvironBuilder.close", "type": "werkzeug.test", "text": ["Closes all files. If you put real file objects into the files dict you can call this method to automatically close them all in one go.", "None"]}, {"name": "EnvironBuilder.from_environ()", "path": "test/index#werkzeug.test.EnvironBuilder.from_environ", "type": "werkzeug.test", "text": ["Turn an environ dict back into a builder. Any extra kwargs override the args extracted from the environ.", "Changed in version 2.0: Path and query values are passed through the WSGI decoding dance to avoid double encoding.", "New in version 0.15.", "EnvironBuilder"]}, {"name": "EnvironBuilder.get_environ()", "path": "test/index#werkzeug.test.EnvironBuilder.get_environ", "type": "werkzeug.test", "text": ["Return the built environ.", "Changed in version 0.15: The content type and length headers are set based on input stream detection. Previously this only set the WSGI keys.", "WSGIEnvironment"]}, {"name": "EnvironBuilder.get_request()", "path": "test/index#werkzeug.test.EnvironBuilder.get_request", "type": "werkzeug.test", "text": ["Returns a request with the data. If the request class is not specified request_class is used.", "cls (Optional[Type[werkzeug.wrappers.request.Request]]) \u2013 The request wrapper to use.", "werkzeug.wrappers.request.Request"]}, {"name": "EnvironBuilder.json_dumps()", "path": "test/index#werkzeug.test.EnvironBuilder.json_dumps", "type": "werkzeug.test", "text": ["The serialization function used when json is passed."]}, {"name": "EnvironBuilder.request_class", "path": "test/index#werkzeug.test.EnvironBuilder.request_class", "type": "werkzeug.test", "text": ["alias of werkzeug.wrappers.request.Request"]}, {"name": "EnvironBuilder.server_protocol", "path": "test/index#werkzeug.test.EnvironBuilder.server_protocol", "type": "werkzeug.test", "text": ["the server protocol to use. defaults to HTTP/1.1"]}, {"name": "EnvironBuilder.wsgi_version", "path": "test/index#werkzeug.test.EnvironBuilder.wsgi_version", "type": "werkzeug.test", "text": ["the wsgi version to use. defaults to (1, 0)"]}, {"name": "EnvironHeaders", "path": "datastructures/index#werkzeug.datastructures.EnvironHeaders", "type": "werkzeug.datastructures", "text": ["Read only version of the headers from a WSGI environment. This provides the same interface as Headers and is constructed from a WSGI environment.", "From Werkzeug 0.3 onwards, the KeyError raised by this class is also a subclass of the BadRequest HTTP exception and will render a page for a 400 BAD REQUEST if caught in a catch-all for HTTP exceptions."]}, {"name": "environ_property", "path": "utils/index#werkzeug.utils.environ_property", "type": "werkzeug.utils", "text": ["Maps request attributes to environment variables. This works not only for the Werkzeug request object, but also any other class with an environ attribute:", "If you pass it a second value it\u2019s used as default if the key does not exist, the third one can be a converter that takes a value and converts it. If it raises ValueError or TypeError the default value is used. If no default value is provided None is used.", "Per default the property is read only. You have to explicitly enable it by passing read_only=False to the constructor."]}, {"name": "escape()", "path": "utils/index#werkzeug.utils.escape", "type": "werkzeug.utils", "text": ["Replace &, <, >, \", and ' with HTML-safe sequences.", "None is escaped to an empty string.", "Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use MarkupSafe instead.", "s (Any) \u2013 ", "str"]}, {"name": "ETags", "path": "datastructures/index#werkzeug.datastructures.ETags", "type": "werkzeug.datastructures", "text": ["A set that can be used to check if one etag is present in a collection of etags.", "Convert the ETags object into a python set. Per default all the weak etags are not part of this set.", "Check if an etag is part of the set ignoring weak tags. It is also possible to use the in operator.", "When passed a quoted tag it will check if this tag is part of the set. If the tag is weak it is checked against weak and strong tags, otherwise strong only.", "Check if an etag is part of the set including weak and strong tags.", "Check if an etag is strong.", "Check if an etag is weak.", "Convert the etags set into a HTTP header string."]}, {"name": "ETags.as_set()", "path": "datastructures/index#werkzeug.datastructures.ETags.as_set", "type": "werkzeug.datastructures", "text": ["Convert the ETags object into a python set. Per default all the weak etags are not part of this set."]}, {"name": "ETags.contains()", "path": "datastructures/index#werkzeug.datastructures.ETags.contains", "type": "werkzeug.datastructures", "text": ["Check if an etag is part of the set ignoring weak tags. It is also possible to use the in operator."]}, {"name": "ETags.contains_raw()", "path": "datastructures/index#werkzeug.datastructures.ETags.contains_raw", "type": "werkzeug.datastructures", "text": ["When passed a quoted tag it will check if this tag is part of the set. If the tag is weak it is checked against weak and strong tags, otherwise strong only."]}, {"name": "ETags.contains_weak()", "path": "datastructures/index#werkzeug.datastructures.ETags.contains_weak", "type": "werkzeug.datastructures", "text": ["Check if an etag is part of the set including weak and strong tags."]}, {"name": "ETags.is_strong()", "path": "datastructures/index#werkzeug.datastructures.ETags.is_strong", "type": "werkzeug.datastructures", "text": ["Check if an etag is strong."]}, {"name": "ETags.is_weak()", "path": "datastructures/index#werkzeug.datastructures.ETags.is_weak", "type": "werkzeug.datastructures", "text": ["Check if an etag is weak."]}, {"name": "ETags.to_header()", "path": "datastructures/index#werkzeug.datastructures.ETags.to_header", "type": "werkzeug.datastructures", "text": ["Convert the etags set into a HTTP header string."]}, {"name": "extract_path_info()", "path": "wsgi/index#werkzeug.wsgi.extract_path_info", "type": "werkzeug.wsgi", "text": ["Extracts the path info from the given URL (or WSGI environment) and path. The path info returned is a string. The URLs might also be IRIs.", "If the path info could not be determined, None is returned.", "Some examples:", "Instead of providing a base URL you can also pass a WSGI environment.", "Optional[str]", "Changed in version 0.15: The errors parameter defaults to leaving invalid bytes quoted instead of replacing them.", "New in version 0.6."]}, {"name": "FastCGI", "path": "deployment/fastcgi/index", "type": "Other", "text": ["A very popular deployment setup on servers like lighttpd and nginx is FastCGI. To use your WSGI application with any of them you will need a FastCGI server first.", "The most popular one is flup which we will use for this guide. Make sure to have it installed.", "First you need to create the FastCGI server file. Let\u2019s call it yourapplication.fcgi:", "This is enough for Apache to work, however ngingx and older versions of lighttpd need a socket to be explicitly passed to communicate with the FastCGI server. For that to work you need to pass the path to the socket to the WSGIServer:", "The path has to be the exact same path you define in the server config.", "Save the yourapplication.fcgi file somewhere you will find it again. It makes sense to have that in /var/www/yourapplication or something similar.", "Make sure to set the executable bit on that file so that the servers can execute it:", "A basic FastCGI configuration for lighttpd looks like this:", "Remember to enable the FastCGI, alias and rewrite modules. This configuration binds the application to /yourapplication.", "See the Lighty docs for more information on FastCGI and Python.", "Installing FastCGI applications on nginx is a bit tricky because by default some FastCGI parameters are not properly forwarded.", "A basic FastCGI configuration for nginx looks like this:", "This configuration binds the application to /yourapplication. If you want to have it in the URL root it\u2019s a bit easier because you don\u2019t have to figure out how to calculate PATH_INFO and SCRIPT_NAME:", "Since Nginx doesn\u2019t load FastCGI apps, you have to do it by yourself. You can either write an init.d script for that or execute it inside a screen session:", "FastCGI deployments tend to be hard to debug on most webservers. Very often the only thing the server log tells you is something along the lines of \u201cpremature end of headers\u201d. In order to debug the application the only thing that can really give you ideas why it breaks is switching to the correct user and executing the application by hand.", "This example assumes your application is called application.fcgi and that your webserver user is www-data:", "In this case the error seems to be \u201cyourapplication\u201d not being on the python path. Common problems are:"]}, {"name": "FileMultiDict", "path": "datastructures/index#werkzeug.datastructures.FileMultiDict", "type": "werkzeug.datastructures", "text": ["A special MultiDict that has convenience methods to add files to it. This is used for EnvironBuilder and generally useful for unittesting.", "New in version 0.5.", "Adds a new file to the dict. file can be a file name or a file-like or a FileStorage object."]}, {"name": "FileMultiDict.add_file()", "path": "datastructures/index#werkzeug.datastructures.FileMultiDict.add_file", "type": "werkzeug.datastructures", "text": ["Adds a new file to the dict. file can be a file name or a file-like or a FileStorage object."]}, {"name": "FileStorage", "path": "datastructures/index#werkzeug.datastructures.FileStorage", "type": "werkzeug.datastructures", "text": ["The FileStorage class is a thin wrapper over incoming files. It is used by the request object to represent uploaded files. All the attributes of the wrapper stream are proxied by the file storage so it\u2019s possible to do storage.read() instead of the long form storage.stream.read().", "The input stream for the uploaded file. This usually points to an open temporary file.", "The filename of the file on the client.", "The name of the form field.", "The multipart headers as Headers object. This usually contains irrelevant information but in combination with custom multipart requests the raw headers might be interesting.", "New in version 0.6.", "Close the underlying file if possible.", "The content-length sent in the header. Usually not available", "The content-type sent in the header. Usually not available", "Like content_type, but without parameters (eg, without charset, type etc.) and always lowercase. For example if the content type is text/HTML; charset=utf-8 the mimetype would be 'text/html'.", "New in version 0.7.", "The mimetype parameters as dict. For example if the content type is text/html; charset=utf-8 the params would be {'charset': 'utf-8'}.", "New in version 0.7.", "Save the file to a destination path or file object. If the destination is a file object you have to close it yourself after the call. The buffer size is the number of bytes held in memory during the copy process. It defaults to 16KB.", "For secure file saving also have a look at secure_filename().", "Changed in version 1.0: Supports pathlib."]}, {"name": "FileStorage.close()", "path": "datastructures/index#werkzeug.datastructures.FileStorage.close", "type": "werkzeug.datastructures", "text": ["Close the underlying file if possible."]}, {"name": "FileStorage.filename", "path": "datastructures/index#werkzeug.datastructures.FileStorage.filename", "type": "werkzeug.datastructures", "text": ["The filename of the file on the client."]}, {"name": "FileStorage.headers", "path": "datastructures/index#werkzeug.datastructures.FileStorage.headers", "type": "werkzeug.datastructures", "text": ["The multipart headers as Headers object. This usually contains irrelevant information but in combination with custom multipart requests the raw headers might be interesting.", "New in version 0.6."]}, {"name": "FileStorage.name", "path": "datastructures/index#werkzeug.datastructures.FileStorage.name", "type": "werkzeug.datastructures", "text": ["The name of the form field."]}, {"name": "FileStorage.save()", "path": "datastructures/index#werkzeug.datastructures.FileStorage.save", "type": "werkzeug.datastructures", "text": ["Save the file to a destination path or file object. If the destination is a file object you have to close it yourself after the call. The buffer size is the number of bytes held in memory during the copy process. It defaults to 16KB.", "For secure file saving also have a look at secure_filename().", "Changed in version 1.0: Supports pathlib."]}, {"name": "FileStorage.stream", "path": "datastructures/index#werkzeug.datastructures.FileStorage.stream", "type": "werkzeug.datastructures", "text": ["The input stream for the uploaded file. This usually points to an open temporary file."]}, {"name": "Filesystem Utilities", "path": "filesystem/index", "type": "Other", "text": ["Various utilities for the local filesystem.", "The warning used by Werkzeug to signal a broken filesystem. Will only be used once per runtime.", "Returns the filesystem encoding that should be used. Note that this is different from the Python understanding of the filesystem encoding which might be deeply flawed. Do not use this value against Python\u2019s string APIs because it might be different. See The Filesystem for the exact behavior.", "The concept of a filesystem encoding in generally is not something you should rely on. As such if you ever need to use this function except for writing wrapper code reconsider.", "str"]}, {"name": "FileWrapper", "path": "wsgi/index#werkzeug.wsgi.FileWrapper", "type": "werkzeug.wsgi", "text": ["This class can be used to convert a file-like object into an iterable. It yields buffer_size blocks until the file is fully read.", "You should not use this class directly but rather use the wrap_file() function that uses the WSGI server\u2019s file wrapper support if it\u2019s available.", "New in version 0.5.", "If you\u2019re using this object together with a Response you have to use the direct_passthrough mode.", "None"]}, {"name": "find_modules()", "path": "utils/index#werkzeug.utils.find_modules", "type": "werkzeug.utils", "text": ["Finds all the modules below a package. This can be useful to automatically import all views / controllers so that their metaclasses / function decorators have a chance to register themselves on the application.", "Packages are not returned unless include_packages is True. This can also recursively list modules but in that case it will import all the packages to get the correct load path of that module.", "generator", "Iterator[str]"]}, {"name": "FloatConverter", "path": "routing/index#werkzeug.routing.FloatConverter", "type": "werkzeug.routing", "text": ["This converter only accepts floating point values:", "By default it only accepts unsigned, positive values. The signed parameter will enable signed, negative values.", "None", "New in version 0.15: The signed parameter."]}, {"name": "FormDataParser", "path": "http/index#werkzeug.formparser.FormDataParser", "type": "werkzeug.formparser", "text": ["This class implements parsing of form data for Werkzeug. By itself it can parse multipart and url encoded form data. It can be subclassed and extended but for most mimetypes it is a better idea to use the untouched stream and expose it as separate attributes on a request object.", "New in version 0.8.", "None"]}, {"name": "generate_etag()", "path": "http/index#werkzeug.http.generate_etag", "type": "werkzeug.http", "text": ["Generate an etag for some data.", "Changed in version 2.0: Use SHA-1. MD5 may not be available in some environments.", "data (bytes) \u2013 ", "str"]}, {"name": "generate_password_hash()", "path": "utils/index#werkzeug.security.generate_password_hash", "type": "werkzeug.security", "text": ["Hash a password with the given method and salt with a string of the given length. The format of the string returned includes the method that was used so that check_password_hash() can check the hash.", "The format for the hashed string looks like this:", "This method can not generate unsalted passwords but it is possible to set param method=\u2019plain\u2019 in order to enforce plaintext passwords. If a salt is used, hmac is used internally to salt the password.", "If PBKDF2 is wanted it can be enabled by setting the method to pbkdf2:method:iterations where iterations is optional:", "str"]}, {"name": "get_content_length()", "path": "wsgi/index#werkzeug.wsgi.get_content_length", "type": "werkzeug.wsgi", "text": ["Returns the content length from the WSGI environment as integer. If it\u2019s not available or chunked transfer encoding is used, None is returned.", "New in version 0.9.", "environ (WSGIEnvironment) \u2013 the WSGI environ to fetch the content length from.", "Optional[int]"]}, {"name": "get_current_url()", "path": "wsgi/index#werkzeug.wsgi.get_current_url", "type": "werkzeug.wsgi", "text": ["Recreate the URL for a request from the parts in a WSGI environment.", "The URL is an IRI, not a URI, so it may contain Unicode characters. Use iri_to_uri() to convert it to ASCII.", "str"]}, {"name": "get_filesystem_encoding()", "path": "filesystem/index#werkzeug.filesystem.get_filesystem_encoding", "type": "werkzeug.filesystem", "text": ["Returns the filesystem encoding that should be used. Note that this is different from the Python understanding of the filesystem encoding which might be deeply flawed. Do not use this value against Python\u2019s string APIs because it might be different. See The Filesystem for the exact behavior.", "The concept of a filesystem encoding in generally is not something you should rely on. As such if you ever need to use this function except for writing wrapper code reconsider.", "str"]}, {"name": "get_host()", "path": "wsgi/index#werkzeug.wsgi.get_host", "type": "werkzeug.wsgi", "text": ["Return the host for the given WSGI environment.", "The Host header is preferred, then SERVER_NAME if it\u2019s not set. The returned host will only contain the port if it is different than the standard port for the protocol.", "Optionally, verify that the host is trusted using host_is_trusted() and raise a SecurityError if it is not.", "Host, with port if necessary.", "SecurityError \u2013 If the host is not trusted.", "str"]}, {"name": "get_input_stream()", "path": "wsgi/index#werkzeug.wsgi.get_input_stream", "type": "werkzeug.wsgi", "text": ["Returns the input stream from the WSGI environment and wraps it in the most sensible way possible. The stream returned is not the raw WSGI stream in most cases but one that is safe to read from without taking into account the content length.", "If content length is not set, the stream will be empty for safety reasons. If the WSGI server supports chunked or infinite streams, it should set the wsgi.input_terminated value in the WSGI environ to indicate that.", "New in version 0.9.", "BinaryIO"]}, {"name": "get_path_info()", "path": "wsgi/index#werkzeug.wsgi.get_path_info", "type": "werkzeug.wsgi", "text": ["Return the PATH_INFO from the WSGI environment and decode it unless charset is None.", "str", "New in version 0.9."]}, {"name": "get_query_string()", "path": "wsgi/index#werkzeug.wsgi.get_query_string", "type": "werkzeug.wsgi", "text": ["Returns the QUERY_STRING from the WSGI environment. This also takes care of the WSGI decoding dance. The string returned will be restricted to ASCII characters.", "environ (WSGIEnvironment) \u2013 WSGI environment to get the query string from.", "str", "New in version 0.9."]}, {"name": "get_script_name()", "path": "wsgi/index#werkzeug.wsgi.get_script_name", "type": "werkzeug.wsgi", "text": ["Return the SCRIPT_NAME from the WSGI environment and decode it unless charset is set to None.", "str", "New in version 0.9."]}, {"name": "Headers", "path": "datastructures/index#werkzeug.datastructures.Headers", "type": "werkzeug.datastructures", "text": ["An object that stores some headers. It has a dict-like interface, but is ordered, can store the same key multiple times, and iterating yields (key, value) pairs instead of only keys.", "This data structure is useful if you want a nicer way to handle WSGI headers which are stored as tuples in a list.", "From Werkzeug 0.3 onwards, the KeyError raised by this class is also a subclass of the BadRequest HTTP exception and will render a page for a 400 BAD REQUEST if caught in a catch-all for HTTP exceptions.", "Headers is mostly compatible with the Python wsgiref.headers.Headers class, with the exception of __getitem__. wsgiref will return None for headers['missing'], whereas Headers will raise a KeyError.", "To create a new Headers object pass it a list or dict of headers which are used as default values. This does not reuse the list passed to the constructor for internal usage.", "defaults \u2013 The list of default values for the Headers.", "Changed in version 0.9: This data structure now stores unicode values similar to how the multi dicts do it. The main difference is that bytes can be set as well which will automatically be latin1 decoded.", "Changed in version 0.9: The linked() function was removed without replacement as it was an API that does not support the changes to the encoding model.", "Add a new header tuple to the list.", "Keyword arguments can specify additional parameters for the header value, with underscores converted to dashes:", "The keyword argument dumping uses dump_options_header() behind the scenes.", "New in version 0.4.1: keyword arguments were added for wsgiref compatibility.", "Add a new header tuple to the list.", "An alias for add() for compatibility with the wsgiref add_header() method.", "Clears all headers.", "Extend headers in this object with items from another object containing header items as well as keyword arguments.", "To replace existing keys instead of extending, use update() instead.", "If provided, the first argument can be another Headers object, a MultiDict, dict, or iterable of pairs.", "Changed in version 1.0: Support MultiDict. Allow passing kwargs.", "Return the default value if the requested data doesn\u2019t exist. If type is provided and is a callable it should convert the value, return it or raise a ValueError if that is not possible. In this case the function will return the default as if the value was not found:", "New in version 0.9: Added support for as_bytes.", "Return a list of all the values for the named field.", "This method is compatible with the wsgiref get_all() method.", "Return the list of items for a given key. If that key is not in the Headers, the return value will be an empty list. Just like get(), getlist() accepts a type parameter. All items will be converted with the callable defined there.", "New in version 0.9: Added support for as_bytes.", "a list of all the values for the key.", "Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use key in data instead.", "Removes and returns a key or index.", "key \u2013 The key to be popped. If this is an integer the item at that position is removed, if it\u2019s a string the value for that key is. If the key is omitted or None the last item is removed.", "an item.", "Removes a key or index and returns a (key, value) item.", "Remove a key.", "key \u2013 The key to be removed.", "Remove all header tuples for key and add a new one. The newly added key either appears at the end of the list if there was no entry or replaces the first one.", "Keyword arguments can specify additional parameters for the header value, with underscores converted to dashes. See add() for more information.", "Changed in version 0.6.1: set() now accepts the same arguments as add().", "Return the first value for the key if it is in the headers, otherwise set the header to the value given by default and return that.", "Remove any existing values for a header and add new ones.", "New in version 1.0.", "Return the list of values for the key if it is in the headers, otherwise set the header to the list of values given by default and return that.", "Unlike MultiDict.setlistdefault(), modifying the returned list will not affect the headers.", "New in version 1.0.", "Convert the headers into a list suitable for WSGI.", "list", "Replace headers in this object with items from another headers object and keyword arguments.", "To extend existing keys instead of replacing, use extend() instead.", "If provided, the first argument can be another Headers object, a MultiDict, dict, or iterable of pairs.", "New in version 1.0."]}, {"name": "Headers.add()", "path": "datastructures/index#werkzeug.datastructures.Headers.add", "type": "werkzeug.datastructures", "text": ["Add a new header tuple to the list.", "Keyword arguments can specify additional parameters for the header value, with underscores converted to dashes:", "The keyword argument dumping uses dump_options_header() behind the scenes.", "New in version 0.4.1: keyword arguments were added for wsgiref compatibility."]}, {"name": "Headers.add_header()", "path": "datastructures/index#werkzeug.datastructures.Headers.add_header", "type": "werkzeug.datastructures", "text": ["Add a new header tuple to the list.", "An alias for add() for compatibility with the wsgiref add_header() method."]}, {"name": "Headers.clear()", "path": "datastructures/index#werkzeug.datastructures.Headers.clear", "type": "werkzeug.datastructures", "text": ["Clears all headers."]}, {"name": "Headers.extend()", "path": "datastructures/index#werkzeug.datastructures.Headers.extend", "type": "werkzeug.datastructures", "text": ["Extend headers in this object with items from another object containing header items as well as keyword arguments.", "To replace existing keys instead of extending, use update() instead.", "If provided, the first argument can be another Headers object, a MultiDict, dict, or iterable of pairs.", "Changed in version 1.0: Support MultiDict. Allow passing kwargs."]}, {"name": "Headers.get()", "path": "datastructures/index#werkzeug.datastructures.Headers.get", "type": "werkzeug.datastructures", "text": ["Return the default value if the requested data doesn\u2019t exist. If type is provided and is a callable it should convert the value, return it or raise a ValueError if that is not possible. In this case the function will return the default as if the value was not found:", "New in version 0.9: Added support for as_bytes."]}, {"name": "Headers.getlist()", "path": "datastructures/index#werkzeug.datastructures.Headers.getlist", "type": "werkzeug.datastructures", "text": ["Return the list of items for a given key. If that key is not in the Headers, the return value will be an empty list. Just like get(), getlist() accepts a type parameter. All items will be converted with the callable defined there.", "New in version 0.9: Added support for as_bytes.", "a list of all the values for the key."]}, {"name": "Headers.get_all()", "path": "datastructures/index#werkzeug.datastructures.Headers.get_all", "type": "werkzeug.datastructures", "text": ["Return a list of all the values for the named field.", "This method is compatible with the wsgiref get_all() method."]}, {"name": "Headers.has_key()", "path": "datastructures/index#werkzeug.datastructures.Headers.has_key", "type": "werkzeug.datastructures", "text": ["Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use key in data instead."]}, {"name": "Headers.pop()", "path": "datastructures/index#werkzeug.datastructures.Headers.pop", "type": "werkzeug.datastructures", "text": ["Removes and returns a key or index.", "key \u2013 The key to be popped. If this is an integer the item at that position is removed, if it\u2019s a string the value for that key is. If the key is omitted or None the last item is removed.", "an item."]}, {"name": "Headers.popitem()", "path": "datastructures/index#werkzeug.datastructures.Headers.popitem", "type": "werkzeug.datastructures", "text": ["Removes a key or index and returns a (key, value) item."]}, {"name": "Headers.remove()", "path": "datastructures/index#werkzeug.datastructures.Headers.remove", "type": "werkzeug.datastructures", "text": ["Remove a key.", "key \u2013 The key to be removed."]}, {"name": "Headers.set()", "path": "datastructures/index#werkzeug.datastructures.Headers.set", "type": "werkzeug.datastructures", "text": ["Remove all header tuples for key and add a new one. The newly added key either appears at the end of the list if there was no entry or replaces the first one.", "Keyword arguments can specify additional parameters for the header value, with underscores converted to dashes. See add() for more information.", "Changed in version 0.6.1: set() now accepts the same arguments as add()."]}, {"name": "Headers.setdefault()", "path": "datastructures/index#werkzeug.datastructures.Headers.setdefault", "type": "werkzeug.datastructures", "text": ["Return the first value for the key if it is in the headers, otherwise set the header to the value given by default and return that."]}, {"name": "Headers.setlist()", "path": "datastructures/index#werkzeug.datastructures.Headers.setlist", "type": "werkzeug.datastructures", "text": ["Remove any existing values for a header and add new ones.", "New in version 1.0."]}, {"name": "Headers.setlistdefault()", "path": "datastructures/index#werkzeug.datastructures.Headers.setlistdefault", "type": "werkzeug.datastructures", "text": ["Return the list of values for the key if it is in the headers, otherwise set the header to the list of values given by default and return that.", "Unlike MultiDict.setlistdefault(), modifying the returned list will not affect the headers.", "New in version 1.0."]}, {"name": "Headers.to_wsgi_list()", "path": "datastructures/index#werkzeug.datastructures.Headers.to_wsgi_list", "type": "werkzeug.datastructures", "text": ["Convert the headers into a list suitable for WSGI.", "list"]}, {"name": "Headers.update()", "path": "datastructures/index#werkzeug.datastructures.Headers.update", "type": "werkzeug.datastructures", "text": ["Replace headers in this object with items from another headers object and keyword arguments.", "To extend existing keys instead of replacing, use extend() instead.", "If provided, the first argument can be another Headers object, a MultiDict, dict, or iterable of pairs.", "New in version 1.0."]}, {"name": "HeaderSet", "path": "datastructures/index#werkzeug.datastructures.HeaderSet", "type": "werkzeug.datastructures", "text": ["Similar to the ETags class this implements a set-like structure. Unlike ETags this is case insensitive and used for vary, allow, and content-language headers.", "If not constructed using the parse_set_header() function the instantiation works like this:", "Add a new header to the set.", "Return the set as real python set type. When calling this, all the items are converted to lowercase and the ordering is lost.", "preserve_casing \u2013 if set to True the items in the set returned will have the original case like in the HeaderSet, otherwise they will be lowercase.", "Clear the set.", "Like remove() but ignores errors.", "header \u2013 the header to be discarded.", "Return the index of the header in the set or return -1 if not found.", "header \u2013 the header to be looked up.", "Return the index of the header in the set or raise an IndexError.", "header \u2013 the header to be looked up.", "Remove a header from the set. This raises an KeyError if the header is not in the set.", "Changed in version 0.5: In older versions a IndexError was raised instead of a KeyError if the object was missing.", "header \u2013 the header to be removed.", "Convert the header set into an HTTP header string.", "Add all the headers from the iterable to the set.", "iterable \u2013 updates the set with the items from the iterable."]}, {"name": "HeaderSet.add()", "path": "datastructures/index#werkzeug.datastructures.HeaderSet.add", "type": "werkzeug.datastructures", "text": ["Add a new header to the set."]}, {"name": "HeaderSet.as_set()", "path": "datastructures/index#werkzeug.datastructures.HeaderSet.as_set", "type": "werkzeug.datastructures", "text": ["Return the set as real python set type. When calling this, all the items are converted to lowercase and the ordering is lost.", "preserve_casing \u2013 if set to True the items in the set returned will have the original case like in the HeaderSet, otherwise they will be lowercase."]}, {"name": "HeaderSet.clear()", "path": "datastructures/index#werkzeug.datastructures.HeaderSet.clear", "type": "werkzeug.datastructures", "text": ["Clear the set."]}, {"name": "HeaderSet.discard()", "path": "datastructures/index#werkzeug.datastructures.HeaderSet.discard", "type": "werkzeug.datastructures", "text": ["Like remove() but ignores errors.", "header \u2013 the header to be discarded."]}, {"name": "HeaderSet.find()", "path": "datastructures/index#werkzeug.datastructures.HeaderSet.find", "type": "werkzeug.datastructures", "text": ["Return the index of the header in the set or return -1 if not found.", "header \u2013 the header to be looked up."]}, {"name": "HeaderSet.index()", "path": "datastructures/index#werkzeug.datastructures.HeaderSet.index", "type": "werkzeug.datastructures", "text": ["Return the index of the header in the set or raise an IndexError.", "header \u2013 the header to be looked up."]}, {"name": "HeaderSet.remove()", "path": "datastructures/index#werkzeug.datastructures.HeaderSet.remove", "type": "werkzeug.datastructures", "text": ["Remove a header from the set. This raises an KeyError if the header is not in the set.", "Changed in version 0.5: In older versions a IndexError was raised instead of a KeyError if the object was missing.", "header \u2013 the header to be removed."]}, {"name": "HeaderSet.to_header()", "path": "datastructures/index#werkzeug.datastructures.HeaderSet.to_header", "type": "werkzeug.datastructures", "text": ["Convert the header set into an HTTP header string."]}, {"name": "HeaderSet.update()", "path": "datastructures/index#werkzeug.datastructures.HeaderSet.update", "type": "werkzeug.datastructures", "text": ["Add all the headers from the iterable to the set.", "iterable \u2013 updates the set with the items from the iterable."]}, {"name": "header_property", "path": "utils/index#werkzeug.utils.header_property", "type": "werkzeug.utils", "text": ["Like environ_property but for headers."]}, {"name": "host_is_trusted()", "path": "wsgi/index#werkzeug.wsgi.host_is_trusted", "type": "werkzeug.wsgi", "text": ["Check if a host matches a list of trusted names.", "bool", "New in version 0.9."]}, {"name": "Href", "path": "urls/index#werkzeug.urls.Href", "type": "werkzeug.urls", "text": ["Implements a callable that constructs URLs with the given base. The function can be called with any number of positional and keyword arguments which than are used to assemble the URL. Works with URLs and posix paths.", "Positional arguments are appended as individual segments to the path of the URL:", "If any of the arguments (positional or keyword) evaluates to None it will be skipped. If no keyword arguments are given the last argument can be a dict or MultiDict (or any other dict subclass), otherwise the keyword arguments are used for the query parameters, cutting off the first trailing underscore of the parameter name:", "Combining of both methods is not allowed:", "Accessing attributes on the href object creates a new href object with the attribute name as prefix:", "If sort is set to True the items are sorted by key or the default sorting algorithm:", "Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use werkzeug.routing instead.", "New in version 0.5: sort and key were added."]}, {"name": "HTMLBuilder", "path": "utils/index#werkzeug.utils.HTMLBuilder", "type": "werkzeug.utils", "text": ["Helper object for HTML generation.", "Per default there are two instances of that class. The html one, and the xhtml one for those two dialects. The class uses keyword parameters and positional parameters to generate small snippets of HTML.", "Keyword parameters are converted to XML/SGML attributes, positional arguments are used as children. Because Python accepts positional arguments before keyword arguments it\u2019s a good idea to use a list with the star-syntax for some children:", "This class works around some browser limitations and can not be used for arbitrary SGML/XML generation. For that purpose lxml and similar libraries exist.", "Calling the builder escapes the string passed:", "Deprecated since version 2.0: Will be removed in Werkzeug 2.1."]}, {"name": "HTTP Exceptions", "path": "exceptions/index", "type": "Other", "text": ["Implements a number of Python exceptions which can be raised from within a view to trigger a standard HTTP non-200 response.", "As you can see from this example those exceptions are callable WSGI applications. However, they are not Werkzeug response objects. You can get a response object by calling get_response() on a HTTP exception.", "Keep in mind that you may have to pass an environ (WSGI) or scope (ASGI) to get_response() because some errors fetch additional information relating to the request.", "If you want to hook in a different exception page to say, a 404 status code, you can add a second except for a specific subclass of an error:", "The following error classes exist in Werkzeug:", "400 Bad Request", "Raise if the browser sends something to the application the application or server cannot handle.", "None", "401 Unauthorized", "Raise if the user is not authorized to access a resource.", "The www_authenticate argument should be used to set the WWW-Authenticate header. This is used for HTTP basic auth and other schemes. Use WWWAuthenticate to create correctly formatted values. Strictly speaking a 401 response is invalid if it doesn\u2019t provide at least one value for this header, although real clients typically don\u2019t care.", "None", "Changed in version 2.0: Serialize multiple www_authenticate items into multiple WWW-Authenticate headers, rather than joining them into a single value, for better interoperability.", "Changed in version 0.15.3: If the www_authenticate argument is not set, the WWW-Authenticate header is not set.", "Changed in version 0.15.3: The response argument was restored.", "Changed in version 0.15.1: description was moved back as the first argument, restoring its previous position.", "Changed in version 0.15.0: www_authenticate was added as the first argument, ahead of description.", "403 Forbidden", "Raise if the user doesn\u2019t have the permission for the requested resource but was authenticated.", "None", "404 Not Found", "Raise if a resource does not exist and never existed.", "None", "405 Method Not Allowed", "Raise if the server used a method the resource does not handle. For example POST if the resource is view only. Especially useful for REST.", "The first argument for this exception should be a list of allowed methods. Strictly speaking the response would be invalid if you don\u2019t provide valid methods in the header which you can do with that list.", "Takes an optional list of valid http methods starting with werkzeug 0.3 the list will be mandatory.", "None", "406 Not Acceptable", "Raise if the server can\u2019t return any content conforming to the Accept headers of the client.", "None", "408 Request Timeout", "Raise to signalize a timeout.", "None", "409 Conflict", "Raise to signal that a request cannot be completed because it conflicts with the current state on the server.", "New in version 0.7.", "None", "410 Gone", "Raise if a resource existed previously and went away without new location.", "None", "411 Length Required", "Raise if the browser submitted data but no Content-Length header which is required for the kind of processing the server does.", "None", "412 Precondition Failed", "Status code used in combination with If-Match, If-None-Match, or If-Unmodified-Since.", "None", "413 Request Entity Too Large", "The status code one should return if the data submitted exceeded a given limit.", "None", "414 Request URI Too Large", "Like 413 but for too long URLs.", "None", "415 Unsupported Media Type", "The status code returned if the server is unable to handle the media type the client transmitted.", "None", "416 Requested Range Not Satisfiable", "The client asked for an invalid part of the file.", "New in version 0.7.", "Takes an optional Content-Range header value based on length parameter.", "None", "417 Expectation Failed", "The server cannot meet the requirements of the Expect request-header.", "New in version 0.7.", "None", "418 I\u2019m a teapot", "The server should return this if it is a teapot and someone attempted to brew coffee with it.", "New in version 0.7.", "None", "422 Unprocessable Entity", "Used if the request is well formed, but the instructions are otherwise incorrect.", "None", "423 Locked", "Used if the resource that is being accessed is locked.", "None", "424 Failed Dependency", "Used if the method could not be performed on the resource because the requested action depended on another action and that action failed.", "None", "428 Precondition Required", "The server requires this request to be conditional, typically to prevent the lost update problem, which is a race condition between two or more clients attempting to update a resource through PUT or DELETE. By requiring each client to include a conditional header (\u201cIf-Match\u201d or \u201cIf-Unmodified- Since\u201d) with the proper value retained from a recent GET request, the server ensures that each client has at least seen the previous revision of the resource.", "None", "429 Too Many Requests", "The server is limiting the rate at which this user receives responses, and this request exceeds that rate. (The server may use any convenient method to identify users and their request rates). The server may include a \u201cRetry-After\u201d header to indicate how long the user should wait before retrying.", "None", "Changed in version 1.0: Added retry_after parameter.", "431 Request Header Fields Too Large", "The server refuses to process the request because the header fields are too large. One or more individual fields may be too large, or the set of all headers is too large.", "None", "451 Unavailable For Legal Reasons", "This status code indicates that the server is denying access to the resource as a consequence of a legal demand.", "None", "500 Internal Server Error", "Raise if an internal server error occurred. This is a good fallback if an unknown error occurred in the dispatcher.", "Changed in version 1.0.0: Added the original_exception attribute.", "None", "The original exception that caused this 500 error. Can be used by frameworks to provide context when handling unexpected errors.", "501 Not Implemented", "Raise if the application does not support the action requested by the browser.", "None", "502 Bad Gateway", "If you do proxying in your application you should return this status code if you received an invalid response from the upstream server it accessed in attempting to fulfill the request.", "None", "503 Service Unavailable", "Status code you should return if a service is temporarily unavailable.", "None", "Changed in version 1.0: Added retry_after parameter.", "504 Gateway Timeout", "Status code you should return if a connection to an upstream server times out.", "None", "505 HTTP Version Not Supported", "The server does not support the HTTP protocol version used in the request.", "None", "Internal exception that is raised if Werkzeug detects a disconnected client. Since the client is already gone at that point attempting to send the error message to the client might not work and might ultimately result in another exception in the server. Mainly this is here so that it is silenced by default as far as Werkzeug is concerned.", "Since disconnections cannot be reliably detected and are unspecified by WSGI to a large extent this might or might not be raised if a client is gone.", "New in version 0.8.", "None", "Raised if something triggers a security error. This is otherwise exactly like a bad request error.", "New in version 0.9.", "None", "All the exceptions implement this common interface:", "The base class for all HTTP exceptions. This exception can be called as a WSGI application to render a default error page or you can catch the subclasses of it independently and render nicer error messages.", "None", "Call the exception as WSGI application.", "Iterable[bytes]", "Get a response object. If one was passed to the exception it\u2019s returned directly.", "a Response object or a subclass thereof.", "Response", "Starting with Werkzeug 0.3 some of the builtin classes raise exceptions that look like regular python exceptions (eg KeyError) but are BadRequest HTTP exceptions at the same time. This decision was made to simplify a common pattern where you want to abort if the client tampered with the submitted form data in a way that the application can\u2019t recover properly and should abort with 400 BAD REQUEST.", "Assuming the application catches all HTTP exceptions and reacts to them properly a view function could do the following safely and doesn\u2019t have to check if the keys exist:", "If title or body are missing in the form, a special key error will be raised which behaves like a KeyError but also a BadRequest exception.", "An exception that is used to signal both a KeyError and a BadRequest. Used by many of the datastructures.", "Sometimes it\u2019s convenient to just raise an exception by the error code, without importing the exception and looking up the name etc. For this purpose there is the abort() function.", "Raises an HTTPException for the given status code or WSGI application.", "If a status code is given, it will be looked up in the list of exceptions and will raise that exception. If passed a WSGI application, it will wrap it in a proxy WSGI exception and raise that:", "NoReturn", "If you want to use this functionality with custom exceptions you can create an instance of the aborter class:", "When passed a dict of code -> exception items it can be used as callable that raises exceptions. If the first argument to the callable is an integer it will be looked up in the mapping, if it\u2019s a WSGI application it will be raised in a proxy exception.", "The rest of the arguments are forwarded to the exception constructor.", "None", "As you can see from the list above not all status codes are available as errors. Especially redirects and other non 200 status codes that do not represent errors are missing. For redirects you can use the redirect() function from the utilities.", "If you want to add an error yourself you can subclass HTTPException:", "This is the minimal code you need for your own exception. If you want to add more logic to the errors you can override the get_description(), get_body(), get_headers() and get_response() methods. In any case you should have a look at the sourcecode of the exceptions module.", "You can override the default description in the constructor with the description parameter:"]}, {"name": "HTTP Proxying", "path": "deployment/proxying/index", "type": "Other", "text": ["Many people prefer using a standalone Python HTTP server and proxying that server via nginx, Apache etc.", "A very stable Python server is CherryPy. This part of the documentation shows you how to combine your WSGI application with the CherryPy WSGI server and how to configure the webserver for proxying.", "To run your application you need a start-server.py file that starts up the WSGI Server.", "It looks something along these lines:", "If you now start the file the server will listen on localhost:8080. Keep in mind that WSGI applications behave slightly different for proxied setups. If you have not developed your application for proxying in mind, you can apply the ProxyFix middleware.", "As an example we show here how to configure nginx to proxy to the server.", "The basic nginx configuration looks like this:", "Since Nginx doesn\u2019t start your server for you, you have to do it by yourself. You can either write an init.d script for that or execute it inside a screen session:"]}, {"name": "HTTP Utilities", "path": "http/index", "type": "Other", "text": ["Werkzeug provides a couple of functions to parse and generate HTTP headers that are useful when implementing WSGI middlewares or whenever you are operating on a lower level layer. All this functionality is also exposed from request and response objects.", "These functions simplify working with times in an HTTP context. Werkzeug produces timezone-aware datetime objects in UTC. When passing datetime objects to Werkzeug, it assumes any naive datetime is in UTC.", "When comparing datetime values from Werkzeug, your own datetime objects must also be timezone-aware, or you must make the values from Werkzeug naive.", "Parse an RFC 2822 date into a timezone-aware datetime.datetime object, or None if parsing fails.", "This is a wrapper for email.utils.parsedate_to_datetime(). It returns None if parsing fails instead of raising an exception, and always returns a timezone-aware datetime object. If the string doesn\u2019t have timezone information, it is assumed to be UTC.", "value (Optional[str]) \u2013 A string with a supported date format.", "Optional[datetime.datetime]", "Changed in version 2.0: Return a timezone-aware datetime object. Use email.utils.parsedate_to_datetime.", "Format a datetime object or timestamp into an RFC 2822 date string.", "This is a wrapper for email.utils.format_datetime(). It assumes naive datetime objects are in UTC instead of raising an exception.", "timestamp (Optional[Union[datetime.datetime, datetime.date, int, float, time.struct_time]]) \u2013 The datetime or timestamp to format. Defaults to the current time.", "str", "Changed in version 2.0: Use email.utils.format_datetime. Accept date objects.", "Format a datetime object or timestamp into an RFC 2822 date string for Set-Cookie expires.", "Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use http_date() instead.", "expires (Optional[Union[datetime.datetime, datetime.date, int, float, time.struct_time]]) \u2013 ", "str", "The following functions can be used to parse incoming HTTP headers. Because Python does not provide data structures with the semantics required by RFC 2616, Werkzeug implements some custom data structures that are documented separately.", "Parse a Content-Type like header into a tuple with the content type and the options:", "This should not be used to parse Cache-Control like headers that use a slightly different format. For these headers use the parse_dict_header() function.", "Changed in version 0.15: RFC 2231 parameter continuations are handled.", "New in version 0.5.", "(mimetype, options) or (mimetype, options, mimetype, options, \u2026) if multiple=True", "Union[Tuple[str, Dict[str, str]], Tuple[Any, \u2026]]", "Parse a set-like header and return a HeaderSet object:", "The return value is an object that treats the items case-insensitively and keeps the order of the items:", "To create a header from the HeaderSet again, use the dump_header() function.", "a HeaderSet", "werkzeug.datastructures.HeaderSet", "Parse lists as described by RFC 2068 Section 2.", "In particular, parse comma-separated lists where the elements of the list may include quoted-strings. A quoted-string could contain a comma. A non-quoted string could have quotes in the middle. Quotes are removed automatically after parsing.", "It basically works like parse_set_header() just that items may appear multiple times and case sensitivity is preserved.", "The return value is a standard list:", "To create a header from the list again, use the dump_header() function.", "value (str) \u2013 a string with a list header.", "list", "List[str]", "Parse lists of key, value pairs as described by RFC 2068 Section 2 and convert them into a python dict (or any other mapping object created from the type with a dict like interface provided by the cls argument):", "If there is no value for a key it will be None:", "To create a header from the dict again, use the dump_header() function.", "Changed in version 0.9: Added support for cls argument.", "an instance of cls", "Dict[str, str]", "Parses an HTTP Accept-* header. This does not implement a complete valid algorithm but one that supports at least value and quality extraction.", "Returns a new Accept object (basically a list of (value, quality) tuples sorted by the quality with some additional accessor methods).", "The second parameter can be a subclass of Accept that is created with the parsed values and returned.", "an instance of cls.", "werkzeug.http._TAnyAccept", "Parse a cache control header. The RFC differs between response and request cache control, this method does not. It\u2019s your responsibility to not use the wrong control statements.", "New in version 0.5: The cls was added. If not specified an immutable RequestCacheControl is returned.", "a cls object.", "werkzeug.http._TAnyCC", "Parse an HTTP basic/digest authorization header transmitted by the web browser. The return value is either None if the header was invalid or not given, otherwise an Authorization object.", "value (Optional[str]) \u2013 the authorization header to parse.", "a Authorization object or None.", "Optional[werkzeug.datastructures.Authorization]", "Parse an HTTP WWW-Authenticate header into a WWWAuthenticate object.", "a WWWAuthenticate object.", "werkzeug.datastructures.WWWAuthenticate", "Parses an if-range header which can be an etag or a date. Returns a IfRange object.", "Changed in version 2.0: If the value represents a datetime, it is timezone-aware.", "New in version 0.7.", "value (Optional[str]) \u2013 ", "werkzeug.datastructures.IfRange", "Parses a range header into a Range object. If the header is missing or malformed None is returned. ranges is a list of (start, stop) tuples where the ranges are non-inclusive.", "New in version 0.7.", "Optional[werkzeug.datastructures.Range]", "Parses a range header into a ContentRange object or None if parsing is not possible.", "New in version 0.7.", "Optional[werkzeug.datastructures.ContentRange]", "The following utilities operate on HTTP headers well but do not parse them. They are useful if you\u2019re dealing with conditional responses or if you want to proxy arbitrary requests but want to remove WSGI-unsupported hop-by-hop headers. Also there is a function to create HTTP header strings from the parsed data.", "Check if a header is an entity header.", "New in version 0.5.", "header (str) \u2013 the header to test.", "True if it\u2019s an entity header, False otherwise.", "bool", "Check if a header is an HTTP/1.1 \u201cHop-by-Hop\u201d header.", "New in version 0.5.", "header (str) \u2013 the header to test.", "True if it\u2019s an HTTP/1.1 \u201cHop-by-Hop\u201d header, False otherwise.", "bool", "Remove all entity headers from a list or Headers object. This operation works in-place. Expires and Content-Location headers are by default not removed. The reason for this is RFC 2616 section 10.3.5 which specifies some entity headers that should be sent.", "Changed in version 0.5: added allowed parameter.", "None", "Remove all HTTP/1.1 \u201cHop-by-Hop\u201d headers from a list or Headers object. This operation works in-place.", "New in version 0.5.", "headers (Union[werkzeug.datastructures.Headers, List[Tuple[str, str]]]) \u2013 a list or Headers object.", "None", "Checks if a given byte content range is valid for the given length.", "New in version 0.7.", "bool", "Quote a header value if necessary.", "New in version 0.5.", "str", "Unquotes a header value. (Reversal of quote_header_value()). This does not use the real unquoting but what browsers are actually using for quoting.", "New in version 0.5.", "str", "Dump an HTTP header again. This is the reversal of parse_list_header(), parse_set_header() and parse_dict_header(). This also quotes strings that include an equals sign unless you pass it as dict of key, value pairs.", "str", "Parse a cookie from a string or WSGI environ.", "The same key can be provided multiple times, the values are stored in-order. The default MultiDict will have the first value first, and all values can be retrieved with MultiDict.getlist().", "ds.MultiDict[str, str]", "Changed in version 1.0.0: Returns a MultiDict instead of a TypeConversionDict.", "Changed in version 0.5: Returns a TypeConversionDict instead of a regular dict. The cls parameter was added.", "Create a Set-Cookie header without the Set-Cookie prefix.", "The return value is usually restricted to ascii as the vast majority of values are properly escaped, but that is no guarantee. It\u2019s tunneled through latin1 as required by PEP 3333.", "The return value is not ASCII safe if the key contains unicode characters. This is technically against the specification but happens in the wild. It\u2019s strongly recommended to not use non-ASCII values for the keys.", "str", "Changed in version 1.0.0: The string 'None' is accepted for samesite.", "For conditional responses the following functions might be useful:", "Parse an etag header.", "value (Optional[str]) \u2013 the tag header to parse", "an ETags object.", "werkzeug.datastructures.ETags", "Quote an etag.", "str", "Unquote a single etag:", "etag (Optional[str]) \u2013 the etag identifier to unquote.", "a (etag, weak) tuple.", "Union[Tuple[str, bool], Tuple[None, None]]", "Generate an etag for some data.", "Changed in version 2.0: Use SHA-1. MD5 may not be available in some environments.", "data (bytes) \u2013 ", "str", "Convenience method for conditional requests.", "True if the resource was modified, otherwise False.", "bool", "Changed in version 2.0: SHA-1 is used to generate an etag value for the data. MD5 may not be available in some environments.", "Changed in version 1.0.0: The check is run for methods other than GET and HEAD.", "A dict of status code -> default status message pairs. This is used by the wrappers and other places where an integer status code is expanded to a string throughout Werkzeug.", "Werkzeug provides the form parsing functions separately from the request object so that you can access form data from a plain WSGI environment.", "The following formats are currently supported by the form data parser:", "Nested multipart is not currently supported (Werkzeug 0.9), but it isn\u2019t used by any of the modern web browsers.", "Usage example:", "Normally the WSGI environment is provided by the WSGI gateway with the incoming data as part of it. If you want to generate such fake-WSGI environments for unittesting you might want to use the create_environ() function or the EnvironBuilder instead.", "This class implements parsing of form data for Werkzeug. By itself it can parse multipart and url encoded form data. It can be subclassed and extended but for most mimetypes it is a better idea to use the untouched stream and expose it as separate attributes on a request object.", "New in version 0.8.", "None", "Parse the form data in the environ and return it as tuple in the form (stream, form, files). You should only call this method if the transport method is POST, PUT, or PATCH.", "If the mimetype of the data transmitted is multipart/form-data the files multidict will be filled with FileStorage objects. If the mimetype is unknown the input stream is wrapped and returned as first argument, else the stream is empty.", "This is a shortcut for the common usage of FormDataParser.", "Have a look at Dealing with Request Data for more details.", "New in version 0.5.1: The optional silent flag was added.", "New in version 0.5: The max_form_memory_size, max_content_length and cls parameters were added.", "A tuple in the form (stream, form, files).", "t_parse_result"]}, {"name": "HTTPException.get_response()", "path": "exceptions/index#werkzeug.exceptions.HTTPException.get_response", "type": "werkzeug.exceptions", "text": ["Get a response object. If one was passed to the exception it\u2019s returned directly.", "a Response object or a subclass thereof.", "Response"]}, {"name": "HTTPException.__call__()", "path": "exceptions/index#werkzeug.exceptions.HTTPException.__call__", "type": "werkzeug.exceptions", "text": ["Call the exception as WSGI application.", "Iterable[bytes]"]}, {"name": "http_date()", "path": "http/index#werkzeug.http.http_date", "type": "werkzeug.http", "text": ["Format a datetime object or timestamp into an RFC 2822 date string.", "This is a wrapper for email.utils.format_datetime(). It assumes naive datetime objects are in UTC instead of raising an exception.", "timestamp (Optional[Union[datetime.datetime, datetime.date, int, float, time.struct_time]]) \u2013 The datetime or timestamp to format. Defaults to the current time.", "str", "Changed in version 2.0: Use email.utils.format_datetime. Accept date objects."]}, {"name": "IfRange", "path": "datastructures/index#werkzeug.datastructures.IfRange", "type": "werkzeug.datastructures", "text": ["Very simple object that represents the If-Range header in parsed form. It will either have neither a etag or date or one of either but never both.", "New in version 0.7.", "The date in parsed format or None.", "The etag parsed and unquoted. Ranges always operate on strong etags so the weakness information is not necessary.", "Converts the object back into an HTTP header."]}, {"name": "IfRange.date", "path": "datastructures/index#werkzeug.datastructures.IfRange.date", "type": "werkzeug.datastructures", "text": ["The date in parsed format or None."]}, {"name": "IfRange.etag", "path": "datastructures/index#werkzeug.datastructures.IfRange.etag", "type": "werkzeug.datastructures", "text": ["The etag parsed and unquoted. Ranges always operate on strong etags so the weakness information is not necessary."]}, {"name": "IfRange.to_header()", "path": "datastructures/index#werkzeug.datastructures.IfRange.to_header", "type": "werkzeug.datastructures", "text": ["Converts the object back into an HTTP header."]}, {"name": "ImmutableDict", "path": "datastructures/index#werkzeug.datastructures.ImmutableDict", "type": "werkzeug.datastructures", "text": ["An immutable dict.", "New in version 0.5.", "Return a shallow mutable copy of this object. Keep in mind that the standard library\u2019s copy() function is a no-op for this class like for any other python immutable type (eg: tuple)."]}, {"name": "ImmutableDict.copy()", "path": "datastructures/index#werkzeug.datastructures.ImmutableDict.copy", "type": "werkzeug.datastructures", "text": ["Return a shallow mutable copy of this object. Keep in mind that the standard library\u2019s copy() function is a no-op for this class like for any other python immutable type (eg: tuple)."]}, {"name": "ImmutableList", "path": "datastructures/index#werkzeug.datastructures.ImmutableList", "type": "werkzeug.datastructures", "text": ["An immutable list.", "New in version 0.5."]}, {"name": "ImmutableMultiDict", "path": "datastructures/index#werkzeug.datastructures.ImmutableMultiDict", "type": "werkzeug.datastructures", "text": ["An immutable MultiDict.", "New in version 0.5.", "Return a shallow mutable copy of this object. Keep in mind that the standard library\u2019s copy() function is a no-op for this class like for any other python immutable type (eg: tuple)."]}, {"name": "ImmutableMultiDict.copy()", "path": "datastructures/index#werkzeug.datastructures.ImmutableMultiDict.copy", "type": "werkzeug.datastructures", "text": ["Return a shallow mutable copy of this object. Keep in mind that the standard library\u2019s copy() function is a no-op for this class like for any other python immutable type (eg: tuple)."]}, {"name": "ImmutableOrderedMultiDict", "path": "datastructures/index#werkzeug.datastructures.ImmutableOrderedMultiDict", "type": "werkzeug.datastructures", "text": ["An immutable OrderedMultiDict.", "New in version 0.6.", "Return a shallow mutable copy of this object. Keep in mind that the standard library\u2019s copy() function is a no-op for this class like for any other python immutable type (eg: tuple)."]}, {"name": "ImmutableOrderedMultiDict.copy()", "path": "datastructures/index#werkzeug.datastructures.ImmutableOrderedMultiDict.copy", "type": "werkzeug.datastructures", "text": ["Return a shallow mutable copy of this object. Keep in mind that the standard library\u2019s copy() function is a no-op for this class like for any other python immutable type (eg: tuple)."]}, {"name": "ImmutableTypeConversionDict", "path": "datastructures/index#werkzeug.datastructures.ImmutableTypeConversionDict", "type": "werkzeug.datastructures", "text": ["Works like a TypeConversionDict but does not support modifications.", "New in version 0.5.", "Return a shallow mutable copy of this object. Keep in mind that the standard library\u2019s copy() function is a no-op for this class like for any other python immutable type (eg: tuple)."]}, {"name": "ImmutableTypeConversionDict.copy()", "path": "datastructures/index#werkzeug.datastructures.ImmutableTypeConversionDict.copy", "type": "werkzeug.datastructures", "text": ["Return a shallow mutable copy of this object. Keep in mind that the standard library\u2019s copy() function is a no-op for this class like for any other python immutable type (eg: tuple)."]}, {"name": "Important Terms", "path": "terms/index", "type": "Other", "text": ["This page covers important terms used in the documentation and Werkzeug itself.", "WSGI a specification for Python web applications Werkzeug follows. It was specified in the PEP 3333 and is widely supported. Unlike previous solutions it guarantees that web applications, servers and utilities can work together.", "For Werkzeug, a response object is an object that works like a WSGI application but does not do any request processing. Usually you have a view function or controller method that processes the request and assembles a response object.", "A response object is not necessarily the Response class or a subclass thereof.", "For example Pylons/webob provide a very similar response class that can be used as well (webob.Response).", "Often people speak of MVC (Model, View, Controller) when developing web applications. However, the Django framework coined MTV (Model, Template, View) which basically means the same but reduces the concept to the data model, a function that processes data from the request and the database and renders a template.", "Werkzeug itself does not tell you how you should develop applications, but the documentation often speaks of view functions that work roughly the same. The idea of a view function is that it\u2019s called with a request object (and optionally some parameters from an URL rule) and returns a response object."]}, {"name": "import_string()", "path": "utils/index#werkzeug.utils.import_string", "type": "werkzeug.utils", "text": ["Imports an object based on a string. This is useful if you want to use import paths as endpoints or something similar. An import path can be specified either in dotted notation (xml.sax.saxutils.escape) or with a colon as object delimiter (xml.sax.saxutils:escape).", "If silent is True the return value will be None if the import fails.", "imported object", "Any"]}, {"name": "Installation", "path": "installation/index", "type": "Other", "text": ["We recommend using the latest version of Python. Werkzeug supports Python 3.6 and newer.", "Werkzeug does not have any direct dependencies.", "These distributions will not be installed automatically. Werkzeug will detect and use them if you install them.", "Use a virtual environment to manage the dependencies for your project, both in development and in production.", "What problem does a virtual environment solve? The more Python projects you have, the more likely it is that you need to work with different versions of Python libraries, or even Python itself. Newer versions of libraries for one project can break compatibility in another project.", "Virtual environments are independent groups of Python libraries, one for each project. Packages installed for one project will not affect other projects or the operating system\u2019s packages.", "Python comes bundled with the venv module to create virtual environments.", "Create a project folder and a venv folder within:", "On Windows:", "Before you work on your project, activate the corresponding environment:", "On Windows:", "Your shell prompt will change to show the name of the activated environment.", "Within the activated environment, use the following command to install Werkzeug:"]}, {"name": "IntegerConverter", "path": "routing/index#werkzeug.routing.IntegerConverter", "type": "werkzeug.routing", "text": ["This converter only accepts integer values:", "By default it only accepts unsigned, positive values. The signed parameter will enable signed, negative values.", "None", "New in version 0.15: The signed parameter."]}, {"name": "InternalServerError.original_exception", "path": "exceptions/index#werkzeug.exceptions.InternalServerError.original_exception", "type": "werkzeug.exceptions", "text": ["The original exception that caused this 500 error. Can be used by frameworks to provide context when handling unexpected errors."]}, {"name": "invalidate_cached_property()", "path": "utils/index#werkzeug.utils.invalidate_cached_property", "type": "werkzeug.utils", "text": ["Invalidates the cache for a cached_property:", "You must pass the name of the cached property as the second argument.", "Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use del obj.name instead.", "None"]}, {"name": "iri_to_uri()", "path": "urls/index#werkzeug.urls.iri_to_uri", "type": "werkzeug.urls", "text": ["Convert an IRI to a URI. All non-ASCII and unsafe characters are quoted. If the URL has a domain, it is encoded to Punycode.", "str", "There is a general problem with IRI conversion with some protocols that are in violation of the URI specification. Consider the following two IRIs:", "After parsing, we don\u2019t know if the scheme requires the //, which is dropped if empty, but conveys different meanings in the final URL if it\u2019s present or not. In this case, you can use safe_conversion, which will return the URL unchanged if it only contains ASCII characters and no whitespace. This can result in a URI with unquoted characters if it was not already quoted correctly, but preserves the URL\u2019s semantics. Werkzeug uses this for the Location header for redirects.", "Changed in version 0.15: All reserved characters remain unquoted. Previously, only some reserved characters were left unquoted.", "Changed in version 0.9.6: The safe_conversion parameter was added.", "New in version 0.6."]}, {"name": "is_byte_range_valid()", "path": "http/index#werkzeug.http.is_byte_range_valid", "type": "werkzeug.http", "text": ["Checks if a given byte content range is valid for the given length.", "New in version 0.7.", "bool"]}, {"name": "is_entity_header()", "path": "http/index#werkzeug.http.is_entity_header", "type": "werkzeug.http", "text": ["Check if a header is an entity header.", "New in version 0.5.", "header (str) \u2013 the header to test.", "True if it\u2019s an entity header, False otherwise.", "bool"]}, {"name": "is_hop_by_hop_header()", "path": "http/index#werkzeug.http.is_hop_by_hop_header", "type": "werkzeug.http", "text": ["Check if a header is an HTTP/1.1 \u201cHop-by-Hop\u201d header.", "New in version 0.5.", "header (str) \u2013 the header to test.", "True if it\u2019s an HTTP/1.1 \u201cHop-by-Hop\u201d header, False otherwise.", "bool"]}, {"name": "is_resource_modified()", "path": "http/index#werkzeug.http.is_resource_modified", "type": "werkzeug.http", "text": ["Convenience method for conditional requests.", "True if the resource was modified, otherwise False.", "bool", "Changed in version 2.0: SHA-1 is used to generate an etag value for the data. MD5 may not be available in some environments.", "Changed in version 1.0.0: The check is run for methods other than GET and HEAD."]}, {"name": "is_running_from_reloader()", "path": "serving/index#werkzeug.serving.is_running_from_reloader", "type": "werkzeug.serving", "text": ["Checks if the application is running from within the Werkzeug reloader subprocess.", "New in version 0.10.", "bool"]}, {"name": "LanguageAccept", "path": "datastructures/index#werkzeug.datastructures.LanguageAccept", "type": "werkzeug.datastructures", "text": ["Like Accept but with normalization for language tags."]}, {"name": "LimitedStream", "path": "wsgi/index#werkzeug.wsgi.LimitedStream", "type": "werkzeug.wsgi", "text": ["Wraps a stream so that it doesn\u2019t read more than n bytes. If the stream is exhausted and the caller tries to get more bytes from it on_exhausted() is called which by default returns an empty string. The return value of that function is forwarded to the reader function. So if it returns an empty string read() will return an empty string as well.", "The limit however must never be higher than what the stream can output. Otherwise readlines() will try to read past the limit.", "Note on WSGI compliance", "calls to readline() and readlines() are not WSGI compliant because it passes a size argument to the readline methods. Unfortunately the WSGI PEP is not safely implementable without a size argument to readline() because there is no EOF marker in the stream. As a result of that the use of readline() is discouraged.", "For the same reason iterating over the LimitedStream is not portable. It internally calls readline().", "We strongly suggest using read() only or using the make_line_iter() which safely iterates line-based over a WSGI input stream.", "None", "Exhaust the stream. This consumes all the data left until the limit is reached.", "chunk_size (int) \u2013 the size for a chunk. It will read the chunk until the stream is exhausted and throw away the results.", "None", "If the stream is exhausted this attribute is True.", "What should happen if a disconnect is detected? The return value of this function is returned from read functions in case the client went away. By default a ClientDisconnected exception is raised.", "bytes", "This is called when the stream tries to read past the limit. The return value of this function is returned from the reading function.", "bytes", "Read size bytes or if size is not provided everything is read.", "size (Optional[int]) \u2013 the number of bytes read.", "bytes", "Return whether object was opened for reading.", "If False, read() will raise OSError.", "bool", "Reads one line from the stream.", "size (Optional[int]) \u2013 ", "bytes", "Reads a file into a list of strings. It calls readline() until the file is read to the end. It does support the optional size argument if the underlying stream supports it for readline.", "size (Optional[int]) \u2013 ", "List[bytes]", "Returns the position of the stream.", "New in version 0.9.", "int"]}, {"name": "LimitedStream.exhaust()", "path": "wsgi/index#werkzeug.wsgi.LimitedStream.exhaust", "type": "werkzeug.wsgi", "text": ["Exhaust the stream. This consumes all the data left until the limit is reached.", "chunk_size (int) \u2013 the size for a chunk. It will read the chunk until the stream is exhausted and throw away the results.", "None"]}, {"name": "LimitedStream.on_disconnect()", "path": "wsgi/index#werkzeug.wsgi.LimitedStream.on_disconnect", "type": "werkzeug.wsgi", "text": ["What should happen if a disconnect is detected? The return value of this function is returned from read functions in case the client went away. By default a ClientDisconnected exception is raised.", "bytes"]}, {"name": "LimitedStream.on_exhausted()", "path": "wsgi/index#werkzeug.wsgi.LimitedStream.on_exhausted", "type": "werkzeug.wsgi", "text": ["This is called when the stream tries to read past the limit. The return value of this function is returned from the reading function.", "bytes"]}, {"name": "LimitedStream.read()", "path": "wsgi/index#werkzeug.wsgi.LimitedStream.read", "type": "werkzeug.wsgi", "text": ["Read size bytes or if size is not provided everything is read.", "size (Optional[int]) \u2013 the number of bytes read.", "bytes"]}, {"name": "LimitedStream.readable()", "path": "wsgi/index#werkzeug.wsgi.LimitedStream.readable", "type": "werkzeug.wsgi", "text": ["Return whether object was opened for reading.", "If False, read() will raise OSError.", "bool"]}, {"name": "LimitedStream.readline()", "path": "wsgi/index#werkzeug.wsgi.LimitedStream.readline", "type": "werkzeug.wsgi", "text": ["Reads one line from the stream.", "size (Optional[int]) \u2013 ", "bytes"]}, {"name": "LimitedStream.readlines()", "path": "wsgi/index#werkzeug.wsgi.LimitedStream.readlines", "type": "werkzeug.wsgi", "text": ["Reads a file into a list of strings. It calls readline() until the file is read to the end. It does support the optional size argument if the underlying stream supports it for readline.", "size (Optional[int]) \u2013 ", "List[bytes]"]}, {"name": "LimitedStream.tell()", "path": "wsgi/index#werkzeug.wsgi.LimitedStream.tell", "type": "werkzeug.wsgi", "text": ["Returns the position of the stream.", "New in version 0.9.", "int"]}, {"name": "LintMiddleware", "path": "middleware/lint/index#werkzeug.middleware.lint.LintMiddleware", "type": "werkzeug.middleware.lint", "text": ["Warns about common errors in the WSGI and HTTP behavior of the server and wrapped application. Some of the issues it checks are:", "Error information is emitted using the warnings module.", "app (WSGIApplication) \u2013 The WSGI application to wrap.", "None"]}, {"name": "LocalManager", "path": "local/index#werkzeug.local.LocalManager", "type": "werkzeug.local", "text": ["Local objects cannot manage themselves. For that you need a local manager. You can pass a local manager multiple locals or add them later y appending them to manager.locals. Every time the manager cleans up, it will clean up all the data left in the locals for this context.", "Changed in version 2.0: ident_func is deprecated and will be removed in Werkzeug 2.1.", "Changed in version 0.7: The ident_func parameter was added.", "Changed in version 0.6.1: The release_local() function can be used instead of a manager.", "None", "Manually clean up the data in the locals for this context. Call this at the end of the request or use make_middleware().", "None", "Return the context identifier the local objects use internally for this context. You cannot override this method to change the behavior but use it to link other context local objects (such as SQLAlchemy\u2019s scoped sessions) to the Werkzeug locals.", "Deprecated since version 2.0: Will be removed in Werkzeug 2.1.", "Changed in version 0.7: You can pass a different ident function to the local manager that will then be propagated to all the locals passed to the constructor.", "int", "Wrap a WSGI application so that cleaning up happens after request end.", "app (WSGIApplication) \u2013 ", "WSGIApplication", "Like make_middleware but for decorating functions.", "Example usage:", "The difference to make_middleware is that the function passed will have all the arguments copied from the inner application (name, docstring, module).", "func (WSGIApplication) \u2013 ", "WSGIApplication"]}, {"name": "LocalManager.cleanup()", "path": "local/index#werkzeug.local.LocalManager.cleanup", "type": "werkzeug.local", "text": ["Manually clean up the data in the locals for this context. Call this at the end of the request or use make_middleware().", "None"]}, {"name": "LocalManager.get_ident()", "path": "local/index#werkzeug.local.LocalManager.get_ident", "type": "werkzeug.local", "text": ["Return the context identifier the local objects use internally for this context. You cannot override this method to change the behavior but use it to link other context local objects (such as SQLAlchemy\u2019s scoped sessions) to the Werkzeug locals.", "Deprecated since version 2.0: Will be removed in Werkzeug 2.1.", "Changed in version 0.7: You can pass a different ident function to the local manager that will then be propagated to all the locals passed to the constructor.", "int"]}, {"name": "LocalManager.make_middleware()", "path": "local/index#werkzeug.local.LocalManager.make_middleware", "type": "werkzeug.local", "text": ["Wrap a WSGI application so that cleaning up happens after request end.", "app (WSGIApplication) \u2013 ", "WSGIApplication"]}, {"name": "LocalManager.middleware()", "path": "local/index#werkzeug.local.LocalManager.middleware", "type": "werkzeug.local", "text": ["Like make_middleware but for decorating functions.", "Example usage:", "The difference to make_middleware is that the function passed will have all the arguments copied from the inner application (name, docstring, module).", "func (WSGIApplication) \u2013 ", "WSGIApplication"]}, {"name": "LocalProxy", "path": "local/index#werkzeug.local.LocalProxy", "type": "werkzeug.local", "text": ["A proxy to the object bound to a Local. All operations on the proxy are forwarded to the bound object. If no object is bound, a RuntimeError is raised.", "__repr__ and __class__ are forwarded, so repr(x) and isinstance(x, cls) will look like the proxied object. Use issubclass(type(x), LocalProxy) to check if an object is a proxy.", "Changed in version 2.0: Updated proxied attributes and methods to reflect the current data model.", "Changed in version 0.6.1: The class can be instantiated with a callable.", "Return the current object. This is useful if you want the real object behind the proxy at a time for performance reasons or because you want to pass the object into a different context.", "Any"]}, {"name": "LocalProxy._get_current_object()", "path": "local/index#werkzeug.local.LocalProxy._get_current_object", "type": "werkzeug.local", "text": ["Return the current object. This is useful if you want the real object behind the proxy at a time for performance reasons or because you want to pass the object into a different context.", "Any"]}, {"name": "LocalStack", "path": "local/index#werkzeug.local.LocalStack", "type": "werkzeug.local", "text": ["This class works similar to a Local but keeps a stack of objects instead. This is best explained with an example:", "They can be force released by using a LocalManager or with the release_local() function but the correct way is to pop the item from the stack after using. When the stack is empty it will no longer be bound to the current context (and as such released).", "By calling the stack without arguments it returns a proxy that resolves to the topmost item on the stack.", "New in version 0.6.1.", "None", "Removes the topmost item from the stack, will return the old value or None if the stack was already empty.", "Any", "Pushes a new item to the stack", "obj (Any) \u2013 ", "List[Any]", "The topmost item on the stack. If the stack is empty, None is returned."]}, {"name": "LocalStack.pop()", "path": "local/index#werkzeug.local.LocalStack.pop", "type": "werkzeug.local", "text": ["Removes the topmost item from the stack, will return the old value or None if the stack was already empty.", "Any"]}, {"name": "LocalStack.push()", "path": "local/index#werkzeug.local.LocalStack.push", "type": "werkzeug.local", "text": ["Pushes a new item to the stack", "obj (Any) \u2013 ", "List[Any]"]}, {"name": "make_chunk_iter()", "path": "wsgi/index#werkzeug.wsgi.make_chunk_iter", "type": "werkzeug.wsgi", "text": ["Works like make_line_iter() but accepts a separator which divides chunks. If you want newline based processing you should use make_line_iter() instead as it supports arbitrary newline markers.", "New in version 0.11.10: added support for the cap_at_buffer parameter.", "New in version 0.9: added support for iterators as input stream.", "New in version 0.8.", "Iterator[bytes]"]}, {"name": "make_line_iter()", "path": "wsgi/index#werkzeug.wsgi.make_line_iter", "type": "werkzeug.wsgi", "text": ["Safely iterates line-based over an input stream. If the input stream is not a LimitedStream the limit parameter is mandatory.", "This uses the stream\u2019s read() method internally as opposite to the readline() method that is unsafe and can only be used in violation of the WSGI specification. The same problem applies to the __iter__ function of the input stream which calls readline() without arguments.", "If you need line-by-line processing it\u2019s strongly recommended to iterate over the input stream using this helper function.", "New in version 0.11.10: added support for the cap_at_buffer parameter.", "New in version 0.9: added support for iterators as input stream.", "Changed in version 0.8: This function now ensures that the limit was reached.", "Iterator[bytes]"]}, {"name": "make_ssl_devcert()", "path": "serving/index#werkzeug.serving.make_ssl_devcert", "type": "werkzeug.serving", "text": ["Creates an SSL key for development. This should be used instead of the 'adhoc' key which generates a new cert on each server start. It accepts a path for where it should store the key and cert and either a host or CN. If a host is given it will use the CN *.host/CN=host.", "For more information see run_simple().", "New in version 0.9.", "Tuple[str, str]"]}, {"name": "Map", "path": "routing/index#werkzeug.routing.Map", "type": "werkzeug.routing", "text": ["The map class stores all the URL rules and some configuration parameters. Some of the configuration values are only stored on the Map instance since those affect all rules, others are just defaults and can be overridden for each rule. Note that you have to specify all arguments besides the rules as keyword arguments!", "None", "Changed in version 1.0: If url_scheme is ws or wss, only WebSocket rules will match.", "Changed in version 1.0: Added merge_slashes.", "Changed in version 0.7: Added encoding_errors and host_matching.", "Changed in version 0.5: Added sort_parameters and sort_key.", "The dictionary of converters. This can be modified after the class was created, but will only affect rules added after the modification. If the rules are defined with the list passed to the class, the converters parameter to the constructor has to be used instead.", "Add a new rule or factory to the map and bind it. Requires that the rule is not bound to another map.", "rulefactory (werkzeug.routing.RuleFactory) \u2013 a Rule or RuleFactory", "None", "Return a new MapAdapter with the details specified to the call. Note that script_name will default to '/' if not further specified or None. The server_name at least is a requirement because the HTTP RFC requires absolute URLs for redirects and so all redirect exceptions raised by Werkzeug will contain the full canonical URL.", "If no path_info is passed to match() it will use the default path info passed to bind. While this doesn\u2019t really make sense for manual bind calls, it\u2019s useful if you bind a map to a WSGI environment which already contains the path info.", "subdomain will default to the default_subdomain for this map if no defined. If there is no default_subdomain you cannot use the subdomain feature.", "Changed in version 1.0: If url_scheme is ws or wss, only WebSocket rules will match.", "Changed in version 0.15: path_info defaults to '/' if None.", "Changed in version 0.8: query_args can be a string.", "Changed in version 0.7: Added query_args.", "werkzeug.routing.MapAdapter", "Like bind() but you can pass it an WSGI environment and it will fetch the information from that dictionary. Note that because of limitations in the protocol there is no way to get the current subdomain and real server_name from the environment. If you don\u2019t provide it, Werkzeug will use SERVER_NAME and SERVER_PORT (or HTTP_HOST if provided) as used server_name with disabled subdomain feature.", "If subdomain is None but an environment and a server name is provided it will calculate the current subdomain automatically. Example: server_name is 'example.com' and the SERVER_NAME in the wsgi environ is 'staging.dev.example.com' the calculated subdomain will be 'staging.dev'.", "If the object passed as environ has an environ attribute, the value of this attribute is used instead. This allows you to pass request objects. Additionally PATH_INFO added as a default of the MapAdapter so that you don\u2019t have to pass the path info to the match method.", "Changed in version 1.0.0: If the passed server name specifies port 443, it will match if the incoming scheme is https without a port.", "Changed in version 1.0.0: A warning is shown when the passed server name does not match the incoming WSGI server name.", "Changed in version 0.8: This will no longer raise a ValueError when an unexpected server name was passed.", "Changed in version 0.5: previously this method accepted a bogus calculate_subdomain parameter that did not have any effect. It was removed because of that.", "MapAdapter", "A dict of default converters to be used.", "Iterate over all rules and check if the endpoint expects the arguments provided. This is for example useful if you have some URLs that expect a language code and others that do not and you want to wrap the builder a bit so that the current language code is automatically added if not provided but endpoints expect it.", "bool", "Iterate over all rules or the rules of an endpoint.", "endpoint (Optional[str]) \u2013 if provided only the rules for that endpoint are returned.", "an iterator", "Iterator[werkzeug.routing.Rule]", "The type of lock to use when updating.", "New in version 1.0.", "Called before matching and building to keep the compiled rules in the correct order after things changed.", "None"]}, {"name": "Map.add()", "path": "routing/index#werkzeug.routing.Map.add", "type": "werkzeug.routing", "text": ["Add a new rule or factory to the map and bind it. Requires that the rule is not bound to another map.", "rulefactory (werkzeug.routing.RuleFactory) \u2013 a Rule or RuleFactory", "None"]}, {"name": "Map.bind()", "path": "routing/index#werkzeug.routing.Map.bind", "type": "werkzeug.routing", "text": ["Return a new MapAdapter with the details specified to the call. Note that script_name will default to '/' if not further specified or None. The server_name at least is a requirement because the HTTP RFC requires absolute URLs for redirects and so all redirect exceptions raised by Werkzeug will contain the full canonical URL.", "If no path_info is passed to match() it will use the default path info passed to bind. While this doesn\u2019t really make sense for manual bind calls, it\u2019s useful if you bind a map to a WSGI environment which already contains the path info.", "subdomain will default to the default_subdomain for this map if no defined. If there is no default_subdomain you cannot use the subdomain feature.", "Changed in version 1.0: If url_scheme is ws or wss, only WebSocket rules will match.", "Changed in version 0.15: path_info defaults to '/' if None.", "Changed in version 0.8: query_args can be a string.", "Changed in version 0.7: Added query_args.", "werkzeug.routing.MapAdapter"]}, {"name": "Map.bind_to_environ()", "path": "routing/index#werkzeug.routing.Map.bind_to_environ", "type": "werkzeug.routing", "text": ["Like bind() but you can pass it an WSGI environment and it will fetch the information from that dictionary. Note that because of limitations in the protocol there is no way to get the current subdomain and real server_name from the environment. If you don\u2019t provide it, Werkzeug will use SERVER_NAME and SERVER_PORT (or HTTP_HOST if provided) as used server_name with disabled subdomain feature.", "If subdomain is None but an environment and a server name is provided it will calculate the current subdomain automatically. Example: server_name is 'example.com' and the SERVER_NAME in the wsgi environ is 'staging.dev.example.com' the calculated subdomain will be 'staging.dev'.", "If the object passed as environ has an environ attribute, the value of this attribute is used instead. This allows you to pass request objects. Additionally PATH_INFO added as a default of the MapAdapter so that you don\u2019t have to pass the path info to the match method.", "Changed in version 1.0.0: If the passed server name specifies port 443, it will match if the incoming scheme is https without a port.", "Changed in version 1.0.0: A warning is shown when the passed server name does not match the incoming WSGI server name.", "Changed in version 0.8: This will no longer raise a ValueError when an unexpected server name was passed.", "Changed in version 0.5: previously this method accepted a bogus calculate_subdomain parameter that did not have any effect. It was removed because of that.", "MapAdapter"]}, {"name": "Map.converters", "path": "routing/index#werkzeug.routing.Map.converters", "type": "werkzeug.routing", "text": ["The dictionary of converters. This can be modified after the class was created, but will only affect rules added after the modification. If the rules are defined with the list passed to the class, the converters parameter to the constructor has to be used instead."]}, {"name": "Map.default_converters", "path": "routing/index#werkzeug.routing.Map.default_converters", "type": "werkzeug.routing", "text": ["A dict of default converters to be used."]}, {"name": "Map.is_endpoint_expecting()", "path": "routing/index#werkzeug.routing.Map.is_endpoint_expecting", "type": "werkzeug.routing", "text": ["Iterate over all rules and check if the endpoint expects the arguments provided. This is for example useful if you have some URLs that expect a language code and others that do not and you want to wrap the builder a bit so that the current language code is automatically added if not provided but endpoints expect it.", "bool"]}, {"name": "Map.iter_rules()", "path": "routing/index#werkzeug.routing.Map.iter_rules", "type": "werkzeug.routing", "text": ["Iterate over all rules or the rules of an endpoint.", "endpoint (Optional[str]) \u2013 if provided only the rules for that endpoint are returned.", "an iterator", "Iterator[werkzeug.routing.Rule]"]}, {"name": "Map.lock_class()", "path": "routing/index#werkzeug.routing.Map.lock_class", "type": "werkzeug.routing", "text": ["The type of lock to use when updating.", "New in version 1.0."]}, {"name": "Map.update()", "path": "routing/index#werkzeug.routing.Map.update", "type": "werkzeug.routing", "text": ["Called before matching and building to keep the compiled rules in the correct order after things changed.", "None"]}, {"name": "MapAdapter", "path": "routing/index#werkzeug.routing.MapAdapter", "type": "werkzeug.routing", "text": ["Returned by Map.bind() or Map.bind_to_environ() and does the URL matching and building based on runtime information.", "Returns the valid methods that match for a given path.", "New in version 0.7.", "path_info (Optional[str]) \u2013 ", "Iterable[str]", "Building URLs works pretty much the other way round. Instead of match you call build and pass it the endpoint and a dict of arguments for the placeholders.", "The build function also accepts an argument called force_external which, if you set it to True will force external URLs. Per default external URLs (include the server name) will only be used if the target URL is on a different subdomain.", "Because URLs cannot contain non ASCII data you will always get bytes back. Non ASCII characters are urlencoded with the charset defined on the map instance.", "Additional values are converted to strings and appended to the URL as URL querystring parameters:", "When processing those additional values, lists are furthermore interpreted as multiple values (as per werkzeug.datastructures.MultiDict):", "Passing a MultiDict will also add multiple values:", "If a rule does not exist when building a BuildError exception is raised.", "The build method accepts an argument called method which allows you to specify the method you want to have an URL built for if you have different methods for the same endpoint specified.", "str", "Changed in version 2.0: Added the url_scheme parameter.", "New in version 0.6: Added the append_unknown parameter.", "Does the complete dispatching process. view_func is called with the endpoint and a dict with the values for the view. It should look up the view function, call it, and return a response object or WSGI application. http exceptions are not caught by default so that applications can display nicer error messages by just catching them by hand. If you want to stick with the default error messages you can pass it catch_http_exceptions=True and it will catch the http exceptions.", "Here a small example for the dispatch usage:", "Keep in mind that this method might return exception objects, too, so use Response.force_type to get a response object.", "WSGIApplication", "Figures out the full host name for the given domain part. The domain part is a subdomain in case host matching is disabled or a full host name.", "domain_part (Optional[str]) \u2013 ", "str", "Internally called to make an alias redirect URL.", "str", "The usage is simple: you just pass the match method the current path info as well as the method (which defaults to GET). The following things can then happen:", "If the path info is not passed to the match method the default path info of the map is used (defaults to the root URL if not defined explicitly).", "All of the exceptions raised are subclasses of HTTPException so they can be used as WSGI responses. They will all render generic error or redirect pages.", "Here is a small example for matching:", "And here is what happens on redirect and missing URLs:", "Tuple[Union[str, werkzeug.routing.Rule], Mapping[str, Any]]", "New in version 1.0: Added websocket.", "Changed in version 0.8: query_args can be a string.", "New in version 0.7: Added query_args.", "New in version 0.6: Added return_rule.", "Test if a rule would match. Works like match but returns True if the URL matches, or False if it does not exist.", "bool"]}, {"name": "MapAdapter.allowed_methods()", "path": "routing/index#werkzeug.routing.MapAdapter.allowed_methods", "type": "werkzeug.routing", "text": ["Returns the valid methods that match for a given path.", "New in version 0.7.", "path_info (Optional[str]) \u2013 ", "Iterable[str]"]}, {"name": "MapAdapter.build()", "path": "routing/index#werkzeug.routing.MapAdapter.build", "type": "werkzeug.routing", "text": ["Building URLs works pretty much the other way round. Instead of match you call build and pass it the endpoint and a dict of arguments for the placeholders.", "The build function also accepts an argument called force_external which, if you set it to True will force external URLs. Per default external URLs (include the server name) will only be used if the target URL is on a different subdomain.", "Because URLs cannot contain non ASCII data you will always get bytes back. Non ASCII characters are urlencoded with the charset defined on the map instance.", "Additional values are converted to strings and appended to the URL as URL querystring parameters:", "When processing those additional values, lists are furthermore interpreted as multiple values (as per werkzeug.datastructures.MultiDict):", "Passing a MultiDict will also add multiple values:", "If a rule does not exist when building a BuildError exception is raised.", "The build method accepts an argument called method which allows you to specify the method you want to have an URL built for if you have different methods for the same endpoint specified.", "str", "Changed in version 2.0: Added the url_scheme parameter.", "New in version 0.6: Added the append_unknown parameter."]}, {"name": "MapAdapter.dispatch()", "path": "routing/index#werkzeug.routing.MapAdapter.dispatch", "type": "werkzeug.routing", "text": ["Does the complete dispatching process. view_func is called with the endpoint and a dict with the values for the view. It should look up the view function, call it, and return a response object or WSGI application. http exceptions are not caught by default so that applications can display nicer error messages by just catching them by hand. If you want to stick with the default error messages you can pass it catch_http_exceptions=True and it will catch the http exceptions.", "Here a small example for the dispatch usage:", "Keep in mind that this method might return exception objects, too, so use Response.force_type to get a response object.", "WSGIApplication"]}, {"name": "MapAdapter.get_host()", "path": "routing/index#werkzeug.routing.MapAdapter.get_host", "type": "werkzeug.routing", "text": ["Figures out the full host name for the given domain part. The domain part is a subdomain in case host matching is disabled or a full host name.", "domain_part (Optional[str]) \u2013 ", "str"]}, {"name": "MapAdapter.make_alias_redirect_url()", "path": "routing/index#werkzeug.routing.MapAdapter.make_alias_redirect_url", "type": "werkzeug.routing", "text": ["Internally called to make an alias redirect URL.", "str"]}, {"name": "MapAdapter.match()", "path": "routing/index#werkzeug.routing.MapAdapter.match", "type": "werkzeug.routing", "text": ["The usage is simple: you just pass the match method the current path info as well as the method (which defaults to GET). The following things can then happen:", "If the path info is not passed to the match method the default path info of the map is used (defaults to the root URL if not defined explicitly).", "All of the exceptions raised are subclasses of HTTPException so they can be used as WSGI responses. They will all render generic error or redirect pages.", "Here is a small example for matching:", "And here is what happens on redirect and missing URLs:", "Tuple[Union[str, werkzeug.routing.Rule], Mapping[str, Any]]", "New in version 1.0: Added websocket.", "Changed in version 0.8: query_args can be a string.", "New in version 0.7: Added query_args.", "New in version 0.6: Added return_rule."]}, {"name": "MapAdapter.test()", "path": "routing/index#werkzeug.routing.MapAdapter.test", "type": "werkzeug.routing", "text": ["Test if a rule would match. Works like match but returns True if the URL matches, or False if it does not exist.", "bool"]}, {"name": "Middleware", "path": "middleware/index", "type": "Other", "text": ["A WSGI middleware is a WSGI application that wraps another application in order to observe or change its behavior. Werkzeug provides some middleware for common use cases.", "The interactive debugger is also a middleware that can be applied manually, although it is typically used automatically with the development server."]}, {"name": "MIMEAccept", "path": "datastructures/index#werkzeug.datastructures.MIMEAccept", "type": "werkzeug.datastructures", "text": ["Like Accept but with special methods and behavior for mimetypes.", "True if this object accepts HTML.", "True if this object accepts JSON.", "True if this object accepts XHTML."]}, {"name": "mod_wsgi (Apache)", "path": "deployment/mod_wsgi/index", "type": "Other", "text": ["If you are using the Apache webserver you should consider using mod_wsgi.", "If you don\u2019t have mod_wsgi installed yet you have to either install it using a package manager or compile it yourself.", "The mod_wsgi installation instructions cover installation instructions for source installations on UNIX systems.", "If you are using ubuntu / debian you can apt-get it and activate it as follows:", "On FreeBSD install mod_wsgi by compiling the www/mod_wsgi port or by using pkg_add:", "If you are using pkgsrc you can install mod_wsgi by compiling the www/ap2-wsgi package.", "If you encounter segfaulting child processes after the first apache reload you can safely ignore them. Just restart the server.", "To run your application you need a yourapplication.wsgi file. This file contains the code mod_wsgi is executing on startup to get the application object. The object called application in that file is then used as application.", "For most applications the following file should be sufficient:", "If you don\u2019t have a factory function for application creation but a singleton instance you can directly import that one as application.", "Store that file somewhere where you will find it again (eg: /var/www/yourapplication) and make sure that yourapplication and all the libraries that are in use are on the python load path. If you don\u2019t want to install it system wide consider using a virtual python instance.", "The last thing you have to do is to create an Apache configuration file for your application. In this example we are telling mod_wsgi to execute the application under a different user for security reasons:"]}, {"name": "MultiDict", "path": "datastructures/index#werkzeug.datastructures.MultiDict", "type": "werkzeug.datastructures", "text": ["A MultiDict is a dictionary subclass customized to deal with multiple values for the same key which is for example used by the parsing functions in the wrappers. This is necessary because some HTML form elements pass multiple values for the same key.", "MultiDict implements all standard dictionary methods. Internally, it saves all values for a key as a list, but the standard dict access methods will only return the first value for a key. If you want to gain access to the other values, too, you have to use the list methods as explained below.", "Basic Usage:", "It behaves like a normal dict thus all dict functions will only return the first value when multiple values for one key are found.", "From Werkzeug 0.3 onwards, the KeyError raised by this class is also a subclass of the BadRequest HTTP exception and will render a page for a 400 BAD REQUEST if caught in a catch-all for HTTP exceptions.", "A MultiDict can be constructed from an iterable of (key, value) tuples, a dict, a MultiDict or from Werkzeug 0.2 onwards some keyword parameters.", "mapping \u2013 the initial value for the MultiDict. Either a regular dict, an iterable of (key, value) tuples or None.", "Adds a new value for the key.", "New in version 0.6.", "Return a shallow copy of this object.", "Return a deep copy of this object.", "Create a new dictionary with keys from iterable and values set to value.", "Return the default value if the requested data doesn\u2019t exist. If type is provided and is a callable it should convert the value, return it or raise a ValueError if that is not possible. In this case the function will return the default as if the value was not found:", "Return the list of items for a given key. If that key is not in the MultiDict, the return value will be an empty list. Just like get, getlist accepts a type parameter. All items will be converted with the callable defined there.", "a list of all the values for the key.", "Return an iterator of (key, value) pairs.", "multi \u2013 If set to True the iterator returned will have a pair for each value of each key. Otherwise it will only contain pairs for the first value of each key.", "Return a iterator of (key, values) pairs, where values is the list of all values associated with the key.", "Return an iterator of all values associated with a key. Zipping keys() and this is the same as calling lists():", "Pop the first item for a list on the dict. Afterwards the key is removed from the dict, so additional values are discarded:", "Pop an item from the dict.", "Pop a (key, list) tuple from the dict.", "Pop the list for a key from the dict. If the key is not in the dict an empty list is returned.", "Changed in version 0.5: If the key does no longer exist a list is returned instead of raising an error.", "Returns the value for the key if it is in the dict, otherwise it returns default and sets that value for key.", "Remove the old values for a key and add new ones. Note that the list you pass the values in will be shallow-copied before it is inserted in the dictionary.", "Like setdefault but sets multiple values. The list returned is not a copy, but the list that is actually used internally. This means that you can put new values into the dict by appending items to the list:", "a list", "Return the contents as regular dict. If flat is True the returned dict will only have the first item present, if flat is False all values will be returned as lists.", "flat \u2013 If set to False the dict returned will have lists with all the values in it. Otherwise it will only contain the first value for each key.", "a dict", "update() extends rather than replaces existing key lists:", "If the value list for a key in other_dict is empty, no new values will be added to the dict and the key will not be created:", "Returns an iterator of the first value on every key\u2019s value list."]}, {"name": "MultiDict.add()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.add", "type": "werkzeug.datastructures", "text": ["Adds a new value for the key.", "New in version 0.6."]}, {"name": "MultiDict.clear()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.clear", "type": "werkzeug.datastructures", "text": []}, {"name": "MultiDict.copy()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.copy", "type": "werkzeug.datastructures", "text": ["Return a shallow copy of this object."]}, {"name": "MultiDict.deepcopy()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.deepcopy", "type": "werkzeug.datastructures", "text": ["Return a deep copy of this object."]}, {"name": "MultiDict.fromkeys()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.fromkeys", "type": "werkzeug.datastructures", "text": ["Create a new dictionary with keys from iterable and values set to value."]}, {"name": "MultiDict.get()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.get", "type": "werkzeug.datastructures", "text": ["Return the default value if the requested data doesn\u2019t exist. If type is provided and is a callable it should convert the value, return it or raise a ValueError if that is not possible. In this case the function will return the default as if the value was not found:"]}, {"name": "MultiDict.getlist()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.getlist", "type": "werkzeug.datastructures", "text": ["Return the list of items for a given key. If that key is not in the MultiDict, the return value will be an empty list. Just like get, getlist accepts a type parameter. All items will be converted with the callable defined there.", "a list of all the values for the key."]}, {"name": "MultiDict.items()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.items", "type": "werkzeug.datastructures", "text": ["Return an iterator of (key, value) pairs.", "multi \u2013 If set to True the iterator returned will have a pair for each value of each key. Otherwise it will only contain pairs for the first value of each key."]}, {"name": "MultiDict.keys()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.keys", "type": "werkzeug.datastructures", "text": []}, {"name": "MultiDict.lists()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.lists", "type": "werkzeug.datastructures", "text": ["Return a iterator of (key, values) pairs, where values is the list of all values associated with the key."]}, {"name": "MultiDict.listvalues()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.listvalues", "type": "werkzeug.datastructures", "text": ["Return an iterator of all values associated with a key. Zipping keys() and this is the same as calling lists():"]}, {"name": "MultiDict.pop()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.pop", "type": "werkzeug.datastructures", "text": ["Pop the first item for a list on the dict. Afterwards the key is removed from the dict, so additional values are discarded:"]}, {"name": "MultiDict.popitem()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.popitem", "type": "werkzeug.datastructures", "text": ["Pop an item from the dict."]}, {"name": "MultiDict.popitemlist()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.popitemlist", "type": "werkzeug.datastructures", "text": ["Pop a (key, list) tuple from the dict."]}, {"name": "MultiDict.poplist()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.poplist", "type": "werkzeug.datastructures", "text": ["Pop the list for a key from the dict. If the key is not in the dict an empty list is returned.", "Changed in version 0.5: If the key does no longer exist a list is returned instead of raising an error."]}, {"name": "MultiDict.setdefault()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.setdefault", "type": "werkzeug.datastructures", "text": ["Returns the value for the key if it is in the dict, otherwise it returns default and sets that value for key."]}, {"name": "MultiDict.setlist()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.setlist", "type": "werkzeug.datastructures", "text": ["Remove the old values for a key and add new ones. Note that the list you pass the values in will be shallow-copied before it is inserted in the dictionary."]}, {"name": "MultiDict.setlistdefault()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.setlistdefault", "type": "werkzeug.datastructures", "text": ["Like setdefault but sets multiple values. The list returned is not a copy, but the list that is actually used internally. This means that you can put new values into the dict by appending items to the list:", "a list"]}, {"name": "MultiDict.to_dict()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.to_dict", "type": "werkzeug.datastructures", "text": ["Return the contents as regular dict. If flat is True the returned dict will only have the first item present, if flat is False all values will be returned as lists.", "flat \u2013 If set to False the dict returned will have lists with all the values in it. Otherwise it will only contain the first value for each key.", "a dict"]}, {"name": "MultiDict.update()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.update", "type": "werkzeug.datastructures", "text": ["update() extends rather than replaces existing key lists:", "If the value list for a key in other_dict is empty, no new values will be added to the dict and the key will not be created:"]}, {"name": "MultiDict.values()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.values", "type": "werkzeug.datastructures", "text": ["Returns an iterator of the first value on every key\u2019s value list."]}, {"name": "OrderedMultiDict", "path": "datastructures/index#werkzeug.datastructures.OrderedMultiDict", "type": "werkzeug.datastructures", "text": ["Works like a regular MultiDict but preserves the order of the fields. To convert the ordered multi dict into a list you can use the items() method and pass it multi=True.", "In general an OrderedMultiDict is an order of magnitude slower than a MultiDict.", "note", "Due to a limitation in Python you cannot convert an ordered multi dict into a regular dict by using dict(multidict). Instead you have to use the to_dict() method, otherwise the internal bucket objects are exposed."]}, {"name": "parse_accept_header()", "path": "http/index#werkzeug.http.parse_accept_header", "type": "werkzeug.http", "text": ["Parses an HTTP Accept-* header. This does not implement a complete valid algorithm but one that supports at least value and quality extraction.", "Returns a new Accept object (basically a list of (value, quality) tuples sorted by the quality with some additional accessor methods).", "The second parameter can be a subclass of Accept that is created with the parsed values and returned.", "an instance of cls.", "werkzeug.http._TAnyAccept"]}, {"name": "parse_authorization_header()", "path": "http/index#werkzeug.http.parse_authorization_header", "type": "werkzeug.http", "text": ["Parse an HTTP basic/digest authorization header transmitted by the web browser. The return value is either None if the header was invalid or not given, otherwise an Authorization object.", "value (Optional[str]) \u2013 the authorization header to parse.", "a Authorization object or None.", "Optional[werkzeug.datastructures.Authorization]"]}, {"name": "parse_cache_control_header()", "path": "http/index#werkzeug.http.parse_cache_control_header", "type": "werkzeug.http", "text": ["Parse a cache control header. The RFC differs between response and request cache control, this method does not. It\u2019s your responsibility to not use the wrong control statements.", "New in version 0.5: The cls was added. If not specified an immutable RequestCacheControl is returned.", "a cls object.", "werkzeug.http._TAnyCC"]}, {"name": "parse_content_range_header()", "path": "http/index#werkzeug.http.parse_content_range_header", "type": "werkzeug.http", "text": ["Parses a range header into a ContentRange object or None if parsing is not possible.", "New in version 0.7.", "Optional[werkzeug.datastructures.ContentRange]"]}, {"name": "parse_cookie()", "path": "http/index#werkzeug.http.parse_cookie", "type": "werkzeug.http", "text": ["Parse a cookie from a string or WSGI environ.", "The same key can be provided multiple times, the values are stored in-order. The default MultiDict will have the first value first, and all values can be retrieved with MultiDict.getlist().", "ds.MultiDict[str, str]", "Changed in version 1.0.0: Returns a MultiDict instead of a TypeConversionDict.", "Changed in version 0.5: Returns a TypeConversionDict instead of a regular dict. The cls parameter was added."]}, {"name": "parse_date()", "path": "http/index#werkzeug.http.parse_date", "type": "werkzeug.http", "text": ["Parse an RFC 2822 date into a timezone-aware datetime.datetime object, or None if parsing fails.", "This is a wrapper for email.utils.parsedate_to_datetime(). It returns None if parsing fails instead of raising an exception, and always returns a timezone-aware datetime object. If the string doesn\u2019t have timezone information, it is assumed to be UTC.", "value (Optional[str]) \u2013 A string with a supported date format.", "Optional[datetime.datetime]", "Changed in version 2.0: Return a timezone-aware datetime object. Use email.utils.parsedate_to_datetime."]}, {"name": "parse_dict_header()", "path": "http/index#werkzeug.http.parse_dict_header", "type": "werkzeug.http", "text": ["Parse lists of key, value pairs as described by RFC 2068 Section 2 and convert them into a python dict (or any other mapping object created from the type with a dict like interface provided by the cls argument):", "If there is no value for a key it will be None:", "To create a header from the dict again, use the dump_header() function.", "Changed in version 0.9: Added support for cls argument.", "an instance of cls", "Dict[str, str]"]}, {"name": "parse_etags()", "path": "http/index#werkzeug.http.parse_etags", "type": "werkzeug.http", "text": ["Parse an etag header.", "value (Optional[str]) \u2013 the tag header to parse", "an ETags object.", "werkzeug.datastructures.ETags"]}, {"name": "parse_form_data()", "path": "http/index#werkzeug.formparser.parse_form_data", "type": "werkzeug.formparser", "text": ["Parse the form data in the environ and return it as tuple in the form (stream, form, files). You should only call this method if the transport method is POST, PUT, or PATCH.", "If the mimetype of the data transmitted is multipart/form-data the files multidict will be filled with FileStorage objects. If the mimetype is unknown the input stream is wrapped and returned as first argument, else the stream is empty.", "This is a shortcut for the common usage of FormDataParser.", "Have a look at Dealing with Request Data for more details.", "New in version 0.5.1: The optional silent flag was added.", "New in version 0.5: The max_form_memory_size, max_content_length and cls parameters were added.", "A tuple in the form (stream, form, files).", "t_parse_result"]}, {"name": "parse_if_range_header()", "path": "http/index#werkzeug.http.parse_if_range_header", "type": "werkzeug.http", "text": ["Parses an if-range header which can be an etag or a date. Returns a IfRange object.", "Changed in version 2.0: If the value represents a datetime, it is timezone-aware.", "New in version 0.7.", "value (Optional[str]) \u2013 ", "werkzeug.datastructures.IfRange"]}, {"name": "parse_list_header()", "path": "http/index#werkzeug.http.parse_list_header", "type": "werkzeug.http", "text": ["Parse lists as described by RFC 2068 Section 2.", "In particular, parse comma-separated lists where the elements of the list may include quoted-strings. A quoted-string could contain a comma. A non-quoted string could have quotes in the middle. Quotes are removed automatically after parsing.", "It basically works like parse_set_header() just that items may appear multiple times and case sensitivity is preserved.", "The return value is a standard list:", "To create a header from the list again, use the dump_header() function.", "value (str) \u2013 a string with a list header.", "list", "List[str]"]}, {"name": "parse_options_header()", "path": "http/index#werkzeug.http.parse_options_header", "type": "werkzeug.http", "text": ["Parse a Content-Type like header into a tuple with the content type and the options:", "This should not be used to parse Cache-Control like headers that use a slightly different format. For these headers use the parse_dict_header() function.", "Changed in version 0.15: RFC 2231 parameter continuations are handled.", "New in version 0.5.", "(mimetype, options) or (mimetype, options, mimetype, options, \u2026) if multiple=True", "Union[Tuple[str, Dict[str, str]], Tuple[Any, \u2026]]"]}, {"name": "parse_range_header()", "path": "http/index#werkzeug.http.parse_range_header", "type": "werkzeug.http", "text": ["Parses a range header into a Range object. If the header is missing or malformed None is returned. ranges is a list of (start, stop) tuples where the ranges are non-inclusive.", "New in version 0.7.", "Optional[werkzeug.datastructures.Range]"]}, {"name": "parse_set_header()", "path": "http/index#werkzeug.http.parse_set_header", "type": "werkzeug.http", "text": ["Parse a set-like header and return a HeaderSet object:", "The return value is an object that treats the items case-insensitively and keeps the order of the items:", "To create a header from the HeaderSet again, use the dump_header() function.", "a HeaderSet", "werkzeug.datastructures.HeaderSet"]}, {"name": "parse_www_authenticate_header()", "path": "http/index#werkzeug.http.parse_www_authenticate_header", "type": "werkzeug.http", "text": ["Parse an HTTP WWW-Authenticate header into a WWWAuthenticate object.", "a WWWAuthenticate object.", "werkzeug.datastructures.WWWAuthenticate"]}, {"name": "PathConverter", "path": "routing/index#werkzeug.routing.PathConverter", "type": "werkzeug.routing", "text": ["Like the default UnicodeConverter, but it also matches slashes. This is useful for wikis and similar applications:", "None"]}, {"name": "pbkdf2_bin()", "path": "utils/index#werkzeug.security.pbkdf2_bin", "type": "werkzeug.security", "text": ["Returns a binary digest for the PBKDF2 hash algorithm of data with the given salt. It iterates iterations times and produces a key of keylen bytes. By default, SHA-256 is used as hash function; a different hashlib hashfunc can be provided.", "bytes", "Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use hashlib.pbkdf2_hmac() instead.", "New in version 0.9."]}, {"name": "pbkdf2_hex()", "path": "utils/index#werkzeug.security.pbkdf2_hex", "type": "werkzeug.security", "text": ["Like pbkdf2_bin(), but returns a hex-encoded string.", "str", "Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use hashlib.pbkdf2_hmac() instead.", "New in version 0.9."]}, {"name": "peek_path_info()", "path": "wsgi/index#werkzeug.wsgi.peek_path_info", "type": "werkzeug.wsgi", "text": ["Returns the next segment on the PATH_INFO or None if there is none. Works like pop_path_info() without modifying the environment:", "If the charset is set to None bytes are returned.", "Changed in version 0.9: The path is now decoded and a charset and encoding parameter can be provided.", "New in version 0.5.", "Optional[str]"]}, {"name": "pop_path_info()", "path": "wsgi/index#werkzeug.wsgi.pop_path_info", "type": "werkzeug.wsgi", "text": ["Removes and returns the next segment of PATH_INFO, pushing it onto SCRIPT_NAME. Returns None if there is nothing left on PATH_INFO.", "If the charset is set to None bytes are returned.", "If there are empty segments ('/foo//bar) these are ignored but properly pushed to the SCRIPT_NAME:", "Changed in version 0.9: The path is now decoded and a charset and encoding parameter can be provided.", "New in version 0.5.", "Optional[str]"]}, {"name": "ProfilerMiddleware", "path": "middleware/profiler/index#werkzeug.middleware.profiler.ProfilerMiddleware", "type": "werkzeug.middleware.profiler", "text": ["Wrap a WSGI application and profile the execution of each request. Responses are buffered so that timings are more exact.", "If stream is given, pstats.Stats are written to it after each request. If profile_dir is given, cProfile data files are saved to that directory, one file per request.", "The filename can be customized by passing filename_format. If it is a string, it will be formatted using str.format() with the following fields available:", "If it is a callable, it will be called with the WSGI environ dict and should return a filename.", "None", "Changed in version 0.15: Stats are written even if profile_dir is given, and can be disable by passing stream=None.", "New in version 0.15: Added filename_format.", "New in version 0.9: Added restrictions and profile_dir."]}, {"name": "ProxyFix", "path": "middleware/proxy_fix/index#werkzeug.middleware.proxy_fix.ProxyFix", "type": "werkzeug.middleware.proxy_fix", "text": ["Adjust the WSGI environ based on X-Forwarded- that proxies in front of the application may set.", "You must tell the middleware how many proxies set each header so it knows what values to trust. It is a security issue to trust values that came from the client rather than a proxy.", "The original values of the headers are stored in the WSGI environ as werkzeug.proxy_fix.orig, a dict.", "None", "Changed in version 1.0: Deprecated code has been removed:", "Changed in version 0.15: All headers support multiple values. The num_proxies argument is deprecated. Each header is configured with a separate number of trusted proxies.", "Changed in version 0.15: Original WSGI environ values are stored in the werkzeug.proxy_fix.orig dict. orig_remote_addr, orig_wsgi_url_scheme, and orig_http_host are deprecated and will be removed in 1.0.", "Changed in version 0.15: Support X-Forwarded-Port and X-Forwarded-Prefix.", "Changed in version 0.15: X-Forwarded-Host and X-Forwarded-Port modify SERVER_NAME and SERVER_PORT."]}, {"name": "ProxyMiddleware", "path": "middleware/http_proxy/index#werkzeug.middleware.http_proxy.ProxyMiddleware", "type": "werkzeug.middleware.http_proxy", "text": ["Proxy requests under a path to an external server, routing other requests to the app.", "This middleware can only proxy HTTP requests, as HTTP is the only protocol handled by the WSGI server. Other protocols, such as WebSocket requests, cannot be proxied at this layer. This should only be used for development, in production a real proxy server should be used.", "The middleware takes a dict mapping a path prefix to a dict describing the host to be proxied to:", "Each host has the following options:", "The target URL to dispatch to. This is required.", "Whether to remove the prefix from the URL before dispatching it to the target. The default is False.", "The host header is automatically rewritten to the URL of the target.", "The host header is unmodified from the client request.", "The host header is overwritten with the value.", "A dictionary of headers to be sent with the request to the target. The default is {}.", "A ssl.SSLContext defining how to verify requests if the target is HTTPS. The default is None.", "In the example above, everything under \"/static/\" is proxied to the server on port 5001. The host header is rewritten to the target, and the \"/static/\" prefix is removed from the URLs.", "None", "New in version 0.14."]}, {"name": "Quickstart", "path": "quickstart/index", "type": "Other", "text": ["This part of the documentation shows how to use the most important parts of Werkzeug. It\u2019s intended as a starting point for developers with basic understanding of PEP 3333 (WSGI) and RFC 2616 (HTTP)."]}, {"name": "quote_etag()", "path": "http/index#werkzeug.http.quote_etag", "type": "werkzeug.http", "text": ["Quote an etag.", "str"]}, {"name": "quote_header_value()", "path": "http/index#werkzeug.http.quote_header_value", "type": "werkzeug.http", "text": ["Quote a header value if necessary.", "New in version 0.5.", "str"]}, {"name": "Range", "path": "datastructures/index#werkzeug.datastructures.Range", "type": "werkzeug.datastructures", "text": ["Represents a Range header. All methods only support only bytes as the unit. Stores a list of ranges if given, but the methods only work if only one range is provided.", "ValueError \u2013 If the ranges provided are invalid.", "Changed in version 0.15: The ranges passed in are validated.", "New in version 0.7.", "Creates a ContentRange object from the current range and given content length.", "If the range is for bytes, the length is not None and there is exactly one range and it is satisfiable it returns a (start, stop) tuple, otherwise None.", "A list of (begin, end) tuples for the range header provided. The ranges are non-inclusive.", "Converts the object into Content-Range HTTP header, based on given length", "Converts the object back into an HTTP header.", "The units of this range. Usually \u201cbytes\u201d."]}, {"name": "Range.make_content_range()", "path": "datastructures/index#werkzeug.datastructures.Range.make_content_range", "type": "werkzeug.datastructures", "text": ["Creates a ContentRange object from the current range and given content length."]}, {"name": "Range.ranges", "path": "datastructures/index#werkzeug.datastructures.Range.ranges", "type": "werkzeug.datastructures", "text": ["A list of (begin, end) tuples for the range header provided. The ranges are non-inclusive."]}, {"name": "Range.range_for_length()", "path": "datastructures/index#werkzeug.datastructures.Range.range_for_length", "type": "werkzeug.datastructures", "text": ["If the range is for bytes, the length is not None and there is exactly one range and it is satisfiable it returns a (start, stop) tuple, otherwise None."]}, {"name": "Range.to_content_range_header()", "path": "datastructures/index#werkzeug.datastructures.Range.to_content_range_header", "type": "werkzeug.datastructures", "text": ["Converts the object into Content-Range HTTP header, based on given length"]}, {"name": "Range.to_header()", "path": "datastructures/index#werkzeug.datastructures.Range.to_header", "type": "werkzeug.datastructures", "text": ["Converts the object back into an HTTP header."]}, {"name": "Range.units", "path": "datastructures/index#werkzeug.datastructures.Range.units", "type": "werkzeug.datastructures", "text": ["The units of this range. Usually \u201cbytes\u201d."]}, {"name": "redirect()", "path": "utils/index#werkzeug.utils.redirect", "type": "werkzeug.utils", "text": ["Returns a response object (a WSGI application) that, if called, redirects the client to the target location. Supported codes are 301, 302, 303, 305, 307, and 308. 300 is not supported because it\u2019s not a real redirect and 304 because it\u2019s the answer for a request with a request with defined If-Modified-Since headers.", "New in version 0.10: The class used for the Response object can now be passed in.", "New in version 0.6: The location can now be a unicode string that is encoded using the iri_to_uri() function.", "Response"]}, {"name": "release_local()", "path": "local/index#werkzeug.local.release_local", "type": "werkzeug.local", "text": ["Releases the contents of the local for the current context. This makes it possible to use locals without a manager.", "Example:", "With this function one can release Local objects as well as LocalStack objects. However it is not possible to release data held by proxies that way, one always has to retain a reference to the underlying local object in order to be able to release it.", "New in version 0.6.1.", "local (Union[werkzeug.local.Local, werkzeug.local.LocalStack]) \u2013 ", "None"]}, {"name": "remove_entity_headers()", "path": "http/index#werkzeug.http.remove_entity_headers", "type": "werkzeug.http", "text": ["Remove all entity headers from a list or Headers object. This operation works in-place. Expires and Content-Location headers are by default not removed. The reason for this is RFC 2616 section 10.3.5 which specifies some entity headers that should be sent.", "Changed in version 0.5: added allowed parameter.", "None"]}, {"name": "remove_hop_by_hop_headers()", "path": "http/index#werkzeug.http.remove_hop_by_hop_headers", "type": "werkzeug.http", "text": ["Remove all HTTP/1.1 \u201cHop-by-Hop\u201d headers from a list or Headers object. This operation works in-place.", "New in version 0.5.", "headers (Union[werkzeug.datastructures.Headers, List[Tuple[str, str]]]) \u2013 a list or Headers object.", "None"]}, {"name": "Request", "path": "wrappers/index#werkzeug.wrappers.Request", "type": "werkzeug.wrappers", "text": ["Represents an incoming WSGI HTTP request, with headers and body taken from the WSGI environment. Has properties and methods for using the functionality defined by various HTTP specs. The data in requests object is read-only.", "Text data is assumed to use UTF-8 encoding, which should be true for the vast majority of modern clients. Using an encoding set by the client is unsafe in Python due to extra encodings it provides, such as zip. To change the assumed encoding, subclass and replace charset.", "None", "Changed in version 2.0: Combine BaseRequest and mixins into a single Request class. Using the old classes is deprecated and will be removed in Werkzeug 2.1.", "Changed in version 0.5: Read-only mode is enforced with immutable classes for all data.", "Called to get a stream for the file upload.", "This must provide a file-like class with read(), readline() and seek() methods that is both writeable and readable.", "The default implementation returns a temporary file if the total content length is higher than 500KB. Because many browsers do not provide a content length for the files only the total content length matters.", "BinaryIO", "List of charsets this client supports as CharsetAccept object.", "List of encodings this client accepts. Encodings in a HTTP term are compression encodings such as gzip. For charsets have a look at accept_charset.", "List of languages this client accepts as LanguageAccept object.", "List of mimetypes this client supports as MIMEAccept object.", "Sent with a preflight request to indicate which headers will be sent with the cross origin request. Set access_control_allow_headers on the response to indicate which headers are allowed.", "Sent with a preflight request to indicate which method will be used for the cross origin request. Set access_control_allow_methods on the response to indicate which methods are allowed.", "If a forwarded header exists this is a list of all ip addresses from the client ip to the last proxy server.", "Decorate a function as responder that accepts the request as the last argument. This works like the responder() decorator but the function is passed the request object as the last argument and the request object will be closed automatically:", "As of Werkzeug 0.14 HTTP exceptions are automatically caught and converted to responses instead of failing.", "f (Callable[[Request], WSGIApplication]) \u2013 the WSGI callable to decorate", "a new WSGI callable", "WSGIApplication", "The parsed URL parameters (the part in the URL after the question mark).", "By default an ImmutableMultiDict is returned from this function. This can be changed by setting parameter_storage_class to a different type. This might be necessary if the order of the form data is important.", "The Authorization object in parsed form.", "Like url but without the query string.", "A RequestCacheControl object for the incoming cache control headers.", "Closes associated resources of this request object. This closes all file handles explicitly. You can also use the request object in a with statement which will automatically close it.", "New in version 0.9.", "None", "The Content-Encoding entity-header field is used as a modifier to the media-type. When present, its value indicates what additional content codings have been applied to the entity-body, and thus what decoding mechanisms must be applied in order to obtain the media-type referenced by the Content-Type header field.", "New in version 0.9.", "The Content-Length entity-header field indicates the size of the entity-body in bytes or, in the case of the HEAD method, the size of the entity-body that would have been sent had the request been a GET.", "The Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest of the entity-body for the purpose of providing an end-to-end message integrity check (MIC) of the entity-body. (Note: a MIC is good for detecting accidental modification of the entity-body in transit, but is not proof against malicious attacks.)", "New in version 0.9.", "The Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of the HEAD method, the media type that would have been sent had the request been a GET.", "A dict with the contents of all cookies transmitted with the request.", "Contains the incoming request data as string in case it came with a mimetype Werkzeug does not handle.", "The Date general-header field represents the date and time at which the message was originated, having the same semantics as orig-date in RFC 822.", "Changed in version 2.0: The datetime object is timezone-aware.", "alias of werkzeug.datastructures.ImmutableMultiDict", "Disable the data property to avoid reading from the input stream.", "Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Create the request with shallow=True instead.", "New in version 0.9.", "The WSGI environment containing HTTP headers and information from the WSGI server.", "MultiDict object containing all uploaded files. Each key in files is the name from the <input type=\"file\" name=\"\">. Each value in files is a Werkzeug FileStorage object.", "It basically behaves like a standard file object you know from Python, with the difference that it also has a save() function that can store the file on the filesystem.", "Note that files will only contain data if the request method was POST, PUT or PATCH and the <form> that posted to the request had enctype=\"multipart/form-data\". It will be empty otherwise.", "See the MultiDict / FileStorage documentation for more details about the used data structure.", "The form parameters. By default an ImmutableMultiDict is returned from this function. This can be changed by setting parameter_storage_class to a different type. This might be necessary if the order of the form data is important.", "Please keep in mind that file uploads will not end up here, but instead in the files attribute.", "Changed in version 0.9: Previous to Werkzeug 0.9 this would only contain form data for POST and PUT requests.", "alias of werkzeug.formparser.FormDataParser", "Create a new request object based on the values provided. If environ is given missing values are filled from there. This method is useful for small scripts when you need to simulate a request from an URL. Do not use this method for unittesting, there is a full featured client object (Client) that allows to create multipart requests, support for cookies etc.", "This accepts the same options as the EnvironBuilder.", "Changed in version 0.5: This method now accepts the same arguments as EnvironBuilder. Because of this the environ parameter is now called environ_overrides.", "request object", "werkzeug.wrappers.request.Request", "Requested path, including the query string.", "This reads the buffered incoming data from the client into one bytes object. By default this is cached but that behavior can be changed by setting cache to False.", "Usually it\u2019s a bad idea to call this method without checking the content length first as a client could send dozens of megabytes or more to cause memory problems on the server.", "Note that if the form data was already parsed this method will not return anything as form data parsing does not cache the data like this method does. To implicitly invoke form data parsing function set parse_form_data to True. When this is done the return value of this method will be an empty string if the form parser handles the data. This generally is not necessary as if the whole data is cached (which is the default) the form parser will used the cached data to parse the form data. Please be generally aware of checking the content length first in any case before calling this method to avoid exhausting server memory.", "If as_text is set to True the return value will be a decoded string.", "New in version 0.9.", "Union[bytes, str]", "Parse data as JSON.", "If the mimetype does not indicate JSON (application/json, see is_json()), this returns None.", "If parsing fails, on_json_loading_failed() is called and its return value is used as the return value.", "Optional[Any]", "The headers received with the request.", "The host name the request was made to, including the port if it\u2019s non-standard. Validated with trusted_hosts.", "The request URL scheme and host only.", "An object containing all the etags in the If-Match header.", "ETags", "The parsed If-Modified-Since header as a datetime object.", "Changed in version 2.0: The datetime object is timezone-aware.", "An object containing all the etags in the If-None-Match header.", "ETags", "The parsed If-Range header.", "Changed in version 2.0: IfRange.date is timezone-aware.", "New in version 0.7.", "The parsed If-Unmodified-Since header as a datetime object.", "Changed in version 2.0: The datetime object is timezone-aware.", "The WSGI input stream.", "In general it\u2019s a bad idea to use this one because you can easily read past the boundary. Use the stream instead.", "Check if the mimetype indicates JSON data, either application/json or application/*+json.", "boolean that is True if the application is served by a WSGI server that spawns multiple processes.", "boolean that is True if the application is served by a multithreaded WSGI server.", "boolean that is True if the application will be executed only once in a process lifetime. This is the case for CGI for example, but it\u2019s not guaranteed that the execution only happens one time.", "True if the request was made with a secure protocol (HTTPS or WSS).", "The parsed JSON data if mimetype indicates JSON (application/json, see is_json()).", "Calls get_json() with default arguments.", "A module or other object that has dumps and loads functions that match the API of the built-in json module.", "alias of werkzeug.datastructures.ImmutableList", "Creates the form data parser. Instantiates the form_data_parser_class with some parameters.", "New in version 0.8.", "werkzeug.formparser.FormDataParser", "the maximum content length. This is forwarded to the form data parsing function (parse_form_data()). When set and the form or files attribute is accessed and the parsing fails because more than the specified value is transmitted a RequestEntityTooLarge exception is raised.", "Have a look at Dealing with Request Data for more details.", "New in version 0.5.", "the maximum form field size. This is forwarded to the form data parsing function (parse_form_data()). When set and the form or files attribute is accessed and the data in memory for post data is longer than the specified value a RequestEntityTooLarge exception is raised.", "Have a look at Dealing with Request Data for more details.", "New in version 0.5.", "The Max-Forwards request-header field provides a mechanism with the TRACE and OPTIONS methods to limit the number of proxies or gateways that can forward the request to the next inbound server.", "The method the request was made with, such as GET.", "Like content_type, but without parameters (eg, without charset, type etc.) and always lowercase. For example if the content type is text/HTML; charset=utf-8 the mimetype would be 'text/html'.", "The mimetype parameters as dict. For example if the content type is text/html; charset=utf-8 the params would be {'charset': 'utf-8'}.", "Called if get_json() parsing fails and isn\u2019t silenced. If this method returns a value, it is used as the return value for get_json(). The default implementation raises BadRequest.", "e (ValueError) \u2013 ", "Any", "The host that the request originated from. Set access_control_allow_origin on the response to indicate which origins are allowed.", "alias of werkzeug.datastructures.ImmutableMultiDict", "The path part of the URL after root_path. This is the path used for routing within the application.", "The Pragma general-header field is used to include implementation-specific directives that might apply to any recipient along the request/response chain. All pragma directives specify optional behavior from the viewpoint of the protocol; however, some systems MAY require that behavior be consistent with the directives.", "The part of the URL after the \u201c?\u201d. This is the raw value, use args for the parsed values.", "The parsed Range header.", "New in version 0.7.", "Range", "The Referer[sic] request-header field allows the client to specify, for the server\u2019s benefit, the address (URI) of the resource from which the Request-URI was obtained (the \u201creferrer\u201d, although the header field is misspelled).", "The address of the client sending the request.", "If the server supports user authentication, and the script is protected, this attribute contains the username the user has authenticated as.", "The prefix that the application is mounted under, without a trailing slash. path comes after this.", "The request URL scheme, host, and root path. This is the root that the application is accessed from.", "The URL scheme of the protocol the request used, such as https or wss.", "Alias for self.root_path. environ[\"SCRIPT_ROOT\"] without a trailing slash.", "The address of the server. (host, port), (path, None) for unix sockets, or None if not known.", "Set when creating the request object. If True, reading from the request body will cause a RuntimeException. Useful to prevent modifying the stream from middleware.", "If the incoming form data was not encoded with a known mimetype the data is stored unmodified in this stream for consumption. Most of the time it is a better idea to use data which will give you that data as a string. The stream only returns the data once.", "Unlike input_stream this stream is properly guarded that you can\u2019t accidentally read past the length of the input. Werkzeug will internally always refer to this stream to read data which makes it possible to wrap this object with a stream that does filtering.", "Changed in version 0.9: This stream is now always available but might be consumed by the form parser later on. Previously the stream was only set if no parsing happened.", "The full request URL with the scheme, host, root path, path, and query string.", "The charset that is assumed for URLs. Defaults to the value of charset.", "New in version 0.6.", "Alias for root_url. The URL with scheme, host, and root path. For example, https://example.com/app/.", "The user agent. Use user_agent.string to get the header value. Set user_agent_class to a subclass of UserAgent to provide parsing for the other properties or other extended data.", "Changed in version 2.0: The built in parser is deprecated and will be removed in Werkzeug 2.1. A UserAgent subclass must be set to parse data from the string.", "alias of werkzeug.useragents._UserAgent", "A werkzeug.datastructures.CombinedMultiDict that combines args and form.", "For GET requests, only args are present, not form.", "Changed in version 2.0: For GET requests, only args are present, not form.", "True if the request method carries content. By default this is true if a Content-Type is sent.", "New in version 0.8."]}, {"name": "Request / Response Objects", "path": "wrappers/index", "type": "Other", "text": ["The request and response objects wrap the WSGI environment or the return value from a WSGI application so that it is another WSGI application (wraps a whole application).", "Your WSGI application is always passed two arguments. The WSGI \u201cenvironment\u201d and the WSGI start_response function that is used to start the response phase. The Request class wraps the environ for easier access to request variables (form data, request headers etc.).", "The Response on the other hand is a standard WSGI application that you can create. The simple hello world in Werkzeug looks like this:", "To make it more useful you can replace it with a function and do some processing:", "Because this is a very common task the Request object provides a helper for that. The above code can be rewritten like this:", "The application is still a valid WSGI application that accepts the environment and start_response callable.", "The implementation of the Werkzeug request and response objects are trying to guard you from common pitfalls by disallowing certain things as much as possible. This serves two purposes: high performance and avoiding of pitfalls.", "For the request object the following rules apply:", "For the response object the following rules apply:", "Represents an incoming WSGI HTTP request, with headers and body taken from the WSGI environment. Has properties and methods for using the functionality defined by various HTTP specs. The data in requests object is read-only.", "Text data is assumed to use UTF-8 encoding, which should be true for the vast majority of modern clients. Using an encoding set by the client is unsafe in Python due to extra encodings it provides, such as zip. To change the assumed encoding, subclass and replace charset.", "None", "Changed in version 2.0: Combine BaseRequest and mixins into a single Request class. Using the old classes is deprecated and will be removed in Werkzeug 2.1.", "Changed in version 0.5: Read-only mode is enforced with immutable classes for all data.", "Called to get a stream for the file upload.", "This must provide a file-like class with read(), readline() and seek() methods that is both writeable and readable.", "The default implementation returns a temporary file if the total content length is higher than 500KB. Because many browsers do not provide a content length for the files only the total content length matters.", "BinaryIO", "List of charsets this client supports as CharsetAccept object.", "List of encodings this client accepts. Encodings in a HTTP term are compression encodings such as gzip. For charsets have a look at accept_charset.", "List of languages this client accepts as LanguageAccept object.", "List of mimetypes this client supports as MIMEAccept object.", "Sent with a preflight request to indicate which headers will be sent with the cross origin request. Set access_control_allow_headers on the response to indicate which headers are allowed.", "Sent with a preflight request to indicate which method will be used for the cross origin request. Set access_control_allow_methods on the response to indicate which methods are allowed.", "If a forwarded header exists this is a list of all ip addresses from the client ip to the last proxy server.", "Decorate a function as responder that accepts the request as the last argument. This works like the responder() decorator but the function is passed the request object as the last argument and the request object will be closed automatically:", "As of Werkzeug 0.14 HTTP exceptions are automatically caught and converted to responses instead of failing.", "f (Callable[[Request], WSGIApplication]) \u2013 the WSGI callable to decorate", "a new WSGI callable", "WSGIApplication", "The parsed URL parameters (the part in the URL after the question mark).", "By default an ImmutableMultiDict is returned from this function. This can be changed by setting parameter_storage_class to a different type. This might be necessary if the order of the form data is important.", "The Authorization object in parsed form.", "Like url but without the query string.", "A RequestCacheControl object for the incoming cache control headers.", "Closes associated resources of this request object. This closes all file handles explicitly. You can also use the request object in a with statement which will automatically close it.", "New in version 0.9.", "None", "The Content-Encoding entity-header field is used as a modifier to the media-type. When present, its value indicates what additional content codings have been applied to the entity-body, and thus what decoding mechanisms must be applied in order to obtain the media-type referenced by the Content-Type header field.", "New in version 0.9.", "The Content-Length entity-header field indicates the size of the entity-body in bytes or, in the case of the HEAD method, the size of the entity-body that would have been sent had the request been a GET.", "The Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest of the entity-body for the purpose of providing an end-to-end message integrity check (MIC) of the entity-body. (Note: a MIC is good for detecting accidental modification of the entity-body in transit, but is not proof against malicious attacks.)", "New in version 0.9.", "The Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of the HEAD method, the media type that would have been sent had the request been a GET.", "A dict with the contents of all cookies transmitted with the request.", "Contains the incoming request data as string in case it came with a mimetype Werkzeug does not handle.", "The Date general-header field represents the date and time at which the message was originated, having the same semantics as orig-date in RFC 822.", "Changed in version 2.0: The datetime object is timezone-aware.", "alias of werkzeug.datastructures.ImmutableMultiDict", "Disable the data property to avoid reading from the input stream.", "Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Create the request with shallow=True instead.", "New in version 0.9.", "The WSGI environment containing HTTP headers and information from the WSGI server.", "MultiDict object containing all uploaded files. Each key in files is the name from the <input type=\"file\" name=\"\">. Each value in files is a Werkzeug FileStorage object.", "It basically behaves like a standard file object you know from Python, with the difference that it also has a save() function that can store the file on the filesystem.", "Note that files will only contain data if the request method was POST, PUT or PATCH and the <form> that posted to the request had enctype=\"multipart/form-data\". It will be empty otherwise.", "See the MultiDict / FileStorage documentation for more details about the used data structure.", "The form parameters. By default an ImmutableMultiDict is returned from this function. This can be changed by setting parameter_storage_class to a different type. This might be necessary if the order of the form data is important.", "Please keep in mind that file uploads will not end up here, but instead in the files attribute.", "Changed in version 0.9: Previous to Werkzeug 0.9 this would only contain form data for POST and PUT requests.", "alias of werkzeug.formparser.FormDataParser", "Create a new request object based on the values provided. If environ is given missing values are filled from there. This method is useful for small scripts when you need to simulate a request from an URL. Do not use this method for unittesting, there is a full featured client object (Client) that allows to create multipart requests, support for cookies etc.", "This accepts the same options as the EnvironBuilder.", "Changed in version 0.5: This method now accepts the same arguments as EnvironBuilder. Because of this the environ parameter is now called environ_overrides.", "request object", "werkzeug.wrappers.request.Request", "Requested path, including the query string.", "This reads the buffered incoming data from the client into one bytes object. By default this is cached but that behavior can be changed by setting cache to False.", "Usually it\u2019s a bad idea to call this method without checking the content length first as a client could send dozens of megabytes or more to cause memory problems on the server.", "Note that if the form data was already parsed this method will not return anything as form data parsing does not cache the data like this method does. To implicitly invoke form data parsing function set parse_form_data to True. When this is done the return value of this method will be an empty string if the form parser handles the data. This generally is not necessary as if the whole data is cached (which is the default) the form parser will used the cached data to parse the form data. Please be generally aware of checking the content length first in any case before calling this method to avoid exhausting server memory.", "If as_text is set to True the return value will be a decoded string.", "New in version 0.9.", "Union[bytes, str]", "Parse data as JSON.", "If the mimetype does not indicate JSON (application/json, see is_json()), this returns None.", "If parsing fails, on_json_loading_failed() is called and its return value is used as the return value.", "Optional[Any]", "The headers received with the request.", "The host name the request was made to, including the port if it\u2019s non-standard. Validated with trusted_hosts.", "The request URL scheme and host only.", "An object containing all the etags in the If-Match header.", "ETags", "The parsed If-Modified-Since header as a datetime object.", "Changed in version 2.0: The datetime object is timezone-aware.", "An object containing all the etags in the If-None-Match header.", "ETags", "The parsed If-Range header.", "Changed in version 2.0: IfRange.date is timezone-aware.", "New in version 0.7.", "The parsed If-Unmodified-Since header as a datetime object.", "Changed in version 2.0: The datetime object is timezone-aware.", "The WSGI input stream.", "In general it\u2019s a bad idea to use this one because you can easily read past the boundary. Use the stream instead.", "Check if the mimetype indicates JSON data, either application/json or application/*+json.", "boolean that is True if the application is served by a WSGI server that spawns multiple processes.", "boolean that is True if the application is served by a multithreaded WSGI server.", "boolean that is True if the application will be executed only once in a process lifetime. This is the case for CGI for example, but it\u2019s not guaranteed that the execution only happens one time.", "True if the request was made with a secure protocol (HTTPS or WSS).", "The parsed JSON data if mimetype indicates JSON (application/json, see is_json()).", "Calls get_json() with default arguments.", "A module or other object that has dumps and loads functions that match the API of the built-in json module.", "alias of werkzeug.datastructures.ImmutableList", "Creates the form data parser. Instantiates the form_data_parser_class with some parameters.", "New in version 0.8.", "werkzeug.formparser.FormDataParser", "the maximum content length. This is forwarded to the form data parsing function (parse_form_data()). When set and the form or files attribute is accessed and the parsing fails because more than the specified value is transmitted a RequestEntityTooLarge exception is raised.", "Have a look at Dealing with Request Data for more details.", "New in version 0.5.", "the maximum form field size. This is forwarded to the form data parsing function (parse_form_data()). When set and the form or files attribute is accessed and the data in memory for post data is longer than the specified value a RequestEntityTooLarge exception is raised.", "Have a look at Dealing with Request Data for more details.", "New in version 0.5.", "The Max-Forwards request-header field provides a mechanism with the TRACE and OPTIONS methods to limit the number of proxies or gateways that can forward the request to the next inbound server.", "The method the request was made with, such as GET.", "Like content_type, but without parameters (eg, without charset, type etc.) and always lowercase. For example if the content type is text/HTML; charset=utf-8 the mimetype would be 'text/html'.", "The mimetype parameters as dict. For example if the content type is text/html; charset=utf-8 the params would be {'charset': 'utf-8'}.", "Called if get_json() parsing fails and isn\u2019t silenced. If this method returns a value, it is used as the return value for get_json(). The default implementation raises BadRequest.", "e (ValueError) \u2013 ", "Any", "The host that the request originated from. Set access_control_allow_origin on the response to indicate which origins are allowed.", "alias of werkzeug.datastructures.ImmutableMultiDict", "The path part of the URL after root_path. This is the path used for routing within the application.", "The Pragma general-header field is used to include implementation-specific directives that might apply to any recipient along the request/response chain. All pragma directives specify optional behavior from the viewpoint of the protocol; however, some systems MAY require that behavior be consistent with the directives.", "The part of the URL after the \u201c?\u201d. This is the raw value, use args for the parsed values.", "The parsed Range header.", "New in version 0.7.", "Range", "The Referer[sic] request-header field allows the client to specify, for the server\u2019s benefit, the address (URI) of the resource from which the Request-URI was obtained (the \u201creferrer\u201d, although the header field is misspelled).", "The address of the client sending the request.", "If the server supports user authentication, and the script is protected, this attribute contains the username the user has authenticated as.", "The prefix that the application is mounted under, without a trailing slash. path comes after this.", "The request URL scheme, host, and root path. This is the root that the application is accessed from.", "The URL scheme of the protocol the request used, such as https or wss.", "Alias for self.root_path. environ[\"SCRIPT_ROOT\"] without a trailing slash.", "The address of the server. (host, port), (path, None) for unix sockets, or None if not known.", "Set when creating the request object. If True, reading from the request body will cause a RuntimeException. Useful to prevent modifying the stream from middleware.", "If the incoming form data was not encoded with a known mimetype the data is stored unmodified in this stream for consumption. Most of the time it is a better idea to use data which will give you that data as a string. The stream only returns the data once.", "Unlike input_stream this stream is properly guarded that you can\u2019t accidentally read past the length of the input. Werkzeug will internally always refer to this stream to read data which makes it possible to wrap this object with a stream that does filtering.", "Changed in version 0.9: This stream is now always available but might be consumed by the form parser later on. Previously the stream was only set if no parsing happened.", "The full request URL with the scheme, host, root path, path, and query string.", "The charset that is assumed for URLs. Defaults to the value of charset.", "New in version 0.6.", "Alias for root_url. The URL with scheme, host, and root path. For example, https://example.com/app/.", "The user agent. Use user_agent.string to get the header value. Set user_agent_class to a subclass of UserAgent to provide parsing for the other properties or other extended data.", "Changed in version 2.0: The built in parser is deprecated and will be removed in Werkzeug 2.1. A UserAgent subclass must be set to parse data from the string.", "alias of werkzeug.useragents._UserAgent", "A werkzeug.datastructures.CombinedMultiDict that combines args and form.", "For GET requests, only args are present, not form.", "Changed in version 2.0: For GET requests, only args are present, not form.", "True if the request method carries content. By default this is true if a Content-Type is sent.", "New in version 0.8.", "Represents an outgoing WSGI HTTP response with body, status, and headers. Has properties and methods for using the functionality defined by various HTTP specs.", "The response body is flexible to support different use cases. The simple form is passing bytes, or a string which will be encoded as UTF-8. Passing an iterable of bytes or strings makes this a streaming response. A generator is particularly useful for building a CSV file in memory or using SSE (Server Sent Events). A file-like object is also iterable, although the send_file() helper should be used in that case.", "The response object is itself a WSGI application callable. When called (__call__()) with environ and start_response, it will pass its status and headers to start_response then return its body as an iterable.", "None", "Changed in version 2.0: Combine BaseResponse and mixins into a single Response class. Using the old classes is deprecated and will be removed in Werkzeug 2.1.", "Changed in version 0.5: The direct_passthrough parameter was added.", "Process this response as WSGI application.", "an application iterator", "Iterable[bytes]", "This method can be called by methods that need a sequence. If mutable is true, it will also ensure that the response sequence is a standard Python list.", "New in version 0.6.", "mutable (bool) \u2013 ", "None", "The Accept-Ranges header. Even though the name would indicate that multiple values are supported, it must be one string token only.", "The values 'bytes' and 'none' are common.", "New in version 0.7.", "Whether credentials can be shared by the browser to JavaScript code. As part of the preflight request it indicates whether credentials can be used on the cross origin request.", "Which headers can be sent with the cross origin request.", "Which methods can be used for the cross origin request.", "The origin or \u2018*\u2019 for any origin that may make cross origin requests.", "Which headers can be shared by the browser to JavaScript code.", "The maximum age in seconds the access control settings can be cached for.", "Add an etag for the current response if there is none yet.", "Changed in version 2.0: SHA-1 is used to generate the value. MD5 may not be available in some environments.", "None", "The Age response-header field conveys the sender\u2019s estimate of the amount of time since the response (or its revalidation) was generated at the origin server.", "Age values are non-negative decimal integers, representing time in seconds.", "The Allow entity-header field lists the set of methods supported by the resource identified by the Request-URI. The purpose of this field is strictly to inform the recipient of valid methods associated with the resource. An Allow header field MUST be present in a 405 (Method Not Allowed) response.", "Should this response object correct the location header to be RFC conformant? This is true by default.", "New in version 0.8.", "Should this response object automatically set the content-length header if possible? This is true by default.", "New in version 0.8.", "The Cache-Control general-header field is used to specify directives that MUST be obeyed by all caching mechanisms along the request/response chain.", "Returns the content length if available or None otherwise.", "Optional[int]", "Adds a function to the internal list of functions that should be called as part of closing down the response. Since 0.7 this function also returns the function that was passed so that this can be used as a decorator.", "New in version 0.6.", "func (Callable[[], Any]) \u2013 ", "Callable[[], Any]", "Close the wrapped response if possible. You can also use the object in a with statement which will automatically close it.", "New in version 0.9: Can now be used in a with statement.", "None", "The Content-Encoding entity-header field is used as a modifier to the media-type. When present, its value indicates what additional content codings have been applied to the entity-body, and thus what decoding mechanisms must be applied in order to obtain the media-type referenced by the Content-Type header field.", "The Content-Language entity-header field describes the natural language(s) of the intended audience for the enclosed entity. Note that this might not be equivalent to all the languages used within the entity-body.", "The Content-Length entity-header field indicates the size of the entity-body, in decimal number of OCTETs, sent to the recipient or, in the case of the HEAD method, the size of the entity-body that would have been sent had the request been a GET.", "The Content-Location entity-header field MAY be used to supply the resource location for the entity enclosed in the message when that entity is accessible from a location separate from the requested resource\u2019s URI.", "The Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest of the entity-body for the purpose of providing an end-to-end message integrity check (MIC) of the entity-body. (Note: a MIC is good for detecting accidental modification of the entity-body in transit, but is not proof against malicious attacks.)", "The Content-Range header as a ContentRange object. Available even if the header is not set.", "New in version 0.7.", "The Content-Security-Policy header adds an additional layer of security to help detect and mitigate certain types of attacks.", "The Content-Security-Policy-Report-Only header adds a csp policy that is not enforced but is reported thereby helping detect certain types of attacks.", "The Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of the HEAD method, the media type that would have been sent had the request been a GET.", "Prevents a document from loading any cross-origin resources that do not explicitly grant the document permission. Values must be a member of the werkzeug.http.COEP enum.", "Allows control over sharing of browsing context group with cross-origin documents. Values must be a member of the werkzeug.http.COOP enum.", "A descriptor that calls get_data() and set_data().", "The Date general-header field represents the date and time at which the message was originated, having the same semantics as orig-date in RFC 822.", "Changed in version 2.0: The datetime object is timezone-aware.", "Delete a cookie. Fails silently if key doesn\u2019t exist.", "None", "Pass the response body directly through as the WSGI iterable. This can be used when the body is a binary file or other iterator of bytes, to skip some unnecessary checks. Use send_file() instead of setting this manually.", "The Expires entity-header field gives the date/time after which the response is considered stale. A stale cache entry may not normally be returned by a cache.", "Changed in version 2.0: The datetime object is timezone-aware.", "Enforce that the WSGI response is a response object of the current type. Werkzeug will use the Response internally in many situations like the exceptions. If you call get_response() on an exception you will get back a regular Response object, even if you are using a custom subclass.", "This method can enforce a given response type, and it will also convert arbitrary WSGI callables into response objects if an environ is provided:", "This is especially useful if you want to post-process responses in the main dispatcher and use functionality provided by your subclass.", "Keep in mind that this will modify response objects in place if possible!", "a response object.", "Response", "Make the response object ready to be pickled. Does the following:", "Changed in version 2.0: An ETag header is added, the no_etag parameter is deprecated and will be removed in Werkzeug 2.1.", "Changed in version 0.6: The Content-Length header is set.", "no_etag (None) \u2013 ", "None", "Create a new response object from an application output. This works best if you pass it an application that returns a generator all the time. Sometimes applications may use the write() callable returned by the start_response function. This tries to resolve such edge cases automatically. But if you don\u2019t get the expected output you should set buffered to True which enforces buffering.", "a response object.", "Response", "Returns the application iterator for the given environ. Depending on the request method and the current status code the return value might be an empty response rather than the one from the response.", "If the request method is HEAD or the status code is in a range where the HTTP specification requires an empty response, an empty iterable is returned.", "New in version 0.6.", "environ (WSGIEnvironment) \u2013 the WSGI environment of the request.", "a response iterable.", "Iterable[bytes]", "The string representation of the response body. Whenever you call this property the response iterable is encoded and flattened. This can lead to unwanted behavior if you stream big data.", "This behavior can be disabled by setting implicit_sequence_conversion to False.", "If as_text is set to True the return value will be a decoded string.", "New in version 0.9.", "as_text (bool) \u2013 ", "Union[bytes, str]", "Return a tuple in the form (etag, is_weak). If there is no ETag the return value is (None, None).", "Union[Tuple[str, bool], Tuple[None, None]]", "Parse data as JSON. Useful during testing.", "If the mimetype does not indicate JSON (application/json, see is_json()), this returns None.", "Unlike Request.get_json(), the result is not cached.", "Optional[Any]", "This is automatically called right before the response is started and returns headers modified for the given environment. It returns a copy of the headers from the response with some modifications applied if necessary.", "For example the location header (if present) is joined with the root URL of the environment. Also the content length is automatically set to zero here for certain status codes.", "Changed in version 0.6: Previously that function was called fix_headers and modified the response object in place. Also since 0.6, IRIs in location and content-location headers are handled properly.", "Also starting with 0.6, Werkzeug will attempt to set the content length if it is able to figure it out on its own. This is the case if all the strings in the response iterable are already encoded and the iterable is buffered.", "environ (WSGIEnvironment) \u2013 the WSGI environment of the request.", "returns a new Headers object.", "werkzeug.datastructures.Headers", "Returns the final WSGI response as tuple. The first item in the tuple is the application iterator, the second the status and the third the list of headers. The response returned is created specially for the given environment. For example if the request method in the WSGI environment is 'HEAD' the response will be empty and only the headers and status code will be present.", "New in version 0.6.", "environ (WSGIEnvironment) \u2013 the WSGI environment of the request.", "an (app_iter, status, headers) tuple.", "Tuple[Iterable[bytes], str, List[Tuple[str, str]]]", "if set to False accessing properties on the response object will not try to consume the response iterator and convert it into a list.", "New in version 0.6.2: That attribute was previously called implicit_seqence_conversion. (Notice the typo). If you did use this feature, you have to adapt your code to the name change.", "Check if the mimetype indicates JSON data, either application/json or application/*+json.", "If the iterator is buffered, this property will be True. A response object will consider an iterator to be buffered if the response attribute is a list or tuple.", "New in version 0.6.", "If the response is streamed (the response is not an iterable with a length information) this property is True. In this case streamed means that there is no information about the number of iterations. This is usually True if a generator is passed to the response object.", "This is useful for checking before applying some sort of post filtering that should not take place for streamed responses.", "Iter the response encoded with the encoding of the response. If the response object is invoked as WSGI application the return value of this method is used as application iterator unless direct_passthrough was activated.", "Iterator[bytes]", "The parsed JSON data if mimetype indicates JSON (application/json, see is_json()).", "Calls get_json() with default arguments.", "A module or other object that has dumps and loads functions that match the API of the built-in json module.", "The Last-Modified entity-header field indicates the date and time at which the origin server believes the variant was last modified.", "Changed in version 2.0: The datetime object is timezone-aware.", "The Location response-header field is used to redirect the recipient to a location other than the Request-URI for completion of the request or identification of a new resource.", "Make the response conditional to the request. This method works best if an etag was defined for the response already. The add_etag method can be used to do that. If called without etag just the date header is set.", "This does nothing if the request method in the request or environ is anything but GET or HEAD.", "For optimal performance when handling range requests, it\u2019s recommended that your response data object implements seekable, seek and tell methods as described by io.IOBase. Objects returned by wrap_file() automatically implement those methods.", "It does not remove the body of the response because that\u2019s something the __call__() function does for us automatically.", "Returns self so that you can do return resp.make_conditional(req) but modifies the object in-place.", "RequestedRangeNotSatisfiable if Range header could not be parsed or satisfied.", "Response", "Changed in version 2.0: Range processing is skipped if length is 0 instead of raising a 416 Range Not Satisfiable error.", "Converts the response iterator in a list. By default this happens automatically if required. If implicit_sequence_conversion is disabled, this method is not automatically called and some properties might raise exceptions. This also encodes all the items.", "New in version 0.6.", "None", "The mimetype (content type without charset etc.)", "The mimetype parameters as dict. For example if the content type is text/html; charset=utf-8 the params would be {'charset': 'utf-8'}.", "New in version 0.5.", "The response body to send as the WSGI iterable. A list of strings or bytes represents a fixed-length response, any other iterable is a streaming response. Strings are encoded to bytes as UTF-8.", "Do not set to a plain string or bytes, that will cause sending the response to be very inefficient as it will iterate one byte at a time.", "The Retry-After response-header field can be used with a 503 (Service Unavailable) response to indicate how long the service is expected to be unavailable to the requesting client.", "Time in seconds until expiration or date.", "Changed in version 2.0: The datetime object is timezone-aware.", "Sets a cookie.", "A warning is raised if the size of the cookie header exceeds max_cookie_size, but the header will still be set.", "None", "Sets a new string as response. The value must be a string or bytes. If a string is set it\u2019s encoded to the charset of the response (utf-8 by default).", "New in version 0.9.", "value (Union[bytes, str]) \u2013 ", "None", "Set the etag, and override the old one if there was one.", "None", "The HTTP status code as a string.", "The HTTP status code as a number.", "The response iterable as write-only stream.", "The Vary field value indicates the set of request-header fields that fully determines, while the response is fresh, whether a cache is permitted to use the response to reply to a subsequent request without revalidation.", "The WWW-Authenticate header in a parsed form."]}, {"name": "Request.access_control_request_headers", "path": "wrappers/index#werkzeug.wrappers.Request.access_control_request_headers", "type": "werkzeug.wrappers", "text": ["Sent with a preflight request to indicate which headers will be sent with the cross origin request. Set access_control_allow_headers on the response to indicate which headers are allowed."]}, {"name": "Request.access_control_request_method", "path": "wrappers/index#werkzeug.wrappers.Request.access_control_request_method", "type": "werkzeug.wrappers", "text": ["Sent with a preflight request to indicate which method will be used for the cross origin request. Set access_control_allow_methods on the response to indicate which methods are allowed."]}, {"name": "Request.application()", "path": "wrappers/index#werkzeug.wrappers.Request.application", "type": "werkzeug.wrappers", "text": ["Decorate a function as responder that accepts the request as the last argument. This works like the responder() decorator but the function is passed the request object as the last argument and the request object will be closed automatically:", "As of Werkzeug 0.14 HTTP exceptions are automatically caught and converted to responses instead of failing.", "f (Callable[[Request], WSGIApplication]) \u2013 the WSGI callable to decorate", "a new WSGI callable", "WSGIApplication"]}, {"name": "Request.close()", "path": "wrappers/index#werkzeug.wrappers.Request.close", "type": "werkzeug.wrappers", "text": ["Closes associated resources of this request object. This closes all file handles explicitly. You can also use the request object in a with statement which will automatically close it.", "New in version 0.9.", "None"]}, {"name": "Request.content_encoding", "path": "wrappers/index#werkzeug.wrappers.Request.content_encoding", "type": "werkzeug.wrappers", "text": ["The Content-Encoding entity-header field is used as a modifier to the media-type. When present, its value indicates what additional content codings have been applied to the entity-body, and thus what decoding mechanisms must be applied in order to obtain the media-type referenced by the Content-Type header field.", "New in version 0.9."]}, {"name": "Request.content_md5", "path": "wrappers/index#werkzeug.wrappers.Request.content_md5", "type": "werkzeug.wrappers", "text": ["The Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest of the entity-body for the purpose of providing an end-to-end message integrity check (MIC) of the entity-body. (Note: a MIC is good for detecting accidental modification of the entity-body in transit, but is not proof against malicious attacks.)", "New in version 0.9."]}, {"name": "Request.content_type", "path": "wrappers/index#werkzeug.wrappers.Request.content_type", "type": "werkzeug.wrappers", "text": ["The Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of the HEAD method, the media type that would have been sent had the request been a GET."]}, {"name": "Request.date", "path": "wrappers/index#werkzeug.wrappers.Request.date", "type": "werkzeug.wrappers", "text": ["The Date general-header field represents the date and time at which the message was originated, having the same semantics as orig-date in RFC 822.", "Changed in version 2.0: The datetime object is timezone-aware."]}, {"name": "Request.dict_storage_class", "path": "wrappers/index#werkzeug.wrappers.Request.dict_storage_class", "type": "werkzeug.wrappers", "text": ["alias of werkzeug.datastructures.ImmutableMultiDict"]}, {"name": "Request.disable_data_descriptor", "path": "wrappers/index#werkzeug.wrappers.Request.disable_data_descriptor", "type": "werkzeug.wrappers", "text": ["Disable the data property to avoid reading from the input stream.", "Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Create the request with shallow=True instead.", "New in version 0.9."]}, {"name": "Request.environ", "path": "wrappers/index#werkzeug.wrappers.Request.environ", "type": "werkzeug.wrappers", "text": ["The WSGI environment containing HTTP headers and information from the WSGI server."]}, {"name": "Request.form_data_parser_class", "path": "wrappers/index#werkzeug.wrappers.Request.form_data_parser_class", "type": "werkzeug.wrappers", "text": ["alias of werkzeug.formparser.FormDataParser"]}, {"name": "Request.from_values()", "path": "wrappers/index#werkzeug.wrappers.Request.from_values", "type": "werkzeug.wrappers", "text": ["Create a new request object based on the values provided. If environ is given missing values are filled from there. This method is useful for small scripts when you need to simulate a request from an URL. Do not use this method for unittesting, there is a full featured client object (Client) that allows to create multipart requests, support for cookies etc.", "This accepts the same options as the EnvironBuilder.", "Changed in version 0.5: This method now accepts the same arguments as EnvironBuilder. Because of this the environ parameter is now called environ_overrides.", "request object", "werkzeug.wrappers.request.Request"]}, {"name": "Request.get_data()", "path": "wrappers/index#werkzeug.wrappers.Request.get_data", "type": "werkzeug.wrappers", "text": ["This reads the buffered incoming data from the client into one bytes object. By default this is cached but that behavior can be changed by setting cache to False.", "Usually it\u2019s a bad idea to call this method without checking the content length first as a client could send dozens of megabytes or more to cause memory problems on the server.", "Note that if the form data was already parsed this method will not return anything as form data parsing does not cache the data like this method does. To implicitly invoke form data parsing function set parse_form_data to True. When this is done the return value of this method will be an empty string if the form parser handles the data. This generally is not necessary as if the whole data is cached (which is the default) the form parser will used the cached data to parse the form data. Please be generally aware of checking the content length first in any case before calling this method to avoid exhausting server memory.", "If as_text is set to True the return value will be a decoded string.", "New in version 0.9.", "Union[bytes, str]"]}, {"name": "Request.get_json()", "path": "wrappers/index#werkzeug.wrappers.Request.get_json", "type": "werkzeug.wrappers", "text": ["Parse data as JSON.", "If the mimetype does not indicate JSON (application/json, see is_json()), this returns None.", "If parsing fails, on_json_loading_failed() is called and its return value is used as the return value.", "Optional[Any]"]}, {"name": "Request.headers", "path": "wrappers/index#werkzeug.wrappers.Request.headers", "type": "werkzeug.wrappers", "text": ["The headers received with the request."]}, {"name": "Request.input_stream", "path": "wrappers/index#werkzeug.wrappers.Request.input_stream", "type": "werkzeug.wrappers", "text": ["The WSGI input stream.", "In general it\u2019s a bad idea to use this one because you can easily read past the boundary. Use the stream instead."]}, {"name": "Request.is_multiprocess", "path": "wrappers/index#werkzeug.wrappers.Request.is_multiprocess", "type": "werkzeug.wrappers", "text": ["boolean that is True if the application is served by a WSGI server that spawns multiple processes."]}, {"name": "Request.is_multithread", "path": "wrappers/index#werkzeug.wrappers.Request.is_multithread", "type": "werkzeug.wrappers", "text": ["boolean that is True if the application is served by a multithreaded WSGI server."]}, {"name": "Request.is_run_once", "path": "wrappers/index#werkzeug.wrappers.Request.is_run_once", "type": "werkzeug.wrappers", "text": ["boolean that is True if the application will be executed only once in a process lifetime. This is the case for CGI for example, but it\u2019s not guaranteed that the execution only happens one time."]}, {"name": "Request.json_module", "path": "wrappers/index#werkzeug.wrappers.Request.json_module", "type": "werkzeug.wrappers", "text": ["A module or other object that has dumps and loads functions that match the API of the built-in json module."]}, {"name": "Request.list_storage_class", "path": "wrappers/index#werkzeug.wrappers.Request.list_storage_class", "type": "werkzeug.wrappers", "text": ["alias of werkzeug.datastructures.ImmutableList"]}, {"name": "Request.make_form_data_parser()", "path": "wrappers/index#werkzeug.wrappers.Request.make_form_data_parser", "type": "werkzeug.wrappers", "text": ["Creates the form data parser. Instantiates the form_data_parser_class with some parameters.", "New in version 0.8.", "werkzeug.formparser.FormDataParser"]}, {"name": "Request.max_content_length", "path": "wrappers/index#werkzeug.wrappers.Request.max_content_length", "type": "werkzeug.wrappers", "text": ["the maximum content length. This is forwarded to the form data parsing function (parse_form_data()). When set and the form or files attribute is accessed and the parsing fails because more than the specified value is transmitted a RequestEntityTooLarge exception is raised.", "Have a look at Dealing with Request Data for more details.", "New in version 0.5."]}, {"name": "Request.max_form_memory_size", "path": "wrappers/index#werkzeug.wrappers.Request.max_form_memory_size", "type": "werkzeug.wrappers", "text": ["the maximum form field size. This is forwarded to the form data parsing function (parse_form_data()). When set and the form or files attribute is accessed and the data in memory for post data is longer than the specified value a RequestEntityTooLarge exception is raised.", "Have a look at Dealing with Request Data for more details.", "New in version 0.5."]}, {"name": "Request.max_forwards", "path": "wrappers/index#werkzeug.wrappers.Request.max_forwards", "type": "werkzeug.wrappers", "text": ["The Max-Forwards request-header field provides a mechanism with the TRACE and OPTIONS methods to limit the number of proxies or gateways that can forward the request to the next inbound server."]}, {"name": "Request.method", "path": "wrappers/index#werkzeug.wrappers.Request.method", "type": "werkzeug.wrappers", "text": ["The method the request was made with, such as GET."]}, {"name": "Request.on_json_loading_failed()", "path": "wrappers/index#werkzeug.wrappers.Request.on_json_loading_failed", "type": "werkzeug.wrappers", "text": ["Called if get_json() parsing fails and isn\u2019t silenced. If this method returns a value, it is used as the return value for get_json(). The default implementation raises BadRequest.", "e (ValueError) \u2013 ", "Any"]}, {"name": "Request.origin", "path": "wrappers/index#werkzeug.wrappers.Request.origin", "type": "werkzeug.wrappers", "text": ["The host that the request originated from. Set access_control_allow_origin on the response to indicate which origins are allowed."]}, {"name": "Request.parameter_storage_class", "path": "wrappers/index#werkzeug.wrappers.Request.parameter_storage_class", "type": "werkzeug.wrappers", "text": ["alias of werkzeug.datastructures.ImmutableMultiDict"]}, {"name": "Request.path", "path": "wrappers/index#werkzeug.wrappers.Request.path", "type": "werkzeug.wrappers", "text": ["The path part of the URL after root_path. This is the path used for routing within the application."]}, {"name": "Request.query_string", "path": "wrappers/index#werkzeug.wrappers.Request.query_string", "type": "werkzeug.wrappers", "text": ["The part of the URL after the \u201c?\u201d. This is the raw value, use args for the parsed values."]}, {"name": "Request.referrer", "path": "wrappers/index#werkzeug.wrappers.Request.referrer", "type": "werkzeug.wrappers", "text": ["The Referer[sic] request-header field allows the client to specify, for the server\u2019s benefit, the address (URI) of the resource from which the Request-URI was obtained (the \u201creferrer\u201d, although the header field is misspelled)."]}, {"name": "Request.remote_addr", "path": "wrappers/index#werkzeug.wrappers.Request.remote_addr", "type": "werkzeug.wrappers", "text": ["The address of the client sending the request."]}, {"name": "Request.remote_user", "path": "wrappers/index#werkzeug.wrappers.Request.remote_user", "type": "werkzeug.wrappers", "text": ["If the server supports user authentication, and the script is protected, this attribute contains the username the user has authenticated as."]}, {"name": "Request.root_path", "path": "wrappers/index#werkzeug.wrappers.Request.root_path", "type": "werkzeug.wrappers", "text": ["The prefix that the application is mounted under, without a trailing slash. path comes after this."]}, {"name": "Request.scheme", "path": "wrappers/index#werkzeug.wrappers.Request.scheme", "type": "werkzeug.wrappers", "text": ["The URL scheme of the protocol the request used, such as https or wss."]}, {"name": "Request.server", "path": "wrappers/index#werkzeug.wrappers.Request.server", "type": "werkzeug.wrappers", "text": ["The address of the server. (host, port), (path, None) for unix sockets, or None if not known."]}, {"name": "Request.shallow", "path": "wrappers/index#werkzeug.wrappers.Request.shallow", "type": "werkzeug.wrappers", "text": ["Set when creating the request object. If True, reading from the request body will cause a RuntimeException. Useful to prevent modifying the stream from middleware."]}, {"name": "Request.user_agent_class", "path": "wrappers/index#werkzeug.wrappers.Request.user_agent_class", "type": "werkzeug.wrappers", "text": ["alias of werkzeug.useragents._UserAgent"]}, {"name": "Request._get_file_stream()", "path": "wrappers/index#werkzeug.wrappers.Request._get_file_stream", "type": "werkzeug.wrappers", "text": ["Called to get a stream for the file upload.", "This must provide a file-like class with read(), readline() and seek() methods that is both writeable and readable.", "The default implementation returns a temporary file if the total content length is higher than 500KB. Because many browsers do not provide a content length for the files only the total content length matters.", "BinaryIO"]}, {"name": "RequestCacheControl", "path": "datastructures/index#werkzeug.datastructures.RequestCacheControl", "type": "werkzeug.datastructures", "text": ["A cache control for requests. This is immutable and gives access to all the request-relevant cache control headers.", "To get a header of the RequestCacheControl object again you can convert the object into a string or call the to_header() method. If you plan to subclass it and add your own items have a look at the sourcecode for that class.", "New in version 0.5: In previous versions a CacheControl class existed that was used both for request and response.", "accessor for \u2018no-cache\u2019", "accessor for \u2018no-store\u2019", "accessor for \u2018max-age\u2019", "accessor for \u2018no-transform\u2019", "accessor for \u2018max-stale\u2019", "accessor for \u2018min-fresh\u2019", "accessor for \u2018only-if-cached\u2019"]}, {"name": "RequestCacheControl.max_age", "path": "datastructures/index#werkzeug.datastructures.RequestCacheControl.max_age", "type": "werkzeug.datastructures", "text": ["accessor for \u2018max-age\u2019"]}, {"name": "RequestCacheControl.no_cache", "path": "datastructures/index#werkzeug.datastructures.RequestCacheControl.no_cache", "type": "werkzeug.datastructures", "text": ["accessor for \u2018no-cache\u2019"]}, {"name": "RequestCacheControl.no_store", "path": "datastructures/index#werkzeug.datastructures.RequestCacheControl.no_store", "type": "werkzeug.datastructures", "text": ["accessor for \u2018no-store\u2019"]}, {"name": "RequestCacheControl.no_transform", "path": "datastructures/index#werkzeug.datastructures.RequestCacheControl.no_transform", "type": "werkzeug.datastructures", "text": ["accessor for \u2018no-transform\u2019"]}, {"name": "responder()", "path": "wsgi/index#werkzeug.wsgi.responder", "type": "werkzeug.wsgi", "text": ["Marks a function as responder. Decorate a function with it and it will automatically call the return value as WSGI application.", "Example:", "f (Callable[[...], WSGIApplication]) \u2013 ", "WSGIApplication"]}, {"name": "Response", "path": "wrappers/index#werkzeug.wrappers.Response", "type": "werkzeug.wrappers", "text": ["Represents an outgoing WSGI HTTP response with body, status, and headers. Has properties and methods for using the functionality defined by various HTTP specs.", "The response body is flexible to support different use cases. The simple form is passing bytes, or a string which will be encoded as UTF-8. Passing an iterable of bytes or strings makes this a streaming response. A generator is particularly useful for building a CSV file in memory or using SSE (Server Sent Events). A file-like object is also iterable, although the send_file() helper should be used in that case.", "The response object is itself a WSGI application callable. When called (__call__()) with environ and start_response, it will pass its status and headers to start_response then return its body as an iterable.", "None", "Changed in version 2.0: Combine BaseResponse and mixins into a single Response class. Using the old classes is deprecated and will be removed in Werkzeug 2.1.", "Changed in version 0.5: The direct_passthrough parameter was added.", "Process this response as WSGI application.", "an application iterator", "Iterable[bytes]", "This method can be called by methods that need a sequence. If mutable is true, it will also ensure that the response sequence is a standard Python list.", "New in version 0.6.", "mutable (bool) \u2013 ", "None", "The Accept-Ranges header. Even though the name would indicate that multiple values are supported, it must be one string token only.", "The values 'bytes' and 'none' are common.", "New in version 0.7.", "Whether credentials can be shared by the browser to JavaScript code. As part of the preflight request it indicates whether credentials can be used on the cross origin request.", "Which headers can be sent with the cross origin request.", "Which methods can be used for the cross origin request.", "The origin or \u2018*\u2019 for any origin that may make cross origin requests.", "Which headers can be shared by the browser to JavaScript code.", "The maximum age in seconds the access control settings can be cached for.", "Add an etag for the current response if there is none yet.", "Changed in version 2.0: SHA-1 is used to generate the value. MD5 may not be available in some environments.", "None", "The Age response-header field conveys the sender\u2019s estimate of the amount of time since the response (or its revalidation) was generated at the origin server.", "Age values are non-negative decimal integers, representing time in seconds.", "The Allow entity-header field lists the set of methods supported by the resource identified by the Request-URI. The purpose of this field is strictly to inform the recipient of valid methods associated with the resource. An Allow header field MUST be present in a 405 (Method Not Allowed) response.", "Should this response object correct the location header to be RFC conformant? This is true by default.", "New in version 0.8.", "Should this response object automatically set the content-length header if possible? This is true by default.", "New in version 0.8.", "The Cache-Control general-header field is used to specify directives that MUST be obeyed by all caching mechanisms along the request/response chain.", "Returns the content length if available or None otherwise.", "Optional[int]", "Adds a function to the internal list of functions that should be called as part of closing down the response. Since 0.7 this function also returns the function that was passed so that this can be used as a decorator.", "New in version 0.6.", "func (Callable[[], Any]) \u2013 ", "Callable[[], Any]", "Close the wrapped response if possible. You can also use the object in a with statement which will automatically close it.", "New in version 0.9: Can now be used in a with statement.", "None", "The Content-Encoding entity-header field is used as a modifier to the media-type. When present, its value indicates what additional content codings have been applied to the entity-body, and thus what decoding mechanisms must be applied in order to obtain the media-type referenced by the Content-Type header field.", "The Content-Language entity-header field describes the natural language(s) of the intended audience for the enclosed entity. Note that this might not be equivalent to all the languages used within the entity-body.", "The Content-Length entity-header field indicates the size of the entity-body, in decimal number of OCTETs, sent to the recipient or, in the case of the HEAD method, the size of the entity-body that would have been sent had the request been a GET.", "The Content-Location entity-header field MAY be used to supply the resource location for the entity enclosed in the message when that entity is accessible from a location separate from the requested resource\u2019s URI.", "The Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest of the entity-body for the purpose of providing an end-to-end message integrity check (MIC) of the entity-body. (Note: a MIC is good for detecting accidental modification of the entity-body in transit, but is not proof against malicious attacks.)", "The Content-Range header as a ContentRange object. Available even if the header is not set.", "New in version 0.7.", "The Content-Security-Policy header adds an additional layer of security to help detect and mitigate certain types of attacks.", "The Content-Security-Policy-Report-Only header adds a csp policy that is not enforced but is reported thereby helping detect certain types of attacks.", "The Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of the HEAD method, the media type that would have been sent had the request been a GET.", "Prevents a document from loading any cross-origin resources that do not explicitly grant the document permission. Values must be a member of the werkzeug.http.COEP enum.", "Allows control over sharing of browsing context group with cross-origin documents. Values must be a member of the werkzeug.http.COOP enum.", "A descriptor that calls get_data() and set_data().", "The Date general-header field represents the date and time at which the message was originated, having the same semantics as orig-date in RFC 822.", "Changed in version 2.0: The datetime object is timezone-aware.", "Delete a cookie. Fails silently if key doesn\u2019t exist.", "None", "Pass the response body directly through as the WSGI iterable. This can be used when the body is a binary file or other iterator of bytes, to skip some unnecessary checks. Use send_file() instead of setting this manually.", "The Expires entity-header field gives the date/time after which the response is considered stale. A stale cache entry may not normally be returned by a cache.", "Changed in version 2.0: The datetime object is timezone-aware.", "Enforce that the WSGI response is a response object of the current type. Werkzeug will use the Response internally in many situations like the exceptions. If you call get_response() on an exception you will get back a regular Response object, even if you are using a custom subclass.", "This method can enforce a given response type, and it will also convert arbitrary WSGI callables into response objects if an environ is provided:", "This is especially useful if you want to post-process responses in the main dispatcher and use functionality provided by your subclass.", "Keep in mind that this will modify response objects in place if possible!", "a response object.", "Response", "Make the response object ready to be pickled. Does the following:", "Changed in version 2.0: An ETag header is added, the no_etag parameter is deprecated and will be removed in Werkzeug 2.1.", "Changed in version 0.6: The Content-Length header is set.", "no_etag (None) \u2013 ", "None", "Create a new response object from an application output. This works best if you pass it an application that returns a generator all the time. Sometimes applications may use the write() callable returned by the start_response function. This tries to resolve such edge cases automatically. But if you don\u2019t get the expected output you should set buffered to True which enforces buffering.", "a response object.", "Response", "Returns the application iterator for the given environ. Depending on the request method and the current status code the return value might be an empty response rather than the one from the response.", "If the request method is HEAD or the status code is in a range where the HTTP specification requires an empty response, an empty iterable is returned.", "New in version 0.6.", "environ (WSGIEnvironment) \u2013 the WSGI environment of the request.", "a response iterable.", "Iterable[bytes]", "The string representation of the response body. Whenever you call this property the response iterable is encoded and flattened. This can lead to unwanted behavior if you stream big data.", "This behavior can be disabled by setting implicit_sequence_conversion to False.", "If as_text is set to True the return value will be a decoded string.", "New in version 0.9.", "as_text (bool) \u2013 ", "Union[bytes, str]", "Return a tuple in the form (etag, is_weak). If there is no ETag the return value is (None, None).", "Union[Tuple[str, bool], Tuple[None, None]]", "Parse data as JSON. Useful during testing.", "If the mimetype does not indicate JSON (application/json, see is_json()), this returns None.", "Unlike Request.get_json(), the result is not cached.", "Optional[Any]", "This is automatically called right before the response is started and returns headers modified for the given environment. It returns a copy of the headers from the response with some modifications applied if necessary.", "For example the location header (if present) is joined with the root URL of the environment. Also the content length is automatically set to zero here for certain status codes.", "Changed in version 0.6: Previously that function was called fix_headers and modified the response object in place. Also since 0.6, IRIs in location and content-location headers are handled properly.", "Also starting with 0.6, Werkzeug will attempt to set the content length if it is able to figure it out on its own. This is the case if all the strings in the response iterable are already encoded and the iterable is buffered.", "environ (WSGIEnvironment) \u2013 the WSGI environment of the request.", "returns a new Headers object.", "werkzeug.datastructures.Headers", "Returns the final WSGI response as tuple. The first item in the tuple is the application iterator, the second the status and the third the list of headers. The response returned is created specially for the given environment. For example if the request method in the WSGI environment is 'HEAD' the response will be empty and only the headers and status code will be present.", "New in version 0.6.", "environ (WSGIEnvironment) \u2013 the WSGI environment of the request.", "an (app_iter, status, headers) tuple.", "Tuple[Iterable[bytes], str, List[Tuple[str, str]]]", "if set to False accessing properties on the response object will not try to consume the response iterator and convert it into a list.", "New in version 0.6.2: That attribute was previously called implicit_seqence_conversion. (Notice the typo). If you did use this feature, you have to adapt your code to the name change.", "Check if the mimetype indicates JSON data, either application/json or application/*+json.", "If the iterator is buffered, this property will be True. A response object will consider an iterator to be buffered if the response attribute is a list or tuple.", "New in version 0.6.", "If the response is streamed (the response is not an iterable with a length information) this property is True. In this case streamed means that there is no information about the number of iterations. This is usually True if a generator is passed to the response object.", "This is useful for checking before applying some sort of post filtering that should not take place for streamed responses.", "Iter the response encoded with the encoding of the response. If the response object is invoked as WSGI application the return value of this method is used as application iterator unless direct_passthrough was activated.", "Iterator[bytes]", "The parsed JSON data if mimetype indicates JSON (application/json, see is_json()).", "Calls get_json() with default arguments.", "A module or other object that has dumps and loads functions that match the API of the built-in json module.", "The Last-Modified entity-header field indicates the date and time at which the origin server believes the variant was last modified.", "Changed in version 2.0: The datetime object is timezone-aware.", "The Location response-header field is used to redirect the recipient to a location other than the Request-URI for completion of the request or identification of a new resource.", "Make the response conditional to the request. This method works best if an etag was defined for the response already. The add_etag method can be used to do that. If called without etag just the date header is set.", "This does nothing if the request method in the request or environ is anything but GET or HEAD.", "For optimal performance when handling range requests, it\u2019s recommended that your response data object implements seekable, seek and tell methods as described by io.IOBase. Objects returned by wrap_file() automatically implement those methods.", "It does not remove the body of the response because that\u2019s something the __call__() function does for us automatically.", "Returns self so that you can do return resp.make_conditional(req) but modifies the object in-place.", "RequestedRangeNotSatisfiable if Range header could not be parsed or satisfied.", "Response", "Changed in version 2.0: Range processing is skipped if length is 0 instead of raising a 416 Range Not Satisfiable error.", "Converts the response iterator in a list. By default this happens automatically if required. If implicit_sequence_conversion is disabled, this method is not automatically called and some properties might raise exceptions. This also encodes all the items.", "New in version 0.6.", "None", "The mimetype (content type without charset etc.)", "The mimetype parameters as dict. For example if the content type is text/html; charset=utf-8 the params would be {'charset': 'utf-8'}.", "New in version 0.5.", "The response body to send as the WSGI iterable. A list of strings or bytes represents a fixed-length response, any other iterable is a streaming response. Strings are encoded to bytes as UTF-8.", "Do not set to a plain string or bytes, that will cause sending the response to be very inefficient as it will iterate one byte at a time.", "The Retry-After response-header field can be used with a 503 (Service Unavailable) response to indicate how long the service is expected to be unavailable to the requesting client.", "Time in seconds until expiration or date.", "Changed in version 2.0: The datetime object is timezone-aware.", "Sets a cookie.", "A warning is raised if the size of the cookie header exceeds max_cookie_size, but the header will still be set.", "None", "Sets a new string as response. The value must be a string or bytes. If a string is set it\u2019s encoded to the charset of the response (utf-8 by default).", "New in version 0.9.", "value (Union[bytes, str]) \u2013 ", "None", "Set the etag, and override the old one if there was one.", "None", "The HTTP status code as a string.", "The HTTP status code as a number.", "The response iterable as write-only stream.", "The Vary field value indicates the set of request-header fields that fully determines, while the response is fresh, whether a cache is permitted to use the response to reply to a subsequent request without revalidation.", "The WWW-Authenticate header in a parsed form."]}, {"name": "Response.accept_ranges", "path": "wrappers/index#werkzeug.wrappers.Response.accept_ranges", "type": "werkzeug.wrappers", "text": ["The Accept-Ranges header. Even though the name would indicate that multiple values are supported, it must be one string token only.", "The values 'bytes' and 'none' are common.", "New in version 0.7."]}, {"name": "Response.access_control_allow_headers", "path": "wrappers/index#werkzeug.wrappers.Response.access_control_allow_headers", "type": "werkzeug.wrappers", "text": ["Which headers can be sent with the cross origin request."]}, {"name": "Response.access_control_allow_methods", "path": "wrappers/index#werkzeug.wrappers.Response.access_control_allow_methods", "type": "werkzeug.wrappers", "text": ["Which methods can be used for the cross origin request."]}, {"name": "Response.access_control_allow_origin", "path": "wrappers/index#werkzeug.wrappers.Response.access_control_allow_origin", "type": "werkzeug.wrappers", "text": ["The origin or \u2018*\u2019 for any origin that may make cross origin requests."]}, {"name": "Response.access_control_expose_headers", "path": "wrappers/index#werkzeug.wrappers.Response.access_control_expose_headers", "type": "werkzeug.wrappers", "text": ["Which headers can be shared by the browser to JavaScript code."]}, {"name": "Response.access_control_max_age", "path": "wrappers/index#werkzeug.wrappers.Response.access_control_max_age", "type": "werkzeug.wrappers", "text": ["The maximum age in seconds the access control settings can be cached for."]}, {"name": "Response.add_etag()", "path": "wrappers/index#werkzeug.wrappers.Response.add_etag", "type": "werkzeug.wrappers", "text": ["Add an etag for the current response if there is none yet.", "Changed in version 2.0: SHA-1 is used to generate the value. MD5 may not be available in some environments.", "None"]}, {"name": "Response.age", "path": "wrappers/index#werkzeug.wrappers.Response.age", "type": "werkzeug.wrappers", "text": ["The Age response-header field conveys the sender\u2019s estimate of the amount of time since the response (or its revalidation) was generated at the origin server.", "Age values are non-negative decimal integers, representing time in seconds."]}, {"name": "Response.autocorrect_location_header", "path": "wrappers/index#werkzeug.wrappers.Response.autocorrect_location_header", "type": "werkzeug.wrappers", "text": ["Should this response object correct the location header to be RFC conformant? This is true by default.", "New in version 0.8."]}, {"name": "Response.automatically_set_content_length", "path": "wrappers/index#werkzeug.wrappers.Response.automatically_set_content_length", "type": "werkzeug.wrappers", "text": ["Should this response object automatically set the content-length header if possible? This is true by default.", "New in version 0.8."]}, {"name": "Response.calculate_content_length()", "path": "wrappers/index#werkzeug.wrappers.Response.calculate_content_length", "type": "werkzeug.wrappers", "text": ["Returns the content length if available or None otherwise.", "Optional[int]"]}, {"name": "Response.call_on_close()", "path": "wrappers/index#werkzeug.wrappers.Response.call_on_close", "type": "werkzeug.wrappers", "text": ["Adds a function to the internal list of functions that should be called as part of closing down the response. Since 0.7 this function also returns the function that was passed so that this can be used as a decorator.", "New in version 0.6.", "func (Callable[[], Any]) \u2013 ", "Callable[[], Any]"]}, {"name": "Response.close()", "path": "wrappers/index#werkzeug.wrappers.Response.close", "type": "werkzeug.wrappers", "text": ["Close the wrapped response if possible. You can also use the object in a with statement which will automatically close it.", "New in version 0.9: Can now be used in a with statement.", "None"]}, {"name": "Response.content_encoding", "path": "wrappers/index#werkzeug.wrappers.Response.content_encoding", "type": "werkzeug.wrappers", "text": ["The Content-Encoding entity-header field is used as a modifier to the media-type. When present, its value indicates what additional content codings have been applied to the entity-body, and thus what decoding mechanisms must be applied in order to obtain the media-type referenced by the Content-Type header field."]}, {"name": "Response.content_length", "path": "wrappers/index#werkzeug.wrappers.Response.content_length", "type": "werkzeug.wrappers", "text": ["The Content-Length entity-header field indicates the size of the entity-body, in decimal number of OCTETs, sent to the recipient or, in the case of the HEAD method, the size of the entity-body that would have been sent had the request been a GET."]}, {"name": "Response.content_location", "path": "wrappers/index#werkzeug.wrappers.Response.content_location", "type": "werkzeug.wrappers", "text": ["The Content-Location entity-header field MAY be used to supply the resource location for the entity enclosed in the message when that entity is accessible from a location separate from the requested resource\u2019s URI."]}, {"name": "Response.content_md5", "path": "wrappers/index#werkzeug.wrappers.Response.content_md5", "type": "werkzeug.wrappers", "text": ["The Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest of the entity-body for the purpose of providing an end-to-end message integrity check (MIC) of the entity-body. (Note: a MIC is good for detecting accidental modification of the entity-body in transit, but is not proof against malicious attacks.)"]}, {"name": "Response.content_security_policy", "path": "wrappers/index#werkzeug.wrappers.Response.content_security_policy", "type": "werkzeug.wrappers", "text": ["The Content-Security-Policy header adds an additional layer of security to help detect and mitigate certain types of attacks."]}, {"name": "Response.content_security_policy_report_only", "path": "wrappers/index#werkzeug.wrappers.Response.content_security_policy_report_only", "type": "werkzeug.wrappers", "text": ["The Content-Security-Policy-Report-Only header adds a csp policy that is not enforced but is reported thereby helping detect certain types of attacks."]}, {"name": "Response.content_type", "path": "wrappers/index#werkzeug.wrappers.Response.content_type", "type": "werkzeug.wrappers", "text": ["The Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of the HEAD method, the media type that would have been sent had the request been a GET."]}, {"name": "Response.cross_origin_embedder_policy", "path": "wrappers/index#werkzeug.wrappers.Response.cross_origin_embedder_policy", "type": "werkzeug.wrappers", "text": ["Prevents a document from loading any cross-origin resources that do not explicitly grant the document permission. Values must be a member of the werkzeug.http.COEP enum."]}, {"name": "Response.cross_origin_opener_policy", "path": "wrappers/index#werkzeug.wrappers.Response.cross_origin_opener_policy", "type": "werkzeug.wrappers", "text": ["Allows control over sharing of browsing context group with cross-origin documents. Values must be a member of the werkzeug.http.COOP enum."]}, {"name": "Response.date", "path": "wrappers/index#werkzeug.wrappers.Response.date", "type": "werkzeug.wrappers", "text": ["The Date general-header field represents the date and time at which the message was originated, having the same semantics as orig-date in RFC 822.", "Changed in version 2.0: The datetime object is timezone-aware."]}, {"name": "Response.delete_cookie()", "path": "wrappers/index#werkzeug.wrappers.Response.delete_cookie", "type": "werkzeug.wrappers", "text": ["Delete a cookie. Fails silently if key doesn\u2019t exist.", "None"]}, {"name": "Response.direct_passthrough", "path": "wrappers/index#werkzeug.wrappers.Response.direct_passthrough", "type": "werkzeug.wrappers", "text": ["Pass the response body directly through as the WSGI iterable. This can be used when the body is a binary file or other iterator of bytes, to skip some unnecessary checks. Use send_file() instead of setting this manually."]}, {"name": "Response.expires", "path": "wrappers/index#werkzeug.wrappers.Response.expires", "type": "werkzeug.wrappers", "text": ["The Expires entity-header field gives the date/time after which the response is considered stale. A stale cache entry may not normally be returned by a cache.", "Changed in version 2.0: The datetime object is timezone-aware."]}, {"name": "Response.force_type()", "path": "wrappers/index#werkzeug.wrappers.Response.force_type", "type": "werkzeug.wrappers", "text": ["Enforce that the WSGI response is a response object of the current type. Werkzeug will use the Response internally in many situations like the exceptions. If you call get_response() on an exception you will get back a regular Response object, even if you are using a custom subclass.", "This method can enforce a given response type, and it will also convert arbitrary WSGI callables into response objects if an environ is provided:", "This is especially useful if you want to post-process responses in the main dispatcher and use functionality provided by your subclass.", "Keep in mind that this will modify response objects in place if possible!", "a response object.", "Response"]}, {"name": "Response.freeze()", "path": "wrappers/index#werkzeug.wrappers.Response.freeze", "type": "werkzeug.wrappers", "text": ["Make the response object ready to be pickled. Does the following:", "Changed in version 2.0: An ETag header is added, the no_etag parameter is deprecated and will be removed in Werkzeug 2.1.", "Changed in version 0.6: The Content-Length header is set.", "no_etag (None) \u2013 ", "None"]}, {"name": "Response.from_app()", "path": "wrappers/index#werkzeug.wrappers.Response.from_app", "type": "werkzeug.wrappers", "text": ["Create a new response object from an application output. This works best if you pass it an application that returns a generator all the time. Sometimes applications may use the write() callable returned by the start_response function. This tries to resolve such edge cases automatically. But if you don\u2019t get the expected output you should set buffered to True which enforces buffering.", "a response object.", "Response"]}, {"name": "Response.get_app_iter()", "path": "wrappers/index#werkzeug.wrappers.Response.get_app_iter", "type": "werkzeug.wrappers", "text": ["Returns the application iterator for the given environ. Depending on the request method and the current status code the return value might be an empty response rather than the one from the response.", "If the request method is HEAD or the status code is in a range where the HTTP specification requires an empty response, an empty iterable is returned.", "New in version 0.6.", "environ (WSGIEnvironment) \u2013 the WSGI environment of the request.", "a response iterable.", "Iterable[bytes]"]}, {"name": "Response.get_data()", "path": "wrappers/index#werkzeug.wrappers.Response.get_data", "type": "werkzeug.wrappers", "text": ["The string representation of the response body. Whenever you call this property the response iterable is encoded and flattened. This can lead to unwanted behavior if you stream big data.", "This behavior can be disabled by setting implicit_sequence_conversion to False.", "If as_text is set to True the return value will be a decoded string.", "New in version 0.9.", "as_text (bool) \u2013 ", "Union[bytes, str]"]}, {"name": "Response.get_etag()", "path": "wrappers/index#werkzeug.wrappers.Response.get_etag", "type": "werkzeug.wrappers", "text": ["Return a tuple in the form (etag, is_weak). If there is no ETag the return value is (None, None).", "Union[Tuple[str, bool], Tuple[None, None]]"]}, {"name": "Response.get_json()", "path": "wrappers/index#werkzeug.wrappers.Response.get_json", "type": "werkzeug.wrappers", "text": ["Parse data as JSON. Useful during testing.", "If the mimetype does not indicate JSON (application/json, see is_json()), this returns None.", "Unlike Request.get_json(), the result is not cached.", "Optional[Any]"]}, {"name": "Response.get_wsgi_headers()", "path": "wrappers/index#werkzeug.wrappers.Response.get_wsgi_headers", "type": "werkzeug.wrappers", "text": ["This is automatically called right before the response is started and returns headers modified for the given environment. It returns a copy of the headers from the response with some modifications applied if necessary.", "For example the location header (if present) is joined with the root URL of the environment. Also the content length is automatically set to zero here for certain status codes.", "Changed in version 0.6: Previously that function was called fix_headers and modified the response object in place. Also since 0.6, IRIs in location and content-location headers are handled properly.", "Also starting with 0.6, Werkzeug will attempt to set the content length if it is able to figure it out on its own. This is the case if all the strings in the response iterable are already encoded and the iterable is buffered.", "environ (WSGIEnvironment) \u2013 the WSGI environment of the request.", "returns a new Headers object.", "werkzeug.datastructures.Headers"]}, {"name": "Response.get_wsgi_response()", "path": "wrappers/index#werkzeug.wrappers.Response.get_wsgi_response", "type": "werkzeug.wrappers", "text": ["Returns the final WSGI response as tuple. The first item in the tuple is the application iterator, the second the status and the third the list of headers. The response returned is created specially for the given environment. For example if the request method in the WSGI environment is 'HEAD' the response will be empty and only the headers and status code will be present.", "New in version 0.6.", "environ (WSGIEnvironment) \u2013 the WSGI environment of the request.", "an (app_iter, status, headers) tuple.", "Tuple[Iterable[bytes], str, List[Tuple[str, str]]]"]}, {"name": "Response.implicit_sequence_conversion", "path": "wrappers/index#werkzeug.wrappers.Response.implicit_sequence_conversion", "type": "werkzeug.wrappers", "text": ["if set to False accessing properties on the response object will not try to consume the response iterator and convert it into a list.", "New in version 0.6.2: That attribute was previously called implicit_seqence_conversion. (Notice the typo). If you did use this feature, you have to adapt your code to the name change."]}, {"name": "Response.iter_encoded()", "path": "wrappers/index#werkzeug.wrappers.Response.iter_encoded", "type": "werkzeug.wrappers", "text": ["Iter the response encoded with the encoding of the response. If the response object is invoked as WSGI application the return value of this method is used as application iterator unless direct_passthrough was activated.", "Iterator[bytes]"]}, {"name": "Response.json_module", "path": "wrappers/index#werkzeug.wrappers.Response.json_module", "type": "werkzeug.wrappers", "text": ["A module or other object that has dumps and loads functions that match the API of the built-in json module."]}, {"name": "Response.last_modified", "path": "wrappers/index#werkzeug.wrappers.Response.last_modified", "type": "werkzeug.wrappers", "text": ["The Last-Modified entity-header field indicates the date and time at which the origin server believes the variant was last modified.", "Changed in version 2.0: The datetime object is timezone-aware."]}, {"name": "Response.location", "path": "wrappers/index#werkzeug.wrappers.Response.location", "type": "werkzeug.wrappers", "text": ["The Location response-header field is used to redirect the recipient to a location other than the Request-URI for completion of the request or identification of a new resource."]}, {"name": "Response.make_conditional()", "path": "wrappers/index#werkzeug.wrappers.Response.make_conditional", "type": "werkzeug.wrappers", "text": ["Make the response conditional to the request. This method works best if an etag was defined for the response already. The add_etag method can be used to do that. If called without etag just the date header is set.", "This does nothing if the request method in the request or environ is anything but GET or HEAD.", "For optimal performance when handling range requests, it\u2019s recommended that your response data object implements seekable, seek and tell methods as described by io.IOBase. Objects returned by wrap_file() automatically implement those methods.", "It does not remove the body of the response because that\u2019s something the __call__() function does for us automatically.", "Returns self so that you can do return resp.make_conditional(req) but modifies the object in-place.", "RequestedRangeNotSatisfiable if Range header could not be parsed or satisfied.", "Response", "Changed in version 2.0: Range processing is skipped if length is 0 instead of raising a 416 Range Not Satisfiable error."]}, {"name": "Response.make_sequence()", "path": "wrappers/index#werkzeug.wrappers.Response.make_sequence", "type": "werkzeug.wrappers", "text": ["Converts the response iterator in a list. By default this happens automatically if required. If implicit_sequence_conversion is disabled, this method is not automatically called and some properties might raise exceptions. This also encodes all the items.", "New in version 0.6.", "None"]}, {"name": "Response.response", "path": "wrappers/index#werkzeug.wrappers.Response.response", "type": "werkzeug.wrappers", "text": ["The response body to send as the WSGI iterable. A list of strings or bytes represents a fixed-length response, any other iterable is a streaming response. Strings are encoded to bytes as UTF-8.", "Do not set to a plain string or bytes, that will cause sending the response to be very inefficient as it will iterate one byte at a time."]}, {"name": "Response.set_cookie()", "path": "wrappers/index#werkzeug.wrappers.Response.set_cookie", "type": "werkzeug.wrappers", "text": ["Sets a cookie.", "A warning is raised if the size of the cookie header exceeds max_cookie_size, but the header will still be set.", "None"]}, {"name": "Response.set_data()", "path": "wrappers/index#werkzeug.wrappers.Response.set_data", "type": "werkzeug.wrappers", "text": ["Sets a new string as response. The value must be a string or bytes. If a string is set it\u2019s encoded to the charset of the response (utf-8 by default).", "New in version 0.9.", "value (Union[bytes, str]) \u2013 ", "None"]}, {"name": "Response.set_etag()", "path": "wrappers/index#werkzeug.wrappers.Response.set_etag", "type": "werkzeug.wrappers", "text": ["Set the etag, and override the old one if there was one.", "None"]}, {"name": "Response._ensure_sequence()", "path": "wrappers/index#werkzeug.wrappers.Response._ensure_sequence", "type": "werkzeug.wrappers", "text": ["This method can be called by methods that need a sequence. If mutable is true, it will also ensure that the response sequence is a standard Python list.", "New in version 0.6.", "mutable (bool) \u2013 ", "None"]}, {"name": "Response.__call__()", "path": "wrappers/index#werkzeug.wrappers.Response.__call__", "type": "werkzeug.wrappers", "text": ["Process this response as WSGI application.", "an application iterator", "Iterable[bytes]"]}, {"name": "ResponseCacheControl", "path": "datastructures/index#werkzeug.datastructures.ResponseCacheControl", "type": "werkzeug.datastructures", "text": ["A cache control for responses. Unlike RequestCacheControl this is mutable and gives access to response-relevant cache control headers.", "To get a header of the ResponseCacheControl object again you can convert the object into a string or call the to_header() method. If you plan to subclass it and add your own items have a look at the sourcecode for that class.", "New in version 0.5: In previous versions a CacheControl class existed that was used both for request and response.", "accessor for \u2018no-cache\u2019", "accessor for \u2018no-store\u2019", "accessor for \u2018max-age\u2019", "accessor for \u2018no-transform\u2019", "accessor for \u2018immutable\u2019", "accessor for \u2018must-revalidate\u2019", "accessor for \u2018private\u2019", "accessor for \u2018proxy-revalidate\u2019", "accessor for \u2018public\u2019", "accessor for \u2018s-maxage\u2019"]}, {"name": "ResponseCacheControl.max_age", "path": "datastructures/index#werkzeug.datastructures.ResponseCacheControl.max_age", "type": "werkzeug.datastructures", "text": ["accessor for \u2018max-age\u2019"]}, {"name": "ResponseCacheControl.no_cache", "path": "datastructures/index#werkzeug.datastructures.ResponseCacheControl.no_cache", "type": "werkzeug.datastructures", "text": ["accessor for \u2018no-cache\u2019"]}, {"name": "ResponseCacheControl.no_store", "path": "datastructures/index#werkzeug.datastructures.ResponseCacheControl.no_store", "type": "werkzeug.datastructures", "text": ["accessor for \u2018no-store\u2019"]}, {"name": "ResponseCacheControl.no_transform", "path": "datastructures/index#werkzeug.datastructures.ResponseCacheControl.no_transform", "type": "werkzeug.datastructures", "text": ["accessor for \u2018no-transform\u2019"]}, {"name": "Rule", "path": "routing/index#werkzeug.routing.Rule", "type": "werkzeug.routing", "text": ["A Rule represents one URL pattern. There are some options for Rule that change the way it behaves and are passed to the Rule constructor. Note that besides the rule-string all arguments must be keyword arguments in order to not break the application on Werkzeug upgrades.", "Rule strings basically are just normal URL paths with placeholders in the format <converter(arguments):name> where the converter and the arguments are optional. If no converter is defined the default converter is used which means string in the normal configuration.", "URL rules that end with a slash are branch URLs, others are leaves. If you have strict_slashes enabled (which is the default), all branch URLs that are matched without a trailing slash will trigger a redirect to the same URL with the missing slash appended.", "The converters are defined on the Map.", "The endpoint for this rule. This can be anything. A reference to a function, a string, a number etc. The preferred way is using a string because the endpoint is used for URL generation.", "An optional dict with defaults for other rules with the same endpoint. This is a bit tricky but useful if you want to have unique URLs:", "If a user now visits http://example.com/all/page/1 he will be redirected to http://example.com/all/. If redirect_defaults is disabled on the Map instance this will only affect the URL generation.", "The subdomain rule string for this rule. If not specified the rule only matches for the default_subdomain of the map. If the map is not bound to a subdomain this feature is disabled.", "Can be useful if you want to have user profiles on different subdomains and all subdomains are forwarded to your application:", "A sequence of http methods this rule applies to. If not specified, all methods are allowed. For example this can be useful if you want different endpoints for POST and GET. If methods are defined and the path matches but the method matched against is not in this list or in the list of another rule for that path the error raised is of the type MethodNotAllowed rather than NotFound. If GET is present in the list of methods and HEAD is not, HEAD is added automatically.", "Override the Map setting for strict_slashes only for this rule. If not specified the Map setting is used.", "Override Map.merge_slashes for this rule.", "Set this to True and the rule will never match but will create a URL that can be build. This is useful if you have resources on a subdomain or folder that are not handled by the WSGI application (like static data)", "If given this must be either a string or callable. In case of a callable it\u2019s called with the url adapter that triggered the match and the values of the URL as keyword arguments and has to return the target for the redirect, otherwise it has to be a string with placeholders in rule syntax:", "When the rule is matched the routing system will raise a RequestRedirect exception with the target for the redirect.", "Keep in mind that the URL will be joined against the URL root of the script so don\u2019t use a leading slash on the target URL unless you really mean root of that domain.", "If enabled this rule serves as an alias for another rule with the same endpoint and arguments.", "If provided and the URL map has host matching enabled this can be used to provide a match rule for the whole host. This also means that the subdomain feature is disabled.", "If True, this rule is only matches for WebSocket (ws://, wss://) requests. By default, rules will only match for HTTP requests.", "New in version 1.0: Added websocket.", "New in version 1.0: Added merge_slashes.", "New in version 0.7: Added alias and host.", "Changed in version 0.6.1: HEAD is added to methods if GET is present.", "None", "Return an unbound copy of this rule.", "This can be useful if want to reuse an already bound URL for another map. See get_empty_kwargs to override what keyword arguments are provided to the new copy.", "werkzeug.routing.Rule"]}, {"name": "Rule.empty()", "path": "routing/index#werkzeug.routing.Rule.empty", "type": "werkzeug.routing", "text": ["Return an unbound copy of this rule.", "This can be useful if want to reuse an already bound URL for another map. See get_empty_kwargs to override what keyword arguments are provided to the new copy.", "werkzeug.routing.Rule"]}, {"name": "RuleFactory", "path": "routing/index#werkzeug.routing.RuleFactory", "type": "werkzeug.routing", "text": ["As soon as you have more complex URL setups it\u2019s a good idea to use rule factories to avoid repetitive tasks. Some of them are builtin, others can be added by subclassing RuleFactory and overriding get_rules.", "Subclasses of RuleFactory have to override this method and return an iterable of rules.", "map (werkzeug.routing.Map) \u2013 ", "Iterable[werkzeug.routing.Rule]"]}, {"name": "RuleFactory.get_rules()", "path": "routing/index#werkzeug.routing.RuleFactory.get_rules", "type": "werkzeug.routing", "text": ["Subclasses of RuleFactory have to override this method and return an iterable of rules.", "map (werkzeug.routing.Map) \u2013 ", "Iterable[werkzeug.routing.Rule]"]}, {"name": "RuleTemplate", "path": "routing/index#werkzeug.routing.RuleTemplate", "type": "werkzeug.routing", "text": ["Returns copies of the rules wrapped and expands string templates in the endpoint, rule, defaults or subdomain sections.", "Here a small example for such a rule template:", "When a rule template is called the keyword arguments are used to replace the placeholders in all the string parameters.", "rules (Iterable[Rule]) \u2013 ", "None"]}, {"name": "run_simple()", "path": "serving/index#werkzeug.serving.run_simple", "type": "werkzeug.serving", "text": ["Start a WSGI application. Optional features include a reloader, multithreading and fork support.", "This function has a command-line interface too:", "Changed in version 2.0: Added exclude_patterns parameter.", "Changed in version 0.15: Bind to a Unix socket by passing a path that starts with unix:// as the hostname.", "New in version 0.10: Improved the reloader and added support for changing the backend through the reloader_type parameter. See Reloader for more information.", "New in version 0.9: Added command-line interface.", "New in version 0.8: Added support for automatically loading a SSL context from certificate file and private key.", "New in version 0.6: support for SSL was added.", "New in version 0.5: static_files was added to simplify serving of static files as well as passthrough_errors.", "None"]}, {"name": "run_wsgi_app()", "path": "test/index#werkzeug.test.run_wsgi_app", "type": "werkzeug.test", "text": ["Return a tuple in the form (app_iter, status, headers) of the application output. This works best if you pass it an application that returns an iterator all the time.", "Sometimes applications may use the write() callable returned by the start_response function. This tries to resolve such edge cases automatically. But if you don\u2019t get the expected output you should set buffered to True which enforces buffering.", "If passed an invalid WSGI application the behavior of this function is undefined. Never pass non-conforming WSGI applications to this function.", "tuple in the form (app_iter, status, headers)", "Tuple[Iterable[bytes], str, werkzeug.datastructures.Headers]"]}, {"name": "safe_join()", "path": "utils/index#werkzeug.security.safe_join", "type": "werkzeug.security", "text": ["Safely join zero or more untrusted path components to a base directory to avoid escaping the base directory.", "A safe path, otherwise None.", "Optional[str]"]}, {"name": "safe_str_cmp()", "path": "utils/index#werkzeug.security.safe_str_cmp", "type": "werkzeug.security", "text": ["This function compares strings in somewhat constant time. This requires that the length of at least one string is known in advance.", "Returns True if the two strings are equal, or False if they are not.", "Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use hmac.compare_digest() instead.", "New in version 0.7.", "bool"]}, {"name": "secure_filename()", "path": "utils/index#werkzeug.utils.secure_filename", "type": "werkzeug.utils", "text": ["Pass it a filename and it will return a secure version of it. This filename can then safely be stored on a regular file system and passed to os.path.join(). The filename returned is an ASCII only string for maximum portability.", "On windows systems the function also makes sure that the file is not named after one of the special device files.", "The function might return an empty filename. It\u2019s your responsibility to ensure that the filename is unique and that you abort or generate a random filename if the function returned an empty one.", "New in version 0.5.", "filename (str) \u2013 the filename to secure", "str"]}, {"name": "send_file()", "path": "utils/index#werkzeug.utils.send_file", "type": "werkzeug.utils", "text": ["Send the contents of a file to the client.", "The first argument can be a file path or a file-like object. Paths are preferred in most cases because Werkzeug can manage the file and get extra information from the path. Passing a file-like object requires that the file is opened in binary mode, and is mostly useful when building a file in memory with io.BytesIO.", "Never pass file paths provided by a user. The path is assumed to be trusted, so a user could craft a path to access a file you didn\u2019t intend.", "If the WSGI server sets a file_wrapper in environ, it is used, otherwise Werkzeug\u2019s built-in wrapper is used. Alternatively, if the HTTP server supports X-Sendfile, use_x_sendfile=True will tell the server to send the given path, which is much more efficient than reading it in Python.", "Response", "New in version 2.0: Adapted from Flask\u2019s implementation.", "Changed in version 2.0: download_name replaces Flask\u2019s attachment_filename parameter. If as_attachment=False, it is passed with Content-Disposition: inline instead.", "Changed in version 2.0: max_age replaces Flask\u2019s cache_timeout parameter. conditional is enabled and max_age is not set by default.", "Changed in version 2.0: etag replaces Flask\u2019s add_etags parameter. It can be a string to use instead of generating one.", "Changed in version 2.0: If an encoding is returned when guessing mimetype from download_name, set the Content-Encoding header."]}, {"name": "Serve Shared Static Files", "path": "middleware/shared_data/index", "type": "Other", "text": ["A WSGI middleware which provides static content for development environments or simple server setups. Its usage is quite simple:", "The contents of the folder ./shared will now be available on http://example.com/shared/. This is pretty useful during development because a standalone media server is not required. Files can also be mounted on the root folder and still continue to use the application because the shared data middleware forwards all unhandled requests to the application, even if the requests are below one of the shared folders.", "If pkg_resources is available you can also tell the middleware to serve files from package data:", "This will then serve the static folder in the myapplication Python package.", "The optional disallow parameter can be a list of fnmatch() rules for files that are not accessible from the web. If cache is set to False no caching headers are sent.", "Currently the middleware does not support non-ASCII filenames. If the encoding on the file system happens to match the encoding of the URI it may work but this could also be by accident. We strongly suggest using ASCII only file names for static files.", "The middleware will guess the mimetype using the Python mimetype module. If it\u2019s unable to figure out the charset it will fall back to fallback_mimetype.", "None", "Changed in version 1.0: The default fallback_mimetype is application/octet-stream. If a filename looks like a text mimetype, the utf-8 charset is added to it.", "New in version 0.6: Added fallback_mimetype.", "Changed in version 0.5: Added cache_timeout.", "Subclasses can override this method to disallow the access to certain files. However by providing disallow in the constructor this method is overwritten.", "filename (str) \u2013 ", "bool"]}, {"name": "Serving WSGI Applications", "path": "serving/index", "type": "Other", "text": ["There are many ways to serve a WSGI application. While you\u2019re developing it, you usually don\u2019t want to have a full-blown webserver like Apache up and running, but instead a simple standalone one. Because of that Werkzeug comes with a builtin development server.", "The easiest way is creating a small start-myproject.py file that runs the application using the builtin server:", "You can also pass it the extra_files keyword argument with a list of additional files (like configuration files) you want to observe.", "Start a WSGI application. Optional features include a reloader, multithreading and fork support.", "This function has a command-line interface too:", "Changed in version 2.0: Added exclude_patterns parameter.", "Changed in version 0.15: Bind to a Unix socket by passing a path that starts with unix:// as the hostname.", "New in version 0.10: Improved the reloader and added support for changing the backend through the reloader_type parameter. See Reloader for more information.", "New in version 0.9: Added command-line interface.", "New in version 0.8: Added support for automatically loading a SSL context from certificate file and private key.", "New in version 0.6: support for SSL was added.", "New in version 0.5: static_files was added to simplify serving of static files as well as passthrough_errors.", "None", "Checks if the application is running from within the Werkzeug reloader subprocess.", "New in version 0.10.", "bool", "Creates an SSL key for development. This should be used instead of the 'adhoc' key which generates a new cert on each server start. It accepts a path for where it should store the key and cert and either a host or CN. If a host is given it will use the CN *.host/CN=host.", "For more information see run_simple().", "New in version 0.9.", "Tuple[str, str]", "Information", "The development server is not intended to be used on production systems. It was designed especially for development purposes and performs poorly under high load. For deployment setups have a look at the Application Deployment pages.", "Changed in version 0.10.", "The Werkzeug reloader constantly monitors modules and paths of your web application, and restarts the server if any of the observed files change.", "Since version 0.10, there are two backends the reloader supports: stat and watchdog.", "If watchdog is installed and available it will automatically be used instead of the builtin stat reloader.", "To switch between the backends you can use the reloader_type parameter of the run_simple() function. 'stat' sets it to the default stat based polling and 'watchdog' forces it to the watchdog backend.", "Note", "Some edge cases, like modules that failed to import correctly, are not handled by the stat reloader for performance reasons. The watchdog reloader monitors such files too.", "The development server highlights the request logs in different colors based on the status code. On Windows, Colorama must be installed as well to enable this.", "Many web applications utilize multiple subdomains. This can be a bit tricky to simulate locally. Fortunately there is the hosts file that can be used to assign the local computer multiple names.", "This allows you to call your local computer yourapplication.local and api.yourapplication.local (or anything else) in addition to localhost.", "You can find the hosts file on the following location:", "Windows", "%SystemRoot%\\system32\\drivers\\etc\\hosts", "Linux / OS X", "/etc/hosts", "You can open the file with your favorite text editor and add a new name after localhost:", "Save the changes and after a while you should be able to access the development server on these host names as well. You can use the URL Routing system to dispatch between different hosts or parse request.host yourself.", "New in version 0.7.", "Starting with Werkzeug 0.7 the development server provides a way to shut down the server after a request. This currently only works with Python 2.6 and later and will only work with the development server. To initiate the shutdown you have to call a function named 'werkzeug.server.shutdown' in the WSGI environment:", "On operating systems that support ipv6 and have it configured such as modern Linux systems, OS X 10.4 or higher as well as Windows Vista some browsers can be painfully slow if accessing your local server. The reason for this is that sometimes \u201clocalhost\u201d is configured to be available on both ipv4 and ipv6 sockets and some browsers will try to access ipv6 first and then ipv4.", "At the current time the integrated webserver does not support ipv6 and ipv4 at the same time and for better portability ipv4 is the default.", "If you notice that the web browser takes ages to load the page there are two ways around this issue. If you don\u2019t need ipv6 support you can disable the ipv6 entry in the hosts file by removing this line:", "Alternatively you can also disable ipv6 support in your browser. For example if Firefox shows this behavior you can disable it by going to about:config and disabling the network.dns.disableIPv6 key. This however is not recommended as of Werkzeug 0.6.1!", "Starting with Werkzeug 0.6.1, the server will now switch between ipv4 and ipv6 based on your operating system\u2019s configuration. This means if that you disabled ipv6 support in your browser but your operating system is preferring ipv6, you will be unable to connect to your server. In that situation, you can either remove the localhost entry for ::1 or explicitly bind the hostname to an ipv4 address (127.0.0.1)", "New in version 0.6.", "The builtin server supports SSL for testing purposes. If an SSL context is provided it will be used. That means a server can either run in HTTP or HTTPS mode, but not both.", "The easiest way to do SSL based development with Werkzeug is by using it to generate an SSL certificate and private key and storing that somewhere and to then put it there. For the certificate you need to provide the name of your server on generation or a CN.", "Generate an SSL key and store it somewhere:", "Now this tuple can be passed as ssl_context to the run_simple() method:", "You will have to acknowledge the certificate in your browser once then.", "You can use a ssl.SSLContext object instead of a tuple for full control over the TLS configuration.", "A key and certificate can be created in advance using the openssl tool instead of the make_ssl_devcert(). This requires that you have the openssl command installed on your system:", "The easiest way to enable SSL is to start the server in adhoc-mode. In that case Werkzeug will generate an SSL certificate for you:", "The downside of this of course is that you will have to acknowledge the certificate each time the server is reloaded. Adhoc certificates are discouraged because modern browsers do a bad job at supporting them for security reasons.", "This feature requires the cryptography library to be installed.", "The dev server can bind to a Unix socket instead of a TCP socket. run_simple() will bind to a Unix socket if the hostname parameter starts with 'unix://'."]}, {"name": "SharedDataMiddleware", "path": "middleware/shared_data/index#werkzeug.middleware.shared_data.SharedDataMiddleware", "type": "werkzeug.middleware.shared_data", "text": ["A WSGI middleware which provides static content for development environments or simple server setups. Its usage is quite simple:", "The contents of the folder ./shared will now be available on http://example.com/shared/. This is pretty useful during development because a standalone media server is not required. Files can also be mounted on the root folder and still continue to use the application because the shared data middleware forwards all unhandled requests to the application, even if the requests are below one of the shared folders.", "If pkg_resources is available you can also tell the middleware to serve files from package data:", "This will then serve the static folder in the myapplication Python package.", "The optional disallow parameter can be a list of fnmatch() rules for files that are not accessible from the web. If cache is set to False no caching headers are sent.", "Currently the middleware does not support non-ASCII filenames. If the encoding on the file system happens to match the encoding of the URI it may work but this could also be by accident. We strongly suggest using ASCII only file names for static files.", "The middleware will guess the mimetype using the Python mimetype module. If it\u2019s unable to figure out the charset it will fall back to fallback_mimetype.", "None", "Changed in version 1.0: The default fallback_mimetype is application/octet-stream. If a filename looks like a text mimetype, the utf-8 charset is added to it.", "New in version 0.6: Added fallback_mimetype.", "Changed in version 0.5: Added cache_timeout.", "Subclasses can override this method to disallow the access to certain files. However by providing disallow in the constructor this method is overwritten.", "filename (str) \u2013 ", "bool"]}, {"name": "SharedDataMiddleware.is_allowed()", "path": "middleware/shared_data/index#werkzeug.middleware.shared_data.SharedDataMiddleware.is_allowed", "type": "werkzeug.middleware.shared_data", "text": ["Subclasses can override this method to disallow the access to certain files. However by providing disallow in the constructor this method is overwritten.", "filename (str) \u2013 ", "bool"]}, {"name": "Subdomain", "path": "routing/index#werkzeug.routing.Subdomain", "type": "werkzeug.routing", "text": ["All URLs provided by this factory have the subdomain set to a specific domain. For example if you want to use the subdomain for the current language this can be a good setup:", "All the rules except for the '#select_language' endpoint will now listen on a two letter long subdomain that holds the language code for the current request.", "None"]}, {"name": "Submount", "path": "routing/index#werkzeug.routing.Submount", "type": "werkzeug.routing", "text": ["Like Subdomain but prefixes the URL rule with a given string:", "Now the rule 'blog/show' matches /blog/entry/<entry_slug>.", "None"]}, {"name": "Testing WSGI Applications", "path": "test/index", "type": "Other", "text": ["Werkzeug provides a Client to simulate requests to a WSGI application without starting a server. The client has methods for making different types of requests, as well as managing cookies across requests.", "The client\u2019s request methods return instances of TestResponse. This provides extra attributes and methods on top of Response that are useful for testing.", "By passing a dict to data, the client will construct a request body with file and form data. It will set the content type to application/x-www-form-urlencoded if there are no files, or multipart/form-data there are.", "Pass a string, bytes, or file-like object to data to use that as the raw request body. In that case, you should set the content type appropriately. For example, to post YAML:", "A shortcut when testing JSON APIs is to pass a dict to json instead of using data. This will automatically call json.dumps() and set the content type to application/json. Additionally, if the app returns JSON, response.json will automatically call json.loads().", "EnvironBuilder is used to construct a WSGI environ dict. The test client uses this internally to prepare its requests. The arguments passed to the client request methods are the same as the builder.", "Sometimes, it can be useful to construct a WSGI environment manually. An environ builder or dict can be passed to the test client request methods in place of other arguments to use a custom environ.", "The test client responses make this available through TestResponse.request and response.request.environ.", "This class allows you to send requests to a wrapped application.", "The use_cookies parameter indicates whether cookies should be stored and sent for subsequent requests. This is True by default, but passing False will disable this behaviour.", "If you want to request some subdomain of your application you may set allow_subdomain_redirects to True as if not no external redirects are allowed.", "Changed in version 2.0: response_wrapper is always a subclass of :class:TestResponse.", "Changed in version 0.5: Added the use_cookies parameter.", "None", "Sets a cookie in the client\u2019s cookie jar. The server name is required and has to match the one that is also passed to the open call.", "None", "Deletes a cookie in the test client.", "None", "Generate an environ dict from the given arguments, make a request to the application using it, and return the response.", "werkzeug.test.TestResponse", "Changed in version 2.0: as_tuple is deprecated and will be removed in Werkzeug 2.1. Use TestResponse.request and request.environ instead.", "Changed in version 2.0: The request input stream is closed when calling response.close(). Input streams for redirects are automatically closed.", "Changed in version 0.5: If a dict is provided as file in the dict for the data parameter the content type has to be called content_type instead of mimetype. This change was made for consistency with werkzeug.FileWrapper.", "Changed in version 0.5: Added the follow_redirects parameter.", "Call open() with method set to GET.", "werkzeug.test.TestResponse", "Call open() with method set to POST.", "werkzeug.test.TestResponse", "Call open() with method set to PUT.", "werkzeug.test.TestResponse", "Call open() with method set to DELETE.", "werkzeug.test.TestResponse", "Call open() with method set to PATCH.", "werkzeug.test.TestResponse", "Call open() with method set to OPTIONS.", "werkzeug.test.TestResponse", "Call open() with method set to HEAD.", "werkzeug.test.TestResponse", "Call open() with method set to TRACE.", "werkzeug.test.TestResponse", "Response subclass that provides extra information about requests made with the test Client.", "Test client requests will always return an instance of this class. If a custom response class is passed to the client, it is subclassed along with this to support test information.", "If the test request included large files, or if the application is serving a file, call close() to close any open files and prevent Python showing a ResourceWarning.", "None", "A request object with the environ used to make the request that resulted in this response.", "A list of intermediate responses. Populated when the test request is made with follow_redirects enabled.", "This class can be used to conveniently create a WSGI environment for testing purposes. It can be used to quickly create WSGI environments or request objects from arbitrary data.", "The signature of this class is also used in some other places as of Werkzeug 0.5 (create_environ(), Response.from_values(), Client.open()). Because of this most of the functionality is available through the constructor alone.", "Files and regular form data can be manipulated independently of each other with the form and files attributes, but are passed with the same argument to the constructor: data.", "data can be any of these values:", "a dict or MultiDict: The keys have to be strings. The values have to be either any of the following objects, or a list of any of the following objects:", "None", "Changed in version 2.0: REQUEST_URI and RAW_URI is the full raw URI including the query string, not only the path.", "Changed in version 2.0: The default request_class is Request instead of BaseRequest.", "New in version 2.0: Added the auth parameter.", "New in version 0.15: The json param and json_dumps() method.", "New in version 0.15: The environ has keys REQUEST_URI and RAW_URI containing the path before perecent-decoding. This is not part of the WSGI PEP, but many WSGI servers include it.", "Changed in version 0.6: path and base_url can now be unicode strings that are encoded with iri_to_uri().", "the server protocol to use. defaults to HTTP/1.1", "the wsgi version to use. defaults to (1, 0)", "alias of werkzeug.wrappers.request.Request", "The serialization function used when json is passed.", "Turn an environ dict back into a builder. Any extra kwargs override the args extracted from the environ.", "Changed in version 2.0: Path and query values are passed through the WSGI decoding dance to avoid double encoding.", "New in version 0.15.", "EnvironBuilder", "The base URL is used to extract the URL scheme, host name, port, and root path.", "The content type for the request. Reflected from and to the headers. Do not set if you set files or form for auto detection.", "The mimetype (content type without charset etc.)", "New in version 0.14.", "The mimetype parameters as dict. For example if the content type is text/html; charset=utf-8 the params would be {'charset': 'utf-8'}.", "New in version 0.14.", "The content length as integer. Reflected from and to the headers. Do not set if you set files or form for auto detection.", "A MultiDict of form values.", "A FileMultiDict of uploaded files. Use add_file() to add new files.", "An optional input stream. This is mutually exclusive with setting form and files, setting it will clear those. Do not provide this if the method is not POST or another method that has a body.", "The query string. If you set this to a string args will no longer be available.", "The URL arguments as MultiDict.", "The server name (read-only, use host to set)", "The server port as integer (read-only, use host to set)", "Closes all files. If you put real file objects into the files dict you can call this method to automatically close them all in one go.", "None", "Return the built environ.", "Changed in version 0.15: The content type and length headers are set based on input stream detection. Previously this only set the WSGI keys.", "WSGIEnvironment", "Returns a request with the data. If the request class is not specified request_class is used.", "cls (Optional[Type[werkzeug.wrappers.request.Request]]) \u2013 The request wrapper to use.", "werkzeug.wrappers.request.Request", "Create a new WSGI environ dict based on the values passed. The first parameter should be the path of the request which defaults to \u2018/\u2019. The second one can either be an absolute path (in that case the host is localhost:80) or a full path to the request with scheme, netloc port and the path to the script.", "This accepts the same arguments as the EnvironBuilder constructor.", "Changed in version 0.5: This function is now a thin wrapper over EnvironBuilder which was added in 0.5. The headers, environ_base, environ_overrides and charset parameters were added.", "WSGIEnvironment", "Return a tuple in the form (app_iter, status, headers) of the application output. This works best if you pass it an application that returns an iterator all the time.", "Sometimes applications may use the write() callable returned by the start_response function. This tries to resolve such edge cases automatically. But if you don\u2019t get the expected output you should set buffered to True which enforces buffering.", "If passed an invalid WSGI application the behavior of this function is undefined. Never pass non-conforming WSGI applications to this function.", "tuple in the form (app_iter, status, headers)", "Tuple[Iterable[bytes], str, werkzeug.datastructures.Headers]"]}, {"name": "TestResponse", "path": "test/index#werkzeug.test.TestResponse", "type": "werkzeug.test", "text": ["Response subclass that provides extra information about requests made with the test Client.", "Test client requests will always return an instance of this class. If a custom response class is passed to the client, it is subclassed along with this to support test information.", "If the test request included large files, or if the application is serving a file, call close() to close any open files and prevent Python showing a ResourceWarning.", "None", "A request object with the environ used to make the request that resulted in this response.", "A list of intermediate responses. Populated when the test request is made with follow_redirects enabled."]}, {"name": "TestResponse.history", "path": "test/index#werkzeug.test.TestResponse.history", "type": "werkzeug.test", "text": ["A list of intermediate responses. Populated when the test request is made with follow_redirects enabled."]}, {"name": "TestResponse.request", "path": "test/index#werkzeug.test.TestResponse.request", "type": "werkzeug.test", "text": ["A request object with the environ used to make the request that resulted in this response."]}, {"name": "test_app()", "path": "wsgi/index#werkzeug.testapp.test_app", "type": "werkzeug.testapp", "text": ["Simple test application that dumps the environment. You can use it to check if Werkzeug is working properly:", "The application displays important information from the WSGI environment, the Python interpreter and the installed libraries.", "Iterable[bytes]"]}, {"name": "TypeConversionDict", "path": "datastructures/index#werkzeug.datastructures.TypeConversionDict", "type": "werkzeug.datastructures", "text": ["Works like a regular dict but the get() method can perform type conversions. MultiDict and CombinedMultiDict are subclasses of this class and provide the same feature.", "New in version 0.5.", "Return the default value if the requested data doesn\u2019t exist. If type is provided and is a callable it should convert the value, return it or raise a ValueError if that is not possible. In this case the function will return the default as if the value was not found:"]}, {"name": "TypeConversionDict.get()", "path": "datastructures/index#werkzeug.datastructures.TypeConversionDict.get", "type": "werkzeug.datastructures", "text": ["Return the default value if the requested data doesn\u2019t exist. If type is provided and is a callable it should convert the value, return it or raise a ValueError if that is not possible. In this case the function will return the default as if the value was not found:"]}, {"name": "unescape()", "path": "utils/index#werkzeug.utils.unescape", "type": "werkzeug.utils", "text": ["The reverse of escape(). This unescapes all the HTML entities, not only those inserted by escape.", "Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use MarkupSafe instead.", "s (str) \u2013 ", "str"]}, {"name": "Unicode", "path": "unicode/index", "type": "Other", "text": ["Werkzeug uses strings internally everwhere text data is assumed, even if the HTTP standard is not Unicode aware. Basically all incoming data is decoded from the charset (UTF-8 by default) so that you don\u2019t work with bytes directly. Outgoing data is encoded into the target charset.", "Imagine you have the German Umlaut \u00f6. In ASCII you cannot represent that character, but in the latin-1 and utf-8 character sets you can represent it, but they look different when encoded:", "An \u00f6 looks different depending on the encoding which makes it hard to work with it as bytes. Instead, Python treats strings as Unicode text and stores the information LATIN SMALL LETTER O WITH DIAERESIS instead of the bytes for \u00f6 in a specific encoding. The length of a string with 1 character will be 1, where the length of the bytes might be some other value.", "However, the HTTP spec was written in a time where ASCII bytes were the common way data was represented. To work around this for the modern web, Werkzeug decodes and encodes incoming and outgoing data automatically. Data sent from the browser to the web application is decoded from UTF-8 bytes into a string. Data sent from the application back to the browser is encoded back to UTF-8.", "Functions that do internal encoding or decoding accept an errors keyword argument that is passed to str.decode() and str.encode(). The default is 'replace' so that errors are easy to spot. It might be useful to set it to 'strict' in order to catch the error and report the bad data to the client.", "In most cases, you should stick with Werkzeug\u2019s default encoding of UTF-8. If you have a specific reason to, you can subclass wrappers.Request and wrappers.Response to change the encoding and error handling.", "The error handling can only be changed for the request. Werkzeug will always raise errors when encoding to bytes in the response. It\u2019s your responsibility to not create data that is not present in the target charset. This is not an issue for UTF-8."]}, {"name": "UnicodeConverter", "path": "routing/index#werkzeug.routing.UnicodeConverter", "type": "werkzeug.routing", "text": ["This converter is the default converter and accepts any string but only one path segment. Thus the string can not include a slash.", "This is the default validator.", "Example:", "None"]}, {"name": "unquote_etag()", "path": "http/index#werkzeug.http.unquote_etag", "type": "werkzeug.http", "text": ["Unquote a single etag:", "etag (Optional[str]) \u2013 the etag identifier to unquote.", "a (etag, weak) tuple.", "Union[Tuple[str, bool], Tuple[None, None]]"]}, {"name": "unquote_header_value()", "path": "http/index#werkzeug.http.unquote_header_value", "type": "werkzeug.http", "text": ["Unquotes a header value. (Reversal of quote_header_value()). This does not use the real unquoting but what browsers are actually using for quoting.", "New in version 0.5.", "str"]}, {"name": "uri_to_iri()", "path": "urls/index#werkzeug.urls.uri_to_iri", "type": "werkzeug.urls", "text": ["Convert a URI to an IRI. All valid UTF-8 characters are unquoted, leaving all reserved and invalid characters quoted. If the URL has a domain, it is decoded from Punycode.", "str", "Changed in version 0.15: All reserved and invalid characters remain quoted. Previously, only some reserved characters were preserved, and invalid bytes were replaced instead of left quoted.", "New in version 0.6."]}, {"name": "URL", "path": "urls/index#werkzeug.urls.URL", "type": "werkzeug.urls", "text": ["Represents a parsed URL. This behaves like a regular tuple but also has some extra attributes that give further insight into the URL.", "Create new instance of _URLTuple(scheme, netloc, path, query, fragment)", "Encodes the URL to a tuple made out of bytes. The charset is only being used for the path, query and fragment.", "werkzeug.urls.BytesURL"]}, {"name": "URL Helpers", "path": "urls/index", "type": "Other", "text": ["Functions for working with URLs.", "Contains implementations of functions from urllib.parse that handle bytes and strings.", "Superclass of URL and BytesURL.", "Create new instance of _URLTuple(scheme, netloc, path, query, fragment)", "Works exactly like host but will return a result that is restricted to ASCII. If it finds a netloc that is not ASCII it will attempt to idna decode it. This is useful for socket operations when the URL might include internationalized characters.", "The authentication part in the URL if available, None otherwise.", "Decodes the netloc part into a string.", "str", "Decodes the query part of the URL. Ths is a shortcut for calling url_decode() on the query argument. The arguments and keyword arguments are forwarded to url_decode() unchanged.", "ds.MultiDict[str, str]", "Encodes the netloc part to an ASCII safe URL as bytes.", "str", "Returns a tuple with the location of the file in the form (server, location). If the netloc is empty in the URL or points to localhost, it\u2019s represented as None.", "The pathformat by default is autodetection but needs to be set when working with URLs of a specific system. The supported values are 'windows' when working with Windows or DOS paths and 'posix' when working with posix paths.", "If the URL does not point to a local file, the server and location are both represented as None.", "pathformat (Optional[str]) \u2013 The expected format of the path component. Currently 'windows' and 'posix' are supported. Defaults to None which is autodetect.", "Tuple[Optional[str], Optional[str]]", "The host part of the URL if available, otherwise None. The host is either the hostname or the IP address mentioned in the URL. It will not contain the port.", "Joins this URL with another one. This is just a convenience function for calling into url_join() and then parsing the return value again.", "werkzeug.urls.BaseURL", "The password if it was part of the URL, None otherwise. This undergoes URL decoding and will always be a string.", "The port in the URL as an integer if it was present, None otherwise. This does not fill in default ports.", "The password if it was part of the URL, None otherwise. Unlike password this one is not being decoded.", "The username if it was part of the URL, None otherwise. Unlike username this one is not being decoded.", "Return an URL with the same values, except for those parameters given new values by whichever keyword arguments are specified.", "kwargs (Any) \u2013 ", "werkzeug.urls.BaseURL", "Returns a URL tuple that holds a IRI. This will try to decode as much information as possible in the URL without losing information similar to how a web browser does it for the URL bar.", "It\u2019s usually more interesting to directly call uri_to_iri() which will return a string.", "werkzeug.urls.BaseURL", "Returns a BytesURL tuple that holds a URI. This will encode all the information in the URL properly to ASCII using the rules a web browser would follow.", "It\u2019s usually more interesting to directly call iri_to_uri() which will return a string.", "werkzeug.urls.BaseURL", "Returns a URL string or bytes depending on the type of the information stored. This is just a convenience function for calling url_unparse() for this URL.", "str", "The username if it was part of the URL, None otherwise. This undergoes URL decoding and will always be a string.", "Represents a parsed URL in bytes.", "Create new instance of _URLTuple(scheme, netloc, path, query, fragment)", "Decodes the URL to a tuple made out of strings. The charset is only being used for the path, query and fragment.", "werkzeug.urls.URL", "Returns the netloc unchanged as bytes.", "bytes", "Implements a callable that constructs URLs with the given base. The function can be called with any number of positional and keyword arguments which than are used to assemble the URL. Works with URLs and posix paths.", "Positional arguments are appended as individual segments to the path of the URL:", "If any of the arguments (positional or keyword) evaluates to None it will be skipped. If no keyword arguments are given the last argument can be a dict or MultiDict (or any other dict subclass), otherwise the keyword arguments are used for the query parameters, cutting off the first trailing underscore of the parameter name:", "Combining of both methods is not allowed:", "Accessing attributes on the href object creates a new href object with the attribute name as prefix:", "If sort is set to True the items are sorted by key or the default sorting algorithm:", "Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use werkzeug.routing instead.", "New in version 0.5: sort and key were added.", "Represents a parsed URL. This behaves like a regular tuple but also has some extra attributes that give further insight into the URL.", "Create new instance of _URLTuple(scheme, netloc, path, query, fragment)", "Encodes the URL to a tuple made out of bytes. The charset is only being used for the path, query and fragment.", "werkzeug.urls.BytesURL", "Convert an IRI to a URI. All non-ASCII and unsafe characters are quoted. If the URL has a domain, it is encoded to Punycode.", "str", "There is a general problem with IRI conversion with some protocols that are in violation of the URI specification. Consider the following two IRIs:", "After parsing, we don\u2019t know if the scheme requires the //, which is dropped if empty, but conveys different meanings in the final URL if it\u2019s present or not. In this case, you can use safe_conversion, which will return the URL unchanged if it only contains ASCII characters and no whitespace. This can result in a URI with unquoted characters if it was not already quoted correctly, but preserves the URL\u2019s semantics. Werkzeug uses this for the Location header for redirects.", "Changed in version 0.15: All reserved characters remain unquoted. Previously, only some reserved characters were left unquoted.", "Changed in version 0.9.6: The safe_conversion parameter was added.", "New in version 0.6.", "Convert a URI to an IRI. All valid UTF-8 characters are unquoted, leaving all reserved and invalid characters quoted. If the URL has a domain, it is decoded from Punycode.", "str", "Changed in version 0.15: All reserved and invalid characters remain quoted. Previously, only some reserved characters were preserved, and invalid bytes were replaced instead of left quoted.", "New in version 0.6.", "Parse a query string and return it as a MultiDict.", "ds.MultiDict[str, str]", "Changed in version 2.0: The decode_keys parameter is deprecated and will be removed in Werkzeug 2.1.", "Changed in version 0.5: In previous versions \u201c;\u201d and \u201c&\u201d could be used for url decoding. Now only \u201c&\u201d is supported. If you want to use \u201c;\u201d, a different separator can be provided.", "Changed in version 0.5: The cls parameter was added.", "Works like url_decode() but decodes a stream. The behavior of stream and limit follows functions like make_line_iter(). The generator of pairs is directly fed to the cls so you can consume the data while it\u2019s parsed.", "ds.MultiDict[str, str]", "Changed in version 2.0: The decode_keys and return_iterator parameters are deprecated and will be removed in Werkzeug 2.1.", "New in version 0.8.", "URL encode a dict/MultiDict. If a value is None it will not appear in the result string. Per default only values are encoded into the target charset strings.", "str", "Changed in version 2.0: The encode_keys parameter is deprecated and will be removed in Werkzeug 2.1.", "Changed in version 0.5: Added the sort, key, and separator parameters.", "Like url_encode() but writes the results to a stream object. If the stream is None a generator over all encoded pairs is returned.", "None", "Changed in version 2.0: The encode_keys parameter is deprecated and will be removed in Werkzeug 2.1.", "New in version 0.8.", "Sometimes you get an URL by a user that just isn\u2019t a real URL because it contains unsafe characters like \u2018 \u2018 and so on. This function can fix some of the problems in a similar way browsers handle data entered by the user:", "str", "Join a base URL and a possibly relative URL to form an absolute interpretation of the latter.", "str", "Parses a URL from a string into a URL tuple. If the URL is lacking a scheme it can be provided as second argument. Otherwise, it is ignored. Optionally fragments can be stripped from the URL by setting allow_fragments to False.", "The inverse of this function is url_unparse().", "werkzeug.urls.BaseURL", "URL encode a single string with a given encoding.", "str", "New in version 0.9.2: The unsafe parameter was added.", "URL encode a single string with the given encoding and convert whitespace to \u201c+\u201d.", "str", "The reverse operation to url_parse(). This accepts arbitrary as well as URL tuples and returns a URL as a string.", "components (Tuple[str, str, str, str, str]) \u2013 the parsed URL as tuple which should be converted into a URL string.", "str", "URL decode a single string with a given encoding. If the charset is set to None no decoding is performed and raw bytes are returned.", "str", "URL decode a single string with the given charset and decode \u201c+\u201d to whitespace.", "Per default encoding errors are ignored. If you want a different behavior you can set errors to 'replace' or 'strict'.", "str"]}, {"name": "URL Routing", "path": "routing/index", "type": "Other", "text": ["When it comes to combining multiple controller or view functions (however you want to call them), you need a dispatcher. A simple way would be applying regular expression tests on PATH_INFO and call registered callback functions that return the value.", "Werkzeug provides a much more powerful system, similar to Routes. All the objects mentioned on this page must be imported from werkzeug.routing, not from werkzeug!", "Here is a simple example which could be the URL definition for a blog:", "So what does that do? First of all we create a new Map which stores a bunch of URL rules. Then we pass it a list of Rule objects.", "Each Rule object is instantiated with a string that represents a rule and an endpoint which will be the alias for what view the rule represents. Multiple rules can have the same endpoint, but should have different arguments to allow URL construction.", "The format for the URL rules is straightforward, but explained in detail below.", "Inside the WSGI application we bind the url_map to the current request which will return a new MapAdapter. This url_map adapter can then be used to match or build domains for the current request.", "The MapAdapter.match() method can then either return a tuple in the form (endpoint, args) or raise one of the three exceptions NotFound, MethodNotAllowed, or RequestRedirect. For more details about those exceptions have a look at the documentation of the MapAdapter.match() method.", "Rule strings are URL paths with placeholders for variable parts in the format <converter(arguments):name>. converter and arguments (with parentheses) are optional. If no converter is given, the default converter is used (string by default). The available converters are discussed below.", "Rules that end with a slash are \u201cbranches\u201d, others are \u201cleaves\u201d. If strict_slashes is enabled (the default), visiting a branch URL without a trailing slash will redirect to the URL with a slash appended.", "Many HTTP servers merge consecutive slashes into one when receiving requests. If merge_slashes is enabled (the default), rules will merge slashes in non-variable parts when matching and building. Visiting a URL with consecutive slashes will redirect to the URL with slashes merged. If you want to disable merge_slashes for a Rule or Map, you\u2019ll also need to configure your web server appropriately.", "Converters for common types of URL variables are built-in. The available converters can be overridden or extended through Map.converters.", "This converter is the default converter and accepts any string but only one path segment. Thus the string can not include a slash.", "This is the default validator.", "Example:", "None", "Like the default UnicodeConverter, but it also matches slashes. This is useful for wikis and similar applications:", "None", "Matches one of the items provided. Items can either be Python identifiers or strings:", "None", "This converter only accepts integer values:", "By default it only accepts unsigned, positive values. The signed parameter will enable signed, negative values.", "None", "New in version 0.15: The signed parameter.", "This converter only accepts floating point values:", "By default it only accepts unsigned, positive values. The signed parameter will enable signed, negative values.", "None", "New in version 0.15: The signed parameter.", "This converter only accepts UUID strings:", "New in version 0.10.", "None", "The map class stores all the URL rules and some configuration parameters. Some of the configuration values are only stored on the Map instance since those affect all rules, others are just defaults and can be overridden for each rule. Note that you have to specify all arguments besides the rules as keyword arguments!", "None", "Changed in version 1.0: If url_scheme is ws or wss, only WebSocket rules will match.", "Changed in version 1.0: Added merge_slashes.", "Changed in version 0.7: Added encoding_errors and host_matching.", "Changed in version 0.5: Added sort_parameters and sort_key.", "The dictionary of converters. This can be modified after the class was created, but will only affect rules added after the modification. If the rules are defined with the list passed to the class, the converters parameter to the constructor has to be used instead.", "Add a new rule or factory to the map and bind it. Requires that the rule is not bound to another map.", "rulefactory (werkzeug.routing.RuleFactory) \u2013 a Rule or RuleFactory", "None", "Return a new MapAdapter with the details specified to the call. Note that script_name will default to '/' if not further specified or None. The server_name at least is a requirement because the HTTP RFC requires absolute URLs for redirects and so all redirect exceptions raised by Werkzeug will contain the full canonical URL.", "If no path_info is passed to match() it will use the default path info passed to bind. While this doesn\u2019t really make sense for manual bind calls, it\u2019s useful if you bind a map to a WSGI environment which already contains the path info.", "subdomain will default to the default_subdomain for this map if no defined. If there is no default_subdomain you cannot use the subdomain feature.", "Changed in version 1.0: If url_scheme is ws or wss, only WebSocket rules will match.", "Changed in version 0.15: path_info defaults to '/' if None.", "Changed in version 0.8: query_args can be a string.", "Changed in version 0.7: Added query_args.", "werkzeug.routing.MapAdapter", "Like bind() but you can pass it an WSGI environment and it will fetch the information from that dictionary. Note that because of limitations in the protocol there is no way to get the current subdomain and real server_name from the environment. If you don\u2019t provide it, Werkzeug will use SERVER_NAME and SERVER_PORT (or HTTP_HOST if provided) as used server_name with disabled subdomain feature.", "If subdomain is None but an environment and a server name is provided it will calculate the current subdomain automatically. Example: server_name is 'example.com' and the SERVER_NAME in the wsgi environ is 'staging.dev.example.com' the calculated subdomain will be 'staging.dev'.", "If the object passed as environ has an environ attribute, the value of this attribute is used instead. This allows you to pass request objects. Additionally PATH_INFO added as a default of the MapAdapter so that you don\u2019t have to pass the path info to the match method.", "Changed in version 1.0.0: If the passed server name specifies port 443, it will match if the incoming scheme is https without a port.", "Changed in version 1.0.0: A warning is shown when the passed server name does not match the incoming WSGI server name.", "Changed in version 0.8: This will no longer raise a ValueError when an unexpected server name was passed.", "Changed in version 0.5: previously this method accepted a bogus calculate_subdomain parameter that did not have any effect. It was removed because of that.", "MapAdapter", "A dict of default converters to be used.", "Iterate over all rules and check if the endpoint expects the arguments provided. This is for example useful if you have some URLs that expect a language code and others that do not and you want to wrap the builder a bit so that the current language code is automatically added if not provided but endpoints expect it.", "bool", "Iterate over all rules or the rules of an endpoint.", "endpoint (Optional[str]) \u2013 if provided only the rules for that endpoint are returned.", "an iterator", "Iterator[werkzeug.routing.Rule]", "The type of lock to use when updating.", "New in version 1.0.", "Called before matching and building to keep the compiled rules in the correct order after things changed.", "None", "Returned by Map.bind() or Map.bind_to_environ() and does the URL matching and building based on runtime information.", "Returns the valid methods that match for a given path.", "New in version 0.7.", "path_info (Optional[str]) \u2013 ", "Iterable[str]", "Building URLs works pretty much the other way round. Instead of match you call build and pass it the endpoint and a dict of arguments for the placeholders.", "The build function also accepts an argument called force_external which, if you set it to True will force external URLs. Per default external URLs (include the server name) will only be used if the target URL is on a different subdomain.", "Because URLs cannot contain non ASCII data you will always get bytes back. Non ASCII characters are urlencoded with the charset defined on the map instance.", "Additional values are converted to strings and appended to the URL as URL querystring parameters:", "When processing those additional values, lists are furthermore interpreted as multiple values (as per werkzeug.datastructures.MultiDict):", "Passing a MultiDict will also add multiple values:", "If a rule does not exist when building a BuildError exception is raised.", "The build method accepts an argument called method which allows you to specify the method you want to have an URL built for if you have different methods for the same endpoint specified.", "str", "Changed in version 2.0: Added the url_scheme parameter.", "New in version 0.6: Added the append_unknown parameter.", "Does the complete dispatching process. view_func is called with the endpoint and a dict with the values for the view. It should look up the view function, call it, and return a response object or WSGI application. http exceptions are not caught by default so that applications can display nicer error messages by just catching them by hand. If you want to stick with the default error messages you can pass it catch_http_exceptions=True and it will catch the http exceptions.", "Here a small example for the dispatch usage:", "Keep in mind that this method might return exception objects, too, so use Response.force_type to get a response object.", "WSGIApplication", "Figures out the full host name for the given domain part. The domain part is a subdomain in case host matching is disabled or a full host name.", "domain_part (Optional[str]) \u2013 ", "str", "Internally called to make an alias redirect URL.", "str", "The usage is simple: you just pass the match method the current path info as well as the method (which defaults to GET). The following things can then happen:", "If the path info is not passed to the match method the default path info of the map is used (defaults to the root URL if not defined explicitly).", "All of the exceptions raised are subclasses of HTTPException so they can be used as WSGI responses. They will all render generic error or redirect pages.", "Here is a small example for matching:", "And here is what happens on redirect and missing URLs:", "Tuple[Union[str, werkzeug.routing.Rule], Mapping[str, Any]]", "New in version 1.0: Added websocket.", "Changed in version 0.8: query_args can be a string.", "New in version 0.7: Added query_args.", "New in version 0.6: Added return_rule.", "Test if a rule would match. Works like match but returns True if the URL matches, or False if it does not exist.", "bool", "A Rule represents one URL pattern. There are some options for Rule that change the way it behaves and are passed to the Rule constructor. Note that besides the rule-string all arguments must be keyword arguments in order to not break the application on Werkzeug upgrades.", "Rule strings basically are just normal URL paths with placeholders in the format <converter(arguments):name> where the converter and the arguments are optional. If no converter is defined the default converter is used which means string in the normal configuration.", "URL rules that end with a slash are branch URLs, others are leaves. If you have strict_slashes enabled (which is the default), all branch URLs that are matched without a trailing slash will trigger a redirect to the same URL with the missing slash appended.", "The converters are defined on the Map.", "The endpoint for this rule. This can be anything. A reference to a function, a string, a number etc. The preferred way is using a string because the endpoint is used for URL generation.", "An optional dict with defaults for other rules with the same endpoint. This is a bit tricky but useful if you want to have unique URLs:", "If a user now visits http://example.com/all/page/1 he will be redirected to http://example.com/all/. If redirect_defaults is disabled on the Map instance this will only affect the URL generation.", "The subdomain rule string for this rule. If not specified the rule only matches for the default_subdomain of the map. If the map is not bound to a subdomain this feature is disabled.", "Can be useful if you want to have user profiles on different subdomains and all subdomains are forwarded to your application:", "A sequence of http methods this rule applies to. If not specified, all methods are allowed. For example this can be useful if you want different endpoints for POST and GET. If methods are defined and the path matches but the method matched against is not in this list or in the list of another rule for that path the error raised is of the type MethodNotAllowed rather than NotFound. If GET is present in the list of methods and HEAD is not, HEAD is added automatically.", "Override the Map setting for strict_slashes only for this rule. If not specified the Map setting is used.", "Override Map.merge_slashes for this rule.", "Set this to True and the rule will never match but will create a URL that can be build. This is useful if you have resources on a subdomain or folder that are not handled by the WSGI application (like static data)", "If given this must be either a string or callable. In case of a callable it\u2019s called with the url adapter that triggered the match and the values of the URL as keyword arguments and has to return the target for the redirect, otherwise it has to be a string with placeholders in rule syntax:", "When the rule is matched the routing system will raise a RequestRedirect exception with the target for the redirect.", "Keep in mind that the URL will be joined against the URL root of the script so don\u2019t use a leading slash on the target URL unless you really mean root of that domain.", "If enabled this rule serves as an alias for another rule with the same endpoint and arguments.", "If provided and the URL map has host matching enabled this can be used to provide a match rule for the whole host. This also means that the subdomain feature is disabled.", "If True, this rule is only matches for WebSocket (ws://, wss://) requests. By default, rules will only match for HTTP requests.", "New in version 1.0: Added websocket.", "New in version 1.0: Added merge_slashes.", "New in version 0.7: Added alias and host.", "Changed in version 0.6.1: HEAD is added to methods if GET is present.", "None", "Return an unbound copy of this rule.", "This can be useful if want to reuse an already bound URL for another map. See get_empty_kwargs to override what keyword arguments are provided to the new copy.", "werkzeug.routing.Rule", "As soon as you have more complex URL setups it\u2019s a good idea to use rule factories to avoid repetitive tasks. Some of them are builtin, others can be added by subclassing RuleFactory and overriding get_rules.", "Subclasses of RuleFactory have to override this method and return an iterable of rules.", "map (werkzeug.routing.Map) \u2013 ", "Iterable[werkzeug.routing.Rule]", "All URLs provided by this factory have the subdomain set to a specific domain. For example if you want to use the subdomain for the current language this can be a good setup:", "All the rules except for the '#select_language' endpoint will now listen on a two letter long subdomain that holds the language code for the current request.", "None", "Like Subdomain but prefixes the URL rule with a given string:", "Now the rule 'blog/show' matches /blog/entry/<entry_slug>.", "None", "Prefixes all endpoints (which must be strings for this factory) with another string. This can be useful for sub applications:", "None", "Returns copies of the rules wrapped and expands string templates in the endpoint, rule, defaults or subdomain sections.", "Here a small example for such a rule template:", "When a rule template is called the keyword arguments are used to replace the placeholders in all the string parameters.", "rules (Iterable[Rule]) \u2013 ", "None", "You can add custom converters that add behaviors not provided by the built-in converters. To make a custom converter, subclass BaseConverter then pass the new class to the Map converters parameter, or add it to url_map.converters.", "The converter should have a regex attribute with a regular expression to match with. If the converter can take arguments in a URL rule, it should accept them in its __init__ method.", "It can implement a to_python method to convert the matched string to some other object. This can also do extra validation that wasn\u2019t possible with the regex attribute, and should raise a werkzeug.routing.ValidationError in that case. Raising any other errors will cause a 500 error.", "It can implement a to_url method to convert a Python object to a string when building a URL. Any error raised here will be converted to a werkzeug.routing.BuildError and eventually cause a 500 error.", "This example implements a BooleanConverter that will match the strings \"yes\", \"no\", and \"maybe\", returning a random value for \"maybe\".", "If you want to change the default converter, assign a different converter to the \"default\" key.", "New in version 0.7.", "Starting with Werkzeug 0.7 it\u2019s also possible to do matching on the whole host names instead of just the subdomain. To enable this feature you need to pass host_matching=True to the Map constructor and provide the host argument to all routes:", "Variable parts are of course also possible in the host section:", "New in version 1.0.", "If a Rule is created with websocket=True, it will only match if the Map is bound to a request with a url_scheme of ws or wss.", "Note", "Werkzeug has no further WebSocket support beyond routing. This functionality is mostly of use to ASGI projects.", "If the only match is a WebSocket rule and the bind is HTTP (or the only match is HTTP and the bind is WebSocket) a WebsocketMismatch (derives from BadRequest) exception is raised.", "As WebSocket URLs have a different scheme, rules are always built with a scheme and host, force_external=True is implied."]}, {"name": "URL.encode()", "path": "urls/index#werkzeug.urls.URL.encode", "type": "werkzeug.urls", "text": ["Encodes the URL to a tuple made out of bytes. The charset is only being used for the path, query and fragment.", "werkzeug.urls.BytesURL"]}, {"name": "url_decode()", "path": "urls/index#werkzeug.urls.url_decode", "type": "werkzeug.urls", "text": ["Parse a query string and return it as a MultiDict.", "ds.MultiDict[str, str]", "Changed in version 2.0: The decode_keys parameter is deprecated and will be removed in Werkzeug 2.1.", "Changed in version 0.5: In previous versions \u201c;\u201d and \u201c&\u201d could be used for url decoding. Now only \u201c&\u201d is supported. If you want to use \u201c;\u201d, a different separator can be provided.", "Changed in version 0.5: The cls parameter was added."]}, {"name": "url_decode_stream()", "path": "urls/index#werkzeug.urls.url_decode_stream", "type": "werkzeug.urls", "text": ["Works like url_decode() but decodes a stream. The behavior of stream and limit follows functions like make_line_iter(). The generator of pairs is directly fed to the cls so you can consume the data while it\u2019s parsed.", "ds.MultiDict[str, str]", "Changed in version 2.0: The decode_keys and return_iterator parameters are deprecated and will be removed in Werkzeug 2.1.", "New in version 0.8."]}, {"name": "url_encode()", "path": "urls/index#werkzeug.urls.url_encode", "type": "werkzeug.urls", "text": ["URL encode a dict/MultiDict. If a value is None it will not appear in the result string. Per default only values are encoded into the target charset strings.", "str", "Changed in version 2.0: The encode_keys parameter is deprecated and will be removed in Werkzeug 2.1.", "Changed in version 0.5: Added the sort, key, and separator parameters."]}, {"name": "url_encode_stream()", "path": "urls/index#werkzeug.urls.url_encode_stream", "type": "werkzeug.urls", "text": ["Like url_encode() but writes the results to a stream object. If the stream is None a generator over all encoded pairs is returned.", "None", "Changed in version 2.0: The encode_keys parameter is deprecated and will be removed in Werkzeug 2.1.", "New in version 0.8."]}, {"name": "url_fix()", "path": "urls/index#werkzeug.urls.url_fix", "type": "werkzeug.urls", "text": ["Sometimes you get an URL by a user that just isn\u2019t a real URL because it contains unsafe characters like \u2018 \u2018 and so on. This function can fix some of the problems in a similar way browsers handle data entered by the user:", "str"]}, {"name": "url_join()", "path": "urls/index#werkzeug.urls.url_join", "type": "werkzeug.urls", "text": ["Join a base URL and a possibly relative URL to form an absolute interpretation of the latter.", "str"]}, {"name": "url_parse()", "path": "urls/index#werkzeug.urls.url_parse", "type": "werkzeug.urls", "text": ["Parses a URL from a string into a URL tuple. If the URL is lacking a scheme it can be provided as second argument. Otherwise, it is ignored. Optionally fragments can be stripped from the URL by setting allow_fragments to False.", "The inverse of this function is url_unparse().", "werkzeug.urls.BaseURL"]}, {"name": "url_quote()", "path": "urls/index#werkzeug.urls.url_quote", "type": "werkzeug.urls", "text": ["URL encode a single string with a given encoding.", "str", "New in version 0.9.2: The unsafe parameter was added."]}, {"name": "url_quote_plus()", "path": "urls/index#werkzeug.urls.url_quote_plus", "type": "werkzeug.urls", "text": ["URL encode a single string with the given encoding and convert whitespace to \u201c+\u201d.", "str"]}, {"name": "url_unparse()", "path": "urls/index#werkzeug.urls.url_unparse", "type": "werkzeug.urls", "text": ["The reverse operation to url_parse(). This accepts arbitrary as well as URL tuples and returns a URL as a string.", "components (Tuple[str, str, str, str, str]) \u2013 the parsed URL as tuple which should be converted into a URL string.", "str"]}, {"name": "url_unquote()", "path": "urls/index#werkzeug.urls.url_unquote", "type": "werkzeug.urls", "text": ["URL decode a single string with a given encoding. If the charset is set to None no decoding is performed and raw bytes are returned.", "str"]}, {"name": "url_unquote_plus()", "path": "urls/index#werkzeug.urls.url_unquote_plus", "type": "werkzeug.urls", "text": ["URL decode a single string with the given charset and decode \u201c+\u201d to whitespace.", "Per default encoding errors are ignored. If you want a different behavior you can set errors to 'replace' or 'strict'.", "str"]}, {"name": "UserAgent", "path": "utils/index#werkzeug.user_agent.UserAgent", "type": "werkzeug.user_agent", "text": ["Represents a parsed user agent header value.", "The default implementation does no parsing, only the string attribute is set. A subclass may parse the string to set the common attributes or expose other information. Set werkzeug.wrappers.Request.user_agent_class to use a subclass.", "string (str) \u2013 The header value to parse.", "None", "New in version 2.0: This replaces the previous useragents module, but does not provide a built-in parser.", "The OS name, if it could be parsed from the string.", "The browser name, if it could be parsed from the string.", "The browser version, if it could be parsed from the string.", "The browser language, if it could be parsed from the string.", "The original header value.", "Convert to a header value.", "str"]}, {"name": "UserAgent", "path": "utils/index#werkzeug.useragents.UserAgent", "type": "werkzeug.useragents", "text": ["Represents a parsed user agent header value.", "This uses a basic parser to try to extract some information from the header.", "environ_or_string (t.Union[str, WSGIEnvironment]) \u2013 The header value to parse, or a WSGI environ containing the header.", "None", "Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Subclass werkzeug.user_agent.UserAgent (note the new module name) to use a dedicated parser instead.", "Changed in version 2.0: Passing a WSGI environ is deprecated and will be removed in 2.1.", "Convert to a header value.", "str"]}, {"name": "UserAgent.browser", "path": "utils/index#werkzeug.user_agent.UserAgent.browser", "type": "werkzeug.user_agent", "text": ["The browser name, if it could be parsed from the string."]}, {"name": "UserAgent.language", "path": "utils/index#werkzeug.user_agent.UserAgent.language", "type": "werkzeug.user_agent", "text": ["The browser language, if it could be parsed from the string."]}, {"name": "UserAgent.platform", "path": "utils/index#werkzeug.user_agent.UserAgent.platform", "type": "werkzeug.user_agent", "text": ["The OS name, if it could be parsed from the string."]}, {"name": "UserAgent.string", "path": "utils/index#werkzeug.user_agent.UserAgent.string", "type": "werkzeug.user_agent", "text": ["The original header value."]}, {"name": "UserAgent.to_header()", "path": "utils/index#werkzeug.user_agent.UserAgent.to_header", "type": "werkzeug.user_agent", "text": ["Convert to a header value.", "str"]}, {"name": "UserAgent.to_header()", "path": "utils/index#werkzeug.useragents.UserAgent.to_header", "type": "werkzeug.useragents", "text": ["Convert to a header value.", "str"]}, {"name": "UserAgent.version", "path": "utils/index#werkzeug.user_agent.UserAgent.version", "type": "werkzeug.user_agent", "text": ["The browser version, if it could be parsed from the string."]}, {"name": "Utilities", "path": "utils/index", "type": "Other", "text": ["Various utility functions shipped with Werkzeug.", "Helper object for HTML generation.", "Per default there are two instances of that class. The html one, and the xhtml one for those two dialects. The class uses keyword parameters and positional parameters to generate small snippets of HTML.", "Keyword parameters are converted to XML/SGML attributes, positional arguments are used as children. Because Python accepts positional arguments before keyword arguments it\u2019s a good idea to use a list with the star-syntax for some children:", "This class works around some browser limitations and can not be used for arbitrary SGML/XML generation. For that purpose lxml and similar libraries exist.", "Calling the builder escapes the string passed:", "Deprecated since version 2.0: Will be removed in Werkzeug 2.1.", "Replace &, <, >, \", and ' with HTML-safe sequences.", "None is escaped to an empty string.", "Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use MarkupSafe instead.", "s (Any) \u2013 ", "str", "The reverse of escape(). This unescapes all the HTML entities, not only those inserted by escape.", "Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use MarkupSafe instead.", "s (str) \u2013 ", "str", "A property() that is only evaluated once. Subsequent access returns the cached value. Setting the property sets the cached value. Deleting the property clears the cached value, accessing it again will evaluate it again.", "The class must have a __dict__ for this to work.", "Changed in version 2.0: del obj.name clears the cached value.", "None", "Invalidates the cache for a cached_property:", "You must pass the name of the cached property as the second argument.", "Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use del obj.name instead.", "None", "Maps request attributes to environment variables. This works not only for the Werkzeug request object, but also any other class with an environ attribute:", "If you pass it a second value it\u2019s used as default if the key does not exist, the third one can be a converter that takes a value and converts it. If it raises ValueError or TypeError the default value is used. If no default value is provided None is used.", "Per default the property is read only. You have to explicitly enable it by passing read_only=False to the constructor.", "Like environ_property but for headers.", "Returns a response object (a WSGI application) that, if called, redirects the client to the target location. Supported codes are 301, 302, 303, 305, 307, and 308. 300 is not supported because it\u2019s not a real redirect and 304 because it\u2019s the answer for a request with a request with defined If-Modified-Since headers.", "New in version 0.10: The class used for the Response object can now be passed in.", "New in version 0.6: The location can now be a unicode string that is encoded using the iri_to_uri() function.", "Response", "Redirects to the same URL but with a slash appended. The behavior of this function is undefined if the path ends with a slash already.", "Response", "Send the contents of a file to the client.", "The first argument can be a file path or a file-like object. Paths are preferred in most cases because Werkzeug can manage the file and get extra information from the path. Passing a file-like object requires that the file is opened in binary mode, and is mostly useful when building a file in memory with io.BytesIO.", "Never pass file paths provided by a user. The path is assumed to be trusted, so a user could craft a path to access a file you didn\u2019t intend.", "If the WSGI server sets a file_wrapper in environ, it is used, otherwise Werkzeug\u2019s built-in wrapper is used. Alternatively, if the HTTP server supports X-Sendfile, use_x_sendfile=True will tell the server to send the given path, which is much more efficient than reading it in Python.", "Response", "New in version 2.0: Adapted from Flask\u2019s implementation.", "Changed in version 2.0: download_name replaces Flask\u2019s attachment_filename parameter. If as_attachment=False, it is passed with Content-Disposition: inline instead.", "Changed in version 2.0: max_age replaces Flask\u2019s cache_timeout parameter. conditional is enabled and max_age is not set by default.", "Changed in version 2.0: etag replaces Flask\u2019s add_etags parameter. It can be a string to use instead of generating one.", "Changed in version 2.0: If an encoding is returned when guessing mimetype from download_name, set the Content-Encoding header.", "Imports an object based on a string. This is useful if you want to use import paths as endpoints or something similar. An import path can be specified either in dotted notation (xml.sax.saxutils.escape) or with a colon as object delimiter (xml.sax.saxutils:escape).", "If silent is True the return value will be None if the import fails.", "imported object", "Any", "Finds all the modules below a package. This can be useful to automatically import all views / controllers so that their metaclasses / function decorators have a chance to register themselves on the application.", "Packages are not returned unless include_packages is True. This can also recursively list modules but in that case it will import all the packages to get the correct load path of that module.", "generator", "Iterator[str]", "Checks if the function accepts the arguments and keyword arguments. Returns a new (args, kwargs) tuple that can safely be passed to the function without causing a TypeError because the function signature is incompatible. If drop_extra is set to True (which is the default) any extra positional or keyword arguments are dropped automatically.", "The exception raised provides three attributes:", "A set of argument names that the function expected but where missing.", "A dict of keyword arguments that the function can not handle but where provided.", "A list of values that where given by positional argument but the function cannot accept.", "This can be useful for decorators that forward user submitted data to a view function:", "tuple in the form (args, kwargs).", "Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use inspect.signature() instead.", "Pass it a filename and it will return a secure version of it. This filename can then safely be stored on a regular file system and passed to os.path.join(). The filename returned is an ASCII only string for maximum portability.", "On windows systems the function also makes sure that the file is not named after one of the special device files.", "The function might return an empty filename. It\u2019s your responsibility to ensure that the filename is unique and that you abort or generate a random filename if the function returned an empty one.", "New in version 0.5.", "filename (str) \u2013 the filename to secure", "str", "Bind the arguments provided into a dict. When passed a function, a tuple of arguments and a dict of keyword arguments bind_arguments returns a dict of names as the function would see it. This can be useful to implement a cache decorator that uses the function arguments to build the cache key based on the values of the arguments.", "a dict of bound keyword arguments.", "Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use Signature.bind() instead.", "Please refer to URL Helpers.", "Represents a parsed user agent header value.", "The default implementation does no parsing, only the string attribute is set. A subclass may parse the string to set the common attributes or expose other information. Set werkzeug.wrappers.Request.user_agent_class to use a subclass.", "string (str) \u2013 The header value to parse.", "None", "New in version 2.0: This replaces the previous useragents module, but does not provide a built-in parser.", "The OS name, if it could be parsed from the string.", "The browser name, if it could be parsed from the string.", "The browser version, if it could be parsed from the string.", "The browser language, if it could be parsed from the string.", "The original header value.", "Convert to a header value.", "str", "Deprecated since version 2.0: This module will be removed in Werkzeug 2.1. Subclass werkzeug.user_agent.UserAgent to use a dedicated parser instead.", "Represents a parsed user agent header value.", "This uses a basic parser to try to extract some information from the header.", "environ_or_string (t.Union[str, WSGIEnvironment]) \u2013 The header value to parse, or a WSGI environ containing the header.", "None", "Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Subclass werkzeug.user_agent.UserAgent (note the new module name) to use a dedicated parser instead.", "Changed in version 2.0: Passing a WSGI environ is deprecated and will be removed in 2.1.", "Convert to a header value.", "str", "New in version 0.6.1.", "Hash a password with the given method and salt with a string of the given length. The format of the string returned includes the method that was used so that check_password_hash() can check the hash.", "The format for the hashed string looks like this:", "This method can not generate unsalted passwords but it is possible to set param method=\u2019plain\u2019 in order to enforce plaintext passwords. If a salt is used, hmac is used internally to salt the password.", "If PBKDF2 is wanted it can be enabled by setting the method to pbkdf2:method:iterations where iterations is optional:", "str", "Check a password against a given salted and hashed password value. In order to support unsalted legacy passwords this method supports plain text passwords, md5 and sha1 hashes (both salted and unsalted).", "Returns True if the password matched, False otherwise.", "bool", "This function compares strings in somewhat constant time. This requires that the length of at least one string is known in advance.", "Returns True if the two strings are equal, or False if they are not.", "Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use hmac.compare_digest() instead.", "New in version 0.7.", "bool", "Safely join zero or more untrusted path components to a base directory to avoid escaping the base directory.", "A safe path, otherwise None.", "Optional[str]", "Like pbkdf2_bin(), but returns a hex-encoded string.", "str", "Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use hashlib.pbkdf2_hmac() instead.", "New in version 0.9.", "Returns a binary digest for the PBKDF2 hash algorithm of data with the given salt. It iterates iterations times and produces a key of keylen bytes. By default, SHA-256 is used as hash function; a different hashlib hashfunc can be provided.", "bytes", "Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use hashlib.pbkdf2_hmac() instead.", "New in version 0.9.", "Werkzeug uses standard Python logging. The logger is named \"werkzeug\".", "If the logger level is not set, it will be set to INFO on first use. If there is no handler for that level, a StreamHandler is added."]}, {"name": "UUIDConverter", "path": "routing/index#werkzeug.routing.UUIDConverter", "type": "werkzeug.routing", "text": ["This converter only accepts UUID strings:", "New in version 0.10.", "None"]}, {"name": "validate_arguments()", "path": "utils/index#werkzeug.utils.validate_arguments", "type": "werkzeug.utils", "text": ["Checks if the function accepts the arguments and keyword arguments. Returns a new (args, kwargs) tuple that can safely be passed to the function without causing a TypeError because the function signature is incompatible. If drop_extra is set to True (which is the default) any extra positional or keyword arguments are dropped automatically.", "The exception raised provides three attributes:", "A set of argument names that the function expected but where missing.", "A dict of keyword arguments that the function can not handle but where provided.", "A list of values that where given by positional argument but the function cannot accept.", "This can be useful for decorators that forward user submitted data to a view function:", "tuple in the form (args, kwargs).", "Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use inspect.signature() instead."]}, {"name": "Werkzeug Tutorial", "path": "tutorial/index", "type": "Other", "text": ["Welcome to the Werkzeug tutorial in which we will create a TinyURL clone that stores URLs in a redis instance. The libraries we will use for this applications are Jinja 2 for the templates, redis for the database layer and, of course, Werkzeug for the WSGI layer.", "You can use pip to install the required libraries:", "Also make sure to have a redis server running on your local machine. If you are on OS X, you can use brew to install it:", "If you are on Ubuntu or Debian, you can use apt-get:", "Redis was developed for UNIX systems and was never really designed to work on Windows. For development purposes, the unofficial ports however work well enough. You can get them from github.", "In this tutorial, we will together create a simple URL shortener service with Werkzeug. Please keep in mind that Werkzeug is not a framework, it\u2019s a library with utilities to create your own framework or application and as such is very flexible. The approach we use here is just one of many you can use.", "As data store, we will use redis here instead of a relational database to keep this simple and because that\u2019s the kind of job that redis excels at.", "The final result will look something like this:", "Werkzeug is a utility library for WSGI. WSGI itself is a protocol or convention that ensures that your web application can speak with the webserver and more importantly that web applications work nicely together.", "A basic \u201cHello World\u201d application in WSGI without the help of Werkzeug looks like this:", "A WSGI application is something you can call and pass an environ dict and a start_response callable. The environ contains all incoming information, the start_response function can be used to indicate the start of the response. With Werkzeug you don\u2019t have to deal directly with either as request and response objects are provided to work with them.", "The request data takes the environ object and allows you to access the data from that environ in a nice manner. The response object is a WSGI application in itself and provides a much nicer way to create responses.", "Here is how you would write that application with response objects:", "And here an expanded version that looks at the query string in the URL (more importantly at the name parameter in the URL to substitute \u201cWorld\u201d against another word):", "And that\u2019s all you need to know about WSGI.", "Before we get started, let\u2019s create the folders needed for this application:", "The shortly folder is not a python package, but just something where we drop our files. Directly into this folder we will then put our main module in the following steps. The files inside the static folder are available to users of the application via HTTP. This is the place where CSS and JavaScript files go. Inside the templates folder we will make Jinja2 look for templates. The templates you create later in the tutorial will go in this directory.", "Now let\u2019s get right into it and create a module for our application. Let\u2019s create a file called shortly.py in the shortly folder. At first we will need a bunch of imports. I will pull in all the imports here, even if they are not used right away, to keep it from being confusing:", "Then we can create the basic structure for our application and a function to create a new instance of it, optionally with a piece of WSGI middleware that exports all the files on the static folder on the web:", "Lastly we can add a piece of code that will start a local development server with automatic code reloading and a debugger:", "The basic idea here is that our Shortly class is an actual WSGI application. The __call__ method directly dispatches to wsgi_app. This is done so that we can wrap wsgi_app to apply middlewares like we do in the create_app function. The actual wsgi_app method then creates a Request object and calls the dispatch_request method which then has to return a Response object which is then evaluated as WSGI application again. As you can see: turtles all the way down. Both the Shortly class we create, as well as any request object in Werkzeug implements the WSGI interface. As a result of that you could even return another WSGI application from the dispatch_request method.", "The create_app factory function can be used to create a new instance of our application. Not only will it pass some parameters as configuration to the application but also optionally add a WSGI middleware that exports static files. This way we have access to the files from the static folder even when we are not configuring our server to provide them which is very helpful for development.", "Now you should be able to execute the file with python and see a server on your local machine:", "It also tells you that the reloader is active. It will use various techniques to figure out if any file changed on the disk and then automatically restart.", "Just go to the URL and you should see \u201cHello World!\u201d.", "Now that we have the basic application class, we can make the constructor do something useful and provide a few helpers on there that can come in handy. We will need to be able to render templates and connect to redis, so let\u2019s extend the class a bit:", "Next up is routing. Routing is the process of matching and parsing the URL to something we can use. Werkzeug provides a flexible integrated routing system which we can use for that. The way it works is that you create a Map instance and add a bunch of Rule objects. Each rule has a pattern it will try to match the URL against and an \u201cendpoint\u201d. The endpoint is typically a string and can be used to uniquely identify the URL. We could also use this to automatically reverse the URL, but that\u2019s not what we will do in this tutorial.", "Just put this into the constructor:", "Here we create a URL map with three rules. / for the root of the URL space where we will just dispatch to a function that implements the logic to create a new URL. And then one that follows the short link to the target URL and another one with the same rule but a plus (+) at the end to show the link details.", "So how do we find our way from the endpoint to a function? That\u2019s up to you. The way we will do it in this tutorial is by calling the method on_ + endpoint on the class itself. Here is how this works:", "We bind the URL map to the current environment and get back a URLAdapter. The adapter can be used to match the request but also to reverse URLs. The match method will return the endpoint and a dictionary of values in the URL. For instance the rule for follow_short_link has a variable part called short_id. When we go to http://localhost:5000/foo we will get the following values back:", "If it does not match anything, it will raise a NotFound exception, which is an HTTPException. All HTTP exceptions are also WSGI applications by themselves which render a default error page. So we just catch all of them down and return the error itself.", "If all works well, we call the function on_ + endpoint and pass it the request as argument as well as all the URL arguments as keyword arguments and return the response object that method returns.", "Let\u2019s start with the first view: the one for new URLs:", "This logic should be easy to understand. Basically we are checking that the request method is POST, in which case we validate the URL and add a new entry to the database, then redirect to the detail page. This means we need to write a function and a helper method. For URL validation this is good enough:", "For inserting the URL, all we need is this little method on our class:", "reverse-url: + the URL will store the short id. If the URL was already submitted this won\u2019t be None and we can just return that value which will be the short ID. Otherwise we increment the last-url-id key and convert it to base36. Then we store the link and the reverse entry in redis. And here the function to convert to base 36:", "So what is missing for this view to work is the template. We will create this later, let\u2019s first also write the other views and then do the templates in one go.", "The redirect view is easy. All it has to do is to look for the link in redis and redirect to it. Additionally we will also increment a counter so that we know how often a link was clicked:", "In this case we will raise a NotFound exception by hand if the URL does not exist, which will bubble up to the dispatch_request function and be converted into a default 404 response.", "The link detail view is very similar, we just render a template again. In addition to looking up the target, we also ask redis for the number of times the link was clicked and let it default to zero if such a key does not yet exist:", "Please be aware that redis always works with strings, so you have to convert the click count to int by hand.", "And here are all the templates. Just drop them into the templates folder. Jinja2 supports template inheritance, so the first thing we will do is create a layout template with blocks that act as placeholders. We also set up Jinja2 so that it automatically escapes strings with HTML rules, so we don\u2019t have to spend time on that ourselves. This prevents XSS attacks and rendering errors.", "layout.html:", "new_url.html:", "short_link_details.html:", "For this to look better than ugly black and white, here a simple stylesheet that goes along:", "static/style.css:", "Look at the implementation in the example dictionary in the Werkzeug repository to see a version of this tutorial with some small refinements such as a custom 404 page."]}, {"name": "wrap_file()", "path": "wsgi/index#werkzeug.wsgi.wrap_file", "type": "werkzeug.wsgi", "text": ["Wraps a file. This uses the WSGI server\u2019s file wrapper if available or otherwise the generic FileWrapper.", "New in version 0.5.", "If the file wrapper from the WSGI server is used it\u2019s important to not iterate over it from inside the application but to pass it through unchanged. If you want to pass out a file wrapper inside a response object you have to set Response.direct_passthrough to True.", "More information about file wrappers are available in PEP 333.", "Iterable[bytes]"]}, {"name": "WSGI Helpers", "path": "wsgi/index", "type": "Other", "text": ["The following classes and functions are designed to make working with the WSGI specification easier or operate on the WSGI layer. All the functionality from this module is available on the high-level Request / Response Objects.", "These classes and functions simplify working with the WSGI application iterator and the input stream.", "The WSGI specification requires that all middlewares and gateways respect the close callback of the iterable returned by the application. Because it is useful to add another close action to a returned iterable and adding a custom iterable is a boring task this class can be used for that:", "If there is just one close function it can be passed instead of the list.", "A closing iterator is not needed if the application uses response objects and finishes the processing if the response is started:", "None", "This class can be used to convert a file-like object into an iterable. It yields buffer_size blocks until the file is fully read.", "You should not use this class directly but rather use the wrap_file() function that uses the WSGI server\u2019s file wrapper support if it\u2019s available.", "New in version 0.5.", "If you\u2019re using this object together with a Response you have to use the direct_passthrough mode.", "None", "Wraps a stream so that it doesn\u2019t read more than n bytes. If the stream is exhausted and the caller tries to get more bytes from it on_exhausted() is called which by default returns an empty string. The return value of that function is forwarded to the reader function. So if it returns an empty string read() will return an empty string as well.", "The limit however must never be higher than what the stream can output. Otherwise readlines() will try to read past the limit.", "Note on WSGI compliance", "calls to readline() and readlines() are not WSGI compliant because it passes a size argument to the readline methods. Unfortunately the WSGI PEP is not safely implementable without a size argument to readline() because there is no EOF marker in the stream. As a result of that the use of readline() is discouraged.", "For the same reason iterating over the LimitedStream is not portable. It internally calls readline().", "We strongly suggest using read() only or using the make_line_iter() which safely iterates line-based over a WSGI input stream.", "None", "Exhaust the stream. This consumes all the data left until the limit is reached.", "chunk_size (int) \u2013 the size for a chunk. It will read the chunk until the stream is exhausted and throw away the results.", "None", "If the stream is exhausted this attribute is True.", "What should happen if a disconnect is detected? The return value of this function is returned from read functions in case the client went away. By default a ClientDisconnected exception is raised.", "bytes", "This is called when the stream tries to read past the limit. The return value of this function is returned from the reading function.", "bytes", "Read size bytes or if size is not provided everything is read.", "size (Optional[int]) \u2013 the number of bytes read.", "bytes", "Return whether object was opened for reading.", "If False, read() will raise OSError.", "bool", "Reads one line from the stream.", "size (Optional[int]) \u2013 ", "bytes", "Reads a file into a list of strings. It calls readline() until the file is read to the end. It does support the optional size argument if the underlying stream supports it for readline.", "size (Optional[int]) \u2013 ", "List[bytes]", "Returns the position of the stream.", "New in version 0.9.", "int", "Safely iterates line-based over an input stream. If the input stream is not a LimitedStream the limit parameter is mandatory.", "This uses the stream\u2019s read() method internally as opposite to the readline() method that is unsafe and can only be used in violation of the WSGI specification. The same problem applies to the __iter__ function of the input stream which calls readline() without arguments.", "If you need line-by-line processing it\u2019s strongly recommended to iterate over the input stream using this helper function.", "New in version 0.11.10: added support for the cap_at_buffer parameter.", "New in version 0.9: added support for iterators as input stream.", "Changed in version 0.8: This function now ensures that the limit was reached.", "Iterator[bytes]", "Works like make_line_iter() but accepts a separator which divides chunks. If you want newline based processing you should use make_line_iter() instead as it supports arbitrary newline markers.", "New in version 0.11.10: added support for the cap_at_buffer parameter.", "New in version 0.9: added support for iterators as input stream.", "New in version 0.8.", "Iterator[bytes]", "Wraps a file. This uses the WSGI server\u2019s file wrapper if available or otherwise the generic FileWrapper.", "New in version 0.5.", "If the file wrapper from the WSGI server is used it\u2019s important to not iterate over it from inside the application but to pass it through unchanged. If you want to pass out a file wrapper inside a response object you have to set Response.direct_passthrough to True.", "More information about file wrappers are available in PEP 333.", "Iterable[bytes]", "These functions operate on the WSGI environment. They extract useful information or perform common manipulations:", "Return the host for the given WSGI environment.", "The Host header is preferred, then SERVER_NAME if it\u2019s not set. The returned host will only contain the port if it is different than the standard port for the protocol.", "Optionally, verify that the host is trusted using host_is_trusted() and raise a SecurityError if it is not.", "Host, with port if necessary.", "SecurityError \u2013 If the host is not trusted.", "str", "Returns the content length from the WSGI environment as integer. If it\u2019s not available or chunked transfer encoding is used, None is returned.", "New in version 0.9.", "environ (WSGIEnvironment) \u2013 the WSGI environ to fetch the content length from.", "Optional[int]", "Returns the input stream from the WSGI environment and wraps it in the most sensible way possible. The stream returned is not the raw WSGI stream in most cases but one that is safe to read from without taking into account the content length.", "If content length is not set, the stream will be empty for safety reasons. If the WSGI server supports chunked or infinite streams, it should set the wsgi.input_terminated value in the WSGI environ to indicate that.", "New in version 0.9.", "BinaryIO", "Recreate the URL for a request from the parts in a WSGI environment.", "The URL is an IRI, not a URI, so it may contain Unicode characters. Use iri_to_uri() to convert it to ASCII.", "str", "Returns the QUERY_STRING from the WSGI environment. This also takes care of the WSGI decoding dance. The string returned will be restricted to ASCII characters.", "environ (WSGIEnvironment) \u2013 WSGI environment to get the query string from.", "str", "New in version 0.9.", "Return the SCRIPT_NAME from the WSGI environment and decode it unless charset is set to None.", "str", "New in version 0.9.", "Return the PATH_INFO from the WSGI environment and decode it unless charset is None.", "str", "New in version 0.9.", "Removes and returns the next segment of PATH_INFO, pushing it onto SCRIPT_NAME. Returns None if there is nothing left on PATH_INFO.", "If the charset is set to None bytes are returned.", "If there are empty segments ('/foo//bar) these are ignored but properly pushed to the SCRIPT_NAME:", "Changed in version 0.9: The path is now decoded and a charset and encoding parameter can be provided.", "New in version 0.5.", "Optional[str]", "Returns the next segment on the PATH_INFO or None if there is none. Works like pop_path_info() without modifying the environment:", "If the charset is set to None bytes are returned.", "Changed in version 0.9: The path is now decoded and a charset and encoding parameter can be provided.", "New in version 0.5.", "Optional[str]", "Extracts the path info from the given URL (or WSGI environment) and path. The path info returned is a string. The URLs might also be IRIs.", "If the path info could not be determined, None is returned.", "Some examples:", "Instead of providing a base URL you can also pass a WSGI environment.", "Optional[str]", "Changed in version 0.15: The errors parameter defaults to leaving invalid bytes quoted instead of replacing them.", "New in version 0.6.", "Check if a host matches a list of trusted names.", "bool", "New in version 0.9.", "Marks a function as responder. Decorate a function with it and it will automatically call the return value as WSGI application.", "Example:", "f (Callable[[...], WSGIApplication]) \u2013 ", "WSGIApplication", "Simple test application that dumps the environment. You can use it to check if Werkzeug is working properly:", "The application displays important information from the WSGI environment, the Python interpreter and the installed libraries.", "Iterable[bytes]", "The values in HTTP requests come in as bytes representing (or encoded to) ASCII. The WSGI specification (PEP 3333) decided to always use the str type to represent values. To accomplish this, the raw bytes are decoded using the ISO-8859-1 charset to produce a string.", "Strings in the WSGI environment are restricted to ISO-8859-1 code points. If a string read from the environment might contain characters outside that charset, it must first be decoded to bytes as ISO-8859-1, then encoded to a string using the proper charset (typically UTF-8). The reverse is done when writing to the environ. This is known as the \u201cWSGI encoding dance\u201d.", "Werkzeug provides functions to deal with this automatically so that you don\u2019t need to be aware of the inner workings. Use the functions on this page as well as EnvironHeaders() to read data out of the WSGI environment.", "Applications should avoid manually creating or modifying a WSGI environment unless they take care of the proper encoding or decoding step. All high level interfaces in Werkzeug will apply the encoding and decoding as necessary.", "The PATH_INFO in the environ is the path value after percent-decoding. For example, the raw path /hello%2fworld would show up from the WSGI server to Werkzeug as /hello/world. This loses the information that the slash was a raw character as opposed to a path separator.", "The WSGI specification (PEP 3333) does not provide a way to get the original value, so it is impossible to route some types of data in the path. The most compatible way to work around this is to send problematic data in the query string instead of the path.", "However, many WSGI servers add a non-standard environ key with the raw path. To match this behavior, Werkzeug\u2019s test client and development server will add the raw value to both the REQUEST_URI and RAW_URI keys. If you want to route based on this value, you can use middleware to replace PATH_INFO in the environ before it reaches the application. However, keep in mind that these keys are non-standard and not guaranteed to be present."]}, {"name": "WSGI Protocol Linter", "path": "middleware/lint/index", "type": "Other", "text": ["This module provides a middleware that performs sanity checks on the behavior of the WSGI server and application. It checks that the PEP 3333 WSGI spec is properly implemented. It also warns on some common HTTP errors such as non-empty responses for 304 status codes.", "Warns about common errors in the WSGI and HTTP behavior of the server and wrapped application. Some of the issues it checks are:", "Error information is emitted using the warnings module.", "app (WSGIApplication) \u2013 The WSGI application to wrap.", "None"]}, {"name": "WWWAuthenticate", "path": "datastructures/index#werkzeug.datastructures.WWWAuthenticate", "type": "werkzeug.datastructures", "text": ["Provides simple access to WWW-Authenticate headers.", "A string indicating a pair of algorithms used to produce the digest and a checksum. If this is not present it is assumed to be \u201cMD5\u201d. If the algorithm is not understood, the challenge should be ignored (and a different one used, if there is more than one).", "A static helper function for Authentication subclasses to add extra authentication system properties onto a class:", "For more information have a look at the sourcecode to see how the regular properties (realm etc.) are implemented.", "A list of URIs that define the protection space. If a URI is an absolute path, it is relative to the canonical root URL of the server being accessed.", "A server-specified data string which should be uniquely generated each time a 401 response is made. It is recommended that this string be base64 or hexadecimal data.", "A string of data, specified by the server, which should be returned by the client unchanged in the Authorization header of subsequent requests with URIs in the same protection space. It is recommended that this string be base64 or hexadecimal data.", "A set of quality-of-privacy directives such as auth and auth-int.", "A string to be displayed to users so they know which username and password to use. This string should contain at least the name of the host performing the authentication and might additionally indicate the collection of users who might have access.", "Clear the auth info and enable basic auth.", "Clear the auth info and enable digest auth.", "A flag, indicating that the previous request from the client was rejected because the nonce value was stale.", "Convert the stored values into a WWW-Authenticate header.", "The type of the auth mechanism. HTTP currently specifies Basic and Digest."]}, {"name": "WWWAuthenticate.auth_property()", "path": "datastructures/index#werkzeug.datastructures.WWWAuthenticate.auth_property", "type": "werkzeug.datastructures", "text": ["A static helper function for Authentication subclasses to add extra authentication system properties onto a class:", "For more information have a look at the sourcecode to see how the regular properties (realm etc.) are implemented."]}, {"name": "WWWAuthenticate.set_basic()", "path": "datastructures/index#werkzeug.datastructures.WWWAuthenticate.set_basic", "type": "werkzeug.datastructures", "text": ["Clear the auth info and enable basic auth."]}, {"name": "WWWAuthenticate.set_digest()", "path": "datastructures/index#werkzeug.datastructures.WWWAuthenticate.set_digest", "type": "werkzeug.datastructures", "text": ["Clear the auth info and enable digest auth."]}, {"name": "WWWAuthenticate.to_header()", "path": "datastructures/index#werkzeug.datastructures.WWWAuthenticate.to_header", "type": "werkzeug.datastructures", "text": ["Convert the stored values into a WWW-Authenticate header."]}, {"name": "X-Forwarded-For Proxy Fix", "path": "middleware/proxy_fix/index", "type": "Other", "text": ["This module provides a middleware that adjusts the WSGI environ based on X-Forwarded- headers that proxies in front of an application may set.", "When an application is running behind a proxy server, WSGI may see the request as coming from that server rather than the real client. Proxies set various headers to track where the request actually came from.", "This middleware should only be used if the application is actually behind such a proxy, and should be configured with the number of proxies that are chained in front of it. Not all proxies set all the headers. Since incoming headers can be faked, you must set how many proxies are setting each header so the middleware knows what to trust.", "Adjust the WSGI environ based on X-Forwarded- that proxies in front of the application may set.", "You must tell the middleware how many proxies set each header so it knows what values to trust. It is a security issue to trust values that came from the client rather than a proxy.", "The original values of the headers are stored in the WSGI environ as werkzeug.proxy_fix.orig, a dict.", "None", "Changed in version 1.0: Deprecated code has been removed:", "Changed in version 0.15: All headers support multiple values. The num_proxies argument is deprecated. Each header is configured with a separate number of trusted proxies.", "Changed in version 0.15: Original WSGI environ values are stored in the werkzeug.proxy_fix.orig dict. orig_remote_addr, orig_wsgi_url_scheme, and orig_http_host are deprecated and will be removed in 1.0.", "Changed in version 0.15: Support X-Forwarded-Port and X-Forwarded-Prefix.", "Changed in version 0.15: X-Forwarded-Host and X-Forwarded-Port modify SERVER_NAME and SERVER_PORT."]}]