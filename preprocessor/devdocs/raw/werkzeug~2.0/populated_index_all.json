[{"name": "abort()", "path": "exceptions/index#werkzeug.exceptions.abort", "type": "werkzeug.exceptions", "text": " \nwerkzeug.exceptions.abort(status, *args, **kwargs)  \nRaises an HTTPException for the given status code or WSGI application. If a status code is given, it will be looked up in the list of exceptions and will raise that exception. If passed a WSGI application, it will wrap it in a proxy WSGI exception and raise that: abort(404)  # 404 Not Found\nabort(Response('Hello World'))\n  Parameters \n \nstatus (Union[int, Response]) \u2013  \nargs (Any) \u2013  \nkwargs (Any) \u2013    Return type \nNoReturn   \n"}, {"name": "Aborter", "path": "exceptions/index#werkzeug.exceptions.Aborter", "type": "werkzeug.exceptions", "text": " \nclass werkzeug.exceptions.Aborter(mapping=None, extra=None)  \nWhen passed a dict of code -> exception items it can be used as callable that raises exceptions. If the first argument to the callable is an integer it will be looked up in the mapping, if it\u2019s a WSGI application it will be raised in a proxy exception. The rest of the arguments are forwarded to the exception constructor.  Parameters \n \nmapping (Optional[Dict[int, Type[werkzeug.exceptions.HTTPException]]]) \u2013  \nextra (Optional[Dict[int, Type[werkzeug.exceptions.HTTPException]]]) \u2013    Return type \nNone   \n"}, {"name": "Accept", "path": "datastructures/index#werkzeug.datastructures.Accept", "type": "werkzeug.datastructures", "text": " \nclass werkzeug.datastructures.Accept(values=())  \nAn Accept object is just a list subclass for lists of (value, quality) tuples. It is automatically sorted by specificity and quality. All Accept objects work similar to a list but provide extra functionality for working with the data. Containment checks are normalized to the rules of that header: >>> a = CharsetAccept([('ISO-8859-1', 1), ('utf-8', 0.7)])\n>>> a.best\n'ISO-8859-1'\n>>> 'iso-8859-1' in a\nTrue\n>>> 'UTF8' in a\nTrue\n>>> 'utf7' in a\nFalse\n To get the quality for an item you can use normal item lookup: >>> print a['utf-8']\n0.7\n>>> a['utf7']\n0\n  Changelog Changed in version 1.0.0: Accept internal values are no longer ordered alphabetically for equal quality tags. Instead the initial order is preserved.   Changed in version 0.5: Accept objects are forced immutable now.   \nproperty best  \nThe best match as value. \n  \nbest_match(matches, default=None)  \nReturns the best match from a list of possible matches based on the specificity and quality of the client. If two items have the same quality and specificity, the one is returned that comes first.  Parameters \n \nmatches \u2013 a list of matches to check for \ndefault \u2013 the value that is returned if none match    \n  \nfind(key)  \nGet the position of an entry or return -1.  Parameters \nkey \u2013 The key to be looked up.   \n  \nindex(key)  \nGet the position of an entry or raise ValueError.  Parameters \nkey \u2013 The key to be looked up.    Changelog Changed in version 0.5: This used to raise IndexError, which was inconsistent with the list API.  \n\n  \nquality(key)  \nReturns the quality of the key.  Changelog New in version 0.6: In previous versions you had to use the item-lookup syntax (eg: obj[key] instead of obj.quality(key))  \n\n  \nto_header()  \nConvert the header set into an HTTP header string. \n  \nvalues()  \nIterate over all values. \n \n"}, {"name": "Accept.best_match()", "path": "datastructures/index#werkzeug.datastructures.Accept.best_match", "type": "werkzeug.datastructures", "text": " \nbest_match(matches, default=None)  \nReturns the best match from a list of possible matches based on the specificity and quality of the client. If two items have the same quality and specificity, the one is returned that comes first.  Parameters \n \nmatches \u2013 a list of matches to check for \ndefault \u2013 the value that is returned if none match    \n"}, {"name": "Accept.find()", "path": "datastructures/index#werkzeug.datastructures.Accept.find", "type": "werkzeug.datastructures", "text": " \nfind(key)  \nGet the position of an entry or return -1.  Parameters \nkey \u2013 The key to be looked up.   \n"}, {"name": "Accept.index()", "path": "datastructures/index#werkzeug.datastructures.Accept.index", "type": "werkzeug.datastructures", "text": " \nindex(key)  \nGet the position of an entry or raise ValueError.  Parameters \nkey \u2013 The key to be looked up.    Changelog Changed in version 0.5: This used to raise IndexError, which was inconsistent with the list API.  \n\n"}, {"name": "Accept.quality()", "path": "datastructures/index#werkzeug.datastructures.Accept.quality", "type": "werkzeug.datastructures", "text": " \nquality(key)  \nReturns the quality of the key.  Changelog New in version 0.6: In previous versions you had to use the item-lookup syntax (eg: obj[key] instead of obj.quality(key))  \n\n"}, {"name": "Accept.to_header()", "path": "datastructures/index#werkzeug.datastructures.Accept.to_header", "type": "werkzeug.datastructures", "text": " \nto_header()  \nConvert the header set into an HTTP header string. \n"}, {"name": "Accept.values()", "path": "datastructures/index#werkzeug.datastructures.Accept.values", "type": "werkzeug.datastructures", "text": " \nvalues()  \nIterate over all values. \n"}, {"name": "AnyConverter", "path": "routing/index#werkzeug.routing.AnyConverter", "type": "werkzeug.routing", "text": " \nclass werkzeug.routing.AnyConverter(map, *items)  \nMatches one of the items provided. Items can either be Python identifiers or strings: Rule('/<any(about, help, imprint, class, \"foo,bar\"):page_name>')\n  Parameters \n \nmap (Map) \u2013 the Map. \nitems (str) \u2013 this function accepts the possible items as positional arguments.   Return type \nNone   \n"}, {"name": "API Levels", "path": "levels/index", "type": "Other", "text": "API Levels Werkzeug is intended to be a utility rather than a framework. Because of that the user-friendly API is separated from the lower-level API so that Werkzeug can easily be used to extend another system. All the functionality the Request and Response objects (aka the \u201cwrappers\u201d) provide is also available in small utility functions.  Example This example implements a small Hello World application that greets the user with the name entered. from html import escape\nfrom werkzeug.wrappers import Request, Response\n\n@Request.application\ndef hello_world(request):\n    result = ['<title>Greeter</title>']\n    if request.method == 'POST':\n        result.append(f\"<h1>Hello {escape(request.form['name'])}!</h1>\")\n    result.append('''\n        <form action=\"\" method=\"post\">\n            <p>Name: <input type=\"text\" name=\"name\" size=\"20\">\n            <input type=\"submit\" value=\"Greet me\">\n        </form>\n    ''')\n    return Response(''.join(result), mimetype='text/html')\n Alternatively the same application could be used without request and response objects but by taking advantage of the parsing functions werkzeug provides: from html import escape\nfrom werkzeug.formparser import parse_form_data\n\ndef hello_world(environ, start_response):\n    result = ['<title>Greeter</title>']\n    if environ['REQUEST_METHOD'] == 'POST':\n        form = parse_form_data(environ)[1]\n        result.append(f\"<h1>Hello {escape(form['name'])}!</h1>\")\n    result.append('''\n        <form action=\"\" method=\"post\">\n            <p>Name: <input type=\"text\" name=\"name\" size=\"20\">\n            <input type=\"submit\" value=\"Greet me\">\n        </form>\n    ''')\n    start_response('200 OK', [('Content-Type', 'text/html; charset=utf-8')])\n    return [''.join(result).encode('utf-8')]\n   High or Low? Usually you want to use the high-level layer (the request and response objects). But there are situations where this might not be what you want. For example you might be maintaining code for an application written in Django or another framework and you have to parse HTTP headers. You can utilize Werkzeug for that by accessing the lower-level HTTP header parsing functions. Another situation where the low level parsing functions can be useful are custom WSGI frameworks, unit-testing or modernizing an old CGI/mod_python application to WSGI as well as WSGI middlewares where you want to keep the overhead low. \n"}, {"name": "append_slash_redirect()", "path": "utils/index#werkzeug.utils.append_slash_redirect", "type": "werkzeug.utils", "text": " \nwerkzeug.utils.append_slash_redirect(environ, code=301)  \nRedirects to the same URL but with a slash appended. The behavior of this function is undefined if the path ends with a slash already.  Parameters \n \nenviron (WSGIEnvironment) \u2013 the WSGI environment for the request that triggers the redirect. \ncode (int) \u2013 the status code for the redirect.   Return type \nResponse   \n"}, {"name": "Application Deployment", "path": "deployment/index", "type": "Other", "text": "Application Deployment This section covers running your application in production on a web server such as Apache or lighttpd.  \nCGI Creating a .cgi file Server Setup   \nmod_wsgi (Apache) Installing mod_wsgi Creating a .wsgi file Configuring Apache   \nFastCGI Creating a .fcgi file Configuring lighttpd Configuring nginx Debugging   \nHTTP Proxying Creating a .py server Configuring nginx   \n"}, {"name": "Application Dispatcher", "path": "middleware/dispatcher/index", "type": "Other", "text": "Application Dispatcher This middleware creates a single WSGI application that dispatches to multiple other WSGI applications mounted at different URL paths. A common example is writing a Single Page Application, where you have a backend API and a frontend written in JavaScript that does the routing in the browser rather than requesting different pages from the server. The frontend is a single HTML and JS file that should be served for any path besides \u201c/api\u201d. This example dispatches to an API app under \u201c/api\u201d, an admin app under \u201c/admin\u201d, and an app that serves frontend files for all other requests: app = DispatcherMiddleware(serve_frontend, {\n    '/api': api_app,\n    '/admin': admin_app,\n})\n In production, you might instead handle this at the HTTP server level, serving files or proxying to application servers based on location. The API and admin apps would each be deployed with a separate WSGI server, and the static files would be served directly by the HTTP server.  \nclass werkzeug.middleware.dispatcher.DispatcherMiddleware(app, mounts=None)  \nCombine multiple applications as a single WSGI application. Requests are dispatched to an application based on the path it is mounted under.  Parameters \n \napp (WSGIApplication) \u2013 The WSGI application to dispatch to if the request doesn\u2019t match a mounted path. \nmounts (Optional[Dict[str, WSGIApplication]]) \u2013 Maps path prefixes to applications for dispatching.   Return type \nNone   \n\n"}, {"name": "Application Profiler", "path": "middleware/profiler/index", "type": "Other", "text": "Application Profiler This module provides a middleware that profiles each request with the cProfile module. This can help identify bottlenecks in your code that may be slowing down your application.  \nclass werkzeug.middleware.profiler.ProfilerMiddleware(app, stream=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='UTF-8'>, sort_by=('time', 'calls'), restrictions=(), profile_dir=None, filename_format='{method}.{path}.{elapsed:.0f}ms.{time:.0f}.prof')  \nWrap a WSGI application and profile the execution of each request. Responses are buffered so that timings are more exact. If stream is given, pstats.Stats are written to it after each request. If profile_dir is given, cProfile data files are saved to that directory, one file per request. The filename can be customized by passing filename_format. If it is a string, it will be formatted using str.format() with the following fields available:  \n{method} - The request method; GET, POST, etc. \n{path} - The request path or \u2018root\u2019 should one not exist. \n{elapsed} - The elapsed time of the request. \n{time} - The time of the request.  If it is a callable, it will be called with the WSGI environ dict and should return a filename.  Parameters \n \napp (WSGIApplication) \u2013 The WSGI application to wrap. \nstream (TextIO) \u2013 Write stats to this stream. Disable with None. \nsort_by (Iterable[str]) \u2013 A tuple of columns to sort stats by. See pstats.Stats.sort_stats(). \nrestrictions (Iterable[Union[str, int, float]]) \u2013 A tuple of restrictions to filter stats by. See pstats.Stats.print_stats(). \nprofile_dir (Optional[str]) \u2013 Save profile data files to this directory. \nfilename_format (str) \u2013 Format string for profile data file names, or a callable returning a name. See explanation above.   Return type \nNone   from werkzeug.middleware.profiler import ProfilerMiddleware\napp = ProfilerMiddleware(app)\n  Changelog Changed in version 0.15: Stats are written even if profile_dir is given, and can be disable by passing stream=None.   New in version 0.15: Added filename_format.   New in version 0.9: Added restrictions and profile_dir.  \n\n\n"}, {"name": "Authorization", "path": "datastructures/index#werkzeug.datastructures.Authorization", "type": "werkzeug.datastructures", "text": " \nclass werkzeug.datastructures.Authorization(auth_type, data=None)  \nRepresents an Authorization header sent by the client. This is returned by parse_authorization_header(). It can be useful to create the object manually to pass to the test Client.  Changelog Changed in version 0.5: This object became immutable.   \nproperty cnonce  \nIf the server sent a qop-header in the WWW-Authenticate header, the client has to provide this value for HTTP digest auth. See the RFC for more details. \n  \nproperty nc  \nThe nonce count value transmitted by clients if a qop-header is also transmitted. HTTP digest auth only. \n  \nproperty nonce  \nThe nonce the server sent for digest auth, sent back by the client. A nonce should be unique for every 401 response for HTTP digest auth. \n  \nproperty opaque  \nThe opaque header from the server returned unchanged by the client. It is recommended that this string be base64 or hexadecimal data. Digest auth only. \n  \nproperty password  \nWhen the authentication type is basic this is the password transmitted by the client, else None. \n  \nproperty qop  \nIndicates what \u201cquality of protection\u201d the client has applied to the message for HTTP digest auth. Note that this is a single token, not a quoted list of alternatives as in WWW-Authenticate. \n  \nproperty realm  \nThis is the server realm sent back for HTTP digest auth. \n  \nproperty response  \nA string of 32 hex digits computed as defined in RFC 2617, which proves that the user knows a password. Digest auth only. \n  \nto_header()  \nConvert to a string value for an Authorization header.  New in version 2.0: Added to support passing authorization to the test client.  \n  \nproperty uri  \nThe URI from Request-URI of the Request-Line; duplicated because proxies are allowed to change the Request-Line in transit. HTTP digest auth only. \n  \nproperty username  \nThe username transmitted. This is set for both basic and digest auth all the time. \n \n"}, {"name": "Authorization.to_header()", "path": "datastructures/index#werkzeug.datastructures.Authorization.to_header", "type": "werkzeug.datastructures", "text": " \nto_header()  \nConvert to a string value for an Authorization header.  New in version 2.0: Added to support passing authorization to the test client.  \n"}, {"name": "BaseURL", "path": "urls/index#werkzeug.urls.BaseURL", "type": "werkzeug.urls", "text": " \nclass werkzeug.urls.BaseURL(scheme, netloc, path, query, fragment)  \nSuperclass of URL and BytesURL. Create new instance of _URLTuple(scheme, netloc, path, query, fragment)  Parameters \n \nscheme (str) \u2013  \nnetloc (str) \u2013  \npath (str) \u2013  \nquery (str) \u2013  \nfragment (str) \u2013      \nproperty ascii_host: Optional[str]  \nWorks exactly like host but will return a result that is restricted to ASCII. If it finds a netloc that is not ASCII it will attempt to idna decode it. This is useful for socket operations when the URL might include internationalized characters. \n  \nproperty auth: Optional[str]  \nThe authentication part in the URL if available, None otherwise. \n  \ndecode_netloc()  \nDecodes the netloc part into a string.  Return type \nstr   \n  \ndecode_query(*args, **kwargs)  \nDecodes the query part of the URL. Ths is a shortcut for calling url_decode() on the query argument. The arguments and keyword arguments are forwarded to url_decode() unchanged.  Parameters \n \nargs (Any) \u2013  \nkwargs (Any) \u2013    Return type \nds.MultiDict[str, str]   \n  \nencode_netloc()  \nEncodes the netloc part to an ASCII safe URL as bytes.  Return type \nstr   \n  \nget_file_location(pathformat=None)  \nReturns a tuple with the location of the file in the form (server, location). If the netloc is empty in the URL or points to localhost, it\u2019s represented as None. The pathformat by default is autodetection but needs to be set when working with URLs of a specific system. The supported values are 'windows' when working with Windows or DOS paths and 'posix' when working with posix paths. If the URL does not point to a local file, the server and location are both represented as None.  Parameters \npathformat (Optional[str]) \u2013 The expected format of the path component. Currently 'windows' and 'posix' are supported. Defaults to None which is autodetect.  Return type \nTuple[Optional[str], Optional[str]]   \n  \nproperty host: Optional[str]  \nThe host part of the URL if available, otherwise None. The host is either the hostname or the IP address mentioned in the URL. It will not contain the port. \n  \njoin(*args, **kwargs)  \nJoins this URL with another one. This is just a convenience function for calling into url_join() and then parsing the return value again.  Parameters \n \nargs (Any) \u2013  \nkwargs (Any) \u2013    Return type \nwerkzeug.urls.BaseURL   \n  \nproperty password: Optional[str]  \nThe password if it was part of the URL, None otherwise. This undergoes URL decoding and will always be a string. \n  \nproperty port: Optional[int]  \nThe port in the URL as an integer if it was present, None otherwise. This does not fill in default ports. \n  \nproperty raw_password: Optional[str]  \nThe password if it was part of the URL, None otherwise. Unlike password this one is not being decoded. \n  \nproperty raw_username: Optional[str]  \nThe username if it was part of the URL, None otherwise. Unlike username this one is not being decoded. \n  \nreplace(**kwargs)  \nReturn an URL with the same values, except for those parameters given new values by whichever keyword arguments are specified.  Parameters \nkwargs (Any) \u2013   Return type \nwerkzeug.urls.BaseURL   \n  \nto_iri_tuple()  \nReturns a URL tuple that holds a IRI. This will try to decode as much information as possible in the URL without losing information similar to how a web browser does it for the URL bar. It\u2019s usually more interesting to directly call uri_to_iri() which will return a string.  Return type \nwerkzeug.urls.BaseURL   \n  \nto_uri_tuple()  \nReturns a BytesURL tuple that holds a URI. This will encode all the information in the URL properly to ASCII using the rules a web browser would follow. It\u2019s usually more interesting to directly call iri_to_uri() which will return a string.  Return type \nwerkzeug.urls.BaseURL   \n  \nto_url()  \nReturns a URL string or bytes depending on the type of the information stored. This is just a convenience function for calling url_unparse() for this URL.  Return type \nstr   \n  \nproperty username: Optional[str]  \nThe username if it was part of the URL, None otherwise. This undergoes URL decoding and will always be a string. \n \n"}, {"name": "BaseURL.decode_netloc()", "path": "urls/index#werkzeug.urls.BaseURL.decode_netloc", "type": "werkzeug.urls", "text": " \ndecode_netloc()  \nDecodes the netloc part into a string.  Return type \nstr   \n"}, {"name": "BaseURL.decode_query()", "path": "urls/index#werkzeug.urls.BaseURL.decode_query", "type": "werkzeug.urls", "text": " \ndecode_query(*args, **kwargs)  \nDecodes the query part of the URL. Ths is a shortcut for calling url_decode() on the query argument. The arguments and keyword arguments are forwarded to url_decode() unchanged.  Parameters \n \nargs (Any) \u2013  \nkwargs (Any) \u2013    Return type \nds.MultiDict[str, str]   \n"}, {"name": "BaseURL.encode_netloc()", "path": "urls/index#werkzeug.urls.BaseURL.encode_netloc", "type": "werkzeug.urls", "text": " \nencode_netloc()  \nEncodes the netloc part to an ASCII safe URL as bytes.  Return type \nstr   \n"}, {"name": "BaseURL.get_file_location()", "path": "urls/index#werkzeug.urls.BaseURL.get_file_location", "type": "werkzeug.urls", "text": " \nget_file_location(pathformat=None)  \nReturns a tuple with the location of the file in the form (server, location). If the netloc is empty in the URL or points to localhost, it\u2019s represented as None. The pathformat by default is autodetection but needs to be set when working with URLs of a specific system. The supported values are 'windows' when working with Windows or DOS paths and 'posix' when working with posix paths. If the URL does not point to a local file, the server and location are both represented as None.  Parameters \npathformat (Optional[str]) \u2013 The expected format of the path component. Currently 'windows' and 'posix' are supported. Defaults to None which is autodetect.  Return type \nTuple[Optional[str], Optional[str]]   \n"}, {"name": "BaseURL.join()", "path": "urls/index#werkzeug.urls.BaseURL.join", "type": "werkzeug.urls", "text": " \njoin(*args, **kwargs)  \nJoins this URL with another one. This is just a convenience function for calling into url_join() and then parsing the return value again.  Parameters \n \nargs (Any) \u2013  \nkwargs (Any) \u2013    Return type \nwerkzeug.urls.BaseURL   \n"}, {"name": "BaseURL.replace()", "path": "urls/index#werkzeug.urls.BaseURL.replace", "type": "werkzeug.urls", "text": " \nreplace(**kwargs)  \nReturn an URL with the same values, except for those parameters given new values by whichever keyword arguments are specified.  Parameters \nkwargs (Any) \u2013   Return type \nwerkzeug.urls.BaseURL   \n"}, {"name": "BaseURL.to_iri_tuple()", "path": "urls/index#werkzeug.urls.BaseURL.to_iri_tuple", "type": "werkzeug.urls", "text": " \nto_iri_tuple()  \nReturns a URL tuple that holds a IRI. This will try to decode as much information as possible in the URL without losing information similar to how a web browser does it for the URL bar. It\u2019s usually more interesting to directly call uri_to_iri() which will return a string.  Return type \nwerkzeug.urls.BaseURL   \n"}, {"name": "BaseURL.to_uri_tuple()", "path": "urls/index#werkzeug.urls.BaseURL.to_uri_tuple", "type": "werkzeug.urls", "text": " \nto_uri_tuple()  \nReturns a BytesURL tuple that holds a URI. This will encode all the information in the URL properly to ASCII using the rules a web browser would follow. It\u2019s usually more interesting to directly call iri_to_uri() which will return a string.  Return type \nwerkzeug.urls.BaseURL   \n"}, {"name": "BaseURL.to_url()", "path": "urls/index#werkzeug.urls.BaseURL.to_url", "type": "werkzeug.urls", "text": " \nto_url()  \nReturns a URL string or bytes depending on the type of the information stored. This is just a convenience function for calling url_unparse() for this URL.  Return type \nstr   \n"}, {"name": "Basic HTTP Proxy", "path": "middleware/http_proxy/index", "type": "Other", "text": "Basic HTTP Proxy  \nclass werkzeug.middleware.http_proxy.ProxyMiddleware(app, targets, chunk_size=16384, timeout=10)  \nProxy requests under a path to an external server, routing other requests to the app. This middleware can only proxy HTTP requests, as HTTP is the only protocol handled by the WSGI server. Other protocols, such as WebSocket requests, cannot be proxied at this layer. This should only be used for development, in production a real proxy server should be used. The middleware takes a dict mapping a path prefix to a dict describing the host to be proxied to: app = ProxyMiddleware(app, {\n    \"/static/\": {\n        \"target\": \"http://127.0.0.1:5001/\",\n    }\n})\n Each host has the following options:  \ntarget: \n\nThe target URL to dispatch to. This is required.  \nremove_prefix: \n\nWhether to remove the prefix from the URL before dispatching it to the target. The default is False.  \nhost: \n\n \n\"<auto>\" (default): \n\nThe host header is automatically rewritten to the URL of the target.  \nNone: \n\nThe host header is unmodified from the client request.  Any other value:\n\nThe host header is overwritten with the value.    \nheaders: \n\nA dictionary of headers to be sent with the request to the target. The default is {}.  \nssl_context: \n\nA ssl.SSLContext defining how to verify requests if the target is HTTPS. The default is None.   In the example above, everything under \"/static/\" is proxied to the server on port 5001. The host header is rewritten to the target, and the \"/static/\" prefix is removed from the URLs.  Parameters \n \napp (WSGIApplication) \u2013 The WSGI application to wrap. \ntargets (Mapping[str, Dict[str, Any]]) \u2013 Proxy target configurations. See description above. \nchunk_size (int) \u2013 Size of chunks to read from input stream and write to target. \ntimeout (int) \u2013 Seconds before an operation to a target fails.   Return type \nNone    Changelog New in version 0.14.  \n\n\n"}, {"name": "bind_arguments()", "path": "utils/index#werkzeug.utils.bind_arguments", "type": "werkzeug.utils", "text": " \nwerkzeug.utils.bind_arguments(func, args, kwargs)  \nBind the arguments provided into a dict. When passed a function, a tuple of arguments and a dict of keyword arguments bind_arguments returns a dict of names as the function would see it. This can be useful to implement a cache decorator that uses the function arguments to build the cache key based on the values of the arguments.  Parameters \n \nfunc \u2013 the function the arguments should be bound for. \nargs \u2013 tuple of positional arguments. \nkwargs \u2013 a dict of keyword arguments.   Returns \na dict of bound keyword arguments.    Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use Signature.bind() instead.  \n"}, {"name": "BrokenFilesystemWarning", "path": "filesystem/index#werkzeug.filesystem.BrokenFilesystemWarning", "type": "werkzeug.filesystem", "text": " \nclass werkzeug.filesystem.BrokenFilesystemWarning  \nThe warning used by Werkzeug to signal a broken filesystem. Will only be used once per runtime. \n"}, {"name": "BSD-3-Clause License", "path": "license/index", "type": "Other", "text": "BSD-3-Clause License Copyright 2007 Pallets Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:  Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u201cAS IS\u201d AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"}, {"name": "BytesURL", "path": "urls/index#werkzeug.urls.BytesURL", "type": "werkzeug.urls", "text": " \nclass werkzeug.urls.BytesURL(scheme, netloc, path, query, fragment)  \nRepresents a parsed URL in bytes. Create new instance of _URLTuple(scheme, netloc, path, query, fragment)  Parameters \n \nscheme (str) \u2013  \nnetloc (str) \u2013  \npath (str) \u2013  \nquery (str) \u2013  \nfragment (str) \u2013      \ndecode(charset='utf-8', errors='replace')  \nDecodes the URL to a tuple made out of strings. The charset is only being used for the path, query and fragment.  Parameters \n \ncharset (str) \u2013  \nerrors (str) \u2013    Return type \nwerkzeug.urls.URL   \n  \nencode_netloc()  \nReturns the netloc unchanged as bytes.  Return type \nbytes   \n \n"}, {"name": "BytesURL.decode()", "path": "urls/index#werkzeug.urls.BytesURL.decode", "type": "werkzeug.urls", "text": " \ndecode(charset='utf-8', errors='replace')  \nDecodes the URL to a tuple made out of strings. The charset is only being used for the path, query and fragment.  Parameters \n \ncharset (str) \u2013  \nerrors (str) \u2013    Return type \nwerkzeug.urls.URL   \n"}, {"name": "BytesURL.encode_netloc()", "path": "urls/index#werkzeug.urls.BytesURL.encode_netloc", "type": "werkzeug.urls", "text": " \nencode_netloc()  \nReturns the netloc unchanged as bytes.  Return type \nbytes   \n"}, {"name": "cached_property", "path": "utils/index#werkzeug.utils.cached_property", "type": "werkzeug.utils", "text": " \nclass werkzeug.utils.cached_property(fget, name=None, doc=None)  \nA property() that is only evaluated once. Subsequent access returns the cached value. Setting the property sets the cached value. Deleting the property clears the cached value, accessing it again will evaluate it again. class Example:\n    @cached_property\n    def value(self):\n        # calculate something important here\n        return 42\n\ne = Example()\ne.value  # evaluates\ne.value  # uses cache\ne.value = 16  # sets cache\ndel e.value  # clears cache\n The class must have a __dict__ for this to work.  Changed in version 2.0: del obj.name clears the cached value.   Parameters \n \nfget (Callable[[Any], Any]) \u2013  \nname (Optional[str]) \u2013  \ndoc (Optional[str]) \u2013    Return type \nNone   \n"}, {"name": "CGI", "path": "deployment/cgi/index", "type": "Other", "text": "CGI If all other deployment methods do not work, CGI will work for sure. CGI is supported by all major servers but usually has a less-than-optimal performance. This is also the way you can use a Werkzeug application on Google\u2019s AppEngine, there however the execution does happen in a CGI-like environment. The application\u2019s performance is unaffected because of that.  Creating a .cgi file First you need to create the CGI application file. Let\u2019s call it yourapplication.cgi: #!/usr/bin/python\nfrom wsgiref.handlers import CGIHandler\nfrom yourapplication import make_app\n\napplication = make_app()\nCGIHandler().run(application)\n   Server Setup Usually there are two ways to configure the server. Either just copy the .cgi into a cgi-bin (and use mod_rewrite or something similar to rewrite the URL) or let the server point to the file directly. In Apache for example you can put something like this into the config: ScriptAlias /app /path/to/the/application.cgi\n For more information consult the documentation of your webserver. \n"}, {"name": "CharsetAccept", "path": "datastructures/index#werkzeug.datastructures.CharsetAccept", "type": "werkzeug.datastructures", "text": " \nclass werkzeug.datastructures.CharsetAccept(values=())  \nLike Accept but with normalization for charsets. \n"}, {"name": "check_password_hash()", "path": "utils/index#werkzeug.security.check_password_hash", "type": "werkzeug.security", "text": " \nwerkzeug.security.check_password_hash(pwhash, password)  \nCheck a password against a given salted and hashed password value. In order to support unsalted legacy passwords this method supports plain text passwords, md5 and sha1 hashes (both salted and unsalted). Returns True if the password matched, False otherwise.  Parameters \n \npwhash (str) \u2013 a hashed string like returned by generate_password_hash(). \npassword (str) \u2013 the plaintext password to compare against the hash.   Return type \nbool   \n"}, {"name": "Client", "path": "test/index#werkzeug.test.Client", "type": "werkzeug.test", "text": " \nclass werkzeug.test.Client(application, response_wrapper=None, use_cookies=True, allow_subdomain_redirects=False)  \nThis class allows you to send requests to a wrapped application. The use_cookies parameter indicates whether cookies should be stored and sent for subsequent requests. This is True by default, but passing False will disable this behaviour. If you want to request some subdomain of your application you may set allow_subdomain_redirects to True as if not no external redirects are allowed.  Changed in version 2.0: response_wrapper is always a subclass of :class:TestResponse.   Changelog Changed in version 0.5: Added the use_cookies parameter.   Parameters \n \napplication (WSGIApplication) \u2013  \nresponse_wrapper (Optional[Type[Response]]) \u2013  \nuse_cookies (bool) \u2013  \nallow_subdomain_redirects (bool) \u2013    Return type \nNone    \nset_cookie(server_name, key, value='', max_age=None, expires=None, path='/', domain=None, secure=False, httponly=False, samesite=None, charset='utf-8')  \nSets a cookie in the client\u2019s cookie jar. The server name is required and has to match the one that is also passed to the open call.  Parameters \n \nserver_name (str) \u2013  \nkey (str) \u2013  \nvalue (str) \u2013  \nmax_age (Optional[Union[datetime.timedelta, int]]) \u2013  \nexpires (Optional[Union[str, datetime.datetime, int, float]]) \u2013  \npath (str) \u2013  \ndomain (Optional[str]) \u2013  \nsecure (bool) \u2013  \nhttponly (bool) \u2013  \nsamesite (Optional[str]) \u2013  \ncharset (str) \u2013    Return type \nNone   \n  \ndelete_cookie(server_name, key, path='/', domain=None, secure=False, httponly=False, samesite=None)  \nDeletes a cookie in the test client.  Parameters \n \nserver_name (str) \u2013  \nkey (str) \u2013  \npath (str) \u2013  \ndomain (Optional[str]) \u2013  \nsecure (bool) \u2013  \nhttponly (bool) \u2013  \nsamesite (Optional[str]) \u2013    Return type \nNone   \n  \nopen(*args, as_tuple=False, buffered=False, follow_redirects=False, **kwargs)  \nGenerate an environ dict from the given arguments, make a request to the application using it, and return the response.  Parameters \n \nargs (Any) \u2013 Passed to EnvironBuilder to create the environ for the request. If a single arg is passed, it can be an existing EnvironBuilder or an environ dict. \nbuffered (bool) \u2013 Convert the iterator returned by the app into a list. If the iterator has a close() method, it is called automatically. \nfollow_redirects (bool) \u2013 Make additional requests to follow HTTP redirects until a non-redirect status is returned. TestResponse.history lists the intermediate responses. \nas_tuple (bool) \u2013  \nkwargs (Any) \u2013    Return type \nwerkzeug.test.TestResponse    Changed in version 2.0: as_tuple is deprecated and will be removed in Werkzeug 2.1. Use TestResponse.request and request.environ instead.   Changed in version 2.0: The request input stream is closed when calling response.close(). Input streams for redirects are automatically closed.   Changelog Changed in version 0.5: If a dict is provided as file in the dict for the data parameter the content type has to be called content_type instead of mimetype. This change was made for consistency with werkzeug.FileWrapper.   Changed in version 0.5: Added the follow_redirects parameter.  \n\n  \nget(*args, **kw)  \nCall open() with method set to GET.  Parameters \n \nargs (Any) \u2013  \nkw (Any) \u2013    Return type \nwerkzeug.test.TestResponse   \n  \npost(*args, **kw)  \nCall open() with method set to POST.  Parameters \n \nargs (Any) \u2013  \nkw (Any) \u2013    Return type \nwerkzeug.test.TestResponse   \n  \nput(*args, **kw)  \nCall open() with method set to PUT.  Parameters \n \nargs (Any) \u2013  \nkw (Any) \u2013    Return type \nwerkzeug.test.TestResponse   \n  \ndelete(*args, **kw)  \nCall open() with method set to DELETE.  Parameters \n \nargs (Any) \u2013  \nkw (Any) \u2013    Return type \nwerkzeug.test.TestResponse   \n  \npatch(*args, **kw)  \nCall open() with method set to PATCH.  Parameters \n \nargs (Any) \u2013  \nkw (Any) \u2013    Return type \nwerkzeug.test.TestResponse   \n  \noptions(*args, **kw)  \nCall open() with method set to OPTIONS.  Parameters \n \nargs (Any) \u2013  \nkw (Any) \u2013    Return type \nwerkzeug.test.TestResponse   \n  \nhead(*args, **kw)  \nCall open() with method set to HEAD.  Parameters \n \nargs (Any) \u2013  \nkw (Any) \u2013    Return type \nwerkzeug.test.TestResponse   \n  \ntrace(*args, **kw)  \nCall open() with method set to TRACE.  Parameters \n \nargs (Any) \u2013  \nkw (Any) \u2013    Return type \nwerkzeug.test.TestResponse   \n \n"}, {"name": "Client.delete()", "path": "test/index#werkzeug.test.Client.delete", "type": "werkzeug.test", "text": " \ndelete(*args, **kw)  \nCall open() with method set to DELETE.  Parameters \n \nargs (Any) \u2013  \nkw (Any) \u2013    Return type \nwerkzeug.test.TestResponse   \n"}, {"name": "Client.delete_cookie()", "path": "test/index#werkzeug.test.Client.delete_cookie", "type": "werkzeug.test", "text": " \ndelete_cookie(server_name, key, path='/', domain=None, secure=False, httponly=False, samesite=None)  \nDeletes a cookie in the test client.  Parameters \n \nserver_name (str) \u2013  \nkey (str) \u2013  \npath (str) \u2013  \ndomain (Optional[str]) \u2013  \nsecure (bool) \u2013  \nhttponly (bool) \u2013  \nsamesite (Optional[str]) \u2013    Return type \nNone   \n"}, {"name": "Client.get()", "path": "test/index#werkzeug.test.Client.get", "type": "werkzeug.test", "text": " \nget(*args, **kw)  \nCall open() with method set to GET.  Parameters \n \nargs (Any) \u2013  \nkw (Any) \u2013    Return type \nwerkzeug.test.TestResponse   \n"}, {"name": "Client.head()", "path": "test/index#werkzeug.test.Client.head", "type": "werkzeug.test", "text": " \nhead(*args, **kw)  \nCall open() with method set to HEAD.  Parameters \n \nargs (Any) \u2013  \nkw (Any) \u2013    Return type \nwerkzeug.test.TestResponse   \n"}, {"name": "Client.open()", "path": "test/index#werkzeug.test.Client.open", "type": "werkzeug.test", "text": " \nopen(*args, as_tuple=False, buffered=False, follow_redirects=False, **kwargs)  \nGenerate an environ dict from the given arguments, make a request to the application using it, and return the response.  Parameters \n \nargs (Any) \u2013 Passed to EnvironBuilder to create the environ for the request. If a single arg is passed, it can be an existing EnvironBuilder or an environ dict. \nbuffered (bool) \u2013 Convert the iterator returned by the app into a list. If the iterator has a close() method, it is called automatically. \nfollow_redirects (bool) \u2013 Make additional requests to follow HTTP redirects until a non-redirect status is returned. TestResponse.history lists the intermediate responses. \nas_tuple (bool) \u2013  \nkwargs (Any) \u2013    Return type \nwerkzeug.test.TestResponse    Changed in version 2.0: as_tuple is deprecated and will be removed in Werkzeug 2.1. Use TestResponse.request and request.environ instead.   Changed in version 2.0: The request input stream is closed when calling response.close(). Input streams for redirects are automatically closed.   Changelog Changed in version 0.5: If a dict is provided as file in the dict for the data parameter the content type has to be called content_type instead of mimetype. This change was made for consistency with werkzeug.FileWrapper.   Changed in version 0.5: Added the follow_redirects parameter.  \n\n"}, {"name": "Client.options()", "path": "test/index#werkzeug.test.Client.options", "type": "werkzeug.test", "text": " \noptions(*args, **kw)  \nCall open() with method set to OPTIONS.  Parameters \n \nargs (Any) \u2013  \nkw (Any) \u2013    Return type \nwerkzeug.test.TestResponse   \n"}, {"name": "Client.patch()", "path": "test/index#werkzeug.test.Client.patch", "type": "werkzeug.test", "text": " \npatch(*args, **kw)  \nCall open() with method set to PATCH.  Parameters \n \nargs (Any) \u2013  \nkw (Any) \u2013    Return type \nwerkzeug.test.TestResponse   \n"}, {"name": "Client.post()", "path": "test/index#werkzeug.test.Client.post", "type": "werkzeug.test", "text": " \npost(*args, **kw)  \nCall open() with method set to POST.  Parameters \n \nargs (Any) \u2013  \nkw (Any) \u2013    Return type \nwerkzeug.test.TestResponse   \n"}, {"name": "Client.put()", "path": "test/index#werkzeug.test.Client.put", "type": "werkzeug.test", "text": " \nput(*args, **kw)  \nCall open() with method set to PUT.  Parameters \n \nargs (Any) \u2013  \nkw (Any) \u2013    Return type \nwerkzeug.test.TestResponse   \n"}, {"name": "Client.set_cookie()", "path": "test/index#werkzeug.test.Client.set_cookie", "type": "werkzeug.test", "text": " \nset_cookie(server_name, key, value='', max_age=None, expires=None, path='/', domain=None, secure=False, httponly=False, samesite=None, charset='utf-8')  \nSets a cookie in the client\u2019s cookie jar. The server name is required and has to match the one that is also passed to the open call.  Parameters \n \nserver_name (str) \u2013  \nkey (str) \u2013  \nvalue (str) \u2013  \nmax_age (Optional[Union[datetime.timedelta, int]]) \u2013  \nexpires (Optional[Union[str, datetime.datetime, int, float]]) \u2013  \npath (str) \u2013  \ndomain (Optional[str]) \u2013  \nsecure (bool) \u2013  \nhttponly (bool) \u2013  \nsamesite (Optional[str]) \u2013  \ncharset (str) \u2013    Return type \nNone   \n"}, {"name": "Client.trace()", "path": "test/index#werkzeug.test.Client.trace", "type": "werkzeug.test", "text": " \ntrace(*args, **kw)  \nCall open() with method set to TRACE.  Parameters \n \nargs (Any) \u2013  \nkw (Any) \u2013    Return type \nwerkzeug.test.TestResponse   \n"}, {"name": "ClosingIterator", "path": "wsgi/index#werkzeug.wsgi.ClosingIterator", "type": "werkzeug.wsgi", "text": " \nclass werkzeug.wsgi.ClosingIterator(iterable, callbacks=None)  \nThe WSGI specification requires that all middlewares and gateways respect the close callback of the iterable returned by the application. Because it is useful to add another close action to a returned iterable and adding a custom iterable is a boring task this class can be used for that: return ClosingIterator(app(environ, start_response), [cleanup_session,\n                                                      cleanup_locals])\n If there is just one close function it can be passed instead of the list. A closing iterator is not needed if the application uses response objects and finishes the processing if the response is started: try:\n    return response(environ, start_response)\nfinally:\n    cleanup_session()\n    cleanup_locals()\n  Parameters \n \niterable (Iterable[bytes]) \u2013  \ncallbacks (Optional[Union[Callable[[], None], Iterable[Callable[[], None]]]]) \u2013    Return type \nNone   \n"}, {"name": "CombinedMultiDict", "path": "datastructures/index#werkzeug.datastructures.CombinedMultiDict", "type": "werkzeug.datastructures", "text": " \nclass werkzeug.datastructures.CombinedMultiDict(dicts=None)  \nA read only MultiDict that you can pass multiple MultiDict instances as sequence and it will combine the return values of all wrapped dicts: >>> from werkzeug.datastructures import CombinedMultiDict, MultiDict\n>>> post = MultiDict([('foo', 'bar')])\n>>> get = MultiDict([('blub', 'blah')])\n>>> combined = CombinedMultiDict([get, post])\n>>> combined['foo']\n'bar'\n>>> combined['blub']\n'blah'\n This works for all read operations and will raise a TypeError for methods that usually change data which isn\u2019t possible. From Werkzeug 0.3 onwards, the KeyError raised by this class is also a subclass of the BadRequest HTTP exception and will render a page for a 400 BAD REQUEST if caught in a catch-all for HTTP exceptions. \n"}, {"name": "ContentRange", "path": "datastructures/index#werkzeug.datastructures.ContentRange", "type": "werkzeug.datastructures", "text": " \nclass werkzeug.datastructures.ContentRange(units, start, stop, length=None, on_update=None)  \nRepresents the content range header.  Changelog New in version 0.7.   \nproperty length  \nThe length of the range or None. \n  \nset(start, stop, length=None, units='bytes')  \nSimple method to update the ranges. \n  \nproperty start  \nThe start point of the range or None. \n  \nproperty stop  \nThe stop point of the range (non-inclusive) or None. Can only be None if also start is None. \n  \nproperty units  \nThe units to use, usually \u201cbytes\u201d \n  \nunset()  \nSets the units to None which indicates that the header should no longer be used. \n \n"}, {"name": "ContentRange.set()", "path": "datastructures/index#werkzeug.datastructures.ContentRange.set", "type": "werkzeug.datastructures", "text": " \nset(start, stop, length=None, units='bytes')  \nSimple method to update the ranges. \n"}, {"name": "ContentRange.unset()", "path": "datastructures/index#werkzeug.datastructures.ContentRange.unset", "type": "werkzeug.datastructures", "text": " \nunset()  \nSets the units to None which indicates that the header should no longer be used. \n"}, {"name": "Context Locals", "path": "local/index", "type": "Other", "text": "Context Locals Sooner or later you have some things you want to have in every single view or helper function or whatever. In PHP the way to go are global variables. However, that isn\u2019t possible in WSGI applications without a major drawback: As soon as you operate on the global namespace your application isn\u2019t thread-safe any longer. The Python standard library has a concept called \u201cthread locals\u201d (or thread-local data). A thread local is a global object in which you can put stuff in and get back later in a thread-safe and thread-specific way. That means that whenever you set or get a value on a thread local object, the thread local object checks in which thread you are and retrieves the value corresponding to your thread (if one exists). So, you won\u2019t accidentally get another thread\u2019s data. This approach, however, has a few disadvantages. For example, besides threads, there are other types of concurrency in Python. A very popular one is greenlets. Also, whether every request gets its own thread is not guaranteed in WSGI. It could be that a request is reusing a thread from a previous request, and hence data is left over in the thread local object. Werkzeug provides its own implementation of local data storage called werkzeug.local. This approach provides a similar functionality to thread locals but also works with greenlets. Here\u2019s a simple example of how one could use werkzeug.local: from werkzeug.local import Local, LocalManager\n\nlocal = Local()\nlocal_manager = LocalManager([local])\n\ndef application(environ, start_response):\n    local.request = request = Request(environ)\n    ...\n\napplication = local_manager.make_middleware(application)\n This binds the request to local.request. Every other piece of code executed after this assignment in the same context can safely access local.request and will get the same request object. The make_middleware method on the local manager ensures that all references to the local objects are cleared up after the request. The same context means the same greenlet (if you\u2019re using greenlets) in the same thread and same process. If a request object is not yet set on the local object and you try to access it, you will get an AttributeError. You can use getattr to avoid that: def get_request():\n    return getattr(local, 'request', None)\n This will try to get the request or return None if the request is not (yet?) available. Note that local objects cannot manage themselves, for that you need a local manager. You can pass a local manager multiple locals or add additionals later by appending them to manager.locals and every time the manager cleans up it will clean up all the data left in the locals for this context.  \nwerkzeug.local.release_local(local)  \nReleases the contents of the local for the current context. This makes it possible to use locals without a manager. Example: >>> loc = Local()\n>>> loc.foo = 42\n>>> release_local(loc)\n>>> hasattr(loc, 'foo')\nFalse\n With this function one can release Local objects as well as LocalStack objects. However it is not possible to release data held by proxies that way, one always has to retain a reference to the underlying local object in order to be able to release it.  Changelog New in version 0.6.1.   Parameters \nlocal (Union[werkzeug.local.Local, werkzeug.local.LocalStack]) \u2013   Return type \nNone   \n  \nclass werkzeug.local.LocalManager(locals=None, ident_func=None)  \nLocal objects cannot manage themselves. For that you need a local manager. You can pass a local manager multiple locals or add them later y appending them to manager.locals. Every time the manager cleans up, it will clean up all the data left in the locals for this context.  Changed in version 2.0: ident_func is deprecated and will be removed in Werkzeug 2.1.   Changelog Changed in version 0.7: The ident_func parameter was added.   Changed in version 0.6.1: The release_local() function can be used instead of a manager.   Parameters \n \nlocals (Optional[Iterable[Union[werkzeug.local.Local, werkzeug.local.LocalStack]]]) \u2013  \nident_func (None) \u2013    Return type \nNone    \ncleanup()  \nManually clean up the data in the locals for this context. Call this at the end of the request or use make_middleware().  Return type \nNone   \n  \nget_ident()  \nReturn the context identifier the local objects use internally for this context. You cannot override this method to change the behavior but use it to link other context local objects (such as SQLAlchemy\u2019s scoped sessions) to the Werkzeug locals.  Deprecated since version 2.0: Will be removed in Werkzeug 2.1.   Changelog Changed in version 0.7: You can pass a different ident function to the local manager that will then be propagated to all the locals passed to the constructor.   Return type \nint   \n  \nmake_middleware(app)  \nWrap a WSGI application so that cleaning up happens after request end.  Parameters \napp (WSGIApplication) \u2013   Return type \nWSGIApplication   \n  \nmiddleware(func)  \nLike make_middleware but for decorating functions. Example usage: @manager.middleware\ndef application(environ, start_response):\n    ...\n The difference to make_middleware is that the function passed will have all the arguments copied from the inner application (name, docstring, module).  Parameters \nfunc (WSGIApplication) \u2013   Return type \nWSGIApplication   \n \n  \nclass werkzeug.local.LocalStack  \nThis class works similar to a Local but keeps a stack of objects instead. This is best explained with an example: >>> ls = LocalStack()\n>>> ls.push(42)\n>>> ls.top\n42\n>>> ls.push(23)\n>>> ls.top\n23\n>>> ls.pop()\n23\n>>> ls.top\n42\n They can be force released by using a LocalManager or with the release_local() function but the correct way is to pop the item from the stack after using. When the stack is empty it will no longer be bound to the current context (and as such released). By calling the stack without arguments it returns a proxy that resolves to the topmost item on the stack.  Changelog New in version 0.6.1.   Return type \nNone    \npop()  \nRemoves the topmost item from the stack, will return the old value or None if the stack was already empty.  Return type \nAny   \n  \npush(obj)  \nPushes a new item to the stack  Parameters \nobj (Any) \u2013   Return type \nList[Any]   \n  \nproperty top: Any  \nThe topmost item on the stack. If the stack is empty, None is returned. \n \n  \nclass werkzeug.local.LocalProxy(local, name=None)  \nA proxy to the object bound to a Local. All operations on the proxy are forwarded to the bound object. If no object is bound, a RuntimeError is raised. from werkzeug.local import Local\nl = Local()\n\n# a proxy to whatever l.user is set to\nuser = l(\"user\")\n\nfrom werkzeug.local import LocalStack\n_request_stack = LocalStack()\n\n# a proxy to _request_stack.top\nrequest = _request_stack()\n\n# a proxy to the session attribute of the request proxy\nsession = LocalProxy(lambda: request.session)\n __repr__ and __class__ are forwarded, so repr(x) and isinstance(x, cls) will look like the proxied object. Use issubclass(type(x), LocalProxy) to check if an object is a proxy. repr(user)  # <User admin>\nisinstance(user, User)  # True\nissubclass(type(user), LocalProxy)  # True\n  Parameters \n \nlocal \u2013 The Local or callable that provides the proxied object. \nname \u2013 The attribute name to look up on a Local. Not used if a callable is given.     Changed in version 2.0: Updated proxied attributes and methods to reflect the current data model.   Changelog Changed in version 0.6.1: The class can be instantiated with a callable.   \n_get_current_object()  \nReturn the current object. This is useful if you want the real object behind the proxy at a time for performance reasons or because you want to pass the object into a different context.  Return type \nAny   \n \n\n"}, {"name": "cookie_date()", "path": "http/index#werkzeug.http.cookie_date", "type": "werkzeug.http", "text": " \nwerkzeug.http.cookie_date(expires=None)  \nFormat a datetime object or timestamp into an RFC 2822 date string for Set-Cookie expires.  Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use http_date() instead.   Parameters \nexpires (Optional[Union[datetime.datetime, datetime.date, int, float, time.struct_time]]) \u2013   Return type \nstr   \n"}, {"name": "create_environ()", "path": "test/index#werkzeug.test.create_environ", "type": "werkzeug.test", "text": " \nwerkzeug.test.create_environ(*args, **kwargs)  \nCreate a new WSGI environ dict based on the values passed. The first parameter should be the path of the request which defaults to \u2018/\u2019. The second one can either be an absolute path (in that case the host is localhost:80) or a full path to the request with scheme, netloc port and the path to the script. This accepts the same arguments as the EnvironBuilder constructor.  Changelog Changed in version 0.5: This function is now a thin wrapper over EnvironBuilder which was added in 0.5. The headers, environ_base, environ_overrides and charset parameters were added.   Parameters \n \nargs (Any) \u2013  \nkwargs (Any) \u2013    Return type \nWSGIEnvironment   \n"}, {"name": "Data Structures", "path": "datastructures/index", "type": "Other", "text": "Data Structures Werkzeug provides some subclasses of common Python objects to extend them with additional features. Some of them are used to make them immutable, others are used to change some semantics to better work with HTTP.  General Purpose  Changelog Changed in version 0.6: The general purpose classes are now pickleable in each protocol as long as the contained objects are pickleable. This means that the FileMultiDict won\u2019t be pickleable as soon as it contains a file.   \nclass werkzeug.datastructures.TypeConversionDict  \nWorks like a regular dict but the get() method can perform type conversions. MultiDict and CombinedMultiDict are subclasses of this class and provide the same feature.  Changelog New in version 0.5.   \nget(key, default=None, type=None)  \nReturn the default value if the requested data doesn\u2019t exist. If type is provided and is a callable it should convert the value, return it or raise a ValueError if that is not possible. In this case the function will return the default as if the value was not found: >>> d = TypeConversionDict(foo='42', bar='blub')\n>>> d.get('foo', type=int)\n42\n>>> d.get('bar', -1, type=int)\n-1\n  Parameters \n \nkey \u2013 The key to be looked up. \ndefault \u2013 The default value to be returned if the key can\u2019t be looked up. If not further specified None is returned. \ntype \u2013 A callable that is used to cast the value in the MultiDict. If a ValueError is raised by this callable the default value is returned.    \n \n  \nclass werkzeug.datastructures.ImmutableTypeConversionDict  \nWorks like a TypeConversionDict but does not support modifications.  Changelog New in version 0.5.   \ncopy()  \nReturn a shallow mutable copy of this object. Keep in mind that the standard library\u2019s copy() function is a no-op for this class like for any other python immutable type (eg: tuple). \n \n  \nclass werkzeug.datastructures.MultiDict(mapping=None)  \nA MultiDict is a dictionary subclass customized to deal with multiple values for the same key which is for example used by the parsing functions in the wrappers. This is necessary because some HTML form elements pass multiple values for the same key. MultiDict implements all standard dictionary methods. Internally, it saves all values for a key as a list, but the standard dict access methods will only return the first value for a key. If you want to gain access to the other values, too, you have to use the list methods as explained below. Basic Usage: >>> d = MultiDict([('a', 'b'), ('a', 'c')])\n>>> d\nMultiDict([('a', 'b'), ('a', 'c')])\n>>> d['a']\n'b'\n>>> d.getlist('a')\n['b', 'c']\n>>> 'a' in d\nTrue\n It behaves like a normal dict thus all dict functions will only return the first value when multiple values for one key are found. From Werkzeug 0.3 onwards, the KeyError raised by this class is also a subclass of the BadRequest HTTP exception and will render a page for a 400 BAD REQUEST if caught in a catch-all for HTTP exceptions. A MultiDict can be constructed from an iterable of (key, value) tuples, a dict, a MultiDict or from Werkzeug 0.2 onwards some keyword parameters.  Parameters \nmapping \u2013 the initial value for the MultiDict. Either a regular dict, an iterable of (key, value) tuples or None.    \nadd(key, value)  \nAdds a new value for the key.  Changelog New in version 0.6.   Parameters \n \nkey \u2013 the key for the value. \nvalue \u2013 the value to add.    \n  \nclear() \u2192 None. Remove all items from D. \n  \ncopy()  \nReturn a shallow copy of this object. \n  \ndeepcopy(memo=None)  \nReturn a deep copy of this object. \n  \nfromkeys(value=None, /)  \nCreate a new dictionary with keys from iterable and values set to value. \n  \nget(key, default=None, type=None)  \nReturn the default value if the requested data doesn\u2019t exist. If type is provided and is a callable it should convert the value, return it or raise a ValueError if that is not possible. In this case the function will return the default as if the value was not found: >>> d = TypeConversionDict(foo='42', bar='blub')\n>>> d.get('foo', type=int)\n42\n>>> d.get('bar', -1, type=int)\n-1\n  Parameters \n \nkey \u2013 The key to be looked up. \ndefault \u2013 The default value to be returned if the key can\u2019t be looked up. If not further specified None is returned. \ntype \u2013 A callable that is used to cast the value in the MultiDict. If a ValueError is raised by this callable the default value is returned.    \n  \ngetlist(key, type=None)  \nReturn the list of items for a given key. If that key is not in the MultiDict, the return value will be an empty list. Just like get, getlist accepts a type parameter. All items will be converted with the callable defined there.  Parameters \n \nkey \u2013 The key to be looked up. \ntype \u2013 A callable that is used to cast the value in the MultiDict. If a ValueError is raised by this callable the value will be removed from the list.   Returns \na list of all the values for the key.   \n  \nitems(multi=False)  \nReturn an iterator of (key, value) pairs.  Parameters \nmulti \u2013 If set to True the iterator returned will have a pair for each value of each key. Otherwise it will only contain pairs for the first value of each key.   \n  \nkeys() \u2192 a set-like object providing a view on D\u2019s keys \n  \nlists()  \nReturn a iterator of (key, values) pairs, where values is the list of all values associated with the key. \n  \nlistvalues()  \nReturn an iterator of all values associated with a key. Zipping keys() and this is the same as calling lists(): >>> d = MultiDict({\"foo\": [1, 2, 3]})\n>>> zip(d.keys(), d.listvalues()) == d.lists()\nTrue\n \n  \npop(key, default=no value)  \nPop the first item for a list on the dict. Afterwards the key is removed from the dict, so additional values are discarded: >>> d = MultiDict({\"foo\": [1, 2, 3]})\n>>> d.pop(\"foo\")\n1\n>>> \"foo\" in d\nFalse\n  Parameters \n \nkey \u2013 the key to pop. \ndefault \u2013 if provided the value to return if the key was not in the dictionary.    \n  \npopitem()  \nPop an item from the dict. \n  \npopitemlist()  \nPop a (key, list) tuple from the dict. \n  \npoplist(key)  \nPop the list for a key from the dict. If the key is not in the dict an empty list is returned.  Changelog Changed in version 0.5: If the key does no longer exist a list is returned instead of raising an error.  \n\n  \nsetdefault(key, default=None)  \nReturns the value for the key if it is in the dict, otherwise it returns default and sets that value for key.  Parameters \n \nkey \u2013 The key to be looked up. \ndefault \u2013 The default value to be returned if the key is not in the dict. If not further specified it\u2019s None.    \n  \nsetlist(key, new_list)  \nRemove the old values for a key and add new ones. Note that the list you pass the values in will be shallow-copied before it is inserted in the dictionary. >>> d = MultiDict()\n>>> d.setlist('foo', ['1', '2'])\n>>> d['foo']\n'1'\n>>> d.getlist('foo')\n['1', '2']\n  Parameters \n \nkey \u2013 The key for which the values are set. \nnew_list \u2013 An iterable with the new values for the key. Old values are removed first.    \n  \nsetlistdefault(key, default_list=None)  \nLike setdefault but sets multiple values. The list returned is not a copy, but the list that is actually used internally. This means that you can put new values into the dict by appending items to the list: >>> d = MultiDict({\"foo\": 1})\n>>> d.setlistdefault(\"foo\").extend([2, 3])\n>>> d.getlist(\"foo\")\n[1, 2, 3]\n  Parameters \n \nkey \u2013 The key to be looked up. \ndefault_list \u2013 An iterable of default values. It is either copied (in case it was a list) or converted into a list before returned.   Returns \na list   \n  \nto_dict(flat=True)  \nReturn the contents as regular dict. If flat is True the returned dict will only have the first item present, if flat is False all values will be returned as lists.  Parameters \nflat \u2013 If set to False the dict returned will have lists with all the values in it. Otherwise it will only contain the first value for each key.  Returns \na dict   \n  \nupdate(mapping)  \nupdate() extends rather than replaces existing key lists: >>> a = MultiDict({'x': 1})\n>>> b = MultiDict({'x': 2, 'y': 3})\n>>> a.update(b)\n>>> a\nMultiDict([('y', 3), ('x', 1), ('x', 2)])\n If the value list for a key in other_dict is empty, no new values will be added to the dict and the key will not be created: >>> x = {'empty_list': []}\n>>> y = MultiDict()\n>>> y.update(x)\n>>> y\nMultiDict([])\n \n  \nvalues()  \nReturns an iterator of the first value on every key\u2019s value list. \n \n  \nclass werkzeug.datastructures.OrderedMultiDict(mapping=None)  \nWorks like a regular MultiDict but preserves the order of the fields. To convert the ordered multi dict into a list you can use the items() method and pass it multi=True. In general an OrderedMultiDict is an order of magnitude slower than a MultiDict.  note Due to a limitation in Python you cannot convert an ordered multi dict into a regular dict by using dict(multidict). Instead you have to use the to_dict() method, otherwise the internal bucket objects are exposed.  \n  \nclass werkzeug.datastructures.ImmutableMultiDict(mapping=None)  \nAn immutable MultiDict.  Changelog New in version 0.5.   \ncopy()  \nReturn a shallow mutable copy of this object. Keep in mind that the standard library\u2019s copy() function is a no-op for this class like for any other python immutable type (eg: tuple). \n \n  \nclass werkzeug.datastructures.ImmutableOrderedMultiDict(mapping=None)  \nAn immutable OrderedMultiDict.  Changelog New in version 0.6.   \ncopy()  \nReturn a shallow mutable copy of this object. Keep in mind that the standard library\u2019s copy() function is a no-op for this class like for any other python immutable type (eg: tuple). \n \n  \nclass werkzeug.datastructures.CombinedMultiDict(dicts=None)  \nA read only MultiDict that you can pass multiple MultiDict instances as sequence and it will combine the return values of all wrapped dicts: >>> from werkzeug.datastructures import CombinedMultiDict, MultiDict\n>>> post = MultiDict([('foo', 'bar')])\n>>> get = MultiDict([('blub', 'blah')])\n>>> combined = CombinedMultiDict([get, post])\n>>> combined['foo']\n'bar'\n>>> combined['blub']\n'blah'\n This works for all read operations and will raise a TypeError for methods that usually change data which isn\u2019t possible. From Werkzeug 0.3 onwards, the KeyError raised by this class is also a subclass of the BadRequest HTTP exception and will render a page for a 400 BAD REQUEST if caught in a catch-all for HTTP exceptions. \n  \nclass werkzeug.datastructures.ImmutableDict  \nAn immutable dict.  Changelog New in version 0.5.   \ncopy()  \nReturn a shallow mutable copy of this object. Keep in mind that the standard library\u2019s copy() function is a no-op for this class like for any other python immutable type (eg: tuple). \n \n  \nclass werkzeug.datastructures.ImmutableList(iterable=(), /)  \nAn immutable list.  Changelog New in version 0.5.   Private  \n  \nclass werkzeug.datastructures.FileMultiDict(mapping=None)  \nA special MultiDict that has convenience methods to add files to it. This is used for EnvironBuilder and generally useful for unittesting.  Changelog New in version 0.5.   \nadd_file(name, file, filename=None, content_type=None)  \nAdds a new file to the dict. file can be a file name or a file-like or a FileStorage object.  Parameters \n \nname \u2013 the name of the field. \nfile \u2013 a filename or file-like object \nfilename \u2013 an optional filename \ncontent_type \u2013 an optional content type    \n \n   HTTP Related  \nclass werkzeug.datastructures.Headers([defaults])  \nAn object that stores some headers. It has a dict-like interface, but is ordered, can store the same key multiple times, and iterating yields (key, value) pairs instead of only keys. This data structure is useful if you want a nicer way to handle WSGI headers which are stored as tuples in a list. From Werkzeug 0.3 onwards, the KeyError raised by this class is also a subclass of the BadRequest HTTP exception and will render a page for a 400 BAD REQUEST if caught in a catch-all for HTTP exceptions. Headers is mostly compatible with the Python wsgiref.headers.Headers class, with the exception of __getitem__. wsgiref will return None for headers['missing'], whereas Headers will raise a KeyError. To create a new Headers object pass it a list or dict of headers which are used as default values. This does not reuse the list passed to the constructor for internal usage.  Parameters \ndefaults \u2013 The list of default values for the Headers.    Changelog Changed in version 0.9: This data structure now stores unicode values similar to how the multi dicts do it. The main difference is that bytes can be set as well which will automatically be latin1 decoded.   Changed in version 0.9: The linked() function was removed without replacement as it was an API that does not support the changes to the encoding model.   \nadd(_key, _value, **kw)  \nAdd a new header tuple to the list. Keyword arguments can specify additional parameters for the header value, with underscores converted to dashes: >>> d = Headers()\n>>> d.add('Content-Type', 'text/plain')\n>>> d.add('Content-Disposition', 'attachment', filename='foo.png')\n The keyword argument dumping uses dump_options_header() behind the scenes.  Changelog New in version 0.4.1: keyword arguments were added for wsgiref compatibility.  \n\n  \nadd_header(_key, _value, **_kw)  \nAdd a new header tuple to the list. An alias for add() for compatibility with the wsgiref add_header() method. \n  \nclear()  \nClears all headers. \n  \nextend(*args, **kwargs)  \nExtend headers in this object with items from another object containing header items as well as keyword arguments. To replace existing keys instead of extending, use update() instead. If provided, the first argument can be another Headers object, a MultiDict, dict, or iterable of pairs.  Changelog Changed in version 1.0: Support MultiDict. Allow passing kwargs.  \n\n  \nget(key, default=None, type=None, as_bytes=False)  \nReturn the default value if the requested data doesn\u2019t exist. If type is provided and is a callable it should convert the value, return it or raise a ValueError if that is not possible. In this case the function will return the default as if the value was not found: >>> d = Headers([('Content-Length', '42')])\n>>> d.get('Content-Length', type=int)\n42\n  Changelog New in version 0.9: Added support for as_bytes.   Parameters \n \nkey \u2013 The key to be looked up. \ndefault \u2013 The default value to be returned if the key can\u2019t be looked up. If not further specified None is returned. \ntype \u2013 A callable that is used to cast the value in the Headers. If a ValueError is raised by this callable the default value is returned. \nas_bytes \u2013 return bytes instead of strings.    \n  \nget_all(name)  \nReturn a list of all the values for the named field. This method is compatible with the wsgiref get_all() method. \n  \ngetlist(key, type=None, as_bytes=False)  \nReturn the list of items for a given key. If that key is not in the Headers, the return value will be an empty list. Just like get(), getlist() accepts a type parameter. All items will be converted with the callable defined there.  Changelog New in version 0.9: Added support for as_bytes.   Parameters \n \nkey \u2013 The key to be looked up. \ntype \u2013 A callable that is used to cast the value in the Headers. If a ValueError is raised by this callable the value will be removed from the list. \nas_bytes \u2013 return bytes instead of strings.   Returns \na list of all the values for the key.   \n  \nhas_key(key)  \n Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use key in data instead.  \n  \npop(key=None, default=no value)  \nRemoves and returns a key or index.  Parameters \nkey \u2013 The key to be popped. If this is an integer the item at that position is removed, if it\u2019s a string the value for that key is. If the key is omitted or None the last item is removed.  Returns \nan item.   \n  \npopitem()  \nRemoves a key or index and returns a (key, value) item. \n  \nremove(key)  \nRemove a key.  Parameters \nkey \u2013 The key to be removed.   \n  \nset(_key, _value, **kw)  \nRemove all header tuples for key and add a new one. The newly added key either appears at the end of the list if there was no entry or replaces the first one. Keyword arguments can specify additional parameters for the header value, with underscores converted to dashes. See add() for more information.  Changelog Changed in version 0.6.1: set() now accepts the same arguments as add().   Parameters \n \nkey \u2013 The key to be inserted. \nvalue \u2013 The value to be inserted.    \n  \nsetdefault(key, default)  \nReturn the first value for the key if it is in the headers, otherwise set the header to the value given by default and return that.  Parameters \n \nkey \u2013 The header key to get. \ndefault \u2013 The value to set for the key if it is not in the headers.    \n  \nsetlist(key, values)  \nRemove any existing values for a header and add new ones.  Parameters \n \nkey \u2013 The header key to set. \nvalues \u2013 An iterable of values to set for the key.     Changelog New in version 1.0.  \n\n  \nsetlistdefault(key, default)  \nReturn the list of values for the key if it is in the headers, otherwise set the header to the list of values given by default and return that. Unlike MultiDict.setlistdefault(), modifying the returned list will not affect the headers.  Parameters \n \nkey \u2013 The header key to get. \ndefault \u2013 An iterable of values to set for the key if it is not in the headers.     Changelog New in version 1.0.  \n\n  \nto_wsgi_list()  \nConvert the headers into a list suitable for WSGI.  Returns \nlist   \n  \nupdate(*args, **kwargs)  \nReplace headers in this object with items from another headers object and keyword arguments. To extend existing keys instead of replacing, use extend() instead. If provided, the first argument can be another Headers object, a MultiDict, dict, or iterable of pairs.  Changelog New in version 1.0.  \n\n \n  \nclass werkzeug.datastructures.EnvironHeaders(environ)  \nRead only version of the headers from a WSGI environment. This provides the same interface as Headers and is constructed from a WSGI environment. From Werkzeug 0.3 onwards, the KeyError raised by this class is also a subclass of the BadRequest HTTP exception and will render a page for a 400 BAD REQUEST if caught in a catch-all for HTTP exceptions. \n  \nclass werkzeug.datastructures.HeaderSet(headers=None, on_update=None)  \nSimilar to the ETags class this implements a set-like structure. Unlike ETags this is case insensitive and used for vary, allow, and content-language headers. If not constructed using the parse_set_header() function the instantiation works like this: >>> hs = HeaderSet(['foo', 'bar', 'baz'])\n>>> hs\nHeaderSet(['foo', 'bar', 'baz'])\n  \nadd(header)  \nAdd a new header to the set. \n  \nas_set(preserve_casing=False)  \nReturn the set as real python set type. When calling this, all the items are converted to lowercase and the ordering is lost.  Parameters \npreserve_casing \u2013 if set to True the items in the set returned will have the original case like in the HeaderSet, otherwise they will be lowercase.   \n  \nclear()  \nClear the set. \n  \ndiscard(header)  \nLike remove() but ignores errors.  Parameters \nheader \u2013 the header to be discarded.   \n  \nfind(header)  \nReturn the index of the header in the set or return -1 if not found.  Parameters \nheader \u2013 the header to be looked up.   \n  \nindex(header)  \nReturn the index of the header in the set or raise an IndexError.  Parameters \nheader \u2013 the header to be looked up.   \n  \nremove(header)  \nRemove a header from the set. This raises an KeyError if the header is not in the set.  Changelog Changed in version 0.5: In older versions a IndexError was raised instead of a KeyError if the object was missing.   Parameters \nheader \u2013 the header to be removed.   \n  \nto_header()  \nConvert the header set into an HTTP header string. \n  \nupdate(iterable)  \nAdd all the headers from the iterable to the set.  Parameters \niterable \u2013 updates the set with the items from the iterable.   \n \n  \nclass werkzeug.datastructures.Accept(values=())  \nAn Accept object is just a list subclass for lists of (value, quality) tuples. It is automatically sorted by specificity and quality. All Accept objects work similar to a list but provide extra functionality for working with the data. Containment checks are normalized to the rules of that header: >>> a = CharsetAccept([('ISO-8859-1', 1), ('utf-8', 0.7)])\n>>> a.best\n'ISO-8859-1'\n>>> 'iso-8859-1' in a\nTrue\n>>> 'UTF8' in a\nTrue\n>>> 'utf7' in a\nFalse\n To get the quality for an item you can use normal item lookup: >>> print a['utf-8']\n0.7\n>>> a['utf7']\n0\n  Changelog Changed in version 1.0.0: Accept internal values are no longer ordered alphabetically for equal quality tags. Instead the initial order is preserved.   Changed in version 0.5: Accept objects are forced immutable now.   \nproperty best  \nThe best match as value. \n  \nbest_match(matches, default=None)  \nReturns the best match from a list of possible matches based on the specificity and quality of the client. If two items have the same quality and specificity, the one is returned that comes first.  Parameters \n \nmatches \u2013 a list of matches to check for \ndefault \u2013 the value that is returned if none match    \n  \nfind(key)  \nGet the position of an entry or return -1.  Parameters \nkey \u2013 The key to be looked up.   \n  \nindex(key)  \nGet the position of an entry or raise ValueError.  Parameters \nkey \u2013 The key to be looked up.    Changelog Changed in version 0.5: This used to raise IndexError, which was inconsistent with the list API.  \n\n  \nquality(key)  \nReturns the quality of the key.  Changelog New in version 0.6: In previous versions you had to use the item-lookup syntax (eg: obj[key] instead of obj.quality(key))  \n\n  \nto_header()  \nConvert the header set into an HTTP header string. \n  \nvalues()  \nIterate over all values. \n \n  \nclass werkzeug.datastructures.MIMEAccept(values=())  \nLike Accept but with special methods and behavior for mimetypes.  \nproperty accept_html  \nTrue if this object accepts HTML. \n  \nproperty accept_json  \nTrue if this object accepts JSON. \n  \nproperty accept_xhtml  \nTrue if this object accepts XHTML. \n \n  \nclass werkzeug.datastructures.CharsetAccept(values=())  \nLike Accept but with normalization for charsets. \n  \nclass werkzeug.datastructures.LanguageAccept(values=())  \nLike Accept but with normalization for language tags. \n  \nclass werkzeug.datastructures.RequestCacheControl(values=(), on_update=None)  \nA cache control for requests. This is immutable and gives access to all the request-relevant cache control headers. To get a header of the RequestCacheControl object again you can convert the object into a string or call the to_header() method. If you plan to subclass it and add your own items have a look at the sourcecode for that class.  Changelog New in version 0.5: In previous versions a CacheControl class existed that was used both for request and response.   \nno_cache  \naccessor for \u2018no-cache\u2019 \n  \nno_store  \naccessor for \u2018no-store\u2019 \n  \nmax_age  \naccessor for \u2018max-age\u2019 \n  \nno_transform  \naccessor for \u2018no-transform\u2019 \n  \nproperty max_stale  \naccessor for \u2018max-stale\u2019 \n  \nproperty min_fresh  \naccessor for \u2018min-fresh\u2019 \n  \nproperty only_if_cached  \naccessor for \u2018only-if-cached\u2019 \n \n  \nclass werkzeug.datastructures.ResponseCacheControl(values=(), on_update=None)  \nA cache control for responses. Unlike RequestCacheControl this is mutable and gives access to response-relevant cache control headers. To get a header of the ResponseCacheControl object again you can convert the object into a string or call the to_header() method. If you plan to subclass it and add your own items have a look at the sourcecode for that class.  Changelog New in version 0.5: In previous versions a CacheControl class existed that was used both for request and response.   \nno_cache  \naccessor for \u2018no-cache\u2019 \n  \nno_store  \naccessor for \u2018no-store\u2019 \n  \nmax_age  \naccessor for \u2018max-age\u2019 \n  \nno_transform  \naccessor for \u2018no-transform\u2019 \n  \nproperty immutable  \naccessor for \u2018immutable\u2019 \n  \nproperty must_revalidate  \naccessor for \u2018must-revalidate\u2019 \n  \nproperty private  \naccessor for \u2018private\u2019 \n  \nproperty proxy_revalidate  \naccessor for \u2018proxy-revalidate\u2019 \n  \nproperty public  \naccessor for \u2018public\u2019 \n  \nproperty s_maxage  \naccessor for \u2018s-maxage\u2019 \n \n  \nclass werkzeug.datastructures.ETags(strong_etags=None, weak_etags=None, star_tag=False)  \nA set that can be used to check if one etag is present in a collection of etags.  \nas_set(include_weak=False)  \nConvert the ETags object into a python set. Per default all the weak etags are not part of this set. \n  \ncontains(etag)  \nCheck if an etag is part of the set ignoring weak tags. It is also possible to use the in operator. \n  \ncontains_raw(etag)  \nWhen passed a quoted tag it will check if this tag is part of the set. If the tag is weak it is checked against weak and strong tags, otherwise strong only. \n  \ncontains_weak(etag)  \nCheck if an etag is part of the set including weak and strong tags. \n  \nis_strong(etag)  \nCheck if an etag is strong. \n  \nis_weak(etag)  \nCheck if an etag is weak. \n  \nto_header()  \nConvert the etags set into a HTTP header string. \n \n  \nclass werkzeug.datastructures.Authorization(auth_type, data=None)  \nRepresents an Authorization header sent by the client. This is returned by parse_authorization_header(). It can be useful to create the object manually to pass to the test Client.  Changelog Changed in version 0.5: This object became immutable.   \nproperty cnonce  \nIf the server sent a qop-header in the WWW-Authenticate header, the client has to provide this value for HTTP digest auth. See the RFC for more details. \n  \nproperty nc  \nThe nonce count value transmitted by clients if a qop-header is also transmitted. HTTP digest auth only. \n  \nproperty nonce  \nThe nonce the server sent for digest auth, sent back by the client. A nonce should be unique for every 401 response for HTTP digest auth. \n  \nproperty opaque  \nThe opaque header from the server returned unchanged by the client. It is recommended that this string be base64 or hexadecimal data. Digest auth only. \n  \nproperty password  \nWhen the authentication type is basic this is the password transmitted by the client, else None. \n  \nproperty qop  \nIndicates what \u201cquality of protection\u201d the client has applied to the message for HTTP digest auth. Note that this is a single token, not a quoted list of alternatives as in WWW-Authenticate. \n  \nproperty realm  \nThis is the server realm sent back for HTTP digest auth. \n  \nproperty response  \nA string of 32 hex digits computed as defined in RFC 2617, which proves that the user knows a password. Digest auth only. \n  \nto_header()  \nConvert to a string value for an Authorization header.  New in version 2.0: Added to support passing authorization to the test client.  \n  \nproperty uri  \nThe URI from Request-URI of the Request-Line; duplicated because proxies are allowed to change the Request-Line in transit. HTTP digest auth only. \n  \nproperty username  \nThe username transmitted. This is set for both basic and digest auth all the time. \n \n  \nclass werkzeug.datastructures.WWWAuthenticate(auth_type=None, values=None, on_update=None)  \nProvides simple access to WWW-Authenticate headers.  \nproperty algorithm  \nA string indicating a pair of algorithms used to produce the digest and a checksum. If this is not present it is assumed to be \u201cMD5\u201d. If the algorithm is not understood, the challenge should be ignored (and a different one used, if there is more than one). \n  \nstatic auth_property(name, doc=None)  \nA static helper function for Authentication subclasses to add extra authentication system properties onto a class: class FooAuthenticate(WWWAuthenticate):\n    special_realm = auth_property('special_realm')\n For more information have a look at the sourcecode to see how the regular properties (realm etc.) are implemented. \n  \nproperty domain  \nA list of URIs that define the protection space. If a URI is an absolute path, it is relative to the canonical root URL of the server being accessed. \n  \nproperty nonce  \nA server-specified data string which should be uniquely generated each time a 401 response is made. It is recommended that this string be base64 or hexadecimal data. \n  \nproperty opaque  \nA string of data, specified by the server, which should be returned by the client unchanged in the Authorization header of subsequent requests with URIs in the same protection space. It is recommended that this string be base64 or hexadecimal data. \n  \nproperty qop  \nA set of quality-of-privacy directives such as auth and auth-int. \n  \nproperty realm  \nA string to be displayed to users so they know which username and password to use. This string should contain at least the name of the host performing the authentication and might additionally indicate the collection of users who might have access. \n  \nset_basic(realm='authentication required')  \nClear the auth info and enable basic auth. \n  \nset_digest(realm, nonce, qop=('auth'), opaque=None, algorithm=None, stale=False)  \nClear the auth info and enable digest auth. \n  \nproperty stale  \nA flag, indicating that the previous request from the client was rejected because the nonce value was stale. \n  \nto_header()  \nConvert the stored values into a WWW-Authenticate header. \n  \nproperty type  \nThe type of the auth mechanism. HTTP currently specifies Basic and Digest. \n \n  \nclass werkzeug.datastructures.IfRange(etag=None, date=None)  \nVery simple object that represents the If-Range header in parsed form. It will either have neither a etag or date or one of either but never both.  Changelog New in version 0.7.   \ndate  \nThe date in parsed format or None. \n  \netag  \nThe etag parsed and unquoted. Ranges always operate on strong etags so the weakness information is not necessary. \n  \nto_header()  \nConverts the object back into an HTTP header. \n \n  \nclass werkzeug.datastructures.Range(units, ranges)  \nRepresents a Range header. All methods only support only bytes as the unit. Stores a list of ranges if given, but the methods only work if only one range is provided.  Raises \nValueError \u2013 If the ranges provided are invalid.    Changelog Changed in version 0.15: The ranges passed in are validated.   New in version 0.7.   \nmake_content_range(length)  \nCreates a ContentRange object from the current range and given content length. \n  \nrange_for_length(length)  \nIf the range is for bytes, the length is not None and there is exactly one range and it is satisfiable it returns a (start, stop) tuple, otherwise None. \n  \nranges  \nA list of (begin, end) tuples for the range header provided. The ranges are non-inclusive. \n  \nto_content_range_header(length)  \nConverts the object into Content-Range HTTP header, based on given length \n  \nto_header()  \nConverts the object back into an HTTP header. \n  \nunits  \nThe units of this range. Usually \u201cbytes\u201d. \n \n  \nclass werkzeug.datastructures.ContentRange(units, start, stop, length=None, on_update=None)  \nRepresents the content range header.  Changelog New in version 0.7.   \nproperty length  \nThe length of the range or None. \n  \nset(start, stop, length=None, units='bytes')  \nSimple method to update the ranges. \n  \nproperty start  \nThe start point of the range or None. \n  \nproperty stop  \nThe stop point of the range (non-inclusive) or None. Can only be None if also start is None. \n  \nproperty units  \nThe units to use, usually \u201cbytes\u201d \n  \nunset()  \nSets the units to None which indicates that the header should no longer be used. \n \n   Others  \nclass werkzeug.datastructures.FileStorage(stream=None, filename=None, name=None, content_type=None, content_length=None, headers=None)  \nThe FileStorage class is a thin wrapper over incoming files. It is used by the request object to represent uploaded files. All the attributes of the wrapper stream are proxied by the file storage so it\u2019s possible to do storage.read() instead of the long form storage.stream.read().  \nstream  \nThe input stream for the uploaded file. This usually points to an open temporary file. \n  \nfilename  \nThe filename of the file on the client. \n  \nname  \nThe name of the form field. \n  \nheaders  \nThe multipart headers as Headers object. This usually contains irrelevant information but in combination with custom multipart requests the raw headers might be interesting.  Changelog New in version 0.6.  \n\n  \nclose()  \nClose the underlying file if possible. \n  \nproperty content_length  \nThe content-length sent in the header. Usually not available \n  \nproperty content_type  \nThe content-type sent in the header. Usually not available \n  \nproperty mimetype  \nLike content_type, but without parameters (eg, without charset, type etc.) and always lowercase. For example if the content type is text/HTML; charset=utf-8 the mimetype would be 'text/html'.  Changelog New in version 0.7.  \n\n  \nproperty mimetype_params  \nThe mimetype parameters as dict. For example if the content type is text/html; charset=utf-8 the params would be {'charset': 'utf-8'}.  Changelog New in version 0.7.  \n\n  \nsave(dst, buffer_size=16384)  \nSave the file to a destination path or file object. If the destination is a file object you have to close it yourself after the call. The buffer size is the number of bytes held in memory during the copy process. It defaults to 16KB. For secure file saving also have a look at secure_filename().  Parameters \n \ndst \u2013 a filename, os.PathLike, or open file object to write to. \nbuffer_size \u2013 Passed as the length parameter of shutil.copyfileobj().     Changelog Changed in version 1.0: Supports pathlib.  \n\n \n \n"}, {"name": "Dealing with Request Data", "path": "request_data/index", "type": "Other", "text": "Dealing with Request Data The most important rule about web development is \u201cDo not trust the user\u201d. This is especially true for incoming request data on the input stream. With WSGI this is actually a bit harder than you would expect. Because of that Werkzeug wraps the request stream for you to save you from the most prominent problems with it.  Missing EOF Marker on Input Stream The input stream has no end-of-file marker. If you would call the read() method on the wsgi.input stream you would cause your application to hang on conforming servers. This is actually intentional however painful. Werkzeug solves that problem by wrapping the input stream in a special LimitedStream. The input stream is exposed on the request objects as stream. This one is either an empty stream (if the form data was parsed) or a limited stream with the contents of the input stream.   When does Werkzeug Parse? Werkzeug parses the incoming data under the following situations:  you access either form, files, or stream and the request method was POST or PUT. if you call parse_form_data().  These calls are not interchangeable. If you invoke parse_form_data() you must not use the request object or at least not the attributes that trigger the parsing process. This is also true if you read from the wsgi.input stream before the parsing. General rule: Leave the WSGI input stream alone. Especially in WSGI middlewares. Use either the parsing functions or the request object. Do not mix multiple WSGI utility libraries for form data parsing or anything else that works on the input stream.   How does it Parse? The standard Werkzeug parsing behavior handles three cases:  input content type was multipart/form-data. In this situation the stream will be empty and form will contain the regular POST / PUT data, files will contain the uploaded files as FileStorage objects. input content type was application/x-www-form-urlencoded. Then the stream will be empty and form will contain the regular POST / PUT data and files will be empty. the input content type was neither of them, stream points to a LimitedStream with the input data for further processing.  Special note on the get_data method: Calling this loads the full request data into memory. This is only safe to do if the max_content_length is set. Also you can either read the stream or call get_data().   Limiting Request Data To avoid being the victim of a DDOS attack you can set the maximum accepted content length and request field sizes. The Request class has two attributes for that: max_content_length and max_form_memory_size. The first one can be used to limit the total content length. For example by setting it to 1024 * 1024 * 16 the request won\u2019t accept more than 16MB of transmitted data. Because certain data can\u2019t be moved to the hard disk (regular post data) whereas temporary files can, there is a second limit you can set. The max_form_memory_size limits the size of POST transmitted form data. By setting it to 1024 * 1024 * 2 you can make sure that all in memory-stored fields are not more than 2MB in size. This however does not affect in-memory stored files if the stream_factory used returns a in-memory file.   How to extend Parsing? Modern web applications transmit a lot more than multipart form data or url encoded data. To extend the capabilities, subclass Request or Request and add or extend methods. \n"}, {"name": "DebuggedApplication", "path": "debug/index#werkzeug.debug.DebuggedApplication", "type": "werkzeug.debug", "text": " \nclass werkzeug.debug.DebuggedApplication(app, evalex=False, request_key='werkzeug.request', console_path='/console', console_init_func=None, show_hidden_frames=False, pin_security=True, pin_logging=True)  \nEnables debugging support for a given application: from werkzeug.debug import DebuggedApplication\nfrom myapp import app\napp = DebuggedApplication(app, evalex=True)\n The evalex keyword argument allows evaluating expressions in a traceback\u2019s frame context.  Parameters \n \napp (WSGIApplication) \u2013 the WSGI application to run debugged. \nevalex (bool) \u2013 enable exception evaluation feature (interactive debugging). This requires a non-forking server. \nrequest_key (str) \u2013 The key that points to the request object in ths environment. This parameter is ignored in current versions. \nconsole_path (str) \u2013 the URL for a general purpose console. \nconsole_init_func (Optional[Callable[[], Dict[str, Any]]]) \u2013 the function that is executed before starting the general purpose console. The return value is used as initial namespace. \nshow_hidden_frames (bool) \u2013 by default hidden traceback frames are skipped. You can show them by setting this parameter to True. \npin_security (bool) \u2013 can be used to disable the pin based security system. \npin_logging (bool) \u2013 enables the logging of the pin system.   Return type \nNone   \n"}, {"name": "Debugging Applications", "path": "debug/index", "type": "Other", "text": "Debugging Applications Depending on the WSGI gateway/server, exceptions are handled differently. Most of the time, exceptions go to stderr or the error log, and a generic \u201c500 Internal Server Error\u201d message is displayed. Since this is not the best debugging environment, Werkzeug provides a WSGI middleware that renders nice tracebacks, optionally with an interactive debug console to execute code in any frame.  Danger The debugger allows the execution of arbitrary code which makes it a major security risk. The debugger must never be used on production machines. We cannot stress this enough. Do not enable the debugger in production.   Note The interactive debugger does not work in forking environments, such as a server that starts multiple processes. Most such environments are production servers, where the debugger should not be enabled anyway.   Enabling the Debugger Enable the debugger by wrapping the application with the DebuggedApplication middleware. Alternatively, you can pass use_debugger=True to run_simple() and it will do that for you.  \nclass werkzeug.debug.DebuggedApplication(app, evalex=False, request_key='werkzeug.request', console_path='/console', console_init_func=None, show_hidden_frames=False, pin_security=True, pin_logging=True)  \nEnables debugging support for a given application: from werkzeug.debug import DebuggedApplication\nfrom myapp import app\napp = DebuggedApplication(app, evalex=True)\n The evalex keyword argument allows evaluating expressions in a traceback\u2019s frame context.  Parameters \n \napp (WSGIApplication) \u2013 the WSGI application to run debugged. \nevalex (bool) \u2013 enable exception evaluation feature (interactive debugging). This requires a non-forking server. \nrequest_key (str) \u2013 The key that points to the request object in ths environment. This parameter is ignored in current versions. \nconsole_path (str) \u2013 the URL for a general purpose console. \nconsole_init_func (Optional[Callable[[], Dict[str, Any]]]) \u2013 the function that is executed before starting the general purpose console. The return value is used as initial namespace. \nshow_hidden_frames (bool) \u2013 by default hidden traceback frames are skipped. You can show them by setting this parameter to True. \npin_security (bool) \u2013 can be used to disable the pin based security system. \npin_logging (bool) \u2013 enables the logging of the pin system.   Return type \nNone   \n   Using the Debugger Once enabled and an error happens during a request you will see a detailed traceback instead of a generic \u201cinternal server error\u201d. The traceback is still output to the terminal as well. The error message is displayed at the top. Clicking it jumps to the bottom of the traceback. Frames that represent user code, as opposed to built-ins or installed packages, are highlighted blue. Clicking a frame will show more lines for context, clicking again will hide them. If you have the evalex feature enabled you can get a console for every frame in the traceback by hovering over a frame and clicking the console icon that appears at the right. Once clicked a console opens where you can execute Python code in:  Inside the interactive consoles you can execute any kind of Python code. Unlike regular Python consoles the output of the object reprs is colored and stripped to a reasonable size by default. If the output is longer than what the console decides to display a small plus sign is added to the repr and a click will expand the repr. To display all variables that are defined in the current frame you can use the dump() function. You can call it without arguments to get a detailed list of all variables and their values, or with an object as argument to get a detailed list of all the attributes it has.   Debugger PIN Starting with Werkzeug 0.11 the debug console is protected by a PIN. This is a security helper to make it less likely for the debugger to be exploited if you forget to disable it when deploying to production. The PIN based authentication is enabled by default. The first time a console is opened, a dialog will prompt for a PIN that is printed to the command line. The PIN is generated in a stable way that is specific to the project. An explicit PIN can be provided through the environment variable WERKZEUG_DEBUG_PIN. This can be set to a number and will become the PIN. This variable can also be set to the value off to disable the PIN check entirely. If an incorrect PIN is entered too many times the server needs to be restarted. This feature is not meant to entirely secure the debugger. It is intended to make it harder for an attacker to exploit the debugger. Never enable the debugger in production.   Pasting Errors If you click on the \u201cTraceback (most recent call last)\u201d header, the view switches to a traditional text-based traceback. You can copy and paste this in order to provide information when asking a question or reporting an issue. \n"}, {"name": "DispatcherMiddleware", "path": "middleware/dispatcher/index#werkzeug.middleware.dispatcher.DispatcherMiddleware", "type": "werkzeug.middleware.dispatcher", "text": " \nclass werkzeug.middleware.dispatcher.DispatcherMiddleware(app, mounts=None)  \nCombine multiple applications as a single WSGI application. Requests are dispatched to an application based on the path it is mounted under.  Parameters \n \napp (WSGIApplication) \u2013 The WSGI application to dispatch to if the request doesn\u2019t match a mounted path. \nmounts (Optional[Dict[str, WSGIApplication]]) \u2013 Maps path prefixes to applications for dispatching.   Return type \nNone   \n"}, {"name": "dump_cookie()", "path": "http/index#werkzeug.http.dump_cookie", "type": "werkzeug.http", "text": " \nwerkzeug.http.dump_cookie(key, value='', max_age=None, expires=None, path='/', domain=None, secure=False, httponly=False, charset='utf-8', sync_expires=True, max_size=4093, samesite=None)  \nCreate a Set-Cookie header without the Set-Cookie prefix. The return value is usually restricted to ascii as the vast majority of values are properly escaped, but that is no guarantee. It\u2019s tunneled through latin1 as required by PEP 3333. The return value is not ASCII safe if the key contains unicode characters. This is technically against the specification but happens in the wild. It\u2019s strongly recommended to not use non-ASCII values for the keys.  Parameters \n \nmax_age (Optional[Union[datetime.timedelta, int]]) \u2013 should be a number of seconds, or None (default) if the cookie should last only as long as the client\u2019s browser session. Additionally timedelta objects are accepted, too. \nexpires (Optional[Union[str, datetime.datetime, int, float]]) \u2013 should be a datetime object or unix timestamp. \npath (Optional[str]) \u2013 limits the cookie to a given path, per default it will span the whole domain. \ndomain (Optional[str]) \u2013 Use this if you want to set a cross-domain cookie. For example, domain=\".example.com\" will set a cookie that is readable by the domain www.example.com, foo.example.com etc. Otherwise, a cookie will only be readable by the domain that set it. \nsecure (bool) \u2013 The cookie will only be available via HTTPS \nhttponly (bool) \u2013 disallow JavaScript to access the cookie. This is an extension to the cookie standard and probably not supported by all browsers. \ncharset (str) \u2013 the encoding for string values. \nsync_expires (bool) \u2013 automatically set expires if max_age is defined but expires not. \nmax_size (int) \u2013 Warn if the final header value exceeds this size. The default, 4093, should be safely supported by most browsers. Set to 0 to disable this check. \nsamesite (Optional[str]) \u2013 Limits the scope of the cookie such that it will only be attached to requests if those requests are same-site. \nkey (str) \u2013  \nvalue (Union[bytes, str]) \u2013    Return type \nstr    Changelog Changed in version 1.0.0: The string 'None' is accepted for samesite.  \n\n"}, {"name": "dump_header()", "path": "http/index#werkzeug.http.dump_header", "type": "werkzeug.http", "text": " \nwerkzeug.http.dump_header(iterable, allow_token=True)  \nDump an HTTP header again. This is the reversal of parse_list_header(), parse_set_header() and parse_dict_header(). This also quotes strings that include an equals sign unless you pass it as dict of key, value pairs. >>> dump_header({'foo': 'bar baz'})\n'foo=\"bar baz\"'\n>>> dump_header(('foo', 'bar baz'))\n'foo, \"bar baz\"'\n  Parameters \n \niterable (Union[Dict[str, Union[str, int]], Iterable[str]]) \u2013 the iterable or dict of values to quote. \nallow_token (bool) \u2013 if set to False tokens as values are disallowed. See quote_header_value() for more details.   Return type \nstr   \n"}, {"name": "EndpointPrefix", "path": "routing/index#werkzeug.routing.EndpointPrefix", "type": "werkzeug.routing", "text": " \nclass werkzeug.routing.EndpointPrefix(prefix, rules)  \nPrefixes all endpoints (which must be strings for this factory) with another string. This can be useful for sub applications: url_map = Map([\n    Rule('/', endpoint='index'),\n    EndpointPrefix('blog/', [Submount('/blog', [\n        Rule('/', endpoint='index'),\n        Rule('/entry/<entry_slug>', endpoint='show')\n    ])])\n])\n  Parameters \n \nprefix (str) \u2013  \nrules (Iterable[Rule]) \u2013    Return type \nNone   \n"}, {"name": "EnvironBuilder", "path": "test/index#werkzeug.test.EnvironBuilder", "type": "werkzeug.test", "text": " \nclass werkzeug.test.EnvironBuilder(path='/', base_url=None, query_string=None, method='GET', input_stream=None, content_type=None, content_length=None, errors_stream=None, multithread=False, multiprocess=False, run_once=False, headers=None, data=None, environ_base=None, environ_overrides=None, charset='utf-8', mimetype=None, json=None, auth=None)  \nThis class can be used to conveniently create a WSGI environment for testing purposes. It can be used to quickly create WSGI environments or request objects from arbitrary data. The signature of this class is also used in some other places as of Werkzeug 0.5 (create_environ(), Response.from_values(), Client.open()). Because of this most of the functionality is available through the constructor alone. Files and regular form data can be manipulated independently of each other with the form and files attributes, but are passed with the same argument to the constructor: data. data can be any of these values:  a str or bytes object: The object is converted into an input_stream, the content_length is set and you have to provide a content_type. \na dict or MultiDict: The keys have to be strings. The values have to be either any of the following objects, or a list of any of the following objects:  a file-like object: These are converted into FileStorage objects automatically. a tuple: The add_file() method is called with the key and the unpacked tuple items as positional arguments. a str: The string is set as form data for the associated key.   a file-like object: The object content is loaded in memory and then handled like a regular str or a bytes.   Parameters \n \npath (str) \u2013 the path of the request. In the WSGI environment this will end up as PATH_INFO. If the query_string is not defined and there is a question mark in the path everything after it is used as query string. \nbase_url (Optional[str]) \u2013 the base URL is a URL that is used to extract the WSGI URL scheme, host (server name + server port) and the script root (SCRIPT_NAME). \nquery_string (Optional[Union[Mapping[str, str], str]]) \u2013 an optional string or dict with URL parameters. \nmethod (str) \u2013 the HTTP method to use, defaults to GET. \ninput_stream (Optional[BinaryIO]) \u2013 an optional input stream. Do not specify this and data. As soon as an input stream is set you can\u2019t modify args and files unless you set the input_stream to None again. \ncontent_type (Optional[str]) \u2013 The content type for the request. As of 0.5 you don\u2019t have to provide this when specifying files and form data via data. \ncontent_length (Optional[int]) \u2013 The content length for the request. You don\u2019t have to specify this when providing data via data. \nerrors_stream (Optional[TextIO]) \u2013 an optional error stream that is used for wsgi.errors. Defaults to stderr. \nmultithread (bool) \u2013 controls wsgi.multithread. Defaults to False. \nmultiprocess (bool) \u2013 controls wsgi.multiprocess. Defaults to False. \nrun_once (bool) \u2013 controls wsgi.run_once. Defaults to False. \nheaders (Optional[Union[werkzeug.datastructures.Headers, Iterable[Tuple[str, str]]]]) \u2013 an optional list or Headers object of headers. \ndata (Optional[Union[BinaryIO, str, bytes, Mapping[str, Any]]]) \u2013 a string or dict of form data or a file-object. See explanation above. \njson (Optional[Mapping[str, Any]]) \u2013 An object to be serialized and assigned to data. Defaults the content type to \"application/json\". Serialized with the function assigned to json_dumps. \nenviron_base (Optional[Mapping[str, Any]]) \u2013 an optional dict of environment defaults. \nenviron_overrides (Optional[Mapping[str, Any]]) \u2013 an optional dict of environment overrides. \ncharset (str) \u2013 the charset used to encode string data. \nauth (Optional[Union[werkzeug.datastructures.Authorization, Tuple[str, str]]]) \u2013 An authorization object to use for the Authorization header value. A (username, password) tuple is a shortcut for Basic authorization. \nmimetype (Optional[str]) \u2013    Return type \nNone    Changed in version 2.0: REQUEST_URI and RAW_URI is the full raw URI including the query string, not only the path.   Changed in version 2.0: The default request_class is Request instead of BaseRequest.   New in version 2.0: Added the auth parameter.   Changelog New in version 0.15: The json param and json_dumps() method.   New in version 0.15: The environ has keys REQUEST_URI and RAW_URI containing the path before perecent-decoding. This is not part of the WSGI PEP, but many WSGI servers include it.   Changed in version 0.6: path and base_url can now be unicode strings that are encoded with iri_to_uri().   \nserver_protocol = 'HTTP/1.1'  \nthe server protocol to use. defaults to HTTP/1.1 \n  \nwsgi_version = (1, 0)  \nthe wsgi version to use. defaults to (1, 0) \n  \nrequest_class  \nalias of werkzeug.wrappers.request.Request \n  \nstatic json_dumps(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)  \nThe serialization function used when json is passed. \n  \nclassmethod from_environ(environ, **kwargs)  \nTurn an environ dict back into a builder. Any extra kwargs override the args extracted from the environ.  Changed in version 2.0: Path and query values are passed through the WSGI decoding dance to avoid double encoding.   Changelog New in version 0.15.   Parameters \n \nenviron (WSGIEnvironment) \u2013  \nkwargs (Any) \u2013    Return type \nEnvironBuilder   \n  \nproperty base_url: str  \nThe base URL is used to extract the URL scheme, host name, port, and root path. \n  \nproperty content_type: Optional[str]  \nThe content type for the request. Reflected from and to the headers. Do not set if you set files or form for auto detection. \n  \nproperty mimetype: Optional[str]  \nThe mimetype (content type without charset etc.)  Changelog New in version 0.14.  \n\n  \nproperty mimetype_params: Mapping[str, str]  \nThe mimetype parameters as dict. For example if the content type is text/html; charset=utf-8 the params would be {'charset': 'utf-8'}.  Changelog New in version 0.14.  \n\n  \nproperty content_length: Optional[int]  \nThe content length as integer. Reflected from and to the headers. Do not set if you set files or form for auto detection. \n  \nproperty form: werkzeug.datastructures.MultiDict  \nA MultiDict of form values. \n  \nproperty files: werkzeug.datastructures.FileMultiDict  \nA FileMultiDict of uploaded files. Use add_file() to add new files. \n  \nproperty input_stream: Optional[BinaryIO]  \nAn optional input stream. This is mutually exclusive with setting form and files, setting it will clear those. Do not provide this if the method is not POST or another method that has a body. \n  \nproperty query_string: str  \nThe query string. If you set this to a string args will no longer be available. \n  \nproperty args: werkzeug.datastructures.MultiDict  \nThe URL arguments as MultiDict. \n  \nproperty server_name: str  \nThe server name (read-only, use host to set) \n  \nproperty server_port: int  \nThe server port as integer (read-only, use host to set) \n  \nclose()  \nCloses all files. If you put real file objects into the files dict you can call this method to automatically close them all in one go.  Return type \nNone   \n  \nget_environ()  \nReturn the built environ.  Changelog Changed in version 0.15: The content type and length headers are set based on input stream detection. Previously this only set the WSGI keys.   Return type \nWSGIEnvironment   \n  \nget_request(cls=None)  \nReturns a request with the data. If the request class is not specified request_class is used.  Parameters \ncls (Optional[Type[werkzeug.wrappers.request.Request]]) \u2013 The request wrapper to use.  Return type \nwerkzeug.wrappers.request.Request   \n \n"}, {"name": "EnvironBuilder.close()", "path": "test/index#werkzeug.test.EnvironBuilder.close", "type": "werkzeug.test", "text": " \nclose()  \nCloses all files. If you put real file objects into the files dict you can call this method to automatically close them all in one go.  Return type \nNone   \n"}, {"name": "EnvironBuilder.from_environ()", "path": "test/index#werkzeug.test.EnvironBuilder.from_environ", "type": "werkzeug.test", "text": " \nclassmethod from_environ(environ, **kwargs)  \nTurn an environ dict back into a builder. Any extra kwargs override the args extracted from the environ.  Changed in version 2.0: Path and query values are passed through the WSGI decoding dance to avoid double encoding.   Changelog New in version 0.15.   Parameters \n \nenviron (WSGIEnvironment) \u2013  \nkwargs (Any) \u2013    Return type \nEnvironBuilder   \n"}, {"name": "EnvironBuilder.get_environ()", "path": "test/index#werkzeug.test.EnvironBuilder.get_environ", "type": "werkzeug.test", "text": " \nget_environ()  \nReturn the built environ.  Changelog Changed in version 0.15: The content type and length headers are set based on input stream detection. Previously this only set the WSGI keys.   Return type \nWSGIEnvironment   \n"}, {"name": "EnvironBuilder.get_request()", "path": "test/index#werkzeug.test.EnvironBuilder.get_request", "type": "werkzeug.test", "text": " \nget_request(cls=None)  \nReturns a request with the data. If the request class is not specified request_class is used.  Parameters \ncls (Optional[Type[werkzeug.wrappers.request.Request]]) \u2013 The request wrapper to use.  Return type \nwerkzeug.wrappers.request.Request   \n"}, {"name": "EnvironBuilder.json_dumps()", "path": "test/index#werkzeug.test.EnvironBuilder.json_dumps", "type": "werkzeug.test", "text": " \nstatic json_dumps(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)  \nThe serialization function used when json is passed. \n"}, {"name": "EnvironBuilder.request_class", "path": "test/index#werkzeug.test.EnvironBuilder.request_class", "type": "werkzeug.test", "text": " \nrequest_class  \nalias of werkzeug.wrappers.request.Request \n"}, {"name": "EnvironBuilder.server_protocol", "path": "test/index#werkzeug.test.EnvironBuilder.server_protocol", "type": "werkzeug.test", "text": " \nserver_protocol = 'HTTP/1.1'  \nthe server protocol to use. defaults to HTTP/1.1 \n"}, {"name": "EnvironBuilder.wsgi_version", "path": "test/index#werkzeug.test.EnvironBuilder.wsgi_version", "type": "werkzeug.test", "text": " \nwsgi_version = (1, 0)  \nthe wsgi version to use. defaults to (1, 0) \n"}, {"name": "EnvironHeaders", "path": "datastructures/index#werkzeug.datastructures.EnvironHeaders", "type": "werkzeug.datastructures", "text": " \nclass werkzeug.datastructures.EnvironHeaders(environ)  \nRead only version of the headers from a WSGI environment. This provides the same interface as Headers and is constructed from a WSGI environment. From Werkzeug 0.3 onwards, the KeyError raised by this class is also a subclass of the BadRequest HTTP exception and will render a page for a 400 BAD REQUEST if caught in a catch-all for HTTP exceptions. \n"}, {"name": "environ_property", "path": "utils/index#werkzeug.utils.environ_property", "type": "werkzeug.utils", "text": " \nclass werkzeug.utils.environ_property(name, default=None, load_func=None, dump_func=None, read_only=None, doc=None)  \nMaps request attributes to environment variables. This works not only for the Werkzeug request object, but also any other class with an environ attribute: >>> class Test(object):\n...     environ = {'key': 'value'}\n...     test = environ_property('key')\n>>> var = Test()\n>>> var.test\n'value'\n If you pass it a second value it\u2019s used as default if the key does not exist, the third one can be a converter that takes a value and converts it. If it raises ValueError or TypeError the default value is used. If no default value is provided None is used. Per default the property is read only. You have to explicitly enable it by passing read_only=False to the constructor. \n"}, {"name": "escape()", "path": "utils/index#werkzeug.utils.escape", "type": "werkzeug.utils", "text": " \nwerkzeug.utils.escape(s)  \nReplace &, <, >, \", and ' with HTML-safe sequences. None is escaped to an empty string.  Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use MarkupSafe instead.   Parameters \ns (Any) \u2013   Return type \nstr   \n"}, {"name": "ETags", "path": "datastructures/index#werkzeug.datastructures.ETags", "type": "werkzeug.datastructures", "text": " \nclass werkzeug.datastructures.ETags(strong_etags=None, weak_etags=None, star_tag=False)  \nA set that can be used to check if one etag is present in a collection of etags.  \nas_set(include_weak=False)  \nConvert the ETags object into a python set. Per default all the weak etags are not part of this set. \n  \ncontains(etag)  \nCheck if an etag is part of the set ignoring weak tags. It is also possible to use the in operator. \n  \ncontains_raw(etag)  \nWhen passed a quoted tag it will check if this tag is part of the set. If the tag is weak it is checked against weak and strong tags, otherwise strong only. \n  \ncontains_weak(etag)  \nCheck if an etag is part of the set including weak and strong tags. \n  \nis_strong(etag)  \nCheck if an etag is strong. \n  \nis_weak(etag)  \nCheck if an etag is weak. \n  \nto_header()  \nConvert the etags set into a HTTP header string. \n \n"}, {"name": "ETags.as_set()", "path": "datastructures/index#werkzeug.datastructures.ETags.as_set", "type": "werkzeug.datastructures", "text": " \nas_set(include_weak=False)  \nConvert the ETags object into a python set. Per default all the weak etags are not part of this set. \n"}, {"name": "ETags.contains()", "path": "datastructures/index#werkzeug.datastructures.ETags.contains", "type": "werkzeug.datastructures", "text": " \ncontains(etag)  \nCheck if an etag is part of the set ignoring weak tags. It is also possible to use the in operator. \n"}, {"name": "ETags.contains_raw()", "path": "datastructures/index#werkzeug.datastructures.ETags.contains_raw", "type": "werkzeug.datastructures", "text": " \ncontains_raw(etag)  \nWhen passed a quoted tag it will check if this tag is part of the set. If the tag is weak it is checked against weak and strong tags, otherwise strong only. \n"}, {"name": "ETags.contains_weak()", "path": "datastructures/index#werkzeug.datastructures.ETags.contains_weak", "type": "werkzeug.datastructures", "text": " \ncontains_weak(etag)  \nCheck if an etag is part of the set including weak and strong tags. \n"}, {"name": "ETags.is_strong()", "path": "datastructures/index#werkzeug.datastructures.ETags.is_strong", "type": "werkzeug.datastructures", "text": " \nis_strong(etag)  \nCheck if an etag is strong. \n"}, {"name": "ETags.is_weak()", "path": "datastructures/index#werkzeug.datastructures.ETags.is_weak", "type": "werkzeug.datastructures", "text": " \nis_weak(etag)  \nCheck if an etag is weak. \n"}, {"name": "ETags.to_header()", "path": "datastructures/index#werkzeug.datastructures.ETags.to_header", "type": "werkzeug.datastructures", "text": " \nto_header()  \nConvert the etags set into a HTTP header string. \n"}, {"name": "extract_path_info()", "path": "wsgi/index#werkzeug.wsgi.extract_path_info", "type": "werkzeug.wsgi", "text": " \nwerkzeug.wsgi.extract_path_info(environ_or_baseurl, path_or_url, charset='utf-8', errors='werkzeug.url_quote', collapse_http_schemes=True)  \nExtracts the path info from the given URL (or WSGI environment) and path. The path info returned is a string. The URLs might also be IRIs. If the path info could not be determined, None is returned. Some examples: >>> extract_path_info('http://example.com/app', '/app/hello')\n'/hello'\n>>> extract_path_info('http://example.com/app',\n...                   'https://example.com/app/hello')\n'/hello'\n>>> extract_path_info('http://example.com/app',\n...                   'https://example.com/app/hello',\n...                   collapse_http_schemes=False) is None\nTrue\n Instead of providing a base URL you can also pass a WSGI environment.  Parameters \n \nenviron_or_baseurl (Union[str, WSGIEnvironment]) \u2013 a WSGI environment dict, a base URL or base IRI. This is the root of the application. \npath_or_url (Union[str, werkzeug.urls._URLTuple]) \u2013 an absolute path from the server root, a relative path (in which case it\u2019s the path info) or a full URL. \ncharset (str) \u2013 the charset for byte data in URLs \nerrors (str) \u2013 the error handling on decode \ncollapse_http_schemes (bool) \u2013 if set to False the algorithm does not assume that http and https on the same server point to the same resource.   Return type \nOptional[str]    Changelog Changed in version 0.15: The errors parameter defaults to leaving invalid bytes quoted instead of replacing them.   New in version 0.6.  \n\n"}, {"name": "FastCGI", "path": "deployment/fastcgi/index", "type": "Other", "text": "FastCGI A very popular deployment setup on servers like lighttpd and nginx is FastCGI. To use your WSGI application with any of them you will need a FastCGI server first. The most popular one is flup which we will use for this guide. Make sure to have it installed.  Creating a .fcgi file First you need to create the FastCGI server file. Let\u2019s call it yourapplication.fcgi: #!/usr/bin/python\nfrom flup.server.fcgi import WSGIServer\nfrom yourapplication import make_app\n\nif __name__ == '__main__':\n    application = make_app()\n    WSGIServer(application).run()\n This is enough for Apache to work, however ngingx and older versions of lighttpd need a socket to be explicitly passed to communicate with the FastCGI server. For that to work you need to pass the path to the socket to the WSGIServer: WSGIServer(application, bindAddress='/path/to/fcgi.sock').run()\n The path has to be the exact same path you define in the server config. Save the yourapplication.fcgi file somewhere you will find it again. It makes sense to have that in /var/www/yourapplication or something similar. Make sure to set the executable bit on that file so that the servers can execute it: # chmod +x /var/www/yourapplication/yourapplication.fcgi\n   Configuring lighttpd A basic FastCGI configuration for lighttpd looks like this: fastcgi.server = (\"/yourapplication.fcgi\" =>\n    ((\n        \"socket\" => \"/tmp/yourapplication-fcgi.sock\",\n        \"bin-path\" => \"/var/www/yourapplication/yourapplication.fcgi\",\n        \"check-local\" => \"disable\",\n        \"max-procs\" -> 1\n    ))\n)\n\nalias.url = (\n    \"/static/\" => \"/path/to/your/static\"\n)\n\nurl.rewrite-once = (\n    \"^(/static.*)$\" => \"$1\",\n    \"^(/.*)$\" => \"/yourapplication.fcgi$1\"\n Remember to enable the FastCGI, alias and rewrite modules. This configuration binds the application to /yourapplication. See the Lighty docs for more information on FastCGI and Python.   Configuring nginx Installing FastCGI applications on nginx is a bit tricky because by default some FastCGI parameters are not properly forwarded. A basic FastCGI configuration for nginx looks like this: location /yourapplication/ {\n    include fastcgi_params;\n    if ($uri ~ ^/yourapplication/(.*)?) {\n        set $path_url $1;\n    }\n    fastcgi_param PATH_INFO $path_url;\n    fastcgi_param SCRIPT_NAME /yourapplication;\n    fastcgi_pass unix:/tmp/yourapplication-fcgi.sock;\n}\n This configuration binds the application to /yourapplication. If you want to have it in the URL root it\u2019s a bit easier because you don\u2019t have to figure out how to calculate PATH_INFO and SCRIPT_NAME: location /yourapplication/ {\n    include fastcgi_params;\n    fastcgi_param PATH_INFO $fastcgi_script_name;\n    fastcgi_param SCRIPT_NAME \"\";\n    fastcgi_pass unix:/tmp/yourapplication-fcgi.sock;\n}\n Since Nginx doesn\u2019t load FastCGI apps, you have to do it by yourself. You can either write an init.d script for that or execute it inside a screen session: $ screen\n$ /var/www/yourapplication/yourapplication.fcgi\n   Debugging FastCGI deployments tend to be hard to debug on most webservers. Very often the only thing the server log tells you is something along the lines of \u201cpremature end of headers\u201d. In order to debug the application the only thing that can really give you ideas why it breaks is switching to the correct user and executing the application by hand. This example assumes your application is called application.fcgi and that your webserver user is www-data: $ su www-data\n$ cd /var/www/yourapplication\n$ python application.fcgi\nTraceback (most recent call last):\n  File \"yourapplication.fcg\", line 4, in <module>\nImportError: No module named yourapplication\n In this case the error seems to be \u201cyourapplication\u201d not being on the python path. Common problems are:  relative paths being used. Don\u2019t rely on the current working directory the code depending on environment variables that are not set by the web server. different python interpreters being used.  \n"}, {"name": "FileMultiDict", "path": "datastructures/index#werkzeug.datastructures.FileMultiDict", "type": "werkzeug.datastructures", "text": " \nclass werkzeug.datastructures.FileMultiDict(mapping=None)  \nA special MultiDict that has convenience methods to add files to it. This is used for EnvironBuilder and generally useful for unittesting.  Changelog New in version 0.5.   \nadd_file(name, file, filename=None, content_type=None)  \nAdds a new file to the dict. file can be a file name or a file-like or a FileStorage object.  Parameters \n \nname \u2013 the name of the field. \nfile \u2013 a filename or file-like object \nfilename \u2013 an optional filename \ncontent_type \u2013 an optional content type    \n \n"}, {"name": "FileMultiDict.add_file()", "path": "datastructures/index#werkzeug.datastructures.FileMultiDict.add_file", "type": "werkzeug.datastructures", "text": " \nadd_file(name, file, filename=None, content_type=None)  \nAdds a new file to the dict. file can be a file name or a file-like or a FileStorage object.  Parameters \n \nname \u2013 the name of the field. \nfile \u2013 a filename or file-like object \nfilename \u2013 an optional filename \ncontent_type \u2013 an optional content type    \n"}, {"name": "FileStorage", "path": "datastructures/index#werkzeug.datastructures.FileStorage", "type": "werkzeug.datastructures", "text": " \nclass werkzeug.datastructures.FileStorage(stream=None, filename=None, name=None, content_type=None, content_length=None, headers=None)  \nThe FileStorage class is a thin wrapper over incoming files. It is used by the request object to represent uploaded files. All the attributes of the wrapper stream are proxied by the file storage so it\u2019s possible to do storage.read() instead of the long form storage.stream.read().  \nstream  \nThe input stream for the uploaded file. This usually points to an open temporary file. \n  \nfilename  \nThe filename of the file on the client. \n  \nname  \nThe name of the form field. \n  \nheaders  \nThe multipart headers as Headers object. This usually contains irrelevant information but in combination with custom multipart requests the raw headers might be interesting.  Changelog New in version 0.6.  \n\n  \nclose()  \nClose the underlying file if possible. \n  \nproperty content_length  \nThe content-length sent in the header. Usually not available \n  \nproperty content_type  \nThe content-type sent in the header. Usually not available \n  \nproperty mimetype  \nLike content_type, but without parameters (eg, without charset, type etc.) and always lowercase. For example if the content type is text/HTML; charset=utf-8 the mimetype would be 'text/html'.  Changelog New in version 0.7.  \n\n  \nproperty mimetype_params  \nThe mimetype parameters as dict. For example if the content type is text/html; charset=utf-8 the params would be {'charset': 'utf-8'}.  Changelog New in version 0.7.  \n\n  \nsave(dst, buffer_size=16384)  \nSave the file to a destination path or file object. If the destination is a file object you have to close it yourself after the call. The buffer size is the number of bytes held in memory during the copy process. It defaults to 16KB. For secure file saving also have a look at secure_filename().  Parameters \n \ndst \u2013 a filename, os.PathLike, or open file object to write to. \nbuffer_size \u2013 Passed as the length parameter of shutil.copyfileobj().     Changelog Changed in version 1.0: Supports pathlib.  \n\n \n"}, {"name": "FileStorage.close()", "path": "datastructures/index#werkzeug.datastructures.FileStorage.close", "type": "werkzeug.datastructures", "text": " \nclose()  \nClose the underlying file if possible. \n"}, {"name": "FileStorage.filename", "path": "datastructures/index#werkzeug.datastructures.FileStorage.filename", "type": "werkzeug.datastructures", "text": " \nfilename  \nThe filename of the file on the client. \n"}, {"name": "FileStorage.headers", "path": "datastructures/index#werkzeug.datastructures.FileStorage.headers", "type": "werkzeug.datastructures", "text": " \nheaders  \nThe multipart headers as Headers object. This usually contains irrelevant information but in combination with custom multipart requests the raw headers might be interesting.  Changelog New in version 0.6.  \n\n"}, {"name": "FileStorage.name", "path": "datastructures/index#werkzeug.datastructures.FileStorage.name", "type": "werkzeug.datastructures", "text": " \nname  \nThe name of the form field. \n"}, {"name": "FileStorage.save()", "path": "datastructures/index#werkzeug.datastructures.FileStorage.save", "type": "werkzeug.datastructures", "text": " \nsave(dst, buffer_size=16384)  \nSave the file to a destination path or file object. If the destination is a file object you have to close it yourself after the call. The buffer size is the number of bytes held in memory during the copy process. It defaults to 16KB. For secure file saving also have a look at secure_filename().  Parameters \n \ndst \u2013 a filename, os.PathLike, or open file object to write to. \nbuffer_size \u2013 Passed as the length parameter of shutil.copyfileobj().     Changelog Changed in version 1.0: Supports pathlib.  \n\n"}, {"name": "FileStorage.stream", "path": "datastructures/index#werkzeug.datastructures.FileStorage.stream", "type": "werkzeug.datastructures", "text": " \nstream  \nThe input stream for the uploaded file. This usually points to an open temporary file. \n"}, {"name": "Filesystem Utilities", "path": "filesystem/index", "type": "Other", "text": "Filesystem Utilities Various utilities for the local filesystem.  \nclass werkzeug.filesystem.BrokenFilesystemWarning  \nThe warning used by Werkzeug to signal a broken filesystem. Will only be used once per runtime. \n  \nwerkzeug.filesystem.get_filesystem_encoding()  \nReturns the filesystem encoding that should be used. Note that this is different from the Python understanding of the filesystem encoding which might be deeply flawed. Do not use this value against Python\u2019s string APIs because it might be different. See The Filesystem for the exact behavior. The concept of a filesystem encoding in generally is not something you should rely on. As such if you ever need to use this function except for writing wrapper code reconsider.  Return type \nstr   \n\n"}, {"name": "FileWrapper", "path": "wsgi/index#werkzeug.wsgi.FileWrapper", "type": "werkzeug.wsgi", "text": " \nclass werkzeug.wsgi.FileWrapper(file, buffer_size=8192)  \nThis class can be used to convert a file-like object into an iterable. It yields buffer_size blocks until the file is fully read. You should not use this class directly but rather use the wrap_file() function that uses the WSGI server\u2019s file wrapper support if it\u2019s available.  Changelog New in version 0.5.  If you\u2019re using this object together with a Response you have to use the direct_passthrough mode.  Parameters \n \nfile (BinaryIO) \u2013 a file-like object with a read() method. \nbuffer_size (int) \u2013 number of bytes for one iteration.   Return type \nNone   \n"}, {"name": "find_modules()", "path": "utils/index#werkzeug.utils.find_modules", "type": "werkzeug.utils", "text": " \nwerkzeug.utils.find_modules(import_path, include_packages=False, recursive=False)  \nFinds all the modules below a package. This can be useful to automatically import all views / controllers so that their metaclasses / function decorators have a chance to register themselves on the application. Packages are not returned unless include_packages is True. This can also recursively list modules but in that case it will import all the packages to get the correct load path of that module.  Parameters \n \nimport_path (str) \u2013 the dotted name for the package to find child modules. \ninclude_packages (bool) \u2013 set to True if packages should be returned, too. \nrecursive (bool) \u2013 set to True if recursion should happen.   Returns \ngenerator  Return type \nIterator[str]   \n"}, {"name": "FloatConverter", "path": "routing/index#werkzeug.routing.FloatConverter", "type": "werkzeug.routing", "text": " \nclass werkzeug.routing.FloatConverter(map, min=None, max=None, signed=False)  \nThis converter only accepts floating point values: Rule(\"/probability/<float:probability>\")\n By default it only accepts unsigned, positive values. The signed parameter will enable signed, negative values. Rule(\"/offset/<float(signed=True):offset>\")\n  Parameters \n \nmap (Map) \u2013 The Map. \nmin (Optional[float]) \u2013 The minimal value. \nmax (Optional[float]) \u2013 The maximal value. \nsigned (bool) \u2013 Allow signed (negative) values.   Return type \nNone    Changelog New in version 0.15: The signed parameter.  \n\n"}, {"name": "FormDataParser", "path": "http/index#werkzeug.formparser.FormDataParser", "type": "werkzeug.formparser", "text": " \nclass werkzeug.formparser.FormDataParser(stream_factory=None, charset='utf-8', errors='replace', max_form_memory_size=None, max_content_length=None, cls=None, silent=True)  \nThis class implements parsing of form data for Werkzeug. By itself it can parse multipart and url encoded form data. It can be subclassed and extended but for most mimetypes it is a better idea to use the untouched stream and expose it as separate attributes on a request object.  Changelog New in version 0.8.   Parameters \n \nstream_factory (Optional[TStreamFactory]) \u2013 An optional callable that returns a new read and writeable file descriptor. This callable works the same as Response._get_file_stream(). \ncharset (str) \u2013 The character set for URL and url encoded form data. \nerrors (str) \u2013 The encoding error behavior. \nmax_form_memory_size (Optional[int]) \u2013 the maximum number of bytes to be accepted for in-memory stored form data. If the data exceeds the value specified an RequestEntityTooLarge exception is raised. \nmax_content_length (Optional[int]) \u2013 If this is provided and the transmitted data is longer than this value an RequestEntityTooLarge exception is raised. \ncls (Optional[Type[werkzeug.datastructures.MultiDict]]) \u2013 an optional dict class to use. If this is not specified or None the default MultiDict is used. \nsilent (bool) \u2013 If set to False parsing errors will not be caught.   Return type \nNone   \n"}, {"name": "generate_etag()", "path": "http/index#werkzeug.http.generate_etag", "type": "werkzeug.http", "text": " \nwerkzeug.http.generate_etag(data)  \nGenerate an etag for some data.  Changed in version 2.0: Use SHA-1. MD5 may not be available in some environments.   Parameters \ndata (bytes) \u2013   Return type \nstr   \n"}, {"name": "generate_password_hash()", "path": "utils/index#werkzeug.security.generate_password_hash", "type": "werkzeug.security", "text": " \nwerkzeug.security.generate_password_hash(password, method='pbkdf2:sha256', salt_length=16)  \nHash a password with the given method and salt with a string of the given length. The format of the string returned includes the method that was used so that check_password_hash() can check the hash. The format for the hashed string looks like this: method$salt$hash\n This method can not generate unsalted passwords but it is possible to set param method=\u2019plain\u2019 in order to enforce plaintext passwords. If a salt is used, hmac is used internally to salt the password. If PBKDF2 is wanted it can be enabled by setting the method to pbkdf2:method:iterations where iterations is optional: pbkdf2:sha256:80000$salt$hash\npbkdf2:sha256$salt$hash\n  Parameters \n \npassword (str) \u2013 the password to hash. \nmethod (str) \u2013 the hash method to use (one that hashlib supports). Can optionally be in the format pbkdf2:method:iterations to enable PBKDF2. \nsalt_length (int) \u2013 the length of the salt in letters.   Return type \nstr   \n"}, {"name": "get_content_length()", "path": "wsgi/index#werkzeug.wsgi.get_content_length", "type": "werkzeug.wsgi", "text": " \nwerkzeug.wsgi.get_content_length(environ)  \nReturns the content length from the WSGI environment as integer. If it\u2019s not available or chunked transfer encoding is used, None is returned.  Changelog New in version 0.9.   Parameters \nenviron (WSGIEnvironment) \u2013 the WSGI environ to fetch the content length from.  Return type \nOptional[int]   \n"}, {"name": "get_current_url()", "path": "wsgi/index#werkzeug.wsgi.get_current_url", "type": "werkzeug.wsgi", "text": " \nwerkzeug.wsgi.get_current_url(environ, root_only=False, strip_querystring=False, host_only=False, trusted_hosts=None)  \nRecreate the URL for a request from the parts in a WSGI environment. The URL is an IRI, not a URI, so it may contain Unicode characters. Use iri_to_uri() to convert it to ASCII.  Parameters \n \nenviron (WSGIEnvironment) \u2013 The WSGI environment to get the URL parts from. \nroot_only (bool) \u2013 Only build the root path, don\u2019t include the remaining path or query string. \nstrip_querystring (bool) \u2013 Don\u2019t include the query string. \nhost_only (bool) \u2013 Only build the scheme and host. \ntrusted_hosts (Optional[Iterable[str]]) \u2013 A list of trusted host names to validate the host against.   Return type \nstr   \n"}, {"name": "get_filesystem_encoding()", "path": "filesystem/index#werkzeug.filesystem.get_filesystem_encoding", "type": "werkzeug.filesystem", "text": " \nwerkzeug.filesystem.get_filesystem_encoding()  \nReturns the filesystem encoding that should be used. Note that this is different from the Python understanding of the filesystem encoding which might be deeply flawed. Do not use this value against Python\u2019s string APIs because it might be different. See The Filesystem for the exact behavior. The concept of a filesystem encoding in generally is not something you should rely on. As such if you ever need to use this function except for writing wrapper code reconsider.  Return type \nstr   \n"}, {"name": "get_host()", "path": "wsgi/index#werkzeug.wsgi.get_host", "type": "werkzeug.wsgi", "text": " \nwerkzeug.wsgi.get_host(environ, trusted_hosts=None)  \nReturn the host for the given WSGI environment. The Host header is preferred, then SERVER_NAME if it\u2019s not set. The returned host will only contain the port if it is different than the standard port for the protocol. Optionally, verify that the host is trusted using host_is_trusted() and raise a SecurityError if it is not.  Parameters \n \nenviron (WSGIEnvironment) \u2013 A WSGI environment dict. \ntrusted_hosts (Optional[Iterable[str]]) \u2013 A list of trusted host names.   Returns \nHost, with port if necessary.  Raises \nSecurityError \u2013 If the host is not trusted.  Return type \nstr   \n"}, {"name": "get_input_stream()", "path": "wsgi/index#werkzeug.wsgi.get_input_stream", "type": "werkzeug.wsgi", "text": " \nwerkzeug.wsgi.get_input_stream(environ, safe_fallback=True)  \nReturns the input stream from the WSGI environment and wraps it in the most sensible way possible. The stream returned is not the raw WSGI stream in most cases but one that is safe to read from without taking into account the content length. If content length is not set, the stream will be empty for safety reasons. If the WSGI server supports chunked or infinite streams, it should set the wsgi.input_terminated value in the WSGI environ to indicate that.  Changelog New in version 0.9.   Parameters \n \nenviron (WSGIEnvironment) \u2013 the WSGI environ to fetch the stream from. \nsafe_fallback (bool) \u2013 use an empty stream as a safe fallback when the content length is not set. Disabling this allows infinite streams, which can be a denial-of-service risk.   Return type \nBinaryIO   \n"}, {"name": "get_path_info()", "path": "wsgi/index#werkzeug.wsgi.get_path_info", "type": "werkzeug.wsgi", "text": " \nwerkzeug.wsgi.get_path_info(environ, charset='utf-8', errors='replace')  \nReturn the PATH_INFO from the WSGI environment and decode it unless charset is None.  Parameters \n \nenviron (WSGIEnvironment) \u2013 WSGI environment to get the path from. \ncharset (str) \u2013 The charset for the path info, or None if no decoding should be performed. \nerrors (str) \u2013 The decoding error handling.   Return type \nstr    Changelog New in version 0.9.  \n\n"}, {"name": "get_query_string()", "path": "wsgi/index#werkzeug.wsgi.get_query_string", "type": "werkzeug.wsgi", "text": " \nwerkzeug.wsgi.get_query_string(environ)  \nReturns the QUERY_STRING from the WSGI environment. This also takes care of the WSGI decoding dance. The string returned will be restricted to ASCII characters.  Parameters \nenviron (WSGIEnvironment) \u2013 WSGI environment to get the query string from.  Return type \nstr    Changelog New in version 0.9.  \n\n"}, {"name": "get_script_name()", "path": "wsgi/index#werkzeug.wsgi.get_script_name", "type": "werkzeug.wsgi", "text": " \nwerkzeug.wsgi.get_script_name(environ, charset='utf-8', errors='replace')  \nReturn the SCRIPT_NAME from the WSGI environment and decode it unless charset is set to None.  Parameters \n \nenviron (WSGIEnvironment) \u2013 WSGI environment to get the path from. \ncharset (str) \u2013 The charset for the path, or None if no decoding should be performed. \nerrors (str) \u2013 The decoding error handling.   Return type \nstr    Changelog New in version 0.9.  \n\n"}, {"name": "Headers", "path": "datastructures/index#werkzeug.datastructures.Headers", "type": "werkzeug.datastructures", "text": " \nclass werkzeug.datastructures.Headers([defaults])  \nAn object that stores some headers. It has a dict-like interface, but is ordered, can store the same key multiple times, and iterating yields (key, value) pairs instead of only keys. This data structure is useful if you want a nicer way to handle WSGI headers which are stored as tuples in a list. From Werkzeug 0.3 onwards, the KeyError raised by this class is also a subclass of the BadRequest HTTP exception and will render a page for a 400 BAD REQUEST if caught in a catch-all for HTTP exceptions. Headers is mostly compatible with the Python wsgiref.headers.Headers class, with the exception of __getitem__. wsgiref will return None for headers['missing'], whereas Headers will raise a KeyError. To create a new Headers object pass it a list or dict of headers which are used as default values. This does not reuse the list passed to the constructor for internal usage.  Parameters \ndefaults \u2013 The list of default values for the Headers.    Changelog Changed in version 0.9: This data structure now stores unicode values similar to how the multi dicts do it. The main difference is that bytes can be set as well which will automatically be latin1 decoded.   Changed in version 0.9: The linked() function was removed without replacement as it was an API that does not support the changes to the encoding model.   \nadd(_key, _value, **kw)  \nAdd a new header tuple to the list. Keyword arguments can specify additional parameters for the header value, with underscores converted to dashes: >>> d = Headers()\n>>> d.add('Content-Type', 'text/plain')\n>>> d.add('Content-Disposition', 'attachment', filename='foo.png')\n The keyword argument dumping uses dump_options_header() behind the scenes.  Changelog New in version 0.4.1: keyword arguments were added for wsgiref compatibility.  \n\n  \nadd_header(_key, _value, **_kw)  \nAdd a new header tuple to the list. An alias for add() for compatibility with the wsgiref add_header() method. \n  \nclear()  \nClears all headers. \n  \nextend(*args, **kwargs)  \nExtend headers in this object with items from another object containing header items as well as keyword arguments. To replace existing keys instead of extending, use update() instead. If provided, the first argument can be another Headers object, a MultiDict, dict, or iterable of pairs.  Changelog Changed in version 1.0: Support MultiDict. Allow passing kwargs.  \n\n  \nget(key, default=None, type=None, as_bytes=False)  \nReturn the default value if the requested data doesn\u2019t exist. If type is provided and is a callable it should convert the value, return it or raise a ValueError if that is not possible. In this case the function will return the default as if the value was not found: >>> d = Headers([('Content-Length', '42')])\n>>> d.get('Content-Length', type=int)\n42\n  Changelog New in version 0.9: Added support for as_bytes.   Parameters \n \nkey \u2013 The key to be looked up. \ndefault \u2013 The default value to be returned if the key can\u2019t be looked up. If not further specified None is returned. \ntype \u2013 A callable that is used to cast the value in the Headers. If a ValueError is raised by this callable the default value is returned. \nas_bytes \u2013 return bytes instead of strings.    \n  \nget_all(name)  \nReturn a list of all the values for the named field. This method is compatible with the wsgiref get_all() method. \n  \ngetlist(key, type=None, as_bytes=False)  \nReturn the list of items for a given key. If that key is not in the Headers, the return value will be an empty list. Just like get(), getlist() accepts a type parameter. All items will be converted with the callable defined there.  Changelog New in version 0.9: Added support for as_bytes.   Parameters \n \nkey \u2013 The key to be looked up. \ntype \u2013 A callable that is used to cast the value in the Headers. If a ValueError is raised by this callable the value will be removed from the list. \nas_bytes \u2013 return bytes instead of strings.   Returns \na list of all the values for the key.   \n  \nhas_key(key)  \n Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use key in data instead.  \n  \npop(key=None, default=no value)  \nRemoves and returns a key or index.  Parameters \nkey \u2013 The key to be popped. If this is an integer the item at that position is removed, if it\u2019s a string the value for that key is. If the key is omitted or None the last item is removed.  Returns \nan item.   \n  \npopitem()  \nRemoves a key or index and returns a (key, value) item. \n  \nremove(key)  \nRemove a key.  Parameters \nkey \u2013 The key to be removed.   \n  \nset(_key, _value, **kw)  \nRemove all header tuples for key and add a new one. The newly added key either appears at the end of the list if there was no entry or replaces the first one. Keyword arguments can specify additional parameters for the header value, with underscores converted to dashes. See add() for more information.  Changelog Changed in version 0.6.1: set() now accepts the same arguments as add().   Parameters \n \nkey \u2013 The key to be inserted. \nvalue \u2013 The value to be inserted.    \n  \nsetdefault(key, default)  \nReturn the first value for the key if it is in the headers, otherwise set the header to the value given by default and return that.  Parameters \n \nkey \u2013 The header key to get. \ndefault \u2013 The value to set for the key if it is not in the headers.    \n  \nsetlist(key, values)  \nRemove any existing values for a header and add new ones.  Parameters \n \nkey \u2013 The header key to set. \nvalues \u2013 An iterable of values to set for the key.     Changelog New in version 1.0.  \n\n  \nsetlistdefault(key, default)  \nReturn the list of values for the key if it is in the headers, otherwise set the header to the list of values given by default and return that. Unlike MultiDict.setlistdefault(), modifying the returned list will not affect the headers.  Parameters \n \nkey \u2013 The header key to get. \ndefault \u2013 An iterable of values to set for the key if it is not in the headers.     Changelog New in version 1.0.  \n\n  \nto_wsgi_list()  \nConvert the headers into a list suitable for WSGI.  Returns \nlist   \n  \nupdate(*args, **kwargs)  \nReplace headers in this object with items from another headers object and keyword arguments. To extend existing keys instead of replacing, use extend() instead. If provided, the first argument can be another Headers object, a MultiDict, dict, or iterable of pairs.  Changelog New in version 1.0.  \n\n \n"}, {"name": "Headers.add()", "path": "datastructures/index#werkzeug.datastructures.Headers.add", "type": "werkzeug.datastructures", "text": " \nadd(_key, _value, **kw)  \nAdd a new header tuple to the list. Keyword arguments can specify additional parameters for the header value, with underscores converted to dashes: >>> d = Headers()\n>>> d.add('Content-Type', 'text/plain')\n>>> d.add('Content-Disposition', 'attachment', filename='foo.png')\n The keyword argument dumping uses dump_options_header() behind the scenes.  Changelog New in version 0.4.1: keyword arguments were added for wsgiref compatibility.  \n\n"}, {"name": "Headers.add_header()", "path": "datastructures/index#werkzeug.datastructures.Headers.add_header", "type": "werkzeug.datastructures", "text": " \nadd_header(_key, _value, **_kw)  \nAdd a new header tuple to the list. An alias for add() for compatibility with the wsgiref add_header() method. \n"}, {"name": "Headers.clear()", "path": "datastructures/index#werkzeug.datastructures.Headers.clear", "type": "werkzeug.datastructures", "text": " \nclear()  \nClears all headers. \n"}, {"name": "Headers.extend()", "path": "datastructures/index#werkzeug.datastructures.Headers.extend", "type": "werkzeug.datastructures", "text": " \nextend(*args, **kwargs)  \nExtend headers in this object with items from another object containing header items as well as keyword arguments. To replace existing keys instead of extending, use update() instead. If provided, the first argument can be another Headers object, a MultiDict, dict, or iterable of pairs.  Changelog Changed in version 1.0: Support MultiDict. Allow passing kwargs.  \n\n"}, {"name": "Headers.get()", "path": "datastructures/index#werkzeug.datastructures.Headers.get", "type": "werkzeug.datastructures", "text": " \nget(key, default=None, type=None, as_bytes=False)  \nReturn the default value if the requested data doesn\u2019t exist. If type is provided and is a callable it should convert the value, return it or raise a ValueError if that is not possible. In this case the function will return the default as if the value was not found: >>> d = Headers([('Content-Length', '42')])\n>>> d.get('Content-Length', type=int)\n42\n  Changelog New in version 0.9: Added support for as_bytes.   Parameters \n \nkey \u2013 The key to be looked up. \ndefault \u2013 The default value to be returned if the key can\u2019t be looked up. If not further specified None is returned. \ntype \u2013 A callable that is used to cast the value in the Headers. If a ValueError is raised by this callable the default value is returned. \nas_bytes \u2013 return bytes instead of strings.    \n"}, {"name": "Headers.getlist()", "path": "datastructures/index#werkzeug.datastructures.Headers.getlist", "type": "werkzeug.datastructures", "text": " \ngetlist(key, type=None, as_bytes=False)  \nReturn the list of items for a given key. If that key is not in the Headers, the return value will be an empty list. Just like get(), getlist() accepts a type parameter. All items will be converted with the callable defined there.  Changelog New in version 0.9: Added support for as_bytes.   Parameters \n \nkey \u2013 The key to be looked up. \ntype \u2013 A callable that is used to cast the value in the Headers. If a ValueError is raised by this callable the value will be removed from the list. \nas_bytes \u2013 return bytes instead of strings.   Returns \na list of all the values for the key.   \n"}, {"name": "Headers.get_all()", "path": "datastructures/index#werkzeug.datastructures.Headers.get_all", "type": "werkzeug.datastructures", "text": " \nget_all(name)  \nReturn a list of all the values for the named field. This method is compatible with the wsgiref get_all() method. \n"}, {"name": "Headers.has_key()", "path": "datastructures/index#werkzeug.datastructures.Headers.has_key", "type": "werkzeug.datastructures", "text": " \nhas_key(key)  \n Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use key in data instead.  \n"}, {"name": "Headers.pop()", "path": "datastructures/index#werkzeug.datastructures.Headers.pop", "type": "werkzeug.datastructures", "text": " \npop(key=None, default=no value)  \nRemoves and returns a key or index.  Parameters \nkey \u2013 The key to be popped. If this is an integer the item at that position is removed, if it\u2019s a string the value for that key is. If the key is omitted or None the last item is removed.  Returns \nan item.   \n"}, {"name": "Headers.popitem()", "path": "datastructures/index#werkzeug.datastructures.Headers.popitem", "type": "werkzeug.datastructures", "text": " \npopitem()  \nRemoves a key or index and returns a (key, value) item. \n"}, {"name": "Headers.remove()", "path": "datastructures/index#werkzeug.datastructures.Headers.remove", "type": "werkzeug.datastructures", "text": " \nremove(key)  \nRemove a key.  Parameters \nkey \u2013 The key to be removed.   \n"}, {"name": "Headers.set()", "path": "datastructures/index#werkzeug.datastructures.Headers.set", "type": "werkzeug.datastructures", "text": " \nset(_key, _value, **kw)  \nRemove all header tuples for key and add a new one. The newly added key either appears at the end of the list if there was no entry or replaces the first one. Keyword arguments can specify additional parameters for the header value, with underscores converted to dashes. See add() for more information.  Changelog Changed in version 0.6.1: set() now accepts the same arguments as add().   Parameters \n \nkey \u2013 The key to be inserted. \nvalue \u2013 The value to be inserted.    \n"}, {"name": "Headers.setdefault()", "path": "datastructures/index#werkzeug.datastructures.Headers.setdefault", "type": "werkzeug.datastructures", "text": " \nsetdefault(key, default)  \nReturn the first value for the key if it is in the headers, otherwise set the header to the value given by default and return that.  Parameters \n \nkey \u2013 The header key to get. \ndefault \u2013 The value to set for the key if it is not in the headers.    \n"}, {"name": "Headers.setlist()", "path": "datastructures/index#werkzeug.datastructures.Headers.setlist", "type": "werkzeug.datastructures", "text": " \nsetlist(key, values)  \nRemove any existing values for a header and add new ones.  Parameters \n \nkey \u2013 The header key to set. \nvalues \u2013 An iterable of values to set for the key.     Changelog New in version 1.0.  \n\n"}, {"name": "Headers.setlistdefault()", "path": "datastructures/index#werkzeug.datastructures.Headers.setlistdefault", "type": "werkzeug.datastructures", "text": " \nsetlistdefault(key, default)  \nReturn the list of values for the key if it is in the headers, otherwise set the header to the list of values given by default and return that. Unlike MultiDict.setlistdefault(), modifying the returned list will not affect the headers.  Parameters \n \nkey \u2013 The header key to get. \ndefault \u2013 An iterable of values to set for the key if it is not in the headers.     Changelog New in version 1.0.  \n\n"}, {"name": "Headers.to_wsgi_list()", "path": "datastructures/index#werkzeug.datastructures.Headers.to_wsgi_list", "type": "werkzeug.datastructures", "text": " \nto_wsgi_list()  \nConvert the headers into a list suitable for WSGI.  Returns \nlist   \n"}, {"name": "Headers.update()", "path": "datastructures/index#werkzeug.datastructures.Headers.update", "type": "werkzeug.datastructures", "text": " \nupdate(*args, **kwargs)  \nReplace headers in this object with items from another headers object and keyword arguments. To extend existing keys instead of replacing, use extend() instead. If provided, the first argument can be another Headers object, a MultiDict, dict, or iterable of pairs.  Changelog New in version 1.0.  \n\n"}, {"name": "HeaderSet", "path": "datastructures/index#werkzeug.datastructures.HeaderSet", "type": "werkzeug.datastructures", "text": " \nclass werkzeug.datastructures.HeaderSet(headers=None, on_update=None)  \nSimilar to the ETags class this implements a set-like structure. Unlike ETags this is case insensitive and used for vary, allow, and content-language headers. If not constructed using the parse_set_header() function the instantiation works like this: >>> hs = HeaderSet(['foo', 'bar', 'baz'])\n>>> hs\nHeaderSet(['foo', 'bar', 'baz'])\n  \nadd(header)  \nAdd a new header to the set. \n  \nas_set(preserve_casing=False)  \nReturn the set as real python set type. When calling this, all the items are converted to lowercase and the ordering is lost.  Parameters \npreserve_casing \u2013 if set to True the items in the set returned will have the original case like in the HeaderSet, otherwise they will be lowercase.   \n  \nclear()  \nClear the set. \n  \ndiscard(header)  \nLike remove() but ignores errors.  Parameters \nheader \u2013 the header to be discarded.   \n  \nfind(header)  \nReturn the index of the header in the set or return -1 if not found.  Parameters \nheader \u2013 the header to be looked up.   \n  \nindex(header)  \nReturn the index of the header in the set or raise an IndexError.  Parameters \nheader \u2013 the header to be looked up.   \n  \nremove(header)  \nRemove a header from the set. This raises an KeyError if the header is not in the set.  Changelog Changed in version 0.5: In older versions a IndexError was raised instead of a KeyError if the object was missing.   Parameters \nheader \u2013 the header to be removed.   \n  \nto_header()  \nConvert the header set into an HTTP header string. \n  \nupdate(iterable)  \nAdd all the headers from the iterable to the set.  Parameters \niterable \u2013 updates the set with the items from the iterable.   \n \n"}, {"name": "HeaderSet.add()", "path": "datastructures/index#werkzeug.datastructures.HeaderSet.add", "type": "werkzeug.datastructures", "text": " \nadd(header)  \nAdd a new header to the set. \n"}, {"name": "HeaderSet.as_set()", "path": "datastructures/index#werkzeug.datastructures.HeaderSet.as_set", "type": "werkzeug.datastructures", "text": " \nas_set(preserve_casing=False)  \nReturn the set as real python set type. When calling this, all the items are converted to lowercase and the ordering is lost.  Parameters \npreserve_casing \u2013 if set to True the items in the set returned will have the original case like in the HeaderSet, otherwise they will be lowercase.   \n"}, {"name": "HeaderSet.clear()", "path": "datastructures/index#werkzeug.datastructures.HeaderSet.clear", "type": "werkzeug.datastructures", "text": " \nclear()  \nClear the set. \n"}, {"name": "HeaderSet.discard()", "path": "datastructures/index#werkzeug.datastructures.HeaderSet.discard", "type": "werkzeug.datastructures", "text": " \ndiscard(header)  \nLike remove() but ignores errors.  Parameters \nheader \u2013 the header to be discarded.   \n"}, {"name": "HeaderSet.find()", "path": "datastructures/index#werkzeug.datastructures.HeaderSet.find", "type": "werkzeug.datastructures", "text": " \nfind(header)  \nReturn the index of the header in the set or return -1 if not found.  Parameters \nheader \u2013 the header to be looked up.   \n"}, {"name": "HeaderSet.index()", "path": "datastructures/index#werkzeug.datastructures.HeaderSet.index", "type": "werkzeug.datastructures", "text": " \nindex(header)  \nReturn the index of the header in the set or raise an IndexError.  Parameters \nheader \u2013 the header to be looked up.   \n"}, {"name": "HeaderSet.remove()", "path": "datastructures/index#werkzeug.datastructures.HeaderSet.remove", "type": "werkzeug.datastructures", "text": " \nremove(header)  \nRemove a header from the set. This raises an KeyError if the header is not in the set.  Changelog Changed in version 0.5: In older versions a IndexError was raised instead of a KeyError if the object was missing.   Parameters \nheader \u2013 the header to be removed.   \n"}, {"name": "HeaderSet.to_header()", "path": "datastructures/index#werkzeug.datastructures.HeaderSet.to_header", "type": "werkzeug.datastructures", "text": " \nto_header()  \nConvert the header set into an HTTP header string. \n"}, {"name": "HeaderSet.update()", "path": "datastructures/index#werkzeug.datastructures.HeaderSet.update", "type": "werkzeug.datastructures", "text": " \nupdate(iterable)  \nAdd all the headers from the iterable to the set.  Parameters \niterable \u2013 updates the set with the items from the iterable.   \n"}, {"name": "header_property", "path": "utils/index#werkzeug.utils.header_property", "type": "werkzeug.utils", "text": " \nclass werkzeug.utils.header_property(name, default=None, load_func=None, dump_func=None, read_only=None, doc=None)  \nLike environ_property but for headers. \n"}, {"name": "host_is_trusted()", "path": "wsgi/index#werkzeug.wsgi.host_is_trusted", "type": "werkzeug.wsgi", "text": " \nwerkzeug.wsgi.host_is_trusted(hostname, trusted_list)  \nCheck if a host matches a list of trusted names.  Parameters \n \nhostname (str) \u2013 The name to check. \ntrusted_list (Iterable[str]) \u2013 A list of valid names to match. If a name starts with a dot it will match all subdomains.   Return type \nbool    Changelog New in version 0.9.  \n\n"}, {"name": "Href", "path": "urls/index#werkzeug.urls.Href", "type": "werkzeug.urls", "text": " \nclass werkzeug.urls.Href(base='./', charset='utf-8', sort=False, key=None)  \nImplements a callable that constructs URLs with the given base. The function can be called with any number of positional and keyword arguments which than are used to assemble the URL. Works with URLs and posix paths. Positional arguments are appended as individual segments to the path of the URL: >>> href = Href('/foo')\n>>> href('bar', 23)\n'/foo/bar/23'\n>>> href('foo', bar=23)\n'/foo/foo?bar=23'\n If any of the arguments (positional or keyword) evaluates to None it will be skipped. If no keyword arguments are given the last argument can be a dict or MultiDict (or any other dict subclass), otherwise the keyword arguments are used for the query parameters, cutting off the first trailing underscore of the parameter name: >>> href(is_=42)\n'/foo?is=42'\n>>> href({'foo': 'bar'})\n'/foo?foo=bar'\n Combining of both methods is not allowed: >>> href({'foo': 'bar'}, bar=42)\nTraceback (most recent call last):\n  ...\nTypeError: keyword arguments and query-dicts can't be combined\n Accessing attributes on the href object creates a new href object with the attribute name as prefix: >>> bar_href = href.bar\n>>> bar_href(\"blub\")\n'/foo/bar/blub'\n If sort is set to True the items are sorted by key or the default sorting algorithm: >>> href = Href(\"/\", sort=True)\n>>> href(a=1, b=2, c=3)\n'/?a=1&b=2&c=3'\n  Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use werkzeug.routing instead.   Changelog New in version 0.5: sort and key were added.  \n\n"}, {"name": "HTMLBuilder", "path": "utils/index#werkzeug.utils.HTMLBuilder", "type": "werkzeug.utils", "text": " \nclass werkzeug.utils.HTMLBuilder(dialect)  \nHelper object for HTML generation. Per default there are two instances of that class. The html one, and the xhtml one for those two dialects. The class uses keyword parameters and positional parameters to generate small snippets of HTML. Keyword parameters are converted to XML/SGML attributes, positional arguments are used as children. Because Python accepts positional arguments before keyword arguments it\u2019s a good idea to use a list with the star-syntax for some children: >>> html.p(class_='foo', *[html.a('foo', href='foo.html'), ' ',\n...                        html.a('bar', href='bar.html')])\n'<p class=\"foo\"><a href=\"foo.html\">foo</a> <a href=\"bar.html\">bar</a></p>'\n This class works around some browser limitations and can not be used for arbitrary SGML/XML generation. For that purpose lxml and similar libraries exist. Calling the builder escapes the string passed: >>> html.p(html(\"<foo>\"))\n'<p>&lt;foo&gt;</p>'\n  Deprecated since version 2.0: Will be removed in Werkzeug 2.1.  \n"}, {"name": "HTTP Exceptions", "path": "exceptions/index", "type": "Other", "text": "HTTP Exceptions Implements a number of Python exceptions which can be raised from within a view to trigger a standard HTTP non-200 response.  Usage Example from werkzeug.wrappers.request import Request\nfrom werkzeug.exceptions import HTTPException, NotFound\n\ndef view(request):\n    raise NotFound()\n\n@Request.application\ndef application(request):\n    try:\n        return view(request)\n    except HTTPException as e:\n        return e\n As you can see from this example those exceptions are callable WSGI applications. However, they are not Werkzeug response objects. You can get a response object by calling get_response() on a HTTP exception. Keep in mind that you may have to pass an environ (WSGI) or scope (ASGI) to get_response() because some errors fetch additional information relating to the request. If you want to hook in a different exception page to say, a 404 status code, you can add a second except for a specific subclass of an error: @Request.application\ndef application(request):\n    try:\n        return view(request)\n    except NotFound as e:\n        return not_found(request)\n    except HTTPException as e:\n        return e\n   Error Classes The following error classes exist in Werkzeug:  \nexception werkzeug.exceptions.BadRequest(description=None, response=None)  \n400 Bad Request Raise if the browser sends something to the application the application or server cannot handle.  Parameters \n \ndescription (Optional[str]) \u2013  \nresponse (Optional[Response]) \u2013    Return type \nNone   \n  \nexception werkzeug.exceptions.Unauthorized(description=None, response=None, www_authenticate=None)  \n401 Unauthorized Raise if the user is not authorized to access a resource. The www_authenticate argument should be used to set the WWW-Authenticate header. This is used for HTTP basic auth and other schemes. Use WWWAuthenticate to create correctly formatted values. Strictly speaking a 401 response is invalid if it doesn\u2019t provide at least one value for this header, although real clients typically don\u2019t care.  Parameters \n \ndescription (Optional[str]) \u2013 Override the default message used for the body of the response. \nwww-authenticate \u2013 A single value, or list of values, for the WWW-Authenticate header(s). \nresponse (Optional[Response]) \u2013  \nwww_authenticate (Optional[Union[WWWAuthenticate, Iterable[WWWAuthenticate]]]) \u2013    Return type \nNone    Changed in version 2.0: Serialize multiple www_authenticate items into multiple WWW-Authenticate headers, rather than joining them into a single value, for better interoperability.   Changelog Changed in version 0.15.3: If the www_authenticate argument is not set, the WWW-Authenticate header is not set.   Changed in version 0.15.3: The response argument was restored.   Changed in version 0.15.1: description was moved back as the first argument, restoring its previous position.   Changed in version 0.15.0: www_authenticate was added as the first argument, ahead of description.  \n\n  \nexception werkzeug.exceptions.Forbidden(description=None, response=None)  \n403 Forbidden Raise if the user doesn\u2019t have the permission for the requested resource but was authenticated.  Parameters \n \ndescription (Optional[str]) \u2013  \nresponse (Optional[Response]) \u2013    Return type \nNone   \n  \nexception werkzeug.exceptions.NotFound(description=None, response=None)  \n404 Not Found Raise if a resource does not exist and never existed.  Parameters \n \ndescription (Optional[str]) \u2013  \nresponse (Optional[Response]) \u2013    Return type \nNone   \n  \nexception werkzeug.exceptions.MethodNotAllowed(valid_methods=None, description=None, response=None)  \n405 Method Not Allowed Raise if the server used a method the resource does not handle. For example POST if the resource is view only. Especially useful for REST. The first argument for this exception should be a list of allowed methods. Strictly speaking the response would be invalid if you don\u2019t provide valid methods in the header which you can do with that list. Takes an optional list of valid http methods starting with werkzeug 0.3 the list will be mandatory.  Parameters \n \nvalid_methods (Optional[Iterable[str]]) \u2013  \ndescription (Optional[str]) \u2013  \nresponse (Optional[Response]) \u2013    Return type \nNone   \n  \nexception werkzeug.exceptions.NotAcceptable(description=None, response=None)  \n406 Not Acceptable Raise if the server can\u2019t return any content conforming to the Accept headers of the client.  Parameters \n \ndescription (Optional[str]) \u2013  \nresponse (Optional[Response]) \u2013    Return type \nNone   \n  \nexception werkzeug.exceptions.RequestTimeout(description=None, response=None)  \n408 Request Timeout Raise to signalize a timeout.  Parameters \n \ndescription (Optional[str]) \u2013  \nresponse (Optional[Response]) \u2013    Return type \nNone   \n  \nexception werkzeug.exceptions.Conflict(description=None, response=None)  \n409 Conflict Raise to signal that a request cannot be completed because it conflicts with the current state on the server.  Changelog New in version 0.7.   Parameters \n \ndescription (Optional[str]) \u2013  \nresponse (Optional[Response]) \u2013    Return type \nNone   \n  \nexception werkzeug.exceptions.Gone(description=None, response=None)  \n410 Gone Raise if a resource existed previously and went away without new location.  Parameters \n \ndescription (Optional[str]) \u2013  \nresponse (Optional[Response]) \u2013    Return type \nNone   \n  \nexception werkzeug.exceptions.LengthRequired(description=None, response=None)  \n411 Length Required Raise if the browser submitted data but no Content-Length header which is required for the kind of processing the server does.  Parameters \n \ndescription (Optional[str]) \u2013  \nresponse (Optional[Response]) \u2013    Return type \nNone   \n  \nexception werkzeug.exceptions.PreconditionFailed(description=None, response=None)  \n412 Precondition Failed Status code used in combination with If-Match, If-None-Match, or If-Unmodified-Since.  Parameters \n \ndescription (Optional[str]) \u2013  \nresponse (Optional[Response]) \u2013    Return type \nNone   \n  \nexception werkzeug.exceptions.RequestEntityTooLarge(description=None, response=None)  \n413 Request Entity Too Large The status code one should return if the data submitted exceeded a given limit.  Parameters \n \ndescription (Optional[str]) \u2013  \nresponse (Optional[Response]) \u2013    Return type \nNone   \n  \nexception werkzeug.exceptions.RequestURITooLarge(description=None, response=None)  \n414 Request URI Too Large Like 413 but for too long URLs.  Parameters \n \ndescription (Optional[str]) \u2013  \nresponse (Optional[Response]) \u2013    Return type \nNone   \n  \nexception werkzeug.exceptions.UnsupportedMediaType(description=None, response=None)  \n415 Unsupported Media Type The status code returned if the server is unable to handle the media type the client transmitted.  Parameters \n \ndescription (Optional[str]) \u2013  \nresponse (Optional[Response]) \u2013    Return type \nNone   \n  \nexception werkzeug.exceptions.RequestedRangeNotSatisfiable(length=None, units='bytes', description=None, response=None)  \n416 Requested Range Not Satisfiable The client asked for an invalid part of the file.  Changelog New in version 0.7.  Takes an optional Content-Range header value based on length parameter.  Parameters \n \nlength (Optional[int]) \u2013  \nunits (str) \u2013  \ndescription (Optional[str]) \u2013  \nresponse (Optional[Response]) \u2013    Return type \nNone   \n  \nexception werkzeug.exceptions.ExpectationFailed(description=None, response=None)  \n417 Expectation Failed The server cannot meet the requirements of the Expect request-header.  Changelog New in version 0.7.   Parameters \n \ndescription (Optional[str]) \u2013  \nresponse (Optional[Response]) \u2013    Return type \nNone   \n  \nexception werkzeug.exceptions.ImATeapot(description=None, response=None)  \n418 I\u2019m a teapot The server should return this if it is a teapot and someone attempted to brew coffee with it.  Changelog New in version 0.7.   Parameters \n \ndescription (Optional[str]) \u2013  \nresponse (Optional[Response]) \u2013    Return type \nNone   \n  \nexception werkzeug.exceptions.UnprocessableEntity(description=None, response=None)  \n422 Unprocessable Entity Used if the request is well formed, but the instructions are otherwise incorrect.  Parameters \n \ndescription (Optional[str]) \u2013  \nresponse (Optional[Response]) \u2013    Return type \nNone   \n  \nexception werkzeug.exceptions.Locked(description=None, response=None)  \n423 Locked Used if the resource that is being accessed is locked.  Parameters \n \ndescription (Optional[str]) \u2013  \nresponse (Optional[Response]) \u2013    Return type \nNone   \n  \nexception werkzeug.exceptions.FailedDependency(description=None, response=None)  \n424 Failed Dependency Used if the method could not be performed on the resource because the requested action depended on another action and that action failed.  Parameters \n \ndescription (Optional[str]) \u2013  \nresponse (Optional[Response]) \u2013    Return type \nNone   \n  \nexception werkzeug.exceptions.PreconditionRequired(description=None, response=None)  \n428 Precondition Required The server requires this request to be conditional, typically to prevent the lost update problem, which is a race condition between two or more clients attempting to update a resource through PUT or DELETE. By requiring each client to include a conditional header (\u201cIf-Match\u201d or \u201cIf-Unmodified- Since\u201d) with the proper value retained from a recent GET request, the server ensures that each client has at least seen the previous revision of the resource.  Parameters \n \ndescription (Optional[str]) \u2013  \nresponse (Optional[Response]) \u2013    Return type \nNone   \n  \nexception werkzeug.exceptions.TooManyRequests(description=None, response=None, retry_after=None)  \n429 Too Many Requests The server is limiting the rate at which this user receives responses, and this request exceeds that rate. (The server may use any convenient method to identify users and their request rates). The server may include a \u201cRetry-After\u201d header to indicate how long the user should wait before retrying.  Parameters \n \nretry_after (Optional[Union[datetime.datetime, int]]) \u2013 If given, set the Retry-After header to this value. May be an int number of seconds or a datetime. \ndescription (Optional[str]) \u2013  \nresponse (Optional[Response]) \u2013    Return type \nNone    Changelog Changed in version 1.0: Added retry_after parameter.  \n\n  \nexception werkzeug.exceptions.RequestHeaderFieldsTooLarge(description=None, response=None)  \n431 Request Header Fields Too Large The server refuses to process the request because the header fields are too large. One or more individual fields may be too large, or the set of all headers is too large.  Parameters \n \ndescription (Optional[str]) \u2013  \nresponse (Optional[Response]) \u2013    Return type \nNone   \n  \nexception werkzeug.exceptions.UnavailableForLegalReasons(description=None, response=None)  \n451 Unavailable For Legal Reasons This status code indicates that the server is denying access to the resource as a consequence of a legal demand.  Parameters \n \ndescription (Optional[str]) \u2013  \nresponse (Optional[Response]) \u2013    Return type \nNone   \n  \nexception werkzeug.exceptions.InternalServerError(description=None, response=None, original_exception=None)  \n500 Internal Server Error Raise if an internal server error occurred. This is a good fallback if an unknown error occurred in the dispatcher.  Changelog Changed in version 1.0.0: Added the original_exception attribute.   Parameters \n \ndescription (Optional[str]) \u2013  \nresponse (Optional[Response]) \u2013  \noriginal_exception (Optional[BaseException]) \u2013    Return type \nNone    \noriginal_exception  \nThe original exception that caused this 500 error. Can be used by frameworks to provide context when handling unexpected errors. \n \n  \nexception werkzeug.exceptions.NotImplemented(description=None, response=None)  \n501 Not Implemented Raise if the application does not support the action requested by the browser.  Parameters \n \ndescription (Optional[str]) \u2013  \nresponse (Optional[Response]) \u2013    Return type \nNone   \n  \nexception werkzeug.exceptions.BadGateway(description=None, response=None)  \n502 Bad Gateway If you do proxying in your application you should return this status code if you received an invalid response from the upstream server it accessed in attempting to fulfill the request.  Parameters \n \ndescription (Optional[str]) \u2013  \nresponse (Optional[Response]) \u2013    Return type \nNone   \n  \nexception werkzeug.exceptions.ServiceUnavailable(description=None, response=None, retry_after=None)  \n503 Service Unavailable Status code you should return if a service is temporarily unavailable.  Parameters \n \nretry_after (Optional[Union[datetime.datetime, int]]) \u2013 If given, set the Retry-After header to this value. May be an int number of seconds or a datetime. \ndescription (Optional[str]) \u2013  \nresponse (Optional[Response]) \u2013    Return type \nNone    Changelog Changed in version 1.0: Added retry_after parameter.  \n\n  \nexception werkzeug.exceptions.GatewayTimeout(description=None, response=None)  \n504 Gateway Timeout Status code you should return if a connection to an upstream server times out.  Parameters \n \ndescription (Optional[str]) \u2013  \nresponse (Optional[Response]) \u2013    Return type \nNone   \n  \nexception werkzeug.exceptions.HTTPVersionNotSupported(description=None, response=None)  \n505 HTTP Version Not Supported The server does not support the HTTP protocol version used in the request.  Parameters \n \ndescription (Optional[str]) \u2013  \nresponse (Optional[Response]) \u2013    Return type \nNone   \n  \nexception werkzeug.exceptions.ClientDisconnected(description=None, response=None)  \nInternal exception that is raised if Werkzeug detects a disconnected client. Since the client is already gone at that point attempting to send the error message to the client might not work and might ultimately result in another exception in the server. Mainly this is here so that it is silenced by default as far as Werkzeug is concerned. Since disconnections cannot be reliably detected and are unspecified by WSGI to a large extent this might or might not be raised if a client is gone.  Changelog New in version 0.8.   Parameters \n \ndescription (Optional[str]) \u2013  \nresponse (Optional[Response]) \u2013    Return type \nNone   \n  \nexception werkzeug.exceptions.SecurityError(description=None, response=None)  \nRaised if something triggers a security error. This is otherwise exactly like a bad request error.  Changelog New in version 0.9.   Parameters \n \ndescription (Optional[str]) \u2013  \nresponse (Optional[Response]) \u2013    Return type \nNone   \n   Baseclass All the exceptions implement this common interface:  \nexception werkzeug.exceptions.HTTPException(description=None, response=None)  \nThe base class for all HTTP exceptions. This exception can be called as a WSGI application to render a default error page or you can catch the subclasses of it independently and render nicer error messages.  Parameters \n \ndescription (Optional[str]) \u2013  \nresponse (Optional[Response]) \u2013    Return type \nNone    \n__call__(environ, start_response)  \nCall the exception as WSGI application.  Parameters \n \nenviron (WSGIEnvironment) \u2013 the WSGI environment. \nstart_response (StartResponse) \u2013 the response callable provided by the WSGI server.   Return type \nIterable[bytes]   \n  \nget_response(environ=None, scope=None)  \nGet a response object. If one was passed to the exception it\u2019s returned directly.  Parameters \n \nenviron (Optional[WSGIEnvironment]) \u2013 the optional environ for the request. This can be used to modify the response depending on how the request looked like. \nscope (Optional[dict]) \u2013    Returns \na Response object or a subclass thereof.  Return type \nResponse   \n \n   Special HTTP Exceptions Starting with Werkzeug 0.3 some of the builtin classes raise exceptions that look like regular python exceptions (eg KeyError) but are BadRequest HTTP exceptions at the same time. This decision was made to simplify a common pattern where you want to abort if the client tampered with the submitted form data in a way that the application can\u2019t recover properly and should abort with 400 BAD REQUEST. Assuming the application catches all HTTP exceptions and reacts to them properly a view function could do the following safely and doesn\u2019t have to check if the keys exist: def new_post(request):\n    post = Post(title=request.form['title'], body=request.form['body'])\n    post.save()\n    return redirect(post.url)\n If title or body are missing in the form, a special key error will be raised which behaves like a KeyError but also a BadRequest exception.  \nexception werkzeug.exceptions.BadRequestKeyError(arg=None, *args, **kwargs)  \nAn exception that is used to signal both a KeyError and a BadRequest. Used by many of the datastructures.  Parameters \n \narg (Optional[str]) \u2013  \nargs (Any) \u2013  \nkwargs (Any) \u2013     \n   Simple Aborting Sometimes it\u2019s convenient to just raise an exception by the error code, without importing the exception and looking up the name etc. For this purpose there is the abort() function.  \nwerkzeug.exceptions.abort(status, *args, **kwargs)  \nRaises an HTTPException for the given status code or WSGI application. If a status code is given, it will be looked up in the list of exceptions and will raise that exception. If passed a WSGI application, it will wrap it in a proxy WSGI exception and raise that: abort(404)  # 404 Not Found\nabort(Response('Hello World'))\n  Parameters \n \nstatus (Union[int, Response]) \u2013  \nargs (Any) \u2013  \nkwargs (Any) \u2013    Return type \nNoReturn   \n If you want to use this functionality with custom exceptions you can create an instance of the aborter class:  \nclass werkzeug.exceptions.Aborter(mapping=None, extra=None)  \nWhen passed a dict of code -> exception items it can be used as callable that raises exceptions. If the first argument to the callable is an integer it will be looked up in the mapping, if it\u2019s a WSGI application it will be raised in a proxy exception. The rest of the arguments are forwarded to the exception constructor.  Parameters \n \nmapping (Optional[Dict[int, Type[werkzeug.exceptions.HTTPException]]]) \u2013  \nextra (Optional[Dict[int, Type[werkzeug.exceptions.HTTPException]]]) \u2013    Return type \nNone   \n   Custom Errors As you can see from the list above not all status codes are available as errors. Especially redirects and other non 200 status codes that do not represent errors are missing. For redirects you can use the redirect() function from the utilities. If you want to add an error yourself you can subclass HTTPException: from werkzeug.exceptions import HTTPException\n\nclass PaymentRequired(HTTPException):\n    code = 402\n    description = '<p>Payment required.</p>'\n This is the minimal code you need for your own exception. If you want to add more logic to the errors you can override the get_description(), get_body(), get_headers() and get_response() methods. In any case you should have a look at the sourcecode of the exceptions module. You can override the default description in the constructor with the description parameter: raise BadRequest(description='Request failed because X was not present')\n \n"}, {"name": "HTTP Proxying", "path": "deployment/proxying/index", "type": "Other", "text": "HTTP Proxying Many people prefer using a standalone Python HTTP server and proxying that server via nginx, Apache etc. A very stable Python server is CherryPy. This part of the documentation shows you how to combine your WSGI application with the CherryPy WSGI server and how to configure the webserver for proxying.  Creating a .py server To run your application you need a start-server.py file that starts up the WSGI Server. It looks something along these lines: from cherrypy import wsgiserver\nfrom yourapplication import make_app\nserver = wsgiserver.CherryPyWSGIServer(('localhost', 8080), make_app())\ntry:\n    server.start()\nexcept KeyboardInterrupt:\n    server.stop()\n If you now start the file the server will listen on localhost:8080. Keep in mind that WSGI applications behave slightly different for proxied setups. If you have not developed your application for proxying in mind, you can apply the ProxyFix middleware.   Configuring nginx As an example we show here how to configure nginx to proxy to the server. The basic nginx configuration looks like this: location / {\n    proxy_set_header        Host $host;\n    proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;\n    proxy_pass              http://127.0.0.1:8080;\n    proxy_redirect          default;\n}\n Since Nginx doesn\u2019t start your server for you, you have to do it by yourself. You can either write an init.d script for that or execute it inside a screen session: $ screen\n$ python start-server.py\n \n"}, {"name": "HTTP Utilities", "path": "http/index", "type": "Other", "text": "HTTP Utilities Werkzeug provides a couple of functions to parse and generate HTTP headers that are useful when implementing WSGI middlewares or whenever you are operating on a lower level layer. All this functionality is also exposed from request and response objects.  Datetime Functions These functions simplify working with times in an HTTP context. Werkzeug produces timezone-aware datetime objects in UTC. When passing datetime objects to Werkzeug, it assumes any naive datetime is in UTC. When comparing datetime values from Werkzeug, your own datetime objects must also be timezone-aware, or you must make the values from Werkzeug naive.  \ndt = datetime.now(timezone.utc) gets the current time in UTC. \ndt = datetime(..., tzinfo=timezone.utc) creates a time in UTC. \ndt = dt.replace(tzinfo=timezone.utc) makes a naive object aware by assuming it\u2019s in UTC. \ndt = dt.replace(tzinfo=None) makes an aware object naive.   \nwerkzeug.http.parse_date(value)  \nParse an RFC 2822 date into a timezone-aware datetime.datetime object, or None if parsing fails. This is a wrapper for email.utils.parsedate_to_datetime(). It returns None if parsing fails instead of raising an exception, and always returns a timezone-aware datetime object. If the string doesn\u2019t have timezone information, it is assumed to be UTC.  Parameters \nvalue (Optional[str]) \u2013 A string with a supported date format.  Return type \nOptional[datetime.datetime]    Changed in version 2.0: Return a timezone-aware datetime object. Use email.utils.parsedate_to_datetime.  \n  \nwerkzeug.http.http_date(timestamp=None)  \nFormat a datetime object or timestamp into an RFC 2822 date string. This is a wrapper for email.utils.format_datetime(). It assumes naive datetime objects are in UTC instead of raising an exception.  Parameters \ntimestamp (Optional[Union[datetime.datetime, datetime.date, int, float, time.struct_time]]) \u2013 The datetime or timestamp to format. Defaults to the current time.  Return type \nstr    Changed in version 2.0: Use email.utils.format_datetime. Accept date objects.  \n  \nwerkzeug.http.cookie_date(expires=None)  \nFormat a datetime object or timestamp into an RFC 2822 date string for Set-Cookie expires.  Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use http_date() instead.   Parameters \nexpires (Optional[Union[datetime.datetime, datetime.date, int, float, time.struct_time]]) \u2013   Return type \nstr   \n   Header Parsing The following functions can be used to parse incoming HTTP headers. Because Python does not provide data structures with the semantics required by RFC 2616, Werkzeug implements some custom data structures that are documented separately.  \nwerkzeug.http.parse_options_header(value, multiple=False)  \nParse a Content-Type like header into a tuple with the content type and the options: >>> parse_options_header('text/html; charset=utf8')\n('text/html', {'charset': 'utf8'})\n This should not be used to parse Cache-Control like headers that use a slightly different format. For these headers use the parse_dict_header() function.  Changelog Changed in version 0.15: RFC 2231 parameter continuations are handled.   New in version 0.5.   Parameters \n \nvalue (Optional[str]) \u2013 the header to parse. \nmultiple (bool) \u2013 Whether try to parse and return multiple MIME types   Returns \n(mimetype, options) or (mimetype, options, mimetype, options, \u2026) if multiple=True  Return type \nUnion[Tuple[str, Dict[str, str]], Tuple[Any, \u2026]]   \n  \nwerkzeug.http.parse_set_header(value, on_update=None)  \nParse a set-like header and return a HeaderSet object: >>> hs = parse_set_header('token, \"quoted value\"')\n The return value is an object that treats the items case-insensitively and keeps the order of the items: >>> 'TOKEN' in hs\nTrue\n>>> hs.index('quoted value')\n1\n>>> hs\nHeaderSet(['token', 'quoted value'])\n To create a header from the HeaderSet again, use the dump_header() function.  Parameters \n \nvalue (Optional[str]) \u2013 a set header to be parsed. \non_update (Optional[Callable[[werkzeug.datastructures.HeaderSet], None]]) \u2013 an optional callable that is called every time a value on the HeaderSet object is changed.   Returns \na HeaderSet  Return type \nwerkzeug.datastructures.HeaderSet   \n  \nwerkzeug.http.parse_list_header(value)  \nParse lists as described by RFC 2068 Section 2. In particular, parse comma-separated lists where the elements of the list may include quoted-strings. A quoted-string could contain a comma. A non-quoted string could have quotes in the middle. Quotes are removed automatically after parsing. It basically works like parse_set_header() just that items may appear multiple times and case sensitivity is preserved. The return value is a standard list: >>> parse_list_header('token, \"quoted value\"')\n['token', 'quoted value']\n To create a header from the list again, use the dump_header() function.  Parameters \nvalue (str) \u2013 a string with a list header.  Returns \nlist  Return type \nList[str]   \n  \nwerkzeug.http.parse_dict_header(value, cls=<class 'dict'>)  \nParse lists of key, value pairs as described by RFC 2068 Section 2 and convert them into a python dict (or any other mapping object created from the type with a dict like interface provided by the cls argument): >>> d = parse_dict_header('foo=\"is a fish\", bar=\"as well\"')\n>>> type(d) is dict\nTrue\n>>> sorted(d.items())\n[('bar', 'as well'), ('foo', 'is a fish')]\n If there is no value for a key it will be None: >>> parse_dict_header('key_without_value')\n{'key_without_value': None}\n To create a header from the dict again, use the dump_header() function.  Changelog Changed in version 0.9: Added support for cls argument.   Parameters \n \nvalue (str) \u2013 a string with a dict header. \ncls (Type[dict]) \u2013 callable to use for storage of parsed results.   Returns \nan instance of cls  Return type \nDict[str, str]   \n  \nwerkzeug.http.parse_accept_header(value[, class])  \nParses an HTTP Accept-* header. This does not implement a complete valid algorithm but one that supports at least value and quality extraction. Returns a new Accept object (basically a list of (value, quality) tuples sorted by the quality with some additional accessor methods). The second parameter can be a subclass of Accept that is created with the parsed values and returned.  Parameters \n \nvalue (Optional[str]) \u2013 the accept header string to be parsed. \ncls (Optional[Type[werkzeug.http._TAnyAccept]]) \u2013 the wrapper class for the return value (can be Accept or a subclass thereof)   Returns \nan instance of cls.  Return type \nwerkzeug.http._TAnyAccept   \n  \nwerkzeug.http.parse_cache_control_header(value, on_update=None, cls=None)  \nParse a cache control header. The RFC differs between response and request cache control, this method does not. It\u2019s your responsibility to not use the wrong control statements.  Changelog New in version 0.5: The cls was added. If not specified an immutable RequestCacheControl is returned.   Parameters \n \nvalue (Optional[str]) \u2013 a cache control header to be parsed. \non_update (Optional[Callable[[werkzeug.http._TAnyCC], None]]) \u2013 an optional callable that is called every time a value on the CacheControl object is changed. \ncls (Optional[Type[werkzeug.http._TAnyCC]]) \u2013 the class for the returned object. By default RequestCacheControl is used.   Returns \na cls object.  Return type \nwerkzeug.http._TAnyCC   \n  \nwerkzeug.http.parse_authorization_header(value)  \nParse an HTTP basic/digest authorization header transmitted by the web browser. The return value is either None if the header was invalid or not given, otherwise an Authorization object.  Parameters \nvalue (Optional[str]) \u2013 the authorization header to parse.  Returns \na Authorization object or None.  Return type \nOptional[werkzeug.datastructures.Authorization]   \n  \nwerkzeug.http.parse_www_authenticate_header(value, on_update=None)  \nParse an HTTP WWW-Authenticate header into a WWWAuthenticate object.  Parameters \n \nvalue (Optional[str]) \u2013 a WWW-Authenticate header to parse. \non_update (Optional[Callable[[werkzeug.datastructures.WWWAuthenticate], None]]) \u2013 an optional callable that is called every time a value on the WWWAuthenticate object is changed.   Returns \na WWWAuthenticate object.  Return type \nwerkzeug.datastructures.WWWAuthenticate   \n  \nwerkzeug.http.parse_if_range_header(value)  \nParses an if-range header which can be an etag or a date. Returns a IfRange object.  Changed in version 2.0: If the value represents a datetime, it is timezone-aware.   Changelog New in version 0.7.   Parameters \nvalue (Optional[str]) \u2013   Return type \nwerkzeug.datastructures.IfRange   \n  \nwerkzeug.http.parse_range_header(value, make_inclusive=True)  \nParses a range header into a Range object. If the header is missing or malformed None is returned. ranges is a list of (start, stop) tuples where the ranges are non-inclusive.  Changelog New in version 0.7.   Parameters \n \nvalue (Optional[str]) \u2013  \nmake_inclusive (bool) \u2013    Return type \nOptional[werkzeug.datastructures.Range]   \n  \nwerkzeug.http.parse_content_range_header(value, on_update=None)  \nParses a range header into a ContentRange object or None if parsing is not possible.  Changelog New in version 0.7.   Parameters \n \nvalue (Optional[str]) \u2013 a content range header to be parsed. \non_update (Optional[Callable[[werkzeug.datastructures.ContentRange], None]]) \u2013 an optional callable that is called every time a value on the ContentRange object is changed.   Return type \nOptional[werkzeug.datastructures.ContentRange]   \n   Header Utilities The following utilities operate on HTTP headers well but do not parse them. They are useful if you\u2019re dealing with conditional responses or if you want to proxy arbitrary requests but want to remove WSGI-unsupported hop-by-hop headers. Also there is a function to create HTTP header strings from the parsed data.  \nwerkzeug.http.is_entity_header(header)  \nCheck if a header is an entity header.  Changelog New in version 0.5.   Parameters \nheader (str) \u2013 the header to test.  Returns \nTrue if it\u2019s an entity header, False otherwise.  Return type \nbool   \n  \nwerkzeug.http.is_hop_by_hop_header(header)  \nCheck if a header is an HTTP/1.1 \u201cHop-by-Hop\u201d header.  Changelog New in version 0.5.   Parameters \nheader (str) \u2013 the header to test.  Returns \nTrue if it\u2019s an HTTP/1.1 \u201cHop-by-Hop\u201d header, False otherwise.  Return type \nbool   \n  \nwerkzeug.http.remove_entity_headers(headers, allowed=('expires', 'content-location'))  \nRemove all entity headers from a list or Headers object. This operation works in-place. Expires and Content-Location headers are by default not removed. The reason for this is RFC 2616 section 10.3.5 which specifies some entity headers that should be sent.  Changelog Changed in version 0.5: added allowed parameter.   Parameters \n \nheaders (Union[werkzeug.datastructures.Headers, List[Tuple[str, str]]]) \u2013 a list or Headers object. \nallowed (Iterable[str]) \u2013 a list of headers that should still be allowed even though they are entity headers.   Return type \nNone   \n  \nwerkzeug.http.remove_hop_by_hop_headers(headers)  \nRemove all HTTP/1.1 \u201cHop-by-Hop\u201d headers from a list or Headers object. This operation works in-place.  Changelog New in version 0.5.   Parameters \nheaders (Union[werkzeug.datastructures.Headers, List[Tuple[str, str]]]) \u2013 a list or Headers object.  Return type \nNone   \n  \nwerkzeug.http.is_byte_range_valid(start, stop, length)  \nChecks if a given byte content range is valid for the given length.  Changelog New in version 0.7.   Parameters \n \nstart (Optional[int]) \u2013  \nstop (Optional[int]) \u2013  \nlength (Optional[int]) \u2013    Return type \nbool   \n  \nwerkzeug.http.quote_header_value(value, extra_chars='', allow_token=True)  \nQuote a header value if necessary.  Changelog New in version 0.5.   Parameters \n \nvalue (Union[str, int]) \u2013 the value to quote. \nextra_chars (str) \u2013 a list of extra characters to skip quoting. \nallow_token (bool) \u2013 if this is enabled token values are returned unchanged.   Return type \nstr   \n  \nwerkzeug.http.unquote_header_value(value, is_filename=False)  \nUnquotes a header value. (Reversal of quote_header_value()). This does not use the real unquoting but what browsers are actually using for quoting.  Changelog New in version 0.5.   Parameters \n \nvalue (str) \u2013 the header value to unquote. \nis_filename (bool) \u2013 The value represents a filename or path.   Return type \nstr   \n  \nwerkzeug.http.dump_header(iterable, allow_token=True)  \nDump an HTTP header again. This is the reversal of parse_list_header(), parse_set_header() and parse_dict_header(). This also quotes strings that include an equals sign unless you pass it as dict of key, value pairs. >>> dump_header({'foo': 'bar baz'})\n'foo=\"bar baz\"'\n>>> dump_header(('foo', 'bar baz'))\n'foo, \"bar baz\"'\n  Parameters \n \niterable (Union[Dict[str, Union[str, int]], Iterable[str]]) \u2013 the iterable or dict of values to quote. \nallow_token (bool) \u2013 if set to False tokens as values are disallowed. See quote_header_value() for more details.   Return type \nstr   \n   Cookies  \nwerkzeug.http.parse_cookie(header, charset='utf-8', errors='replace', cls=None)  \nParse a cookie from a string or WSGI environ. The same key can be provided multiple times, the values are stored in-order. The default MultiDict will have the first value first, and all values can be retrieved with MultiDict.getlist().  Parameters \n \nheader (Optional[Union[WSGIEnvironment, str, bytes]]) \u2013 The cookie header as a string, or a WSGI environ dict with a HTTP_COOKIE key. \ncharset (str) \u2013 The charset for the cookie values. \nerrors (str) \u2013 The error behavior for the charset decoding. \ncls (Optional[Type[ds.MultiDict]]) \u2013 A dict-like class to store the parsed cookies in. Defaults to MultiDict.   Return type \nds.MultiDict[str, str]    Changelog Changed in version 1.0.0: Returns a MultiDict instead of a TypeConversionDict.   Changed in version 0.5: Returns a TypeConversionDict instead of a regular dict. The cls parameter was added.  \n\n  \nwerkzeug.http.dump_cookie(key, value='', max_age=None, expires=None, path='/', domain=None, secure=False, httponly=False, charset='utf-8', sync_expires=True, max_size=4093, samesite=None)  \nCreate a Set-Cookie header without the Set-Cookie prefix. The return value is usually restricted to ascii as the vast majority of values are properly escaped, but that is no guarantee. It\u2019s tunneled through latin1 as required by PEP 3333. The return value is not ASCII safe if the key contains unicode characters. This is technically against the specification but happens in the wild. It\u2019s strongly recommended to not use non-ASCII values for the keys.  Parameters \n \nmax_age (Optional[Union[datetime.timedelta, int]]) \u2013 should be a number of seconds, or None (default) if the cookie should last only as long as the client\u2019s browser session. Additionally timedelta objects are accepted, too. \nexpires (Optional[Union[str, datetime.datetime, int, float]]) \u2013 should be a datetime object or unix timestamp. \npath (Optional[str]) \u2013 limits the cookie to a given path, per default it will span the whole domain. \ndomain (Optional[str]) \u2013 Use this if you want to set a cross-domain cookie. For example, domain=\".example.com\" will set a cookie that is readable by the domain www.example.com, foo.example.com etc. Otherwise, a cookie will only be readable by the domain that set it. \nsecure (bool) \u2013 The cookie will only be available via HTTPS \nhttponly (bool) \u2013 disallow JavaScript to access the cookie. This is an extension to the cookie standard and probably not supported by all browsers. \ncharset (str) \u2013 the encoding for string values. \nsync_expires (bool) \u2013 automatically set expires if max_age is defined but expires not. \nmax_size (int) \u2013 Warn if the final header value exceeds this size. The default, 4093, should be safely supported by most browsers. Set to 0 to disable this check. \nsamesite (Optional[str]) \u2013 Limits the scope of the cookie such that it will only be attached to requests if those requests are same-site. \nkey (str) \u2013  \nvalue (Union[bytes, str]) \u2013    Return type \nstr    Changelog Changed in version 1.0.0: The string 'None' is accepted for samesite.  \n\n   Conditional Response Helpers For conditional responses the following functions might be useful:  \nwerkzeug.http.parse_etags(value)  \nParse an etag header.  Parameters \nvalue (Optional[str]) \u2013 the tag header to parse  Returns \nan ETags object.  Return type \nwerkzeug.datastructures.ETags   \n  \nwerkzeug.http.quote_etag(etag, weak=False)  \nQuote an etag.  Parameters \n \netag (str) \u2013 the etag to quote. \nweak (bool) \u2013 set to True to tag it \u201cweak\u201d.   Return type \nstr   \n  \nwerkzeug.http.unquote_etag(etag)  \nUnquote a single etag: >>> unquote_etag('W/\"bar\"')\n('bar', True)\n>>> unquote_etag('\"bar\"')\n('bar', False)\n  Parameters \netag (Optional[str]) \u2013 the etag identifier to unquote.  Returns \na (etag, weak) tuple.  Return type \nUnion[Tuple[str, bool], Tuple[None, None]]   \n  \nwerkzeug.http.generate_etag(data)  \nGenerate an etag for some data.  Changed in version 2.0: Use SHA-1. MD5 may not be available in some environments.   Parameters \ndata (bytes) \u2013   Return type \nstr   \n  \nwerkzeug.http.is_resource_modified(environ, etag=None, data=None, last_modified=None, ignore_if_range=True)  \nConvenience method for conditional requests.  Parameters \n \nenviron (WSGIEnvironment) \u2013 the WSGI environment of the request to be checked. \netag (Optional[str]) \u2013 the etag for the response for comparison. \ndata (Optional[bytes]) \u2013 or alternatively the data of the response to automatically generate an etag using generate_etag(). \nlast_modified (Optional[Union[datetime.datetime, str]]) \u2013 an optional date of the last modification. \nignore_if_range (bool) \u2013 If False, If-Range header will be taken into account.   Returns \nTrue if the resource was modified, otherwise False.  Return type \nbool    Changed in version 2.0: SHA-1 is used to generate an etag value for the data. MD5 may not be available in some environments.   Changelog Changed in version 1.0.0: The check is run for methods other than GET and HEAD.  \n\n   Constants  \nwerkzeug.http.HTTP_STATUS_CODES  \nA dict of status code -> default status message pairs. This is used by the wrappers and other places where an integer status code is expanded to a string throughout Werkzeug. \n   Form Data Parsing Werkzeug provides the form parsing functions separately from the request object so that you can access form data from a plain WSGI environment. The following formats are currently supported by the form data parser:  application/x-www-form-urlencoded multipart/form-data  Nested multipart is not currently supported (Werkzeug 0.9), but it isn\u2019t used by any of the modern web browsers. Usage example: >>> from io import BytesIO\n>>> from werkzeug.formparser import parse_form_data\n>>> data = (\n...     b'--foo\\r\\nContent-Disposition: form-data; name=\"test\"\\r\\n'\n...     b\"\\r\\nHello World!\\r\\n--foo--\"\n... )\n>>> environ = {\n...     \"wsgi.input\": BytesIO(data),\n...     \"CONTENT_LENGTH\": str(len(data)),\n...     \"CONTENT_TYPE\": \"multipart/form-data; boundary=foo\",\n...     \"REQUEST_METHOD\": \"POST\",\n... }\n>>> stream, form, files = parse_form_data(environ)\n>>> stream.read()\nb''\n>>> form['test']\n'Hello World!'\n>>> not files\nTrue\n Normally the WSGI environment is provided by the WSGI gateway with the incoming data as part of it. If you want to generate such fake-WSGI environments for unittesting you might want to use the create_environ() function or the EnvironBuilder instead.  \nclass werkzeug.formparser.FormDataParser(stream_factory=None, charset='utf-8', errors='replace', max_form_memory_size=None, max_content_length=None, cls=None, silent=True)  \nThis class implements parsing of form data for Werkzeug. By itself it can parse multipart and url encoded form data. It can be subclassed and extended but for most mimetypes it is a better idea to use the untouched stream and expose it as separate attributes on a request object.  Changelog New in version 0.8.   Parameters \n \nstream_factory (Optional[TStreamFactory]) \u2013 An optional callable that returns a new read and writeable file descriptor. This callable works the same as Response._get_file_stream(). \ncharset (str) \u2013 The character set for URL and url encoded form data. \nerrors (str) \u2013 The encoding error behavior. \nmax_form_memory_size (Optional[int]) \u2013 the maximum number of bytes to be accepted for in-memory stored form data. If the data exceeds the value specified an RequestEntityTooLarge exception is raised. \nmax_content_length (Optional[int]) \u2013 If this is provided and the transmitted data is longer than this value an RequestEntityTooLarge exception is raised. \ncls (Optional[Type[werkzeug.datastructures.MultiDict]]) \u2013 an optional dict class to use. If this is not specified or None the default MultiDict is used. \nsilent (bool) \u2013 If set to False parsing errors will not be caught.   Return type \nNone   \n  \nwerkzeug.formparser.parse_form_data(environ, stream_factory=None, charset='utf-8', errors='replace', max_form_memory_size=None, max_content_length=None, cls=None, silent=True)  \nParse the form data in the environ and return it as tuple in the form (stream, form, files). You should only call this method if the transport method is POST, PUT, or PATCH. If the mimetype of the data transmitted is multipart/form-data the files multidict will be filled with FileStorage objects. If the mimetype is unknown the input stream is wrapped and returned as first argument, else the stream is empty. This is a shortcut for the common usage of FormDataParser. Have a look at Dealing with Request Data for more details.  Changelog New in version 0.5.1: The optional silent flag was added.   New in version 0.5: The max_form_memory_size, max_content_length and cls parameters were added.   Parameters \n \nenviron (WSGIEnvironment) \u2013 the WSGI environment to be used for parsing. \nstream_factory (Optional[TStreamFactory]) \u2013 An optional callable that returns a new read and writeable file descriptor. This callable works the same as Response._get_file_stream(). \ncharset (str) \u2013 The character set for URL and url encoded form data. \nerrors (str) \u2013 The encoding error behavior. \nmax_form_memory_size (Optional[int]) \u2013 the maximum number of bytes to be accepted for in-memory stored form data. If the data exceeds the value specified an RequestEntityTooLarge exception is raised. \nmax_content_length (Optional[int]) \u2013 If this is provided and the transmitted data is longer than this value an RequestEntityTooLarge exception is raised. \ncls (Optional[Type[werkzeug.datastructures.MultiDict]]) \u2013 an optional dict class to use. If this is not specified or None the default MultiDict is used. \nsilent (bool) \u2013 If set to False parsing errors will not be caught.   Returns \nA tuple in the form (stream, form, files).  Return type \nt_parse_result   \n \n"}, {"name": "HTTPException.get_response()", "path": "exceptions/index#werkzeug.exceptions.HTTPException.get_response", "type": "werkzeug.exceptions", "text": " \nget_response(environ=None, scope=None)  \nGet a response object. If one was passed to the exception it\u2019s returned directly.  Parameters \n \nenviron (Optional[WSGIEnvironment]) \u2013 the optional environ for the request. This can be used to modify the response depending on how the request looked like. \nscope (Optional[dict]) \u2013    Returns \na Response object or a subclass thereof.  Return type \nResponse   \n"}, {"name": "HTTPException.__call__()", "path": "exceptions/index#werkzeug.exceptions.HTTPException.__call__", "type": "werkzeug.exceptions", "text": " \n__call__(environ, start_response)  \nCall the exception as WSGI application.  Parameters \n \nenviron (WSGIEnvironment) \u2013 the WSGI environment. \nstart_response (StartResponse) \u2013 the response callable provided by the WSGI server.   Return type \nIterable[bytes]   \n"}, {"name": "http_date()", "path": "http/index#werkzeug.http.http_date", "type": "werkzeug.http", "text": " \nwerkzeug.http.http_date(timestamp=None)  \nFormat a datetime object or timestamp into an RFC 2822 date string. This is a wrapper for email.utils.format_datetime(). It assumes naive datetime objects are in UTC instead of raising an exception.  Parameters \ntimestamp (Optional[Union[datetime.datetime, datetime.date, int, float, time.struct_time]]) \u2013 The datetime or timestamp to format. Defaults to the current time.  Return type \nstr    Changed in version 2.0: Use email.utils.format_datetime. Accept date objects.  \n"}, {"name": "IfRange", "path": "datastructures/index#werkzeug.datastructures.IfRange", "type": "werkzeug.datastructures", "text": " \nclass werkzeug.datastructures.IfRange(etag=None, date=None)  \nVery simple object that represents the If-Range header in parsed form. It will either have neither a etag or date or one of either but never both.  Changelog New in version 0.7.   \ndate  \nThe date in parsed format or None. \n  \netag  \nThe etag parsed and unquoted. Ranges always operate on strong etags so the weakness information is not necessary. \n  \nto_header()  \nConverts the object back into an HTTP header. \n \n"}, {"name": "IfRange.date", "path": "datastructures/index#werkzeug.datastructures.IfRange.date", "type": "werkzeug.datastructures", "text": " \ndate  \nThe date in parsed format or None. \n"}, {"name": "IfRange.etag", "path": "datastructures/index#werkzeug.datastructures.IfRange.etag", "type": "werkzeug.datastructures", "text": " \netag  \nThe etag parsed and unquoted. Ranges always operate on strong etags so the weakness information is not necessary. \n"}, {"name": "IfRange.to_header()", "path": "datastructures/index#werkzeug.datastructures.IfRange.to_header", "type": "werkzeug.datastructures", "text": " \nto_header()  \nConverts the object back into an HTTP header. \n"}, {"name": "ImmutableDict", "path": "datastructures/index#werkzeug.datastructures.ImmutableDict", "type": "werkzeug.datastructures", "text": " \nclass werkzeug.datastructures.ImmutableDict  \nAn immutable dict.  Changelog New in version 0.5.   \ncopy()  \nReturn a shallow mutable copy of this object. Keep in mind that the standard library\u2019s copy() function is a no-op for this class like for any other python immutable type (eg: tuple). \n \n"}, {"name": "ImmutableDict.copy()", "path": "datastructures/index#werkzeug.datastructures.ImmutableDict.copy", "type": "werkzeug.datastructures", "text": " \ncopy()  \nReturn a shallow mutable copy of this object. Keep in mind that the standard library\u2019s copy() function is a no-op for this class like for any other python immutable type (eg: tuple). \n"}, {"name": "ImmutableList", "path": "datastructures/index#werkzeug.datastructures.ImmutableList", "type": "werkzeug.datastructures", "text": " \nclass werkzeug.datastructures.ImmutableList(iterable=(), /)  \nAn immutable list.  Changelog New in version 0.5.   Private  \n"}, {"name": "ImmutableMultiDict", "path": "datastructures/index#werkzeug.datastructures.ImmutableMultiDict", "type": "werkzeug.datastructures", "text": " \nclass werkzeug.datastructures.ImmutableMultiDict(mapping=None)  \nAn immutable MultiDict.  Changelog New in version 0.5.   \ncopy()  \nReturn a shallow mutable copy of this object. Keep in mind that the standard library\u2019s copy() function is a no-op for this class like for any other python immutable type (eg: tuple). \n \n"}, {"name": "ImmutableMultiDict.copy()", "path": "datastructures/index#werkzeug.datastructures.ImmutableMultiDict.copy", "type": "werkzeug.datastructures", "text": " \ncopy()  \nReturn a shallow mutable copy of this object. Keep in mind that the standard library\u2019s copy() function is a no-op for this class like for any other python immutable type (eg: tuple). \n"}, {"name": "ImmutableOrderedMultiDict", "path": "datastructures/index#werkzeug.datastructures.ImmutableOrderedMultiDict", "type": "werkzeug.datastructures", "text": " \nclass werkzeug.datastructures.ImmutableOrderedMultiDict(mapping=None)  \nAn immutable OrderedMultiDict.  Changelog New in version 0.6.   \ncopy()  \nReturn a shallow mutable copy of this object. Keep in mind that the standard library\u2019s copy() function is a no-op for this class like for any other python immutable type (eg: tuple). \n \n"}, {"name": "ImmutableOrderedMultiDict.copy()", "path": "datastructures/index#werkzeug.datastructures.ImmutableOrderedMultiDict.copy", "type": "werkzeug.datastructures", "text": " \ncopy()  \nReturn a shallow mutable copy of this object. Keep in mind that the standard library\u2019s copy() function is a no-op for this class like for any other python immutable type (eg: tuple). \n"}, {"name": "ImmutableTypeConversionDict", "path": "datastructures/index#werkzeug.datastructures.ImmutableTypeConversionDict", "type": "werkzeug.datastructures", "text": " \nclass werkzeug.datastructures.ImmutableTypeConversionDict  \nWorks like a TypeConversionDict but does not support modifications.  Changelog New in version 0.5.   \ncopy()  \nReturn a shallow mutable copy of this object. Keep in mind that the standard library\u2019s copy() function is a no-op for this class like for any other python immutable type (eg: tuple). \n \n"}, {"name": "ImmutableTypeConversionDict.copy()", "path": "datastructures/index#werkzeug.datastructures.ImmutableTypeConversionDict.copy", "type": "werkzeug.datastructures", "text": " \ncopy()  \nReturn a shallow mutable copy of this object. Keep in mind that the standard library\u2019s copy() function is a no-op for this class like for any other python immutable type (eg: tuple). \n"}, {"name": "Important Terms", "path": "terms/index", "type": "Other", "text": "Important Terms This page covers important terms used in the documentation and Werkzeug itself.  WSGI WSGI a specification for Python web applications Werkzeug follows. It was specified in the PEP 3333 and is widely supported. Unlike previous solutions it guarantees that web applications, servers and utilities can work together.   Response Object For Werkzeug, a response object is an object that works like a WSGI application but does not do any request processing. Usually you have a view function or controller method that processes the request and assembles a response object. A response object is not necessarily the Response class or a subclass thereof. For example Pylons/webob provide a very similar response class that can be used as well (webob.Response).   View Function Often people speak of MVC (Model, View, Controller) when developing web applications. However, the Django framework coined MTV (Model, Template, View) which basically means the same but reduces the concept to the data model, a function that processes data from the request and the database and renders a template. Werkzeug itself does not tell you how you should develop applications, but the documentation often speaks of view functions that work roughly the same. The idea of a view function is that it\u2019s called with a request object (and optionally some parameters from an URL rule) and returns a response object. \n"}, {"name": "import_string()", "path": "utils/index#werkzeug.utils.import_string", "type": "werkzeug.utils", "text": " \nwerkzeug.utils.import_string(import_name, silent=False)  \nImports an object based on a string. This is useful if you want to use import paths as endpoints or something similar. An import path can be specified either in dotted notation (xml.sax.saxutils.escape) or with a colon as object delimiter (xml.sax.saxutils:escape). If silent is True the return value will be None if the import fails.  Parameters \n \nimport_name (str) \u2013 the dotted name for the object to import. \nsilent (bool) \u2013 if set to True import errors are ignored and None is returned instead.   Returns \nimported object  Return type \nAny   \n"}, {"name": "Installation", "path": "installation/index", "type": "Other", "text": "Installation  Python Version We recommend using the latest version of Python. Werkzeug supports Python 3.6 and newer.   Dependencies Werkzeug does not have any direct dependencies.  Optional dependencies These distributions will not be installed automatically. Werkzeug will detect and use them if you install them.  \nColorama provides request log highlighting when using the development server on Windows. This works automatically on other systems. \nWatchdog provides a faster, more efficient reloader for the development server.     Virtual environments Use a virtual environment to manage the dependencies for your project, both in development and in production. What problem does a virtual environment solve? The more Python projects you have, the more likely it is that you need to work with different versions of Python libraries, or even Python itself. Newer versions of libraries for one project can break compatibility in another project. Virtual environments are independent groups of Python libraries, one for each project. Packages installed for one project will not affect other projects or the operating system\u2019s packages. Python comes bundled with the venv module to create virtual environments.  Create an environment Create a project folder and a venv folder within: mkdir myproject\ncd myproject\npython3 -m venv venv\n On Windows: py -3 -m venv venv\n   Activate the environment Before you work on your project, activate the corresponding environment: . venv/bin/activate\n On Windows: venv\\Scripts\\activate\n Your shell prompt will change to show the name of the activated environment.    Install Werkzeug Within the activated environment, use the following command to install Werkzeug: pip install Werkzeug\n \n"}, {"name": "IntegerConverter", "path": "routing/index#werkzeug.routing.IntegerConverter", "type": "werkzeug.routing", "text": " \nclass werkzeug.routing.IntegerConverter(map, fixed_digits=0, min=None, max=None, signed=False)  \nThis converter only accepts integer values: Rule(\"/page/<int:page>\")\n By default it only accepts unsigned, positive values. The signed parameter will enable signed, negative values. Rule(\"/page/<int(signed=True):page>\")\n  Parameters \n \nmap (Map) \u2013 The Map. \nfixed_digits (int) \u2013 The number of fixed digits in the URL. If you set this to 4 for example, the rule will only match if the URL looks like /0001/. The default is variable length. \nmin (Optional[int]) \u2013 The minimal value. \nmax (Optional[int]) \u2013 The maximal value. \nsigned (bool) \u2013 Allow signed (negative) values.   Return type \nNone    Changelog New in version 0.15: The signed parameter.  \n\n"}, {"name": "InternalServerError.original_exception", "path": "exceptions/index#werkzeug.exceptions.InternalServerError.original_exception", "type": "werkzeug.exceptions", "text": " \noriginal_exception  \nThe original exception that caused this 500 error. Can be used by frameworks to provide context when handling unexpected errors. \n"}, {"name": "invalidate_cached_property()", "path": "utils/index#werkzeug.utils.invalidate_cached_property", "type": "werkzeug.utils", "text": " \nwerkzeug.utils.invalidate_cached_property(obj, name)  \nInvalidates the cache for a cached_property: >>> class Test(object):\n...     @cached_property\n...     def magic_number(self):\n...         print(\"recalculating...\")\n...         return 42\n...\n>>> var = Test()\n>>> var.magic_number\nrecalculating...\n42\n>>> var.magic_number\n42\n>>> invalidate_cached_property(var, \"magic_number\")\n>>> var.magic_number\nrecalculating...\n42\n You must pass the name of the cached property as the second argument.  Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use del obj.name instead.   Parameters \n \nobj (object) \u2013  \nname (str) \u2013    Return type \nNone   \n"}, {"name": "iri_to_uri()", "path": "urls/index#werkzeug.urls.iri_to_uri", "type": "werkzeug.urls", "text": " \nwerkzeug.urls.iri_to_uri(iri, charset='utf-8', errors='strict', safe_conversion=False)  \nConvert an IRI to a URI. All non-ASCII and unsafe characters are quoted. If the URL has a domain, it is encoded to Punycode. >>> iri_to_uri('http://\\u2603.net/p\\xe5th?q=\\xe8ry%DF')\n'http://xn--n3h.net/p%C3%A5th?q=%C3%A8ry%DF'\n  Parameters \n \niri (Union[str, Tuple[str, str, str, str, str]]) \u2013 The IRI to convert. \ncharset (str) \u2013 The encoding of the IRI. \nerrors (str) \u2013 Error handler to use during bytes.encode. \nsafe_conversion (bool) \u2013 Return the URL unchanged if it only contains ASCII characters and no whitespace. See the explanation below.   Return type \nstr   There is a general problem with IRI conversion with some protocols that are in violation of the URI specification. Consider the following two IRIs: magnet:?xt=uri:whatever\nitms-services://?action=download-manifest\n After parsing, we don\u2019t know if the scheme requires the //, which is dropped if empty, but conveys different meanings in the final URL if it\u2019s present or not. In this case, you can use safe_conversion, which will return the URL unchanged if it only contains ASCII characters and no whitespace. This can result in a URI with unquoted characters if it was not already quoted correctly, but preserves the URL\u2019s semantics. Werkzeug uses this for the Location header for redirects.  Changelog Changed in version 0.15: All reserved characters remain unquoted. Previously, only some reserved characters were left unquoted.   Changed in version 0.9.6: The safe_conversion parameter was added.   New in version 0.6.  \n\n"}, {"name": "is_byte_range_valid()", "path": "http/index#werkzeug.http.is_byte_range_valid", "type": "werkzeug.http", "text": " \nwerkzeug.http.is_byte_range_valid(start, stop, length)  \nChecks if a given byte content range is valid for the given length.  Changelog New in version 0.7.   Parameters \n \nstart (Optional[int]) \u2013  \nstop (Optional[int]) \u2013  \nlength (Optional[int]) \u2013    Return type \nbool   \n"}, {"name": "is_entity_header()", "path": "http/index#werkzeug.http.is_entity_header", "type": "werkzeug.http", "text": " \nwerkzeug.http.is_entity_header(header)  \nCheck if a header is an entity header.  Changelog New in version 0.5.   Parameters \nheader (str) \u2013 the header to test.  Returns \nTrue if it\u2019s an entity header, False otherwise.  Return type \nbool   \n"}, {"name": "is_hop_by_hop_header()", "path": "http/index#werkzeug.http.is_hop_by_hop_header", "type": "werkzeug.http", "text": " \nwerkzeug.http.is_hop_by_hop_header(header)  \nCheck if a header is an HTTP/1.1 \u201cHop-by-Hop\u201d header.  Changelog New in version 0.5.   Parameters \nheader (str) \u2013 the header to test.  Returns \nTrue if it\u2019s an HTTP/1.1 \u201cHop-by-Hop\u201d header, False otherwise.  Return type \nbool   \n"}, {"name": "is_resource_modified()", "path": "http/index#werkzeug.http.is_resource_modified", "type": "werkzeug.http", "text": " \nwerkzeug.http.is_resource_modified(environ, etag=None, data=None, last_modified=None, ignore_if_range=True)  \nConvenience method for conditional requests.  Parameters \n \nenviron (WSGIEnvironment) \u2013 the WSGI environment of the request to be checked. \netag (Optional[str]) \u2013 the etag for the response for comparison. \ndata (Optional[bytes]) \u2013 or alternatively the data of the response to automatically generate an etag using generate_etag(). \nlast_modified (Optional[Union[datetime.datetime, str]]) \u2013 an optional date of the last modification. \nignore_if_range (bool) \u2013 If False, If-Range header will be taken into account.   Returns \nTrue if the resource was modified, otherwise False.  Return type \nbool    Changed in version 2.0: SHA-1 is used to generate an etag value for the data. MD5 may not be available in some environments.   Changelog Changed in version 1.0.0: The check is run for methods other than GET and HEAD.  \n\n"}, {"name": "is_running_from_reloader()", "path": "serving/index#werkzeug.serving.is_running_from_reloader", "type": "werkzeug.serving", "text": " \nwerkzeug.serving.is_running_from_reloader()  \nChecks if the application is running from within the Werkzeug reloader subprocess.  Changelog New in version 0.10.   Return type \nbool   \n"}, {"name": "LanguageAccept", "path": "datastructures/index#werkzeug.datastructures.LanguageAccept", "type": "werkzeug.datastructures", "text": " \nclass werkzeug.datastructures.LanguageAccept(values=())  \nLike Accept but with normalization for language tags. \n"}, {"name": "LimitedStream", "path": "wsgi/index#werkzeug.wsgi.LimitedStream", "type": "werkzeug.wsgi", "text": " \nclass werkzeug.wsgi.LimitedStream(stream, limit)  \nWraps a stream so that it doesn\u2019t read more than n bytes. If the stream is exhausted and the caller tries to get more bytes from it on_exhausted() is called which by default returns an empty string. The return value of that function is forwarded to the reader function. So if it returns an empty string read() will return an empty string as well. The limit however must never be higher than what the stream can output. Otherwise readlines() will try to read past the limit.  Note on WSGI compliance calls to readline() and readlines() are not WSGI compliant because it passes a size argument to the readline methods. Unfortunately the WSGI PEP is not safely implementable without a size argument to readline() because there is no EOF marker in the stream. As a result of that the use of readline() is discouraged. For the same reason iterating over the LimitedStream is not portable. It internally calls readline(). We strongly suggest using read() only or using the make_line_iter() which safely iterates line-based over a WSGI input stream.   Parameters \n \nstream (BinaryIO) \u2013 the stream to wrap. \nlimit (int) \u2013 the limit for the stream, must not be longer than what the string can provide if the stream does not end with EOF (like wsgi.input)   Return type \nNone    \nexhaust(chunk_size=65536)  \nExhaust the stream. This consumes all the data left until the limit is reached.  Parameters \nchunk_size (int) \u2013 the size for a chunk. It will read the chunk until the stream is exhausted and throw away the results.  Return type \nNone   \n  \nproperty is_exhausted: bool  \nIf the stream is exhausted this attribute is True. \n  \non_disconnect()  \nWhat should happen if a disconnect is detected? The return value of this function is returned from read functions in case the client went away. By default a ClientDisconnected exception is raised.  Return type \nbytes   \n  \non_exhausted()  \nThis is called when the stream tries to read past the limit. The return value of this function is returned from the reading function.  Return type \nbytes   \n  \nread(size=None)  \nRead size bytes or if size is not provided everything is read.  Parameters \nsize (Optional[int]) \u2013 the number of bytes read.  Return type \nbytes   \n  \nreadable()  \nReturn whether object was opened for reading. If False, read() will raise OSError.  Return type \nbool   \n  \nreadline(size=None)  \nReads one line from the stream.  Parameters \nsize (Optional[int]) \u2013   Return type \nbytes   \n  \nreadlines(size=None)  \nReads a file into a list of strings. It calls readline() until the file is read to the end. It does support the optional size argument if the underlying stream supports it for readline.  Parameters \nsize (Optional[int]) \u2013   Return type \nList[bytes]   \n  \ntell()  \nReturns the position of the stream.  Changelog New in version 0.9.   Return type \nint   \n \n"}, {"name": "LimitedStream.exhaust()", "path": "wsgi/index#werkzeug.wsgi.LimitedStream.exhaust", "type": "werkzeug.wsgi", "text": " \nexhaust(chunk_size=65536)  \nExhaust the stream. This consumes all the data left until the limit is reached.  Parameters \nchunk_size (int) \u2013 the size for a chunk. It will read the chunk until the stream is exhausted and throw away the results.  Return type \nNone   \n"}, {"name": "LimitedStream.on_disconnect()", "path": "wsgi/index#werkzeug.wsgi.LimitedStream.on_disconnect", "type": "werkzeug.wsgi", "text": " \non_disconnect()  \nWhat should happen if a disconnect is detected? The return value of this function is returned from read functions in case the client went away. By default a ClientDisconnected exception is raised.  Return type \nbytes   \n"}, {"name": "LimitedStream.on_exhausted()", "path": "wsgi/index#werkzeug.wsgi.LimitedStream.on_exhausted", "type": "werkzeug.wsgi", "text": " \non_exhausted()  \nThis is called when the stream tries to read past the limit. The return value of this function is returned from the reading function.  Return type \nbytes   \n"}, {"name": "LimitedStream.read()", "path": "wsgi/index#werkzeug.wsgi.LimitedStream.read", "type": "werkzeug.wsgi", "text": " \nread(size=None)  \nRead size bytes or if size is not provided everything is read.  Parameters \nsize (Optional[int]) \u2013 the number of bytes read.  Return type \nbytes   \n"}, {"name": "LimitedStream.readable()", "path": "wsgi/index#werkzeug.wsgi.LimitedStream.readable", "type": "werkzeug.wsgi", "text": " \nreadable()  \nReturn whether object was opened for reading. If False, read() will raise OSError.  Return type \nbool   \n"}, {"name": "LimitedStream.readline()", "path": "wsgi/index#werkzeug.wsgi.LimitedStream.readline", "type": "werkzeug.wsgi", "text": " \nreadline(size=None)  \nReads one line from the stream.  Parameters \nsize (Optional[int]) \u2013   Return type \nbytes   \n"}, {"name": "LimitedStream.readlines()", "path": "wsgi/index#werkzeug.wsgi.LimitedStream.readlines", "type": "werkzeug.wsgi", "text": " \nreadlines(size=None)  \nReads a file into a list of strings. It calls readline() until the file is read to the end. It does support the optional size argument if the underlying stream supports it for readline.  Parameters \nsize (Optional[int]) \u2013   Return type \nList[bytes]   \n"}, {"name": "LimitedStream.tell()", "path": "wsgi/index#werkzeug.wsgi.LimitedStream.tell", "type": "werkzeug.wsgi", "text": " \ntell()  \nReturns the position of the stream.  Changelog New in version 0.9.   Return type \nint   \n"}, {"name": "LintMiddleware", "path": "middleware/lint/index#werkzeug.middleware.lint.LintMiddleware", "type": "werkzeug.middleware.lint", "text": " \nclass werkzeug.middleware.lint.LintMiddleware(app)  \nWarns about common errors in the WSGI and HTTP behavior of the server and wrapped application. Some of the issues it checks are:  invalid status codes non-bytes sent to the WSGI server strings returned from the WSGI application non-empty conditional responses unquoted etags relative URLs in the Location header unsafe calls to wsgi.input unclosed iterators  Error information is emitted using the warnings module.  Parameters \napp (WSGIApplication) \u2013 The WSGI application to wrap.  Return type \nNone   from werkzeug.middleware.lint import LintMiddleware\napp = LintMiddleware(app)\n \n"}, {"name": "LocalManager", "path": "local/index#werkzeug.local.LocalManager", "type": "werkzeug.local", "text": " \nclass werkzeug.local.LocalManager(locals=None, ident_func=None)  \nLocal objects cannot manage themselves. For that you need a local manager. You can pass a local manager multiple locals or add them later y appending them to manager.locals. Every time the manager cleans up, it will clean up all the data left in the locals for this context.  Changed in version 2.0: ident_func is deprecated and will be removed in Werkzeug 2.1.   Changelog Changed in version 0.7: The ident_func parameter was added.   Changed in version 0.6.1: The release_local() function can be used instead of a manager.   Parameters \n \nlocals (Optional[Iterable[Union[werkzeug.local.Local, werkzeug.local.LocalStack]]]) \u2013  \nident_func (None) \u2013    Return type \nNone    \ncleanup()  \nManually clean up the data in the locals for this context. Call this at the end of the request or use make_middleware().  Return type \nNone   \n  \nget_ident()  \nReturn the context identifier the local objects use internally for this context. You cannot override this method to change the behavior but use it to link other context local objects (such as SQLAlchemy\u2019s scoped sessions) to the Werkzeug locals.  Deprecated since version 2.0: Will be removed in Werkzeug 2.1.   Changelog Changed in version 0.7: You can pass a different ident function to the local manager that will then be propagated to all the locals passed to the constructor.   Return type \nint   \n  \nmake_middleware(app)  \nWrap a WSGI application so that cleaning up happens after request end.  Parameters \napp (WSGIApplication) \u2013   Return type \nWSGIApplication   \n  \nmiddleware(func)  \nLike make_middleware but for decorating functions. Example usage: @manager.middleware\ndef application(environ, start_response):\n    ...\n The difference to make_middleware is that the function passed will have all the arguments copied from the inner application (name, docstring, module).  Parameters \nfunc (WSGIApplication) \u2013   Return type \nWSGIApplication   \n \n"}, {"name": "LocalManager.cleanup()", "path": "local/index#werkzeug.local.LocalManager.cleanup", "type": "werkzeug.local", "text": " \ncleanup()  \nManually clean up the data in the locals for this context. Call this at the end of the request or use make_middleware().  Return type \nNone   \n"}, {"name": "LocalManager.get_ident()", "path": "local/index#werkzeug.local.LocalManager.get_ident", "type": "werkzeug.local", "text": " \nget_ident()  \nReturn the context identifier the local objects use internally for this context. You cannot override this method to change the behavior but use it to link other context local objects (such as SQLAlchemy\u2019s scoped sessions) to the Werkzeug locals.  Deprecated since version 2.0: Will be removed in Werkzeug 2.1.   Changelog Changed in version 0.7: You can pass a different ident function to the local manager that will then be propagated to all the locals passed to the constructor.   Return type \nint   \n"}, {"name": "LocalManager.make_middleware()", "path": "local/index#werkzeug.local.LocalManager.make_middleware", "type": "werkzeug.local", "text": " \nmake_middleware(app)  \nWrap a WSGI application so that cleaning up happens after request end.  Parameters \napp (WSGIApplication) \u2013   Return type \nWSGIApplication   \n"}, {"name": "LocalManager.middleware()", "path": "local/index#werkzeug.local.LocalManager.middleware", "type": "werkzeug.local", "text": " \nmiddleware(func)  \nLike make_middleware but for decorating functions. Example usage: @manager.middleware\ndef application(environ, start_response):\n    ...\n The difference to make_middleware is that the function passed will have all the arguments copied from the inner application (name, docstring, module).  Parameters \nfunc (WSGIApplication) \u2013   Return type \nWSGIApplication   \n"}, {"name": "LocalProxy", "path": "local/index#werkzeug.local.LocalProxy", "type": "werkzeug.local", "text": " \nclass werkzeug.local.LocalProxy(local, name=None)  \nA proxy to the object bound to a Local. All operations on the proxy are forwarded to the bound object. If no object is bound, a RuntimeError is raised. from werkzeug.local import Local\nl = Local()\n\n# a proxy to whatever l.user is set to\nuser = l(\"user\")\n\nfrom werkzeug.local import LocalStack\n_request_stack = LocalStack()\n\n# a proxy to _request_stack.top\nrequest = _request_stack()\n\n# a proxy to the session attribute of the request proxy\nsession = LocalProxy(lambda: request.session)\n __repr__ and __class__ are forwarded, so repr(x) and isinstance(x, cls) will look like the proxied object. Use issubclass(type(x), LocalProxy) to check if an object is a proxy. repr(user)  # <User admin>\nisinstance(user, User)  # True\nissubclass(type(user), LocalProxy)  # True\n  Parameters \n \nlocal \u2013 The Local or callable that provides the proxied object. \nname \u2013 The attribute name to look up on a Local. Not used if a callable is given.     Changed in version 2.0: Updated proxied attributes and methods to reflect the current data model.   Changelog Changed in version 0.6.1: The class can be instantiated with a callable.   \n_get_current_object()  \nReturn the current object. This is useful if you want the real object behind the proxy at a time for performance reasons or because you want to pass the object into a different context.  Return type \nAny   \n \n"}, {"name": "LocalProxy._get_current_object()", "path": "local/index#werkzeug.local.LocalProxy._get_current_object", "type": "werkzeug.local", "text": " \n_get_current_object()  \nReturn the current object. This is useful if you want the real object behind the proxy at a time for performance reasons or because you want to pass the object into a different context.  Return type \nAny   \n"}, {"name": "LocalStack", "path": "local/index#werkzeug.local.LocalStack", "type": "werkzeug.local", "text": " \nclass werkzeug.local.LocalStack  \nThis class works similar to a Local but keeps a stack of objects instead. This is best explained with an example: >>> ls = LocalStack()\n>>> ls.push(42)\n>>> ls.top\n42\n>>> ls.push(23)\n>>> ls.top\n23\n>>> ls.pop()\n23\n>>> ls.top\n42\n They can be force released by using a LocalManager or with the release_local() function but the correct way is to pop the item from the stack after using. When the stack is empty it will no longer be bound to the current context (and as such released). By calling the stack without arguments it returns a proxy that resolves to the topmost item on the stack.  Changelog New in version 0.6.1.   Return type \nNone    \npop()  \nRemoves the topmost item from the stack, will return the old value or None if the stack was already empty.  Return type \nAny   \n  \npush(obj)  \nPushes a new item to the stack  Parameters \nobj (Any) \u2013   Return type \nList[Any]   \n  \nproperty top: Any  \nThe topmost item on the stack. If the stack is empty, None is returned. \n \n"}, {"name": "LocalStack.pop()", "path": "local/index#werkzeug.local.LocalStack.pop", "type": "werkzeug.local", "text": " \npop()  \nRemoves the topmost item from the stack, will return the old value or None if the stack was already empty.  Return type \nAny   \n"}, {"name": "LocalStack.push()", "path": "local/index#werkzeug.local.LocalStack.push", "type": "werkzeug.local", "text": " \npush(obj)  \nPushes a new item to the stack  Parameters \nobj (Any) \u2013   Return type \nList[Any]   \n"}, {"name": "make_chunk_iter()", "path": "wsgi/index#werkzeug.wsgi.make_chunk_iter", "type": "werkzeug.wsgi", "text": " \nwerkzeug.wsgi.make_chunk_iter(stream, separator, limit=None, buffer_size=10240, cap_at_buffer=False)  \nWorks like make_line_iter() but accepts a separator which divides chunks. If you want newline based processing you should use make_line_iter() instead as it supports arbitrary newline markers.  Changelog New in version 0.11.10: added support for the cap_at_buffer parameter.   New in version 0.9: added support for iterators as input stream.   New in version 0.8.   Parameters \n \nstream (Union[Iterable[bytes], BinaryIO]) \u2013 the stream or iterate to iterate over. \nseparator (bytes) \u2013 the separator that divides chunks. \nlimit (Optional[int]) \u2013 the limit in bytes for the stream. (Usually content length. Not necessary if the stream is otherwise already limited). \nbuffer_size (int) \u2013 The optional buffer size. \ncap_at_buffer (bool) \u2013 if this is set chunks are split if they are longer than the buffer size. Internally this is implemented that the buffer size might be exhausted by a factor of two however.   Return type \nIterator[bytes]   \n"}, {"name": "make_line_iter()", "path": "wsgi/index#werkzeug.wsgi.make_line_iter", "type": "werkzeug.wsgi", "text": " \nwerkzeug.wsgi.make_line_iter(stream, limit=None, buffer_size=10240, cap_at_buffer=False)  \nSafely iterates line-based over an input stream. If the input stream is not a LimitedStream the limit parameter is mandatory. This uses the stream\u2019s read() method internally as opposite to the readline() method that is unsafe and can only be used in violation of the WSGI specification. The same problem applies to the __iter__ function of the input stream which calls readline() without arguments. If you need line-by-line processing it\u2019s strongly recommended to iterate over the input stream using this helper function.  Changelog New in version 0.11.10: added support for the cap_at_buffer parameter.   New in version 0.9: added support for iterators as input stream.   Changed in version 0.8: This function now ensures that the limit was reached.   Parameters \n \nstream (Union[Iterable[bytes], BinaryIO]) \u2013 the stream or iterate to iterate over. \nlimit (Optional[int]) \u2013 the limit in bytes for the stream. (Usually content length. Not necessary if the stream is a LimitedStream. \nbuffer_size (int) \u2013 The optional buffer size. \ncap_at_buffer (bool) \u2013 if this is set chunks are split if they are longer than the buffer size. Internally this is implemented that the buffer size might be exhausted by a factor of two however.   Return type \nIterator[bytes]   \n"}, {"name": "make_ssl_devcert()", "path": "serving/index#werkzeug.serving.make_ssl_devcert", "type": "werkzeug.serving", "text": " \nwerkzeug.serving.make_ssl_devcert(base_path, host=None, cn=None)  \nCreates an SSL key for development. This should be used instead of the 'adhoc' key which generates a new cert on each server start. It accepts a path for where it should store the key and cert and either a host or CN. If a host is given it will use the CN *.host/CN=host. For more information see run_simple().  Changelog New in version 0.9.   Parameters \n \nbase_path (str) \u2013 the path to the certificate and key. The extension .crt is added for the certificate, .key is added for the key. \nhost (Optional[str]) \u2013 the name of the host. This can be used as an alternative for the cn. \ncn (Optional[str]) \u2013 the CN to use.   Return type \nTuple[str, str]   \n"}, {"name": "Map", "path": "routing/index#werkzeug.routing.Map", "type": "werkzeug.routing", "text": " \nclass werkzeug.routing.Map(rules=None, default_subdomain='', charset='utf-8', strict_slashes=True, merge_slashes=True, redirect_defaults=True, converters=None, sort_parameters=False, sort_key=None, encoding_errors='replace', host_matching=False)  \nThe map class stores all the URL rules and some configuration parameters. Some of the configuration values are only stored on the Map instance since those affect all rules, others are just defaults and can be overridden for each rule. Note that you have to specify all arguments besides the rules as keyword arguments!  Parameters \n \nrules (Optional[Iterable[werkzeug.routing.RuleFactory]]) \u2013 sequence of url rules for this map. \ndefault_subdomain (str) \u2013 The default subdomain for rules without a subdomain defined. \ncharset (str) \u2013 charset of the url. defaults to \"utf-8\"\n \nstrict_slashes (bool) \u2013 If a rule ends with a slash but the matched URL does not, redirect to the URL with a trailing slash. \nmerge_slashes (bool) \u2013 Merge consecutive slashes when matching or building URLs. Matches will redirect to the normalized URL. Slashes in variable parts are not merged. \nredirect_defaults (bool) \u2013 This will redirect to the default rule if it wasn\u2019t visited that way. This helps creating unique URLs. \nconverters (Optional[Mapping[str, Type[werkzeug.routing.BaseConverter]]]) \u2013 A dict of converters that adds additional converters to the list of converters. If you redefine one converter this will override the original one. \nsort_parameters (bool) \u2013 If set to True the url parameters are sorted. See url_encode for more details. \nsort_key (Optional[Callable[[Any], Any]]) \u2013 The sort key function for url_encode. \nencoding_errors (str) \u2013 the error method to use for decoding \nhost_matching (bool) \u2013 if set to True it enables the host matching feature and disables the subdomain one. If enabled the host parameter to rules is used instead of the subdomain one.   Return type \nNone    Changelog Changed in version 1.0: If url_scheme is ws or wss, only WebSocket rules will match.   Changed in version 1.0: Added merge_slashes.   Changed in version 0.7: Added encoding_errors and host_matching.   Changed in version 0.5: Added sort_parameters and sort_key.   \nconverters  \nThe dictionary of converters. This can be modified after the class was created, but will only affect rules added after the modification. If the rules are defined with the list passed to the class, the converters parameter to the constructor has to be used instead. \n  \nadd(rulefactory)  \nAdd a new rule or factory to the map and bind it. Requires that the rule is not bound to another map.  Parameters \nrulefactory (werkzeug.routing.RuleFactory) \u2013 a Rule or RuleFactory  Return type \nNone   \n  \nbind(server_name, script_name=None, subdomain=None, url_scheme='http', default_method='GET', path_info=None, query_args=None)  \nReturn a new MapAdapter with the details specified to the call. Note that script_name will default to '/' if not further specified or None. The server_name at least is a requirement because the HTTP RFC requires absolute URLs for redirects and so all redirect exceptions raised by Werkzeug will contain the full canonical URL. If no path_info is passed to match() it will use the default path info passed to bind. While this doesn\u2019t really make sense for manual bind calls, it\u2019s useful if you bind a map to a WSGI environment which already contains the path info. subdomain will default to the default_subdomain for this map if no defined. If there is no default_subdomain you cannot use the subdomain feature.  Changelog Changed in version 1.0: If url_scheme is ws or wss, only WebSocket rules will match.   Changed in version 0.15: path_info defaults to '/' if None.   Changed in version 0.8: query_args can be a string.   Changed in version 0.7: Added query_args.   Parameters \n \nserver_name (str) \u2013  \nscript_name (Optional[str]) \u2013  \nsubdomain (Optional[str]) \u2013  \nurl_scheme (str) \u2013  \ndefault_method (str) \u2013  \npath_info (Optional[str]) \u2013  \nquery_args (Optional[Union[Mapping[str, Any], str]]) \u2013    Return type \nwerkzeug.routing.MapAdapter   \n  \nbind_to_environ(environ, server_name=None, subdomain=None)  \nLike bind() but you can pass it an WSGI environment and it will fetch the information from that dictionary. Note that because of limitations in the protocol there is no way to get the current subdomain and real server_name from the environment. If you don\u2019t provide it, Werkzeug will use SERVER_NAME and SERVER_PORT (or HTTP_HOST if provided) as used server_name with disabled subdomain feature. If subdomain is None but an environment and a server name is provided it will calculate the current subdomain automatically. Example: server_name is 'example.com' and the SERVER_NAME in the wsgi environ is 'staging.dev.example.com' the calculated subdomain will be 'staging.dev'. If the object passed as environ has an environ attribute, the value of this attribute is used instead. This allows you to pass request objects. Additionally PATH_INFO added as a default of the MapAdapter so that you don\u2019t have to pass the path info to the match method.  Changelog Changed in version 1.0.0: If the passed server name specifies port 443, it will match if the incoming scheme is https without a port.   Changed in version 1.0.0: A warning is shown when the passed server name does not match the incoming WSGI server name.   Changed in version 0.8: This will no longer raise a ValueError when an unexpected server name was passed.   Changed in version 0.5: previously this method accepted a bogus calculate_subdomain parameter that did not have any effect. It was removed because of that.   Parameters \n \nenviron (WSGIEnvironment) \u2013 a WSGI environment. \nserver_name (Optional[str]) \u2013 an optional server name hint (see above). \nsubdomain (Optional[str]) \u2013 optionally the current subdomain (see above).   Return type \nMapAdapter   \n  \ndefault_converters = {'any': <class 'werkzeug.routing.AnyConverter'>, 'default': <class 'werkzeug.routing.UnicodeConverter'>, 'float': <class 'werkzeug.routing.FloatConverter'>, 'int': <class 'werkzeug.routing.IntegerConverter'>, 'path': <class 'werkzeug.routing.PathConverter'>, 'string': <class 'werkzeug.routing.UnicodeConverter'>, 'uuid': <class 'werkzeug.routing.UUIDConverter'>}  \nA dict of default converters to be used. \n  \nis_endpoint_expecting(endpoint, *arguments)  \nIterate over all rules and check if the endpoint expects the arguments provided. This is for example useful if you have some URLs that expect a language code and others that do not and you want to wrap the builder a bit so that the current language code is automatically added if not provided but endpoints expect it.  Parameters \n \nendpoint (str) \u2013 the endpoint to check. \narguments (str) \u2013 this function accepts one or more arguments as positional arguments. Each one of them is checked.   Return type \nbool   \n  \niter_rules(endpoint=None)  \nIterate over all rules or the rules of an endpoint.  Parameters \nendpoint (Optional[str]) \u2013 if provided only the rules for that endpoint are returned.  Returns \nan iterator  Return type \nIterator[werkzeug.routing.Rule]   \n  \nlock_class()  \nThe type of lock to use when updating.  Changelog New in version 1.0.  \n\n  \nupdate()  \nCalled before matching and building to keep the compiled rules in the correct order after things changed.  Return type \nNone   \n \n"}, {"name": "Map.add()", "path": "routing/index#werkzeug.routing.Map.add", "type": "werkzeug.routing", "text": " \nadd(rulefactory)  \nAdd a new rule or factory to the map and bind it. Requires that the rule is not bound to another map.  Parameters \nrulefactory (werkzeug.routing.RuleFactory) \u2013 a Rule or RuleFactory  Return type \nNone   \n"}, {"name": "Map.bind()", "path": "routing/index#werkzeug.routing.Map.bind", "type": "werkzeug.routing", "text": " \nbind(server_name, script_name=None, subdomain=None, url_scheme='http', default_method='GET', path_info=None, query_args=None)  \nReturn a new MapAdapter with the details specified to the call. Note that script_name will default to '/' if not further specified or None. The server_name at least is a requirement because the HTTP RFC requires absolute URLs for redirects and so all redirect exceptions raised by Werkzeug will contain the full canonical URL. If no path_info is passed to match() it will use the default path info passed to bind. While this doesn\u2019t really make sense for manual bind calls, it\u2019s useful if you bind a map to a WSGI environment which already contains the path info. subdomain will default to the default_subdomain for this map if no defined. If there is no default_subdomain you cannot use the subdomain feature.  Changelog Changed in version 1.0: If url_scheme is ws or wss, only WebSocket rules will match.   Changed in version 0.15: path_info defaults to '/' if None.   Changed in version 0.8: query_args can be a string.   Changed in version 0.7: Added query_args.   Parameters \n \nserver_name (str) \u2013  \nscript_name (Optional[str]) \u2013  \nsubdomain (Optional[str]) \u2013  \nurl_scheme (str) \u2013  \ndefault_method (str) \u2013  \npath_info (Optional[str]) \u2013  \nquery_args (Optional[Union[Mapping[str, Any], str]]) \u2013    Return type \nwerkzeug.routing.MapAdapter   \n"}, {"name": "Map.bind_to_environ()", "path": "routing/index#werkzeug.routing.Map.bind_to_environ", "type": "werkzeug.routing", "text": " \nbind_to_environ(environ, server_name=None, subdomain=None)  \nLike bind() but you can pass it an WSGI environment and it will fetch the information from that dictionary. Note that because of limitations in the protocol there is no way to get the current subdomain and real server_name from the environment. If you don\u2019t provide it, Werkzeug will use SERVER_NAME and SERVER_PORT (or HTTP_HOST if provided) as used server_name with disabled subdomain feature. If subdomain is None but an environment and a server name is provided it will calculate the current subdomain automatically. Example: server_name is 'example.com' and the SERVER_NAME in the wsgi environ is 'staging.dev.example.com' the calculated subdomain will be 'staging.dev'. If the object passed as environ has an environ attribute, the value of this attribute is used instead. This allows you to pass request objects. Additionally PATH_INFO added as a default of the MapAdapter so that you don\u2019t have to pass the path info to the match method.  Changelog Changed in version 1.0.0: If the passed server name specifies port 443, it will match if the incoming scheme is https without a port.   Changed in version 1.0.0: A warning is shown when the passed server name does not match the incoming WSGI server name.   Changed in version 0.8: This will no longer raise a ValueError when an unexpected server name was passed.   Changed in version 0.5: previously this method accepted a bogus calculate_subdomain parameter that did not have any effect. It was removed because of that.   Parameters \n \nenviron (WSGIEnvironment) \u2013 a WSGI environment. \nserver_name (Optional[str]) \u2013 an optional server name hint (see above). \nsubdomain (Optional[str]) \u2013 optionally the current subdomain (see above).   Return type \nMapAdapter   \n"}, {"name": "Map.converters", "path": "routing/index#werkzeug.routing.Map.converters", "type": "werkzeug.routing", "text": " \nconverters  \nThe dictionary of converters. This can be modified after the class was created, but will only affect rules added after the modification. If the rules are defined with the list passed to the class, the converters parameter to the constructor has to be used instead. \n"}, {"name": "Map.default_converters", "path": "routing/index#werkzeug.routing.Map.default_converters", "type": "werkzeug.routing", "text": " \ndefault_converters = {'any': <class 'werkzeug.routing.AnyConverter'>, 'default': <class 'werkzeug.routing.UnicodeConverter'>, 'float': <class 'werkzeug.routing.FloatConverter'>, 'int': <class 'werkzeug.routing.IntegerConverter'>, 'path': <class 'werkzeug.routing.PathConverter'>, 'string': <class 'werkzeug.routing.UnicodeConverter'>, 'uuid': <class 'werkzeug.routing.UUIDConverter'>}  \nA dict of default converters to be used. \n"}, {"name": "Map.is_endpoint_expecting()", "path": "routing/index#werkzeug.routing.Map.is_endpoint_expecting", "type": "werkzeug.routing", "text": " \nis_endpoint_expecting(endpoint, *arguments)  \nIterate over all rules and check if the endpoint expects the arguments provided. This is for example useful if you have some URLs that expect a language code and others that do not and you want to wrap the builder a bit so that the current language code is automatically added if not provided but endpoints expect it.  Parameters \n \nendpoint (str) \u2013 the endpoint to check. \narguments (str) \u2013 this function accepts one or more arguments as positional arguments. Each one of them is checked.   Return type \nbool   \n"}, {"name": "Map.iter_rules()", "path": "routing/index#werkzeug.routing.Map.iter_rules", "type": "werkzeug.routing", "text": " \niter_rules(endpoint=None)  \nIterate over all rules or the rules of an endpoint.  Parameters \nendpoint (Optional[str]) \u2013 if provided only the rules for that endpoint are returned.  Returns \nan iterator  Return type \nIterator[werkzeug.routing.Rule]   \n"}, {"name": "Map.lock_class()", "path": "routing/index#werkzeug.routing.Map.lock_class", "type": "werkzeug.routing", "text": " \nlock_class()  \nThe type of lock to use when updating.  Changelog New in version 1.0.  \n\n"}, {"name": "Map.update()", "path": "routing/index#werkzeug.routing.Map.update", "type": "werkzeug.routing", "text": " \nupdate()  \nCalled before matching and building to keep the compiled rules in the correct order after things changed.  Return type \nNone   \n"}, {"name": "MapAdapter", "path": "routing/index#werkzeug.routing.MapAdapter", "type": "werkzeug.routing", "text": " \nclass werkzeug.routing.MapAdapter(map, server_name, script_name, subdomain, url_scheme, path_info, default_method, query_args=None)  \nReturned by Map.bind() or Map.bind_to_environ() and does the URL matching and building based on runtime information.  Parameters \n \nmap (werkzeug.routing.Map) \u2013  \nserver_name (str) \u2013  \nscript_name (str) \u2013  \nsubdomain (Optional[str]) \u2013  \nurl_scheme (str) \u2013  \npath_info (str) \u2013  \ndefault_method (str) \u2013  \nquery_args (Optional[Union[Mapping[str, Any], str]]) \u2013      \nallowed_methods(path_info=None)  \nReturns the valid methods that match for a given path.  Changelog New in version 0.7.   Parameters \npath_info (Optional[str]) \u2013   Return type \nIterable[str]   \n  \nbuild(endpoint, values=None, method=None, force_external=False, append_unknown=True, url_scheme=None)  \nBuilding URLs works pretty much the other way round. Instead of match you call build and pass it the endpoint and a dict of arguments for the placeholders. The build function also accepts an argument called force_external which, if you set it to True will force external URLs. Per default external URLs (include the server name) will only be used if the target URL is on a different subdomain. >>> m = Map([\n...     Rule('/', endpoint='index'),\n...     Rule('/downloads/', endpoint='downloads/index'),\n...     Rule('/downloads/<int:id>', endpoint='downloads/show')\n... ])\n>>> urls = m.bind(\"example.com\", \"/\")\n>>> urls.build(\"index\", {})\n'/'\n>>> urls.build(\"downloads/show\", {'id': 42})\n'/downloads/42'\n>>> urls.build(\"downloads/show\", {'id': 42}, force_external=True)\n'http://example.com/downloads/42'\n Because URLs cannot contain non ASCII data you will always get bytes back. Non ASCII characters are urlencoded with the charset defined on the map instance. Additional values are converted to strings and appended to the URL as URL querystring parameters: >>> urls.build(\"index\", {'q': 'My Searchstring'})\n'/?q=My+Searchstring'\n When processing those additional values, lists are furthermore interpreted as multiple values (as per werkzeug.datastructures.MultiDict): >>> urls.build(\"index\", {'q': ['a', 'b', 'c']})\n'/?q=a&q=b&q=c'\n Passing a MultiDict will also add multiple values: >>> urls.build(\"index\", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))\n'/?p=z&q=a&q=b'\n If a rule does not exist when building a BuildError exception is raised. The build method accepts an argument called method which allows you to specify the method you want to have an URL built for if you have different methods for the same endpoint specified.  Parameters \n \nendpoint (str) \u2013 the endpoint of the URL to build. \nvalues (Optional[Mapping[str, Any]]) \u2013 the values for the URL to build. Unhandled values are appended to the URL as query parameters. \nmethod (Optional[str]) \u2013 the HTTP method for the rule if there are different URLs for different methods on the same endpoint. \nforce_external (bool) \u2013 enforce full canonical external URLs. If the URL scheme is not provided, this will generate a protocol-relative URL. \nappend_unknown (bool) \u2013 unknown parameters are appended to the generated URL as query string argument. Disable this if you want the builder to ignore those. \nurl_scheme (Optional[str]) \u2013 Scheme to use in place of the bound url_scheme.   Return type \nstr    Changed in version 2.0: Added the url_scheme parameter.   Changelog New in version 0.6: Added the append_unknown parameter.  \n\n  \ndispatch(view_func, path_info=None, method=None, catch_http_exceptions=False)  \nDoes the complete dispatching process. view_func is called with the endpoint and a dict with the values for the view. It should look up the view function, call it, and return a response object or WSGI application. http exceptions are not caught by default so that applications can display nicer error messages by just catching them by hand. If you want to stick with the default error messages you can pass it catch_http_exceptions=True and it will catch the http exceptions. Here a small example for the dispatch usage: from werkzeug.wrappers import Request, Response\nfrom werkzeug.wsgi import responder\nfrom werkzeug.routing import Map, Rule\n\ndef on_index(request):\n    return Response('Hello from the index')\n\nurl_map = Map([Rule('/', endpoint='index')])\nviews = {'index': on_index}\n\n@responder\ndef application(environ, start_response):\n    request = Request(environ)\n    urls = url_map.bind_to_environ(environ)\n    return urls.dispatch(lambda e, v: views[e](request, **v),\n                         catch_http_exceptions=True)\n Keep in mind that this method might return exception objects, too, so use Response.force_type to get a response object.  Parameters \n \nview_func (Callable[[str, Mapping[str, Any]], WSGIApplication]) \u2013 a function that is called with the endpoint as first argument and the value dict as second. Has to dispatch to the actual view function with this information. (see above) \npath_info (Optional[str]) \u2013 the path info to use for matching. Overrides the path info specified on binding. \nmethod (Optional[str]) \u2013 the HTTP method used for matching. Overrides the method specified on binding. \ncatch_http_exceptions (bool) \u2013 set to True to catch any of the werkzeug HTTPExceptions.   Return type \nWSGIApplication   \n  \nget_host(domain_part)  \nFigures out the full host name for the given domain part. The domain part is a subdomain in case host matching is disabled or a full host name.  Parameters \ndomain_part (Optional[str]) \u2013   Return type \nstr   \n  \nmake_alias_redirect_url(path, endpoint, values, method, query_args)  \nInternally called to make an alias redirect URL.  Parameters \n \npath (str) \u2013  \nendpoint (str) \u2013  \nvalues (Mapping[str, Any]) \u2013  \nmethod (str) \u2013  \nquery_args (Union[Mapping[str, Any], str]) \u2013    Return type \nstr   \n  \nmatch(path_info=None, method=None, return_rule=False, query_args=None, websocket=None)  \nThe usage is simple: you just pass the match method the current path info as well as the method (which defaults to GET). The following things can then happen:  you receive a NotFound exception that indicates that no URL is matching. A NotFound exception is also a WSGI application you can call to get a default page not found page (happens to be the same object as werkzeug.exceptions.NotFound) you receive a MethodNotAllowed exception that indicates that there is a match for this URL but not for the current request method. This is useful for RESTful applications. you receive a RequestRedirect exception with a new_url attribute. This exception is used to notify you about a request Werkzeug requests from your WSGI application. This is for example the case if you request /foo although the correct URL is /foo/ You can use the RequestRedirect instance as response-like object similar to all other subclasses of HTTPException. you receive a WebsocketMismatch exception if the only match is a WebSocket rule but the bind is an HTTP request, or if the match is an HTTP rule but the bind is a WebSocket request. you get a tuple in the form (endpoint, arguments) if there is a match (unless return_rule is True, in which case you get a tuple in the form (rule, arguments))  If the path info is not passed to the match method the default path info of the map is used (defaults to the root URL if not defined explicitly). All of the exceptions raised are subclasses of HTTPException so they can be used as WSGI responses. They will all render generic error or redirect pages. Here is a small example for matching: >>> m = Map([\n...     Rule('/', endpoint='index'),\n...     Rule('/downloads/', endpoint='downloads/index'),\n...     Rule('/downloads/<int:id>', endpoint='downloads/show')\n... ])\n>>> urls = m.bind(\"example.com\", \"/\")\n>>> urls.match(\"/\", \"GET\")\n('index', {})\n>>> urls.match(\"/downloads/42\")\n('downloads/show', {'id': 42})\n And here is what happens on redirect and missing URLs: >>> urls.match(\"/downloads\")\nTraceback (most recent call last):\n  ...\nRequestRedirect: http://example.com/downloads/\n>>> urls.match(\"/missing\")\nTraceback (most recent call last):\n  ...\nNotFound: 404 Not Found\n  Parameters \n \npath_info (Optional[str]) \u2013 the path info to use for matching. Overrides the path info specified on binding. \nmethod (Optional[str]) \u2013 the HTTP method used for matching. Overrides the method specified on binding. \nreturn_rule (bool) \u2013 return the rule that matched instead of just the endpoint (defaults to False). \nquery_args (Optional[Union[Mapping[str, Any], str]]) \u2013 optional query arguments that are used for automatic redirects as string or dictionary. It\u2019s currently not possible to use the query arguments for URL matching. \nwebsocket (Optional[bool]) \u2013 Match WebSocket instead of HTTP requests. A websocket request has a ws or wss url_scheme. This overrides that detection.   Return type \nTuple[Union[str, werkzeug.routing.Rule], Mapping[str, Any]]    Changelog New in version 1.0: Added websocket.   Changed in version 0.8: query_args can be a string.   New in version 0.7: Added query_args.   New in version 0.6: Added return_rule.  \n\n  \ntest(path_info=None, method=None)  \nTest if a rule would match. Works like match but returns True if the URL matches, or False if it does not exist.  Parameters \n \npath_info (Optional[str]) \u2013 the path info to use for matching. Overrides the path info specified on binding. \nmethod (Optional[str]) \u2013 the HTTP method used for matching. Overrides the method specified on binding.   Return type \nbool   \n \n"}, {"name": "MapAdapter.allowed_methods()", "path": "routing/index#werkzeug.routing.MapAdapter.allowed_methods", "type": "werkzeug.routing", "text": " \nallowed_methods(path_info=None)  \nReturns the valid methods that match for a given path.  Changelog New in version 0.7.   Parameters \npath_info (Optional[str]) \u2013   Return type \nIterable[str]   \n"}, {"name": "MapAdapter.build()", "path": "routing/index#werkzeug.routing.MapAdapter.build", "type": "werkzeug.routing", "text": " \nbuild(endpoint, values=None, method=None, force_external=False, append_unknown=True, url_scheme=None)  \nBuilding URLs works pretty much the other way round. Instead of match you call build and pass it the endpoint and a dict of arguments for the placeholders. The build function also accepts an argument called force_external which, if you set it to True will force external URLs. Per default external URLs (include the server name) will only be used if the target URL is on a different subdomain. >>> m = Map([\n...     Rule('/', endpoint='index'),\n...     Rule('/downloads/', endpoint='downloads/index'),\n...     Rule('/downloads/<int:id>', endpoint='downloads/show')\n... ])\n>>> urls = m.bind(\"example.com\", \"/\")\n>>> urls.build(\"index\", {})\n'/'\n>>> urls.build(\"downloads/show\", {'id': 42})\n'/downloads/42'\n>>> urls.build(\"downloads/show\", {'id': 42}, force_external=True)\n'http://example.com/downloads/42'\n Because URLs cannot contain non ASCII data you will always get bytes back. Non ASCII characters are urlencoded with the charset defined on the map instance. Additional values are converted to strings and appended to the URL as URL querystring parameters: >>> urls.build(\"index\", {'q': 'My Searchstring'})\n'/?q=My+Searchstring'\n When processing those additional values, lists are furthermore interpreted as multiple values (as per werkzeug.datastructures.MultiDict): >>> urls.build(\"index\", {'q': ['a', 'b', 'c']})\n'/?q=a&q=b&q=c'\n Passing a MultiDict will also add multiple values: >>> urls.build(\"index\", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))\n'/?p=z&q=a&q=b'\n If a rule does not exist when building a BuildError exception is raised. The build method accepts an argument called method which allows you to specify the method you want to have an URL built for if you have different methods for the same endpoint specified.  Parameters \n \nendpoint (str) \u2013 the endpoint of the URL to build. \nvalues (Optional[Mapping[str, Any]]) \u2013 the values for the URL to build. Unhandled values are appended to the URL as query parameters. \nmethod (Optional[str]) \u2013 the HTTP method for the rule if there are different URLs for different methods on the same endpoint. \nforce_external (bool) \u2013 enforce full canonical external URLs. If the URL scheme is not provided, this will generate a protocol-relative URL. \nappend_unknown (bool) \u2013 unknown parameters are appended to the generated URL as query string argument. Disable this if you want the builder to ignore those. \nurl_scheme (Optional[str]) \u2013 Scheme to use in place of the bound url_scheme.   Return type \nstr    Changed in version 2.0: Added the url_scheme parameter.   Changelog New in version 0.6: Added the append_unknown parameter.  \n\n"}, {"name": "MapAdapter.dispatch()", "path": "routing/index#werkzeug.routing.MapAdapter.dispatch", "type": "werkzeug.routing", "text": " \ndispatch(view_func, path_info=None, method=None, catch_http_exceptions=False)  \nDoes the complete dispatching process. view_func is called with the endpoint and a dict with the values for the view. It should look up the view function, call it, and return a response object or WSGI application. http exceptions are not caught by default so that applications can display nicer error messages by just catching them by hand. If you want to stick with the default error messages you can pass it catch_http_exceptions=True and it will catch the http exceptions. Here a small example for the dispatch usage: from werkzeug.wrappers import Request, Response\nfrom werkzeug.wsgi import responder\nfrom werkzeug.routing import Map, Rule\n\ndef on_index(request):\n    return Response('Hello from the index')\n\nurl_map = Map([Rule('/', endpoint='index')])\nviews = {'index': on_index}\n\n@responder\ndef application(environ, start_response):\n    request = Request(environ)\n    urls = url_map.bind_to_environ(environ)\n    return urls.dispatch(lambda e, v: views[e](request, **v),\n                         catch_http_exceptions=True)\n Keep in mind that this method might return exception objects, too, so use Response.force_type to get a response object.  Parameters \n \nview_func (Callable[[str, Mapping[str, Any]], WSGIApplication]) \u2013 a function that is called with the endpoint as first argument and the value dict as second. Has to dispatch to the actual view function with this information. (see above) \npath_info (Optional[str]) \u2013 the path info to use for matching. Overrides the path info specified on binding. \nmethod (Optional[str]) \u2013 the HTTP method used for matching. Overrides the method specified on binding. \ncatch_http_exceptions (bool) \u2013 set to True to catch any of the werkzeug HTTPExceptions.   Return type \nWSGIApplication   \n"}, {"name": "MapAdapter.get_host()", "path": "routing/index#werkzeug.routing.MapAdapter.get_host", "type": "werkzeug.routing", "text": " \nget_host(domain_part)  \nFigures out the full host name for the given domain part. The domain part is a subdomain in case host matching is disabled or a full host name.  Parameters \ndomain_part (Optional[str]) \u2013   Return type \nstr   \n"}, {"name": "MapAdapter.make_alias_redirect_url()", "path": "routing/index#werkzeug.routing.MapAdapter.make_alias_redirect_url", "type": "werkzeug.routing", "text": " \nmake_alias_redirect_url(path, endpoint, values, method, query_args)  \nInternally called to make an alias redirect URL.  Parameters \n \npath (str) \u2013  \nendpoint (str) \u2013  \nvalues (Mapping[str, Any]) \u2013  \nmethod (str) \u2013  \nquery_args (Union[Mapping[str, Any], str]) \u2013    Return type \nstr   \n"}, {"name": "MapAdapter.match()", "path": "routing/index#werkzeug.routing.MapAdapter.match", "type": "werkzeug.routing", "text": " \nmatch(path_info=None, method=None, return_rule=False, query_args=None, websocket=None)  \nThe usage is simple: you just pass the match method the current path info as well as the method (which defaults to GET). The following things can then happen:  you receive a NotFound exception that indicates that no URL is matching. A NotFound exception is also a WSGI application you can call to get a default page not found page (happens to be the same object as werkzeug.exceptions.NotFound) you receive a MethodNotAllowed exception that indicates that there is a match for this URL but not for the current request method. This is useful for RESTful applications. you receive a RequestRedirect exception with a new_url attribute. This exception is used to notify you about a request Werkzeug requests from your WSGI application. This is for example the case if you request /foo although the correct URL is /foo/ You can use the RequestRedirect instance as response-like object similar to all other subclasses of HTTPException. you receive a WebsocketMismatch exception if the only match is a WebSocket rule but the bind is an HTTP request, or if the match is an HTTP rule but the bind is a WebSocket request. you get a tuple in the form (endpoint, arguments) if there is a match (unless return_rule is True, in which case you get a tuple in the form (rule, arguments))  If the path info is not passed to the match method the default path info of the map is used (defaults to the root URL if not defined explicitly). All of the exceptions raised are subclasses of HTTPException so they can be used as WSGI responses. They will all render generic error or redirect pages. Here is a small example for matching: >>> m = Map([\n...     Rule('/', endpoint='index'),\n...     Rule('/downloads/', endpoint='downloads/index'),\n...     Rule('/downloads/<int:id>', endpoint='downloads/show')\n... ])\n>>> urls = m.bind(\"example.com\", \"/\")\n>>> urls.match(\"/\", \"GET\")\n('index', {})\n>>> urls.match(\"/downloads/42\")\n('downloads/show', {'id': 42})\n And here is what happens on redirect and missing URLs: >>> urls.match(\"/downloads\")\nTraceback (most recent call last):\n  ...\nRequestRedirect: http://example.com/downloads/\n>>> urls.match(\"/missing\")\nTraceback (most recent call last):\n  ...\nNotFound: 404 Not Found\n  Parameters \n \npath_info (Optional[str]) \u2013 the path info to use for matching. Overrides the path info specified on binding. \nmethod (Optional[str]) \u2013 the HTTP method used for matching. Overrides the method specified on binding. \nreturn_rule (bool) \u2013 return the rule that matched instead of just the endpoint (defaults to False). \nquery_args (Optional[Union[Mapping[str, Any], str]]) \u2013 optional query arguments that are used for automatic redirects as string or dictionary. It\u2019s currently not possible to use the query arguments for URL matching. \nwebsocket (Optional[bool]) \u2013 Match WebSocket instead of HTTP requests. A websocket request has a ws or wss url_scheme. This overrides that detection.   Return type \nTuple[Union[str, werkzeug.routing.Rule], Mapping[str, Any]]    Changelog New in version 1.0: Added websocket.   Changed in version 0.8: query_args can be a string.   New in version 0.7: Added query_args.   New in version 0.6: Added return_rule.  \n\n"}, {"name": "MapAdapter.test()", "path": "routing/index#werkzeug.routing.MapAdapter.test", "type": "werkzeug.routing", "text": " \ntest(path_info=None, method=None)  \nTest if a rule would match. Works like match but returns True if the URL matches, or False if it does not exist.  Parameters \n \npath_info (Optional[str]) \u2013 the path info to use for matching. Overrides the path info specified on binding. \nmethod (Optional[str]) \u2013 the HTTP method used for matching. Overrides the method specified on binding.   Return type \nbool   \n"}, {"name": "Middleware", "path": "middleware/index", "type": "Other", "text": "Middleware A WSGI middleware is a WSGI application that wraps another application in order to observe or change its behavior. Werkzeug provides some middleware for common use cases.  X-Forwarded-For Proxy Fix Serve Shared Static Files Application Dispatcher Basic HTTP Proxy WSGI Protocol Linter Application Profiler  The interactive debugger is also a middleware that can be applied manually, although it is typically used automatically with the development server.\n"}, {"name": "MIMEAccept", "path": "datastructures/index#werkzeug.datastructures.MIMEAccept", "type": "werkzeug.datastructures", "text": " \nclass werkzeug.datastructures.MIMEAccept(values=())  \nLike Accept but with special methods and behavior for mimetypes.  \nproperty accept_html  \nTrue if this object accepts HTML. \n  \nproperty accept_json  \nTrue if this object accepts JSON. \n  \nproperty accept_xhtml  \nTrue if this object accepts XHTML. \n \n"}, {"name": "mod_wsgi (Apache)", "path": "deployment/mod_wsgi/index", "type": "Other", "text": "mod_wsgi (Apache) If you are using the Apache webserver you should consider using mod_wsgi.  Installing mod_wsgi\n If you don\u2019t have mod_wsgi installed yet you have to either install it using a package manager or compile it yourself. The mod_wsgi installation instructions cover installation instructions for source installations on UNIX systems. If you are using ubuntu / debian you can apt-get it and activate it as follows: # apt-get install libapache2-mod-wsgi\n On FreeBSD install mod_wsgi by compiling the www/mod_wsgi port or by using pkg_add: # pkg_add -r mod_wsgi\n If you are using pkgsrc you can install mod_wsgi by compiling the www/ap2-wsgi package. If you encounter segfaulting child processes after the first apache reload you can safely ignore them. Just restart the server.   Creating a .wsgi file To run your application you need a yourapplication.wsgi file. This file contains the code mod_wsgi is executing on startup to get the application object. The object called application in that file is then used as application. For most applications the following file should be sufficient: from yourapplication import make_app\napplication = make_app()\n If you don\u2019t have a factory function for application creation but a singleton instance you can directly import that one as application. Store that file somewhere where you will find it again (eg: /var/www/yourapplication) and make sure that yourapplication and all the libraries that are in use are on the python load path. If you don\u2019t want to install it system wide consider using a virtual python instance.   Configuring Apache The last thing you have to do is to create an Apache configuration file for your application. In this example we are telling mod_wsgi to execute the application under a different user for security reasons: <VirtualHost *>\n    ServerName example.com\n\n    WSGIDaemonProcess yourapplication user=user1 group=group1 processes=2 threads=5\n    WSGIScriptAlias / /var/www/yourapplication/yourapplication.wsgi\n\n    <Directory /var/www/yourapplication>\n        WSGIProcessGroup yourapplication\n        WSGIApplicationGroup %{GLOBAL}\n        Order deny,allow\n        Allow from all\n    </Directory>\n</VirtualHost>\n \n"}, {"name": "MultiDict", "path": "datastructures/index#werkzeug.datastructures.MultiDict", "type": "werkzeug.datastructures", "text": " \nclass werkzeug.datastructures.MultiDict(mapping=None)  \nA MultiDict is a dictionary subclass customized to deal with multiple values for the same key which is for example used by the parsing functions in the wrappers. This is necessary because some HTML form elements pass multiple values for the same key. MultiDict implements all standard dictionary methods. Internally, it saves all values for a key as a list, but the standard dict access methods will only return the first value for a key. If you want to gain access to the other values, too, you have to use the list methods as explained below. Basic Usage: >>> d = MultiDict([('a', 'b'), ('a', 'c')])\n>>> d\nMultiDict([('a', 'b'), ('a', 'c')])\n>>> d['a']\n'b'\n>>> d.getlist('a')\n['b', 'c']\n>>> 'a' in d\nTrue\n It behaves like a normal dict thus all dict functions will only return the first value when multiple values for one key are found. From Werkzeug 0.3 onwards, the KeyError raised by this class is also a subclass of the BadRequest HTTP exception and will render a page for a 400 BAD REQUEST if caught in a catch-all for HTTP exceptions. A MultiDict can be constructed from an iterable of (key, value) tuples, a dict, a MultiDict or from Werkzeug 0.2 onwards some keyword parameters.  Parameters \nmapping \u2013 the initial value for the MultiDict. Either a regular dict, an iterable of (key, value) tuples or None.    \nadd(key, value)  \nAdds a new value for the key.  Changelog New in version 0.6.   Parameters \n \nkey \u2013 the key for the value. \nvalue \u2013 the value to add.    \n  \nclear() \u2192 None. Remove all items from D. \n  \ncopy()  \nReturn a shallow copy of this object. \n  \ndeepcopy(memo=None)  \nReturn a deep copy of this object. \n  \nfromkeys(value=None, /)  \nCreate a new dictionary with keys from iterable and values set to value. \n  \nget(key, default=None, type=None)  \nReturn the default value if the requested data doesn\u2019t exist. If type is provided and is a callable it should convert the value, return it or raise a ValueError if that is not possible. In this case the function will return the default as if the value was not found: >>> d = TypeConversionDict(foo='42', bar='blub')\n>>> d.get('foo', type=int)\n42\n>>> d.get('bar', -1, type=int)\n-1\n  Parameters \n \nkey \u2013 The key to be looked up. \ndefault \u2013 The default value to be returned if the key can\u2019t be looked up. If not further specified None is returned. \ntype \u2013 A callable that is used to cast the value in the MultiDict. If a ValueError is raised by this callable the default value is returned.    \n  \ngetlist(key, type=None)  \nReturn the list of items for a given key. If that key is not in the MultiDict, the return value will be an empty list. Just like get, getlist accepts a type parameter. All items will be converted with the callable defined there.  Parameters \n \nkey \u2013 The key to be looked up. \ntype \u2013 A callable that is used to cast the value in the MultiDict. If a ValueError is raised by this callable the value will be removed from the list.   Returns \na list of all the values for the key.   \n  \nitems(multi=False)  \nReturn an iterator of (key, value) pairs.  Parameters \nmulti \u2013 If set to True the iterator returned will have a pair for each value of each key. Otherwise it will only contain pairs for the first value of each key.   \n  \nkeys() \u2192 a set-like object providing a view on D\u2019s keys \n  \nlists()  \nReturn a iterator of (key, values) pairs, where values is the list of all values associated with the key. \n  \nlistvalues()  \nReturn an iterator of all values associated with a key. Zipping keys() and this is the same as calling lists(): >>> d = MultiDict({\"foo\": [1, 2, 3]})\n>>> zip(d.keys(), d.listvalues()) == d.lists()\nTrue\n \n  \npop(key, default=no value)  \nPop the first item for a list on the dict. Afterwards the key is removed from the dict, so additional values are discarded: >>> d = MultiDict({\"foo\": [1, 2, 3]})\n>>> d.pop(\"foo\")\n1\n>>> \"foo\" in d\nFalse\n  Parameters \n \nkey \u2013 the key to pop. \ndefault \u2013 if provided the value to return if the key was not in the dictionary.    \n  \npopitem()  \nPop an item from the dict. \n  \npopitemlist()  \nPop a (key, list) tuple from the dict. \n  \npoplist(key)  \nPop the list for a key from the dict. If the key is not in the dict an empty list is returned.  Changelog Changed in version 0.5: If the key does no longer exist a list is returned instead of raising an error.  \n\n  \nsetdefault(key, default=None)  \nReturns the value for the key if it is in the dict, otherwise it returns default and sets that value for key.  Parameters \n \nkey \u2013 The key to be looked up. \ndefault \u2013 The default value to be returned if the key is not in the dict. If not further specified it\u2019s None.    \n  \nsetlist(key, new_list)  \nRemove the old values for a key and add new ones. Note that the list you pass the values in will be shallow-copied before it is inserted in the dictionary. >>> d = MultiDict()\n>>> d.setlist('foo', ['1', '2'])\n>>> d['foo']\n'1'\n>>> d.getlist('foo')\n['1', '2']\n  Parameters \n \nkey \u2013 The key for which the values are set. \nnew_list \u2013 An iterable with the new values for the key. Old values are removed first.    \n  \nsetlistdefault(key, default_list=None)  \nLike setdefault but sets multiple values. The list returned is not a copy, but the list that is actually used internally. This means that you can put new values into the dict by appending items to the list: >>> d = MultiDict({\"foo\": 1})\n>>> d.setlistdefault(\"foo\").extend([2, 3])\n>>> d.getlist(\"foo\")\n[1, 2, 3]\n  Parameters \n \nkey \u2013 The key to be looked up. \ndefault_list \u2013 An iterable of default values. It is either copied (in case it was a list) or converted into a list before returned.   Returns \na list   \n  \nto_dict(flat=True)  \nReturn the contents as regular dict. If flat is True the returned dict will only have the first item present, if flat is False all values will be returned as lists.  Parameters \nflat \u2013 If set to False the dict returned will have lists with all the values in it. Otherwise it will only contain the first value for each key.  Returns \na dict   \n  \nupdate(mapping)  \nupdate() extends rather than replaces existing key lists: >>> a = MultiDict({'x': 1})\n>>> b = MultiDict({'x': 2, 'y': 3})\n>>> a.update(b)\n>>> a\nMultiDict([('y', 3), ('x', 1), ('x', 2)])\n If the value list for a key in other_dict is empty, no new values will be added to the dict and the key will not be created: >>> x = {'empty_list': []}\n>>> y = MultiDict()\n>>> y.update(x)\n>>> y\nMultiDict([])\n \n  \nvalues()  \nReturns an iterator of the first value on every key\u2019s value list. \n \n"}, {"name": "MultiDict.add()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.add", "type": "werkzeug.datastructures", "text": " \nadd(key, value)  \nAdds a new value for the key.  Changelog New in version 0.6.   Parameters \n \nkey \u2013 the key for the value. \nvalue \u2013 the value to add.    \n"}, {"name": "MultiDict.clear()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.clear", "type": "werkzeug.datastructures", "text": " \nclear() \u2192 None. Remove all items from D. \n"}, {"name": "MultiDict.copy()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.copy", "type": "werkzeug.datastructures", "text": " \ncopy()  \nReturn a shallow copy of this object. \n"}, {"name": "MultiDict.deepcopy()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.deepcopy", "type": "werkzeug.datastructures", "text": " \ndeepcopy(memo=None)  \nReturn a deep copy of this object. \n"}, {"name": "MultiDict.fromkeys()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.fromkeys", "type": "werkzeug.datastructures", "text": " \nfromkeys(value=None, /)  \nCreate a new dictionary with keys from iterable and values set to value. \n"}, {"name": "MultiDict.get()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.get", "type": "werkzeug.datastructures", "text": " \nget(key, default=None, type=None)  \nReturn the default value if the requested data doesn\u2019t exist. If type is provided and is a callable it should convert the value, return it or raise a ValueError if that is not possible. In this case the function will return the default as if the value was not found: >>> d = TypeConversionDict(foo='42', bar='blub')\n>>> d.get('foo', type=int)\n42\n>>> d.get('bar', -1, type=int)\n-1\n  Parameters \n \nkey \u2013 The key to be looked up. \ndefault \u2013 The default value to be returned if the key can\u2019t be looked up. If not further specified None is returned. \ntype \u2013 A callable that is used to cast the value in the MultiDict. If a ValueError is raised by this callable the default value is returned.    \n"}, {"name": "MultiDict.getlist()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.getlist", "type": "werkzeug.datastructures", "text": " \ngetlist(key, type=None)  \nReturn the list of items for a given key. If that key is not in the MultiDict, the return value will be an empty list. Just like get, getlist accepts a type parameter. All items will be converted with the callable defined there.  Parameters \n \nkey \u2013 The key to be looked up. \ntype \u2013 A callable that is used to cast the value in the MultiDict. If a ValueError is raised by this callable the value will be removed from the list.   Returns \na list of all the values for the key.   \n"}, {"name": "MultiDict.items()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.items", "type": "werkzeug.datastructures", "text": " \nitems(multi=False)  \nReturn an iterator of (key, value) pairs.  Parameters \nmulti \u2013 If set to True the iterator returned will have a pair for each value of each key. Otherwise it will only contain pairs for the first value of each key.   \n"}, {"name": "MultiDict.keys()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.keys", "type": "werkzeug.datastructures", "text": " \nkeys() \u2192 a set-like object providing a view on D\u2019s keys \n"}, {"name": "MultiDict.lists()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.lists", "type": "werkzeug.datastructures", "text": " \nlists()  \nReturn a iterator of (key, values) pairs, where values is the list of all values associated with the key. \n"}, {"name": "MultiDict.listvalues()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.listvalues", "type": "werkzeug.datastructures", "text": " \nlistvalues()  \nReturn an iterator of all values associated with a key. Zipping keys() and this is the same as calling lists(): >>> d = MultiDict({\"foo\": [1, 2, 3]})\n>>> zip(d.keys(), d.listvalues()) == d.lists()\nTrue\n \n"}, {"name": "MultiDict.pop()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.pop", "type": "werkzeug.datastructures", "text": " \npop(key, default=no value)  \nPop the first item for a list on the dict. Afterwards the key is removed from the dict, so additional values are discarded: >>> d = MultiDict({\"foo\": [1, 2, 3]})\n>>> d.pop(\"foo\")\n1\n>>> \"foo\" in d\nFalse\n  Parameters \n \nkey \u2013 the key to pop. \ndefault \u2013 if provided the value to return if the key was not in the dictionary.    \n"}, {"name": "MultiDict.popitem()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.popitem", "type": "werkzeug.datastructures", "text": " \npopitem()  \nPop an item from the dict. \n"}, {"name": "MultiDict.popitemlist()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.popitemlist", "type": "werkzeug.datastructures", "text": " \npopitemlist()  \nPop a (key, list) tuple from the dict. \n"}, {"name": "MultiDict.poplist()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.poplist", "type": "werkzeug.datastructures", "text": " \npoplist(key)  \nPop the list for a key from the dict. If the key is not in the dict an empty list is returned.  Changelog Changed in version 0.5: If the key does no longer exist a list is returned instead of raising an error.  \n\n"}, {"name": "MultiDict.setdefault()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.setdefault", "type": "werkzeug.datastructures", "text": " \nsetdefault(key, default=None)  \nReturns the value for the key if it is in the dict, otherwise it returns default and sets that value for key.  Parameters \n \nkey \u2013 The key to be looked up. \ndefault \u2013 The default value to be returned if the key is not in the dict. If not further specified it\u2019s None.    \n"}, {"name": "MultiDict.setlist()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.setlist", "type": "werkzeug.datastructures", "text": " \nsetlist(key, new_list)  \nRemove the old values for a key and add new ones. Note that the list you pass the values in will be shallow-copied before it is inserted in the dictionary. >>> d = MultiDict()\n>>> d.setlist('foo', ['1', '2'])\n>>> d['foo']\n'1'\n>>> d.getlist('foo')\n['1', '2']\n  Parameters \n \nkey \u2013 The key for which the values are set. \nnew_list \u2013 An iterable with the new values for the key. Old values are removed first.    \n"}, {"name": "MultiDict.setlistdefault()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.setlistdefault", "type": "werkzeug.datastructures", "text": " \nsetlistdefault(key, default_list=None)  \nLike setdefault but sets multiple values. The list returned is not a copy, but the list that is actually used internally. This means that you can put new values into the dict by appending items to the list: >>> d = MultiDict({\"foo\": 1})\n>>> d.setlistdefault(\"foo\").extend([2, 3])\n>>> d.getlist(\"foo\")\n[1, 2, 3]\n  Parameters \n \nkey \u2013 The key to be looked up. \ndefault_list \u2013 An iterable of default values. It is either copied (in case it was a list) or converted into a list before returned.   Returns \na list   \n"}, {"name": "MultiDict.to_dict()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.to_dict", "type": "werkzeug.datastructures", "text": " \nto_dict(flat=True)  \nReturn the contents as regular dict. If flat is True the returned dict will only have the first item present, if flat is False all values will be returned as lists.  Parameters \nflat \u2013 If set to False the dict returned will have lists with all the values in it. Otherwise it will only contain the first value for each key.  Returns \na dict   \n"}, {"name": "MultiDict.update()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.update", "type": "werkzeug.datastructures", "text": " \nupdate(mapping)  \nupdate() extends rather than replaces existing key lists: >>> a = MultiDict({'x': 1})\n>>> b = MultiDict({'x': 2, 'y': 3})\n>>> a.update(b)\n>>> a\nMultiDict([('y', 3), ('x', 1), ('x', 2)])\n If the value list for a key in other_dict is empty, no new values will be added to the dict and the key will not be created: >>> x = {'empty_list': []}\n>>> y = MultiDict()\n>>> y.update(x)\n>>> y\nMultiDict([])\n \n"}, {"name": "MultiDict.values()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.values", "type": "werkzeug.datastructures", "text": " \nvalues()  \nReturns an iterator of the first value on every key\u2019s value list. \n"}, {"name": "OrderedMultiDict", "path": "datastructures/index#werkzeug.datastructures.OrderedMultiDict", "type": "werkzeug.datastructures", "text": " \nclass werkzeug.datastructures.OrderedMultiDict(mapping=None)  \nWorks like a regular MultiDict but preserves the order of the fields. To convert the ordered multi dict into a list you can use the items() method and pass it multi=True. In general an OrderedMultiDict is an order of magnitude slower than a MultiDict.  note Due to a limitation in Python you cannot convert an ordered multi dict into a regular dict by using dict(multidict). Instead you have to use the to_dict() method, otherwise the internal bucket objects are exposed.  \n"}, {"name": "parse_accept_header()", "path": "http/index#werkzeug.http.parse_accept_header", "type": "werkzeug.http", "text": " \nwerkzeug.http.parse_accept_header(value[, class])  \nParses an HTTP Accept-* header. This does not implement a complete valid algorithm but one that supports at least value and quality extraction. Returns a new Accept object (basically a list of (value, quality) tuples sorted by the quality with some additional accessor methods). The second parameter can be a subclass of Accept that is created with the parsed values and returned.  Parameters \n \nvalue (Optional[str]) \u2013 the accept header string to be parsed. \ncls (Optional[Type[werkzeug.http._TAnyAccept]]) \u2013 the wrapper class for the return value (can be Accept or a subclass thereof)   Returns \nan instance of cls.  Return type \nwerkzeug.http._TAnyAccept   \n"}, {"name": "parse_authorization_header()", "path": "http/index#werkzeug.http.parse_authorization_header", "type": "werkzeug.http", "text": " \nwerkzeug.http.parse_authorization_header(value)  \nParse an HTTP basic/digest authorization header transmitted by the web browser. The return value is either None if the header was invalid or not given, otherwise an Authorization object.  Parameters \nvalue (Optional[str]) \u2013 the authorization header to parse.  Returns \na Authorization object or None.  Return type \nOptional[werkzeug.datastructures.Authorization]   \n"}, {"name": "parse_cache_control_header()", "path": "http/index#werkzeug.http.parse_cache_control_header", "type": "werkzeug.http", "text": " \nwerkzeug.http.parse_cache_control_header(value, on_update=None, cls=None)  \nParse a cache control header. The RFC differs between response and request cache control, this method does not. It\u2019s your responsibility to not use the wrong control statements.  Changelog New in version 0.5: The cls was added. If not specified an immutable RequestCacheControl is returned.   Parameters \n \nvalue (Optional[str]) \u2013 a cache control header to be parsed. \non_update (Optional[Callable[[werkzeug.http._TAnyCC], None]]) \u2013 an optional callable that is called every time a value on the CacheControl object is changed. \ncls (Optional[Type[werkzeug.http._TAnyCC]]) \u2013 the class for the returned object. By default RequestCacheControl is used.   Returns \na cls object.  Return type \nwerkzeug.http._TAnyCC   \n"}, {"name": "parse_content_range_header()", "path": "http/index#werkzeug.http.parse_content_range_header", "type": "werkzeug.http", "text": " \nwerkzeug.http.parse_content_range_header(value, on_update=None)  \nParses a range header into a ContentRange object or None if parsing is not possible.  Changelog New in version 0.7.   Parameters \n \nvalue (Optional[str]) \u2013 a content range header to be parsed. \non_update (Optional[Callable[[werkzeug.datastructures.ContentRange], None]]) \u2013 an optional callable that is called every time a value on the ContentRange object is changed.   Return type \nOptional[werkzeug.datastructures.ContentRange]   \n"}, {"name": "parse_cookie()", "path": "http/index#werkzeug.http.parse_cookie", "type": "werkzeug.http", "text": " \nwerkzeug.http.parse_cookie(header, charset='utf-8', errors='replace', cls=None)  \nParse a cookie from a string or WSGI environ. The same key can be provided multiple times, the values are stored in-order. The default MultiDict will have the first value first, and all values can be retrieved with MultiDict.getlist().  Parameters \n \nheader (Optional[Union[WSGIEnvironment, str, bytes]]) \u2013 The cookie header as a string, or a WSGI environ dict with a HTTP_COOKIE key. \ncharset (str) \u2013 The charset for the cookie values. \nerrors (str) \u2013 The error behavior for the charset decoding. \ncls (Optional[Type[ds.MultiDict]]) \u2013 A dict-like class to store the parsed cookies in. Defaults to MultiDict.   Return type \nds.MultiDict[str, str]    Changelog Changed in version 1.0.0: Returns a MultiDict instead of a TypeConversionDict.   Changed in version 0.5: Returns a TypeConversionDict instead of a regular dict. The cls parameter was added.  \n\n"}, {"name": "parse_date()", "path": "http/index#werkzeug.http.parse_date", "type": "werkzeug.http", "text": " \nwerkzeug.http.parse_date(value)  \nParse an RFC 2822 date into a timezone-aware datetime.datetime object, or None if parsing fails. This is a wrapper for email.utils.parsedate_to_datetime(). It returns None if parsing fails instead of raising an exception, and always returns a timezone-aware datetime object. If the string doesn\u2019t have timezone information, it is assumed to be UTC.  Parameters \nvalue (Optional[str]) \u2013 A string with a supported date format.  Return type \nOptional[datetime.datetime]    Changed in version 2.0: Return a timezone-aware datetime object. Use email.utils.parsedate_to_datetime.  \n"}, {"name": "parse_dict_header()", "path": "http/index#werkzeug.http.parse_dict_header", "type": "werkzeug.http", "text": " \nwerkzeug.http.parse_dict_header(value, cls=<class 'dict'>)  \nParse lists of key, value pairs as described by RFC 2068 Section 2 and convert them into a python dict (or any other mapping object created from the type with a dict like interface provided by the cls argument): >>> d = parse_dict_header('foo=\"is a fish\", bar=\"as well\"')\n>>> type(d) is dict\nTrue\n>>> sorted(d.items())\n[('bar', 'as well'), ('foo', 'is a fish')]\n If there is no value for a key it will be None: >>> parse_dict_header('key_without_value')\n{'key_without_value': None}\n To create a header from the dict again, use the dump_header() function.  Changelog Changed in version 0.9: Added support for cls argument.   Parameters \n \nvalue (str) \u2013 a string with a dict header. \ncls (Type[dict]) \u2013 callable to use for storage of parsed results.   Returns \nan instance of cls  Return type \nDict[str, str]   \n"}, {"name": "parse_etags()", "path": "http/index#werkzeug.http.parse_etags", "type": "werkzeug.http", "text": " \nwerkzeug.http.parse_etags(value)  \nParse an etag header.  Parameters \nvalue (Optional[str]) \u2013 the tag header to parse  Returns \nan ETags object.  Return type \nwerkzeug.datastructures.ETags   \n"}, {"name": "parse_form_data()", "path": "http/index#werkzeug.formparser.parse_form_data", "type": "werkzeug.formparser", "text": " \nwerkzeug.formparser.parse_form_data(environ, stream_factory=None, charset='utf-8', errors='replace', max_form_memory_size=None, max_content_length=None, cls=None, silent=True)  \nParse the form data in the environ and return it as tuple in the form (stream, form, files). You should only call this method if the transport method is POST, PUT, or PATCH. If the mimetype of the data transmitted is multipart/form-data the files multidict will be filled with FileStorage objects. If the mimetype is unknown the input stream is wrapped and returned as first argument, else the stream is empty. This is a shortcut for the common usage of FormDataParser. Have a look at Dealing with Request Data for more details.  Changelog New in version 0.5.1: The optional silent flag was added.   New in version 0.5: The max_form_memory_size, max_content_length and cls parameters were added.   Parameters \n \nenviron (WSGIEnvironment) \u2013 the WSGI environment to be used for parsing. \nstream_factory (Optional[TStreamFactory]) \u2013 An optional callable that returns a new read and writeable file descriptor. This callable works the same as Response._get_file_stream(). \ncharset (str) \u2013 The character set for URL and url encoded form data. \nerrors (str) \u2013 The encoding error behavior. \nmax_form_memory_size (Optional[int]) \u2013 the maximum number of bytes to be accepted for in-memory stored form data. If the data exceeds the value specified an RequestEntityTooLarge exception is raised. \nmax_content_length (Optional[int]) \u2013 If this is provided and the transmitted data is longer than this value an RequestEntityTooLarge exception is raised. \ncls (Optional[Type[werkzeug.datastructures.MultiDict]]) \u2013 an optional dict class to use. If this is not specified or None the default MultiDict is used. \nsilent (bool) \u2013 If set to False parsing errors will not be caught.   Returns \nA tuple in the form (stream, form, files).  Return type \nt_parse_result   \n"}, {"name": "parse_if_range_header()", "path": "http/index#werkzeug.http.parse_if_range_header", "type": "werkzeug.http", "text": " \nwerkzeug.http.parse_if_range_header(value)  \nParses an if-range header which can be an etag or a date. Returns a IfRange object.  Changed in version 2.0: If the value represents a datetime, it is timezone-aware.   Changelog New in version 0.7.   Parameters \nvalue (Optional[str]) \u2013   Return type \nwerkzeug.datastructures.IfRange   \n"}, {"name": "parse_list_header()", "path": "http/index#werkzeug.http.parse_list_header", "type": "werkzeug.http", "text": " \nwerkzeug.http.parse_list_header(value)  \nParse lists as described by RFC 2068 Section 2. In particular, parse comma-separated lists where the elements of the list may include quoted-strings. A quoted-string could contain a comma. A non-quoted string could have quotes in the middle. Quotes are removed automatically after parsing. It basically works like parse_set_header() just that items may appear multiple times and case sensitivity is preserved. The return value is a standard list: >>> parse_list_header('token, \"quoted value\"')\n['token', 'quoted value']\n To create a header from the list again, use the dump_header() function.  Parameters \nvalue (str) \u2013 a string with a list header.  Returns \nlist  Return type \nList[str]   \n"}, {"name": "parse_options_header()", "path": "http/index#werkzeug.http.parse_options_header", "type": "werkzeug.http", "text": " \nwerkzeug.http.parse_options_header(value, multiple=False)  \nParse a Content-Type like header into a tuple with the content type and the options: >>> parse_options_header('text/html; charset=utf8')\n('text/html', {'charset': 'utf8'})\n This should not be used to parse Cache-Control like headers that use a slightly different format. For these headers use the parse_dict_header() function.  Changelog Changed in version 0.15: RFC 2231 parameter continuations are handled.   New in version 0.5.   Parameters \n \nvalue (Optional[str]) \u2013 the header to parse. \nmultiple (bool) \u2013 Whether try to parse and return multiple MIME types   Returns \n(mimetype, options) or (mimetype, options, mimetype, options, \u2026) if multiple=True  Return type \nUnion[Tuple[str, Dict[str, str]], Tuple[Any, \u2026]]   \n"}, {"name": "parse_range_header()", "path": "http/index#werkzeug.http.parse_range_header", "type": "werkzeug.http", "text": " \nwerkzeug.http.parse_range_header(value, make_inclusive=True)  \nParses a range header into a Range object. If the header is missing or malformed None is returned. ranges is a list of (start, stop) tuples where the ranges are non-inclusive.  Changelog New in version 0.7.   Parameters \n \nvalue (Optional[str]) \u2013  \nmake_inclusive (bool) \u2013    Return type \nOptional[werkzeug.datastructures.Range]   \n"}, {"name": "parse_set_header()", "path": "http/index#werkzeug.http.parse_set_header", "type": "werkzeug.http", "text": " \nwerkzeug.http.parse_set_header(value, on_update=None)  \nParse a set-like header and return a HeaderSet object: >>> hs = parse_set_header('token, \"quoted value\"')\n The return value is an object that treats the items case-insensitively and keeps the order of the items: >>> 'TOKEN' in hs\nTrue\n>>> hs.index('quoted value')\n1\n>>> hs\nHeaderSet(['token', 'quoted value'])\n To create a header from the HeaderSet again, use the dump_header() function.  Parameters \n \nvalue (Optional[str]) \u2013 a set header to be parsed. \non_update (Optional[Callable[[werkzeug.datastructures.HeaderSet], None]]) \u2013 an optional callable that is called every time a value on the HeaderSet object is changed.   Returns \na HeaderSet  Return type \nwerkzeug.datastructures.HeaderSet   \n"}, {"name": "parse_www_authenticate_header()", "path": "http/index#werkzeug.http.parse_www_authenticate_header", "type": "werkzeug.http", "text": " \nwerkzeug.http.parse_www_authenticate_header(value, on_update=None)  \nParse an HTTP WWW-Authenticate header into a WWWAuthenticate object.  Parameters \n \nvalue (Optional[str]) \u2013 a WWW-Authenticate header to parse. \non_update (Optional[Callable[[werkzeug.datastructures.WWWAuthenticate], None]]) \u2013 an optional callable that is called every time a value on the WWWAuthenticate object is changed.   Returns \na WWWAuthenticate object.  Return type \nwerkzeug.datastructures.WWWAuthenticate   \n"}, {"name": "PathConverter", "path": "routing/index#werkzeug.routing.PathConverter", "type": "werkzeug.routing", "text": " \nclass werkzeug.routing.PathConverter(map, *args, **kwargs)  \nLike the default UnicodeConverter, but it also matches slashes. This is useful for wikis and similar applications: Rule('/<path:wikipage>')\nRule('/<path:wikipage>/edit')\n  Parameters \n \nmap (Map) \u2013 the Map. \nargs (Any) \u2013  \nkwargs (Any) \u2013    Return type \nNone   \n"}, {"name": "pbkdf2_bin()", "path": "utils/index#werkzeug.security.pbkdf2_bin", "type": "werkzeug.security", "text": " \nwerkzeug.security.pbkdf2_bin(data, salt, iterations=260000, keylen=None, hashfunc=None)  \nReturns a binary digest for the PBKDF2 hash algorithm of data with the given salt. It iterates iterations times and produces a key of keylen bytes. By default, SHA-256 is used as hash function; a different hashlib hashfunc can be provided.  Parameters \n \ndata (Union[str, bytes]) \u2013 the data to derive. \nsalt (Union[str, bytes]) \u2013 the salt for the derivation. \niterations (int) \u2013 the number of iterations. \nkeylen (Optional[int]) \u2013 the length of the resulting key. If not provided the digest size will be used. \nhashfunc (Optional[Union[str, Callable]]) \u2013 the hash function to use. This can either be the string name of a known hash function or a function from the hashlib module. Defaults to sha256.   Return type \nbytes    Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use hashlib.pbkdf2_hmac() instead.   Changelog New in version 0.9.  \n\n"}, {"name": "pbkdf2_hex()", "path": "utils/index#werkzeug.security.pbkdf2_hex", "type": "werkzeug.security", "text": " \nwerkzeug.security.pbkdf2_hex(data, salt, iterations=260000, keylen=None, hashfunc=None)  \nLike pbkdf2_bin(), but returns a hex-encoded string.  Parameters \n \ndata (Union[str, bytes]) \u2013 the data to derive. \nsalt (Union[str, bytes]) \u2013 the salt for the derivation. \niterations (int) \u2013 the number of iterations. \nkeylen (Optional[int]) \u2013 the length of the resulting key. If not provided, the digest size will be used. \nhashfunc (Optional[Union[str, Callable]]) \u2013 the hash function to use. This can either be the string name of a known hash function, or a function from the hashlib module. Defaults to sha256.   Return type \nstr    Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use hashlib.pbkdf2_hmac() instead.   Changelog New in version 0.9.  \n\n"}, {"name": "peek_path_info()", "path": "wsgi/index#werkzeug.wsgi.peek_path_info", "type": "werkzeug.wsgi", "text": " \nwerkzeug.wsgi.peek_path_info(environ, charset='utf-8', errors='replace')  \nReturns the next segment on the PATH_INFO or None if there is none. Works like pop_path_info() without modifying the environment: >>> env = {'SCRIPT_NAME': '/foo', 'PATH_INFO': '/a/b'}\n>>> peek_path_info(env)\n'a'\n>>> peek_path_info(env)\n'a'\n If the charset is set to None bytes are returned.  Changelog Changed in version 0.9: The path is now decoded and a charset and encoding parameter can be provided.   New in version 0.5.   Parameters \n \nenviron (WSGIEnvironment) \u2013 the WSGI environment that is checked. \ncharset (str) \u2013  \nerrors (str) \u2013    Return type \nOptional[str]   \n"}, {"name": "pop_path_info()", "path": "wsgi/index#werkzeug.wsgi.pop_path_info", "type": "werkzeug.wsgi", "text": " \nwerkzeug.wsgi.pop_path_info(environ, charset='utf-8', errors='replace')  \nRemoves and returns the next segment of PATH_INFO, pushing it onto SCRIPT_NAME. Returns None if there is nothing left on PATH_INFO. If the charset is set to None bytes are returned. If there are empty segments ('/foo//bar) these are ignored but properly pushed to the SCRIPT_NAME: >>> env = {'SCRIPT_NAME': '/foo', 'PATH_INFO': '/a/b'}\n>>> pop_path_info(env)\n'a'\n>>> env['SCRIPT_NAME']\n'/foo/a'\n>>> pop_path_info(env)\n'b'\n>>> env['SCRIPT_NAME']\n'/foo/a/b'\n  Changelog Changed in version 0.9: The path is now decoded and a charset and encoding parameter can be provided.   New in version 0.5.   Parameters \n \nenviron (WSGIEnvironment) \u2013 the WSGI environment that is modified. \ncharset (str) \u2013 The encoding parameter passed to bytes.decode(). \nerrors (str) \u2013 The errors paramater passed to bytes.decode().   Return type \nOptional[str]   \n"}, {"name": "ProfilerMiddleware", "path": "middleware/profiler/index#werkzeug.middleware.profiler.ProfilerMiddleware", "type": "werkzeug.middleware.profiler", "text": " \nclass werkzeug.middleware.profiler.ProfilerMiddleware(app, stream=<_io.TextIOWrapper name='<stdout>' mode='w' encoding='UTF-8'>, sort_by=('time', 'calls'), restrictions=(), profile_dir=None, filename_format='{method}.{path}.{elapsed:.0f}ms.{time:.0f}.prof')  \nWrap a WSGI application and profile the execution of each request. Responses are buffered so that timings are more exact. If stream is given, pstats.Stats are written to it after each request. If profile_dir is given, cProfile data files are saved to that directory, one file per request. The filename can be customized by passing filename_format. If it is a string, it will be formatted using str.format() with the following fields available:  \n{method} - The request method; GET, POST, etc. \n{path} - The request path or \u2018root\u2019 should one not exist. \n{elapsed} - The elapsed time of the request. \n{time} - The time of the request.  If it is a callable, it will be called with the WSGI environ dict and should return a filename.  Parameters \n \napp (WSGIApplication) \u2013 The WSGI application to wrap. \nstream (TextIO) \u2013 Write stats to this stream. Disable with None. \nsort_by (Iterable[str]) \u2013 A tuple of columns to sort stats by. See pstats.Stats.sort_stats(). \nrestrictions (Iterable[Union[str, int, float]]) \u2013 A tuple of restrictions to filter stats by. See pstats.Stats.print_stats(). \nprofile_dir (Optional[str]) \u2013 Save profile data files to this directory. \nfilename_format (str) \u2013 Format string for profile data file names, or a callable returning a name. See explanation above.   Return type \nNone   from werkzeug.middleware.profiler import ProfilerMiddleware\napp = ProfilerMiddleware(app)\n  Changelog Changed in version 0.15: Stats are written even if profile_dir is given, and can be disable by passing stream=None.   New in version 0.15: Added filename_format.   New in version 0.9: Added restrictions and profile_dir.  \n\n"}, {"name": "ProxyFix", "path": "middleware/proxy_fix/index#werkzeug.middleware.proxy_fix.ProxyFix", "type": "werkzeug.middleware.proxy_fix", "text": " \nclass werkzeug.middleware.proxy_fix.ProxyFix(app, x_for=1, x_proto=1, x_host=0, x_port=0, x_prefix=0)  \nAdjust the WSGI environ based on X-Forwarded- that proxies in front of the application may set.  \nX-Forwarded-For sets REMOTE_ADDR. \nX-Forwarded-Proto sets wsgi.url_scheme. \nX-Forwarded-Host sets HTTP_HOST, SERVER_NAME, and SERVER_PORT. \nX-Forwarded-Port sets HTTP_HOST and SERVER_PORT. \nX-Forwarded-Prefix sets SCRIPT_NAME.  You must tell the middleware how many proxies set each header so it knows what values to trust. It is a security issue to trust values that came from the client rather than a proxy. The original values of the headers are stored in the WSGI environ as werkzeug.proxy_fix.orig, a dict.  Parameters \n \napp (WSGIApplication) \u2013 The WSGI application to wrap. \nx_for (int) \u2013 Number of values to trust for X-Forwarded-For. \nx_proto (int) \u2013 Number of values to trust for X-Forwarded-Proto. \nx_host (int) \u2013 Number of values to trust for X-Forwarded-Host. \nx_port (int) \u2013 Number of values to trust for X-Forwarded-Port. \nx_prefix (int) \u2013 Number of values to trust for X-Forwarded-Prefix.   Return type \nNone   from werkzeug.middleware.proxy_fix import ProxyFix\n# App is behind one proxy that sets the -For and -Host headers.\napp = ProxyFix(app, x_for=1, x_host=1)\n  Changelog Changed in version 1.0: Deprecated code has been removed:  The num_proxies argument and attribute. The get_remote_addr method. The environ keys orig_remote_addr, orig_wsgi_url_scheme, and orig_http_host.    Changed in version 0.15: All headers support multiple values. The num_proxies argument is deprecated. Each header is configured with a separate number of trusted proxies.   Changed in version 0.15: Original WSGI environ values are stored in the werkzeug.proxy_fix.orig dict. orig_remote_addr, orig_wsgi_url_scheme, and orig_http_host are deprecated and will be removed in 1.0.   Changed in version 0.15: Support X-Forwarded-Port and X-Forwarded-Prefix.   Changed in version 0.15: X-Forwarded-Host and X-Forwarded-Port modify SERVER_NAME and SERVER_PORT.  \n\n"}, {"name": "ProxyMiddleware", "path": "middleware/http_proxy/index#werkzeug.middleware.http_proxy.ProxyMiddleware", "type": "werkzeug.middleware.http_proxy", "text": " \nclass werkzeug.middleware.http_proxy.ProxyMiddleware(app, targets, chunk_size=16384, timeout=10)  \nProxy requests under a path to an external server, routing other requests to the app. This middleware can only proxy HTTP requests, as HTTP is the only protocol handled by the WSGI server. Other protocols, such as WebSocket requests, cannot be proxied at this layer. This should only be used for development, in production a real proxy server should be used. The middleware takes a dict mapping a path prefix to a dict describing the host to be proxied to: app = ProxyMiddleware(app, {\n    \"/static/\": {\n        \"target\": \"http://127.0.0.1:5001/\",\n    }\n})\n Each host has the following options:  \ntarget: \n\nThe target URL to dispatch to. This is required.  \nremove_prefix: \n\nWhether to remove the prefix from the URL before dispatching it to the target. The default is False.  \nhost: \n\n \n\"<auto>\" (default): \n\nThe host header is automatically rewritten to the URL of the target.  \nNone: \n\nThe host header is unmodified from the client request.  Any other value:\n\nThe host header is overwritten with the value.    \nheaders: \n\nA dictionary of headers to be sent with the request to the target. The default is {}.  \nssl_context: \n\nA ssl.SSLContext defining how to verify requests if the target is HTTPS. The default is None.   In the example above, everything under \"/static/\" is proxied to the server on port 5001. The host header is rewritten to the target, and the \"/static/\" prefix is removed from the URLs.  Parameters \n \napp (WSGIApplication) \u2013 The WSGI application to wrap. \ntargets (Mapping[str, Dict[str, Any]]) \u2013 Proxy target configurations. See description above. \nchunk_size (int) \u2013 Size of chunks to read from input stream and write to target. \ntimeout (int) \u2013 Seconds before an operation to a target fails.   Return type \nNone    Changelog New in version 0.14.  \n\n"}, {"name": "Quickstart", "path": "quickstart/index", "type": "Other", "text": "Quickstart This part of the documentation shows how to use the most important parts of Werkzeug. It\u2019s intended as a starting point for developers with basic understanding of PEP 3333 (WSGI) and RFC 2616 (HTTP).\n"}, {"name": "quote_etag()", "path": "http/index#werkzeug.http.quote_etag", "type": "werkzeug.http", "text": " \nwerkzeug.http.quote_etag(etag, weak=False)  \nQuote an etag.  Parameters \n \netag (str) \u2013 the etag to quote. \nweak (bool) \u2013 set to True to tag it \u201cweak\u201d.   Return type \nstr   \n"}, {"name": "quote_header_value()", "path": "http/index#werkzeug.http.quote_header_value", "type": "werkzeug.http", "text": " \nwerkzeug.http.quote_header_value(value, extra_chars='', allow_token=True)  \nQuote a header value if necessary.  Changelog New in version 0.5.   Parameters \n \nvalue (Union[str, int]) \u2013 the value to quote. \nextra_chars (str) \u2013 a list of extra characters to skip quoting. \nallow_token (bool) \u2013 if this is enabled token values are returned unchanged.   Return type \nstr   \n"}, {"name": "Range", "path": "datastructures/index#werkzeug.datastructures.Range", "type": "werkzeug.datastructures", "text": " \nclass werkzeug.datastructures.Range(units, ranges)  \nRepresents a Range header. All methods only support only bytes as the unit. Stores a list of ranges if given, but the methods only work if only one range is provided.  Raises \nValueError \u2013 If the ranges provided are invalid.    Changelog Changed in version 0.15: The ranges passed in are validated.   New in version 0.7.   \nmake_content_range(length)  \nCreates a ContentRange object from the current range and given content length. \n  \nrange_for_length(length)  \nIf the range is for bytes, the length is not None and there is exactly one range and it is satisfiable it returns a (start, stop) tuple, otherwise None. \n  \nranges  \nA list of (begin, end) tuples for the range header provided. The ranges are non-inclusive. \n  \nto_content_range_header(length)  \nConverts the object into Content-Range HTTP header, based on given length \n  \nto_header()  \nConverts the object back into an HTTP header. \n  \nunits  \nThe units of this range. Usually \u201cbytes\u201d. \n \n"}, {"name": "Range.make_content_range()", "path": "datastructures/index#werkzeug.datastructures.Range.make_content_range", "type": "werkzeug.datastructures", "text": " \nmake_content_range(length)  \nCreates a ContentRange object from the current range and given content length. \n"}, {"name": "Range.ranges", "path": "datastructures/index#werkzeug.datastructures.Range.ranges", "type": "werkzeug.datastructures", "text": " \nranges  \nA list of (begin, end) tuples for the range header provided. The ranges are non-inclusive. \n"}, {"name": "Range.range_for_length()", "path": "datastructures/index#werkzeug.datastructures.Range.range_for_length", "type": "werkzeug.datastructures", "text": " \nrange_for_length(length)  \nIf the range is for bytes, the length is not None and there is exactly one range and it is satisfiable it returns a (start, stop) tuple, otherwise None. \n"}, {"name": "Range.to_content_range_header()", "path": "datastructures/index#werkzeug.datastructures.Range.to_content_range_header", "type": "werkzeug.datastructures", "text": " \nto_content_range_header(length)  \nConverts the object into Content-Range HTTP header, based on given length \n"}, {"name": "Range.to_header()", "path": "datastructures/index#werkzeug.datastructures.Range.to_header", "type": "werkzeug.datastructures", "text": " \nto_header()  \nConverts the object back into an HTTP header. \n"}, {"name": "Range.units", "path": "datastructures/index#werkzeug.datastructures.Range.units", "type": "werkzeug.datastructures", "text": " \nunits  \nThe units of this range. Usually \u201cbytes\u201d. \n"}, {"name": "redirect()", "path": "utils/index#werkzeug.utils.redirect", "type": "werkzeug.utils", "text": " \nwerkzeug.utils.redirect(location, code=302, Response=None)  \nReturns a response object (a WSGI application) that, if called, redirects the client to the target location. Supported codes are 301, 302, 303, 305, 307, and 308. 300 is not supported because it\u2019s not a real redirect and 304 because it\u2019s the answer for a request with a request with defined If-Modified-Since headers.  Changelog New in version 0.10: The class used for the Response object can now be passed in.   New in version 0.6: The location can now be a unicode string that is encoded using the iri_to_uri() function.   Parameters \n \nlocation (str) \u2013 the location the response should redirect to. \ncode (int) \u2013 the redirect status code. defaults to 302. \nResponse (class) \u2013 a Response class to use when instantiating a response. The default is werkzeug.wrappers.Response if unspecified.   Return type \nResponse   \n"}, {"name": "release_local()", "path": "local/index#werkzeug.local.release_local", "type": "werkzeug.local", "text": " \nwerkzeug.local.release_local(local)  \nReleases the contents of the local for the current context. This makes it possible to use locals without a manager. Example: >>> loc = Local()\n>>> loc.foo = 42\n>>> release_local(loc)\n>>> hasattr(loc, 'foo')\nFalse\n With this function one can release Local objects as well as LocalStack objects. However it is not possible to release data held by proxies that way, one always has to retain a reference to the underlying local object in order to be able to release it.  Changelog New in version 0.6.1.   Parameters \nlocal (Union[werkzeug.local.Local, werkzeug.local.LocalStack]) \u2013   Return type \nNone   \n"}, {"name": "remove_entity_headers()", "path": "http/index#werkzeug.http.remove_entity_headers", "type": "werkzeug.http", "text": " \nwerkzeug.http.remove_entity_headers(headers, allowed=('expires', 'content-location'))  \nRemove all entity headers from a list or Headers object. This operation works in-place. Expires and Content-Location headers are by default not removed. The reason for this is RFC 2616 section 10.3.5 which specifies some entity headers that should be sent.  Changelog Changed in version 0.5: added allowed parameter.   Parameters \n \nheaders (Union[werkzeug.datastructures.Headers, List[Tuple[str, str]]]) \u2013 a list or Headers object. \nallowed (Iterable[str]) \u2013 a list of headers that should still be allowed even though they are entity headers.   Return type \nNone   \n"}, {"name": "remove_hop_by_hop_headers()", "path": "http/index#werkzeug.http.remove_hop_by_hop_headers", "type": "werkzeug.http", "text": " \nwerkzeug.http.remove_hop_by_hop_headers(headers)  \nRemove all HTTP/1.1 \u201cHop-by-Hop\u201d headers from a list or Headers object. This operation works in-place.  Changelog New in version 0.5.   Parameters \nheaders (Union[werkzeug.datastructures.Headers, List[Tuple[str, str]]]) \u2013 a list or Headers object.  Return type \nNone   \n"}, {"name": "Request", "path": "wrappers/index#werkzeug.wrappers.Request", "type": "werkzeug.wrappers", "text": " \nclass werkzeug.wrappers.Request(environ, populate_request=True, shallow=False)  \nRepresents an incoming WSGI HTTP request, with headers and body taken from the WSGI environment. Has properties and methods for using the functionality defined by various HTTP specs. The data in requests object is read-only. Text data is assumed to use UTF-8 encoding, which should be true for the vast majority of modern clients. Using an encoding set by the client is unsafe in Python due to extra encodings it provides, such as zip. To change the assumed encoding, subclass and replace charset.  Parameters \n \nenviron (WSGIEnvironment) \u2013 The WSGI environ is generated by the WSGI server and contains information about the server configuration and client request. \npopulate_request (bool) \u2013 Add this request object to the WSGI environ as environ['werkzeug.request']. Can be useful when debugging. \nshallow (bool) \u2013 Makes reading from stream (and any method that would read from it) raise a RuntimeError. Useful to prevent consuming the form data in middleware, which would make it unavailable to the final application.   Return type \nNone    Changed in version 2.0: Combine BaseRequest and mixins into a single Request class. Using the old classes is deprecated and will be removed in Werkzeug 2.1.   Changelog Changed in version 0.5: Read-only mode is enforced with immutable classes for all data.   \n_get_file_stream(total_content_length, content_type, filename=None, content_length=None)  \nCalled to get a stream for the file upload. This must provide a file-like class with read(), readline() and seek() methods that is both writeable and readable. The default implementation returns a temporary file if the total content length is higher than 500KB. Because many browsers do not provide a content length for the files only the total content length matters.  Parameters \n \ntotal_content_length (Optional[int]) \u2013 the total content length of all the data in the request combined. This value is guaranteed to be there. \ncontent_type (Optional[str]) \u2013 the mimetype of the uploaded file. \nfilename (Optional[str]) \u2013 the filename of the uploaded file. May be None. \ncontent_length (Optional[int]) \u2013 the length of this file. This value is usually not provided because webbrowsers do not provide this value.   Return type \nBinaryIO   \n  \nproperty accept_charsets: werkzeug.datastructures.CharsetAccept  \nList of charsets this client supports as CharsetAccept object. \n  \nproperty accept_encodings: werkzeug.datastructures.Accept  \nList of encodings this client accepts. Encodings in a HTTP term are compression encodings such as gzip. For charsets have a look at accept_charset. \n  \nproperty accept_languages: werkzeug.datastructures.LanguageAccept  \nList of languages this client accepts as LanguageAccept object. \n  \nproperty accept_mimetypes: werkzeug.datastructures.MIMEAccept  \nList of mimetypes this client supports as MIMEAccept object. \n  \naccess_control_request_headers  \nSent with a preflight request to indicate which headers will be sent with the cross origin request. Set access_control_allow_headers on the response to indicate which headers are allowed. \n  \naccess_control_request_method  \nSent with a preflight request to indicate which method will be used for the cross origin request. Set access_control_allow_methods on the response to indicate which methods are allowed. \n  \nproperty access_route: List[str]  \nIf a forwarded header exists this is a list of all ip addresses from the client ip to the last proxy server. \n  \nclassmethod application(f)  \nDecorate a function as responder that accepts the request as the last argument. This works like the responder() decorator but the function is passed the request object as the last argument and the request object will be closed automatically: @Request.application\ndef my_wsgi_app(request):\n    return Response('Hello World!')\n As of Werkzeug 0.14 HTTP exceptions are automatically caught and converted to responses instead of failing.  Parameters \nf (Callable[[Request], WSGIApplication]) \u2013 the WSGI callable to decorate  Returns \na new WSGI callable  Return type \nWSGIApplication   \n  \nproperty args: MultiDict[str, str]  \nThe parsed URL parameters (the part in the URL after the question mark). By default an ImmutableMultiDict is returned from this function. This can be changed by setting parameter_storage_class to a different type. This might be necessary if the order of the form data is important. \n  \nproperty authorization: Optional[werkzeug.datastructures.Authorization]  \nThe Authorization object in parsed form. \n  \nproperty base_url: str  \nLike url but without the query string. \n  \nproperty cache_control: werkzeug.datastructures.RequestCacheControl  \nA RequestCacheControl object for the incoming cache control headers. \n  \nclose()  \nCloses associated resources of this request object. This closes all file handles explicitly. You can also use the request object in a with statement which will automatically close it.  Changelog New in version 0.9.   Return type \nNone   \n  \ncontent_encoding  \nThe Content-Encoding entity-header field is used as a modifier to the media-type. When present, its value indicates what additional content codings have been applied to the entity-body, and thus what decoding mechanisms must be applied in order to obtain the media-type referenced by the Content-Type header field.  Changelog New in version 0.9.  \n\n  \nproperty content_length: Optional[int]  \nThe Content-Length entity-header field indicates the size of the entity-body in bytes or, in the case of the HEAD method, the size of the entity-body that would have been sent had the request been a GET. \n  \ncontent_md5  \nThe Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest of the entity-body for the purpose of providing an end-to-end message integrity check (MIC) of the entity-body. (Note: a MIC is good for detecting accidental modification of the entity-body in transit, but is not proof against malicious attacks.)  Changelog New in version 0.9.  \n\n  \ncontent_type  \nThe Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of the HEAD method, the media type that would have been sent had the request been a GET. \n  \nproperty cookies: ImmutableMultiDict[str, str]  \nA dict with the contents of all cookies transmitted with the request. \n  \nproperty data: bytes  \nContains the incoming request data as string in case it came with a mimetype Werkzeug does not handle. \n  \ndate  \nThe Date general-header field represents the date and time at which the message was originated, having the same semantics as orig-date in RFC 822.  Changed in version 2.0: The datetime object is timezone-aware.  \n  \ndict_storage_class  \nalias of werkzeug.datastructures.ImmutableMultiDict \n  \ndisable_data_descriptor: Optional[bool] = None  \nDisable the data property to avoid reading from the input stream.  Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Create the request with shallow=True instead.   Changelog New in version 0.9.  \n\n  \nenviron: WSGIEnvironment  \nThe WSGI environment containing HTTP headers and information from the WSGI server. \n  \nproperty files: ImmutableMultiDict[str, FileStorage]  \nMultiDict object containing all uploaded files. Each key in files is the name from the <input type=\"file\" name=\"\">. Each value in files is a Werkzeug FileStorage object. It basically behaves like a standard file object you know from Python, with the difference that it also has a save() function that can store the file on the filesystem. Note that files will only contain data if the request method was POST, PUT or PATCH and the <form> that posted to the request had enctype=\"multipart/form-data\". It will be empty otherwise. See the MultiDict / FileStorage documentation for more details about the used data structure. \n  \nproperty form: ImmutableMultiDict[str, str]  \nThe form parameters. By default an ImmutableMultiDict is returned from this function. This can be changed by setting parameter_storage_class to a different type. This might be necessary if the order of the form data is important. Please keep in mind that file uploads will not end up here, but instead in the files attribute.  Changelog Changed in version 0.9: Previous to Werkzeug 0.9 this would only contain form data for POST and PUT requests.  \n\n  \nform_data_parser_class  \nalias of werkzeug.formparser.FormDataParser \n  \nclassmethod from_values(*args, **kwargs)  \nCreate a new request object based on the values provided. If environ is given missing values are filled from there. This method is useful for small scripts when you need to simulate a request from an URL. Do not use this method for unittesting, there is a full featured client object (Client) that allows to create multipart requests, support for cookies etc. This accepts the same options as the EnvironBuilder.  Changelog Changed in version 0.5: This method now accepts the same arguments as EnvironBuilder. Because of this the environ parameter is now called environ_overrides.   Returns \nrequest object  Parameters \n \nargs (Any) \u2013  \nkwargs (Any) \u2013    Return type \nwerkzeug.wrappers.request.Request   \n  \nproperty full_path: str  \nRequested path, including the query string. \n  \nget_data(cache=True, as_text=False, parse_form_data=False)  \nThis reads the buffered incoming data from the client into one bytes object. By default this is cached but that behavior can be changed by setting cache to False. Usually it\u2019s a bad idea to call this method without checking the content length first as a client could send dozens of megabytes or more to cause memory problems on the server. Note that if the form data was already parsed this method will not return anything as form data parsing does not cache the data like this method does. To implicitly invoke form data parsing function set parse_form_data to True. When this is done the return value of this method will be an empty string if the form parser handles the data. This generally is not necessary as if the whole data is cached (which is the default) the form parser will used the cached data to parse the form data. Please be generally aware of checking the content length first in any case before calling this method to avoid exhausting server memory. If as_text is set to True the return value will be a decoded string.  Changelog New in version 0.9.   Parameters \n \ncache (bool) \u2013  \nas_text (bool) \u2013  \nparse_form_data (bool) \u2013    Return type \nUnion[bytes, str]   \n  \nget_json(force=False, silent=False, cache=True)  \nParse data as JSON. If the mimetype does not indicate JSON (application/json, see is_json()), this returns None. If parsing fails, on_json_loading_failed() is called and its return value is used as the return value.  Parameters \n \nforce (bool) \u2013 Ignore the mimetype and always try to parse JSON. \nsilent (bool) \u2013 Silence parsing errors and return None instead. \ncache (bool) \u2013 Store the parsed JSON to return for subsequent calls.   Return type \nOptional[Any]   \n  \nheaders  \nThe headers received with the request. \n  \nproperty host: str  \nThe host name the request was made to, including the port if it\u2019s non-standard. Validated with trusted_hosts. \n  \nproperty host_url: str  \nThe request URL scheme and host only. \n  \nproperty if_match: werkzeug.datastructures.ETags  \nAn object containing all the etags in the If-Match header.  Return type \nETags   \n  \nproperty if_modified_since: Optional[datetime.datetime]  \nThe parsed If-Modified-Since header as a datetime object.  Changed in version 2.0: The datetime object is timezone-aware.  \n  \nproperty if_none_match: werkzeug.datastructures.ETags  \nAn object containing all the etags in the If-None-Match header.  Return type \nETags   \n  \nproperty if_range: werkzeug.datastructures.IfRange  \nThe parsed If-Range header.  Changed in version 2.0: IfRange.date is timezone-aware.   Changelog New in version 0.7.  \n\n  \nproperty if_unmodified_since: Optional[datetime.datetime]  \nThe parsed If-Unmodified-Since header as a datetime object.  Changed in version 2.0: The datetime object is timezone-aware.  \n  \ninput_stream  \nThe WSGI input stream. In general it\u2019s a bad idea to use this one because you can easily read past the boundary. Use the stream instead. \n  \nproperty is_json: bool  \nCheck if the mimetype indicates JSON data, either application/json or application/*+json. \n  \nis_multiprocess  \nboolean that is True if the application is served by a WSGI server that spawns multiple processes. \n  \nis_multithread  \nboolean that is True if the application is served by a multithreaded WSGI server. \n  \nis_run_once  \nboolean that is True if the application will be executed only once in a process lifetime. This is the case for CGI for example, but it\u2019s not guaranteed that the execution only happens one time. \n  \nproperty is_secure: bool  \nTrue if the request was made with a secure protocol (HTTPS or WSS). \n  \nproperty json: Optional[Any]  \nThe parsed JSON data if mimetype indicates JSON (application/json, see is_json()). Calls get_json() with default arguments. \n  \njson_module = <module 'json' from '/home/docs/.pyenv/versions/3.7.9/lib/python3.7/json/__init__.py'>  \nA module or other object that has dumps and loads functions that match the API of the built-in json module. \n  \nlist_storage_class  \nalias of werkzeug.datastructures.ImmutableList \n  \nmake_form_data_parser()  \nCreates the form data parser. Instantiates the form_data_parser_class with some parameters.  Changelog New in version 0.8.   Return type \nwerkzeug.formparser.FormDataParser   \n  \nmax_content_length: Optional[int] = None  \nthe maximum content length. This is forwarded to the form data parsing function (parse_form_data()). When set and the form or files attribute is accessed and the parsing fails because more than the specified value is transmitted a RequestEntityTooLarge exception is raised. Have a look at Dealing with Request Data for more details.  Changelog New in version 0.5.  \n\n  \nmax_form_memory_size: Optional[int] = None  \nthe maximum form field size. This is forwarded to the form data parsing function (parse_form_data()). When set and the form or files attribute is accessed and the data in memory for post data is longer than the specified value a RequestEntityTooLarge exception is raised. Have a look at Dealing with Request Data for more details.  Changelog New in version 0.5.  \n\n  \nmax_forwards  \nThe Max-Forwards request-header field provides a mechanism with the TRACE and OPTIONS methods to limit the number of proxies or gateways that can forward the request to the next inbound server. \n  \nmethod  \nThe method the request was made with, such as GET. \n  \nproperty mimetype: str  \nLike content_type, but without parameters (eg, without charset, type etc.) and always lowercase. For example if the content type is text/HTML; charset=utf-8 the mimetype would be 'text/html'. \n  \nproperty mimetype_params: Dict[str, str]  \nThe mimetype parameters as dict. For example if the content type is text/html; charset=utf-8 the params would be {'charset': 'utf-8'}. \n  \non_json_loading_failed(e)  \nCalled if get_json() parsing fails and isn\u2019t silenced. If this method returns a value, it is used as the return value for get_json(). The default implementation raises BadRequest.  Parameters \ne (ValueError) \u2013   Return type \nAny   \n  \norigin  \nThe host that the request originated from. Set access_control_allow_origin on the response to indicate which origins are allowed. \n  \nparameter_storage_class  \nalias of werkzeug.datastructures.ImmutableMultiDict \n  \npath  \nThe path part of the URL after root_path. This is the path used for routing within the application. \n  \nproperty pragma: werkzeug.datastructures.HeaderSet  \nThe Pragma general-header field is used to include implementation-specific directives that might apply to any recipient along the request/response chain. All pragma directives specify optional behavior from the viewpoint of the protocol; however, some systems MAY require that behavior be consistent with the directives. \n  \nquery_string  \nThe part of the URL after the \u201c?\u201d. This is the raw value, use args for the parsed values. \n  \nproperty range: Optional[werkzeug.datastructures.Range]  \nThe parsed Range header.  Changelog New in version 0.7.   Return type \nRange   \n  \nreferrer  \nThe Referer[sic] request-header field allows the client to specify, for the server\u2019s benefit, the address (URI) of the resource from which the Request-URI was obtained (the \u201creferrer\u201d, although the header field is misspelled). \n  \nremote_addr  \nThe address of the client sending the request. \n  \nremote_user  \nIf the server supports user authentication, and the script is protected, this attribute contains the username the user has authenticated as. \n  \nroot_path  \nThe prefix that the application is mounted under, without a trailing slash. path comes after this. \n  \nproperty root_url: str  \nThe request URL scheme, host, and root path. This is the root that the application is accessed from. \n  \nscheme  \nThe URL scheme of the protocol the request used, such as https or wss. \n  \nproperty script_root: str  \nAlias for self.root_path. environ[\"SCRIPT_ROOT\"] without a trailing slash. \n  \nserver  \nThe address of the server. (host, port), (path, None) for unix sockets, or None if not known. \n  \nshallow: bool  \nSet when creating the request object. If True, reading from the request body will cause a RuntimeException. Useful to prevent modifying the stream from middleware. \n  \nproperty stream: BinaryIO  \nIf the incoming form data was not encoded with a known mimetype the data is stored unmodified in this stream for consumption. Most of the time it is a better idea to use data which will give you that data as a string. The stream only returns the data once. Unlike input_stream this stream is properly guarded that you can\u2019t accidentally read past the length of the input. Werkzeug will internally always refer to this stream to read data which makes it possible to wrap this object with a stream that does filtering.  Changelog Changed in version 0.9: This stream is now always available but might be consumed by the form parser later on. Previously the stream was only set if no parsing happened.  \n\n  \nproperty url: str  \nThe full request URL with the scheme, host, root path, path, and query string. \n  \nproperty url_charset: str  \nThe charset that is assumed for URLs. Defaults to the value of charset.  Changelog New in version 0.6.  \n\n  \nproperty url_root: str  \nAlias for root_url. The URL with scheme, host, and root path. For example, https://example.com/app/. \n  \nproperty user_agent: werkzeug.user_agent.UserAgent  \nThe user agent. Use user_agent.string to get the header value. Set user_agent_class to a subclass of UserAgent to provide parsing for the other properties or other extended data.  Changed in version 2.0: The built in parser is deprecated and will be removed in Werkzeug 2.1. A UserAgent subclass must be set to parse data from the string.  \n  \nuser_agent_class  \nalias of werkzeug.useragents._UserAgent \n  \nproperty values: CombinedMultiDict[str, str]  \nA werkzeug.datastructures.CombinedMultiDict that combines args and form. For GET requests, only args are present, not form.  Changed in version 2.0: For GET requests, only args are present, not form.  \n  \nproperty want_form_data_parsed: bool  \nTrue if the request method carries content. By default this is true if a Content-Type is sent.  Changelog New in version 0.8.  \n\n \n"}, {"name": "Request / Response Objects", "path": "wrappers/index", "type": "Other", "text": "Request / Response Objects The request and response objects wrap the WSGI environment or the return value from a WSGI application so that it is another WSGI application (wraps a whole application).  How they Work Your WSGI application is always passed two arguments. The WSGI \u201cenvironment\u201d and the WSGI start_response function that is used to start the response phase. The Request class wraps the environ for easier access to request variables (form data, request headers etc.). The Response on the other hand is a standard WSGI application that you can create. The simple hello world in Werkzeug looks like this: from werkzeug.wrappers import Response\napplication = Response('Hello World!')\n To make it more useful you can replace it with a function and do some processing: from werkzeug.wrappers import Request, Response\n\ndef application(environ, start_response):\n    request = Request(environ)\n    response = Response(f\"Hello {request.args.get('name', 'World!')}!\")\n    return response(environ, start_response)\n Because this is a very common task the Request object provides a helper for that. The above code can be rewritten like this: from werkzeug.wrappers import Request, Response\n\n@Request.application\ndef application(request):\n    return Response(f\"Hello {request.args.get('name', 'World!')}!\")\n The application is still a valid WSGI application that accepts the environment and start_response callable.   Mutability and Reusability of Wrappers The implementation of the Werkzeug request and response objects are trying to guard you from common pitfalls by disallowing certain things as much as possible. This serves two purposes: high performance and avoiding of pitfalls. For the request object the following rules apply:  The request object is immutable. Modifications are not supported by default, you may however replace the immutable attributes with mutable attributes if you need to modify it. The request object may be shared in the same thread, but is not thread safe itself. If you need to access it from multiple threads, use locks around calls. It\u2019s not possible to pickle the request object.  For the response object the following rules apply:  The response object is mutable The response object can be pickled or copied after freeze() was called. Since Werkzeug 0.6 it\u2019s safe to use the same response object for multiple WSGI responses. It\u2019s possible to create copies using copy.deepcopy.    Wrapper Classes  \nclass werkzeug.wrappers.Request(environ, populate_request=True, shallow=False)  \nRepresents an incoming WSGI HTTP request, with headers and body taken from the WSGI environment. Has properties and methods for using the functionality defined by various HTTP specs. The data in requests object is read-only. Text data is assumed to use UTF-8 encoding, which should be true for the vast majority of modern clients. Using an encoding set by the client is unsafe in Python due to extra encodings it provides, such as zip. To change the assumed encoding, subclass and replace charset.  Parameters \n \nenviron (WSGIEnvironment) \u2013 The WSGI environ is generated by the WSGI server and contains information about the server configuration and client request. \npopulate_request (bool) \u2013 Add this request object to the WSGI environ as environ['werkzeug.request']. Can be useful when debugging. \nshallow (bool) \u2013 Makes reading from stream (and any method that would read from it) raise a RuntimeError. Useful to prevent consuming the form data in middleware, which would make it unavailable to the final application.   Return type \nNone    Changed in version 2.0: Combine BaseRequest and mixins into a single Request class. Using the old classes is deprecated and will be removed in Werkzeug 2.1.   Changelog Changed in version 0.5: Read-only mode is enforced with immutable classes for all data.   \n_get_file_stream(total_content_length, content_type, filename=None, content_length=None)  \nCalled to get a stream for the file upload. This must provide a file-like class with read(), readline() and seek() methods that is both writeable and readable. The default implementation returns a temporary file if the total content length is higher than 500KB. Because many browsers do not provide a content length for the files only the total content length matters.  Parameters \n \ntotal_content_length (Optional[int]) \u2013 the total content length of all the data in the request combined. This value is guaranteed to be there. \ncontent_type (Optional[str]) \u2013 the mimetype of the uploaded file. \nfilename (Optional[str]) \u2013 the filename of the uploaded file. May be None. \ncontent_length (Optional[int]) \u2013 the length of this file. This value is usually not provided because webbrowsers do not provide this value.   Return type \nBinaryIO   \n  \nproperty accept_charsets: werkzeug.datastructures.CharsetAccept  \nList of charsets this client supports as CharsetAccept object. \n  \nproperty accept_encodings: werkzeug.datastructures.Accept  \nList of encodings this client accepts. Encodings in a HTTP term are compression encodings such as gzip. For charsets have a look at accept_charset. \n  \nproperty accept_languages: werkzeug.datastructures.LanguageAccept  \nList of languages this client accepts as LanguageAccept object. \n  \nproperty accept_mimetypes: werkzeug.datastructures.MIMEAccept  \nList of mimetypes this client supports as MIMEAccept object. \n  \naccess_control_request_headers  \nSent with a preflight request to indicate which headers will be sent with the cross origin request. Set access_control_allow_headers on the response to indicate which headers are allowed. \n  \naccess_control_request_method  \nSent with a preflight request to indicate which method will be used for the cross origin request. Set access_control_allow_methods on the response to indicate which methods are allowed. \n  \nproperty access_route: List[str]  \nIf a forwarded header exists this is a list of all ip addresses from the client ip to the last proxy server. \n  \nclassmethod application(f)  \nDecorate a function as responder that accepts the request as the last argument. This works like the responder() decorator but the function is passed the request object as the last argument and the request object will be closed automatically: @Request.application\ndef my_wsgi_app(request):\n    return Response('Hello World!')\n As of Werkzeug 0.14 HTTP exceptions are automatically caught and converted to responses instead of failing.  Parameters \nf (Callable[[Request], WSGIApplication]) \u2013 the WSGI callable to decorate  Returns \na new WSGI callable  Return type \nWSGIApplication   \n  \nproperty args: MultiDict[str, str]  \nThe parsed URL parameters (the part in the URL after the question mark). By default an ImmutableMultiDict is returned from this function. This can be changed by setting parameter_storage_class to a different type. This might be necessary if the order of the form data is important. \n  \nproperty authorization: Optional[werkzeug.datastructures.Authorization]  \nThe Authorization object in parsed form. \n  \nproperty base_url: str  \nLike url but without the query string. \n  \nproperty cache_control: werkzeug.datastructures.RequestCacheControl  \nA RequestCacheControl object for the incoming cache control headers. \n  \nclose()  \nCloses associated resources of this request object. This closes all file handles explicitly. You can also use the request object in a with statement which will automatically close it.  Changelog New in version 0.9.   Return type \nNone   \n  \ncontent_encoding  \nThe Content-Encoding entity-header field is used as a modifier to the media-type. When present, its value indicates what additional content codings have been applied to the entity-body, and thus what decoding mechanisms must be applied in order to obtain the media-type referenced by the Content-Type header field.  Changelog New in version 0.9.  \n\n  \nproperty content_length: Optional[int]  \nThe Content-Length entity-header field indicates the size of the entity-body in bytes or, in the case of the HEAD method, the size of the entity-body that would have been sent had the request been a GET. \n  \ncontent_md5  \nThe Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest of the entity-body for the purpose of providing an end-to-end message integrity check (MIC) of the entity-body. (Note: a MIC is good for detecting accidental modification of the entity-body in transit, but is not proof against malicious attacks.)  Changelog New in version 0.9.  \n\n  \ncontent_type  \nThe Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of the HEAD method, the media type that would have been sent had the request been a GET. \n  \nproperty cookies: ImmutableMultiDict[str, str]  \nA dict with the contents of all cookies transmitted with the request. \n  \nproperty data: bytes  \nContains the incoming request data as string in case it came with a mimetype Werkzeug does not handle. \n  \ndate  \nThe Date general-header field represents the date and time at which the message was originated, having the same semantics as orig-date in RFC 822.  Changed in version 2.0: The datetime object is timezone-aware.  \n  \ndict_storage_class  \nalias of werkzeug.datastructures.ImmutableMultiDict \n  \ndisable_data_descriptor: Optional[bool] = None  \nDisable the data property to avoid reading from the input stream.  Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Create the request with shallow=True instead.   Changelog New in version 0.9.  \n\n  \nenviron: WSGIEnvironment  \nThe WSGI environment containing HTTP headers and information from the WSGI server. \n  \nproperty files: ImmutableMultiDict[str, FileStorage]  \nMultiDict object containing all uploaded files. Each key in files is the name from the <input type=\"file\" name=\"\">. Each value in files is a Werkzeug FileStorage object. It basically behaves like a standard file object you know from Python, with the difference that it also has a save() function that can store the file on the filesystem. Note that files will only contain data if the request method was POST, PUT or PATCH and the <form> that posted to the request had enctype=\"multipart/form-data\". It will be empty otherwise. See the MultiDict / FileStorage documentation for more details about the used data structure. \n  \nproperty form: ImmutableMultiDict[str, str]  \nThe form parameters. By default an ImmutableMultiDict is returned from this function. This can be changed by setting parameter_storage_class to a different type. This might be necessary if the order of the form data is important. Please keep in mind that file uploads will not end up here, but instead in the files attribute.  Changelog Changed in version 0.9: Previous to Werkzeug 0.9 this would only contain form data for POST and PUT requests.  \n\n  \nform_data_parser_class  \nalias of werkzeug.formparser.FormDataParser \n  \nclassmethod from_values(*args, **kwargs)  \nCreate a new request object based on the values provided. If environ is given missing values are filled from there. This method is useful for small scripts when you need to simulate a request from an URL. Do not use this method for unittesting, there is a full featured client object (Client) that allows to create multipart requests, support for cookies etc. This accepts the same options as the EnvironBuilder.  Changelog Changed in version 0.5: This method now accepts the same arguments as EnvironBuilder. Because of this the environ parameter is now called environ_overrides.   Returns \nrequest object  Parameters \n \nargs (Any) \u2013  \nkwargs (Any) \u2013    Return type \nwerkzeug.wrappers.request.Request   \n  \nproperty full_path: str  \nRequested path, including the query string. \n  \nget_data(cache=True, as_text=False, parse_form_data=False)  \nThis reads the buffered incoming data from the client into one bytes object. By default this is cached but that behavior can be changed by setting cache to False. Usually it\u2019s a bad idea to call this method without checking the content length first as a client could send dozens of megabytes or more to cause memory problems on the server. Note that if the form data was already parsed this method will not return anything as form data parsing does not cache the data like this method does. To implicitly invoke form data parsing function set parse_form_data to True. When this is done the return value of this method will be an empty string if the form parser handles the data. This generally is not necessary as if the whole data is cached (which is the default) the form parser will used the cached data to parse the form data. Please be generally aware of checking the content length first in any case before calling this method to avoid exhausting server memory. If as_text is set to True the return value will be a decoded string.  Changelog New in version 0.9.   Parameters \n \ncache (bool) \u2013  \nas_text (bool) \u2013  \nparse_form_data (bool) \u2013    Return type \nUnion[bytes, str]   \n  \nget_json(force=False, silent=False, cache=True)  \nParse data as JSON. If the mimetype does not indicate JSON (application/json, see is_json()), this returns None. If parsing fails, on_json_loading_failed() is called and its return value is used as the return value.  Parameters \n \nforce (bool) \u2013 Ignore the mimetype and always try to parse JSON. \nsilent (bool) \u2013 Silence parsing errors and return None instead. \ncache (bool) \u2013 Store the parsed JSON to return for subsequent calls.   Return type \nOptional[Any]   \n  \nheaders  \nThe headers received with the request. \n  \nproperty host: str  \nThe host name the request was made to, including the port if it\u2019s non-standard. Validated with trusted_hosts. \n  \nproperty host_url: str  \nThe request URL scheme and host only. \n  \nproperty if_match: werkzeug.datastructures.ETags  \nAn object containing all the etags in the If-Match header.  Return type \nETags   \n  \nproperty if_modified_since: Optional[datetime.datetime]  \nThe parsed If-Modified-Since header as a datetime object.  Changed in version 2.0: The datetime object is timezone-aware.  \n  \nproperty if_none_match: werkzeug.datastructures.ETags  \nAn object containing all the etags in the If-None-Match header.  Return type \nETags   \n  \nproperty if_range: werkzeug.datastructures.IfRange  \nThe parsed If-Range header.  Changed in version 2.0: IfRange.date is timezone-aware.   Changelog New in version 0.7.  \n\n  \nproperty if_unmodified_since: Optional[datetime.datetime]  \nThe parsed If-Unmodified-Since header as a datetime object.  Changed in version 2.0: The datetime object is timezone-aware.  \n  \ninput_stream  \nThe WSGI input stream. In general it\u2019s a bad idea to use this one because you can easily read past the boundary. Use the stream instead. \n  \nproperty is_json: bool  \nCheck if the mimetype indicates JSON data, either application/json or application/*+json. \n  \nis_multiprocess  \nboolean that is True if the application is served by a WSGI server that spawns multiple processes. \n  \nis_multithread  \nboolean that is True if the application is served by a multithreaded WSGI server. \n  \nis_run_once  \nboolean that is True if the application will be executed only once in a process lifetime. This is the case for CGI for example, but it\u2019s not guaranteed that the execution only happens one time. \n  \nproperty is_secure: bool  \nTrue if the request was made with a secure protocol (HTTPS or WSS). \n  \nproperty json: Optional[Any]  \nThe parsed JSON data if mimetype indicates JSON (application/json, see is_json()). Calls get_json() with default arguments. \n  \njson_module = <module 'json' from '/home/docs/.pyenv/versions/3.7.9/lib/python3.7/json/__init__.py'>  \nA module or other object that has dumps and loads functions that match the API of the built-in json module. \n  \nlist_storage_class  \nalias of werkzeug.datastructures.ImmutableList \n  \nmake_form_data_parser()  \nCreates the form data parser. Instantiates the form_data_parser_class with some parameters.  Changelog New in version 0.8.   Return type \nwerkzeug.formparser.FormDataParser   \n  \nmax_content_length: Optional[int] = None  \nthe maximum content length. This is forwarded to the form data parsing function (parse_form_data()). When set and the form or files attribute is accessed and the parsing fails because more than the specified value is transmitted a RequestEntityTooLarge exception is raised. Have a look at Dealing with Request Data for more details.  Changelog New in version 0.5.  \n\n  \nmax_form_memory_size: Optional[int] = None  \nthe maximum form field size. This is forwarded to the form data parsing function (parse_form_data()). When set and the form or files attribute is accessed and the data in memory for post data is longer than the specified value a RequestEntityTooLarge exception is raised. Have a look at Dealing with Request Data for more details.  Changelog New in version 0.5.  \n\n  \nmax_forwards  \nThe Max-Forwards request-header field provides a mechanism with the TRACE and OPTIONS methods to limit the number of proxies or gateways that can forward the request to the next inbound server. \n  \nmethod  \nThe method the request was made with, such as GET. \n  \nproperty mimetype: str  \nLike content_type, but without parameters (eg, without charset, type etc.) and always lowercase. For example if the content type is text/HTML; charset=utf-8 the mimetype would be 'text/html'. \n  \nproperty mimetype_params: Dict[str, str]  \nThe mimetype parameters as dict. For example if the content type is text/html; charset=utf-8 the params would be {'charset': 'utf-8'}. \n  \non_json_loading_failed(e)  \nCalled if get_json() parsing fails and isn\u2019t silenced. If this method returns a value, it is used as the return value for get_json(). The default implementation raises BadRequest.  Parameters \ne (ValueError) \u2013   Return type \nAny   \n  \norigin  \nThe host that the request originated from. Set access_control_allow_origin on the response to indicate which origins are allowed. \n  \nparameter_storage_class  \nalias of werkzeug.datastructures.ImmutableMultiDict \n  \npath  \nThe path part of the URL after root_path. This is the path used for routing within the application. \n  \nproperty pragma: werkzeug.datastructures.HeaderSet  \nThe Pragma general-header field is used to include implementation-specific directives that might apply to any recipient along the request/response chain. All pragma directives specify optional behavior from the viewpoint of the protocol; however, some systems MAY require that behavior be consistent with the directives. \n  \nquery_string  \nThe part of the URL after the \u201c?\u201d. This is the raw value, use args for the parsed values. \n  \nproperty range: Optional[werkzeug.datastructures.Range]  \nThe parsed Range header.  Changelog New in version 0.7.   Return type \nRange   \n  \nreferrer  \nThe Referer[sic] request-header field allows the client to specify, for the server\u2019s benefit, the address (URI) of the resource from which the Request-URI was obtained (the \u201creferrer\u201d, although the header field is misspelled). \n  \nremote_addr  \nThe address of the client sending the request. \n  \nremote_user  \nIf the server supports user authentication, and the script is protected, this attribute contains the username the user has authenticated as. \n  \nroot_path  \nThe prefix that the application is mounted under, without a trailing slash. path comes after this. \n  \nproperty root_url: str  \nThe request URL scheme, host, and root path. This is the root that the application is accessed from. \n  \nscheme  \nThe URL scheme of the protocol the request used, such as https or wss. \n  \nproperty script_root: str  \nAlias for self.root_path. environ[\"SCRIPT_ROOT\"] without a trailing slash. \n  \nserver  \nThe address of the server. (host, port), (path, None) for unix sockets, or None if not known. \n  \nshallow: bool  \nSet when creating the request object. If True, reading from the request body will cause a RuntimeException. Useful to prevent modifying the stream from middleware. \n  \nproperty stream: BinaryIO  \nIf the incoming form data was not encoded with a known mimetype the data is stored unmodified in this stream for consumption. Most of the time it is a better idea to use data which will give you that data as a string. The stream only returns the data once. Unlike input_stream this stream is properly guarded that you can\u2019t accidentally read past the length of the input. Werkzeug will internally always refer to this stream to read data which makes it possible to wrap this object with a stream that does filtering.  Changelog Changed in version 0.9: This stream is now always available but might be consumed by the form parser later on. Previously the stream was only set if no parsing happened.  \n\n  \nproperty url: str  \nThe full request URL with the scheme, host, root path, path, and query string. \n  \nproperty url_charset: str  \nThe charset that is assumed for URLs. Defaults to the value of charset.  Changelog New in version 0.6.  \n\n  \nproperty url_root: str  \nAlias for root_url. The URL with scheme, host, and root path. For example, https://example.com/app/. \n  \nproperty user_agent: werkzeug.user_agent.UserAgent  \nThe user agent. Use user_agent.string to get the header value. Set user_agent_class to a subclass of UserAgent to provide parsing for the other properties or other extended data.  Changed in version 2.0: The built in parser is deprecated and will be removed in Werkzeug 2.1. A UserAgent subclass must be set to parse data from the string.  \n  \nuser_agent_class  \nalias of werkzeug.useragents._UserAgent \n  \nproperty values: CombinedMultiDict[str, str]  \nA werkzeug.datastructures.CombinedMultiDict that combines args and form. For GET requests, only args are present, not form.  Changed in version 2.0: For GET requests, only args are present, not form.  \n  \nproperty want_form_data_parsed: bool  \nTrue if the request method carries content. By default this is true if a Content-Type is sent.  Changelog New in version 0.8.  \n\n \n  \nclass werkzeug.wrappers.Response(response=None, status=None, headers=None, mimetype=None, content_type=None, direct_passthrough=False)  \nRepresents an outgoing WSGI HTTP response with body, status, and headers. Has properties and methods for using the functionality defined by various HTTP specs. The response body is flexible to support different use cases. The simple form is passing bytes, or a string which will be encoded as UTF-8. Passing an iterable of bytes or strings makes this a streaming response. A generator is particularly useful for building a CSV file in memory or using SSE (Server Sent Events). A file-like object is also iterable, although the send_file() helper should be used in that case. The response object is itself a WSGI application callable. When called (__call__()) with environ and start_response, it will pass its status and headers to start_response then return its body as an iterable. from werkzeug.wrappers.response import Response\n\ndef index():\n    return Response(\"Hello, World!\")\n\ndef application(environ, start_response):\n    path = environ.get(\"PATH_INFO\") or \"/\"\n\n    if path == \"/\":\n        response = index()\n    else:\n        response = Response(\"Not Found\", status=404)\n\n    return response(environ, start_response)\n  Parameters \n \nresponse (Union[Iterable[str], Iterable[bytes]]) \u2013 The data for the body of the response. A string or bytes, or tuple or list of strings or bytes, for a fixed-length response, or any other iterable of strings or bytes for a streaming response. Defaults to an empty body. \nstatus (Optional[Union[int, str, http.HTTPStatus]]) \u2013 The status code for the response. Either an int, in which case the default status message is added, or a string in the form {code} {message}, like 404 Not Found. Defaults to 200. \nheaders (werkzeug.datastructures.Headers) \u2013 A Headers object, or a list of (key, value) tuples that will be converted to a Headers object. \nmimetype (Optional[str]) \u2013 The mime type (content type without charset or other parameters) of the response. If the value starts with text/ (or matches some other special cases), the charset will be added to create the content_type. \ncontent_type (Optional[str]) \u2013 The full content type of the response. Overrides building the value from mimetype. \ndirect_passthrough (bool) \u2013 Pass the response body directly through as the WSGI iterable. This can be used when the body is a binary file or other iterator of bytes, to skip some unnecessary checks. Use send_file() instead of setting this manually.   Return type \nNone    Changed in version 2.0: Combine BaseResponse and mixins into a single Response class. Using the old classes is deprecated and will be removed in Werkzeug 2.1.   Changelog Changed in version 0.5: The direct_passthrough parameter was added.   \n__call__(environ, start_response)  \nProcess this response as WSGI application.  Parameters \n \nenviron (WSGIEnvironment) \u2013 the WSGI environment. \nstart_response (StartResponse) \u2013 the response callable provided by the WSGI server.   Returns \nan application iterator  Return type \nIterable[bytes]   \n  \n_ensure_sequence(mutable=False)  \nThis method can be called by methods that need a sequence. If mutable is true, it will also ensure that the response sequence is a standard Python list.  Changelog New in version 0.6.   Parameters \nmutable (bool) \u2013   Return type \nNone   \n  \naccept_ranges  \nThe Accept-Ranges header. Even though the name would indicate that multiple values are supported, it must be one string token only. The values 'bytes' and 'none' are common.  Changelog New in version 0.7.  \n\n  \nproperty access_control_allow_credentials: bool  \nWhether credentials can be shared by the browser to JavaScript code. As part of the preflight request it indicates whether credentials can be used on the cross origin request. \n  \naccess_control_allow_headers  \nWhich headers can be sent with the cross origin request. \n  \naccess_control_allow_methods  \nWhich methods can be used for the cross origin request. \n  \naccess_control_allow_origin  \nThe origin or \u2018*\u2019 for any origin that may make cross origin requests. \n  \naccess_control_expose_headers  \nWhich headers can be shared by the browser to JavaScript code. \n  \naccess_control_max_age  \nThe maximum age in seconds the access control settings can be cached for. \n  \nadd_etag(overwrite=False, weak=False)  \nAdd an etag for the current response if there is none yet.  Changed in version 2.0: SHA-1 is used to generate the value. MD5 may not be available in some environments.   Parameters \n \noverwrite (bool) \u2013  \nweak (bool) \u2013    Return type \nNone   \n  \nage  \nThe Age response-header field conveys the sender\u2019s estimate of the amount of time since the response (or its revalidation) was generated at the origin server. Age values are non-negative decimal integers, representing time in seconds. \n  \nproperty allow: werkzeug.datastructures.HeaderSet  \nThe Allow entity-header field lists the set of methods supported by the resource identified by the Request-URI. The purpose of this field is strictly to inform the recipient of valid methods associated with the resource. An Allow header field MUST be present in a 405 (Method Not Allowed) response. \n  \nautocorrect_location_header = True  \nShould this response object correct the location header to be RFC conformant? This is true by default.  Changelog New in version 0.8.  \n\n  \nautomatically_set_content_length = True  \nShould this response object automatically set the content-length header if possible? This is true by default.  Changelog New in version 0.8.  \n\n  \nproperty cache_control: werkzeug.datastructures.ResponseCacheControl  \nThe Cache-Control general-header field is used to specify directives that MUST be obeyed by all caching mechanisms along the request/response chain. \n  \ncalculate_content_length()  \nReturns the content length if available or None otherwise.  Return type \nOptional[int]   \n  \ncall_on_close(func)  \nAdds a function to the internal list of functions that should be called as part of closing down the response. Since 0.7 this function also returns the function that was passed so that this can be used as a decorator.  Changelog New in version 0.6.   Parameters \nfunc (Callable[[], Any]) \u2013   Return type \nCallable[[], Any]   \n  \nclose()  \nClose the wrapped response if possible. You can also use the object in a with statement which will automatically close it.  Changelog New in version 0.9: Can now be used in a with statement.   Return type \nNone   \n  \ncontent_encoding  \nThe Content-Encoding entity-header field is used as a modifier to the media-type. When present, its value indicates what additional content codings have been applied to the entity-body, and thus what decoding mechanisms must be applied in order to obtain the media-type referenced by the Content-Type header field. \n  \nproperty content_language: werkzeug.datastructures.HeaderSet  \nThe Content-Language entity-header field describes the natural language(s) of the intended audience for the enclosed entity. Note that this might not be equivalent to all the languages used within the entity-body. \n  \ncontent_length  \nThe Content-Length entity-header field indicates the size of the entity-body, in decimal number of OCTETs, sent to the recipient or, in the case of the HEAD method, the size of the entity-body that would have been sent had the request been a GET. \n  \ncontent_location  \nThe Content-Location entity-header field MAY be used to supply the resource location for the entity enclosed in the message when that entity is accessible from a location separate from the requested resource\u2019s URI. \n  \ncontent_md5  \nThe Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest of the entity-body for the purpose of providing an end-to-end message integrity check (MIC) of the entity-body. (Note: a MIC is good for detecting accidental modification of the entity-body in transit, but is not proof against malicious attacks.) \n  \nproperty content_range: werkzeug.datastructures.ContentRange  \nThe Content-Range header as a ContentRange object. Available even if the header is not set.  Changelog New in version 0.7.  \n\n  \ncontent_security_policy  \nThe Content-Security-Policy header adds an additional layer of security to help detect and mitigate certain types of attacks. \n  \ncontent_security_policy_report_only  \nThe Content-Security-Policy-Report-Only header adds a csp policy that is not enforced but is reported thereby helping detect certain types of attacks. \n  \ncontent_type  \nThe Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of the HEAD method, the media type that would have been sent had the request been a GET. \n  \ncross_origin_embedder_policy  \nPrevents a document from loading any cross-origin resources that do not explicitly grant the document permission. Values must be a member of the werkzeug.http.COEP enum. \n  \ncross_origin_opener_policy  \nAllows control over sharing of browsing context group with cross-origin documents. Values must be a member of the werkzeug.http.COOP enum. \n  \nproperty data: Union[bytes, str]  \nA descriptor that calls get_data() and set_data(). \n  \ndate  \nThe Date general-header field represents the date and time at which the message was originated, having the same semantics as orig-date in RFC 822.  Changed in version 2.0: The datetime object is timezone-aware.  \n  \ndelete_cookie(key, path='/', domain=None, secure=False, httponly=False, samesite=None)  \nDelete a cookie. Fails silently if key doesn\u2019t exist.  Parameters \n \nkey (str) \u2013 the key (name) of the cookie to be deleted. \npath (str) \u2013 if the cookie that should be deleted was limited to a path, the path has to be defined here. \ndomain (Optional[str]) \u2013 if the cookie that should be deleted was limited to a domain, that domain has to be defined here. \nsecure (bool) \u2013 If True, the cookie will only be available via HTTPS. \nhttponly (bool) \u2013 Disallow JavaScript access to the cookie. \nsamesite (Optional[str]) \u2013 Limit the scope of the cookie to only be attached to requests that are \u201csame-site\u201d.   Return type \nNone   \n  \ndirect_passthrough  \nPass the response body directly through as the WSGI iterable. This can be used when the body is a binary file or other iterator of bytes, to skip some unnecessary checks. Use send_file() instead of setting this manually. \n  \nexpires  \nThe Expires entity-header field gives the date/time after which the response is considered stale. A stale cache entry may not normally be returned by a cache.  Changed in version 2.0: The datetime object is timezone-aware.  \n  \nclassmethod force_type(response, environ=None)  \nEnforce that the WSGI response is a response object of the current type. Werkzeug will use the Response internally in many situations like the exceptions. If you call get_response() on an exception you will get back a regular Response object, even if you are using a custom subclass. This method can enforce a given response type, and it will also convert arbitrary WSGI callables into response objects if an environ is provided: # convert a Werkzeug response object into an instance of the\n# MyResponseClass subclass.\nresponse = MyResponseClass.force_type(response)\n\n# convert any WSGI application into a response object\nresponse = MyResponseClass.force_type(response, environ)\n This is especially useful if you want to post-process responses in the main dispatcher and use functionality provided by your subclass. Keep in mind that this will modify response objects in place if possible!  Parameters \n \nresponse (Response) \u2013 a response object or wsgi application. \nenviron (Optional[WSGIEnvironment]) \u2013 a WSGI environment object.   Returns \na response object.  Return type \nResponse   \n  \nfreeze(no_etag=None)  \nMake the response object ready to be pickled. Does the following:  Buffer the response into a list, ignoring implicity_sequence_conversion and direct_passthrough. Set the Content-Length header. Generate an ETag header if one is not already set.   Changed in version 2.0: An ETag header is added, the no_etag parameter is deprecated and will be removed in Werkzeug 2.1.   Changelog Changed in version 0.6: The Content-Length header is set.   Parameters \nno_etag (None) \u2013   Return type \nNone   \n  \nclassmethod from_app(app, environ, buffered=False)  \nCreate a new response object from an application output. This works best if you pass it an application that returns a generator all the time. Sometimes applications may use the write() callable returned by the start_response function. This tries to resolve such edge cases automatically. But if you don\u2019t get the expected output you should set buffered to True which enforces buffering.  Parameters \n \napp (WSGIApplication) \u2013 the WSGI application to execute. \nenviron (WSGIEnvironment) \u2013 the WSGI environment to execute against. \nbuffered (bool) \u2013 set to True to enforce buffering.   Returns \na response object.  Return type \nResponse   \n  \nget_app_iter(environ)  \nReturns the application iterator for the given environ. Depending on the request method and the current status code the return value might be an empty response rather than the one from the response. If the request method is HEAD or the status code is in a range where the HTTP specification requires an empty response, an empty iterable is returned.  Changelog New in version 0.6.   Parameters \nenviron (WSGIEnvironment) \u2013 the WSGI environment of the request.  Returns \na response iterable.  Return type \nIterable[bytes]   \n  \nget_data(as_text=False)  \nThe string representation of the response body. Whenever you call this property the response iterable is encoded and flattened. This can lead to unwanted behavior if you stream big data. This behavior can be disabled by setting implicit_sequence_conversion to False. If as_text is set to True the return value will be a decoded string.  Changelog New in version 0.9.   Parameters \nas_text (bool) \u2013   Return type \nUnion[bytes, str]   \n  \nget_etag()  \nReturn a tuple in the form (etag, is_weak). If there is no ETag the return value is (None, None).  Return type \nUnion[Tuple[str, bool], Tuple[None, None]]   \n  \nget_json(force=False, silent=False)  \nParse data as JSON. Useful during testing. If the mimetype does not indicate JSON (application/json, see is_json()), this returns None. Unlike Request.get_json(), the result is not cached.  Parameters \n \nforce (bool) \u2013 Ignore the mimetype and always try to parse JSON. \nsilent (bool) \u2013 Silence parsing errors and return None instead.   Return type \nOptional[Any]   \n  \nget_wsgi_headers(environ)  \nThis is automatically called right before the response is started and returns headers modified for the given environment. It returns a copy of the headers from the response with some modifications applied if necessary. For example the location header (if present) is joined with the root URL of the environment. Also the content length is automatically set to zero here for certain status codes.  Changelog Changed in version 0.6: Previously that function was called fix_headers and modified the response object in place. Also since 0.6, IRIs in location and content-location headers are handled properly. Also starting with 0.6, Werkzeug will attempt to set the content length if it is able to figure it out on its own. This is the case if all the strings in the response iterable are already encoded and the iterable is buffered.   Parameters \nenviron (WSGIEnvironment) \u2013 the WSGI environment of the request.  Returns \nreturns a new Headers object.  Return type \nwerkzeug.datastructures.Headers   \n  \nget_wsgi_response(environ)  \nReturns the final WSGI response as tuple. The first item in the tuple is the application iterator, the second the status and the third the list of headers. The response returned is created specially for the given environment. For example if the request method in the WSGI environment is 'HEAD' the response will be empty and only the headers and status code will be present.  Changelog New in version 0.6.   Parameters \nenviron (WSGIEnvironment) \u2013 the WSGI environment of the request.  Returns \nan (app_iter, status, headers) tuple.  Return type \nTuple[Iterable[bytes], str, List[Tuple[str, str]]]   \n  \nimplicit_sequence_conversion = True  \nif set to False accessing properties on the response object will not try to consume the response iterator and convert it into a list.  Changelog New in version 0.6.2: That attribute was previously called implicit_seqence_conversion. (Notice the typo). If you did use this feature, you have to adapt your code to the name change.  \n\n  \nproperty is_json: bool  \nCheck if the mimetype indicates JSON data, either application/json or application/*+json. \n  \nproperty is_sequence: bool  \nIf the iterator is buffered, this property will be True. A response object will consider an iterator to be buffered if the response attribute is a list or tuple.  Changelog New in version 0.6.  \n\n  \nproperty is_streamed: bool  \nIf the response is streamed (the response is not an iterable with a length information) this property is True. In this case streamed means that there is no information about the number of iterations. This is usually True if a generator is passed to the response object. This is useful for checking before applying some sort of post filtering that should not take place for streamed responses. \n  \niter_encoded()  \nIter the response encoded with the encoding of the response. If the response object is invoked as WSGI application the return value of this method is used as application iterator unless direct_passthrough was activated.  Return type \nIterator[bytes]   \n  \nproperty json: Optional[Any]  \nThe parsed JSON data if mimetype indicates JSON (application/json, see is_json()). Calls get_json() with default arguments. \n  \njson_module = <module 'json' from '/home/docs/.pyenv/versions/3.7.9/lib/python3.7/json/__init__.py'>  \nA module or other object that has dumps and loads functions that match the API of the built-in json module. \n  \nlast_modified  \nThe Last-Modified entity-header field indicates the date and time at which the origin server believes the variant was last modified.  Changed in version 2.0: The datetime object is timezone-aware.  \n  \nlocation  \nThe Location response-header field is used to redirect the recipient to a location other than the Request-URI for completion of the request or identification of a new resource. \n  \nmake_conditional(request_or_environ, accept_ranges=False, complete_length=None)  \nMake the response conditional to the request. This method works best if an etag was defined for the response already. The add_etag method can be used to do that. If called without etag just the date header is set. This does nothing if the request method in the request or environ is anything but GET or HEAD. For optimal performance when handling range requests, it\u2019s recommended that your response data object implements seekable, seek and tell methods as described by io.IOBase. Objects returned by wrap_file() automatically implement those methods. It does not remove the body of the response because that\u2019s something the __call__() function does for us automatically. Returns self so that you can do return resp.make_conditional(req) but modifies the object in-place.  Parameters \n \nrequest_or_environ (WSGIEnvironment) \u2013 a request object or WSGI environment to be used to make the response conditional against. \naccept_ranges (Union[bool, str]) \u2013 This parameter dictates the value of Accept-Ranges header. If False (default), the header is not set. If True, it will be set to \"bytes\". If None, it will be set to \"none\". If it\u2019s a string, it will use this value. \ncomplete_length (Optional[int]) \u2013 Will be used only in valid Range Requests. It will set Content-Range complete length value and compute Content-Length real value. This parameter is mandatory for successful Range Requests completion.   Raises \nRequestedRangeNotSatisfiable if Range header could not be parsed or satisfied.  Return type \nResponse    Changed in version 2.0: Range processing is skipped if length is 0 instead of raising a 416 Range Not Satisfiable error.  \n  \nmake_sequence()  \nConverts the response iterator in a list. By default this happens automatically if required. If implicit_sequence_conversion is disabled, this method is not automatically called and some properties might raise exceptions. This also encodes all the items.  Changelog New in version 0.6.   Return type \nNone   \n  \nproperty mimetype: Optional[str]  \nThe mimetype (content type without charset etc.) \n  \nproperty mimetype_params: Dict[str, str]  \nThe mimetype parameters as dict. For example if the content type is text/html; charset=utf-8 the params would be {'charset': 'utf-8'}.  Changelog New in version 0.5.  \n\n  \nresponse: Union[Iterable[str], Iterable[bytes]]  \nThe response body to send as the WSGI iterable. A list of strings or bytes represents a fixed-length response, any other iterable is a streaming response. Strings are encoded to bytes as UTF-8. Do not set to a plain string or bytes, that will cause sending the response to be very inefficient as it will iterate one byte at a time. \n  \nproperty retry_after: Optional[datetime.datetime]  \nThe Retry-After response-header field can be used with a 503 (Service Unavailable) response to indicate how long the service is expected to be unavailable to the requesting client. Time in seconds until expiration or date.  Changed in version 2.0: The datetime object is timezone-aware.  \n  \nset_cookie(key, value='', max_age=None, expires=None, path='/', domain=None, secure=False, httponly=False, samesite=None)  \nSets a cookie. A warning is raised if the size of the cookie header exceeds max_cookie_size, but the header will still be set.  Parameters \n \nkey (str) \u2013 the key (name) of the cookie to be set. \nvalue (str) \u2013 the value of the cookie. \nmax_age (Optional[Union[datetime.timedelta, int]]) \u2013 should be a number of seconds, or None (default) if the cookie should last only as long as the client\u2019s browser session. \nexpires (Optional[Union[str, datetime.datetime, int, float]]) \u2013 should be a datetime object or UNIX timestamp. \npath (Optional[str]) \u2013 limits the cookie to a given path, per default it will span the whole domain. \ndomain (Optional[str]) \u2013 if you want to set a cross-domain cookie. For example, domain=\".example.com\" will set a cookie that is readable by the domain www.example.com, foo.example.com etc. Otherwise, a cookie will only be readable by the domain that set it. \nsecure (bool) \u2013 If True, the cookie will only be available via HTTPS. \nhttponly (bool) \u2013 Disallow JavaScript access to the cookie. \nsamesite (Optional[str]) \u2013 Limit the scope of the cookie to only be attached to requests that are \u201csame-site\u201d.   Return type \nNone   \n  \nset_data(value)  \nSets a new string as response. The value must be a string or bytes. If a string is set it\u2019s encoded to the charset of the response (utf-8 by default).  Changelog New in version 0.9.   Parameters \nvalue (Union[bytes, str]) \u2013   Return type \nNone   \n  \nset_etag(etag, weak=False)  \nSet the etag, and override the old one if there was one.  Parameters \n \netag (str) \u2013  \nweak (bool) \u2013    Return type \nNone   \n  \nproperty status: str  \nThe HTTP status code as a string. \n  \nproperty status_code: int  \nThe HTTP status code as a number. \n  \nproperty stream: werkzeug.wrappers.response.ResponseStream  \nThe response iterable as write-only stream. \n  \nproperty vary: werkzeug.datastructures.HeaderSet  \nThe Vary field value indicates the set of request-header fields that fully determines, while the response is fresh, whether a cache is permitted to use the response to reply to a subsequent request without revalidation. \n  \nproperty www_authenticate: werkzeug.datastructures.WWWAuthenticate  \nThe WWW-Authenticate header in a parsed form. \n \n \n"}, {"name": "Request.access_control_request_headers", "path": "wrappers/index#werkzeug.wrappers.Request.access_control_request_headers", "type": "werkzeug.wrappers", "text": " \naccess_control_request_headers  \nSent with a preflight request to indicate which headers will be sent with the cross origin request. Set access_control_allow_headers on the response to indicate which headers are allowed. \n"}, {"name": "Request.access_control_request_method", "path": "wrappers/index#werkzeug.wrappers.Request.access_control_request_method", "type": "werkzeug.wrappers", "text": " \naccess_control_request_method  \nSent with a preflight request to indicate which method will be used for the cross origin request. Set access_control_allow_methods on the response to indicate which methods are allowed. \n"}, {"name": "Request.application()", "path": "wrappers/index#werkzeug.wrappers.Request.application", "type": "werkzeug.wrappers", "text": " \nclassmethod application(f)  \nDecorate a function as responder that accepts the request as the last argument. This works like the responder() decorator but the function is passed the request object as the last argument and the request object will be closed automatically: @Request.application\ndef my_wsgi_app(request):\n    return Response('Hello World!')\n As of Werkzeug 0.14 HTTP exceptions are automatically caught and converted to responses instead of failing.  Parameters \nf (Callable[[Request], WSGIApplication]) \u2013 the WSGI callable to decorate  Returns \na new WSGI callable  Return type \nWSGIApplication   \n"}, {"name": "Request.close()", "path": "wrappers/index#werkzeug.wrappers.Request.close", "type": "werkzeug.wrappers", "text": " \nclose()  \nCloses associated resources of this request object. This closes all file handles explicitly. You can also use the request object in a with statement which will automatically close it.  Changelog New in version 0.9.   Return type \nNone   \n"}, {"name": "Request.content_encoding", "path": "wrappers/index#werkzeug.wrappers.Request.content_encoding", "type": "werkzeug.wrappers", "text": " \ncontent_encoding  \nThe Content-Encoding entity-header field is used as a modifier to the media-type. When present, its value indicates what additional content codings have been applied to the entity-body, and thus what decoding mechanisms must be applied in order to obtain the media-type referenced by the Content-Type header field.  Changelog New in version 0.9.  \n\n"}, {"name": "Request.content_md5", "path": "wrappers/index#werkzeug.wrappers.Request.content_md5", "type": "werkzeug.wrappers", "text": " \ncontent_md5  \nThe Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest of the entity-body for the purpose of providing an end-to-end message integrity check (MIC) of the entity-body. (Note: a MIC is good for detecting accidental modification of the entity-body in transit, but is not proof against malicious attacks.)  Changelog New in version 0.9.  \n\n"}, {"name": "Request.content_type", "path": "wrappers/index#werkzeug.wrappers.Request.content_type", "type": "werkzeug.wrappers", "text": " \ncontent_type  \nThe Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of the HEAD method, the media type that would have been sent had the request been a GET. \n"}, {"name": "Request.date", "path": "wrappers/index#werkzeug.wrappers.Request.date", "type": "werkzeug.wrappers", "text": " \ndate  \nThe Date general-header field represents the date and time at which the message was originated, having the same semantics as orig-date in RFC 822.  Changed in version 2.0: The datetime object is timezone-aware.  \n"}, {"name": "Request.dict_storage_class", "path": "wrappers/index#werkzeug.wrappers.Request.dict_storage_class", "type": "werkzeug.wrappers", "text": " \ndict_storage_class  \nalias of werkzeug.datastructures.ImmutableMultiDict \n"}, {"name": "Request.disable_data_descriptor", "path": "wrappers/index#werkzeug.wrappers.Request.disable_data_descriptor", "type": "werkzeug.wrappers", "text": " \ndisable_data_descriptor: Optional[bool] = None  \nDisable the data property to avoid reading from the input stream.  Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Create the request with shallow=True instead.   Changelog New in version 0.9.  \n\n"}, {"name": "Request.environ", "path": "wrappers/index#werkzeug.wrappers.Request.environ", "type": "werkzeug.wrappers", "text": " \nenviron: WSGIEnvironment  \nThe WSGI environment containing HTTP headers and information from the WSGI server. \n"}, {"name": "Request.form_data_parser_class", "path": "wrappers/index#werkzeug.wrappers.Request.form_data_parser_class", "type": "werkzeug.wrappers", "text": " \nform_data_parser_class  \nalias of werkzeug.formparser.FormDataParser \n"}, {"name": "Request.from_values()", "path": "wrappers/index#werkzeug.wrappers.Request.from_values", "type": "werkzeug.wrappers", "text": " \nclassmethod from_values(*args, **kwargs)  \nCreate a new request object based on the values provided. If environ is given missing values are filled from there. This method is useful for small scripts when you need to simulate a request from an URL. Do not use this method for unittesting, there is a full featured client object (Client) that allows to create multipart requests, support for cookies etc. This accepts the same options as the EnvironBuilder.  Changelog Changed in version 0.5: This method now accepts the same arguments as EnvironBuilder. Because of this the environ parameter is now called environ_overrides.   Returns \nrequest object  Parameters \n \nargs (Any) \u2013  \nkwargs (Any) \u2013    Return type \nwerkzeug.wrappers.request.Request   \n"}, {"name": "Request.get_data()", "path": "wrappers/index#werkzeug.wrappers.Request.get_data", "type": "werkzeug.wrappers", "text": " \nget_data(cache=True, as_text=False, parse_form_data=False)  \nThis reads the buffered incoming data from the client into one bytes object. By default this is cached but that behavior can be changed by setting cache to False. Usually it\u2019s a bad idea to call this method without checking the content length first as a client could send dozens of megabytes or more to cause memory problems on the server. Note that if the form data was already parsed this method will not return anything as form data parsing does not cache the data like this method does. To implicitly invoke form data parsing function set parse_form_data to True. When this is done the return value of this method will be an empty string if the form parser handles the data. This generally is not necessary as if the whole data is cached (which is the default) the form parser will used the cached data to parse the form data. Please be generally aware of checking the content length first in any case before calling this method to avoid exhausting server memory. If as_text is set to True the return value will be a decoded string.  Changelog New in version 0.9.   Parameters \n \ncache (bool) \u2013  \nas_text (bool) \u2013  \nparse_form_data (bool) \u2013    Return type \nUnion[bytes, str]   \n"}, {"name": "Request.get_json()", "path": "wrappers/index#werkzeug.wrappers.Request.get_json", "type": "werkzeug.wrappers", "text": " \nget_json(force=False, silent=False, cache=True)  \nParse data as JSON. If the mimetype does not indicate JSON (application/json, see is_json()), this returns None. If parsing fails, on_json_loading_failed() is called and its return value is used as the return value.  Parameters \n \nforce (bool) \u2013 Ignore the mimetype and always try to parse JSON. \nsilent (bool) \u2013 Silence parsing errors and return None instead. \ncache (bool) \u2013 Store the parsed JSON to return for subsequent calls.   Return type \nOptional[Any]   \n"}, {"name": "Request.headers", "path": "wrappers/index#werkzeug.wrappers.Request.headers", "type": "werkzeug.wrappers", "text": " \nheaders  \nThe headers received with the request. \n"}, {"name": "Request.input_stream", "path": "wrappers/index#werkzeug.wrappers.Request.input_stream", "type": "werkzeug.wrappers", "text": " \ninput_stream  \nThe WSGI input stream. In general it\u2019s a bad idea to use this one because you can easily read past the boundary. Use the stream instead. \n"}, {"name": "Request.is_multiprocess", "path": "wrappers/index#werkzeug.wrappers.Request.is_multiprocess", "type": "werkzeug.wrappers", "text": " \nis_multiprocess  \nboolean that is True if the application is served by a WSGI server that spawns multiple processes. \n"}, {"name": "Request.is_multithread", "path": "wrappers/index#werkzeug.wrappers.Request.is_multithread", "type": "werkzeug.wrappers", "text": " \nis_multithread  \nboolean that is True if the application is served by a multithreaded WSGI server. \n"}, {"name": "Request.is_run_once", "path": "wrappers/index#werkzeug.wrappers.Request.is_run_once", "type": "werkzeug.wrappers", "text": " \nis_run_once  \nboolean that is True if the application will be executed only once in a process lifetime. This is the case for CGI for example, but it\u2019s not guaranteed that the execution only happens one time. \n"}, {"name": "Request.json_module", "path": "wrappers/index#werkzeug.wrappers.Request.json_module", "type": "werkzeug.wrappers", "text": " \njson_module = <module 'json' from '/home/docs/.pyenv/versions/3.7.9/lib/python3.7/json/__init__.py'>  \nA module or other object that has dumps and loads functions that match the API of the built-in json module. \n"}, {"name": "Request.list_storage_class", "path": "wrappers/index#werkzeug.wrappers.Request.list_storage_class", "type": "werkzeug.wrappers", "text": " \nlist_storage_class  \nalias of werkzeug.datastructures.ImmutableList \n"}, {"name": "Request.make_form_data_parser()", "path": "wrappers/index#werkzeug.wrappers.Request.make_form_data_parser", "type": "werkzeug.wrappers", "text": " \nmake_form_data_parser()  \nCreates the form data parser. Instantiates the form_data_parser_class with some parameters.  Changelog New in version 0.8.   Return type \nwerkzeug.formparser.FormDataParser   \n"}, {"name": "Request.max_content_length", "path": "wrappers/index#werkzeug.wrappers.Request.max_content_length", "type": "werkzeug.wrappers", "text": " \nmax_content_length: Optional[int] = None  \nthe maximum content length. This is forwarded to the form data parsing function (parse_form_data()). When set and the form or files attribute is accessed and the parsing fails because more than the specified value is transmitted a RequestEntityTooLarge exception is raised. Have a look at Dealing with Request Data for more details.  Changelog New in version 0.5.  \n\n"}, {"name": "Request.max_form_memory_size", "path": "wrappers/index#werkzeug.wrappers.Request.max_form_memory_size", "type": "werkzeug.wrappers", "text": " \nmax_form_memory_size: Optional[int] = None  \nthe maximum form field size. This is forwarded to the form data parsing function (parse_form_data()). When set and the form or files attribute is accessed and the data in memory for post data is longer than the specified value a RequestEntityTooLarge exception is raised. Have a look at Dealing with Request Data for more details.  Changelog New in version 0.5.  \n\n"}, {"name": "Request.max_forwards", "path": "wrappers/index#werkzeug.wrappers.Request.max_forwards", "type": "werkzeug.wrappers", "text": " \nmax_forwards  \nThe Max-Forwards request-header field provides a mechanism with the TRACE and OPTIONS methods to limit the number of proxies or gateways that can forward the request to the next inbound server. \n"}, {"name": "Request.method", "path": "wrappers/index#werkzeug.wrappers.Request.method", "type": "werkzeug.wrappers", "text": " \nmethod  \nThe method the request was made with, such as GET. \n"}, {"name": "Request.on_json_loading_failed()", "path": "wrappers/index#werkzeug.wrappers.Request.on_json_loading_failed", "type": "werkzeug.wrappers", "text": " \non_json_loading_failed(e)  \nCalled if get_json() parsing fails and isn\u2019t silenced. If this method returns a value, it is used as the return value for get_json(). The default implementation raises BadRequest.  Parameters \ne (ValueError) \u2013   Return type \nAny   \n"}, {"name": "Request.origin", "path": "wrappers/index#werkzeug.wrappers.Request.origin", "type": "werkzeug.wrappers", "text": " \norigin  \nThe host that the request originated from. Set access_control_allow_origin on the response to indicate which origins are allowed. \n"}, {"name": "Request.parameter_storage_class", "path": "wrappers/index#werkzeug.wrappers.Request.parameter_storage_class", "type": "werkzeug.wrappers", "text": " \nparameter_storage_class  \nalias of werkzeug.datastructures.ImmutableMultiDict \n"}, {"name": "Request.path", "path": "wrappers/index#werkzeug.wrappers.Request.path", "type": "werkzeug.wrappers", "text": " \npath  \nThe path part of the URL after root_path. This is the path used for routing within the application. \n"}, {"name": "Request.query_string", "path": "wrappers/index#werkzeug.wrappers.Request.query_string", "type": "werkzeug.wrappers", "text": " \nquery_string  \nThe part of the URL after the \u201c?\u201d. This is the raw value, use args for the parsed values. \n"}, {"name": "Request.referrer", "path": "wrappers/index#werkzeug.wrappers.Request.referrer", "type": "werkzeug.wrappers", "text": " \nreferrer  \nThe Referer[sic] request-header field allows the client to specify, for the server\u2019s benefit, the address (URI) of the resource from which the Request-URI was obtained (the \u201creferrer\u201d, although the header field is misspelled). \n"}, {"name": "Request.remote_addr", "path": "wrappers/index#werkzeug.wrappers.Request.remote_addr", "type": "werkzeug.wrappers", "text": " \nremote_addr  \nThe address of the client sending the request. \n"}, {"name": "Request.remote_user", "path": "wrappers/index#werkzeug.wrappers.Request.remote_user", "type": "werkzeug.wrappers", "text": " \nremote_user  \nIf the server supports user authentication, and the script is protected, this attribute contains the username the user has authenticated as. \n"}, {"name": "Request.root_path", "path": "wrappers/index#werkzeug.wrappers.Request.root_path", "type": "werkzeug.wrappers", "text": " \nroot_path  \nThe prefix that the application is mounted under, without a trailing slash. path comes after this. \n"}, {"name": "Request.scheme", "path": "wrappers/index#werkzeug.wrappers.Request.scheme", "type": "werkzeug.wrappers", "text": " \nscheme  \nThe URL scheme of the protocol the request used, such as https or wss. \n"}, {"name": "Request.server", "path": "wrappers/index#werkzeug.wrappers.Request.server", "type": "werkzeug.wrappers", "text": " \nserver  \nThe address of the server. (host, port), (path, None) for unix sockets, or None if not known. \n"}, {"name": "Request.shallow", "path": "wrappers/index#werkzeug.wrappers.Request.shallow", "type": "werkzeug.wrappers", "text": " \nshallow: bool  \nSet when creating the request object. If True, reading from the request body will cause a RuntimeException. Useful to prevent modifying the stream from middleware. \n"}, {"name": "Request.user_agent_class", "path": "wrappers/index#werkzeug.wrappers.Request.user_agent_class", "type": "werkzeug.wrappers", "text": " \nuser_agent_class  \nalias of werkzeug.useragents._UserAgent \n"}, {"name": "Request._get_file_stream()", "path": "wrappers/index#werkzeug.wrappers.Request._get_file_stream", "type": "werkzeug.wrappers", "text": " \n_get_file_stream(total_content_length, content_type, filename=None, content_length=None)  \nCalled to get a stream for the file upload. This must provide a file-like class with read(), readline() and seek() methods that is both writeable and readable. The default implementation returns a temporary file if the total content length is higher than 500KB. Because many browsers do not provide a content length for the files only the total content length matters.  Parameters \n \ntotal_content_length (Optional[int]) \u2013 the total content length of all the data in the request combined. This value is guaranteed to be there. \ncontent_type (Optional[str]) \u2013 the mimetype of the uploaded file. \nfilename (Optional[str]) \u2013 the filename of the uploaded file. May be None. \ncontent_length (Optional[int]) \u2013 the length of this file. This value is usually not provided because webbrowsers do not provide this value.   Return type \nBinaryIO   \n"}, {"name": "RequestCacheControl", "path": "datastructures/index#werkzeug.datastructures.RequestCacheControl", "type": "werkzeug.datastructures", "text": " \nclass werkzeug.datastructures.RequestCacheControl(values=(), on_update=None)  \nA cache control for requests. This is immutable and gives access to all the request-relevant cache control headers. To get a header of the RequestCacheControl object again you can convert the object into a string or call the to_header() method. If you plan to subclass it and add your own items have a look at the sourcecode for that class.  Changelog New in version 0.5: In previous versions a CacheControl class existed that was used both for request and response.   \nno_cache  \naccessor for \u2018no-cache\u2019 \n  \nno_store  \naccessor for \u2018no-store\u2019 \n  \nmax_age  \naccessor for \u2018max-age\u2019 \n  \nno_transform  \naccessor for \u2018no-transform\u2019 \n  \nproperty max_stale  \naccessor for \u2018max-stale\u2019 \n  \nproperty min_fresh  \naccessor for \u2018min-fresh\u2019 \n  \nproperty only_if_cached  \naccessor for \u2018only-if-cached\u2019 \n \n"}, {"name": "RequestCacheControl.max_age", "path": "datastructures/index#werkzeug.datastructures.RequestCacheControl.max_age", "type": "werkzeug.datastructures", "text": " \nmax_age  \naccessor for \u2018max-age\u2019 \n"}, {"name": "RequestCacheControl.no_cache", "path": "datastructures/index#werkzeug.datastructures.RequestCacheControl.no_cache", "type": "werkzeug.datastructures", "text": " \nno_cache  \naccessor for \u2018no-cache\u2019 \n"}, {"name": "RequestCacheControl.no_store", "path": "datastructures/index#werkzeug.datastructures.RequestCacheControl.no_store", "type": "werkzeug.datastructures", "text": " \nno_store  \naccessor for \u2018no-store\u2019 \n"}, {"name": "RequestCacheControl.no_transform", "path": "datastructures/index#werkzeug.datastructures.RequestCacheControl.no_transform", "type": "werkzeug.datastructures", "text": " \nno_transform  \naccessor for \u2018no-transform\u2019 \n"}, {"name": "responder()", "path": "wsgi/index#werkzeug.wsgi.responder", "type": "werkzeug.wsgi", "text": " \nwerkzeug.wsgi.responder(f)  \nMarks a function as responder. Decorate a function with it and it will automatically call the return value as WSGI application. Example: @responder\ndef application(environ, start_response):\n    return Response('Hello World!')\n  Parameters \nf (Callable[[...], WSGIApplication]) \u2013   Return type \nWSGIApplication   \n"}, {"name": "Response", "path": "wrappers/index#werkzeug.wrappers.Response", "type": "werkzeug.wrappers", "text": " \nclass werkzeug.wrappers.Response(response=None, status=None, headers=None, mimetype=None, content_type=None, direct_passthrough=False)  \nRepresents an outgoing WSGI HTTP response with body, status, and headers. Has properties and methods for using the functionality defined by various HTTP specs. The response body is flexible to support different use cases. The simple form is passing bytes, or a string which will be encoded as UTF-8. Passing an iterable of bytes or strings makes this a streaming response. A generator is particularly useful for building a CSV file in memory or using SSE (Server Sent Events). A file-like object is also iterable, although the send_file() helper should be used in that case. The response object is itself a WSGI application callable. When called (__call__()) with environ and start_response, it will pass its status and headers to start_response then return its body as an iterable. from werkzeug.wrappers.response import Response\n\ndef index():\n    return Response(\"Hello, World!\")\n\ndef application(environ, start_response):\n    path = environ.get(\"PATH_INFO\") or \"/\"\n\n    if path == \"/\":\n        response = index()\n    else:\n        response = Response(\"Not Found\", status=404)\n\n    return response(environ, start_response)\n  Parameters \n \nresponse (Union[Iterable[str], Iterable[bytes]]) \u2013 The data for the body of the response. A string or bytes, or tuple or list of strings or bytes, for a fixed-length response, or any other iterable of strings or bytes for a streaming response. Defaults to an empty body. \nstatus (Optional[Union[int, str, http.HTTPStatus]]) \u2013 The status code for the response. Either an int, in which case the default status message is added, or a string in the form {code} {message}, like 404 Not Found. Defaults to 200. \nheaders (werkzeug.datastructures.Headers) \u2013 A Headers object, or a list of (key, value) tuples that will be converted to a Headers object. \nmimetype (Optional[str]) \u2013 The mime type (content type without charset or other parameters) of the response. If the value starts with text/ (or matches some other special cases), the charset will be added to create the content_type. \ncontent_type (Optional[str]) \u2013 The full content type of the response. Overrides building the value from mimetype. \ndirect_passthrough (bool) \u2013 Pass the response body directly through as the WSGI iterable. This can be used when the body is a binary file or other iterator of bytes, to skip some unnecessary checks. Use send_file() instead of setting this manually.   Return type \nNone    Changed in version 2.0: Combine BaseResponse and mixins into a single Response class. Using the old classes is deprecated and will be removed in Werkzeug 2.1.   Changelog Changed in version 0.5: The direct_passthrough parameter was added.   \n__call__(environ, start_response)  \nProcess this response as WSGI application.  Parameters \n \nenviron (WSGIEnvironment) \u2013 the WSGI environment. \nstart_response (StartResponse) \u2013 the response callable provided by the WSGI server.   Returns \nan application iterator  Return type \nIterable[bytes]   \n  \n_ensure_sequence(mutable=False)  \nThis method can be called by methods that need a sequence. If mutable is true, it will also ensure that the response sequence is a standard Python list.  Changelog New in version 0.6.   Parameters \nmutable (bool) \u2013   Return type \nNone   \n  \naccept_ranges  \nThe Accept-Ranges header. Even though the name would indicate that multiple values are supported, it must be one string token only. The values 'bytes' and 'none' are common.  Changelog New in version 0.7.  \n\n  \nproperty access_control_allow_credentials: bool  \nWhether credentials can be shared by the browser to JavaScript code. As part of the preflight request it indicates whether credentials can be used on the cross origin request. \n  \naccess_control_allow_headers  \nWhich headers can be sent with the cross origin request. \n  \naccess_control_allow_methods  \nWhich methods can be used for the cross origin request. \n  \naccess_control_allow_origin  \nThe origin or \u2018*\u2019 for any origin that may make cross origin requests. \n  \naccess_control_expose_headers  \nWhich headers can be shared by the browser to JavaScript code. \n  \naccess_control_max_age  \nThe maximum age in seconds the access control settings can be cached for. \n  \nadd_etag(overwrite=False, weak=False)  \nAdd an etag for the current response if there is none yet.  Changed in version 2.0: SHA-1 is used to generate the value. MD5 may not be available in some environments.   Parameters \n \noverwrite (bool) \u2013  \nweak (bool) \u2013    Return type \nNone   \n  \nage  \nThe Age response-header field conveys the sender\u2019s estimate of the amount of time since the response (or its revalidation) was generated at the origin server. Age values are non-negative decimal integers, representing time in seconds. \n  \nproperty allow: werkzeug.datastructures.HeaderSet  \nThe Allow entity-header field lists the set of methods supported by the resource identified by the Request-URI. The purpose of this field is strictly to inform the recipient of valid methods associated with the resource. An Allow header field MUST be present in a 405 (Method Not Allowed) response. \n  \nautocorrect_location_header = True  \nShould this response object correct the location header to be RFC conformant? This is true by default.  Changelog New in version 0.8.  \n\n  \nautomatically_set_content_length = True  \nShould this response object automatically set the content-length header if possible? This is true by default.  Changelog New in version 0.8.  \n\n  \nproperty cache_control: werkzeug.datastructures.ResponseCacheControl  \nThe Cache-Control general-header field is used to specify directives that MUST be obeyed by all caching mechanisms along the request/response chain. \n  \ncalculate_content_length()  \nReturns the content length if available or None otherwise.  Return type \nOptional[int]   \n  \ncall_on_close(func)  \nAdds a function to the internal list of functions that should be called as part of closing down the response. Since 0.7 this function also returns the function that was passed so that this can be used as a decorator.  Changelog New in version 0.6.   Parameters \nfunc (Callable[[], Any]) \u2013   Return type \nCallable[[], Any]   \n  \nclose()  \nClose the wrapped response if possible. You can also use the object in a with statement which will automatically close it.  Changelog New in version 0.9: Can now be used in a with statement.   Return type \nNone   \n  \ncontent_encoding  \nThe Content-Encoding entity-header field is used as a modifier to the media-type. When present, its value indicates what additional content codings have been applied to the entity-body, and thus what decoding mechanisms must be applied in order to obtain the media-type referenced by the Content-Type header field. \n  \nproperty content_language: werkzeug.datastructures.HeaderSet  \nThe Content-Language entity-header field describes the natural language(s) of the intended audience for the enclosed entity. Note that this might not be equivalent to all the languages used within the entity-body. \n  \ncontent_length  \nThe Content-Length entity-header field indicates the size of the entity-body, in decimal number of OCTETs, sent to the recipient or, in the case of the HEAD method, the size of the entity-body that would have been sent had the request been a GET. \n  \ncontent_location  \nThe Content-Location entity-header field MAY be used to supply the resource location for the entity enclosed in the message when that entity is accessible from a location separate from the requested resource\u2019s URI. \n  \ncontent_md5  \nThe Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest of the entity-body for the purpose of providing an end-to-end message integrity check (MIC) of the entity-body. (Note: a MIC is good for detecting accidental modification of the entity-body in transit, but is not proof against malicious attacks.) \n  \nproperty content_range: werkzeug.datastructures.ContentRange  \nThe Content-Range header as a ContentRange object. Available even if the header is not set.  Changelog New in version 0.7.  \n\n  \ncontent_security_policy  \nThe Content-Security-Policy header adds an additional layer of security to help detect and mitigate certain types of attacks. \n  \ncontent_security_policy_report_only  \nThe Content-Security-Policy-Report-Only header adds a csp policy that is not enforced but is reported thereby helping detect certain types of attacks. \n  \ncontent_type  \nThe Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of the HEAD method, the media type that would have been sent had the request been a GET. \n  \ncross_origin_embedder_policy  \nPrevents a document from loading any cross-origin resources that do not explicitly grant the document permission. Values must be a member of the werkzeug.http.COEP enum. \n  \ncross_origin_opener_policy  \nAllows control over sharing of browsing context group with cross-origin documents. Values must be a member of the werkzeug.http.COOP enum. \n  \nproperty data: Union[bytes, str]  \nA descriptor that calls get_data() and set_data(). \n  \ndate  \nThe Date general-header field represents the date and time at which the message was originated, having the same semantics as orig-date in RFC 822.  Changed in version 2.0: The datetime object is timezone-aware.  \n  \ndelete_cookie(key, path='/', domain=None, secure=False, httponly=False, samesite=None)  \nDelete a cookie. Fails silently if key doesn\u2019t exist.  Parameters \n \nkey (str) \u2013 the key (name) of the cookie to be deleted. \npath (str) \u2013 if the cookie that should be deleted was limited to a path, the path has to be defined here. \ndomain (Optional[str]) \u2013 if the cookie that should be deleted was limited to a domain, that domain has to be defined here. \nsecure (bool) \u2013 If True, the cookie will only be available via HTTPS. \nhttponly (bool) \u2013 Disallow JavaScript access to the cookie. \nsamesite (Optional[str]) \u2013 Limit the scope of the cookie to only be attached to requests that are \u201csame-site\u201d.   Return type \nNone   \n  \ndirect_passthrough  \nPass the response body directly through as the WSGI iterable. This can be used when the body is a binary file or other iterator of bytes, to skip some unnecessary checks. Use send_file() instead of setting this manually. \n  \nexpires  \nThe Expires entity-header field gives the date/time after which the response is considered stale. A stale cache entry may not normally be returned by a cache.  Changed in version 2.0: The datetime object is timezone-aware.  \n  \nclassmethod force_type(response, environ=None)  \nEnforce that the WSGI response is a response object of the current type. Werkzeug will use the Response internally in many situations like the exceptions. If you call get_response() on an exception you will get back a regular Response object, even if you are using a custom subclass. This method can enforce a given response type, and it will also convert arbitrary WSGI callables into response objects if an environ is provided: # convert a Werkzeug response object into an instance of the\n# MyResponseClass subclass.\nresponse = MyResponseClass.force_type(response)\n\n# convert any WSGI application into a response object\nresponse = MyResponseClass.force_type(response, environ)\n This is especially useful if you want to post-process responses in the main dispatcher and use functionality provided by your subclass. Keep in mind that this will modify response objects in place if possible!  Parameters \n \nresponse (Response) \u2013 a response object or wsgi application. \nenviron (Optional[WSGIEnvironment]) \u2013 a WSGI environment object.   Returns \na response object.  Return type \nResponse   \n  \nfreeze(no_etag=None)  \nMake the response object ready to be pickled. Does the following:  Buffer the response into a list, ignoring implicity_sequence_conversion and direct_passthrough. Set the Content-Length header. Generate an ETag header if one is not already set.   Changed in version 2.0: An ETag header is added, the no_etag parameter is deprecated and will be removed in Werkzeug 2.1.   Changelog Changed in version 0.6: The Content-Length header is set.   Parameters \nno_etag (None) \u2013   Return type \nNone   \n  \nclassmethod from_app(app, environ, buffered=False)  \nCreate a new response object from an application output. This works best if you pass it an application that returns a generator all the time. Sometimes applications may use the write() callable returned by the start_response function. This tries to resolve such edge cases automatically. But if you don\u2019t get the expected output you should set buffered to True which enforces buffering.  Parameters \n \napp (WSGIApplication) \u2013 the WSGI application to execute. \nenviron (WSGIEnvironment) \u2013 the WSGI environment to execute against. \nbuffered (bool) \u2013 set to True to enforce buffering.   Returns \na response object.  Return type \nResponse   \n  \nget_app_iter(environ)  \nReturns the application iterator for the given environ. Depending on the request method and the current status code the return value might be an empty response rather than the one from the response. If the request method is HEAD or the status code is in a range where the HTTP specification requires an empty response, an empty iterable is returned.  Changelog New in version 0.6.   Parameters \nenviron (WSGIEnvironment) \u2013 the WSGI environment of the request.  Returns \na response iterable.  Return type \nIterable[bytes]   \n  \nget_data(as_text=False)  \nThe string representation of the response body. Whenever you call this property the response iterable is encoded and flattened. This can lead to unwanted behavior if you stream big data. This behavior can be disabled by setting implicit_sequence_conversion to False. If as_text is set to True the return value will be a decoded string.  Changelog New in version 0.9.   Parameters \nas_text (bool) \u2013   Return type \nUnion[bytes, str]   \n  \nget_etag()  \nReturn a tuple in the form (etag, is_weak). If there is no ETag the return value is (None, None).  Return type \nUnion[Tuple[str, bool], Tuple[None, None]]   \n  \nget_json(force=False, silent=False)  \nParse data as JSON. Useful during testing. If the mimetype does not indicate JSON (application/json, see is_json()), this returns None. Unlike Request.get_json(), the result is not cached.  Parameters \n \nforce (bool) \u2013 Ignore the mimetype and always try to parse JSON. \nsilent (bool) \u2013 Silence parsing errors and return None instead.   Return type \nOptional[Any]   \n  \nget_wsgi_headers(environ)  \nThis is automatically called right before the response is started and returns headers modified for the given environment. It returns a copy of the headers from the response with some modifications applied if necessary. For example the location header (if present) is joined with the root URL of the environment. Also the content length is automatically set to zero here for certain status codes.  Changelog Changed in version 0.6: Previously that function was called fix_headers and modified the response object in place. Also since 0.6, IRIs in location and content-location headers are handled properly. Also starting with 0.6, Werkzeug will attempt to set the content length if it is able to figure it out on its own. This is the case if all the strings in the response iterable are already encoded and the iterable is buffered.   Parameters \nenviron (WSGIEnvironment) \u2013 the WSGI environment of the request.  Returns \nreturns a new Headers object.  Return type \nwerkzeug.datastructures.Headers   \n  \nget_wsgi_response(environ)  \nReturns the final WSGI response as tuple. The first item in the tuple is the application iterator, the second the status and the third the list of headers. The response returned is created specially for the given environment. For example if the request method in the WSGI environment is 'HEAD' the response will be empty and only the headers and status code will be present.  Changelog New in version 0.6.   Parameters \nenviron (WSGIEnvironment) \u2013 the WSGI environment of the request.  Returns \nan (app_iter, status, headers) tuple.  Return type \nTuple[Iterable[bytes], str, List[Tuple[str, str]]]   \n  \nimplicit_sequence_conversion = True  \nif set to False accessing properties on the response object will not try to consume the response iterator and convert it into a list.  Changelog New in version 0.6.2: That attribute was previously called implicit_seqence_conversion. (Notice the typo). If you did use this feature, you have to adapt your code to the name change.  \n\n  \nproperty is_json: bool  \nCheck if the mimetype indicates JSON data, either application/json or application/*+json. \n  \nproperty is_sequence: bool  \nIf the iterator is buffered, this property will be True. A response object will consider an iterator to be buffered if the response attribute is a list or tuple.  Changelog New in version 0.6.  \n\n  \nproperty is_streamed: bool  \nIf the response is streamed (the response is not an iterable with a length information) this property is True. In this case streamed means that there is no information about the number of iterations. This is usually True if a generator is passed to the response object. This is useful for checking before applying some sort of post filtering that should not take place for streamed responses. \n  \niter_encoded()  \nIter the response encoded with the encoding of the response. If the response object is invoked as WSGI application the return value of this method is used as application iterator unless direct_passthrough was activated.  Return type \nIterator[bytes]   \n  \nproperty json: Optional[Any]  \nThe parsed JSON data if mimetype indicates JSON (application/json, see is_json()). Calls get_json() with default arguments. \n  \njson_module = <module 'json' from '/home/docs/.pyenv/versions/3.7.9/lib/python3.7/json/__init__.py'>  \nA module or other object that has dumps and loads functions that match the API of the built-in json module. \n  \nlast_modified  \nThe Last-Modified entity-header field indicates the date and time at which the origin server believes the variant was last modified.  Changed in version 2.0: The datetime object is timezone-aware.  \n  \nlocation  \nThe Location response-header field is used to redirect the recipient to a location other than the Request-URI for completion of the request or identification of a new resource. \n  \nmake_conditional(request_or_environ, accept_ranges=False, complete_length=None)  \nMake the response conditional to the request. This method works best if an etag was defined for the response already. The add_etag method can be used to do that. If called without etag just the date header is set. This does nothing if the request method in the request or environ is anything but GET or HEAD. For optimal performance when handling range requests, it\u2019s recommended that your response data object implements seekable, seek and tell methods as described by io.IOBase. Objects returned by wrap_file() automatically implement those methods. It does not remove the body of the response because that\u2019s something the __call__() function does for us automatically. Returns self so that you can do return resp.make_conditional(req) but modifies the object in-place.  Parameters \n \nrequest_or_environ (WSGIEnvironment) \u2013 a request object or WSGI environment to be used to make the response conditional against. \naccept_ranges (Union[bool, str]) \u2013 This parameter dictates the value of Accept-Ranges header. If False (default), the header is not set. If True, it will be set to \"bytes\". If None, it will be set to \"none\". If it\u2019s a string, it will use this value. \ncomplete_length (Optional[int]) \u2013 Will be used only in valid Range Requests. It will set Content-Range complete length value and compute Content-Length real value. This parameter is mandatory for successful Range Requests completion.   Raises \nRequestedRangeNotSatisfiable if Range header could not be parsed or satisfied.  Return type \nResponse    Changed in version 2.0: Range processing is skipped if length is 0 instead of raising a 416 Range Not Satisfiable error.  \n  \nmake_sequence()  \nConverts the response iterator in a list. By default this happens automatically if required. If implicit_sequence_conversion is disabled, this method is not automatically called and some properties might raise exceptions. This also encodes all the items.  Changelog New in version 0.6.   Return type \nNone   \n  \nproperty mimetype: Optional[str]  \nThe mimetype (content type without charset etc.) \n  \nproperty mimetype_params: Dict[str, str]  \nThe mimetype parameters as dict. For example if the content type is text/html; charset=utf-8 the params would be {'charset': 'utf-8'}.  Changelog New in version 0.5.  \n\n  \nresponse: Union[Iterable[str], Iterable[bytes]]  \nThe response body to send as the WSGI iterable. A list of strings or bytes represents a fixed-length response, any other iterable is a streaming response. Strings are encoded to bytes as UTF-8. Do not set to a plain string or bytes, that will cause sending the response to be very inefficient as it will iterate one byte at a time. \n  \nproperty retry_after: Optional[datetime.datetime]  \nThe Retry-After response-header field can be used with a 503 (Service Unavailable) response to indicate how long the service is expected to be unavailable to the requesting client. Time in seconds until expiration or date.  Changed in version 2.0: The datetime object is timezone-aware.  \n  \nset_cookie(key, value='', max_age=None, expires=None, path='/', domain=None, secure=False, httponly=False, samesite=None)  \nSets a cookie. A warning is raised if the size of the cookie header exceeds max_cookie_size, but the header will still be set.  Parameters \n \nkey (str) \u2013 the key (name) of the cookie to be set. \nvalue (str) \u2013 the value of the cookie. \nmax_age (Optional[Union[datetime.timedelta, int]]) \u2013 should be a number of seconds, or None (default) if the cookie should last only as long as the client\u2019s browser session. \nexpires (Optional[Union[str, datetime.datetime, int, float]]) \u2013 should be a datetime object or UNIX timestamp. \npath (Optional[str]) \u2013 limits the cookie to a given path, per default it will span the whole domain. \ndomain (Optional[str]) \u2013 if you want to set a cross-domain cookie. For example, domain=\".example.com\" will set a cookie that is readable by the domain www.example.com, foo.example.com etc. Otherwise, a cookie will only be readable by the domain that set it. \nsecure (bool) \u2013 If True, the cookie will only be available via HTTPS. \nhttponly (bool) \u2013 Disallow JavaScript access to the cookie. \nsamesite (Optional[str]) \u2013 Limit the scope of the cookie to only be attached to requests that are \u201csame-site\u201d.   Return type \nNone   \n  \nset_data(value)  \nSets a new string as response. The value must be a string or bytes. If a string is set it\u2019s encoded to the charset of the response (utf-8 by default).  Changelog New in version 0.9.   Parameters \nvalue (Union[bytes, str]) \u2013   Return type \nNone   \n  \nset_etag(etag, weak=False)  \nSet the etag, and override the old one if there was one.  Parameters \n \netag (str) \u2013  \nweak (bool) \u2013    Return type \nNone   \n  \nproperty status: str  \nThe HTTP status code as a string. \n  \nproperty status_code: int  \nThe HTTP status code as a number. \n  \nproperty stream: werkzeug.wrappers.response.ResponseStream  \nThe response iterable as write-only stream. \n  \nproperty vary: werkzeug.datastructures.HeaderSet  \nThe Vary field value indicates the set of request-header fields that fully determines, while the response is fresh, whether a cache is permitted to use the response to reply to a subsequent request without revalidation. \n  \nproperty www_authenticate: werkzeug.datastructures.WWWAuthenticate  \nThe WWW-Authenticate header in a parsed form. \n \n"}, {"name": "Response.accept_ranges", "path": "wrappers/index#werkzeug.wrappers.Response.accept_ranges", "type": "werkzeug.wrappers", "text": " \naccept_ranges  \nThe Accept-Ranges header. Even though the name would indicate that multiple values are supported, it must be one string token only. The values 'bytes' and 'none' are common.  Changelog New in version 0.7.  \n\n"}, {"name": "Response.access_control_allow_headers", "path": "wrappers/index#werkzeug.wrappers.Response.access_control_allow_headers", "type": "werkzeug.wrappers", "text": " \naccess_control_allow_headers  \nWhich headers can be sent with the cross origin request. \n"}, {"name": "Response.access_control_allow_methods", "path": "wrappers/index#werkzeug.wrappers.Response.access_control_allow_methods", "type": "werkzeug.wrappers", "text": " \naccess_control_allow_methods  \nWhich methods can be used for the cross origin request. \n"}, {"name": "Response.access_control_allow_origin", "path": "wrappers/index#werkzeug.wrappers.Response.access_control_allow_origin", "type": "werkzeug.wrappers", "text": " \naccess_control_allow_origin  \nThe origin or \u2018*\u2019 for any origin that may make cross origin requests. \n"}, {"name": "Response.access_control_expose_headers", "path": "wrappers/index#werkzeug.wrappers.Response.access_control_expose_headers", "type": "werkzeug.wrappers", "text": " \naccess_control_expose_headers  \nWhich headers can be shared by the browser to JavaScript code. \n"}, {"name": "Response.access_control_max_age", "path": "wrappers/index#werkzeug.wrappers.Response.access_control_max_age", "type": "werkzeug.wrappers", "text": " \naccess_control_max_age  \nThe maximum age in seconds the access control settings can be cached for. \n"}, {"name": "Response.add_etag()", "path": "wrappers/index#werkzeug.wrappers.Response.add_etag", "type": "werkzeug.wrappers", "text": " \nadd_etag(overwrite=False, weak=False)  \nAdd an etag for the current response if there is none yet.  Changed in version 2.0: SHA-1 is used to generate the value. MD5 may not be available in some environments.   Parameters \n \noverwrite (bool) \u2013  \nweak (bool) \u2013    Return type \nNone   \n"}, {"name": "Response.age", "path": "wrappers/index#werkzeug.wrappers.Response.age", "type": "werkzeug.wrappers", "text": " \nage  \nThe Age response-header field conveys the sender\u2019s estimate of the amount of time since the response (or its revalidation) was generated at the origin server. Age values are non-negative decimal integers, representing time in seconds. \n"}, {"name": "Response.autocorrect_location_header", "path": "wrappers/index#werkzeug.wrappers.Response.autocorrect_location_header", "type": "werkzeug.wrappers", "text": " \nautocorrect_location_header = True  \nShould this response object correct the location header to be RFC conformant? This is true by default.  Changelog New in version 0.8.  \n\n"}, {"name": "Response.automatically_set_content_length", "path": "wrappers/index#werkzeug.wrappers.Response.automatically_set_content_length", "type": "werkzeug.wrappers", "text": " \nautomatically_set_content_length = True  \nShould this response object automatically set the content-length header if possible? This is true by default.  Changelog New in version 0.8.  \n\n"}, {"name": "Response.calculate_content_length()", "path": "wrappers/index#werkzeug.wrappers.Response.calculate_content_length", "type": "werkzeug.wrappers", "text": " \ncalculate_content_length()  \nReturns the content length if available or None otherwise.  Return type \nOptional[int]   \n"}, {"name": "Response.call_on_close()", "path": "wrappers/index#werkzeug.wrappers.Response.call_on_close", "type": "werkzeug.wrappers", "text": " \ncall_on_close(func)  \nAdds a function to the internal list of functions that should be called as part of closing down the response. Since 0.7 this function also returns the function that was passed so that this can be used as a decorator.  Changelog New in version 0.6.   Parameters \nfunc (Callable[[], Any]) \u2013   Return type \nCallable[[], Any]   \n"}, {"name": "Response.close()", "path": "wrappers/index#werkzeug.wrappers.Response.close", "type": "werkzeug.wrappers", "text": " \nclose()  \nClose the wrapped response if possible. You can also use the object in a with statement which will automatically close it.  Changelog New in version 0.9: Can now be used in a with statement.   Return type \nNone   \n"}, {"name": "Response.content_encoding", "path": "wrappers/index#werkzeug.wrappers.Response.content_encoding", "type": "werkzeug.wrappers", "text": " \ncontent_encoding  \nThe Content-Encoding entity-header field is used as a modifier to the media-type. When present, its value indicates what additional content codings have been applied to the entity-body, and thus what decoding mechanisms must be applied in order to obtain the media-type referenced by the Content-Type header field. \n"}, {"name": "Response.content_length", "path": "wrappers/index#werkzeug.wrappers.Response.content_length", "type": "werkzeug.wrappers", "text": " \ncontent_length  \nThe Content-Length entity-header field indicates the size of the entity-body, in decimal number of OCTETs, sent to the recipient or, in the case of the HEAD method, the size of the entity-body that would have been sent had the request been a GET. \n"}, {"name": "Response.content_location", "path": "wrappers/index#werkzeug.wrappers.Response.content_location", "type": "werkzeug.wrappers", "text": " \ncontent_location  \nThe Content-Location entity-header field MAY be used to supply the resource location for the entity enclosed in the message when that entity is accessible from a location separate from the requested resource\u2019s URI. \n"}, {"name": "Response.content_md5", "path": "wrappers/index#werkzeug.wrappers.Response.content_md5", "type": "werkzeug.wrappers", "text": " \ncontent_md5  \nThe Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest of the entity-body for the purpose of providing an end-to-end message integrity check (MIC) of the entity-body. (Note: a MIC is good for detecting accidental modification of the entity-body in transit, but is not proof against malicious attacks.) \n"}, {"name": "Response.content_security_policy", "path": "wrappers/index#werkzeug.wrappers.Response.content_security_policy", "type": "werkzeug.wrappers", "text": " \ncontent_security_policy  \nThe Content-Security-Policy header adds an additional layer of security to help detect and mitigate certain types of attacks. \n"}, {"name": "Response.content_security_policy_report_only", "path": "wrappers/index#werkzeug.wrappers.Response.content_security_policy_report_only", "type": "werkzeug.wrappers", "text": " \ncontent_security_policy_report_only  \nThe Content-Security-Policy-Report-Only header adds a csp policy that is not enforced but is reported thereby helping detect certain types of attacks. \n"}, {"name": "Response.content_type", "path": "wrappers/index#werkzeug.wrappers.Response.content_type", "type": "werkzeug.wrappers", "text": " \ncontent_type  \nThe Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of the HEAD method, the media type that would have been sent had the request been a GET. \n"}, {"name": "Response.cross_origin_embedder_policy", "path": "wrappers/index#werkzeug.wrappers.Response.cross_origin_embedder_policy", "type": "werkzeug.wrappers", "text": " \ncross_origin_embedder_policy  \nPrevents a document from loading any cross-origin resources that do not explicitly grant the document permission. Values must be a member of the werkzeug.http.COEP enum. \n"}, {"name": "Response.cross_origin_opener_policy", "path": "wrappers/index#werkzeug.wrappers.Response.cross_origin_opener_policy", "type": "werkzeug.wrappers", "text": " \ncross_origin_opener_policy  \nAllows control over sharing of browsing context group with cross-origin documents. Values must be a member of the werkzeug.http.COOP enum. \n"}, {"name": "Response.date", "path": "wrappers/index#werkzeug.wrappers.Response.date", "type": "werkzeug.wrappers", "text": " \ndate  \nThe Date general-header field represents the date and time at which the message was originated, having the same semantics as orig-date in RFC 822.  Changed in version 2.0: The datetime object is timezone-aware.  \n"}, {"name": "Response.delete_cookie()", "path": "wrappers/index#werkzeug.wrappers.Response.delete_cookie", "type": "werkzeug.wrappers", "text": " \ndelete_cookie(key, path='/', domain=None, secure=False, httponly=False, samesite=None)  \nDelete a cookie. Fails silently if key doesn\u2019t exist.  Parameters \n \nkey (str) \u2013 the key (name) of the cookie to be deleted. \npath (str) \u2013 if the cookie that should be deleted was limited to a path, the path has to be defined here. \ndomain (Optional[str]) \u2013 if the cookie that should be deleted was limited to a domain, that domain has to be defined here. \nsecure (bool) \u2013 If True, the cookie will only be available via HTTPS. \nhttponly (bool) \u2013 Disallow JavaScript access to the cookie. \nsamesite (Optional[str]) \u2013 Limit the scope of the cookie to only be attached to requests that are \u201csame-site\u201d.   Return type \nNone   \n"}, {"name": "Response.direct_passthrough", "path": "wrappers/index#werkzeug.wrappers.Response.direct_passthrough", "type": "werkzeug.wrappers", "text": " \ndirect_passthrough  \nPass the response body directly through as the WSGI iterable. This can be used when the body is a binary file or other iterator of bytes, to skip some unnecessary checks. Use send_file() instead of setting this manually. \n"}, {"name": "Response.expires", "path": "wrappers/index#werkzeug.wrappers.Response.expires", "type": "werkzeug.wrappers", "text": " \nexpires  \nThe Expires entity-header field gives the date/time after which the response is considered stale. A stale cache entry may not normally be returned by a cache.  Changed in version 2.0: The datetime object is timezone-aware.  \n"}, {"name": "Response.force_type()", "path": "wrappers/index#werkzeug.wrappers.Response.force_type", "type": "werkzeug.wrappers", "text": " \nclassmethod force_type(response, environ=None)  \nEnforce that the WSGI response is a response object of the current type. Werkzeug will use the Response internally in many situations like the exceptions. If you call get_response() on an exception you will get back a regular Response object, even if you are using a custom subclass. This method can enforce a given response type, and it will also convert arbitrary WSGI callables into response objects if an environ is provided: # convert a Werkzeug response object into an instance of the\n# MyResponseClass subclass.\nresponse = MyResponseClass.force_type(response)\n\n# convert any WSGI application into a response object\nresponse = MyResponseClass.force_type(response, environ)\n This is especially useful if you want to post-process responses in the main dispatcher and use functionality provided by your subclass. Keep in mind that this will modify response objects in place if possible!  Parameters \n \nresponse (Response) \u2013 a response object or wsgi application. \nenviron (Optional[WSGIEnvironment]) \u2013 a WSGI environment object.   Returns \na response object.  Return type \nResponse   \n"}, {"name": "Response.freeze()", "path": "wrappers/index#werkzeug.wrappers.Response.freeze", "type": "werkzeug.wrappers", "text": " \nfreeze(no_etag=None)  \nMake the response object ready to be pickled. Does the following:  Buffer the response into a list, ignoring implicity_sequence_conversion and direct_passthrough. Set the Content-Length header. Generate an ETag header if one is not already set.   Changed in version 2.0: An ETag header is added, the no_etag parameter is deprecated and will be removed in Werkzeug 2.1.   Changelog Changed in version 0.6: The Content-Length header is set.   Parameters \nno_etag (None) \u2013   Return type \nNone   \n"}, {"name": "Response.from_app()", "path": "wrappers/index#werkzeug.wrappers.Response.from_app", "type": "werkzeug.wrappers", "text": " \nclassmethod from_app(app, environ, buffered=False)  \nCreate a new response object from an application output. This works best if you pass it an application that returns a generator all the time. Sometimes applications may use the write() callable returned by the start_response function. This tries to resolve such edge cases automatically. But if you don\u2019t get the expected output you should set buffered to True which enforces buffering.  Parameters \n \napp (WSGIApplication) \u2013 the WSGI application to execute. \nenviron (WSGIEnvironment) \u2013 the WSGI environment to execute against. \nbuffered (bool) \u2013 set to True to enforce buffering.   Returns \na response object.  Return type \nResponse   \n"}, {"name": "Response.get_app_iter()", "path": "wrappers/index#werkzeug.wrappers.Response.get_app_iter", "type": "werkzeug.wrappers", "text": " \nget_app_iter(environ)  \nReturns the application iterator for the given environ. Depending on the request method and the current status code the return value might be an empty response rather than the one from the response. If the request method is HEAD or the status code is in a range where the HTTP specification requires an empty response, an empty iterable is returned.  Changelog New in version 0.6.   Parameters \nenviron (WSGIEnvironment) \u2013 the WSGI environment of the request.  Returns \na response iterable.  Return type \nIterable[bytes]   \n"}, {"name": "Response.get_data()", "path": "wrappers/index#werkzeug.wrappers.Response.get_data", "type": "werkzeug.wrappers", "text": " \nget_data(as_text=False)  \nThe string representation of the response body. Whenever you call this property the response iterable is encoded and flattened. This can lead to unwanted behavior if you stream big data. This behavior can be disabled by setting implicit_sequence_conversion to False. If as_text is set to True the return value will be a decoded string.  Changelog New in version 0.9.   Parameters \nas_text (bool) \u2013   Return type \nUnion[bytes, str]   \n"}, {"name": "Response.get_etag()", "path": "wrappers/index#werkzeug.wrappers.Response.get_etag", "type": "werkzeug.wrappers", "text": " \nget_etag()  \nReturn a tuple in the form (etag, is_weak). If there is no ETag the return value is (None, None).  Return type \nUnion[Tuple[str, bool], Tuple[None, None]]   \n"}, {"name": "Response.get_json()", "path": "wrappers/index#werkzeug.wrappers.Response.get_json", "type": "werkzeug.wrappers", "text": " \nget_json(force=False, silent=False)  \nParse data as JSON. Useful during testing. If the mimetype does not indicate JSON (application/json, see is_json()), this returns None. Unlike Request.get_json(), the result is not cached.  Parameters \n \nforce (bool) \u2013 Ignore the mimetype and always try to parse JSON. \nsilent (bool) \u2013 Silence parsing errors and return None instead.   Return type \nOptional[Any]   \n"}, {"name": "Response.get_wsgi_headers()", "path": "wrappers/index#werkzeug.wrappers.Response.get_wsgi_headers", "type": "werkzeug.wrappers", "text": " \nget_wsgi_headers(environ)  \nThis is automatically called right before the response is started and returns headers modified for the given environment. It returns a copy of the headers from the response with some modifications applied if necessary. For example the location header (if present) is joined with the root URL of the environment. Also the content length is automatically set to zero here for certain status codes.  Changelog Changed in version 0.6: Previously that function was called fix_headers and modified the response object in place. Also since 0.6, IRIs in location and content-location headers are handled properly. Also starting with 0.6, Werkzeug will attempt to set the content length if it is able to figure it out on its own. This is the case if all the strings in the response iterable are already encoded and the iterable is buffered.   Parameters \nenviron (WSGIEnvironment) \u2013 the WSGI environment of the request.  Returns \nreturns a new Headers object.  Return type \nwerkzeug.datastructures.Headers   \n"}, {"name": "Response.get_wsgi_response()", "path": "wrappers/index#werkzeug.wrappers.Response.get_wsgi_response", "type": "werkzeug.wrappers", "text": " \nget_wsgi_response(environ)  \nReturns the final WSGI response as tuple. The first item in the tuple is the application iterator, the second the status and the third the list of headers. The response returned is created specially for the given environment. For example if the request method in the WSGI environment is 'HEAD' the response will be empty and only the headers and status code will be present.  Changelog New in version 0.6.   Parameters \nenviron (WSGIEnvironment) \u2013 the WSGI environment of the request.  Returns \nan (app_iter, status, headers) tuple.  Return type \nTuple[Iterable[bytes], str, List[Tuple[str, str]]]   \n"}, {"name": "Response.implicit_sequence_conversion", "path": "wrappers/index#werkzeug.wrappers.Response.implicit_sequence_conversion", "type": "werkzeug.wrappers", "text": " \nimplicit_sequence_conversion = True  \nif set to False accessing properties on the response object will not try to consume the response iterator and convert it into a list.  Changelog New in version 0.6.2: That attribute was previously called implicit_seqence_conversion. (Notice the typo). If you did use this feature, you have to adapt your code to the name change.  \n\n"}, {"name": "Response.iter_encoded()", "path": "wrappers/index#werkzeug.wrappers.Response.iter_encoded", "type": "werkzeug.wrappers", "text": " \niter_encoded()  \nIter the response encoded with the encoding of the response. If the response object is invoked as WSGI application the return value of this method is used as application iterator unless direct_passthrough was activated.  Return type \nIterator[bytes]   \n"}, {"name": "Response.json_module", "path": "wrappers/index#werkzeug.wrappers.Response.json_module", "type": "werkzeug.wrappers", "text": " \njson_module = <module 'json' from '/home/docs/.pyenv/versions/3.7.9/lib/python3.7/json/__init__.py'>  \nA module or other object that has dumps and loads functions that match the API of the built-in json module. \n"}, {"name": "Response.last_modified", "path": "wrappers/index#werkzeug.wrappers.Response.last_modified", "type": "werkzeug.wrappers", "text": " \nlast_modified  \nThe Last-Modified entity-header field indicates the date and time at which the origin server believes the variant was last modified.  Changed in version 2.0: The datetime object is timezone-aware.  \n"}, {"name": "Response.location", "path": "wrappers/index#werkzeug.wrappers.Response.location", "type": "werkzeug.wrappers", "text": " \nlocation  \nThe Location response-header field is used to redirect the recipient to a location other than the Request-URI for completion of the request or identification of a new resource. \n"}, {"name": "Response.make_conditional()", "path": "wrappers/index#werkzeug.wrappers.Response.make_conditional", "type": "werkzeug.wrappers", "text": " \nmake_conditional(request_or_environ, accept_ranges=False, complete_length=None)  \nMake the response conditional to the request. This method works best if an etag was defined for the response already. The add_etag method can be used to do that. If called without etag just the date header is set. This does nothing if the request method in the request or environ is anything but GET or HEAD. For optimal performance when handling range requests, it\u2019s recommended that your response data object implements seekable, seek and tell methods as described by io.IOBase. Objects returned by wrap_file() automatically implement those methods. It does not remove the body of the response because that\u2019s something the __call__() function does for us automatically. Returns self so that you can do return resp.make_conditional(req) but modifies the object in-place.  Parameters \n \nrequest_or_environ (WSGIEnvironment) \u2013 a request object or WSGI environment to be used to make the response conditional against. \naccept_ranges (Union[bool, str]) \u2013 This parameter dictates the value of Accept-Ranges header. If False (default), the header is not set. If True, it will be set to \"bytes\". If None, it will be set to \"none\". If it\u2019s a string, it will use this value. \ncomplete_length (Optional[int]) \u2013 Will be used only in valid Range Requests. It will set Content-Range complete length value and compute Content-Length real value. This parameter is mandatory for successful Range Requests completion.   Raises \nRequestedRangeNotSatisfiable if Range header could not be parsed or satisfied.  Return type \nResponse    Changed in version 2.0: Range processing is skipped if length is 0 instead of raising a 416 Range Not Satisfiable error.  \n"}, {"name": "Response.make_sequence()", "path": "wrappers/index#werkzeug.wrappers.Response.make_sequence", "type": "werkzeug.wrappers", "text": " \nmake_sequence()  \nConverts the response iterator in a list. By default this happens automatically if required. If implicit_sequence_conversion is disabled, this method is not automatically called and some properties might raise exceptions. This also encodes all the items.  Changelog New in version 0.6.   Return type \nNone   \n"}, {"name": "Response.response", "path": "wrappers/index#werkzeug.wrappers.Response.response", "type": "werkzeug.wrappers", "text": " \nresponse: Union[Iterable[str], Iterable[bytes]]  \nThe response body to send as the WSGI iterable. A list of strings or bytes represents a fixed-length response, any other iterable is a streaming response. Strings are encoded to bytes as UTF-8. Do not set to a plain string or bytes, that will cause sending the response to be very inefficient as it will iterate one byte at a time. \n"}, {"name": "Response.set_cookie()", "path": "wrappers/index#werkzeug.wrappers.Response.set_cookie", "type": "werkzeug.wrappers", "text": " \nset_cookie(key, value='', max_age=None, expires=None, path='/', domain=None, secure=False, httponly=False, samesite=None)  \nSets a cookie. A warning is raised if the size of the cookie header exceeds max_cookie_size, but the header will still be set.  Parameters \n \nkey (str) \u2013 the key (name) of the cookie to be set. \nvalue (str) \u2013 the value of the cookie. \nmax_age (Optional[Union[datetime.timedelta, int]]) \u2013 should be a number of seconds, or None (default) if the cookie should last only as long as the client\u2019s browser session. \nexpires (Optional[Union[str, datetime.datetime, int, float]]) \u2013 should be a datetime object or UNIX timestamp. \npath (Optional[str]) \u2013 limits the cookie to a given path, per default it will span the whole domain. \ndomain (Optional[str]) \u2013 if you want to set a cross-domain cookie. For example, domain=\".example.com\" will set a cookie that is readable by the domain www.example.com, foo.example.com etc. Otherwise, a cookie will only be readable by the domain that set it. \nsecure (bool) \u2013 If True, the cookie will only be available via HTTPS. \nhttponly (bool) \u2013 Disallow JavaScript access to the cookie. \nsamesite (Optional[str]) \u2013 Limit the scope of the cookie to only be attached to requests that are \u201csame-site\u201d.   Return type \nNone   \n"}, {"name": "Response.set_data()", "path": "wrappers/index#werkzeug.wrappers.Response.set_data", "type": "werkzeug.wrappers", "text": " \nset_data(value)  \nSets a new string as response. The value must be a string or bytes. If a string is set it\u2019s encoded to the charset of the response (utf-8 by default).  Changelog New in version 0.9.   Parameters \nvalue (Union[bytes, str]) \u2013   Return type \nNone   \n"}, {"name": "Response.set_etag()", "path": "wrappers/index#werkzeug.wrappers.Response.set_etag", "type": "werkzeug.wrappers", "text": " \nset_etag(etag, weak=False)  \nSet the etag, and override the old one if there was one.  Parameters \n \netag (str) \u2013  \nweak (bool) \u2013    Return type \nNone   \n"}, {"name": "Response._ensure_sequence()", "path": "wrappers/index#werkzeug.wrappers.Response._ensure_sequence", "type": "werkzeug.wrappers", "text": " \n_ensure_sequence(mutable=False)  \nThis method can be called by methods that need a sequence. If mutable is true, it will also ensure that the response sequence is a standard Python list.  Changelog New in version 0.6.   Parameters \nmutable (bool) \u2013   Return type \nNone   \n"}, {"name": "Response.__call__()", "path": "wrappers/index#werkzeug.wrappers.Response.__call__", "type": "werkzeug.wrappers", "text": " \n__call__(environ, start_response)  \nProcess this response as WSGI application.  Parameters \n \nenviron (WSGIEnvironment) \u2013 the WSGI environment. \nstart_response (StartResponse) \u2013 the response callable provided by the WSGI server.   Returns \nan application iterator  Return type \nIterable[bytes]   \n"}, {"name": "ResponseCacheControl", "path": "datastructures/index#werkzeug.datastructures.ResponseCacheControl", "type": "werkzeug.datastructures", "text": " \nclass werkzeug.datastructures.ResponseCacheControl(values=(), on_update=None)  \nA cache control for responses. Unlike RequestCacheControl this is mutable and gives access to response-relevant cache control headers. To get a header of the ResponseCacheControl object again you can convert the object into a string or call the to_header() method. If you plan to subclass it and add your own items have a look at the sourcecode for that class.  Changelog New in version 0.5: In previous versions a CacheControl class existed that was used both for request and response.   \nno_cache  \naccessor for \u2018no-cache\u2019 \n  \nno_store  \naccessor for \u2018no-store\u2019 \n  \nmax_age  \naccessor for \u2018max-age\u2019 \n  \nno_transform  \naccessor for \u2018no-transform\u2019 \n  \nproperty immutable  \naccessor for \u2018immutable\u2019 \n  \nproperty must_revalidate  \naccessor for \u2018must-revalidate\u2019 \n  \nproperty private  \naccessor for \u2018private\u2019 \n  \nproperty proxy_revalidate  \naccessor for \u2018proxy-revalidate\u2019 \n  \nproperty public  \naccessor for \u2018public\u2019 \n  \nproperty s_maxage  \naccessor for \u2018s-maxage\u2019 \n \n"}, {"name": "ResponseCacheControl.max_age", "path": "datastructures/index#werkzeug.datastructures.ResponseCacheControl.max_age", "type": "werkzeug.datastructures", "text": " \nmax_age  \naccessor for \u2018max-age\u2019 \n"}, {"name": "ResponseCacheControl.no_cache", "path": "datastructures/index#werkzeug.datastructures.ResponseCacheControl.no_cache", "type": "werkzeug.datastructures", "text": " \nno_cache  \naccessor for \u2018no-cache\u2019 \n"}, {"name": "ResponseCacheControl.no_store", "path": "datastructures/index#werkzeug.datastructures.ResponseCacheControl.no_store", "type": "werkzeug.datastructures", "text": " \nno_store  \naccessor for \u2018no-store\u2019 \n"}, {"name": "ResponseCacheControl.no_transform", "path": "datastructures/index#werkzeug.datastructures.ResponseCacheControl.no_transform", "type": "werkzeug.datastructures", "text": " \nno_transform  \naccessor for \u2018no-transform\u2019 \n"}, {"name": "Rule", "path": "routing/index#werkzeug.routing.Rule", "type": "werkzeug.routing", "text": " \nclass werkzeug.routing.Rule(string, defaults=None, subdomain=None, methods=None, build_only=False, endpoint=None, strict_slashes=None, merge_slashes=None, redirect_to=None, alias=False, host=None, websocket=False)  \nA Rule represents one URL pattern. There are some options for Rule that change the way it behaves and are passed to the Rule constructor. Note that besides the rule-string all arguments must be keyword arguments in order to not break the application on Werkzeug upgrades.  \nstring \n\nRule strings basically are just normal URL paths with placeholders in the format <converter(arguments):name> where the converter and the arguments are optional. If no converter is defined the default converter is used which means string in the normal configuration. URL rules that end with a slash are branch URLs, others are leaves. If you have strict_slashes enabled (which is the default), all branch URLs that are matched without a trailing slash will trigger a redirect to the same URL with the missing slash appended. The converters are defined on the Map.  \nendpoint \n\nThe endpoint for this rule. This can be anything. A reference to a function, a string, a number etc. The preferred way is using a string because the endpoint is used for URL generation.  \ndefaults \n\nAn optional dict with defaults for other rules with the same endpoint. This is a bit tricky but useful if you want to have unique URLs: url_map = Map([\n    Rule('/all/', defaults={'page': 1}, endpoint='all_entries'),\n    Rule('/all/page/<int:page>', endpoint='all_entries')\n])\n If a user now visits http://example.com/all/page/1 he will be redirected to http://example.com/all/. If redirect_defaults is disabled on the Map instance this will only affect the URL generation.  \nsubdomain \n\nThe subdomain rule string for this rule. If not specified the rule only matches for the default_subdomain of the map. If the map is not bound to a subdomain this feature is disabled. Can be useful if you want to have user profiles on different subdomains and all subdomains are forwarded to your application: url_map = Map([\n    Rule('/', subdomain='<username>', endpoint='user/homepage'),\n    Rule('/stats', subdomain='<username>', endpoint='user/stats')\n])\n  \nmethods \n\nA sequence of http methods this rule applies to. If not specified, all methods are allowed. For example this can be useful if you want different endpoints for POST and GET. If methods are defined and the path matches but the method matched against is not in this list or in the list of another rule for that path the error raised is of the type MethodNotAllowed rather than NotFound. If GET is present in the list of methods and HEAD is not, HEAD is added automatically.  \nstrict_slashes \n\nOverride the Map setting for strict_slashes only for this rule. If not specified the Map setting is used.  \nmerge_slashes \n\nOverride Map.merge_slashes for this rule.  \nbuild_only \n\nSet this to True and the rule will never match but will create a URL that can be build. This is useful if you have resources on a subdomain or folder that are not handled by the WSGI application (like static data)  \nredirect_to \n\nIf given this must be either a string or callable. In case of a callable it\u2019s called with the url adapter that triggered the match and the values of the URL as keyword arguments and has to return the target for the redirect, otherwise it has to be a string with placeholders in rule syntax: def foo_with_slug(adapter, id):\n    # ask the database for the slug for the old id.  this of\n    # course has nothing to do with werkzeug.\n    return f'foo/{Foo.get_slug_for_id(id)}'\n\nurl_map = Map([\n    Rule('/foo/<slug>', endpoint='foo'),\n    Rule('/some/old/url/<slug>', redirect_to='foo/<slug>'),\n    Rule('/other/old/url/<int:id>', redirect_to=foo_with_slug)\n])\n When the rule is matched the routing system will raise a RequestRedirect exception with the target for the redirect. Keep in mind that the URL will be joined against the URL root of the script so don\u2019t use a leading slash on the target URL unless you really mean root of that domain.  \nalias \n\nIf enabled this rule serves as an alias for another rule with the same endpoint and arguments.  \nhost \n\nIf provided and the URL map has host matching enabled this can be used to provide a match rule for the whole host. This also means that the subdomain feature is disabled.  \nwebsocket \n\nIf True, this rule is only matches for WebSocket (ws://, wss://) requests. By default, rules will only match for HTTP requests.    Changelog New in version 1.0: Added websocket.   New in version 1.0: Added merge_slashes.   New in version 0.7: Added alias and host.   Changed in version 0.6.1: HEAD is added to methods if GET is present.   Parameters \n \nstring (str) \u2013  \ndefaults (Optional[Mapping[str, Any]]) \u2013  \nsubdomain (Optional[str]) \u2013  \nmethods (Optional[Iterable[str]]) \u2013  \nbuild_only (bool) \u2013  \nendpoint (Optional[str]) \u2013  \nstrict_slashes (Optional[bool]) \u2013  \nmerge_slashes (Optional[bool]) \u2013  \nredirect_to (Optional[Union[str, Callable[[...], str]]]) \u2013  \nalias (bool) \u2013  \nhost (Optional[str]) \u2013  \nwebsocket (bool) \u2013    Return type \nNone    \nempty()  \nReturn an unbound copy of this rule. This can be useful if want to reuse an already bound URL for another map. See get_empty_kwargs to override what keyword arguments are provided to the new copy.  Return type \nwerkzeug.routing.Rule   \n \n"}, {"name": "Rule.empty()", "path": "routing/index#werkzeug.routing.Rule.empty", "type": "werkzeug.routing", "text": " \nempty()  \nReturn an unbound copy of this rule. This can be useful if want to reuse an already bound URL for another map. See get_empty_kwargs to override what keyword arguments are provided to the new copy.  Return type \nwerkzeug.routing.Rule   \n"}, {"name": "RuleFactory", "path": "routing/index#werkzeug.routing.RuleFactory", "type": "werkzeug.routing", "text": " \nclass werkzeug.routing.RuleFactory  \nAs soon as you have more complex URL setups it\u2019s a good idea to use rule factories to avoid repetitive tasks. Some of them are builtin, others can be added by subclassing RuleFactory and overriding get_rules.  \nget_rules(map)  \nSubclasses of RuleFactory have to override this method and return an iterable of rules.  Parameters \nmap (werkzeug.routing.Map) \u2013   Return type \nIterable[werkzeug.routing.Rule]   \n \n"}, {"name": "RuleFactory.get_rules()", "path": "routing/index#werkzeug.routing.RuleFactory.get_rules", "type": "werkzeug.routing", "text": " \nget_rules(map)  \nSubclasses of RuleFactory have to override this method and return an iterable of rules.  Parameters \nmap (werkzeug.routing.Map) \u2013   Return type \nIterable[werkzeug.routing.Rule]   \n"}, {"name": "RuleTemplate", "path": "routing/index#werkzeug.routing.RuleTemplate", "type": "werkzeug.routing", "text": " \nclass werkzeug.routing.RuleTemplate(rules)  \nReturns copies of the rules wrapped and expands string templates in the endpoint, rule, defaults or subdomain sections. Here a small example for such a rule template: from werkzeug.routing import Map, Rule, RuleTemplate\n\nresource = RuleTemplate([\n    Rule('/$name/', endpoint='$name.list'),\n    Rule('/$name/<int:id>', endpoint='$name.show')\n])\n\nurl_map = Map([resource(name='user'), resource(name='page')])\n When a rule template is called the keyword arguments are used to replace the placeholders in all the string parameters.  Parameters \nrules (Iterable[Rule]) \u2013   Return type \nNone   \n"}, {"name": "run_simple()", "path": "serving/index#werkzeug.serving.run_simple", "type": "werkzeug.serving", "text": " \nwerkzeug.serving.run_simple(hostname, port, application, use_reloader=False, use_debugger=False, use_evalex=True, extra_files=None, exclude_patterns=None, reloader_interval=1, reloader_type='auto', threaded=False, processes=1, request_handler=None, static_files=None, passthrough_errors=False, ssl_context=None)  \nStart a WSGI application. Optional features include a reloader, multithreading and fork support. This function has a command-line interface too: python -m werkzeug.serving --help\n  Changed in version 2.0: Added exclude_patterns parameter.   Changelog Changed in version 0.15: Bind to a Unix socket by passing a path that starts with unix:// as the hostname.   New in version 0.10: Improved the reloader and added support for changing the backend through the reloader_type parameter. See Reloader for more information.   New in version 0.9: Added command-line interface.   New in version 0.8: Added support for automatically loading a SSL context from certificate file and private key.   New in version 0.6: support for SSL was added.   New in version 0.5: static_files was added to simplify serving of static files as well as passthrough_errors.   Parameters \n \nhostname (str) \u2013 The host to bind to, for example 'localhost'. If the value is a path that starts with unix:// it will bind to a Unix socket instead of a TCP socket.. \nport (int) \u2013 The port for the server. eg: 8080\n \napplication (WSGIApplication) \u2013 the WSGI application to execute \nuse_reloader (bool) \u2013 should the server automatically restart the python process if modules were changed? \nuse_debugger (bool) \u2013 should the werkzeug debugging system be used? \nuse_evalex (bool) \u2013 should the exception evaluation feature be enabled? \nextra_files (Optional[Iterable[str]]) \u2013 a list of files the reloader should watch additionally to the modules. For example configuration files. \nexclude_patterns (Optional[Iterable[str]]) \u2013 List of fnmatch patterns to ignore when running the reloader. For example, ignore cache files that shouldn\u2019t reload when updated. \nreloader_interval (int) \u2013 the interval for the reloader in seconds. \nreloader_type (str) \u2013 the type of reloader to use. The default is auto detection. Valid values are 'stat' and 'watchdog'. See Reloader for more information. \nthreaded (bool) \u2013 should the process handle each request in a separate thread? \nprocesses (int) \u2013 if greater than 1 then handle each request in a new process up to this maximum number of concurrent processes. \nrequest_handler (Optional[Type[werkzeug.serving.WSGIRequestHandler]]) \u2013 optional parameter that can be used to replace the default one. You can use this to replace it with a different BaseHTTPRequestHandler subclass. \nstatic_files (Optional[Dict[str, Union[str, Tuple[str, str]]]]) \u2013 a list or dict of paths for static files. This works exactly like SharedDataMiddleware, it\u2019s actually just wrapping the application in that middleware before serving. \npassthrough_errors (bool) \u2013 set this to True to disable the error catching. This means that the server will die on errors but it can be useful to hook debuggers in (pdb etc.) \nssl_context (Optional[Union[ssl.SSLContext, Tuple[str, Optional[str]], te.Literal['adhoc']]]) \u2013 an SSL context for the connection. Either an ssl.SSLContext, a tuple in the form (cert_file, pkey_file), the string 'adhoc' if the server should automatically create one, or None to disable SSL (which is the default).   Return type \nNone   \n"}, {"name": "run_wsgi_app()", "path": "test/index#werkzeug.test.run_wsgi_app", "type": "werkzeug.test", "text": " \nwerkzeug.test.run_wsgi_app(app, environ, buffered=False)  \nReturn a tuple in the form (app_iter, status, headers) of the application output. This works best if you pass it an application that returns an iterator all the time. Sometimes applications may use the write() callable returned by the start_response function. This tries to resolve such edge cases automatically. But if you don\u2019t get the expected output you should set buffered to True which enforces buffering. If passed an invalid WSGI application the behavior of this function is undefined. Never pass non-conforming WSGI applications to this function.  Parameters \n \napp (WSGIApplication) \u2013 the application to execute. \nbuffered (bool) \u2013 set to True to enforce buffering. \nenviron (WSGIEnvironment) \u2013    Returns \ntuple in the form (app_iter, status, headers)  Return type \nTuple[Iterable[bytes], str, werkzeug.datastructures.Headers]   \n"}, {"name": "safe_join()", "path": "utils/index#werkzeug.security.safe_join", "type": "werkzeug.security", "text": " \nwerkzeug.security.safe_join(directory, *pathnames)  \nSafely join zero or more untrusted path components to a base directory to avoid escaping the base directory.  Parameters \n \ndirectory (str) \u2013 The trusted base directory. \npathnames (str) \u2013 The untrusted path components relative to the base directory.   Returns \nA safe path, otherwise None.  Return type \nOptional[str]   \n"}, {"name": "safe_str_cmp()", "path": "utils/index#werkzeug.security.safe_str_cmp", "type": "werkzeug.security", "text": " \nwerkzeug.security.safe_str_cmp(a, b)  \nThis function compares strings in somewhat constant time. This requires that the length of at least one string is known in advance. Returns True if the two strings are equal, or False if they are not.  Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use hmac.compare_digest() instead.   Changelog New in version 0.7.   Parameters \n \na (str) \u2013  \nb (str) \u2013    Return type \nbool   \n"}, {"name": "secure_filename()", "path": "utils/index#werkzeug.utils.secure_filename", "type": "werkzeug.utils", "text": " \nwerkzeug.utils.secure_filename(filename)  \nPass it a filename and it will return a secure version of it. This filename can then safely be stored on a regular file system and passed to os.path.join(). The filename returned is an ASCII only string for maximum portability. On windows systems the function also makes sure that the file is not named after one of the special device files. >>> secure_filename(\"My cool movie.mov\")\n'My_cool_movie.mov'\n>>> secure_filename(\"../../../etc/passwd\")\n'etc_passwd'\n>>> secure_filename('i contain cool \\xfcml\\xe4uts.txt')\n'i_contain_cool_umlauts.txt'\n The function might return an empty filename. It\u2019s your responsibility to ensure that the filename is unique and that you abort or generate a random filename if the function returned an empty one.  Changelog New in version 0.5.   Parameters \nfilename (str) \u2013 the filename to secure  Return type \nstr   \n"}, {"name": "send_file()", "path": "utils/index#werkzeug.utils.send_file", "type": "werkzeug.utils", "text": " \nwerkzeug.utils.send_file(path_or_file, environ, mimetype=None, as_attachment=False, download_name=None, conditional=True, etag=True, last_modified=None, max_age=None, use_x_sendfile=False, response_class=None, _root_path=None)  \nSend the contents of a file to the client. The first argument can be a file path or a file-like object. Paths are preferred in most cases because Werkzeug can manage the file and get extra information from the path. Passing a file-like object requires that the file is opened in binary mode, and is mostly useful when building a file in memory with io.BytesIO. Never pass file paths provided by a user. The path is assumed to be trusted, so a user could craft a path to access a file you didn\u2019t intend. If the WSGI server sets a file_wrapper in environ, it is used, otherwise Werkzeug\u2019s built-in wrapper is used. Alternatively, if the HTTP server supports X-Sendfile, use_x_sendfile=True will tell the server to send the given path, which is much more efficient than reading it in Python.  Parameters \n \npath_or_file (Union[os.PathLike, str, BinaryIO]) \u2013 The path to the file to send, relative to the current working directory if a relative path is given. Alternatively, a file-like object opened in binary mode. Make sure the file pointer is seeked to the start of the data. \nenviron (WSGIEnvironment) \u2013 The WSGI environ for the current request. \nmimetype (Optional[str]) \u2013 The MIME type to send for the file. If not provided, it will try to detect it from the file name. \nas_attachment (bool) \u2013 Indicate to a browser that it should offer to save the file instead of displaying it. \ndownload_name (Optional[str]) \u2013 The default name browsers will use when saving the file. Defaults to the passed file name. \nconditional (bool) \u2013 Enable conditional and range responses based on request headers. Requires passing a file path and environ. \netag (Union[bool, str]) \u2013 Calculate an ETag for the file, which requires passing a file path. Can also be a string to use instead. \nlast_modified (Optional[Union[datetime.datetime, int, float]]) \u2013 The last modified time to send for the file, in seconds. If not provided, it will try to detect it from the file path. \nmax_age (Optional[Union[int, Callable[[Optional[Union[os.PathLike, str]]], int]]]) \u2013 How long the client should cache the file, in seconds. If set, Cache-Control will be public, otherwise it will be no-cache to prefer conditional caching. \nuse_x_sendfile (bool) \u2013 Set the X-Sendfile header to let the server to efficiently send the file. Requires support from the HTTP server. Requires passing a file path. \nresponse_class (Optional[Type[Response]]) \u2013 Build the response using this class. Defaults to Response. \n_root_path (Optional[Union[os.PathLike, str]]) \u2013 Do not use. For internal use only. Use send_from_directory() to safely send files under a path.   Return type \nResponse    New in version 2.0: Adapted from Flask\u2019s implementation.   Changed in version 2.0: download_name replaces Flask\u2019s attachment_filename parameter. If as_attachment=False, it is passed with Content-Disposition: inline instead.   Changed in version 2.0: max_age replaces Flask\u2019s cache_timeout parameter. conditional is enabled and max_age is not set by default.   Changed in version 2.0: etag replaces Flask\u2019s add_etags parameter. It can be a string to use instead of generating one.   Changed in version 2.0: If an encoding is returned when guessing mimetype from download_name, set the Content-Encoding header.  \n"}, {"name": "Serve Shared Static Files", "path": "middleware/shared_data/index", "type": "Other", "text": "Serve Shared Static Files  \nclass werkzeug.middleware.shared_data.SharedDataMiddleware(app, exports, disallow=None, cache=True, cache_timeout=43200, fallback_mimetype='application/octet-stream')  \nA WSGI middleware which provides static content for development environments or simple server setups. Its usage is quite simple: import os\nfrom werkzeug.middleware.shared_data import SharedDataMiddleware\n\napp = SharedDataMiddleware(app, {\n    '/shared': os.path.join(os.path.dirname(__file__), 'shared')\n})\n The contents of the folder ./shared will now be available on http://example.com/shared/. This is pretty useful during development because a standalone media server is not required. Files can also be mounted on the root folder and still continue to use the application because the shared data middleware forwards all unhandled requests to the application, even if the requests are below one of the shared folders. If pkg_resources is available you can also tell the middleware to serve files from package data: app = SharedDataMiddleware(app, {\n    '/static': ('myapplication', 'static')\n})\n This will then serve the static folder in the myapplication Python package. The optional disallow parameter can be a list of fnmatch() rules for files that are not accessible from the web. If cache is set to False no caching headers are sent. Currently the middleware does not support non-ASCII filenames. If the encoding on the file system happens to match the encoding of the URI it may work but this could also be by accident. We strongly suggest using ASCII only file names for static files. The middleware will guess the mimetype using the Python mimetype module. If it\u2019s unable to figure out the charset it will fall back to fallback_mimetype.  Parameters \n \napp (WSGIApplication) \u2013 the application to wrap. If you don\u2019t want to wrap an application you can pass it NotFound. \nexports (Union[Dict[str, Union[str, Tuple[str, str]]], Iterable[Tuple[str, Union[str, Tuple[str, str]]]]]) \u2013 a list or dict of exported files and folders. \ndisallow (None) \u2013 a list of fnmatch() rules. \ncache (bool) \u2013 enable or disable caching headers. \ncache_timeout (int) \u2013 the cache timeout in seconds for the headers. \nfallback_mimetype (str) \u2013 The fallback mimetype for unknown files.   Return type \nNone    Changelog Changed in version 1.0: The default fallback_mimetype is application/octet-stream. If a filename looks like a text mimetype, the utf-8 charset is added to it.   New in version 0.6: Added fallback_mimetype.   Changed in version 0.5: Added cache_timeout.   \nis_allowed(filename)  \nSubclasses can override this method to disallow the access to certain files. However by providing disallow in the constructor this method is overwritten.  Parameters \nfilename (str) \u2013   Return type \nbool   \n \n\n"}, {"name": "Serving WSGI Applications", "path": "serving/index", "type": "Other", "text": "Serving WSGI Applications There are many ways to serve a WSGI application. While you\u2019re developing it, you usually don\u2019t want to have a full-blown webserver like Apache up and running, but instead a simple standalone one. Because of that Werkzeug comes with a builtin development server. The easiest way is creating a small start-myproject.py file that runs the application using the builtin server: from werkzeug.serving import run_simple\nfrom myproject import make_app\n\napp = make_app(...)\nrun_simple('localhost', 8080, app, use_reloader=True)\n You can also pass it the extra_files keyword argument with a list of additional files (like configuration files) you want to observe.  \nwerkzeug.serving.run_simple(hostname, port, application, use_reloader=False, use_debugger=False, use_evalex=True, extra_files=None, exclude_patterns=None, reloader_interval=1, reloader_type='auto', threaded=False, processes=1, request_handler=None, static_files=None, passthrough_errors=False, ssl_context=None)  \nStart a WSGI application. Optional features include a reloader, multithreading and fork support. This function has a command-line interface too: python -m werkzeug.serving --help\n  Changed in version 2.0: Added exclude_patterns parameter.   Changelog Changed in version 0.15: Bind to a Unix socket by passing a path that starts with unix:// as the hostname.   New in version 0.10: Improved the reloader and added support for changing the backend through the reloader_type parameter. See Reloader for more information.   New in version 0.9: Added command-line interface.   New in version 0.8: Added support for automatically loading a SSL context from certificate file and private key.   New in version 0.6: support for SSL was added.   New in version 0.5: static_files was added to simplify serving of static files as well as passthrough_errors.   Parameters \n \nhostname (str) \u2013 The host to bind to, for example 'localhost'. If the value is a path that starts with unix:// it will bind to a Unix socket instead of a TCP socket.. \nport (int) \u2013 The port for the server. eg: 8080\n \napplication (WSGIApplication) \u2013 the WSGI application to execute \nuse_reloader (bool) \u2013 should the server automatically restart the python process if modules were changed? \nuse_debugger (bool) \u2013 should the werkzeug debugging system be used? \nuse_evalex (bool) \u2013 should the exception evaluation feature be enabled? \nextra_files (Optional[Iterable[str]]) \u2013 a list of files the reloader should watch additionally to the modules. For example configuration files. \nexclude_patterns (Optional[Iterable[str]]) \u2013 List of fnmatch patterns to ignore when running the reloader. For example, ignore cache files that shouldn\u2019t reload when updated. \nreloader_interval (int) \u2013 the interval for the reloader in seconds. \nreloader_type (str) \u2013 the type of reloader to use. The default is auto detection. Valid values are 'stat' and 'watchdog'. See Reloader for more information. \nthreaded (bool) \u2013 should the process handle each request in a separate thread? \nprocesses (int) \u2013 if greater than 1 then handle each request in a new process up to this maximum number of concurrent processes. \nrequest_handler (Optional[Type[werkzeug.serving.WSGIRequestHandler]]) \u2013 optional parameter that can be used to replace the default one. You can use this to replace it with a different BaseHTTPRequestHandler subclass. \nstatic_files (Optional[Dict[str, Union[str, Tuple[str, str]]]]) \u2013 a list or dict of paths for static files. This works exactly like SharedDataMiddleware, it\u2019s actually just wrapping the application in that middleware before serving. \npassthrough_errors (bool) \u2013 set this to True to disable the error catching. This means that the server will die on errors but it can be useful to hook debuggers in (pdb etc.) \nssl_context (Optional[Union[ssl.SSLContext, Tuple[str, Optional[str]], te.Literal['adhoc']]]) \u2013 an SSL context for the connection. Either an ssl.SSLContext, a tuple in the form (cert_file, pkey_file), the string 'adhoc' if the server should automatically create one, or None to disable SSL (which is the default).   Return type \nNone   \n  \nwerkzeug.serving.is_running_from_reloader()  \nChecks if the application is running from within the Werkzeug reloader subprocess.  Changelog New in version 0.10.   Return type \nbool   \n  \nwerkzeug.serving.make_ssl_devcert(base_path, host=None, cn=None)  \nCreates an SSL key for development. This should be used instead of the 'adhoc' key which generates a new cert on each server start. It accepts a path for where it should store the key and cert and either a host or CN. If a host is given it will use the CN *.host/CN=host. For more information see run_simple().  Changelog New in version 0.9.   Parameters \n \nbase_path (str) \u2013 the path to the certificate and key. The extension .crt is added for the certificate, .key is added for the key. \nhost (Optional[str]) \u2013 the name of the host. This can be used as an alternative for the cn. \ncn (Optional[str]) \u2013 the CN to use.   Return type \nTuple[str, str]   \n  Information The development server is not intended to be used on production systems. It was designed especially for development purposes and performs poorly under high load. For deployment setups have a look at the Application Deployment pages.   Reloader  Changelog Changed in version 0.10.  The Werkzeug reloader constantly monitors modules and paths of your web application, and restarts the server if any of the observed files change. Since version 0.10, there are two backends the reloader supports: stat and watchdog.  The default stat backend simply checks the mtime of all files in a regular interval. This is sufficient for most cases, however, it is known to drain a laptop\u2019s battery. The watchdog backend uses filesystem events, and is much faster than stat. It requires the watchdog module to be installed. The recommended way to achieve this is to add Werkzeug[watchdog] to your requirements file.  If watchdog is installed and available it will automatically be used instead of the builtin stat reloader. To switch between the backends you can use the reloader_type parameter of the run_simple() function. 'stat' sets it to the default stat based polling and 'watchdog' forces it to the watchdog backend.  Note Some edge cases, like modules that failed to import correctly, are not handled by the stat reloader for performance reasons. The watchdog reloader monitors such files too.    Colored Logging The development server highlights the request logs in different colors based on the status code. On Windows, Colorama must be installed as well to enable this.   Virtual Hosts Many web applications utilize multiple subdomains. This can be a bit tricky to simulate locally. Fortunately there is the hosts file that can be used to assign the local computer multiple names. This allows you to call your local computer yourapplication.local and api.yourapplication.local (or anything else) in addition to localhost. You can find the hosts file on the following location:  \nWindows %SystemRoot%\\system32\\drivers\\etc\\hosts  \nLinux / OS X /etc/hosts   You can open the file with your favorite text editor and add a new name after localhost: 127.0.0.1       localhost yourapplication.local api.yourapplication.local\n Save the changes and after a while you should be able to access the development server on these host names as well. You can use the URL Routing system to dispatch between different hosts or parse request.host yourself.   Shutting Down The Server  Changelog New in version 0.7.  Starting with Werkzeug 0.7 the development server provides a way to shut down the server after a request. This currently only works with Python 2.6 and later and will only work with the development server. To initiate the shutdown you have to call a function named 'werkzeug.server.shutdown' in the WSGI environment: def shutdown_server(environ):\n    if not 'werkzeug.server.shutdown' in environ:\n        raise RuntimeError('Not running the development server')\n    environ['werkzeug.server.shutdown']()\n   Troubleshooting On operating systems that support ipv6 and have it configured such as modern Linux systems, OS X 10.4 or higher as well as Windows Vista some browsers can be painfully slow if accessing your local server. The reason for this is that sometimes \u201clocalhost\u201d is configured to be available on both ipv4 and ipv6 sockets and some browsers will try to access ipv6 first and then ipv4. At the current time the integrated webserver does not support ipv6 and ipv4 at the same time and for better portability ipv4 is the default. If you notice that the web browser takes ages to load the page there are two ways around this issue. If you don\u2019t need ipv6 support you can disable the ipv6 entry in the hosts file by removing this line: ::1             localhost\n Alternatively you can also disable ipv6 support in your browser. For example if Firefox shows this behavior you can disable it by going to about:config and disabling the network.dns.disableIPv6 key. This however is not recommended as of Werkzeug 0.6.1! Starting with Werkzeug 0.6.1, the server will now switch between ipv4 and ipv6 based on your operating system\u2019s configuration. This means if that you disabled ipv6 support in your browser but your operating system is preferring ipv6, you will be unable to connect to your server. In that situation, you can either remove the localhost entry for ::1 or explicitly bind the hostname to an ipv4 address (127.0.0.1)   SSL  Changelog New in version 0.6.  The builtin server supports SSL for testing purposes. If an SSL context is provided it will be used. That means a server can either run in HTTP or HTTPS mode, but not both.  Quickstart The easiest way to do SSL based development with Werkzeug is by using it to generate an SSL certificate and private key and storing that somewhere and to then put it there. For the certificate you need to provide the name of your server on generation or a CN.  \nGenerate an SSL key and store it somewhere: >>> from werkzeug.serving import make_ssl_devcert\n>>> make_ssl_devcert('/path/to/the/key', host='localhost')\n('/path/to/the/key.crt', '/path/to/the/key.key')\n  \nNow this tuple can be passed as ssl_context to the run_simple() method: run_simple('localhost', 4000, application,\n           ssl_context=('/path/to/the/key.crt',\n                        '/path/to/the/key.key'))\n   You will have to acknowledge the certificate in your browser once then.   Loading Contexts by Hand You can use a ssl.SSLContext object instead of a tuple for full control over the TLS configuration. import ssl\nctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\nctx.load_cert_chain('ssl.cert', 'ssl.key')\nrun_simple('localhost', 4000, application, ssl_context=ctx)\n   Generating Certificates A key and certificate can be created in advance using the openssl tool instead of the make_ssl_devcert(). This requires that you have the openssl command installed on your system: $ openssl genrsa 1024 > ssl.key\n$ openssl req -new -x509 -nodes -sha1 -days 365 -key ssl.key > ssl.cert\n   Adhoc Certificates The easiest way to enable SSL is to start the server in adhoc-mode. In that case Werkzeug will generate an SSL certificate for you: run_simple('localhost', 4000, application,\n           ssl_context='adhoc')\n The downside of this of course is that you will have to acknowledge the certificate each time the server is reloaded. Adhoc certificates are discouraged because modern browsers do a bad job at supporting them for security reasons. This feature requires the cryptography library to be installed.    Unix Sockets The dev server can bind to a Unix socket instead of a TCP socket. run_simple() will bind to a Unix socket if the hostname parameter starts with 'unix://'. from werkzeug.serving import run_simple\nrun_simple('unix://example.sock', 0, app)\n \n"}, {"name": "SharedDataMiddleware", "path": "middleware/shared_data/index#werkzeug.middleware.shared_data.SharedDataMiddleware", "type": "werkzeug.middleware.shared_data", "text": " \nclass werkzeug.middleware.shared_data.SharedDataMiddleware(app, exports, disallow=None, cache=True, cache_timeout=43200, fallback_mimetype='application/octet-stream')  \nA WSGI middleware which provides static content for development environments or simple server setups. Its usage is quite simple: import os\nfrom werkzeug.middleware.shared_data import SharedDataMiddleware\n\napp = SharedDataMiddleware(app, {\n    '/shared': os.path.join(os.path.dirname(__file__), 'shared')\n})\n The contents of the folder ./shared will now be available on http://example.com/shared/. This is pretty useful during development because a standalone media server is not required. Files can also be mounted on the root folder and still continue to use the application because the shared data middleware forwards all unhandled requests to the application, even if the requests are below one of the shared folders. If pkg_resources is available you can also tell the middleware to serve files from package data: app = SharedDataMiddleware(app, {\n    '/static': ('myapplication', 'static')\n})\n This will then serve the static folder in the myapplication Python package. The optional disallow parameter can be a list of fnmatch() rules for files that are not accessible from the web. If cache is set to False no caching headers are sent. Currently the middleware does not support non-ASCII filenames. If the encoding on the file system happens to match the encoding of the URI it may work but this could also be by accident. We strongly suggest using ASCII only file names for static files. The middleware will guess the mimetype using the Python mimetype module. If it\u2019s unable to figure out the charset it will fall back to fallback_mimetype.  Parameters \n \napp (WSGIApplication) \u2013 the application to wrap. If you don\u2019t want to wrap an application you can pass it NotFound. \nexports (Union[Dict[str, Union[str, Tuple[str, str]]], Iterable[Tuple[str, Union[str, Tuple[str, str]]]]]) \u2013 a list or dict of exported files and folders. \ndisallow (None) \u2013 a list of fnmatch() rules. \ncache (bool) \u2013 enable or disable caching headers. \ncache_timeout (int) \u2013 the cache timeout in seconds for the headers. \nfallback_mimetype (str) \u2013 The fallback mimetype for unknown files.   Return type \nNone    Changelog Changed in version 1.0: The default fallback_mimetype is application/octet-stream. If a filename looks like a text mimetype, the utf-8 charset is added to it.   New in version 0.6: Added fallback_mimetype.   Changed in version 0.5: Added cache_timeout.   \nis_allowed(filename)  \nSubclasses can override this method to disallow the access to certain files. However by providing disallow in the constructor this method is overwritten.  Parameters \nfilename (str) \u2013   Return type \nbool   \n \n"}, {"name": "SharedDataMiddleware.is_allowed()", "path": "middleware/shared_data/index#werkzeug.middleware.shared_data.SharedDataMiddleware.is_allowed", "type": "werkzeug.middleware.shared_data", "text": " \nis_allowed(filename)  \nSubclasses can override this method to disallow the access to certain files. However by providing disallow in the constructor this method is overwritten.  Parameters \nfilename (str) \u2013   Return type \nbool   \n"}, {"name": "Subdomain", "path": "routing/index#werkzeug.routing.Subdomain", "type": "werkzeug.routing", "text": " \nclass werkzeug.routing.Subdomain(subdomain, rules)  \nAll URLs provided by this factory have the subdomain set to a specific domain. For example if you want to use the subdomain for the current language this can be a good setup: url_map = Map([\n    Rule('/', endpoint='#select_language'),\n    Subdomain('<string(length=2):lang_code>', [\n        Rule('/', endpoint='index'),\n        Rule('/about', endpoint='about'),\n        Rule('/help', endpoint='help')\n    ])\n])\n All the rules except for the '#select_language' endpoint will now listen on a two letter long subdomain that holds the language code for the current request.  Parameters \n \nsubdomain (str) \u2013  \nrules (Iterable[Rule]) \u2013    Return type \nNone   \n"}, {"name": "Submount", "path": "routing/index#werkzeug.routing.Submount", "type": "werkzeug.routing", "text": " \nclass werkzeug.routing.Submount(path, rules)  \nLike Subdomain but prefixes the URL rule with a given string: url_map = Map([\n    Rule('/', endpoint='index'),\n    Submount('/blog', [\n        Rule('/', endpoint='blog/index'),\n        Rule('/entry/<entry_slug>', endpoint='blog/show')\n    ])\n])\n Now the rule 'blog/show' matches /blog/entry/<entry_slug>.  Parameters \n \npath (str) \u2013  \nrules (Iterable[Rule]) \u2013    Return type \nNone   \n"}, {"name": "Testing WSGI Applications", "path": "test/index", "type": "Other", "text": "Testing WSGI Applications  Test Client Werkzeug provides a Client to simulate requests to a WSGI application without starting a server. The client has methods for making different types of requests, as well as managing cookies across requests. >>> from werkzeug.test import Client\n>>> from werkzeug.testapp import test_app\n>>> c = Client(test_app)\n>>> response = c.get(\"/\")\n>>> response.status_code\n200\n>>> resp.headers\nHeaders([('Content-Type', 'text/html; charset=utf-8'), ('Content-Length', '6658')])\n>>> response.get_data(as_text=True)\n'<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"...'\n The client\u2019s request methods return instances of TestResponse. This provides extra attributes and methods on top of Response that are useful for testing.   Request Body By passing a dict to data, the client will construct a request body with file and form data. It will set the content type to application/x-www-form-urlencoded if there are no files, or multipart/form-data there are. import io\n\nresponse = client.post(data={\n    \"name\": \"test\",\n    \"file\": (BytesIO(\"file contents\".encode(\"utf8\")), \"test.txt\")\n})\n Pass a string, bytes, or file-like object to data to use that as the raw request body. In that case, you should set the content type appropriately. For example, to post YAML: response = client.post(\n    data=\"a: value\\nb: 1\\n\", content_type=\"application/yaml\"\n)\n A shortcut when testing JSON APIs is to pass a dict to json instead of using data. This will automatically call json.dumps() and set the content type to application/json. Additionally, if the app returns JSON, response.json will automatically call json.loads(). response = client.post(\"/api\", json={\"a\": \"value\", \"b\": 1})\nobj = response.json()\n   Environment Builder EnvironBuilder is used to construct a WSGI environ dict. The test client uses this internally to prepare its requests. The arguments passed to the client request methods are the same as the builder. Sometimes, it can be useful to construct a WSGI environment manually. An environ builder or dict can be passed to the test client request methods in place of other arguments to use a custom environ. from werkzeug.test import EnvironBuilder\nbuilder = EnvironBuilder(...)\n# build an environ dict\nenviron = builder.get_environ()\n# build an environ dict wrapped in a request\nrequest = builder.get_request()\n The test client responses make this available through TestResponse.request and response.request.environ.   API  \nclass werkzeug.test.Client(application, response_wrapper=None, use_cookies=True, allow_subdomain_redirects=False)  \nThis class allows you to send requests to a wrapped application. The use_cookies parameter indicates whether cookies should be stored and sent for subsequent requests. This is True by default, but passing False will disable this behaviour. If you want to request some subdomain of your application you may set allow_subdomain_redirects to True as if not no external redirects are allowed.  Changed in version 2.0: response_wrapper is always a subclass of :class:TestResponse.   Changelog Changed in version 0.5: Added the use_cookies parameter.   Parameters \n \napplication (WSGIApplication) \u2013  \nresponse_wrapper (Optional[Type[Response]]) \u2013  \nuse_cookies (bool) \u2013  \nallow_subdomain_redirects (bool) \u2013    Return type \nNone    \nset_cookie(server_name, key, value='', max_age=None, expires=None, path='/', domain=None, secure=False, httponly=False, samesite=None, charset='utf-8')  \nSets a cookie in the client\u2019s cookie jar. The server name is required and has to match the one that is also passed to the open call.  Parameters \n \nserver_name (str) \u2013  \nkey (str) \u2013  \nvalue (str) \u2013  \nmax_age (Optional[Union[datetime.timedelta, int]]) \u2013  \nexpires (Optional[Union[str, datetime.datetime, int, float]]) \u2013  \npath (str) \u2013  \ndomain (Optional[str]) \u2013  \nsecure (bool) \u2013  \nhttponly (bool) \u2013  \nsamesite (Optional[str]) \u2013  \ncharset (str) \u2013    Return type \nNone   \n  \ndelete_cookie(server_name, key, path='/', domain=None, secure=False, httponly=False, samesite=None)  \nDeletes a cookie in the test client.  Parameters \n \nserver_name (str) \u2013  \nkey (str) \u2013  \npath (str) \u2013  \ndomain (Optional[str]) \u2013  \nsecure (bool) \u2013  \nhttponly (bool) \u2013  \nsamesite (Optional[str]) \u2013    Return type \nNone   \n  \nopen(*args, as_tuple=False, buffered=False, follow_redirects=False, **kwargs)  \nGenerate an environ dict from the given arguments, make a request to the application using it, and return the response.  Parameters \n \nargs (Any) \u2013 Passed to EnvironBuilder to create the environ for the request. If a single arg is passed, it can be an existing EnvironBuilder or an environ dict. \nbuffered (bool) \u2013 Convert the iterator returned by the app into a list. If the iterator has a close() method, it is called automatically. \nfollow_redirects (bool) \u2013 Make additional requests to follow HTTP redirects until a non-redirect status is returned. TestResponse.history lists the intermediate responses. \nas_tuple (bool) \u2013  \nkwargs (Any) \u2013    Return type \nwerkzeug.test.TestResponse    Changed in version 2.0: as_tuple is deprecated and will be removed in Werkzeug 2.1. Use TestResponse.request and request.environ instead.   Changed in version 2.0: The request input stream is closed when calling response.close(). Input streams for redirects are automatically closed.   Changelog Changed in version 0.5: If a dict is provided as file in the dict for the data parameter the content type has to be called content_type instead of mimetype. This change was made for consistency with werkzeug.FileWrapper.   Changed in version 0.5: Added the follow_redirects parameter.  \n\n  \nget(*args, **kw)  \nCall open() with method set to GET.  Parameters \n \nargs (Any) \u2013  \nkw (Any) \u2013    Return type \nwerkzeug.test.TestResponse   \n  \npost(*args, **kw)  \nCall open() with method set to POST.  Parameters \n \nargs (Any) \u2013  \nkw (Any) \u2013    Return type \nwerkzeug.test.TestResponse   \n  \nput(*args, **kw)  \nCall open() with method set to PUT.  Parameters \n \nargs (Any) \u2013  \nkw (Any) \u2013    Return type \nwerkzeug.test.TestResponse   \n  \ndelete(*args, **kw)  \nCall open() with method set to DELETE.  Parameters \n \nargs (Any) \u2013  \nkw (Any) \u2013    Return type \nwerkzeug.test.TestResponse   \n  \npatch(*args, **kw)  \nCall open() with method set to PATCH.  Parameters \n \nargs (Any) \u2013  \nkw (Any) \u2013    Return type \nwerkzeug.test.TestResponse   \n  \noptions(*args, **kw)  \nCall open() with method set to OPTIONS.  Parameters \n \nargs (Any) \u2013  \nkw (Any) \u2013    Return type \nwerkzeug.test.TestResponse   \n  \nhead(*args, **kw)  \nCall open() with method set to HEAD.  Parameters \n \nargs (Any) \u2013  \nkw (Any) \u2013    Return type \nwerkzeug.test.TestResponse   \n  \ntrace(*args, **kw)  \nCall open() with method set to TRACE.  Parameters \n \nargs (Any) \u2013  \nkw (Any) \u2013    Return type \nwerkzeug.test.TestResponse   \n \n  \nclass werkzeug.test.TestResponse(response, status, headers, request, history=(), **kwargs)  \nResponse subclass that provides extra information about requests made with the test Client. Test client requests will always return an instance of this class. If a custom response class is passed to the client, it is subclassed along with this to support test information. If the test request included large files, or if the application is serving a file, call close() to close any open files and prevent Python showing a ResourceWarning.  Parameters \n \nresponse (Union[Iterable[str], Iterable[bytes]]) \u2013  \nstatus (str) \u2013  \nheaders (werkzeug.datastructures.Headers) \u2013  \nrequest (werkzeug.wrappers.request.Request) \u2013  \nhistory (Tuple[werkzeug.test.TestResponse, ...]) \u2013  \nkwargs (Any) \u2013    Return type \nNone    \nrequest: werkzeug.wrappers.request.Request  \nA request object with the environ used to make the request that resulted in this response. \n  \nhistory: Tuple[werkzeug.test.TestResponse, ...]  \nA list of intermediate responses. Populated when the test request is made with follow_redirects enabled. \n \n  \nclass werkzeug.test.EnvironBuilder(path='/', base_url=None, query_string=None, method='GET', input_stream=None, content_type=None, content_length=None, errors_stream=None, multithread=False, multiprocess=False, run_once=False, headers=None, data=None, environ_base=None, environ_overrides=None, charset='utf-8', mimetype=None, json=None, auth=None)  \nThis class can be used to conveniently create a WSGI environment for testing purposes. It can be used to quickly create WSGI environments or request objects from arbitrary data. The signature of this class is also used in some other places as of Werkzeug 0.5 (create_environ(), Response.from_values(), Client.open()). Because of this most of the functionality is available through the constructor alone. Files and regular form data can be manipulated independently of each other with the form and files attributes, but are passed with the same argument to the constructor: data. data can be any of these values:  a str or bytes object: The object is converted into an input_stream, the content_length is set and you have to provide a content_type. \na dict or MultiDict: The keys have to be strings. The values have to be either any of the following objects, or a list of any of the following objects:  a file-like object: These are converted into FileStorage objects automatically. a tuple: The add_file() method is called with the key and the unpacked tuple items as positional arguments. a str: The string is set as form data for the associated key.   a file-like object: The object content is loaded in memory and then handled like a regular str or a bytes.   Parameters \n \npath (str) \u2013 the path of the request. In the WSGI environment this will end up as PATH_INFO. If the query_string is not defined and there is a question mark in the path everything after it is used as query string. \nbase_url (Optional[str]) \u2013 the base URL is a URL that is used to extract the WSGI URL scheme, host (server name + server port) and the script root (SCRIPT_NAME). \nquery_string (Optional[Union[Mapping[str, str], str]]) \u2013 an optional string or dict with URL parameters. \nmethod (str) \u2013 the HTTP method to use, defaults to GET. \ninput_stream (Optional[BinaryIO]) \u2013 an optional input stream. Do not specify this and data. As soon as an input stream is set you can\u2019t modify args and files unless you set the input_stream to None again. \ncontent_type (Optional[str]) \u2013 The content type for the request. As of 0.5 you don\u2019t have to provide this when specifying files and form data via data. \ncontent_length (Optional[int]) \u2013 The content length for the request. You don\u2019t have to specify this when providing data via data. \nerrors_stream (Optional[TextIO]) \u2013 an optional error stream that is used for wsgi.errors. Defaults to stderr. \nmultithread (bool) \u2013 controls wsgi.multithread. Defaults to False. \nmultiprocess (bool) \u2013 controls wsgi.multiprocess. Defaults to False. \nrun_once (bool) \u2013 controls wsgi.run_once. Defaults to False. \nheaders (Optional[Union[werkzeug.datastructures.Headers, Iterable[Tuple[str, str]]]]) \u2013 an optional list or Headers object of headers. \ndata (Optional[Union[BinaryIO, str, bytes, Mapping[str, Any]]]) \u2013 a string or dict of form data or a file-object. See explanation above. \njson (Optional[Mapping[str, Any]]) \u2013 An object to be serialized and assigned to data. Defaults the content type to \"application/json\". Serialized with the function assigned to json_dumps. \nenviron_base (Optional[Mapping[str, Any]]) \u2013 an optional dict of environment defaults. \nenviron_overrides (Optional[Mapping[str, Any]]) \u2013 an optional dict of environment overrides. \ncharset (str) \u2013 the charset used to encode string data. \nauth (Optional[Union[werkzeug.datastructures.Authorization, Tuple[str, str]]]) \u2013 An authorization object to use for the Authorization header value. A (username, password) tuple is a shortcut for Basic authorization. \nmimetype (Optional[str]) \u2013    Return type \nNone    Changed in version 2.0: REQUEST_URI and RAW_URI is the full raw URI including the query string, not only the path.   Changed in version 2.0: The default request_class is Request instead of BaseRequest.   New in version 2.0: Added the auth parameter.   Changelog New in version 0.15: The json param and json_dumps() method.   New in version 0.15: The environ has keys REQUEST_URI and RAW_URI containing the path before perecent-decoding. This is not part of the WSGI PEP, but many WSGI servers include it.   Changed in version 0.6: path and base_url can now be unicode strings that are encoded with iri_to_uri().   \nserver_protocol = 'HTTP/1.1'  \nthe server protocol to use. defaults to HTTP/1.1 \n  \nwsgi_version = (1, 0)  \nthe wsgi version to use. defaults to (1, 0) \n  \nrequest_class  \nalias of werkzeug.wrappers.request.Request \n  \nstatic json_dumps(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)  \nThe serialization function used when json is passed. \n  \nclassmethod from_environ(environ, **kwargs)  \nTurn an environ dict back into a builder. Any extra kwargs override the args extracted from the environ.  Changed in version 2.0: Path and query values are passed through the WSGI decoding dance to avoid double encoding.   Changelog New in version 0.15.   Parameters \n \nenviron (WSGIEnvironment) \u2013  \nkwargs (Any) \u2013    Return type \nEnvironBuilder   \n  \nproperty base_url: str  \nThe base URL is used to extract the URL scheme, host name, port, and root path. \n  \nproperty content_type: Optional[str]  \nThe content type for the request. Reflected from and to the headers. Do not set if you set files or form for auto detection. \n  \nproperty mimetype: Optional[str]  \nThe mimetype (content type without charset etc.)  Changelog New in version 0.14.  \n\n  \nproperty mimetype_params: Mapping[str, str]  \nThe mimetype parameters as dict. For example if the content type is text/html; charset=utf-8 the params would be {'charset': 'utf-8'}.  Changelog New in version 0.14.  \n\n  \nproperty content_length: Optional[int]  \nThe content length as integer. Reflected from and to the headers. Do not set if you set files or form for auto detection. \n  \nproperty form: werkzeug.datastructures.MultiDict  \nA MultiDict of form values. \n  \nproperty files: werkzeug.datastructures.FileMultiDict  \nA FileMultiDict of uploaded files. Use add_file() to add new files. \n  \nproperty input_stream: Optional[BinaryIO]  \nAn optional input stream. This is mutually exclusive with setting form and files, setting it will clear those. Do not provide this if the method is not POST or another method that has a body. \n  \nproperty query_string: str  \nThe query string. If you set this to a string args will no longer be available. \n  \nproperty args: werkzeug.datastructures.MultiDict  \nThe URL arguments as MultiDict. \n  \nproperty server_name: str  \nThe server name (read-only, use host to set) \n  \nproperty server_port: int  \nThe server port as integer (read-only, use host to set) \n  \nclose()  \nCloses all files. If you put real file objects into the files dict you can call this method to automatically close them all in one go.  Return type \nNone   \n  \nget_environ()  \nReturn the built environ.  Changelog Changed in version 0.15: The content type and length headers are set based on input stream detection. Previously this only set the WSGI keys.   Return type \nWSGIEnvironment   \n  \nget_request(cls=None)  \nReturns a request with the data. If the request class is not specified request_class is used.  Parameters \ncls (Optional[Type[werkzeug.wrappers.request.Request]]) \u2013 The request wrapper to use.  Return type \nwerkzeug.wrappers.request.Request   \n \n  \nwerkzeug.test.create_environ(*args, **kwargs)  \nCreate a new WSGI environ dict based on the values passed. The first parameter should be the path of the request which defaults to \u2018/\u2019. The second one can either be an absolute path (in that case the host is localhost:80) or a full path to the request with scheme, netloc port and the path to the script. This accepts the same arguments as the EnvironBuilder constructor.  Changelog Changed in version 0.5: This function is now a thin wrapper over EnvironBuilder which was added in 0.5. The headers, environ_base, environ_overrides and charset parameters were added.   Parameters \n \nargs (Any) \u2013  \nkwargs (Any) \u2013    Return type \nWSGIEnvironment   \n  \nwerkzeug.test.run_wsgi_app(app, environ, buffered=False)  \nReturn a tuple in the form (app_iter, status, headers) of the application output. This works best if you pass it an application that returns an iterator all the time. Sometimes applications may use the write() callable returned by the start_response function. This tries to resolve such edge cases automatically. But if you don\u2019t get the expected output you should set buffered to True which enforces buffering. If passed an invalid WSGI application the behavior of this function is undefined. Never pass non-conforming WSGI applications to this function.  Parameters \n \napp (WSGIApplication) \u2013 the application to execute. \nbuffered (bool) \u2013 set to True to enforce buffering. \nenviron (WSGIEnvironment) \u2013    Returns \ntuple in the form (app_iter, status, headers)  Return type \nTuple[Iterable[bytes], str, werkzeug.datastructures.Headers]   \n \n"}, {"name": "TestResponse", "path": "test/index#werkzeug.test.TestResponse", "type": "werkzeug.test", "text": " \nclass werkzeug.test.TestResponse(response, status, headers, request, history=(), **kwargs)  \nResponse subclass that provides extra information about requests made with the test Client. Test client requests will always return an instance of this class. If a custom response class is passed to the client, it is subclassed along with this to support test information. If the test request included large files, or if the application is serving a file, call close() to close any open files and prevent Python showing a ResourceWarning.  Parameters \n \nresponse (Union[Iterable[str], Iterable[bytes]]) \u2013  \nstatus (str) \u2013  \nheaders (werkzeug.datastructures.Headers) \u2013  \nrequest (werkzeug.wrappers.request.Request) \u2013  \nhistory (Tuple[werkzeug.test.TestResponse, ...]) \u2013  \nkwargs (Any) \u2013    Return type \nNone    \nrequest: werkzeug.wrappers.request.Request  \nA request object with the environ used to make the request that resulted in this response. \n  \nhistory: Tuple[werkzeug.test.TestResponse, ...]  \nA list of intermediate responses. Populated when the test request is made with follow_redirects enabled. \n \n"}, {"name": "TestResponse.history", "path": "test/index#werkzeug.test.TestResponse.history", "type": "werkzeug.test", "text": " \nhistory: Tuple[werkzeug.test.TestResponse, ...]  \nA list of intermediate responses. Populated when the test request is made with follow_redirects enabled. \n"}, {"name": "TestResponse.request", "path": "test/index#werkzeug.test.TestResponse.request", "type": "werkzeug.test", "text": " \nrequest: werkzeug.wrappers.request.Request  \nA request object with the environ used to make the request that resulted in this response. \n"}, {"name": "test_app()", "path": "wsgi/index#werkzeug.testapp.test_app", "type": "werkzeug.testapp", "text": " \nwerkzeug.testapp.test_app(environ, start_response)  \nSimple test application that dumps the environment. You can use it to check if Werkzeug is working properly: >>> from werkzeug.serving import run_simple\n>>> from werkzeug.testapp import test_app\n>>> run_simple('localhost', 3000, test_app)\n * Running on http://localhost:3000/\n The application displays important information from the WSGI environment, the Python interpreter and the installed libraries.  Parameters \n \nenviron (WSGIEnvironment) \u2013  \nstart_response (StartResponse) \u2013    Return type \nIterable[bytes]   \n"}, {"name": "TypeConversionDict", "path": "datastructures/index#werkzeug.datastructures.TypeConversionDict", "type": "werkzeug.datastructures", "text": " \nclass werkzeug.datastructures.TypeConversionDict  \nWorks like a regular dict but the get() method can perform type conversions. MultiDict and CombinedMultiDict are subclasses of this class and provide the same feature.  Changelog New in version 0.5.   \nget(key, default=None, type=None)  \nReturn the default value if the requested data doesn\u2019t exist. If type is provided and is a callable it should convert the value, return it or raise a ValueError if that is not possible. In this case the function will return the default as if the value was not found: >>> d = TypeConversionDict(foo='42', bar='blub')\n>>> d.get('foo', type=int)\n42\n>>> d.get('bar', -1, type=int)\n-1\n  Parameters \n \nkey \u2013 The key to be looked up. \ndefault \u2013 The default value to be returned if the key can\u2019t be looked up. If not further specified None is returned. \ntype \u2013 A callable that is used to cast the value in the MultiDict. If a ValueError is raised by this callable the default value is returned.    \n \n"}, {"name": "TypeConversionDict.get()", "path": "datastructures/index#werkzeug.datastructures.TypeConversionDict.get", "type": "werkzeug.datastructures", "text": " \nget(key, default=None, type=None)  \nReturn the default value if the requested data doesn\u2019t exist. If type is provided and is a callable it should convert the value, return it or raise a ValueError if that is not possible. In this case the function will return the default as if the value was not found: >>> d = TypeConversionDict(foo='42', bar='blub')\n>>> d.get('foo', type=int)\n42\n>>> d.get('bar', -1, type=int)\n-1\n  Parameters \n \nkey \u2013 The key to be looked up. \ndefault \u2013 The default value to be returned if the key can\u2019t be looked up. If not further specified None is returned. \ntype \u2013 A callable that is used to cast the value in the MultiDict. If a ValueError is raised by this callable the default value is returned.    \n"}, {"name": "unescape()", "path": "utils/index#werkzeug.utils.unescape", "type": "werkzeug.utils", "text": " \nwerkzeug.utils.unescape(s)  \nThe reverse of escape(). This unescapes all the HTML entities, not only those inserted by escape.  Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use MarkupSafe instead.   Parameters \ns (str) \u2013   Return type \nstr   \n"}, {"name": "Unicode", "path": "unicode/index", "type": "Other", "text": "Unicode Werkzeug uses strings internally everwhere text data is assumed, even if the HTTP standard is not Unicode aware. Basically all incoming data is decoded from the charset (UTF-8 by default) so that you don\u2019t work with bytes directly. Outgoing data is encoded into the target charset.  Unicode in Python Imagine you have the German Umlaut \u00f6. In ASCII you cannot represent that character, but in the latin-1 and utf-8 character sets you can represent it, but they look different when encoded: >>> \"\u00f6\".encode(\"latin1\")\nb'\\xf6'\n>>> \"\u00f6\".encode(\"utf-8\")\nb'\\xc3\\xb6'\n An \u00f6 looks different depending on the encoding which makes it hard to work with it as bytes. Instead, Python treats strings as Unicode text and stores the information LATIN SMALL LETTER O WITH DIAERESIS instead of the bytes for \u00f6 in a specific encoding. The length of a string with 1 character will be 1, where the length of the bytes might be some other value.   Unicode in HTTP However, the HTTP spec was written in a time where ASCII bytes were the common way data was represented. To work around this for the modern web, Werkzeug decodes and encodes incoming and outgoing data automatically. Data sent from the browser to the web application is decoded from UTF-8 bytes into a string. Data sent from the application back to the browser is encoded back to UTF-8.   Error Handling Functions that do internal encoding or decoding accept an errors keyword argument that is passed to str.decode() and str.encode(). The default is 'replace' so that errors are easy to spot. It might be useful to set it to 'strict' in order to catch the error and report the bad data to the client.   Request and Response Objects In most cases, you should stick with Werkzeug\u2019s default encoding of UTF-8. If you have a specific reason to, you can subclass wrappers.Request and wrappers.Response to change the encoding and error handling. from werkzeug.wrappers.request import Request\nfrom werkzeug.wrappers.response import Response\n\nclass Latin1Request(Request):\n    charset = \"latin1\"\n    encoding_errors = \"strict\"\n\nclass Latin1Response(Response):\n    charset = \"latin1\"\n The error handling can only be changed for the request. Werkzeug will always raise errors when encoding to bytes in the response. It\u2019s your responsibility to not create data that is not present in the target charset. This is not an issue for UTF-8. \n"}, {"name": "UnicodeConverter", "path": "routing/index#werkzeug.routing.UnicodeConverter", "type": "werkzeug.routing", "text": " \nclass werkzeug.routing.UnicodeConverter(map, minlength=1, maxlength=None, length=None)  \nThis converter is the default converter and accepts any string but only one path segment. Thus the string can not include a slash. This is the default validator. Example: Rule('/pages/<page>'),\nRule('/<string(length=2):lang_code>')\n  Parameters \n \nmap (Map) \u2013 the Map. \nminlength (int) \u2013 the minimum length of the string. Must be greater or equal 1. \nmaxlength (Optional[int]) \u2013 the maximum length of the string. \nlength (Optional[int]) \u2013 the exact length of the string.   Return type \nNone   \n"}, {"name": "unquote_etag()", "path": "http/index#werkzeug.http.unquote_etag", "type": "werkzeug.http", "text": " \nwerkzeug.http.unquote_etag(etag)  \nUnquote a single etag: >>> unquote_etag('W/\"bar\"')\n('bar', True)\n>>> unquote_etag('\"bar\"')\n('bar', False)\n  Parameters \netag (Optional[str]) \u2013 the etag identifier to unquote.  Returns \na (etag, weak) tuple.  Return type \nUnion[Tuple[str, bool], Tuple[None, None]]   \n"}, {"name": "unquote_header_value()", "path": "http/index#werkzeug.http.unquote_header_value", "type": "werkzeug.http", "text": " \nwerkzeug.http.unquote_header_value(value, is_filename=False)  \nUnquotes a header value. (Reversal of quote_header_value()). This does not use the real unquoting but what browsers are actually using for quoting.  Changelog New in version 0.5.   Parameters \n \nvalue (str) \u2013 the header value to unquote. \nis_filename (bool) \u2013 The value represents a filename or path.   Return type \nstr   \n"}, {"name": "uri_to_iri()", "path": "urls/index#werkzeug.urls.uri_to_iri", "type": "werkzeug.urls", "text": " \nwerkzeug.urls.uri_to_iri(uri, charset='utf-8', errors='werkzeug.url_quote')  \nConvert a URI to an IRI. All valid UTF-8 characters are unquoted, leaving all reserved and invalid characters quoted. If the URL has a domain, it is decoded from Punycode. >>> uri_to_iri(\"http://xn--n3h.net/p%C3%A5th?q=%C3%A8ry%DF\")\n'http://\\u2603.net/p\\xe5th?q=\\xe8ry%DF'\n  Parameters \n \nuri (Union[str, Tuple[str, str, str, str, str]]) \u2013 The URI to convert. \ncharset (str) \u2013 The encoding to encode unquoted bytes with. \nerrors (str) \u2013 Error handler to use during bytes.encode. By default, invalid bytes are left quoted.   Return type \nstr    Changelog Changed in version 0.15: All reserved and invalid characters remain quoted. Previously, only some reserved characters were preserved, and invalid bytes were replaced instead of left quoted.   New in version 0.6.  \n\n"}, {"name": "URL", "path": "urls/index#werkzeug.urls.URL", "type": "werkzeug.urls", "text": " \nclass werkzeug.urls.URL(scheme, netloc, path, query, fragment)  \nRepresents a parsed URL. This behaves like a regular tuple but also has some extra attributes that give further insight into the URL. Create new instance of _URLTuple(scheme, netloc, path, query, fragment)  Parameters \n \nscheme (str) \u2013  \nnetloc (str) \u2013  \npath (str) \u2013  \nquery (str) \u2013  \nfragment (str) \u2013      \nencode(charset='utf-8', errors='replace')  \nEncodes the URL to a tuple made out of bytes. The charset is only being used for the path, query and fragment.  Parameters \n \ncharset (str) \u2013  \nerrors (str) \u2013    Return type \nwerkzeug.urls.BytesURL   \n \n"}, {"name": "URL Helpers", "path": "urls/index", "type": "Other", "text": "URL Helpers Functions for working with URLs. Contains implementations of functions from urllib.parse that handle bytes and strings.  \nclass werkzeug.urls.BaseURL(scheme, netloc, path, query, fragment)  \nSuperclass of URL and BytesURL. Create new instance of _URLTuple(scheme, netloc, path, query, fragment)  Parameters \n \nscheme (str) \u2013  \nnetloc (str) \u2013  \npath (str) \u2013  \nquery (str) \u2013  \nfragment (str) \u2013      \nproperty ascii_host: Optional[str]  \nWorks exactly like host but will return a result that is restricted to ASCII. If it finds a netloc that is not ASCII it will attempt to idna decode it. This is useful for socket operations when the URL might include internationalized characters. \n  \nproperty auth: Optional[str]  \nThe authentication part in the URL if available, None otherwise. \n  \ndecode_netloc()  \nDecodes the netloc part into a string.  Return type \nstr   \n  \ndecode_query(*args, **kwargs)  \nDecodes the query part of the URL. Ths is a shortcut for calling url_decode() on the query argument. The arguments and keyword arguments are forwarded to url_decode() unchanged.  Parameters \n \nargs (Any) \u2013  \nkwargs (Any) \u2013    Return type \nds.MultiDict[str, str]   \n  \nencode_netloc()  \nEncodes the netloc part to an ASCII safe URL as bytes.  Return type \nstr   \n  \nget_file_location(pathformat=None)  \nReturns a tuple with the location of the file in the form (server, location). If the netloc is empty in the URL or points to localhost, it\u2019s represented as None. The pathformat by default is autodetection but needs to be set when working with URLs of a specific system. The supported values are 'windows' when working with Windows or DOS paths and 'posix' when working with posix paths. If the URL does not point to a local file, the server and location are both represented as None.  Parameters \npathformat (Optional[str]) \u2013 The expected format of the path component. Currently 'windows' and 'posix' are supported. Defaults to None which is autodetect.  Return type \nTuple[Optional[str], Optional[str]]   \n  \nproperty host: Optional[str]  \nThe host part of the URL if available, otherwise None. The host is either the hostname or the IP address mentioned in the URL. It will not contain the port. \n  \njoin(*args, **kwargs)  \nJoins this URL with another one. This is just a convenience function for calling into url_join() and then parsing the return value again.  Parameters \n \nargs (Any) \u2013  \nkwargs (Any) \u2013    Return type \nwerkzeug.urls.BaseURL   \n  \nproperty password: Optional[str]  \nThe password if it was part of the URL, None otherwise. This undergoes URL decoding and will always be a string. \n  \nproperty port: Optional[int]  \nThe port in the URL as an integer if it was present, None otherwise. This does not fill in default ports. \n  \nproperty raw_password: Optional[str]  \nThe password if it was part of the URL, None otherwise. Unlike password this one is not being decoded. \n  \nproperty raw_username: Optional[str]  \nThe username if it was part of the URL, None otherwise. Unlike username this one is not being decoded. \n  \nreplace(**kwargs)  \nReturn an URL with the same values, except for those parameters given new values by whichever keyword arguments are specified.  Parameters \nkwargs (Any) \u2013   Return type \nwerkzeug.urls.BaseURL   \n  \nto_iri_tuple()  \nReturns a URL tuple that holds a IRI. This will try to decode as much information as possible in the URL without losing information similar to how a web browser does it for the URL bar. It\u2019s usually more interesting to directly call uri_to_iri() which will return a string.  Return type \nwerkzeug.urls.BaseURL   \n  \nto_uri_tuple()  \nReturns a BytesURL tuple that holds a URI. This will encode all the information in the URL properly to ASCII using the rules a web browser would follow. It\u2019s usually more interesting to directly call iri_to_uri() which will return a string.  Return type \nwerkzeug.urls.BaseURL   \n  \nto_url()  \nReturns a URL string or bytes depending on the type of the information stored. This is just a convenience function for calling url_unparse() for this URL.  Return type \nstr   \n  \nproperty username: Optional[str]  \nThe username if it was part of the URL, None otherwise. This undergoes URL decoding and will always be a string. \n \n  \nclass werkzeug.urls.BytesURL(scheme, netloc, path, query, fragment)  \nRepresents a parsed URL in bytes. Create new instance of _URLTuple(scheme, netloc, path, query, fragment)  Parameters \n \nscheme (str) \u2013  \nnetloc (str) \u2013  \npath (str) \u2013  \nquery (str) \u2013  \nfragment (str) \u2013      \ndecode(charset='utf-8', errors='replace')  \nDecodes the URL to a tuple made out of strings. The charset is only being used for the path, query and fragment.  Parameters \n \ncharset (str) \u2013  \nerrors (str) \u2013    Return type \nwerkzeug.urls.URL   \n  \nencode_netloc()  \nReturns the netloc unchanged as bytes.  Return type \nbytes   \n \n  \nclass werkzeug.urls.Href(base='./', charset='utf-8', sort=False, key=None)  \nImplements a callable that constructs URLs with the given base. The function can be called with any number of positional and keyword arguments which than are used to assemble the URL. Works with URLs and posix paths. Positional arguments are appended as individual segments to the path of the URL: >>> href = Href('/foo')\n>>> href('bar', 23)\n'/foo/bar/23'\n>>> href('foo', bar=23)\n'/foo/foo?bar=23'\n If any of the arguments (positional or keyword) evaluates to None it will be skipped. If no keyword arguments are given the last argument can be a dict or MultiDict (or any other dict subclass), otherwise the keyword arguments are used for the query parameters, cutting off the first trailing underscore of the parameter name: >>> href(is_=42)\n'/foo?is=42'\n>>> href({'foo': 'bar'})\n'/foo?foo=bar'\n Combining of both methods is not allowed: >>> href({'foo': 'bar'}, bar=42)\nTraceback (most recent call last):\n  ...\nTypeError: keyword arguments and query-dicts can't be combined\n Accessing attributes on the href object creates a new href object with the attribute name as prefix: >>> bar_href = href.bar\n>>> bar_href(\"blub\")\n'/foo/bar/blub'\n If sort is set to True the items are sorted by key or the default sorting algorithm: >>> href = Href(\"/\", sort=True)\n>>> href(a=1, b=2, c=3)\n'/?a=1&b=2&c=3'\n  Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use werkzeug.routing instead.   Changelog New in version 0.5: sort and key were added.  \n\n  \nclass werkzeug.urls.URL(scheme, netloc, path, query, fragment)  \nRepresents a parsed URL. This behaves like a regular tuple but also has some extra attributes that give further insight into the URL. Create new instance of _URLTuple(scheme, netloc, path, query, fragment)  Parameters \n \nscheme (str) \u2013  \nnetloc (str) \u2013  \npath (str) \u2013  \nquery (str) \u2013  \nfragment (str) \u2013      \nencode(charset='utf-8', errors='replace')  \nEncodes the URL to a tuple made out of bytes. The charset is only being used for the path, query and fragment.  Parameters \n \ncharset (str) \u2013  \nerrors (str) \u2013    Return type \nwerkzeug.urls.BytesURL   \n \n  \nwerkzeug.urls.iri_to_uri(iri, charset='utf-8', errors='strict', safe_conversion=False)  \nConvert an IRI to a URI. All non-ASCII and unsafe characters are quoted. If the URL has a domain, it is encoded to Punycode. >>> iri_to_uri('http://\\u2603.net/p\\xe5th?q=\\xe8ry%DF')\n'http://xn--n3h.net/p%C3%A5th?q=%C3%A8ry%DF'\n  Parameters \n \niri (Union[str, Tuple[str, str, str, str, str]]) \u2013 The IRI to convert. \ncharset (str) \u2013 The encoding of the IRI. \nerrors (str) \u2013 Error handler to use during bytes.encode. \nsafe_conversion (bool) \u2013 Return the URL unchanged if it only contains ASCII characters and no whitespace. See the explanation below.   Return type \nstr   There is a general problem with IRI conversion with some protocols that are in violation of the URI specification. Consider the following two IRIs: magnet:?xt=uri:whatever\nitms-services://?action=download-manifest\n After parsing, we don\u2019t know if the scheme requires the //, which is dropped if empty, but conveys different meanings in the final URL if it\u2019s present or not. In this case, you can use safe_conversion, which will return the URL unchanged if it only contains ASCII characters and no whitespace. This can result in a URI with unquoted characters if it was not already quoted correctly, but preserves the URL\u2019s semantics. Werkzeug uses this for the Location header for redirects.  Changelog Changed in version 0.15: All reserved characters remain unquoted. Previously, only some reserved characters were left unquoted.   Changed in version 0.9.6: The safe_conversion parameter was added.   New in version 0.6.  \n\n  \nwerkzeug.urls.uri_to_iri(uri, charset='utf-8', errors='werkzeug.url_quote')  \nConvert a URI to an IRI. All valid UTF-8 characters are unquoted, leaving all reserved and invalid characters quoted. If the URL has a domain, it is decoded from Punycode. >>> uri_to_iri(\"http://xn--n3h.net/p%C3%A5th?q=%C3%A8ry%DF\")\n'http://\\u2603.net/p\\xe5th?q=\\xe8ry%DF'\n  Parameters \n \nuri (Union[str, Tuple[str, str, str, str, str]]) \u2013 The URI to convert. \ncharset (str) \u2013 The encoding to encode unquoted bytes with. \nerrors (str) \u2013 Error handler to use during bytes.encode. By default, invalid bytes are left quoted.   Return type \nstr    Changelog Changed in version 0.15: All reserved and invalid characters remain quoted. Previously, only some reserved characters were preserved, and invalid bytes were replaced instead of left quoted.   New in version 0.6.  \n\n  \nwerkzeug.urls.url_decode(s, charset='utf-8', decode_keys=None, include_empty=True, errors='replace', separator='&', cls=None)  \nParse a query string and return it as a MultiDict.  Parameters \n \ns (AnyStr) \u2013 The query string to parse. \ncharset (str) \u2013 Decode bytes to string with this charset. If not given, bytes are returned as-is. \ninclude_empty (bool) \u2013 Include keys with empty values in the dict. \nerrors (str) \u2013 Error handling behavior when decoding bytes. \nseparator (str) \u2013 Separator character between pairs. \ncls (Optional[Type[ds.MultiDict]]) \u2013 Container to hold result instead of MultiDict. \ndecode_keys (None) \u2013    Return type \nds.MultiDict[str, str]    Changed in version 2.0: The decode_keys parameter is deprecated and will be removed in Werkzeug 2.1.   Changelog Changed in version 0.5: In previous versions \u201c;\u201d and \u201c&\u201d could be used for url decoding. Now only \u201c&\u201d is supported. If you want to use \u201c;\u201d, a different separator can be provided.   Changed in version 0.5: The cls parameter was added.  \n\n  \nwerkzeug.urls.url_decode_stream(stream, charset='utf-8', decode_keys=None, include_empty=True, errors='replace', separator=b'&', cls=None, limit=None, return_iterator=False)  \nWorks like url_decode() but decodes a stream. The behavior of stream and limit follows functions like make_line_iter(). The generator of pairs is directly fed to the cls so you can consume the data while it\u2019s parsed.  Parameters \n \nstream (BinaryIO) \u2013 a stream with the encoded querystring \ncharset (str) \u2013 the charset of the query string. If set to None no decoding will take place. \ninclude_empty (bool) \u2013 Set to False if you don\u2019t want empty values to appear in the dict. \nerrors (str) \u2013 the decoding error behavior. \nseparator (bytes) \u2013 the pair separator to be used, defaults to &\n \ncls (Optional[Type[ds.MultiDict]]) \u2013 an optional dict class to use. If this is not specified or None the default MultiDict is used. \nlimit (Optional[int]) \u2013 the content length of the URL data. Not necessary if a limited stream is provided. \ndecode_keys (None) \u2013  \nreturn_iterator (bool) \u2013    Return type \nds.MultiDict[str, str]    Changed in version 2.0: The decode_keys and return_iterator parameters are deprecated and will be removed in Werkzeug 2.1.   Changelog New in version 0.8.  \n\n  \nwerkzeug.urls.url_encode(obj, charset='utf-8', encode_keys=None, sort=False, key=None, separator='&')  \nURL encode a dict/MultiDict. If a value is None it will not appear in the result string. Per default only values are encoded into the target charset strings.  Parameters \n \nobj (Union[Mapping[str, str], Iterable[Tuple[str, str]]]) \u2013 the object to encode into a query string. \ncharset (str) \u2013 the charset of the query string. \nsort (bool) \u2013 set to True if you want parameters to be sorted by key. \nseparator (str) \u2013 the separator to be used for the pairs. \nkey (Optional[Callable[[Tuple[str, str]], Any]]) \u2013 an optional function to be used for sorting. For more details check out the sorted() documentation. \nencode_keys (None) \u2013    Return type \nstr    Changed in version 2.0: The encode_keys parameter is deprecated and will be removed in Werkzeug 2.1.   Changelog Changed in version 0.5: Added the sort, key, and separator parameters.  \n\n  \nwerkzeug.urls.url_encode_stream(obj, stream=None, charset='utf-8', encode_keys=None, sort=False, key=None, separator='&')  \nLike url_encode() but writes the results to a stream object. If the stream is None a generator over all encoded pairs is returned.  Parameters \n \nobj (Union[Mapping[str, str], Iterable[Tuple[str, str]]]) \u2013 the object to encode into a query string. \nstream (Optional[TextIO]) \u2013 a stream to write the encoded object into or None if an iterator over the encoded pairs should be returned. In that case the separator argument is ignored. \ncharset (str) \u2013 the charset of the query string. \nsort (bool) \u2013 set to True if you want parameters to be sorted by key. \nseparator (str) \u2013 the separator to be used for the pairs. \nkey (Optional[Callable[[Tuple[str, str]], Any]]) \u2013 an optional function to be used for sorting. For more details check out the sorted() documentation. \nencode_keys (None) \u2013    Return type \nNone    Changed in version 2.0: The encode_keys parameter is deprecated and will be removed in Werkzeug 2.1.   Changelog New in version 0.8.  \n\n  \nwerkzeug.urls.url_fix(s, charset='utf-8')  \nSometimes you get an URL by a user that just isn\u2019t a real URL because it contains unsafe characters like \u2018 \u2018 and so on. This function can fix some of the problems in a similar way browsers handle data entered by the user: >>> url_fix('http://de.wikipedia.org/wiki/Elf (Begriffskl\\xe4rung)')\n'http://de.wikipedia.org/wiki/Elf%20(Begriffskl%C3%A4rung)'\n  Parameters \n \ns (str) \u2013 the string with the URL to fix. \ncharset (str) \u2013 The target charset for the URL if the url was given as a string.   Return type \nstr   \n  \nwerkzeug.urls.url_join(base, url, allow_fragments=True)  \nJoin a base URL and a possibly relative URL to form an absolute interpretation of the latter.  Parameters \n \nbase (Union[str, Tuple[str, str, str, str, str]]) \u2013 the base URL for the join operation. \nurl (Union[str, Tuple[str, str, str, str, str]]) \u2013 the URL to join. \nallow_fragments (bool) \u2013 indicates whether fragments should be allowed.   Return type \nstr   \n  \nwerkzeug.urls.url_parse(url, scheme=None, allow_fragments=True)  \nParses a URL from a string into a URL tuple. If the URL is lacking a scheme it can be provided as second argument. Otherwise, it is ignored. Optionally fragments can be stripped from the URL by setting allow_fragments to False. The inverse of this function is url_unparse().  Parameters \n \nurl (str) \u2013 the URL to parse. \nscheme (Optional[str]) \u2013 the default schema to use if the URL is schemaless. \nallow_fragments (bool) \u2013 if set to False a fragment will be removed from the URL.   Return type \nwerkzeug.urls.BaseURL   \n  \nwerkzeug.urls.url_quote(string, charset='utf-8', errors='strict', safe='/:', unsafe='')  \nURL encode a single string with a given encoding.  Parameters \n \ns \u2013 the string to quote. \ncharset (str) \u2013 the charset to be used. \nsafe (Union[str, bytes]) \u2013 an optional sequence of safe characters. \nunsafe (Union[str, bytes]) \u2013 an optional sequence of unsafe characters. \nstring (Union[str, bytes]) \u2013  \nerrors (str) \u2013    Return type \nstr    Changelog New in version 0.9.2: The unsafe parameter was added.  \n\n  \nwerkzeug.urls.url_quote_plus(string, charset='utf-8', errors='strict', safe='')  \nURL encode a single string with the given encoding and convert whitespace to \u201c+\u201d.  Parameters \n \ns \u2013 The string to quote. \ncharset (str) \u2013 The charset to be used. \nsafe (str) \u2013 An optional sequence of safe characters. \nstring (str) \u2013  \nerrors (str) \u2013    Return type \nstr   \n  \nwerkzeug.urls.url_unparse(components)  \nThe reverse operation to url_parse(). This accepts arbitrary as well as URL tuples and returns a URL as a string.  Parameters \ncomponents (Tuple[str, str, str, str, str]) \u2013 the parsed URL as tuple which should be converted into a URL string.  Return type \nstr   \n  \nwerkzeug.urls.url_unquote(s, charset='utf-8', errors='replace', unsafe='')  \nURL decode a single string with a given encoding. If the charset is set to None no decoding is performed and raw bytes are returned.  Parameters \n \ns (Union[str, bytes]) \u2013 the string to unquote. \ncharset (str) \u2013 the charset of the query string. If set to None no decoding will take place. \nerrors (str) \u2013 the error handling for the charset decoding. \nunsafe (str) \u2013    Return type \nstr   \n  \nwerkzeug.urls.url_unquote_plus(s, charset='utf-8', errors='replace')  \nURL decode a single string with the given charset and decode \u201c+\u201d to whitespace. Per default encoding errors are ignored. If you want a different behavior you can set errors to 'replace' or 'strict'.  Parameters \n \ns (Union[str, bytes]) \u2013 The string to unquote. \ncharset (str) \u2013 the charset of the query string. If set to None no decoding will take place. \nerrors (str) \u2013 The error handling for the charset decoding.   Return type \nstr   \n\n"}, {"name": "URL Routing", "path": "routing/index", "type": "Other", "text": "URL Routing When it comes to combining multiple controller or view functions (however you want to call them), you need a dispatcher. A simple way would be applying regular expression tests on PATH_INFO and call registered callback functions that return the value. Werkzeug provides a much more powerful system, similar to Routes. All the objects mentioned on this page must be imported from werkzeug.routing, not from werkzeug!  Quickstart Here is a simple example which could be the URL definition for a blog: from werkzeug.routing import Map, Rule, NotFound, RequestRedirect\n\nurl_map = Map([\n    Rule('/', endpoint='blog/index'),\n    Rule('/<int:year>/', endpoint='blog/archive'),\n    Rule('/<int:year>/<int:month>/', endpoint='blog/archive'),\n    Rule('/<int:year>/<int:month>/<int:day>/', endpoint='blog/archive'),\n    Rule('/<int:year>/<int:month>/<int:day>/<slug>',\n         endpoint='blog/show_post'),\n    Rule('/about', endpoint='blog/about_me'),\n    Rule('/feeds/', endpoint='blog/feeds'),\n    Rule('/feeds/<feed_name>.rss', endpoint='blog/show_feed')\n])\n\ndef application(environ, start_response):\n    urls = url_map.bind_to_environ(environ)\n    try:\n        endpoint, args = urls.match()\n    except HTTPException, e:\n        return e(environ, start_response)\n    start_response('200 OK', [('Content-Type', 'text/plain')])\n    return [f'Rule points to {endpoint!r} with arguments {args!r}']\n So what does that do? First of all we create a new Map which stores a bunch of URL rules. Then we pass it a list of Rule objects. Each Rule object is instantiated with a string that represents a rule and an endpoint which will be the alias for what view the rule represents. Multiple rules can have the same endpoint, but should have different arguments to allow URL construction. The format for the URL rules is straightforward, but explained in detail below. Inside the WSGI application we bind the url_map to the current request which will return a new MapAdapter. This url_map adapter can then be used to match or build domains for the current request. The MapAdapter.match() method can then either return a tuple in the form (endpoint, args) or raise one of the three exceptions NotFound, MethodNotAllowed, or RequestRedirect. For more details about those exceptions have a look at the documentation of the MapAdapter.match() method.   Rule Format Rule strings are URL paths with placeholders for variable parts in the format <converter(arguments):name>. converter and arguments (with parentheses) are optional. If no converter is given, the default converter is used (string by default). The available converters are discussed below. Rules that end with a slash are \u201cbranches\u201d, others are \u201cleaves\u201d. If strict_slashes is enabled (the default), visiting a branch URL without a trailing slash will redirect to the URL with a slash appended. Many HTTP servers merge consecutive slashes into one when receiving requests. If merge_slashes is enabled (the default), rules will merge slashes in non-variable parts when matching and building. Visiting a URL with consecutive slashes will redirect to the URL with slashes merged. If you want to disable merge_slashes for a Rule or Map, you\u2019ll also need to configure your web server appropriately.   Built-in Converters Converters for common types of URL variables are built-in. The available converters can be overridden or extended through Map.converters.  \nclass werkzeug.routing.UnicodeConverter(map, minlength=1, maxlength=None, length=None)  \nThis converter is the default converter and accepts any string but only one path segment. Thus the string can not include a slash. This is the default validator. Example: Rule('/pages/<page>'),\nRule('/<string(length=2):lang_code>')\n  Parameters \n \nmap (Map) \u2013 the Map. \nminlength (int) \u2013 the minimum length of the string. Must be greater or equal 1. \nmaxlength (Optional[int]) \u2013 the maximum length of the string. \nlength (Optional[int]) \u2013 the exact length of the string.   Return type \nNone   \n  \nclass werkzeug.routing.PathConverter(map, *args, **kwargs)  \nLike the default UnicodeConverter, but it also matches slashes. This is useful for wikis and similar applications: Rule('/<path:wikipage>')\nRule('/<path:wikipage>/edit')\n  Parameters \n \nmap (Map) \u2013 the Map. \nargs (Any) \u2013  \nkwargs (Any) \u2013    Return type \nNone   \n  \nclass werkzeug.routing.AnyConverter(map, *items)  \nMatches one of the items provided. Items can either be Python identifiers or strings: Rule('/<any(about, help, imprint, class, \"foo,bar\"):page_name>')\n  Parameters \n \nmap (Map) \u2013 the Map. \nitems (str) \u2013 this function accepts the possible items as positional arguments.   Return type \nNone   \n  \nclass werkzeug.routing.IntegerConverter(map, fixed_digits=0, min=None, max=None, signed=False)  \nThis converter only accepts integer values: Rule(\"/page/<int:page>\")\n By default it only accepts unsigned, positive values. The signed parameter will enable signed, negative values. Rule(\"/page/<int(signed=True):page>\")\n  Parameters \n \nmap (Map) \u2013 The Map. \nfixed_digits (int) \u2013 The number of fixed digits in the URL. If you set this to 4 for example, the rule will only match if the URL looks like /0001/. The default is variable length. \nmin (Optional[int]) \u2013 The minimal value. \nmax (Optional[int]) \u2013 The maximal value. \nsigned (bool) \u2013 Allow signed (negative) values.   Return type \nNone    Changelog New in version 0.15: The signed parameter.  \n\n  \nclass werkzeug.routing.FloatConverter(map, min=None, max=None, signed=False)  \nThis converter only accepts floating point values: Rule(\"/probability/<float:probability>\")\n By default it only accepts unsigned, positive values. The signed parameter will enable signed, negative values. Rule(\"/offset/<float(signed=True):offset>\")\n  Parameters \n \nmap (Map) \u2013 The Map. \nmin (Optional[float]) \u2013 The minimal value. \nmax (Optional[float]) \u2013 The maximal value. \nsigned (bool) \u2013 Allow signed (negative) values.   Return type \nNone    Changelog New in version 0.15: The signed parameter.  \n\n  \nclass werkzeug.routing.UUIDConverter(map, *args, **kwargs)  \nThis converter only accepts UUID strings: Rule('/object/<uuid:identifier>')\n  Changelog New in version 0.10.   Parameters \n \nmap (Map) \u2013 the Map. \nargs (Any) \u2013  \nkwargs (Any) \u2013    Return type \nNone   \n   Maps, Rules and Adapters  \nclass werkzeug.routing.Map(rules=None, default_subdomain='', charset='utf-8', strict_slashes=True, merge_slashes=True, redirect_defaults=True, converters=None, sort_parameters=False, sort_key=None, encoding_errors='replace', host_matching=False)  \nThe map class stores all the URL rules and some configuration parameters. Some of the configuration values are only stored on the Map instance since those affect all rules, others are just defaults and can be overridden for each rule. Note that you have to specify all arguments besides the rules as keyword arguments!  Parameters \n \nrules (Optional[Iterable[werkzeug.routing.RuleFactory]]) \u2013 sequence of url rules for this map. \ndefault_subdomain (str) \u2013 The default subdomain for rules without a subdomain defined. \ncharset (str) \u2013 charset of the url. defaults to \"utf-8\"\n \nstrict_slashes (bool) \u2013 If a rule ends with a slash but the matched URL does not, redirect to the URL with a trailing slash. \nmerge_slashes (bool) \u2013 Merge consecutive slashes when matching or building URLs. Matches will redirect to the normalized URL. Slashes in variable parts are not merged. \nredirect_defaults (bool) \u2013 This will redirect to the default rule if it wasn\u2019t visited that way. This helps creating unique URLs. \nconverters (Optional[Mapping[str, Type[werkzeug.routing.BaseConverter]]]) \u2013 A dict of converters that adds additional converters to the list of converters. If you redefine one converter this will override the original one. \nsort_parameters (bool) \u2013 If set to True the url parameters are sorted. See url_encode for more details. \nsort_key (Optional[Callable[[Any], Any]]) \u2013 The sort key function for url_encode. \nencoding_errors (str) \u2013 the error method to use for decoding \nhost_matching (bool) \u2013 if set to True it enables the host matching feature and disables the subdomain one. If enabled the host parameter to rules is used instead of the subdomain one.   Return type \nNone    Changelog Changed in version 1.0: If url_scheme is ws or wss, only WebSocket rules will match.   Changed in version 1.0: Added merge_slashes.   Changed in version 0.7: Added encoding_errors and host_matching.   Changed in version 0.5: Added sort_parameters and sort_key.   \nconverters  \nThe dictionary of converters. This can be modified after the class was created, but will only affect rules added after the modification. If the rules are defined with the list passed to the class, the converters parameter to the constructor has to be used instead. \n  \nadd(rulefactory)  \nAdd a new rule or factory to the map and bind it. Requires that the rule is not bound to another map.  Parameters \nrulefactory (werkzeug.routing.RuleFactory) \u2013 a Rule or RuleFactory  Return type \nNone   \n  \nbind(server_name, script_name=None, subdomain=None, url_scheme='http', default_method='GET', path_info=None, query_args=None)  \nReturn a new MapAdapter with the details specified to the call. Note that script_name will default to '/' if not further specified or None. The server_name at least is a requirement because the HTTP RFC requires absolute URLs for redirects and so all redirect exceptions raised by Werkzeug will contain the full canonical URL. If no path_info is passed to match() it will use the default path info passed to bind. While this doesn\u2019t really make sense for manual bind calls, it\u2019s useful if you bind a map to a WSGI environment which already contains the path info. subdomain will default to the default_subdomain for this map if no defined. If there is no default_subdomain you cannot use the subdomain feature.  Changelog Changed in version 1.0: If url_scheme is ws or wss, only WebSocket rules will match.   Changed in version 0.15: path_info defaults to '/' if None.   Changed in version 0.8: query_args can be a string.   Changed in version 0.7: Added query_args.   Parameters \n \nserver_name (str) \u2013  \nscript_name (Optional[str]) \u2013  \nsubdomain (Optional[str]) \u2013  \nurl_scheme (str) \u2013  \ndefault_method (str) \u2013  \npath_info (Optional[str]) \u2013  \nquery_args (Optional[Union[Mapping[str, Any], str]]) \u2013    Return type \nwerkzeug.routing.MapAdapter   \n  \nbind_to_environ(environ, server_name=None, subdomain=None)  \nLike bind() but you can pass it an WSGI environment and it will fetch the information from that dictionary. Note that because of limitations in the protocol there is no way to get the current subdomain and real server_name from the environment. If you don\u2019t provide it, Werkzeug will use SERVER_NAME and SERVER_PORT (or HTTP_HOST if provided) as used server_name with disabled subdomain feature. If subdomain is None but an environment and a server name is provided it will calculate the current subdomain automatically. Example: server_name is 'example.com' and the SERVER_NAME in the wsgi environ is 'staging.dev.example.com' the calculated subdomain will be 'staging.dev'. If the object passed as environ has an environ attribute, the value of this attribute is used instead. This allows you to pass request objects. Additionally PATH_INFO added as a default of the MapAdapter so that you don\u2019t have to pass the path info to the match method.  Changelog Changed in version 1.0.0: If the passed server name specifies port 443, it will match if the incoming scheme is https without a port.   Changed in version 1.0.0: A warning is shown when the passed server name does not match the incoming WSGI server name.   Changed in version 0.8: This will no longer raise a ValueError when an unexpected server name was passed.   Changed in version 0.5: previously this method accepted a bogus calculate_subdomain parameter that did not have any effect. It was removed because of that.   Parameters \n \nenviron (WSGIEnvironment) \u2013 a WSGI environment. \nserver_name (Optional[str]) \u2013 an optional server name hint (see above). \nsubdomain (Optional[str]) \u2013 optionally the current subdomain (see above).   Return type \nMapAdapter   \n  \ndefault_converters = {'any': <class 'werkzeug.routing.AnyConverter'>, 'default': <class 'werkzeug.routing.UnicodeConverter'>, 'float': <class 'werkzeug.routing.FloatConverter'>, 'int': <class 'werkzeug.routing.IntegerConverter'>, 'path': <class 'werkzeug.routing.PathConverter'>, 'string': <class 'werkzeug.routing.UnicodeConverter'>, 'uuid': <class 'werkzeug.routing.UUIDConverter'>}  \nA dict of default converters to be used. \n  \nis_endpoint_expecting(endpoint, *arguments)  \nIterate over all rules and check if the endpoint expects the arguments provided. This is for example useful if you have some URLs that expect a language code and others that do not and you want to wrap the builder a bit so that the current language code is automatically added if not provided but endpoints expect it.  Parameters \n \nendpoint (str) \u2013 the endpoint to check. \narguments (str) \u2013 this function accepts one or more arguments as positional arguments. Each one of them is checked.   Return type \nbool   \n  \niter_rules(endpoint=None)  \nIterate over all rules or the rules of an endpoint.  Parameters \nendpoint (Optional[str]) \u2013 if provided only the rules for that endpoint are returned.  Returns \nan iterator  Return type \nIterator[werkzeug.routing.Rule]   \n  \nlock_class()  \nThe type of lock to use when updating.  Changelog New in version 1.0.  \n\n  \nupdate()  \nCalled before matching and building to keep the compiled rules in the correct order after things changed.  Return type \nNone   \n \n  \nclass werkzeug.routing.MapAdapter(map, server_name, script_name, subdomain, url_scheme, path_info, default_method, query_args=None)  \nReturned by Map.bind() or Map.bind_to_environ() and does the URL matching and building based on runtime information.  Parameters \n \nmap (werkzeug.routing.Map) \u2013  \nserver_name (str) \u2013  \nscript_name (str) \u2013  \nsubdomain (Optional[str]) \u2013  \nurl_scheme (str) \u2013  \npath_info (str) \u2013  \ndefault_method (str) \u2013  \nquery_args (Optional[Union[Mapping[str, Any], str]]) \u2013      \nallowed_methods(path_info=None)  \nReturns the valid methods that match for a given path.  Changelog New in version 0.7.   Parameters \npath_info (Optional[str]) \u2013   Return type \nIterable[str]   \n  \nbuild(endpoint, values=None, method=None, force_external=False, append_unknown=True, url_scheme=None)  \nBuilding URLs works pretty much the other way round. Instead of match you call build and pass it the endpoint and a dict of arguments for the placeholders. The build function also accepts an argument called force_external which, if you set it to True will force external URLs. Per default external URLs (include the server name) will only be used if the target URL is on a different subdomain. >>> m = Map([\n...     Rule('/', endpoint='index'),\n...     Rule('/downloads/', endpoint='downloads/index'),\n...     Rule('/downloads/<int:id>', endpoint='downloads/show')\n... ])\n>>> urls = m.bind(\"example.com\", \"/\")\n>>> urls.build(\"index\", {})\n'/'\n>>> urls.build(\"downloads/show\", {'id': 42})\n'/downloads/42'\n>>> urls.build(\"downloads/show\", {'id': 42}, force_external=True)\n'http://example.com/downloads/42'\n Because URLs cannot contain non ASCII data you will always get bytes back. Non ASCII characters are urlencoded with the charset defined on the map instance. Additional values are converted to strings and appended to the URL as URL querystring parameters: >>> urls.build(\"index\", {'q': 'My Searchstring'})\n'/?q=My+Searchstring'\n When processing those additional values, lists are furthermore interpreted as multiple values (as per werkzeug.datastructures.MultiDict): >>> urls.build(\"index\", {'q': ['a', 'b', 'c']})\n'/?q=a&q=b&q=c'\n Passing a MultiDict will also add multiple values: >>> urls.build(\"index\", MultiDict((('p', 'z'), ('q', 'a'), ('q', 'b'))))\n'/?p=z&q=a&q=b'\n If a rule does not exist when building a BuildError exception is raised. The build method accepts an argument called method which allows you to specify the method you want to have an URL built for if you have different methods for the same endpoint specified.  Parameters \n \nendpoint (str) \u2013 the endpoint of the URL to build. \nvalues (Optional[Mapping[str, Any]]) \u2013 the values for the URL to build. Unhandled values are appended to the URL as query parameters. \nmethod (Optional[str]) \u2013 the HTTP method for the rule if there are different URLs for different methods on the same endpoint. \nforce_external (bool) \u2013 enforce full canonical external URLs. If the URL scheme is not provided, this will generate a protocol-relative URL. \nappend_unknown (bool) \u2013 unknown parameters are appended to the generated URL as query string argument. Disable this if you want the builder to ignore those. \nurl_scheme (Optional[str]) \u2013 Scheme to use in place of the bound url_scheme.   Return type \nstr    Changed in version 2.0: Added the url_scheme parameter.   Changelog New in version 0.6: Added the append_unknown parameter.  \n\n  \ndispatch(view_func, path_info=None, method=None, catch_http_exceptions=False)  \nDoes the complete dispatching process. view_func is called with the endpoint and a dict with the values for the view. It should look up the view function, call it, and return a response object or WSGI application. http exceptions are not caught by default so that applications can display nicer error messages by just catching them by hand. If you want to stick with the default error messages you can pass it catch_http_exceptions=True and it will catch the http exceptions. Here a small example for the dispatch usage: from werkzeug.wrappers import Request, Response\nfrom werkzeug.wsgi import responder\nfrom werkzeug.routing import Map, Rule\n\ndef on_index(request):\n    return Response('Hello from the index')\n\nurl_map = Map([Rule('/', endpoint='index')])\nviews = {'index': on_index}\n\n@responder\ndef application(environ, start_response):\n    request = Request(environ)\n    urls = url_map.bind_to_environ(environ)\n    return urls.dispatch(lambda e, v: views[e](request, **v),\n                         catch_http_exceptions=True)\n Keep in mind that this method might return exception objects, too, so use Response.force_type to get a response object.  Parameters \n \nview_func (Callable[[str, Mapping[str, Any]], WSGIApplication]) \u2013 a function that is called with the endpoint as first argument and the value dict as second. Has to dispatch to the actual view function with this information. (see above) \npath_info (Optional[str]) \u2013 the path info to use for matching. Overrides the path info specified on binding. \nmethod (Optional[str]) \u2013 the HTTP method used for matching. Overrides the method specified on binding. \ncatch_http_exceptions (bool) \u2013 set to True to catch any of the werkzeug HTTPExceptions.   Return type \nWSGIApplication   \n  \nget_host(domain_part)  \nFigures out the full host name for the given domain part. The domain part is a subdomain in case host matching is disabled or a full host name.  Parameters \ndomain_part (Optional[str]) \u2013   Return type \nstr   \n  \nmake_alias_redirect_url(path, endpoint, values, method, query_args)  \nInternally called to make an alias redirect URL.  Parameters \n \npath (str) \u2013  \nendpoint (str) \u2013  \nvalues (Mapping[str, Any]) \u2013  \nmethod (str) \u2013  \nquery_args (Union[Mapping[str, Any], str]) \u2013    Return type \nstr   \n  \nmatch(path_info=None, method=None, return_rule=False, query_args=None, websocket=None)  \nThe usage is simple: you just pass the match method the current path info as well as the method (which defaults to GET). The following things can then happen:  you receive a NotFound exception that indicates that no URL is matching. A NotFound exception is also a WSGI application you can call to get a default page not found page (happens to be the same object as werkzeug.exceptions.NotFound) you receive a MethodNotAllowed exception that indicates that there is a match for this URL but not for the current request method. This is useful for RESTful applications. you receive a RequestRedirect exception with a new_url attribute. This exception is used to notify you about a request Werkzeug requests from your WSGI application. This is for example the case if you request /foo although the correct URL is /foo/ You can use the RequestRedirect instance as response-like object similar to all other subclasses of HTTPException. you receive a WebsocketMismatch exception if the only match is a WebSocket rule but the bind is an HTTP request, or if the match is an HTTP rule but the bind is a WebSocket request. you get a tuple in the form (endpoint, arguments) if there is a match (unless return_rule is True, in which case you get a tuple in the form (rule, arguments))  If the path info is not passed to the match method the default path info of the map is used (defaults to the root URL if not defined explicitly). All of the exceptions raised are subclasses of HTTPException so they can be used as WSGI responses. They will all render generic error or redirect pages. Here is a small example for matching: >>> m = Map([\n...     Rule('/', endpoint='index'),\n...     Rule('/downloads/', endpoint='downloads/index'),\n...     Rule('/downloads/<int:id>', endpoint='downloads/show')\n... ])\n>>> urls = m.bind(\"example.com\", \"/\")\n>>> urls.match(\"/\", \"GET\")\n('index', {})\n>>> urls.match(\"/downloads/42\")\n('downloads/show', {'id': 42})\n And here is what happens on redirect and missing URLs: >>> urls.match(\"/downloads\")\nTraceback (most recent call last):\n  ...\nRequestRedirect: http://example.com/downloads/\n>>> urls.match(\"/missing\")\nTraceback (most recent call last):\n  ...\nNotFound: 404 Not Found\n  Parameters \n \npath_info (Optional[str]) \u2013 the path info to use for matching. Overrides the path info specified on binding. \nmethod (Optional[str]) \u2013 the HTTP method used for matching. Overrides the method specified on binding. \nreturn_rule (bool) \u2013 return the rule that matched instead of just the endpoint (defaults to False). \nquery_args (Optional[Union[Mapping[str, Any], str]]) \u2013 optional query arguments that are used for automatic redirects as string or dictionary. It\u2019s currently not possible to use the query arguments for URL matching. \nwebsocket (Optional[bool]) \u2013 Match WebSocket instead of HTTP requests. A websocket request has a ws or wss url_scheme. This overrides that detection.   Return type \nTuple[Union[str, werkzeug.routing.Rule], Mapping[str, Any]]    Changelog New in version 1.0: Added websocket.   Changed in version 0.8: query_args can be a string.   New in version 0.7: Added query_args.   New in version 0.6: Added return_rule.  \n\n  \ntest(path_info=None, method=None)  \nTest if a rule would match. Works like match but returns True if the URL matches, or False if it does not exist.  Parameters \n \npath_info (Optional[str]) \u2013 the path info to use for matching. Overrides the path info specified on binding. \nmethod (Optional[str]) \u2013 the HTTP method used for matching. Overrides the method specified on binding.   Return type \nbool   \n \n  \nclass werkzeug.routing.Rule(string, defaults=None, subdomain=None, methods=None, build_only=False, endpoint=None, strict_slashes=None, merge_slashes=None, redirect_to=None, alias=False, host=None, websocket=False)  \nA Rule represents one URL pattern. There are some options for Rule that change the way it behaves and are passed to the Rule constructor. Note that besides the rule-string all arguments must be keyword arguments in order to not break the application on Werkzeug upgrades.  \nstring \n\nRule strings basically are just normal URL paths with placeholders in the format <converter(arguments):name> where the converter and the arguments are optional. If no converter is defined the default converter is used which means string in the normal configuration. URL rules that end with a slash are branch URLs, others are leaves. If you have strict_slashes enabled (which is the default), all branch URLs that are matched without a trailing slash will trigger a redirect to the same URL with the missing slash appended. The converters are defined on the Map.  \nendpoint \n\nThe endpoint for this rule. This can be anything. A reference to a function, a string, a number etc. The preferred way is using a string because the endpoint is used for URL generation.  \ndefaults \n\nAn optional dict with defaults for other rules with the same endpoint. This is a bit tricky but useful if you want to have unique URLs: url_map = Map([\n    Rule('/all/', defaults={'page': 1}, endpoint='all_entries'),\n    Rule('/all/page/<int:page>', endpoint='all_entries')\n])\n If a user now visits http://example.com/all/page/1 he will be redirected to http://example.com/all/. If redirect_defaults is disabled on the Map instance this will only affect the URL generation.  \nsubdomain \n\nThe subdomain rule string for this rule. If not specified the rule only matches for the default_subdomain of the map. If the map is not bound to a subdomain this feature is disabled. Can be useful if you want to have user profiles on different subdomains and all subdomains are forwarded to your application: url_map = Map([\n    Rule('/', subdomain='<username>', endpoint='user/homepage'),\n    Rule('/stats', subdomain='<username>', endpoint='user/stats')\n])\n  \nmethods \n\nA sequence of http methods this rule applies to. If not specified, all methods are allowed. For example this can be useful if you want different endpoints for POST and GET. If methods are defined and the path matches but the method matched against is not in this list or in the list of another rule for that path the error raised is of the type MethodNotAllowed rather than NotFound. If GET is present in the list of methods and HEAD is not, HEAD is added automatically.  \nstrict_slashes \n\nOverride the Map setting for strict_slashes only for this rule. If not specified the Map setting is used.  \nmerge_slashes \n\nOverride Map.merge_slashes for this rule.  \nbuild_only \n\nSet this to True and the rule will never match but will create a URL that can be build. This is useful if you have resources on a subdomain or folder that are not handled by the WSGI application (like static data)  \nredirect_to \n\nIf given this must be either a string or callable. In case of a callable it\u2019s called with the url adapter that triggered the match and the values of the URL as keyword arguments and has to return the target for the redirect, otherwise it has to be a string with placeholders in rule syntax: def foo_with_slug(adapter, id):\n    # ask the database for the slug for the old id.  this of\n    # course has nothing to do with werkzeug.\n    return f'foo/{Foo.get_slug_for_id(id)}'\n\nurl_map = Map([\n    Rule('/foo/<slug>', endpoint='foo'),\n    Rule('/some/old/url/<slug>', redirect_to='foo/<slug>'),\n    Rule('/other/old/url/<int:id>', redirect_to=foo_with_slug)\n])\n When the rule is matched the routing system will raise a RequestRedirect exception with the target for the redirect. Keep in mind that the URL will be joined against the URL root of the script so don\u2019t use a leading slash on the target URL unless you really mean root of that domain.  \nalias \n\nIf enabled this rule serves as an alias for another rule with the same endpoint and arguments.  \nhost \n\nIf provided and the URL map has host matching enabled this can be used to provide a match rule for the whole host. This also means that the subdomain feature is disabled.  \nwebsocket \n\nIf True, this rule is only matches for WebSocket (ws://, wss://) requests. By default, rules will only match for HTTP requests.    Changelog New in version 1.0: Added websocket.   New in version 1.0: Added merge_slashes.   New in version 0.7: Added alias and host.   Changed in version 0.6.1: HEAD is added to methods if GET is present.   Parameters \n \nstring (str) \u2013  \ndefaults (Optional[Mapping[str, Any]]) \u2013  \nsubdomain (Optional[str]) \u2013  \nmethods (Optional[Iterable[str]]) \u2013  \nbuild_only (bool) \u2013  \nendpoint (Optional[str]) \u2013  \nstrict_slashes (Optional[bool]) \u2013  \nmerge_slashes (Optional[bool]) \u2013  \nredirect_to (Optional[Union[str, Callable[[...], str]]]) \u2013  \nalias (bool) \u2013  \nhost (Optional[str]) \u2013  \nwebsocket (bool) \u2013    Return type \nNone    \nempty()  \nReturn an unbound copy of this rule. This can be useful if want to reuse an already bound URL for another map. See get_empty_kwargs to override what keyword arguments are provided to the new copy.  Return type \nwerkzeug.routing.Rule   \n \n   Rule Factories  \nclass werkzeug.routing.RuleFactory  \nAs soon as you have more complex URL setups it\u2019s a good idea to use rule factories to avoid repetitive tasks. Some of them are builtin, others can be added by subclassing RuleFactory and overriding get_rules.  \nget_rules(map)  \nSubclasses of RuleFactory have to override this method and return an iterable of rules.  Parameters \nmap (werkzeug.routing.Map) \u2013   Return type \nIterable[werkzeug.routing.Rule]   \n \n  \nclass werkzeug.routing.Subdomain(subdomain, rules)  \nAll URLs provided by this factory have the subdomain set to a specific domain. For example if you want to use the subdomain for the current language this can be a good setup: url_map = Map([\n    Rule('/', endpoint='#select_language'),\n    Subdomain('<string(length=2):lang_code>', [\n        Rule('/', endpoint='index'),\n        Rule('/about', endpoint='about'),\n        Rule('/help', endpoint='help')\n    ])\n])\n All the rules except for the '#select_language' endpoint will now listen on a two letter long subdomain that holds the language code for the current request.  Parameters \n \nsubdomain (str) \u2013  \nrules (Iterable[Rule]) \u2013    Return type \nNone   \n  \nclass werkzeug.routing.Submount(path, rules)  \nLike Subdomain but prefixes the URL rule with a given string: url_map = Map([\n    Rule('/', endpoint='index'),\n    Submount('/blog', [\n        Rule('/', endpoint='blog/index'),\n        Rule('/entry/<entry_slug>', endpoint='blog/show')\n    ])\n])\n Now the rule 'blog/show' matches /blog/entry/<entry_slug>.  Parameters \n \npath (str) \u2013  \nrules (Iterable[Rule]) \u2013    Return type \nNone   \n  \nclass werkzeug.routing.EndpointPrefix(prefix, rules)  \nPrefixes all endpoints (which must be strings for this factory) with another string. This can be useful for sub applications: url_map = Map([\n    Rule('/', endpoint='index'),\n    EndpointPrefix('blog/', [Submount('/blog', [\n        Rule('/', endpoint='index'),\n        Rule('/entry/<entry_slug>', endpoint='show')\n    ])])\n])\n  Parameters \n \nprefix (str) \u2013  \nrules (Iterable[Rule]) \u2013    Return type \nNone   \n   Rule Templates  \nclass werkzeug.routing.RuleTemplate(rules)  \nReturns copies of the rules wrapped and expands string templates in the endpoint, rule, defaults or subdomain sections. Here a small example for such a rule template: from werkzeug.routing import Map, Rule, RuleTemplate\n\nresource = RuleTemplate([\n    Rule('/$name/', endpoint='$name.list'),\n    Rule('/$name/<int:id>', endpoint='$name.show')\n])\n\nurl_map = Map([resource(name='user'), resource(name='page')])\n When a rule template is called the keyword arguments are used to replace the placeholders in all the string parameters.  Parameters \nrules (Iterable[Rule]) \u2013   Return type \nNone   \n   Custom Converters You can add custom converters that add behaviors not provided by the built-in converters. To make a custom converter, subclass BaseConverter then pass the new class to the Map converters parameter, or add it to url_map.converters. The converter should have a regex attribute with a regular expression to match with. If the converter can take arguments in a URL rule, it should accept them in its __init__ method. It can implement a to_python method to convert the matched string to some other object. This can also do extra validation that wasn\u2019t possible with the regex attribute, and should raise a werkzeug.routing.ValidationError in that case. Raising any other errors will cause a 500 error. It can implement a to_url method to convert a Python object to a string when building a URL. Any error raised here will be converted to a werkzeug.routing.BuildError and eventually cause a 500 error. This example implements a BooleanConverter that will match the strings \"yes\", \"no\", and \"maybe\", returning a random value for \"maybe\". from random import randrange\nfrom werkzeug.routing import BaseConverter, ValidationError\n\nclass BooleanConverter(BaseConverter):\n    regex = r\"(?:yes|no|maybe)\"\n\n    def __init__(self, url_map, maybe=False):\n        super().__init__(url_map)\n        self.maybe = maybe\n\n    def to_python(self, value):\n        if value == \"maybe\":\n            if self.maybe:\n                return not randrange(2)\n            raise ValidationError\n        return value == 'yes'\n\n    def to_url(self, value):\n        return \"yes\" if value else \"no\"\n\nfrom werkzeug.routing import Map, Rule\n\nurl_map = Map([\n    Rule(\"/vote/<bool:werkzeug_rocks>\", endpoint=\"vote\"),\n    Rule(\"/guess/<bool(maybe=True):foo>\", endpoint=\"guess\")\n], converters={'bool': BooleanConverter})\n If you want to change the default converter, assign a different converter to the \"default\" key.   Host Matching  Changelog New in version 0.7.  Starting with Werkzeug 0.7 it\u2019s also possible to do matching on the whole host names instead of just the subdomain. To enable this feature you need to pass host_matching=True to the Map constructor and provide the host argument to all routes: url_map = Map([\n    Rule('/', endpoint='www_index', host='www.example.com'),\n    Rule('/', endpoint='help_index', host='help.example.com')\n], host_matching=True)\n Variable parts are of course also possible in the host section: url_map = Map([\n    Rule('/', endpoint='www_index', host='www.example.com'),\n    Rule('/', endpoint='user_index', host='<user>.example.com')\n], host_matching=True)\n   WebSockets  Changelog New in version 1.0.  If a Rule is created with websocket=True, it will only match if the Map is bound to a request with a url_scheme of ws or wss.  Note Werkzeug has no further WebSocket support beyond routing. This functionality is mostly of use to ASGI projects.  url_map = Map([\n    Rule(\"/ws\", endpoint=\"comm\", websocket=True),\n])\nadapter = map.bind(\"example.org\", \"/ws\", url_scheme=\"ws\")\nassert adapter.match() == (\"comm\", {})\n If the only match is a WebSocket rule and the bind is HTTP (or the only match is HTTP and the bind is WebSocket) a WebsocketMismatch (derives from BadRequest) exception is raised. As WebSocket URLs have a different scheme, rules are always built with a scheme and host, force_external=True is implied. url = adapter.build(\"comm\")\nassert url == \"ws://example.org/ws\"\n \n"}, {"name": "URL.encode()", "path": "urls/index#werkzeug.urls.URL.encode", "type": "werkzeug.urls", "text": " \nencode(charset='utf-8', errors='replace')  \nEncodes the URL to a tuple made out of bytes. The charset is only being used for the path, query and fragment.  Parameters \n \ncharset (str) \u2013  \nerrors (str) \u2013    Return type \nwerkzeug.urls.BytesURL   \n"}, {"name": "url_decode()", "path": "urls/index#werkzeug.urls.url_decode", "type": "werkzeug.urls", "text": " \nwerkzeug.urls.url_decode(s, charset='utf-8', decode_keys=None, include_empty=True, errors='replace', separator='&', cls=None)  \nParse a query string and return it as a MultiDict.  Parameters \n \ns (AnyStr) \u2013 The query string to parse. \ncharset (str) \u2013 Decode bytes to string with this charset. If not given, bytes are returned as-is. \ninclude_empty (bool) \u2013 Include keys with empty values in the dict. \nerrors (str) \u2013 Error handling behavior when decoding bytes. \nseparator (str) \u2013 Separator character between pairs. \ncls (Optional[Type[ds.MultiDict]]) \u2013 Container to hold result instead of MultiDict. \ndecode_keys (None) \u2013    Return type \nds.MultiDict[str, str]    Changed in version 2.0: The decode_keys parameter is deprecated and will be removed in Werkzeug 2.1.   Changelog Changed in version 0.5: In previous versions \u201c;\u201d and \u201c&\u201d could be used for url decoding. Now only \u201c&\u201d is supported. If you want to use \u201c;\u201d, a different separator can be provided.   Changed in version 0.5: The cls parameter was added.  \n\n"}, {"name": "url_decode_stream()", "path": "urls/index#werkzeug.urls.url_decode_stream", "type": "werkzeug.urls", "text": " \nwerkzeug.urls.url_decode_stream(stream, charset='utf-8', decode_keys=None, include_empty=True, errors='replace', separator=b'&', cls=None, limit=None, return_iterator=False)  \nWorks like url_decode() but decodes a stream. The behavior of stream and limit follows functions like make_line_iter(). The generator of pairs is directly fed to the cls so you can consume the data while it\u2019s parsed.  Parameters \n \nstream (BinaryIO) \u2013 a stream with the encoded querystring \ncharset (str) \u2013 the charset of the query string. If set to None no decoding will take place. \ninclude_empty (bool) \u2013 Set to False if you don\u2019t want empty values to appear in the dict. \nerrors (str) \u2013 the decoding error behavior. \nseparator (bytes) \u2013 the pair separator to be used, defaults to &\n \ncls (Optional[Type[ds.MultiDict]]) \u2013 an optional dict class to use. If this is not specified or None the default MultiDict is used. \nlimit (Optional[int]) \u2013 the content length of the URL data. Not necessary if a limited stream is provided. \ndecode_keys (None) \u2013  \nreturn_iterator (bool) \u2013    Return type \nds.MultiDict[str, str]    Changed in version 2.0: The decode_keys and return_iterator parameters are deprecated and will be removed in Werkzeug 2.1.   Changelog New in version 0.8.  \n\n"}, {"name": "url_encode()", "path": "urls/index#werkzeug.urls.url_encode", "type": "werkzeug.urls", "text": " \nwerkzeug.urls.url_encode(obj, charset='utf-8', encode_keys=None, sort=False, key=None, separator='&')  \nURL encode a dict/MultiDict. If a value is None it will not appear in the result string. Per default only values are encoded into the target charset strings.  Parameters \n \nobj (Union[Mapping[str, str], Iterable[Tuple[str, str]]]) \u2013 the object to encode into a query string. \ncharset (str) \u2013 the charset of the query string. \nsort (bool) \u2013 set to True if you want parameters to be sorted by key. \nseparator (str) \u2013 the separator to be used for the pairs. \nkey (Optional[Callable[[Tuple[str, str]], Any]]) \u2013 an optional function to be used for sorting. For more details check out the sorted() documentation. \nencode_keys (None) \u2013    Return type \nstr    Changed in version 2.0: The encode_keys parameter is deprecated and will be removed in Werkzeug 2.1.   Changelog Changed in version 0.5: Added the sort, key, and separator parameters.  \n\n"}, {"name": "url_encode_stream()", "path": "urls/index#werkzeug.urls.url_encode_stream", "type": "werkzeug.urls", "text": " \nwerkzeug.urls.url_encode_stream(obj, stream=None, charset='utf-8', encode_keys=None, sort=False, key=None, separator='&')  \nLike url_encode() but writes the results to a stream object. If the stream is None a generator over all encoded pairs is returned.  Parameters \n \nobj (Union[Mapping[str, str], Iterable[Tuple[str, str]]]) \u2013 the object to encode into a query string. \nstream (Optional[TextIO]) \u2013 a stream to write the encoded object into or None if an iterator over the encoded pairs should be returned. In that case the separator argument is ignored. \ncharset (str) \u2013 the charset of the query string. \nsort (bool) \u2013 set to True if you want parameters to be sorted by key. \nseparator (str) \u2013 the separator to be used for the pairs. \nkey (Optional[Callable[[Tuple[str, str]], Any]]) \u2013 an optional function to be used for sorting. For more details check out the sorted() documentation. \nencode_keys (None) \u2013    Return type \nNone    Changed in version 2.0: The encode_keys parameter is deprecated and will be removed in Werkzeug 2.1.   Changelog New in version 0.8.  \n\n"}, {"name": "url_fix()", "path": "urls/index#werkzeug.urls.url_fix", "type": "werkzeug.urls", "text": " \nwerkzeug.urls.url_fix(s, charset='utf-8')  \nSometimes you get an URL by a user that just isn\u2019t a real URL because it contains unsafe characters like \u2018 \u2018 and so on. This function can fix some of the problems in a similar way browsers handle data entered by the user: >>> url_fix('http://de.wikipedia.org/wiki/Elf (Begriffskl\\xe4rung)')\n'http://de.wikipedia.org/wiki/Elf%20(Begriffskl%C3%A4rung)'\n  Parameters \n \ns (str) \u2013 the string with the URL to fix. \ncharset (str) \u2013 The target charset for the URL if the url was given as a string.   Return type \nstr   \n"}, {"name": "url_join()", "path": "urls/index#werkzeug.urls.url_join", "type": "werkzeug.urls", "text": " \nwerkzeug.urls.url_join(base, url, allow_fragments=True)  \nJoin a base URL and a possibly relative URL to form an absolute interpretation of the latter.  Parameters \n \nbase (Union[str, Tuple[str, str, str, str, str]]) \u2013 the base URL for the join operation. \nurl (Union[str, Tuple[str, str, str, str, str]]) \u2013 the URL to join. \nallow_fragments (bool) \u2013 indicates whether fragments should be allowed.   Return type \nstr   \n"}, {"name": "url_parse()", "path": "urls/index#werkzeug.urls.url_parse", "type": "werkzeug.urls", "text": " \nwerkzeug.urls.url_parse(url, scheme=None, allow_fragments=True)  \nParses a URL from a string into a URL tuple. If the URL is lacking a scheme it can be provided as second argument. Otherwise, it is ignored. Optionally fragments can be stripped from the URL by setting allow_fragments to False. The inverse of this function is url_unparse().  Parameters \n \nurl (str) \u2013 the URL to parse. \nscheme (Optional[str]) \u2013 the default schema to use if the URL is schemaless. \nallow_fragments (bool) \u2013 if set to False a fragment will be removed from the URL.   Return type \nwerkzeug.urls.BaseURL   \n"}, {"name": "url_quote()", "path": "urls/index#werkzeug.urls.url_quote", "type": "werkzeug.urls", "text": " \nwerkzeug.urls.url_quote(string, charset='utf-8', errors='strict', safe='/:', unsafe='')  \nURL encode a single string with a given encoding.  Parameters \n \ns \u2013 the string to quote. \ncharset (str) \u2013 the charset to be used. \nsafe (Union[str, bytes]) \u2013 an optional sequence of safe characters. \nunsafe (Union[str, bytes]) \u2013 an optional sequence of unsafe characters. \nstring (Union[str, bytes]) \u2013  \nerrors (str) \u2013    Return type \nstr    Changelog New in version 0.9.2: The unsafe parameter was added.  \n\n"}, {"name": "url_quote_plus()", "path": "urls/index#werkzeug.urls.url_quote_plus", "type": "werkzeug.urls", "text": " \nwerkzeug.urls.url_quote_plus(string, charset='utf-8', errors='strict', safe='')  \nURL encode a single string with the given encoding and convert whitespace to \u201c+\u201d.  Parameters \n \ns \u2013 The string to quote. \ncharset (str) \u2013 The charset to be used. \nsafe (str) \u2013 An optional sequence of safe characters. \nstring (str) \u2013  \nerrors (str) \u2013    Return type \nstr   \n"}, {"name": "url_unparse()", "path": "urls/index#werkzeug.urls.url_unparse", "type": "werkzeug.urls", "text": " \nwerkzeug.urls.url_unparse(components)  \nThe reverse operation to url_parse(). This accepts arbitrary as well as URL tuples and returns a URL as a string.  Parameters \ncomponents (Tuple[str, str, str, str, str]) \u2013 the parsed URL as tuple which should be converted into a URL string.  Return type \nstr   \n"}, {"name": "url_unquote()", "path": "urls/index#werkzeug.urls.url_unquote", "type": "werkzeug.urls", "text": " \nwerkzeug.urls.url_unquote(s, charset='utf-8', errors='replace', unsafe='')  \nURL decode a single string with a given encoding. If the charset is set to None no decoding is performed and raw bytes are returned.  Parameters \n \ns (Union[str, bytes]) \u2013 the string to unquote. \ncharset (str) \u2013 the charset of the query string. If set to None no decoding will take place. \nerrors (str) \u2013 the error handling for the charset decoding. \nunsafe (str) \u2013    Return type \nstr   \n"}, {"name": "url_unquote_plus()", "path": "urls/index#werkzeug.urls.url_unquote_plus", "type": "werkzeug.urls", "text": " \nwerkzeug.urls.url_unquote_plus(s, charset='utf-8', errors='replace')  \nURL decode a single string with the given charset and decode \u201c+\u201d to whitespace. Per default encoding errors are ignored. If you want a different behavior you can set errors to 'replace' or 'strict'.  Parameters \n \ns (Union[str, bytes]) \u2013 The string to unquote. \ncharset (str) \u2013 the charset of the query string. If set to None no decoding will take place. \nerrors (str) \u2013 The error handling for the charset decoding.   Return type \nstr   \n"}, {"name": "UserAgent", "path": "utils/index#werkzeug.user_agent.UserAgent", "type": "werkzeug.user_agent", "text": " \nclass werkzeug.user_agent.UserAgent(string)  \nRepresents a parsed user agent header value. The default implementation does no parsing, only the string attribute is set. A subclass may parse the string to set the common attributes or expose other information. Set werkzeug.wrappers.Request.user_agent_class to use a subclass.  Parameters \nstring (str) \u2013 The header value to parse.  Return type \nNone    New in version 2.0: This replaces the previous useragents module, but does not provide a built-in parser.   \nplatform: Optional[str] = None  \nThe OS name, if it could be parsed from the string. \n  \nbrowser: Optional[str] = None  \nThe browser name, if it could be parsed from the string. \n  \nversion: Optional[str] = None  \nThe browser version, if it could be parsed from the string. \n  \nlanguage: Optional[str] = None  \nThe browser language, if it could be parsed from the string. \n  \nstring: str  \nThe original header value. \n  \nto_header()  \nConvert to a header value.  Return type \nstr   \n \n"}, {"name": "UserAgent", "path": "utils/index#werkzeug.useragents.UserAgent", "type": "werkzeug.useragents", "text": " \nclass werkzeug.useragents.UserAgent(environ_or_string)  \nRepresents a parsed user agent header value. This uses a basic parser to try to extract some information from the header.  Parameters \nenviron_or_string (t.Union[str, WSGIEnvironment]) \u2013 The header value to parse, or a WSGI environ containing the header.  Return type \nNone    Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Subclass werkzeug.user_agent.UserAgent (note the new module name) to use a dedicated parser instead.   Changed in version 2.0: Passing a WSGI environ is deprecated and will be removed in 2.1.   \nto_header()  \nConvert to a header value.  Return type \nstr   \n \n"}, {"name": "UserAgent.browser", "path": "utils/index#werkzeug.user_agent.UserAgent.browser", "type": "werkzeug.user_agent", "text": " \nbrowser: Optional[str] = None  \nThe browser name, if it could be parsed from the string. \n"}, {"name": "UserAgent.language", "path": "utils/index#werkzeug.user_agent.UserAgent.language", "type": "werkzeug.user_agent", "text": " \nlanguage: Optional[str] = None  \nThe browser language, if it could be parsed from the string. \n"}, {"name": "UserAgent.platform", "path": "utils/index#werkzeug.user_agent.UserAgent.platform", "type": "werkzeug.user_agent", "text": " \nplatform: Optional[str] = None  \nThe OS name, if it could be parsed from the string. \n"}, {"name": "UserAgent.string", "path": "utils/index#werkzeug.user_agent.UserAgent.string", "type": "werkzeug.user_agent", "text": " \nstring: str  \nThe original header value. \n"}, {"name": "UserAgent.to_header()", "path": "utils/index#werkzeug.user_agent.UserAgent.to_header", "type": "werkzeug.user_agent", "text": " \nto_header()  \nConvert to a header value.  Return type \nstr   \n"}, {"name": "UserAgent.to_header()", "path": "utils/index#werkzeug.useragents.UserAgent.to_header", "type": "werkzeug.useragents", "text": " \nto_header()  \nConvert to a header value.  Return type \nstr   \n"}, {"name": "UserAgent.version", "path": "utils/index#werkzeug.user_agent.UserAgent.version", "type": "werkzeug.user_agent", "text": " \nversion: Optional[str] = None  \nThe browser version, if it could be parsed from the string. \n"}, {"name": "Utilities", "path": "utils/index", "type": "Other", "text": "Utilities Various utility functions shipped with Werkzeug.  HTML Helpers  \nclass werkzeug.utils.HTMLBuilder(dialect)  \nHelper object for HTML generation. Per default there are two instances of that class. The html one, and the xhtml one for those two dialects. The class uses keyword parameters and positional parameters to generate small snippets of HTML. Keyword parameters are converted to XML/SGML attributes, positional arguments are used as children. Because Python accepts positional arguments before keyword arguments it\u2019s a good idea to use a list with the star-syntax for some children: >>> html.p(class_='foo', *[html.a('foo', href='foo.html'), ' ',\n...                        html.a('bar', href='bar.html')])\n'<p class=\"foo\"><a href=\"foo.html\">foo</a> <a href=\"bar.html\">bar</a></p>'\n This class works around some browser limitations and can not be used for arbitrary SGML/XML generation. For that purpose lxml and similar libraries exist. Calling the builder escapes the string passed: >>> html.p(html(\"<foo>\"))\n'<p>&lt;foo&gt;</p>'\n  Deprecated since version 2.0: Will be removed in Werkzeug 2.1.  \n  \nwerkzeug.utils.escape(s)  \nReplace &, <, >, \", and ' with HTML-safe sequences. None is escaped to an empty string.  Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use MarkupSafe instead.   Parameters \ns (Any) \u2013   Return type \nstr   \n  \nwerkzeug.utils.unescape(s)  \nThe reverse of escape(). This unescapes all the HTML entities, not only those inserted by escape.  Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use MarkupSafe instead.   Parameters \ns (str) \u2013   Return type \nstr   \n   General Helpers  \nclass werkzeug.utils.cached_property(fget, name=None, doc=None)  \nA property() that is only evaluated once. Subsequent access returns the cached value. Setting the property sets the cached value. Deleting the property clears the cached value, accessing it again will evaluate it again. class Example:\n    @cached_property\n    def value(self):\n        # calculate something important here\n        return 42\n\ne = Example()\ne.value  # evaluates\ne.value  # uses cache\ne.value = 16  # sets cache\ndel e.value  # clears cache\n The class must have a __dict__ for this to work.  Changed in version 2.0: del obj.name clears the cached value.   Parameters \n \nfget (Callable[[Any], Any]) \u2013  \nname (Optional[str]) \u2013  \ndoc (Optional[str]) \u2013    Return type \nNone   \n  \nwerkzeug.utils.invalidate_cached_property(obj, name)  \nInvalidates the cache for a cached_property: >>> class Test(object):\n...     @cached_property\n...     def magic_number(self):\n...         print(\"recalculating...\")\n...         return 42\n...\n>>> var = Test()\n>>> var.magic_number\nrecalculating...\n42\n>>> var.magic_number\n42\n>>> invalidate_cached_property(var, \"magic_number\")\n>>> var.magic_number\nrecalculating...\n42\n You must pass the name of the cached property as the second argument.  Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use del obj.name instead.   Parameters \n \nobj (object) \u2013  \nname (str) \u2013    Return type \nNone   \n  \nclass werkzeug.utils.environ_property(name, default=None, load_func=None, dump_func=None, read_only=None, doc=None)  \nMaps request attributes to environment variables. This works not only for the Werkzeug request object, but also any other class with an environ attribute: >>> class Test(object):\n...     environ = {'key': 'value'}\n...     test = environ_property('key')\n>>> var = Test()\n>>> var.test\n'value'\n If you pass it a second value it\u2019s used as default if the key does not exist, the third one can be a converter that takes a value and converts it. If it raises ValueError or TypeError the default value is used. If no default value is provided None is used. Per default the property is read only. You have to explicitly enable it by passing read_only=False to the constructor. \n  \nclass werkzeug.utils.header_property(name, default=None, load_func=None, dump_func=None, read_only=None, doc=None)  \nLike environ_property but for headers. \n  \nwerkzeug.utils.redirect(location, code=302, Response=None)  \nReturns a response object (a WSGI application) that, if called, redirects the client to the target location. Supported codes are 301, 302, 303, 305, 307, and 308. 300 is not supported because it\u2019s not a real redirect and 304 because it\u2019s the answer for a request with a request with defined If-Modified-Since headers.  Changelog New in version 0.10: The class used for the Response object can now be passed in.   New in version 0.6: The location can now be a unicode string that is encoded using the iri_to_uri() function.   Parameters \n \nlocation (str) \u2013 the location the response should redirect to. \ncode (int) \u2013 the redirect status code. defaults to 302. \nResponse (class) \u2013 a Response class to use when instantiating a response. The default is werkzeug.wrappers.Response if unspecified.   Return type \nResponse   \n  \nwerkzeug.utils.append_slash_redirect(environ, code=301)  \nRedirects to the same URL but with a slash appended. The behavior of this function is undefined if the path ends with a slash already.  Parameters \n \nenviron (WSGIEnvironment) \u2013 the WSGI environment for the request that triggers the redirect. \ncode (int) \u2013 the status code for the redirect.   Return type \nResponse   \n  \nwerkzeug.utils.send_file(path_or_file, environ, mimetype=None, as_attachment=False, download_name=None, conditional=True, etag=True, last_modified=None, max_age=None, use_x_sendfile=False, response_class=None, _root_path=None)  \nSend the contents of a file to the client. The first argument can be a file path or a file-like object. Paths are preferred in most cases because Werkzeug can manage the file and get extra information from the path. Passing a file-like object requires that the file is opened in binary mode, and is mostly useful when building a file in memory with io.BytesIO. Never pass file paths provided by a user. The path is assumed to be trusted, so a user could craft a path to access a file you didn\u2019t intend. If the WSGI server sets a file_wrapper in environ, it is used, otherwise Werkzeug\u2019s built-in wrapper is used. Alternatively, if the HTTP server supports X-Sendfile, use_x_sendfile=True will tell the server to send the given path, which is much more efficient than reading it in Python.  Parameters \n \npath_or_file (Union[os.PathLike, str, BinaryIO]) \u2013 The path to the file to send, relative to the current working directory if a relative path is given. Alternatively, a file-like object opened in binary mode. Make sure the file pointer is seeked to the start of the data. \nenviron (WSGIEnvironment) \u2013 The WSGI environ for the current request. \nmimetype (Optional[str]) \u2013 The MIME type to send for the file. If not provided, it will try to detect it from the file name. \nas_attachment (bool) \u2013 Indicate to a browser that it should offer to save the file instead of displaying it. \ndownload_name (Optional[str]) \u2013 The default name browsers will use when saving the file. Defaults to the passed file name. \nconditional (bool) \u2013 Enable conditional and range responses based on request headers. Requires passing a file path and environ. \netag (Union[bool, str]) \u2013 Calculate an ETag for the file, which requires passing a file path. Can also be a string to use instead. \nlast_modified (Optional[Union[datetime.datetime, int, float]]) \u2013 The last modified time to send for the file, in seconds. If not provided, it will try to detect it from the file path. \nmax_age (Optional[Union[int, Callable[[Optional[Union[os.PathLike, str]]], int]]]) \u2013 How long the client should cache the file, in seconds. If set, Cache-Control will be public, otherwise it will be no-cache to prefer conditional caching. \nuse_x_sendfile (bool) \u2013 Set the X-Sendfile header to let the server to efficiently send the file. Requires support from the HTTP server. Requires passing a file path. \nresponse_class (Optional[Type[Response]]) \u2013 Build the response using this class. Defaults to Response. \n_root_path (Optional[Union[os.PathLike, str]]) \u2013 Do not use. For internal use only. Use send_from_directory() to safely send files under a path.   Return type \nResponse    New in version 2.0: Adapted from Flask\u2019s implementation.   Changed in version 2.0: download_name replaces Flask\u2019s attachment_filename parameter. If as_attachment=False, it is passed with Content-Disposition: inline instead.   Changed in version 2.0: max_age replaces Flask\u2019s cache_timeout parameter. conditional is enabled and max_age is not set by default.   Changed in version 2.0: etag replaces Flask\u2019s add_etags parameter. It can be a string to use instead of generating one.   Changed in version 2.0: If an encoding is returned when guessing mimetype from download_name, set the Content-Encoding header.  \n  \nwerkzeug.utils.import_string(import_name, silent=False)  \nImports an object based on a string. This is useful if you want to use import paths as endpoints or something similar. An import path can be specified either in dotted notation (xml.sax.saxutils.escape) or with a colon as object delimiter (xml.sax.saxutils:escape). If silent is True the return value will be None if the import fails.  Parameters \n \nimport_name (str) \u2013 the dotted name for the object to import. \nsilent (bool) \u2013 if set to True import errors are ignored and None is returned instead.   Returns \nimported object  Return type \nAny   \n  \nwerkzeug.utils.find_modules(import_path, include_packages=False, recursive=False)  \nFinds all the modules below a package. This can be useful to automatically import all views / controllers so that their metaclasses / function decorators have a chance to register themselves on the application. Packages are not returned unless include_packages is True. This can also recursively list modules but in that case it will import all the packages to get the correct load path of that module.  Parameters \n \nimport_path (str) \u2013 the dotted name for the package to find child modules. \ninclude_packages (bool) \u2013 set to True if packages should be returned, too. \nrecursive (bool) \u2013 set to True if recursion should happen.   Returns \ngenerator  Return type \nIterator[str]   \n  \nwerkzeug.utils.validate_arguments(func, args, kwargs, drop_extra=True)  \nChecks if the function accepts the arguments and keyword arguments. Returns a new (args, kwargs) tuple that can safely be passed to the function without causing a TypeError because the function signature is incompatible. If drop_extra is set to True (which is the default) any extra positional or keyword arguments are dropped automatically. The exception raised provides three attributes:  \nmissing \n\nA set of argument names that the function expected but where missing.  \nextra \n\nA dict of keyword arguments that the function can not handle but where provided.  \nextra_positional \n\nA list of values that where given by positional argument but the function cannot accept.   This can be useful for decorators that forward user submitted data to a view function: from werkzeug.utils import ArgumentValidationError, validate_arguments\n\ndef sanitize(f):\n    def proxy(request):\n        data = request.values.to_dict()\n        try:\n            args, kwargs = validate_arguments(f, (request,), data)\n        except ArgumentValidationError:\n            raise BadRequest('The browser failed to transmit all '\n                             'the data expected.')\n        return f(*args, **kwargs)\n    return proxy\n  Parameters \n \nfunc \u2013 the function the validation is performed against. \nargs \u2013 a tuple of positional arguments. \nkwargs \u2013 a dict of keyword arguments. \ndrop_extra \u2013 set to False if you don\u2019t want extra arguments to be silently dropped.   Returns \ntuple in the form (args, kwargs).    Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use inspect.signature() instead.  \n  \nwerkzeug.utils.secure_filename(filename)  \nPass it a filename and it will return a secure version of it. This filename can then safely be stored on a regular file system and passed to os.path.join(). The filename returned is an ASCII only string for maximum portability. On windows systems the function also makes sure that the file is not named after one of the special device files. >>> secure_filename(\"My cool movie.mov\")\n'My_cool_movie.mov'\n>>> secure_filename(\"../../../etc/passwd\")\n'etc_passwd'\n>>> secure_filename('i contain cool \\xfcml\\xe4uts.txt')\n'i_contain_cool_umlauts.txt'\n The function might return an empty filename. It\u2019s your responsibility to ensure that the filename is unique and that you abort or generate a random filename if the function returned an empty one.  Changelog New in version 0.5.   Parameters \nfilename (str) \u2013 the filename to secure  Return type \nstr   \n  \nwerkzeug.utils.bind_arguments(func, args, kwargs)  \nBind the arguments provided into a dict. When passed a function, a tuple of arguments and a dict of keyword arguments bind_arguments returns a dict of names as the function would see it. This can be useful to implement a cache decorator that uses the function arguments to build the cache key based on the values of the arguments.  Parameters \n \nfunc \u2013 the function the arguments should be bound for. \nargs \u2013 tuple of positional arguments. \nkwargs \u2013 a dict of keyword arguments.   Returns \na dict of bound keyword arguments.    Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use Signature.bind() instead.  \n   URL Helpers Please refer to URL Helpers.   User Agent API  \nclass werkzeug.user_agent.UserAgent(string)  \nRepresents a parsed user agent header value. The default implementation does no parsing, only the string attribute is set. A subclass may parse the string to set the common attributes or expose other information. Set werkzeug.wrappers.Request.user_agent_class to use a subclass.  Parameters \nstring (str) \u2013 The header value to parse.  Return type \nNone    New in version 2.0: This replaces the previous useragents module, but does not provide a built-in parser.   \nplatform: Optional[str] = None  \nThe OS name, if it could be parsed from the string. \n  \nbrowser: Optional[str] = None  \nThe browser name, if it could be parsed from the string. \n  \nversion: Optional[str] = None  \nThe browser version, if it could be parsed from the string. \n  \nlanguage: Optional[str] = None  \nThe browser language, if it could be parsed from the string. \n  \nstring: str  \nThe original header value. \n  \nto_header()  \nConvert to a header value.  Return type \nstr   \n \n   UserAgent Parsing (deprecated)  Deprecated since version 2.0: This module will be removed in Werkzeug 2.1. Subclass werkzeug.user_agent.UserAgent to use a dedicated parser instead.   \nclass werkzeug.useragents.UserAgent(environ_or_string)  \nRepresents a parsed user agent header value. This uses a basic parser to try to extract some information from the header.  Parameters \nenviron_or_string (t.Union[str, WSGIEnvironment]) \u2013 The header value to parse, or a WSGI environ containing the header.  Return type \nNone    Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Subclass werkzeug.user_agent.UserAgent (note the new module name) to use a dedicated parser instead.   Changed in version 2.0: Passing a WSGI environ is deprecated and will be removed in 2.1.   \nto_header()  \nConvert to a header value.  Return type \nstr   \n \n   Security Helpers  Changelog New in version 0.6.1.   \nwerkzeug.security.generate_password_hash(password, method='pbkdf2:sha256', salt_length=16)  \nHash a password with the given method and salt with a string of the given length. The format of the string returned includes the method that was used so that check_password_hash() can check the hash. The format for the hashed string looks like this: method$salt$hash\n This method can not generate unsalted passwords but it is possible to set param method=\u2019plain\u2019 in order to enforce plaintext passwords. If a salt is used, hmac is used internally to salt the password. If PBKDF2 is wanted it can be enabled by setting the method to pbkdf2:method:iterations where iterations is optional: pbkdf2:sha256:80000$salt$hash\npbkdf2:sha256$salt$hash\n  Parameters \n \npassword (str) \u2013 the password to hash. \nmethod (str) \u2013 the hash method to use (one that hashlib supports). Can optionally be in the format pbkdf2:method:iterations to enable PBKDF2. \nsalt_length (int) \u2013 the length of the salt in letters.   Return type \nstr   \n  \nwerkzeug.security.check_password_hash(pwhash, password)  \nCheck a password against a given salted and hashed password value. In order to support unsalted legacy passwords this method supports plain text passwords, md5 and sha1 hashes (both salted and unsalted). Returns True if the password matched, False otherwise.  Parameters \n \npwhash (str) \u2013 a hashed string like returned by generate_password_hash(). \npassword (str) \u2013 the plaintext password to compare against the hash.   Return type \nbool   \n  \nwerkzeug.security.safe_str_cmp(a, b)  \nThis function compares strings in somewhat constant time. This requires that the length of at least one string is known in advance. Returns True if the two strings are equal, or False if they are not.  Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use hmac.compare_digest() instead.   Changelog New in version 0.7.   Parameters \n \na (str) \u2013  \nb (str) \u2013    Return type \nbool   \n  \nwerkzeug.security.safe_join(directory, *pathnames)  \nSafely join zero or more untrusted path components to a base directory to avoid escaping the base directory.  Parameters \n \ndirectory (str) \u2013 The trusted base directory. \npathnames (str) \u2013 The untrusted path components relative to the base directory.   Returns \nA safe path, otherwise None.  Return type \nOptional[str]   \n  \nwerkzeug.security.pbkdf2_hex(data, salt, iterations=260000, keylen=None, hashfunc=None)  \nLike pbkdf2_bin(), but returns a hex-encoded string.  Parameters \n \ndata (Union[str, bytes]) \u2013 the data to derive. \nsalt (Union[str, bytes]) \u2013 the salt for the derivation. \niterations (int) \u2013 the number of iterations. \nkeylen (Optional[int]) \u2013 the length of the resulting key. If not provided, the digest size will be used. \nhashfunc (Optional[Union[str, Callable]]) \u2013 the hash function to use. This can either be the string name of a known hash function, or a function from the hashlib module. Defaults to sha256.   Return type \nstr    Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use hashlib.pbkdf2_hmac() instead.   Changelog New in version 0.9.  \n\n  \nwerkzeug.security.pbkdf2_bin(data, salt, iterations=260000, keylen=None, hashfunc=None)  \nReturns a binary digest for the PBKDF2 hash algorithm of data with the given salt. It iterates iterations times and produces a key of keylen bytes. By default, SHA-256 is used as hash function; a different hashlib hashfunc can be provided.  Parameters \n \ndata (Union[str, bytes]) \u2013 the data to derive. \nsalt (Union[str, bytes]) \u2013 the salt for the derivation. \niterations (int) \u2013 the number of iterations. \nkeylen (Optional[int]) \u2013 the length of the resulting key. If not provided the digest size will be used. \nhashfunc (Optional[Union[str, Callable]]) \u2013 the hash function to use. This can either be the string name of a known hash function or a function from the hashlib module. Defaults to sha256.   Return type \nbytes    Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use hashlib.pbkdf2_hmac() instead.   Changelog New in version 0.9.  \n\n   Logging Werkzeug uses standard Python logging. The logger is named \"werkzeug\". import logging\nlogger = logging.getLogger(\"werkzeug\")\n If the logger level is not set, it will be set to INFO on first use. If there is no handler for that level, a StreamHandler is added. \n"}, {"name": "UUIDConverter", "path": "routing/index#werkzeug.routing.UUIDConverter", "type": "werkzeug.routing", "text": " \nclass werkzeug.routing.UUIDConverter(map, *args, **kwargs)  \nThis converter only accepts UUID strings: Rule('/object/<uuid:identifier>')\n  Changelog New in version 0.10.   Parameters \n \nmap (Map) \u2013 the Map. \nargs (Any) \u2013  \nkwargs (Any) \u2013    Return type \nNone   \n"}, {"name": "validate_arguments()", "path": "utils/index#werkzeug.utils.validate_arguments", "type": "werkzeug.utils", "text": " \nwerkzeug.utils.validate_arguments(func, args, kwargs, drop_extra=True)  \nChecks if the function accepts the arguments and keyword arguments. Returns a new (args, kwargs) tuple that can safely be passed to the function without causing a TypeError because the function signature is incompatible. If drop_extra is set to True (which is the default) any extra positional or keyword arguments are dropped automatically. The exception raised provides three attributes:  \nmissing \n\nA set of argument names that the function expected but where missing.  \nextra \n\nA dict of keyword arguments that the function can not handle but where provided.  \nextra_positional \n\nA list of values that where given by positional argument but the function cannot accept.   This can be useful for decorators that forward user submitted data to a view function: from werkzeug.utils import ArgumentValidationError, validate_arguments\n\ndef sanitize(f):\n    def proxy(request):\n        data = request.values.to_dict()\n        try:\n            args, kwargs = validate_arguments(f, (request,), data)\n        except ArgumentValidationError:\n            raise BadRequest('The browser failed to transmit all '\n                             'the data expected.')\n        return f(*args, **kwargs)\n    return proxy\n  Parameters \n \nfunc \u2013 the function the validation is performed against. \nargs \u2013 a tuple of positional arguments. \nkwargs \u2013 a dict of keyword arguments. \ndrop_extra \u2013 set to False if you don\u2019t want extra arguments to be silently dropped.   Returns \ntuple in the form (args, kwargs).    Deprecated since version 2.0: Will be removed in Werkzeug 2.1. Use inspect.signature() instead.  \n"}, {"name": "Werkzeug Tutorial", "path": "tutorial/index", "type": "Other", "text": "Werkzeug Tutorial Welcome to the Werkzeug tutorial in which we will create a TinyURL clone that stores URLs in a redis instance. The libraries we will use for this applications are Jinja 2 for the templates, redis for the database layer and, of course, Werkzeug for the WSGI layer. You can use pip to install the required libraries: pip install Jinja2 redis Werkzeug\n Also make sure to have a redis server running on your local machine. If you are on OS X, you can use brew to install it: brew install redis\n If you are on Ubuntu or Debian, you can use apt-get: sudo apt-get install redis-server\n Redis was developed for UNIX systems and was never really designed to work on Windows. For development purposes, the unofficial ports however work well enough. You can get them from github.  Introducing Shortly In this tutorial, we will together create a simple URL shortener service with Werkzeug. Please keep in mind that Werkzeug is not a framework, it\u2019s a library with utilities to create your own framework or application and as such is very flexible. The approach we use here is just one of many you can use. As data store, we will use redis here instead of a relational database to keep this simple and because that\u2019s the kind of job that redis excels at. The final result will look something like this:    Step 0: A Basic WSGI Introduction Werkzeug is a utility library for WSGI. WSGI itself is a protocol or convention that ensures that your web application can speak with the webserver and more importantly that web applications work nicely together. A basic \u201cHello World\u201d application in WSGI without the help of Werkzeug looks like this: def application(environ, start_response):\n    start_response('200 OK', [('Content-Type', 'text/plain')])\n    return ['Hello World!']\n A WSGI application is something you can call and pass an environ dict and a start_response callable. The environ contains all incoming information, the start_response function can be used to indicate the start of the response. With Werkzeug you don\u2019t have to deal directly with either as request and response objects are provided to work with them. The request data takes the environ object and allows you to access the data from that environ in a nice manner. The response object is a WSGI application in itself and provides a much nicer way to create responses. Here is how you would write that application with response objects: from werkzeug.wrappers import Response\n\ndef application(environ, start_response):\n    response = Response('Hello World!', mimetype='text/plain')\n    return response(environ, start_response)\n And here an expanded version that looks at the query string in the URL (more importantly at the name parameter in the URL to substitute \u201cWorld\u201d against another word): from werkzeug.wrappers import Request, Response\n\ndef application(environ, start_response):\n    request = Request(environ)\n    text = f\"Hello {request.args.get('name', 'World')}!\"\n    response = Response(text, mimetype='text/plain')\n    return response(environ, start_response)\n And that\u2019s all you need to know about WSGI.   Step 1: Creating the Folders Before we get started, let\u2019s create the folders needed for this application: /shortly\n    /static\n    /templates\n The shortly folder is not a python package, but just something where we drop our files. Directly into this folder we will then put our main module in the following steps. The files inside the static folder are available to users of the application via HTTP. This is the place where CSS and JavaScript files go. Inside the templates folder we will make Jinja2 look for templates. The templates you create later in the tutorial will go in this directory.   Step 2: The Base Structure Now let\u2019s get right into it and create a module for our application. Let\u2019s create a file called shortly.py in the shortly folder. At first we will need a bunch of imports. I will pull in all the imports here, even if they are not used right away, to keep it from being confusing: import os\nimport redis\nfrom werkzeug.urls import url_parse\nfrom werkzeug.wrappers import Request, Response\nfrom werkzeug.routing import Map, Rule\nfrom werkzeug.exceptions import HTTPException, NotFound\nfrom werkzeug.middleware.shared_data import SharedDataMiddleware\nfrom werkzeug.utils import redirect\nfrom jinja2 import Environment, FileSystemLoader\n Then we can create the basic structure for our application and a function to create a new instance of it, optionally with a piece of WSGI middleware that exports all the files on the static folder on the web: class Shortly(object):\n\n    def __init__(self, config):\n        self.redis = redis.Redis(config['redis_host'], config['redis_port'])\n\n    def dispatch_request(self, request):\n        return Response('Hello World!')\n\n    def wsgi_app(self, environ, start_response):\n        request = Request(environ)\n        response = self.dispatch_request(request)\n        return response(environ, start_response)\n\n    def __call__(self, environ, start_response):\n        return self.wsgi_app(environ, start_response)\n\n\ndef create_app(redis_host='localhost', redis_port=6379, with_static=True):\n    app = Shortly({\n        'redis_host':       redis_host,\n        'redis_port':       redis_port\n    })\n    if with_static:\n        app.wsgi_app = SharedDataMiddleware(app.wsgi_app, {\n            '/static':  os.path.join(os.path.dirname(__file__), 'static')\n        })\n    return app\n Lastly we can add a piece of code that will start a local development server with automatic code reloading and a debugger: if __name__ == '__main__':\n    from werkzeug.serving import run_simple\n    app = create_app()\n    run_simple('127.0.0.1', 5000, app, use_debugger=True, use_reloader=True)\n The basic idea here is that our Shortly class is an actual WSGI application. The __call__ method directly dispatches to wsgi_app. This is done so that we can wrap wsgi_app to apply middlewares like we do in the create_app function. The actual wsgi_app method then creates a Request object and calls the dispatch_request method which then has to return a Response object which is then evaluated as WSGI application again. As you can see: turtles all the way down. Both the Shortly class we create, as well as any request object in Werkzeug implements the WSGI interface. As a result of that you could even return another WSGI application from the dispatch_request method. The create_app factory function can be used to create a new instance of our application. Not only will it pass some parameters as configuration to the application but also optionally add a WSGI middleware that exports static files. This way we have access to the files from the static folder even when we are not configuring our server to provide them which is very helpful for development.   Intermezzo: Running the Application Now you should be able to execute the file with python and see a server on your local machine: $ python shortly.py\n * Running on http://127.0.0.1:5000/\n * Restarting with reloader: stat() polling\n It also tells you that the reloader is active. It will use various techniques to figure out if any file changed on the disk and then automatically restart. Just go to the URL and you should see \u201cHello World!\u201d.   Step 3: The Environment Now that we have the basic application class, we can make the constructor do something useful and provide a few helpers on there that can come in handy. We will need to be able to render templates and connect to redis, so let\u2019s extend the class a bit: def __init__(self, config):\n    self.redis = redis.Redis(config['redis_host'], config['redis_port'])\n    template_path = os.path.join(os.path.dirname(__file__), 'templates')\n    self.jinja_env = Environment(loader=FileSystemLoader(template_path),\n                                 autoescape=True)\n\ndef render_template(self, template_name, **context):\n    t = self.jinja_env.get_template(template_name)\n    return Response(t.render(context), mimetype='text/html')\n   Step 4: The Routing Next up is routing. Routing is the process of matching and parsing the URL to something we can use. Werkzeug provides a flexible integrated routing system which we can use for that. The way it works is that you create a Map instance and add a bunch of Rule objects. Each rule has a pattern it will try to match the URL against and an \u201cendpoint\u201d. The endpoint is typically a string and can be used to uniquely identify the URL. We could also use this to automatically reverse the URL, but that\u2019s not what we will do in this tutorial. Just put this into the constructor: self.url_map = Map([\n    Rule('/', endpoint='new_url'),\n    Rule('/<short_id>', endpoint='follow_short_link'),\n    Rule('/<short_id>+', endpoint='short_link_details')\n])\n Here we create a URL map with three rules. / for the root of the URL space where we will just dispatch to a function that implements the logic to create a new URL. And then one that follows the short link to the target URL and another one with the same rule but a plus (+) at the end to show the link details. So how do we find our way from the endpoint to a function? That\u2019s up to you. The way we will do it in this tutorial is by calling the method on_ + endpoint on the class itself. Here is how this works: def dispatch_request(self, request):\n    adapter = self.url_map.bind_to_environ(request.environ)\n    try:\n        endpoint, values = adapter.match()\n        return getattr(self, f'on_{endpoint}')(request, **values)\n    except HTTPException as e:\n        return e\n We bind the URL map to the current environment and get back a URLAdapter. The adapter can be used to match the request but also to reverse URLs. The match method will return the endpoint and a dictionary of values in the URL. For instance the rule for follow_short_link has a variable part called short_id. When we go to http://localhost:5000/foo we will get the following values back: endpoint = 'follow_short_link'\nvalues = {'short_id': 'foo'}\n If it does not match anything, it will raise a NotFound exception, which is an HTTPException. All HTTP exceptions are also WSGI applications by themselves which render a default error page. So we just catch all of them down and return the error itself. If all works well, we call the function on_ + endpoint and pass it the request as argument as well as all the URL arguments as keyword arguments and return the response object that method returns.   Step 5: The First View Let\u2019s start with the first view: the one for new URLs: def on_new_url(self, request):\n    error = None\n    url = ''\n    if request.method == 'POST':\n        url = request.form['url']\n        if not is_valid_url(url):\n            error = 'Please enter a valid URL'\n        else:\n            short_id = self.insert_url(url)\n            return redirect(f\"/{short_id}+\"\n\n\n            )\n    return self.render_template('new_url.html', error=error, url=url)\n This logic should be easy to understand. Basically we are checking that the request method is POST, in which case we validate the URL and add a new entry to the database, then redirect to the detail page. This means we need to write a function and a helper method. For URL validation this is good enough: def is_valid_url(url):\n    parts = url_parse(url)\n    return parts.scheme in ('http', 'https')\n For inserting the URL, all we need is this little method on our class: def insert_url(self, url):\n    short_id = self.redis.get(f'reverse-url:{url}')\n    if short_id is not None:\n        return short_id\n    url_num = self.redis.incr('last-url-id')\n    short_id = base36_encode(url_num)\n    self.redis.set(f'url-target:{short_id}', url)\n    self.redis.set(f'reverse-url:{url}', short_id)\n    return short_id\n reverse-url: + the URL will store the short id. If the URL was already submitted this won\u2019t be None and we can just return that value which will be the short ID. Otherwise we increment the last-url-id key and convert it to base36. Then we store the link and the reverse entry in redis. And here the function to convert to base 36: def base36_encode(number):\n    assert number >= 0, 'positive integer required'\n    if number == 0:\n        return '0'\n    base36 = []\n    while number != 0:\n        number, i = divmod(number, 36)\n        base36.append('0123456789abcdefghijklmnopqrstuvwxyz'[i])\n    return ''.join(reversed(base36))\n So what is missing for this view to work is the template. We will create this later, let\u2019s first also write the other views and then do the templates in one go.   Step 6: Redirect View The redirect view is easy. All it has to do is to look for the link in redis and redirect to it. Additionally we will also increment a counter so that we know how often a link was clicked: def on_follow_short_link(self, request, short_id):\n    link_target = self.redis.get(f'url-target:{short_id')\n    if link_target is None:\n        raise NotFound()\n    self.redis.incr(f'click-count:{short_id}')\n    return redirect(link_target)\n In this case we will raise a NotFound exception by hand if the URL does not exist, which will bubble up to the dispatch_request function and be converted into a default 404 response.   Step 7: Detail View The link detail view is very similar, we just render a template again. In addition to looking up the target, we also ask redis for the number of times the link was clicked and let it default to zero if such a key does not yet exist: def on_short_link_details(self, request, short_id):\n    link_target = self.redis.get(f'url-target:{short_id}')\n    if link_target is None:\n        raise NotFound()\n    click_count = int(self.redis.get(f'click-count:{short_id}') or 0)\n    return self.render_template('short_link_details.html',\n        link_target=link_target,\n        short_id=short_id,\n        click_count=click_count\n    )\n Please be aware that redis always works with strings, so you have to convert the click count to int by hand.   Step 8: Templates And here are all the templates. Just drop them into the templates folder. Jinja2 supports template inheritance, so the first thing we will do is create a layout template with blocks that act as placeholders. We also set up Jinja2 so that it automatically escapes strings with HTML rules, so we don\u2019t have to spend time on that ourselves. This prevents XSS attacks and rendering errors. layout.html: <!doctype html>\n<title>{% block title %}{% endblock %} | shortly</title>\n<link rel=stylesheet href=/static/style.css type=text/css>\n<div class=box>\n  <h1><a href=/>shortly</a></h1>\n  <p class=tagline>Shortly is a URL shortener written with Werkzeug\n  {% block body %}{% endblock %}\n</div>\n new_url.html: {% extends \"layout.html\" %}\n{% block title %}Create New Short URL{% endblock %}\n{% block body %}\n  <h2>Submit URL</h2>\n  <form action=\"\" method=post>\n    {% if error %}\n      <p class=error><strong>Error:</strong> {{ error }}\n    {% endif %}\n    <p>URL:\n      <input type=text name=url value=\"{{ url }}\" class=urlinput>\n      <input type=submit value=\"Shorten\">\n  </form>\n{% endblock %}\n short_link_details.html: {% extends \"layout.html\" %}\n{% block title %}Details about /{{ short_id }}{% endblock %}\n{% block body %}\n  <h2><a href=\"/{{ short_id }}\">/{{ short_id }}</a></h2>\n  <dl>\n    <dt>Full link\n    <dd class=link><div>{{ link_target }}</div>\n    <dt>Click count:\n    <dd>{{ click_count }}\n  </dl>\n{% endblock %}\n   Step 9: The Style For this to look better than ugly black and white, here a simple stylesheet that goes along: static/style.css: body        { background: #E8EFF0; margin: 0; padding: 0; }\nbody, input { font-family: 'Helvetica Neue', Arial,\n              sans-serif; font-weight: 300; font-size: 18px; }\n.box        { width: 500px; margin: 60px auto; padding: 20px;\n              background: white; box-shadow: 0 1px 4px #BED1D4;\n              border-radius: 2px; }\na           { color: #11557C; }\nh1, h2      { margin: 0; color: #11557C; }\nh1 a        { text-decoration: none; }\nh2          { font-weight: normal; font-size: 24px; }\n.tagline    { color: #888; font-style: italic; margin: 0 0 20px 0; }\n.link div   { overflow: auto; font-size: 0.8em; white-space: pre;\n              padding: 4px 10px; margin: 5px 0; background: #E5EAF1; }\ndt          { font-weight: normal; }\n.error      { background: #E8EFF0; padding: 3px 8px; color: #11557C;\n              font-size: 0.9em; border-radius: 2px; }\n.urlinput   { width: 300px; }\n   Bonus: Refinements Look at the implementation in the example dictionary in the Werkzeug repository to see a version of this tutorial with some small refinements such as a custom 404 page.  shortly in the example folder  \n"}, {"name": "wrap_file()", "path": "wsgi/index#werkzeug.wsgi.wrap_file", "type": "werkzeug.wsgi", "text": " \nwerkzeug.wsgi.wrap_file(environ, file, buffer_size=8192)  \nWraps a file. This uses the WSGI server\u2019s file wrapper if available or otherwise the generic FileWrapper.  Changelog New in version 0.5.  If the file wrapper from the WSGI server is used it\u2019s important to not iterate over it from inside the application but to pass it through unchanged. If you want to pass out a file wrapper inside a response object you have to set Response.direct_passthrough to True. More information about file wrappers are available in PEP 333.  Parameters \n \nfile (BinaryIO) \u2013 a file-like object with a read() method. \nbuffer_size (int) \u2013 number of bytes for one iteration. \nenviron (WSGIEnvironment) \u2013    Return type \nIterable[bytes]   \n"}, {"name": "WSGI Helpers", "path": "wsgi/index", "type": "Other", "text": "WSGI Helpers The following classes and functions are designed to make working with the WSGI specification easier or operate on the WSGI layer. All the functionality from this module is available on the high-level Request / Response Objects.  Iterator / Stream Helpers These classes and functions simplify working with the WSGI application iterator and the input stream.  \nclass werkzeug.wsgi.ClosingIterator(iterable, callbacks=None)  \nThe WSGI specification requires that all middlewares and gateways respect the close callback of the iterable returned by the application. Because it is useful to add another close action to a returned iterable and adding a custom iterable is a boring task this class can be used for that: return ClosingIterator(app(environ, start_response), [cleanup_session,\n                                                      cleanup_locals])\n If there is just one close function it can be passed instead of the list. A closing iterator is not needed if the application uses response objects and finishes the processing if the response is started: try:\n    return response(environ, start_response)\nfinally:\n    cleanup_session()\n    cleanup_locals()\n  Parameters \n \niterable (Iterable[bytes]) \u2013  \ncallbacks (Optional[Union[Callable[[], None], Iterable[Callable[[], None]]]]) \u2013    Return type \nNone   \n  \nclass werkzeug.wsgi.FileWrapper(file, buffer_size=8192)  \nThis class can be used to convert a file-like object into an iterable. It yields buffer_size blocks until the file is fully read. You should not use this class directly but rather use the wrap_file() function that uses the WSGI server\u2019s file wrapper support if it\u2019s available.  Changelog New in version 0.5.  If you\u2019re using this object together with a Response you have to use the direct_passthrough mode.  Parameters \n \nfile (BinaryIO) \u2013 a file-like object with a read() method. \nbuffer_size (int) \u2013 number of bytes for one iteration.   Return type \nNone   \n  \nclass werkzeug.wsgi.LimitedStream(stream, limit)  \nWraps a stream so that it doesn\u2019t read more than n bytes. If the stream is exhausted and the caller tries to get more bytes from it on_exhausted() is called which by default returns an empty string. The return value of that function is forwarded to the reader function. So if it returns an empty string read() will return an empty string as well. The limit however must never be higher than what the stream can output. Otherwise readlines() will try to read past the limit.  Note on WSGI compliance calls to readline() and readlines() are not WSGI compliant because it passes a size argument to the readline methods. Unfortunately the WSGI PEP is not safely implementable without a size argument to readline() because there is no EOF marker in the stream. As a result of that the use of readline() is discouraged. For the same reason iterating over the LimitedStream is not portable. It internally calls readline(). We strongly suggest using read() only or using the make_line_iter() which safely iterates line-based over a WSGI input stream.   Parameters \n \nstream (BinaryIO) \u2013 the stream to wrap. \nlimit (int) \u2013 the limit for the stream, must not be longer than what the string can provide if the stream does not end with EOF (like wsgi.input)   Return type \nNone    \nexhaust(chunk_size=65536)  \nExhaust the stream. This consumes all the data left until the limit is reached.  Parameters \nchunk_size (int) \u2013 the size for a chunk. It will read the chunk until the stream is exhausted and throw away the results.  Return type \nNone   \n  \nproperty is_exhausted: bool  \nIf the stream is exhausted this attribute is True. \n  \non_disconnect()  \nWhat should happen if a disconnect is detected? The return value of this function is returned from read functions in case the client went away. By default a ClientDisconnected exception is raised.  Return type \nbytes   \n  \non_exhausted()  \nThis is called when the stream tries to read past the limit. The return value of this function is returned from the reading function.  Return type \nbytes   \n  \nread(size=None)  \nRead size bytes or if size is not provided everything is read.  Parameters \nsize (Optional[int]) \u2013 the number of bytes read.  Return type \nbytes   \n  \nreadable()  \nReturn whether object was opened for reading. If False, read() will raise OSError.  Return type \nbool   \n  \nreadline(size=None)  \nReads one line from the stream.  Parameters \nsize (Optional[int]) \u2013   Return type \nbytes   \n  \nreadlines(size=None)  \nReads a file into a list of strings. It calls readline() until the file is read to the end. It does support the optional size argument if the underlying stream supports it for readline.  Parameters \nsize (Optional[int]) \u2013   Return type \nList[bytes]   \n  \ntell()  \nReturns the position of the stream.  Changelog New in version 0.9.   Return type \nint   \n \n  \nwerkzeug.wsgi.make_line_iter(stream, limit=None, buffer_size=10240, cap_at_buffer=False)  \nSafely iterates line-based over an input stream. If the input stream is not a LimitedStream the limit parameter is mandatory. This uses the stream\u2019s read() method internally as opposite to the readline() method that is unsafe and can only be used in violation of the WSGI specification. The same problem applies to the __iter__ function of the input stream which calls readline() without arguments. If you need line-by-line processing it\u2019s strongly recommended to iterate over the input stream using this helper function.  Changelog New in version 0.11.10: added support for the cap_at_buffer parameter.   New in version 0.9: added support for iterators as input stream.   Changed in version 0.8: This function now ensures that the limit was reached.   Parameters \n \nstream (Union[Iterable[bytes], BinaryIO]) \u2013 the stream or iterate to iterate over. \nlimit (Optional[int]) \u2013 the limit in bytes for the stream. (Usually content length. Not necessary if the stream is a LimitedStream. \nbuffer_size (int) \u2013 The optional buffer size. \ncap_at_buffer (bool) \u2013 if this is set chunks are split if they are longer than the buffer size. Internally this is implemented that the buffer size might be exhausted by a factor of two however.   Return type \nIterator[bytes]   \n  \nwerkzeug.wsgi.make_chunk_iter(stream, separator, limit=None, buffer_size=10240, cap_at_buffer=False)  \nWorks like make_line_iter() but accepts a separator which divides chunks. If you want newline based processing you should use make_line_iter() instead as it supports arbitrary newline markers.  Changelog New in version 0.11.10: added support for the cap_at_buffer parameter.   New in version 0.9: added support for iterators as input stream.   New in version 0.8.   Parameters \n \nstream (Union[Iterable[bytes], BinaryIO]) \u2013 the stream or iterate to iterate over. \nseparator (bytes) \u2013 the separator that divides chunks. \nlimit (Optional[int]) \u2013 the limit in bytes for the stream. (Usually content length. Not necessary if the stream is otherwise already limited). \nbuffer_size (int) \u2013 The optional buffer size. \ncap_at_buffer (bool) \u2013 if this is set chunks are split if they are longer than the buffer size. Internally this is implemented that the buffer size might be exhausted by a factor of two however.   Return type \nIterator[bytes]   \n  \nwerkzeug.wsgi.wrap_file(environ, file, buffer_size=8192)  \nWraps a file. This uses the WSGI server\u2019s file wrapper if available or otherwise the generic FileWrapper.  Changelog New in version 0.5.  If the file wrapper from the WSGI server is used it\u2019s important to not iterate over it from inside the application but to pass it through unchanged. If you want to pass out a file wrapper inside a response object you have to set Response.direct_passthrough to True. More information about file wrappers are available in PEP 333.  Parameters \n \nfile (BinaryIO) \u2013 a file-like object with a read() method. \nbuffer_size (int) \u2013 number of bytes for one iteration. \nenviron (WSGIEnvironment) \u2013    Return type \nIterable[bytes]   \n   Environ Helpers These functions operate on the WSGI environment. They extract useful information or perform common manipulations:  \nwerkzeug.wsgi.get_host(environ, trusted_hosts=None)  \nReturn the host for the given WSGI environment. The Host header is preferred, then SERVER_NAME if it\u2019s not set. The returned host will only contain the port if it is different than the standard port for the protocol. Optionally, verify that the host is trusted using host_is_trusted() and raise a SecurityError if it is not.  Parameters \n \nenviron (WSGIEnvironment) \u2013 A WSGI environment dict. \ntrusted_hosts (Optional[Iterable[str]]) \u2013 A list of trusted host names.   Returns \nHost, with port if necessary.  Raises \nSecurityError \u2013 If the host is not trusted.  Return type \nstr   \n  \nwerkzeug.wsgi.get_content_length(environ)  \nReturns the content length from the WSGI environment as integer. If it\u2019s not available or chunked transfer encoding is used, None is returned.  Changelog New in version 0.9.   Parameters \nenviron (WSGIEnvironment) \u2013 the WSGI environ to fetch the content length from.  Return type \nOptional[int]   \n  \nwerkzeug.wsgi.get_input_stream(environ, safe_fallback=True)  \nReturns the input stream from the WSGI environment and wraps it in the most sensible way possible. The stream returned is not the raw WSGI stream in most cases but one that is safe to read from without taking into account the content length. If content length is not set, the stream will be empty for safety reasons. If the WSGI server supports chunked or infinite streams, it should set the wsgi.input_terminated value in the WSGI environ to indicate that.  Changelog New in version 0.9.   Parameters \n \nenviron (WSGIEnvironment) \u2013 the WSGI environ to fetch the stream from. \nsafe_fallback (bool) \u2013 use an empty stream as a safe fallback when the content length is not set. Disabling this allows infinite streams, which can be a denial-of-service risk.   Return type \nBinaryIO   \n  \nwerkzeug.wsgi.get_current_url(environ, root_only=False, strip_querystring=False, host_only=False, trusted_hosts=None)  \nRecreate the URL for a request from the parts in a WSGI environment. The URL is an IRI, not a URI, so it may contain Unicode characters. Use iri_to_uri() to convert it to ASCII.  Parameters \n \nenviron (WSGIEnvironment) \u2013 The WSGI environment to get the URL parts from. \nroot_only (bool) \u2013 Only build the root path, don\u2019t include the remaining path or query string. \nstrip_querystring (bool) \u2013 Don\u2019t include the query string. \nhost_only (bool) \u2013 Only build the scheme and host. \ntrusted_hosts (Optional[Iterable[str]]) \u2013 A list of trusted host names to validate the host against.   Return type \nstr   \n  \nwerkzeug.wsgi.get_query_string(environ)  \nReturns the QUERY_STRING from the WSGI environment. This also takes care of the WSGI decoding dance. The string returned will be restricted to ASCII characters.  Parameters \nenviron (WSGIEnvironment) \u2013 WSGI environment to get the query string from.  Return type \nstr    Changelog New in version 0.9.  \n\n  \nwerkzeug.wsgi.get_script_name(environ, charset='utf-8', errors='replace')  \nReturn the SCRIPT_NAME from the WSGI environment and decode it unless charset is set to None.  Parameters \n \nenviron (WSGIEnvironment) \u2013 WSGI environment to get the path from. \ncharset (str) \u2013 The charset for the path, or None if no decoding should be performed. \nerrors (str) \u2013 The decoding error handling.   Return type \nstr    Changelog New in version 0.9.  \n\n  \nwerkzeug.wsgi.get_path_info(environ, charset='utf-8', errors='replace')  \nReturn the PATH_INFO from the WSGI environment and decode it unless charset is None.  Parameters \n \nenviron (WSGIEnvironment) \u2013 WSGI environment to get the path from. \ncharset (str) \u2013 The charset for the path info, or None if no decoding should be performed. \nerrors (str) \u2013 The decoding error handling.   Return type \nstr    Changelog New in version 0.9.  \n\n  \nwerkzeug.wsgi.pop_path_info(environ, charset='utf-8', errors='replace')  \nRemoves and returns the next segment of PATH_INFO, pushing it onto SCRIPT_NAME. Returns None if there is nothing left on PATH_INFO. If the charset is set to None bytes are returned. If there are empty segments ('/foo//bar) these are ignored but properly pushed to the SCRIPT_NAME: >>> env = {'SCRIPT_NAME': '/foo', 'PATH_INFO': '/a/b'}\n>>> pop_path_info(env)\n'a'\n>>> env['SCRIPT_NAME']\n'/foo/a'\n>>> pop_path_info(env)\n'b'\n>>> env['SCRIPT_NAME']\n'/foo/a/b'\n  Changelog Changed in version 0.9: The path is now decoded and a charset and encoding parameter can be provided.   New in version 0.5.   Parameters \n \nenviron (WSGIEnvironment) \u2013 the WSGI environment that is modified. \ncharset (str) \u2013 The encoding parameter passed to bytes.decode(). \nerrors (str) \u2013 The errors paramater passed to bytes.decode().   Return type \nOptional[str]   \n  \nwerkzeug.wsgi.peek_path_info(environ, charset='utf-8', errors='replace')  \nReturns the next segment on the PATH_INFO or None if there is none. Works like pop_path_info() without modifying the environment: >>> env = {'SCRIPT_NAME': '/foo', 'PATH_INFO': '/a/b'}\n>>> peek_path_info(env)\n'a'\n>>> peek_path_info(env)\n'a'\n If the charset is set to None bytes are returned.  Changelog Changed in version 0.9: The path is now decoded and a charset and encoding parameter can be provided.   New in version 0.5.   Parameters \n \nenviron (WSGIEnvironment) \u2013 the WSGI environment that is checked. \ncharset (str) \u2013  \nerrors (str) \u2013    Return type \nOptional[str]   \n  \nwerkzeug.wsgi.extract_path_info(environ_or_baseurl, path_or_url, charset='utf-8', errors='werkzeug.url_quote', collapse_http_schemes=True)  \nExtracts the path info from the given URL (or WSGI environment) and path. The path info returned is a string. The URLs might also be IRIs. If the path info could not be determined, None is returned. Some examples: >>> extract_path_info('http://example.com/app', '/app/hello')\n'/hello'\n>>> extract_path_info('http://example.com/app',\n...                   'https://example.com/app/hello')\n'/hello'\n>>> extract_path_info('http://example.com/app',\n...                   'https://example.com/app/hello',\n...                   collapse_http_schemes=False) is None\nTrue\n Instead of providing a base URL you can also pass a WSGI environment.  Parameters \n \nenviron_or_baseurl (Union[str, WSGIEnvironment]) \u2013 a WSGI environment dict, a base URL or base IRI. This is the root of the application. \npath_or_url (Union[str, werkzeug.urls._URLTuple]) \u2013 an absolute path from the server root, a relative path (in which case it\u2019s the path info) or a full URL. \ncharset (str) \u2013 the charset for byte data in URLs \nerrors (str) \u2013 the error handling on decode \ncollapse_http_schemes (bool) \u2013 if set to False the algorithm does not assume that http and https on the same server point to the same resource.   Return type \nOptional[str]    Changelog Changed in version 0.15: The errors parameter defaults to leaving invalid bytes quoted instead of replacing them.   New in version 0.6.  \n\n  \nwerkzeug.wsgi.host_is_trusted(hostname, trusted_list)  \nCheck if a host matches a list of trusted names.  Parameters \n \nhostname (str) \u2013 The name to check. \ntrusted_list (Iterable[str]) \u2013 A list of valid names to match. If a name starts with a dot it will match all subdomains.   Return type \nbool    Changelog New in version 0.9.  \n\n   Convenience Helpers  \nwerkzeug.wsgi.responder(f)  \nMarks a function as responder. Decorate a function with it and it will automatically call the return value as WSGI application. Example: @responder\ndef application(environ, start_response):\n    return Response('Hello World!')\n  Parameters \nf (Callable[[...], WSGIApplication]) \u2013   Return type \nWSGIApplication   \n  \nwerkzeug.testapp.test_app(environ, start_response)  \nSimple test application that dumps the environment. You can use it to check if Werkzeug is working properly: >>> from werkzeug.serving import run_simple\n>>> from werkzeug.testapp import test_app\n>>> run_simple('localhost', 3000, test_app)\n * Running on http://localhost:3000/\n The application displays important information from the WSGI environment, the Python interpreter and the installed libraries.  Parameters \n \nenviron (WSGIEnvironment) \u2013  \nstart_response (StartResponse) \u2013    Return type \nIterable[bytes]   \n   Bytes, Strings, and Encodings The values in HTTP requests come in as bytes representing (or encoded to) ASCII. The WSGI specification (PEP 3333) decided to always use the str type to represent values. To accomplish this, the raw bytes are decoded using the ISO-8859-1 charset to produce a string. Strings in the WSGI environment are restricted to ISO-8859-1 code points. If a string read from the environment might contain characters outside that charset, it must first be decoded to bytes as ISO-8859-1, then encoded to a string using the proper charset (typically UTF-8). The reverse is done when writing to the environ. This is known as the \u201cWSGI encoding dance\u201d. Werkzeug provides functions to deal with this automatically so that you don\u2019t need to be aware of the inner workings. Use the functions on this page as well as EnvironHeaders() to read data out of the WSGI environment. Applications should avoid manually creating or modifying a WSGI environment unless they take care of the proper encoding or decoding step. All high level interfaces in Werkzeug will apply the encoding and decoding as necessary.   Raw Request URI and Path Encoding The PATH_INFO in the environ is the path value after percent-decoding. For example, the raw path /hello%2fworld would show up from the WSGI server to Werkzeug as /hello/world. This loses the information that the slash was a raw character as opposed to a path separator. The WSGI specification (PEP 3333) does not provide a way to get the original value, so it is impossible to route some types of data in the path. The most compatible way to work around this is to send problematic data in the query string instead of the path. However, many WSGI servers add a non-standard environ key with the raw path. To match this behavior, Werkzeug\u2019s test client and development server will add the raw value to both the REQUEST_URI and RAW_URI keys. If you want to route based on this value, you can use middleware to replace PATH_INFO in the environ before it reaches the application. However, keep in mind that these keys are non-standard and not guaranteed to be present. \n"}, {"name": "WSGI Protocol Linter", "path": "middleware/lint/index", "type": "Other", "text": "WSGI Protocol Linter This module provides a middleware that performs sanity checks on the behavior of the WSGI server and application. It checks that the PEP 3333 WSGI spec is properly implemented. It also warns on some common HTTP errors such as non-empty responses for 304 status codes.  \nclass werkzeug.middleware.lint.LintMiddleware(app)  \nWarns about common errors in the WSGI and HTTP behavior of the server and wrapped application. Some of the issues it checks are:  invalid status codes non-bytes sent to the WSGI server strings returned from the WSGI application non-empty conditional responses unquoted etags relative URLs in the Location header unsafe calls to wsgi.input unclosed iterators  Error information is emitted using the warnings module.  Parameters \napp (WSGIApplication) \u2013 The WSGI application to wrap.  Return type \nNone   from werkzeug.middleware.lint import LintMiddleware\napp = LintMiddleware(app)\n \n\n"}, {"name": "WWWAuthenticate", "path": "datastructures/index#werkzeug.datastructures.WWWAuthenticate", "type": "werkzeug.datastructures", "text": " \nclass werkzeug.datastructures.WWWAuthenticate(auth_type=None, values=None, on_update=None)  \nProvides simple access to WWW-Authenticate headers.  \nproperty algorithm  \nA string indicating a pair of algorithms used to produce the digest and a checksum. If this is not present it is assumed to be \u201cMD5\u201d. If the algorithm is not understood, the challenge should be ignored (and a different one used, if there is more than one). \n  \nstatic auth_property(name, doc=None)  \nA static helper function for Authentication subclasses to add extra authentication system properties onto a class: class FooAuthenticate(WWWAuthenticate):\n    special_realm = auth_property('special_realm')\n For more information have a look at the sourcecode to see how the regular properties (realm etc.) are implemented. \n  \nproperty domain  \nA list of URIs that define the protection space. If a URI is an absolute path, it is relative to the canonical root URL of the server being accessed. \n  \nproperty nonce  \nA server-specified data string which should be uniquely generated each time a 401 response is made. It is recommended that this string be base64 or hexadecimal data. \n  \nproperty opaque  \nA string of data, specified by the server, which should be returned by the client unchanged in the Authorization header of subsequent requests with URIs in the same protection space. It is recommended that this string be base64 or hexadecimal data. \n  \nproperty qop  \nA set of quality-of-privacy directives such as auth and auth-int. \n  \nproperty realm  \nA string to be displayed to users so they know which username and password to use. This string should contain at least the name of the host performing the authentication and might additionally indicate the collection of users who might have access. \n  \nset_basic(realm='authentication required')  \nClear the auth info and enable basic auth. \n  \nset_digest(realm, nonce, qop=('auth'), opaque=None, algorithm=None, stale=False)  \nClear the auth info and enable digest auth. \n  \nproperty stale  \nA flag, indicating that the previous request from the client was rejected because the nonce value was stale. \n  \nto_header()  \nConvert the stored values into a WWW-Authenticate header. \n  \nproperty type  \nThe type of the auth mechanism. HTTP currently specifies Basic and Digest. \n \n"}, {"name": "WWWAuthenticate.auth_property()", "path": "datastructures/index#werkzeug.datastructures.WWWAuthenticate.auth_property", "type": "werkzeug.datastructures", "text": " \nstatic auth_property(name, doc=None)  \nA static helper function for Authentication subclasses to add extra authentication system properties onto a class: class FooAuthenticate(WWWAuthenticate):\n    special_realm = auth_property('special_realm')\n For more information have a look at the sourcecode to see how the regular properties (realm etc.) are implemented. \n"}, {"name": "WWWAuthenticate.set_basic()", "path": "datastructures/index#werkzeug.datastructures.WWWAuthenticate.set_basic", "type": "werkzeug.datastructures", "text": " \nset_basic(realm='authentication required')  \nClear the auth info and enable basic auth. \n"}, {"name": "WWWAuthenticate.set_digest()", "path": "datastructures/index#werkzeug.datastructures.WWWAuthenticate.set_digest", "type": "werkzeug.datastructures", "text": " \nset_digest(realm, nonce, qop=('auth'), opaque=None, algorithm=None, stale=False)  \nClear the auth info and enable digest auth. \n"}, {"name": "WWWAuthenticate.to_header()", "path": "datastructures/index#werkzeug.datastructures.WWWAuthenticate.to_header", "type": "werkzeug.datastructures", "text": " \nto_header()  \nConvert the stored values into a WWW-Authenticate header. \n"}, {"name": "X-Forwarded-For Proxy Fix", "path": "middleware/proxy_fix/index", "type": "Other", "text": "X-Forwarded-For Proxy Fix This module provides a middleware that adjusts the WSGI environ based on X-Forwarded- headers that proxies in front of an application may set. When an application is running behind a proxy server, WSGI may see the request as coming from that server rather than the real client. Proxies set various headers to track where the request actually came from. This middleware should only be used if the application is actually behind such a proxy, and should be configured with the number of proxies that are chained in front of it. Not all proxies set all the headers. Since incoming headers can be faked, you must set how many proxies are setting each header so the middleware knows what to trust.  \nclass werkzeug.middleware.proxy_fix.ProxyFix(app, x_for=1, x_proto=1, x_host=0, x_port=0, x_prefix=0)  \nAdjust the WSGI environ based on X-Forwarded- that proxies in front of the application may set.  \nX-Forwarded-For sets REMOTE_ADDR. \nX-Forwarded-Proto sets wsgi.url_scheme. \nX-Forwarded-Host sets HTTP_HOST, SERVER_NAME, and SERVER_PORT. \nX-Forwarded-Port sets HTTP_HOST and SERVER_PORT. \nX-Forwarded-Prefix sets SCRIPT_NAME.  You must tell the middleware how many proxies set each header so it knows what values to trust. It is a security issue to trust values that came from the client rather than a proxy. The original values of the headers are stored in the WSGI environ as werkzeug.proxy_fix.orig, a dict.  Parameters \n \napp (WSGIApplication) \u2013 The WSGI application to wrap. \nx_for (int) \u2013 Number of values to trust for X-Forwarded-For. \nx_proto (int) \u2013 Number of values to trust for X-Forwarded-Proto. \nx_host (int) \u2013 Number of values to trust for X-Forwarded-Host. \nx_port (int) \u2013 Number of values to trust for X-Forwarded-Port. \nx_prefix (int) \u2013 Number of values to trust for X-Forwarded-Prefix.   Return type \nNone   from werkzeug.middleware.proxy_fix import ProxyFix\n# App is behind one proxy that sets the -For and -Host headers.\napp = ProxyFix(app, x_for=1, x_host=1)\n  Changelog Changed in version 1.0: Deprecated code has been removed:  The num_proxies argument and attribute. The get_remote_addr method. The environ keys orig_remote_addr, orig_wsgi_url_scheme, and orig_http_host.    Changed in version 0.15: All headers support multiple values. The num_proxies argument is deprecated. Each header is configured with a separate number of trusted proxies.   Changed in version 0.15: Original WSGI environ values are stored in the werkzeug.proxy_fix.orig dict. orig_remote_addr, orig_wsgi_url_scheme, and orig_http_host are deprecated and will be removed in 1.0.   Changed in version 0.15: Support X-Forwarded-Port and X-Forwarded-Prefix.   Changed in version 0.15: X-Forwarded-Host and X-Forwarded-Port modify SERVER_NAME and SERVER_PORT.  \n\n\n"}]