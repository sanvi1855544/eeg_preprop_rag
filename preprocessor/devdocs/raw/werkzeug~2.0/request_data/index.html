<h1>Dealing with Request Data</h1> <p>The most important rule about web development is “Do not trust the user”. This is especially true for incoming request data on the input stream. With WSGI this is actually a bit harder than you would expect. Because of that Werkzeug wraps the request stream for you to save you from the most prominent problems with it.</p> <section id="missing-eof-marker-on-input-stream"> <h2>Missing EOF Marker on Input Stream</h2> <p>The input stream has no end-of-file marker. If you would call the <code>read()</code> method on the <code>wsgi.input</code> stream you would cause your application to hang on conforming servers. This is actually intentional however painful. Werkzeug solves that problem by wrapping the input stream in a special <code>LimitedStream</code>. The input stream is exposed on the request objects as <code>stream</code>. This one is either an empty stream (if the form data was parsed) or a limited stream with the contents of the input stream.</p> </section> <section id="when-does-werkzeug-parse"> <h2>When does Werkzeug Parse?</h2> <p>Werkzeug parses the incoming data under the following situations:</p> <ul class="simple"> <li>you access either <code>form</code>, <code>files</code>, or <code>stream</code> and the request method was <code>POST</code> or <code>PUT</code>.</li> <li>if you call <code>parse_form_data()</code>.</li> </ul> <p>These calls are not interchangeable. If you invoke <code>parse_form_data()</code> you must not use the request object or at least not the attributes that trigger the parsing process.</p> <p>This is also true if you read from the <code>wsgi.input</code> stream before the parsing.</p> <p><strong>General rule:</strong> Leave the WSGI input stream alone. Especially in WSGI middlewares. Use either the parsing functions or the request object. Do not mix multiple WSGI utility libraries for form data parsing or anything else that works on the input stream.</p> </section> <section id="how-does-it-parse"> <h2>How does it Parse?</h2> <p>The standard Werkzeug parsing behavior handles three cases:</p> <ul class="simple"> <li>input content type was <code>multipart/form-data</code>. In this situation the <code>stream</code> will be empty and <code>form</code> will contain the regular <code>POST</code> / <code>PUT</code> data, <code>files</code> will contain the uploaded files as <code>FileStorage</code> objects.</li> <li>input content type was <code>application/x-www-form-urlencoded</code>. Then the <code>stream</code> will be empty and <code>form</code> will contain the regular <code>POST</code> / <code>PUT</code> data and <code>files</code> will be empty.</li> <li>the input content type was neither of them, <code>stream</code> points to a <code>LimitedStream</code> with the input data for further processing.</li> </ul> <p>Special note on the <code>get_data</code> method: Calling this loads the full request data into memory. This is only safe to do if the <code>max_content_length</code> is set. Also you can <em>either</em> read the stream <em>or</em> call <code>get_data()</code>.</p> </section> <section id="limiting-request-data"> <h2>Limiting Request Data</h2> <p>To avoid being the victim of a DDOS attack you can set the maximum accepted content length and request field sizes. The <code>Request</code> class has two attributes for that: <code>max_content_length</code> and <code>max_form_memory_size</code>.</p> <p>The first one can be used to limit the total content length. For example by setting it to <code>1024 * 1024 * 16</code> the request won’t accept more than 16MB of transmitted data.</p> <p>Because certain data can’t be moved to the hard disk (regular post data) whereas temporary files can, there is a second limit you can set. The <code>max_form_memory_size</code> limits the size of <code>POST</code> transmitted form data. By setting it to <code>1024 * 1024 * 2</code> you can make sure that all in memory-stored fields are not more than 2MB in size.</p> <p>This however does <em>not</em> affect in-memory stored files if the <code>stream_factory</code> used returns a in-memory file.</p> </section> <section id="how-to-extend-parsing"> <h2>How to extend Parsing?</h2> <p>Modern web applications transmit a lot more than multipart form data or url encoded data. To extend the capabilities, subclass <code>Request</code> or <code>Request</code> and add or extend methods.</p> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2007&ndash;2021 Pallets<br>Licensed under the BSD 3-clause License.<br>
    <a href="https://werkzeug.palletsprojects.com/en/2.0.x/request_data/" class="_attribution-link">https://werkzeug.palletsprojects.com/en/2.0.x/request_data/</a>
  </p>
</div>
