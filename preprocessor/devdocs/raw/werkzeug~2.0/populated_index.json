[{"name": "abort()", "path": "exceptions/index#werkzeug.exceptions.abort", "type": "werkzeug.exceptions", "text": "\nRaises an `HTTPException` for the given status code or WSGI application.\n\nIf a status code is given, it will be looked up in the list of exceptions and\nwill raise that exception. If passed a WSGI application, it will wrap it in a\nproxy WSGI exception and raise that:\n\nNoReturn\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Aborter", "path": "exceptions/index#werkzeug.exceptions.Aborter", "type": "werkzeug.exceptions", "text": "\nWhen passed a dict of code -> exception items it can be used as callable that\nraises exceptions. If the first argument to the callable is an integer it will\nbe looked up in the mapping, if it\u2019s a WSGI application it will be raised in a\nproxy exception.\n\nThe rest of the arguments are forwarded to the exception constructor.\n\nNone\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Accept", "path": "datastructures/index#werkzeug.datastructures.Accept", "type": "werkzeug.datastructures", "text": "\nAn `Accept` object is just a list subclass for lists of `(value, quality)`\ntuples. It is automatically sorted by specificity and quality.\n\nAll `Accept` objects work similar to a list but provide extra functionality\nfor working with the data. Containment checks are normalized to the rules of\nthat header:\n\nTo get the quality for an item you can use normal item lookup:\n\nChanged in version 1.0.0: `Accept` internal values are no longer ordered\nalphabetically for equal quality tags. Instead the initial order is preserved.\n\nChanged in version 0.5: `Accept` objects are forced immutable now.\n\nThe best match as value.\n\nReturns the best match from a list of possible matches based on the\nspecificity and quality of the client. If two items have the same quality and\nspecificity, the one is returned that comes first.\n\nGet the position of an entry or return -1.\n\nkey \u2013 The key to be looked up.\n\nGet the position of an entry or raise `ValueError`.\n\nkey \u2013 The key to be looked up.\n\nChanged in version 0.5: This used to raise `IndexError`, which was\ninconsistent with the list API.\n\nReturns the quality of the key.\n\nNew in version 0.6: In previous versions you had to use the item-lookup syntax\n(eg: `obj[key]` instead of `obj.quality(key)`)\n\nConvert the header set into an HTTP header string.\n\nIterate over all values.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Accept.best_match()", "path": "datastructures/index#werkzeug.datastructures.Accept.best_match", "type": "werkzeug.datastructures", "text": "\nReturns the best match from a list of possible matches based on the\nspecificity and quality of the client. If two items have the same quality and\nspecificity, the one is returned that comes first.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Accept.find()", "path": "datastructures/index#werkzeug.datastructures.Accept.find", "type": "werkzeug.datastructures", "text": "\nGet the position of an entry or return -1.\n\nkey \u2013 The key to be looked up.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Accept.index()", "path": "datastructures/index#werkzeug.datastructures.Accept.index", "type": "werkzeug.datastructures", "text": "\nGet the position of an entry or raise `ValueError`.\n\nkey \u2013 The key to be looked up.\n\nChanged in version 0.5: This used to raise `IndexError`, which was\ninconsistent with the list API.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Accept.quality()", "path": "datastructures/index#werkzeug.datastructures.Accept.quality", "type": "werkzeug.datastructures", "text": "\nReturns the quality of the key.\n\nNew in version 0.6: In previous versions you had to use the item-lookup syntax\n(eg: `obj[key]` instead of `obj.quality(key)`)\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Accept.to_header()", "path": "datastructures/index#werkzeug.datastructures.Accept.to_header", "type": "werkzeug.datastructures", "text": "\nConvert the header set into an HTTP header string.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Accept.values()", "path": "datastructures/index#werkzeug.datastructures.Accept.values", "type": "werkzeug.datastructures", "text": "\nIterate over all values.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "AnyConverter", "path": "routing/index#werkzeug.routing.AnyConverter", "type": "werkzeug.routing", "text": "\nMatches one of the items provided. Items can either be Python identifiers or\nstrings:\n\nNone\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "API Levels", "path": "levels/index", "type": "Other", "text": "\nWerkzeug is intended to be a utility rather than a framework. Because of that\nthe user-friendly API is separated from the lower-level API so that Werkzeug\ncan easily be used to extend another system.\n\nAll the functionality the `Request` and `Response` objects (aka the\n\u201cwrappers\u201d) provide is also available in small utility functions.\n\nThis example implements a small `Hello World` application that greets the user\nwith the name entered.\n\nAlternatively the same application could be used without request and response\nobjects but by taking advantage of the parsing functions werkzeug provides:\n\nUsually you want to use the high-level layer (the request and response\nobjects). But there are situations where this might not be what you want.\n\nFor example you might be maintaining code for an application written in Django\nor another framework and you have to parse HTTP headers. You can utilize\nWerkzeug for that by accessing the lower-level HTTP header parsing functions.\n\nAnother situation where the low level parsing functions can be useful are\ncustom WSGI frameworks, unit-testing or modernizing an old CGI/mod_python\napplication to WSGI as well as WSGI middlewares where you want to keep the\noverhead low.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "append_slash_redirect()", "path": "utils/index#werkzeug.utils.append_slash_redirect", "type": "werkzeug.utils", "text": "\nRedirects to the same URL but with a slash appended. The behavior of this\nfunction is undefined if the path ends with a slash already.\n\nResponse\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Application Deployment", "path": "deployment/index", "type": "Other", "text": "\nThis section covers running your application in production on a web server\nsuch as Apache or lighttpd.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Application Dispatcher", "path": "middleware/dispatcher/index", "type": "Other", "text": "\nThis middleware creates a single WSGI application that dispatches to multiple\nother WSGI applications mounted at different URL paths.\n\nA common example is writing a Single Page Application, where you have a\nbackend API and a frontend written in JavaScript that does the routing in the\nbrowser rather than requesting different pages from the server. The frontend\nis a single HTML and JS file that should be served for any path besides\n\u201c/api\u201d.\n\nThis example dispatches to an API app under \u201c/api\u201d, an admin app under\n\u201c/admin\u201d, and an app that serves frontend files for all other requests:\n\nIn production, you might instead handle this at the HTTP server level, serving\nfiles or proxying to application servers based on location. The API and admin\napps would each be deployed with a separate WSGI server, and the static files\nwould be served directly by the HTTP server.\n\nCombine multiple applications as a single WSGI application. Requests are\ndispatched to an application based on the path it is mounted under.\n\nNone\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Application Profiler", "path": "middleware/profiler/index", "type": "Other", "text": "\nThis module provides a middleware that profiles each request with the\n`cProfile` module. This can help identify bottlenecks in your code that may be\nslowing down your application.\n\nWrap a WSGI application and profile the execution of each request. Responses\nare buffered so that timings are more exact.\n\nIf `stream` is given, `pstats.Stats` are written to it after each request. If\n`profile_dir` is given, `cProfile` data files are saved to that directory, one\nfile per request.\n\nThe filename can be customized by passing `filename_format`. If it is a\nstring, it will be formatted using `str.format()` with the following fields\navailable:\n\nIf it is a callable, it will be called with the WSGI `environ` dict and should\nreturn a filename.\n\nNone\n\nChanged in version 0.15: Stats are written even if `profile_dir` is given, and\ncan be disable by passing `stream=None`.\n\nNew in version 0.15: Added `filename_format`.\n\nNew in version 0.9: Added `restrictions` and `profile_dir`.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Authorization", "path": "datastructures/index#werkzeug.datastructures.Authorization", "type": "werkzeug.datastructures", "text": "\nRepresents an `Authorization` header sent by the client.\n\nThis is returned by `parse_authorization_header()`. It can be useful to create\nthe object manually to pass to the test `Client`.\n\nChanged in version 0.5: This object became immutable.\n\nIf the server sent a qop-header in the `WWW-Authenticate` header, the client\nhas to provide this value for HTTP digest auth. See the RFC for more details.\n\nThe nonce count value transmitted by clients if a qop-header is also\ntransmitted. HTTP digest auth only.\n\nThe nonce the server sent for digest auth, sent back by the client. A nonce\nshould be unique for every 401 response for HTTP digest auth.\n\nThe opaque header from the server returned unchanged by the client. It is\nrecommended that this string be base64 or hexadecimal data. Digest auth only.\n\nWhen the authentication type is basic this is the password transmitted by the\nclient, else `None`.\n\nIndicates what \u201cquality of protection\u201d the client has applied to the message\nfor HTTP digest auth. Note that this is a single token, not a quoted list of\nalternatives as in WWW-Authenticate.\n\nThis is the server realm sent back for HTTP digest auth.\n\nA string of 32 hex digits computed as defined in RFC 2617, which proves that\nthe user knows a password. Digest auth only.\n\nConvert to a string value for an `Authorization` header.\n\nNew in version 2.0: Added to support passing authorization to the test client.\n\nThe URI from Request-URI of the Request-Line; duplicated because proxies are\nallowed to change the Request-Line in transit. HTTP digest auth only.\n\nThe username transmitted. This is set for both basic and digest auth all the\ntime.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Authorization.to_header()", "path": "datastructures/index#werkzeug.datastructures.Authorization.to_header", "type": "werkzeug.datastructures", "text": "\nConvert to a string value for an `Authorization` header.\n\nNew in version 2.0: Added to support passing authorization to the test client.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "BaseURL", "path": "urls/index#werkzeug.urls.BaseURL", "type": "werkzeug.urls", "text": "\nSuperclass of `URL` and `BytesURL`.\n\nCreate new instance of _URLTuple(scheme, netloc, path, query, fragment)\n\nWorks exactly like `host` but will return a result that is restricted to\nASCII. If it finds a netloc that is not ASCII it will attempt to idna decode\nit. This is useful for socket operations when the URL might include\ninternationalized characters.\n\nThe authentication part in the URL if available, `None` otherwise.\n\nDecodes the netloc part into a string.\n\nstr\n\nDecodes the query part of the URL. Ths is a shortcut for calling\n`url_decode()` on the query argument. The arguments and keyword arguments are\nforwarded to `url_decode()` unchanged.\n\nds.MultiDict[str, str]\n\nEncodes the netloc part to an ASCII safe URL as bytes.\n\nstr\n\nReturns a tuple with the location of the file in the form `(server,\nlocation)`. If the netloc is empty in the URL or points to localhost, it\u2019s\nrepresented as `None`.\n\nThe `pathformat` by default is autodetection but needs to be set when working\nwith URLs of a specific system. The supported values are `'windows'` when\nworking with Windows or DOS paths and `'posix'` when working with posix paths.\n\nIf the URL does not point to a local file, the server and location are both\nrepresented as `None`.\n\npathformat (Optional[str]) \u2013 The expected format of the path component.\nCurrently `'windows'` and `'posix'` are supported. Defaults to `None` which is\nautodetect.\n\nTuple[Optional[str], Optional[str]]\n\nThe host part of the URL if available, otherwise `None`. The host is either\nthe hostname or the IP address mentioned in the URL. It will not contain the\nport.\n\nJoins this URL with another one. This is just a convenience function for\ncalling into `url_join()` and then parsing the return value again.\n\nwerkzeug.urls.BaseURL\n\nThe password if it was part of the URL, `None` otherwise. This undergoes URL\ndecoding and will always be a string.\n\nThe port in the URL as an integer if it was present, `None` otherwise. This\ndoes not fill in default ports.\n\nThe password if it was part of the URL, `None` otherwise. Unlike `password`\nthis one is not being decoded.\n\nThe username if it was part of the URL, `None` otherwise. Unlike `username`\nthis one is not being decoded.\n\nReturn an URL with the same values, except for those parameters given new\nvalues by whichever keyword arguments are specified.\n\nkwargs (Any) \u2013\n\nwerkzeug.urls.BaseURL\n\nReturns a `URL` tuple that holds a IRI. This will try to decode as much\ninformation as possible in the URL without losing information similar to how a\nweb browser does it for the URL bar.\n\nIt\u2019s usually more interesting to directly call `uri_to_iri()` which will\nreturn a string.\n\nwerkzeug.urls.BaseURL\n\nReturns a `BytesURL` tuple that holds a URI. This will encode all the\ninformation in the URL properly to ASCII using the rules a web browser would\nfollow.\n\nIt\u2019s usually more interesting to directly call `iri_to_uri()` which will\nreturn a string.\n\nwerkzeug.urls.BaseURL\n\nReturns a URL string or bytes depending on the type of the information stored.\nThis is just a convenience function for calling `url_unparse()` for this URL.\n\nstr\n\nThe username if it was part of the URL, `None` otherwise. This undergoes URL\ndecoding and will always be a string.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "BaseURL.decode_netloc()", "path": "urls/index#werkzeug.urls.BaseURL.decode_netloc", "type": "werkzeug.urls", "text": "\nDecodes the netloc part into a string.\n\nstr\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "BaseURL.decode_query()", "path": "urls/index#werkzeug.urls.BaseURL.decode_query", "type": "werkzeug.urls", "text": "\nDecodes the query part of the URL. Ths is a shortcut for calling\n`url_decode()` on the query argument. The arguments and keyword arguments are\nforwarded to `url_decode()` unchanged.\n\nds.MultiDict[str, str]\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "BaseURL.encode_netloc()", "path": "urls/index#werkzeug.urls.BaseURL.encode_netloc", "type": "werkzeug.urls", "text": "\nEncodes the netloc part to an ASCII safe URL as bytes.\n\nstr\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "BaseURL.get_file_location()", "path": "urls/index#werkzeug.urls.BaseURL.get_file_location", "type": "werkzeug.urls", "text": "\nReturns a tuple with the location of the file in the form `(server,\nlocation)`. If the netloc is empty in the URL or points to localhost, it\u2019s\nrepresented as `None`.\n\nThe `pathformat` by default is autodetection but needs to be set when working\nwith URLs of a specific system. The supported values are `'windows'` when\nworking with Windows or DOS paths and `'posix'` when working with posix paths.\n\nIf the URL does not point to a local file, the server and location are both\nrepresented as `None`.\n\npathformat (Optional[str]) \u2013 The expected format of the path component.\nCurrently `'windows'` and `'posix'` are supported. Defaults to `None` which is\nautodetect.\n\nTuple[Optional[str], Optional[str]]\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "BaseURL.join()", "path": "urls/index#werkzeug.urls.BaseURL.join", "type": "werkzeug.urls", "text": "\nJoins this URL with another one. This is just a convenience function for\ncalling into `url_join()` and then parsing the return value again.\n\nwerkzeug.urls.BaseURL\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "BaseURL.replace()", "path": "urls/index#werkzeug.urls.BaseURL.replace", "type": "werkzeug.urls", "text": "\nReturn an URL with the same values, except for those parameters given new\nvalues by whichever keyword arguments are specified.\n\nkwargs (Any) \u2013\n\nwerkzeug.urls.BaseURL\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "BaseURL.to_iri_tuple()", "path": "urls/index#werkzeug.urls.BaseURL.to_iri_tuple", "type": "werkzeug.urls", "text": "\nReturns a `URL` tuple that holds a IRI. This will try to decode as much\ninformation as possible in the URL without losing information similar to how a\nweb browser does it for the URL bar.\n\nIt\u2019s usually more interesting to directly call `uri_to_iri()` which will\nreturn a string.\n\nwerkzeug.urls.BaseURL\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "BaseURL.to_uri_tuple()", "path": "urls/index#werkzeug.urls.BaseURL.to_uri_tuple", "type": "werkzeug.urls", "text": "\nReturns a `BytesURL` tuple that holds a URI. This will encode all the\ninformation in the URL properly to ASCII using the rules a web browser would\nfollow.\n\nIt\u2019s usually more interesting to directly call `iri_to_uri()` which will\nreturn a string.\n\nwerkzeug.urls.BaseURL\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "BaseURL.to_url()", "path": "urls/index#werkzeug.urls.BaseURL.to_url", "type": "werkzeug.urls", "text": "\nReturns a URL string or bytes depending on the type of the information stored.\nThis is just a convenience function for calling `url_unparse()` for this URL.\n\nstr\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Basic HTTP Proxy", "path": "middleware/http_proxy/index", "type": "Other", "text": "\nProxy requests under a path to an external server, routing other requests to\nthe app.\n\nThis middleware can only proxy HTTP requests, as HTTP is the only protocol\nhandled by the WSGI server. Other protocols, such as WebSocket requests,\ncannot be proxied at this layer. This should only be used for development, in\nproduction a real proxy server should be used.\n\nThe middleware takes a dict mapping a path prefix to a dict describing the\nhost to be proxied to:\n\nEach host has the following options:\n\nThe target URL to dispatch to. This is required.\n\nWhether to remove the prefix from the URL before dispatching it to the target.\nThe default is `False`.\n\nThe host header is automatically rewritten to the URL of the target.\n\nThe host header is unmodified from the client request.\n\nThe host header is overwritten with the value.\n\nA dictionary of headers to be sent with the request to the target. The default\nis `{}`.\n\nA `ssl.SSLContext` defining how to verify requests if the target is HTTPS. The\ndefault is `None`.\n\nIn the example above, everything under `\"/static/\"` is proxied to the server\non port 5001. The host header is rewritten to the target, and the `\"/static/\"`\nprefix is removed from the URLs.\n\nNone\n\nNew in version 0.14.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "bind_arguments()", "path": "utils/index#werkzeug.utils.bind_arguments", "type": "werkzeug.utils", "text": "\nBind the arguments provided into a dict. When passed a function, a tuple of\narguments and a dict of keyword arguments `bind_arguments` returns a dict of\nnames as the function would see it. This can be useful to implement a cache\ndecorator that uses the function arguments to build the cache key based on the\nvalues of the arguments.\n\na `dict` of bound keyword arguments.\n\nDeprecated since version 2.0: Will be removed in Werkzeug 2.1. Use\n`Signature.bind()` instead.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "BrokenFilesystemWarning", "path": "filesystem/index#werkzeug.filesystem.BrokenFilesystemWarning", "type": "werkzeug.filesystem", "text": "\nThe warning used by Werkzeug to signal a broken filesystem. Will only be used\nonce per runtime.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "BSD-3-Clause License", "path": "license/index", "type": "Other", "text": "\nCopyright 2007 Pallets\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \u201cAS IS\u201d\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\nFOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\nSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\nCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\nOR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "BytesURL", "path": "urls/index#werkzeug.urls.BytesURL", "type": "werkzeug.urls", "text": "\nRepresents a parsed URL in bytes.\n\nCreate new instance of _URLTuple(scheme, netloc, path, query, fragment)\n\nDecodes the URL to a tuple made out of strings. The charset is only being used\nfor the path, query and fragment.\n\nwerkzeug.urls.URL\n\nReturns the netloc unchanged as bytes.\n\nbytes\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "BytesURL.decode()", "path": "urls/index#werkzeug.urls.BytesURL.decode", "type": "werkzeug.urls", "text": "\nDecodes the URL to a tuple made out of strings. The charset is only being used\nfor the path, query and fragment.\n\nwerkzeug.urls.URL\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "BytesURL.encode_netloc()", "path": "urls/index#werkzeug.urls.BytesURL.encode_netloc", "type": "werkzeug.urls", "text": "\nReturns the netloc unchanged as bytes.\n\nbytes\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "cached_property", "path": "utils/index#werkzeug.utils.cached_property", "type": "werkzeug.utils", "text": "\nA `property()` that is only evaluated once. Subsequent access returns the\ncached value. Setting the property sets the cached value. Deleting the\nproperty clears the cached value, accessing it again will evaluate it again.\n\nThe class must have a `__dict__` for this to work.\n\nChanged in version 2.0: `del obj.name` clears the cached value.\n\nNone\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "CGI", "path": "deployment/cgi/index", "type": "Other", "text": "\nIf all other deployment methods do not work, CGI will work for sure. CGI is\nsupported by all major servers but usually has a less-than-optimal\nperformance.\n\nThis is also the way you can use a Werkzeug application on Google\u2019s AppEngine,\nthere however the execution does happen in a CGI-like environment. The\napplication\u2019s performance is unaffected because of that.\n\nFirst you need to create the CGI application file. Let\u2019s call it\n`yourapplication.cgi`:\n\nUsually there are two ways to configure the server. Either just copy the\n`.cgi` into a `cgi-bin` (and use `mod_rewrite` or something similar to rewrite\nthe URL) or let the server point to the file directly.\n\nIn Apache for example you can put something like this into the config:\n\nFor more information consult the documentation of your webserver.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "CharsetAccept", "path": "datastructures/index#werkzeug.datastructures.CharsetAccept", "type": "werkzeug.datastructures", "text": "\nLike `Accept` but with normalization for charsets.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "check_password_hash()", "path": "utils/index#werkzeug.security.check_password_hash", "type": "werkzeug.security", "text": "\nCheck a password against a given salted and hashed password value. In order to\nsupport unsalted legacy passwords this method supports plain text passwords,\nmd5 and sha1 hashes (both salted and unsalted).\n\nReturns `True` if the password matched, `False` otherwise.\n\nbool\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Client", "path": "test/index#werkzeug.test.Client", "type": "werkzeug.test", "text": "\nThis class allows you to send requests to a wrapped application.\n\nThe use_cookies parameter indicates whether cookies should be stored and sent\nfor subsequent requests. This is True by default, but passing False will\ndisable this behaviour.\n\nIf you want to request some subdomain of your application you may set\n`allow_subdomain_redirects` to `True` as if not no external redirects are\nallowed.\n\nChanged in version 2.0: `response_wrapper` is always a subclass of\n:class:`TestResponse`.\n\nChanged in version 0.5: Added the `use_cookies` parameter.\n\nNone\n\nSets a cookie in the client\u2019s cookie jar. The server name is required and has\nto match the one that is also passed to the open call.\n\nNone\n\nDeletes a cookie in the test client.\n\nNone\n\nGenerate an environ dict from the given arguments, make a request to the\napplication using it, and return the response.\n\nwerkzeug.test.TestResponse\n\nChanged in version 2.0: `as_tuple` is deprecated and will be removed in\nWerkzeug 2.1. Use `TestResponse.request` and `request.environ` instead.\n\nChanged in version 2.0: The request input stream is closed when calling\n`response.close()`. Input streams for redirects are automatically closed.\n\nChanged in version 0.5: If a dict is provided as file in the dict for the\n`data` parameter the content type has to be called `content_type` instead of\n`mimetype`. This change was made for consistency with `werkzeug.FileWrapper`.\n\nChanged in version 0.5: Added the `follow_redirects` parameter.\n\nCall `open()` with `method` set to `GET`.\n\nwerkzeug.test.TestResponse\n\nCall `open()` with `method` set to `POST`.\n\nwerkzeug.test.TestResponse\n\nCall `open()` with `method` set to `PUT`.\n\nwerkzeug.test.TestResponse\n\nCall `open()` with `method` set to `DELETE`.\n\nwerkzeug.test.TestResponse\n\nCall `open()` with `method` set to `PATCH`.\n\nwerkzeug.test.TestResponse\n\nCall `open()` with `method` set to `OPTIONS`.\n\nwerkzeug.test.TestResponse\n\nCall `open()` with `method` set to `HEAD`.\n\nwerkzeug.test.TestResponse\n\nCall `open()` with `method` set to `TRACE`.\n\nwerkzeug.test.TestResponse\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Client.delete()", "path": "test/index#werkzeug.test.Client.delete", "type": "werkzeug.test", "text": "\nCall `open()` with `method` set to `DELETE`.\n\nwerkzeug.test.TestResponse\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Client.delete_cookie()", "path": "test/index#werkzeug.test.Client.delete_cookie", "type": "werkzeug.test", "text": "\nDeletes a cookie in the test client.\n\nNone\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Client.get()", "path": "test/index#werkzeug.test.Client.get", "type": "werkzeug.test", "text": "\nCall `open()` with `method` set to `GET`.\n\nwerkzeug.test.TestResponse\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Client.head()", "path": "test/index#werkzeug.test.Client.head", "type": "werkzeug.test", "text": "\nCall `open()` with `method` set to `HEAD`.\n\nwerkzeug.test.TestResponse\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Client.open()", "path": "test/index#werkzeug.test.Client.open", "type": "werkzeug.test", "text": "\nGenerate an environ dict from the given arguments, make a request to the\napplication using it, and return the response.\n\nwerkzeug.test.TestResponse\n\nChanged in version 2.0: `as_tuple` is deprecated and will be removed in\nWerkzeug 2.1. Use `TestResponse.request` and `request.environ` instead.\n\nChanged in version 2.0: The request input stream is closed when calling\n`response.close()`. Input streams for redirects are automatically closed.\n\nChanged in version 0.5: If a dict is provided as file in the dict for the\n`data` parameter the content type has to be called `content_type` instead of\n`mimetype`. This change was made for consistency with `werkzeug.FileWrapper`.\n\nChanged in version 0.5: Added the `follow_redirects` parameter.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Client.options()", "path": "test/index#werkzeug.test.Client.options", "type": "werkzeug.test", "text": "\nCall `open()` with `method` set to `OPTIONS`.\n\nwerkzeug.test.TestResponse\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Client.patch()", "path": "test/index#werkzeug.test.Client.patch", "type": "werkzeug.test", "text": "\nCall `open()` with `method` set to `PATCH`.\n\nwerkzeug.test.TestResponse\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Client.post()", "path": "test/index#werkzeug.test.Client.post", "type": "werkzeug.test", "text": "\nCall `open()` with `method` set to `POST`.\n\nwerkzeug.test.TestResponse\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Client.put()", "path": "test/index#werkzeug.test.Client.put", "type": "werkzeug.test", "text": "\nCall `open()` with `method` set to `PUT`.\n\nwerkzeug.test.TestResponse\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Client.set_cookie()", "path": "test/index#werkzeug.test.Client.set_cookie", "type": "werkzeug.test", "text": "\nSets a cookie in the client\u2019s cookie jar. The server name is required and has\nto match the one that is also passed to the open call.\n\nNone\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Client.trace()", "path": "test/index#werkzeug.test.Client.trace", "type": "werkzeug.test", "text": "\nCall `open()` with `method` set to `TRACE`.\n\nwerkzeug.test.TestResponse\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "ClosingIterator", "path": "wsgi/index#werkzeug.wsgi.ClosingIterator", "type": "werkzeug.wsgi", "text": "\nThe WSGI specification requires that all middlewares and gateways respect the\n`close` callback of the iterable returned by the application. Because it is\nuseful to add another close action to a returned iterable and adding a custom\niterable is a boring task this class can be used for that:\n\nIf there is just one close function it can be passed instead of the list.\n\nA closing iterator is not needed if the application uses response objects and\nfinishes the processing if the response is started:\n\nNone\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "CombinedMultiDict", "path": "datastructures/index#werkzeug.datastructures.CombinedMultiDict", "type": "werkzeug.datastructures", "text": "\nA read only `MultiDict` that you can pass multiple `MultiDict` instances as\nsequence and it will combine the return values of all wrapped dicts:\n\nThis works for all read operations and will raise a `TypeError` for methods\nthat usually change data which isn\u2019t possible.\n\nFrom Werkzeug 0.3 onwards, the `KeyError` raised by this class is also a\nsubclass of the `BadRequest` HTTP exception and will render a page for a `400\nBAD REQUEST` if caught in a catch-all for HTTP exceptions.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "ContentRange", "path": "datastructures/index#werkzeug.datastructures.ContentRange", "type": "werkzeug.datastructures", "text": "\nRepresents the content range header.\n\nNew in version 0.7.\n\nThe length of the range or `None`.\n\nSimple method to update the ranges.\n\nThe start point of the range or `None`.\n\nThe stop point of the range (non-inclusive) or `None`. Can only be `None` if\nalso start is `None`.\n\nThe units to use, usually \u201cbytes\u201d\n\nSets the units to `None` which indicates that the header should no longer be\nused.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "ContentRange.set()", "path": "datastructures/index#werkzeug.datastructures.ContentRange.set", "type": "werkzeug.datastructures", "text": "\nSimple method to update the ranges.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "ContentRange.unset()", "path": "datastructures/index#werkzeug.datastructures.ContentRange.unset", "type": "werkzeug.datastructures", "text": "\nSets the units to `None` which indicates that the header should no longer be\nused.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Context Locals", "path": "local/index", "type": "Other", "text": "\nSooner or later you have some things you want to have in every single view or\nhelper function or whatever. In PHP the way to go are global variables.\nHowever, that isn\u2019t possible in WSGI applications without a major drawback: As\nsoon as you operate on the global namespace your application isn\u2019t thread-safe\nany longer.\n\nThe Python standard library has a concept called \u201cthread locals\u201d (or thread-\nlocal data). A thread local is a global object in which you can put stuff in\nand get back later in a thread-safe and thread-specific way. That means that\nwhenever you set or get a value on a thread local object, the thread local\nobject checks in which thread you are and retrieves the value corresponding to\nyour thread (if one exists). So, you won\u2019t accidentally get another thread\u2019s\ndata.\n\nThis approach, however, has a few disadvantages. For example, besides threads,\nthere are other types of concurrency in Python. A very popular one is\ngreenlets. Also, whether every request gets its own thread is not guaranteed\nin WSGI. It could be that a request is reusing a thread from a previous\nrequest, and hence data is left over in the thread local object.\n\nWerkzeug provides its own implementation of local data storage called\n`werkzeug.local`. This approach provides a similar functionality to thread\nlocals but also works with greenlets.\n\nHere\u2019s a simple example of how one could use werkzeug.local:\n\nThis binds the request to `local.request`. Every other piece of code executed\nafter this assignment in the same context can safely access local.request and\nwill get the same request object. The `make_middleware` method on the local\nmanager ensures that all references to the local objects are cleared up after\nthe request.\n\nThe same context means the same greenlet (if you\u2019re using greenlets) in the\nsame thread and same process.\n\nIf a request object is not yet set on the local object and you try to access\nit, you will get an `AttributeError`. You can use `getattr` to avoid that:\n\nThis will try to get the request or return `None` if the request is not (yet?)\navailable.\n\nNote that local objects cannot manage themselves, for that you need a local\nmanager. You can pass a local manager multiple locals or add additionals later\nby appending them to `manager.locals` and every time the manager cleans up it\nwill clean up all the data left in the locals for this context.\n\nReleases the contents of the local for the current context. This makes it\npossible to use locals without a manager.\n\nExample:\n\nWith this function one can release `Local` objects as well as `LocalStack`\nobjects. However it is not possible to release data held by proxies that way,\none always has to retain a reference to the underlying local object in order\nto be able to release it.\n\nNew in version 0.6.1.\n\nlocal (Union[werkzeug.local.Local, werkzeug.local.LocalStack]) \u2013\n\nNone\n\nLocal objects cannot manage themselves. For that you need a local manager. You\ncan pass a local manager multiple locals or add them later y appending them to\n`manager.locals`. Every time the manager cleans up, it will clean up all the\ndata left in the locals for this context.\n\nChanged in version 2.0: `ident_func` is deprecated and will be removed in\nWerkzeug 2.1.\n\nChanged in version 0.7: The `ident_func` parameter was added.\n\nChanged in version 0.6.1: The `release_local()` function can be used instead\nof a manager.\n\nNone\n\nManually clean up the data in the locals for this context. Call this at the\nend of the request or use `make_middleware()`.\n\nNone\n\nReturn the context identifier the local objects use internally for this\ncontext. You cannot override this method to change the behavior but use it to\nlink other context local objects (such as SQLAlchemy\u2019s scoped sessions) to the\nWerkzeug locals.\n\nDeprecated since version 2.0: Will be removed in Werkzeug 2.1.\n\nChanged in version 0.7: You can pass a different ident function to the local\nmanager that will then be propagated to all the locals passed to the\nconstructor.\n\nint\n\nWrap a WSGI application so that cleaning up happens after request end.\n\napp (WSGIApplication) \u2013\n\nWSGIApplication\n\nLike `make_middleware` but for decorating functions.\n\nExample usage:\n\nThe difference to `make_middleware` is that the function passed will have all\nthe arguments copied from the inner application (name, docstring, module).\n\nfunc (WSGIApplication) \u2013\n\nWSGIApplication\n\nThis class works similar to a `Local` but keeps a stack of objects instead.\nThis is best explained with an example:\n\nThey can be force released by using a `LocalManager` or with the\n`release_local()` function but the correct way is to pop the item from the\nstack after using. When the stack is empty it will no longer be bound to the\ncurrent context (and as such released).\n\nBy calling the stack without arguments it returns a proxy that resolves to the\ntopmost item on the stack.\n\nNew in version 0.6.1.\n\nNone\n\nRemoves the topmost item from the stack, will return the old value or `None`\nif the stack was already empty.\n\nAny\n\nPushes a new item to the stack\n\nobj (Any) \u2013\n\nList[Any]\n\nThe topmost item on the stack. If the stack is empty, `None` is returned.\n\nA proxy to the object bound to a `Local`. All operations on the proxy are\nforwarded to the bound object. If no object is bound, a `RuntimeError` is\nraised.\n\n`__repr__` and `__class__` are forwarded, so `repr(x)` and `isinstance(x,\ncls)` will look like the proxied object. Use `issubclass(type(x), LocalProxy)`\nto check if an object is a proxy.\n\nChanged in version 2.0: Updated proxied attributes and methods to reflect the\ncurrent data model.\n\nChanged in version 0.6.1: The class can be instantiated with a callable.\n\nReturn the current object. This is useful if you want the real object behind\nthe proxy at a time for performance reasons or because you want to pass the\nobject into a different context.\n\nAny\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "cookie_date()", "path": "http/index#werkzeug.http.cookie_date", "type": "werkzeug.http", "text": "\nFormat a datetime object or timestamp into an RFC 2822 date string for `Set-\nCookie expires`.\n\nDeprecated since version 2.0: Will be removed in Werkzeug 2.1. Use\n`http_date()` instead.\n\nexpires (Optional[Union[datetime.datetime, datetime.date, int, float,\ntime.struct_time]]) \u2013\n\nstr\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "create_environ()", "path": "test/index#werkzeug.test.create_environ", "type": "werkzeug.test", "text": "\nCreate a new WSGI environ dict based on the values passed. The first parameter\nshould be the path of the request which defaults to \u2018/\u2019. The second one can\neither be an absolute path (in that case the host is localhost:80) or a full\npath to the request with scheme, netloc port and the path to the script.\n\nThis accepts the same arguments as the `EnvironBuilder` constructor.\n\nChanged in version 0.5: This function is now a thin wrapper over\n`EnvironBuilder` which was added in 0.5. The `headers`, `environ_base`,\n`environ_overrides` and `charset` parameters were added.\n\nWSGIEnvironment\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Data Structures", "path": "datastructures/index", "type": "Other", "text": "\nWerkzeug provides some subclasses of common Python objects to extend them with\nadditional features. Some of them are used to make them immutable, others are\nused to change some semantics to better work with HTTP.\n\nChanged in version 0.6: The general purpose classes are now pickleable in each\nprotocol as long as the contained objects are pickleable. This means that the\n`FileMultiDict` won\u2019t be pickleable as soon as it contains a file.\n\nWorks like a regular dict but the `get()` method can perform type conversions.\n`MultiDict` and `CombinedMultiDict` are subclasses of this class and provide\nthe same feature.\n\nNew in version 0.5.\n\nReturn the default value if the requested data doesn\u2019t exist. If `type` is\nprovided and is a callable it should convert the value, return it or raise a\n`ValueError` if that is not possible. In this case the function will return\nthe default as if the value was not found:\n\nWorks like a `TypeConversionDict` but does not support modifications.\n\nNew in version 0.5.\n\nReturn a shallow mutable copy of this object. Keep in mind that the standard\nlibrary\u2019s `copy()` function is a no-op for this class like for any other\npython immutable type (eg: `tuple`).\n\nA `MultiDict` is a dictionary subclass customized to deal with multiple values\nfor the same key which is for example used by the parsing functions in the\nwrappers. This is necessary because some HTML form elements pass multiple\nvalues for the same key.\n\n`MultiDict` implements all standard dictionary methods. Internally, it saves\nall values for a key as a list, but the standard dict access methods will only\nreturn the first value for a key. If you want to gain access to the other\nvalues, too, you have to use the `list` methods as explained below.\n\nBasic Usage:\n\nIt behaves like a normal dict thus all dict functions will only return the\nfirst value when multiple values for one key are found.\n\nFrom Werkzeug 0.3 onwards, the `KeyError` raised by this class is also a\nsubclass of the `BadRequest` HTTP exception and will render a page for a `400\nBAD REQUEST` if caught in a catch-all for HTTP exceptions.\n\nA `MultiDict` can be constructed from an iterable of `(key, value)` tuples, a\ndict, a `MultiDict` or from Werkzeug 0.2 onwards some keyword parameters.\n\nmapping \u2013 the initial value for the `MultiDict`. Either a regular dict, an\niterable of `(key, value)` tuples or `None`.\n\nAdds a new value for the key.\n\nNew in version 0.6.\n\nReturn a shallow copy of this object.\n\nReturn a deep copy of this object.\n\nCreate a new dictionary with keys from iterable and values set to value.\n\nReturn the default value if the requested data doesn\u2019t exist. If `type` is\nprovided and is a callable it should convert the value, return it or raise a\n`ValueError` if that is not possible. In this case the function will return\nthe default as if the value was not found:\n\nReturn the list of items for a given key. If that key is not in the\n`MultiDict`, the return value will be an empty list. Just like `get`,\n`getlist` accepts a `type` parameter. All items will be converted with the\ncallable defined there.\n\na `list` of all the values for the key.\n\nReturn an iterator of `(key, value)` pairs.\n\nmulti \u2013 If set to `True` the iterator returned will have a pair for each value\nof each key. Otherwise it will only contain pairs for the first value of each\nkey.\n\nReturn a iterator of `(key, values)` pairs, where values is the list of all\nvalues associated with the key.\n\nReturn an iterator of all values associated with a key. Zipping `keys()` and\nthis is the same as calling `lists()`:\n\nPop the first item for a list on the dict. Afterwards the key is removed from\nthe dict, so additional values are discarded:\n\nPop an item from the dict.\n\nPop a `(key, list)` tuple from the dict.\n\nPop the list for a key from the dict. If the key is not in the dict an empty\nlist is returned.\n\nChanged in version 0.5: If the key does no longer exist a list is returned\ninstead of raising an error.\n\nReturns the value for the key if it is in the dict, otherwise it returns\n`default` and sets that value for `key`.\n\nRemove the old values for a key and add new ones. Note that the list you pass\nthe values in will be shallow-copied before it is inserted in the dictionary.\n\nLike `setdefault` but sets multiple values. The list returned is not a copy,\nbut the list that is actually used internally. This means that you can put new\nvalues into the dict by appending items to the list:\n\na `list`\n\nReturn the contents as regular dict. If `flat` is `True` the returned dict\nwill only have the first item present, if `flat` is `False` all values will be\nreturned as lists.\n\nflat \u2013 If set to `False` the dict returned will have lists with all the values\nin it. Otherwise it will only contain the first value for each key.\n\na `dict`\n\nupdate() extends rather than replaces existing key lists:\n\nIf the value list for a key in `other_dict` is empty, no new values will be\nadded to the dict and the key will not be created:\n\nReturns an iterator of the first value on every key\u2019s value list.\n\nWorks like a regular `MultiDict` but preserves the order of the fields. To\nconvert the ordered multi dict into a list you can use the `items()` method\nand pass it `multi=True`.\n\nIn general an `OrderedMultiDict` is an order of magnitude slower than a\n`MultiDict`.\n\nnote\n\nDue to a limitation in Python you cannot convert an ordered multi dict into a\nregular dict by using `dict(multidict)`. Instead you have to use the\n`to_dict()` method, otherwise the internal bucket objects are exposed.\n\nAn immutable `MultiDict`.\n\nNew in version 0.5.\n\nReturn a shallow mutable copy of this object. Keep in mind that the standard\nlibrary\u2019s `copy()` function is a no-op for this class like for any other\npython immutable type (eg: `tuple`).\n\nAn immutable `OrderedMultiDict`.\n\nNew in version 0.6.\n\nReturn a shallow mutable copy of this object. Keep in mind that the standard\nlibrary\u2019s `copy()` function is a no-op for this class like for any other\npython immutable type (eg: `tuple`).\n\nA read only `MultiDict` that you can pass multiple `MultiDict` instances as\nsequence and it will combine the return values of all wrapped dicts:\n\nThis works for all read operations and will raise a `TypeError` for methods\nthat usually change data which isn\u2019t possible.\n\nFrom Werkzeug 0.3 onwards, the `KeyError` raised by this class is also a\nsubclass of the `BadRequest` HTTP exception and will render a page for a `400\nBAD REQUEST` if caught in a catch-all for HTTP exceptions.\n\nAn immutable `dict`.\n\nNew in version 0.5.\n\nReturn a shallow mutable copy of this object. Keep in mind that the standard\nlibrary\u2019s `copy()` function is a no-op for this class like for any other\npython immutable type (eg: `tuple`).\n\nAn immutable `list`.\n\nNew in version 0.5.\n\nA special `MultiDict` that has convenience methods to add files to it. This is\nused for `EnvironBuilder` and generally useful for unittesting.\n\nNew in version 0.5.\n\nAdds a new file to the dict. `file` can be a file name or a `file`-like or a\n`FileStorage` object.\n\nAn object that stores some headers. It has a dict-like interface, but is\nordered, can store the same key multiple times, and iterating yields `(key,\nvalue)` pairs instead of only keys.\n\nThis data structure is useful if you want a nicer way to handle WSGI headers\nwhich are stored as tuples in a list.\n\nFrom Werkzeug 0.3 onwards, the `KeyError` raised by this class is also a\nsubclass of the `BadRequest` HTTP exception and will render a page for a `400\nBAD REQUEST` if caught in a catch-all for HTTP exceptions.\n\nHeaders is mostly compatible with the Python `wsgiref.headers.Headers` class,\nwith the exception of `__getitem__`. `wsgiref` will return `None` for\n`headers['missing']`, whereas `Headers` will raise a `KeyError`.\n\nTo create a new `Headers` object pass it a list or dict of headers which are\nused as default values. This does not reuse the list passed to the constructor\nfor internal usage.\n\ndefaults \u2013 The list of default values for the `Headers`.\n\nChanged in version 0.9: This data structure now stores unicode values similar\nto how the multi dicts do it. The main difference is that bytes can be set as\nwell which will automatically be latin1 decoded.\n\nChanged in version 0.9: The `linked()` function was removed without\nreplacement as it was an API that does not support the changes to the encoding\nmodel.\n\nAdd a new header tuple to the list.\n\nKeyword arguments can specify additional parameters for the header value, with\nunderscores converted to dashes:\n\nThe keyword argument dumping uses `dump_options_header()` behind the scenes.\n\nNew in version 0.4.1: keyword arguments were added for `wsgiref`\ncompatibility.\n\nAdd a new header tuple to the list.\n\nAn alias for `add()` for compatibility with the `wsgiref` `add_header()`\nmethod.\n\nClears all headers.\n\nExtend headers in this object with items from another object containing header\nitems as well as keyword arguments.\n\nTo replace existing keys instead of extending, use `update()` instead.\n\nIf provided, the first argument can be another `Headers` object, a\n`MultiDict`, `dict`, or iterable of pairs.\n\nChanged in version 1.0: Support `MultiDict`. Allow passing `kwargs`.\n\nReturn the default value if the requested data doesn\u2019t exist. If `type` is\nprovided and is a callable it should convert the value, return it or raise a\n`ValueError` if that is not possible. In this case the function will return\nthe default as if the value was not found:\n\nNew in version 0.9: Added support for `as_bytes`.\n\nReturn a list of all the values for the named field.\n\nThis method is compatible with the `wsgiref` `get_all()` method.\n\nReturn the list of items for a given key. If that key is not in the `Headers`,\nthe return value will be an empty list. Just like `get()`, `getlist()` accepts\na `type` parameter. All items will be converted with the callable defined\nthere.\n\nNew in version 0.9: Added support for `as_bytes`.\n\na `list` of all the values for the key.\n\nDeprecated since version 2.0: Will be removed in Werkzeug 2.1. Use `key in\ndata` instead.\n\nRemoves and returns a key or index.\n\nkey \u2013 The key to be popped. If this is an integer the item at that position is\nremoved, if it\u2019s a string the value for that key is. If the key is omitted or\n`None` the last item is removed.\n\nan item.\n\nRemoves a key or index and returns a (key, value) item.\n\nRemove a key.\n\nkey \u2013 The key to be removed.\n\nRemove all header tuples for `key` and add a new one. The newly added key\neither appears at the end of the list if there was no entry or replaces the\nfirst one.\n\nKeyword arguments can specify additional parameters for the header value, with\nunderscores converted to dashes. See `add()` for more information.\n\nChanged in version 0.6.1: `set()` now accepts the same arguments as `add()`.\n\nReturn the first value for the key if it is in the headers, otherwise set the\nheader to the value given by `default` and return that.\n\nRemove any existing values for a header and add new ones.\n\nNew in version 1.0.\n\nReturn the list of values for the key if it is in the headers, otherwise set\nthe header to the list of values given by `default` and return that.\n\nUnlike `MultiDict.setlistdefault()`, modifying the returned list will not\naffect the headers.\n\nNew in version 1.0.\n\nConvert the headers into a list suitable for WSGI.\n\nlist\n\nReplace headers in this object with items from another headers object and\nkeyword arguments.\n\nTo extend existing keys instead of replacing, use `extend()` instead.\n\nIf provided, the first argument can be another `Headers` object, a\n`MultiDict`, `dict`, or iterable of pairs.\n\nNew in version 1.0.\n\nRead only version of the headers from a WSGI environment. This provides the\nsame interface as `Headers` and is constructed from a WSGI environment.\n\nFrom Werkzeug 0.3 onwards, the `KeyError` raised by this class is also a\nsubclass of the `BadRequest` HTTP exception and will render a page for a `400\nBAD REQUEST` if caught in a catch-all for HTTP exceptions.\n\nSimilar to the `ETags` class this implements a set-like structure. Unlike\n`ETags` this is case insensitive and used for vary, allow, and content-\nlanguage headers.\n\nIf not constructed using the `parse_set_header()` function the instantiation\nworks like this:\n\nAdd a new header to the set.\n\nReturn the set as real python set type. When calling this, all the items are\nconverted to lowercase and the ordering is lost.\n\npreserve_casing \u2013 if set to `True` the items in the set returned will have the\noriginal case like in the `HeaderSet`, otherwise they will be lowercase.\n\nClear the set.\n\nLike `remove()` but ignores errors.\n\nheader \u2013 the header to be discarded.\n\nReturn the index of the header in the set or return -1 if not found.\n\nheader \u2013 the header to be looked up.\n\nReturn the index of the header in the set or raise an `IndexError`.\n\nheader \u2013 the header to be looked up.\n\nRemove a header from the set. This raises an `KeyError` if the header is not\nin the set.\n\nChanged in version 0.5: In older versions a `IndexError` was raised instead of\na `KeyError` if the object was missing.\n\nheader \u2013 the header to be removed.\n\nConvert the header set into an HTTP header string.\n\nAdd all the headers from the iterable to the set.\n\niterable \u2013 updates the set with the items from the iterable.\n\nAn `Accept` object is just a list subclass for lists of `(value, quality)`\ntuples. It is automatically sorted by specificity and quality.\n\nAll `Accept` objects work similar to a list but provide extra functionality\nfor working with the data. Containment checks are normalized to the rules of\nthat header:\n\nTo get the quality for an item you can use normal item lookup:\n\nChanged in version 1.0.0: `Accept` internal values are no longer ordered\nalphabetically for equal quality tags. Instead the initial order is preserved.\n\nChanged in version 0.5: `Accept` objects are forced immutable now.\n\nThe best match as value.\n\nReturns the best match from a list of possible matches based on the\nspecificity and quality of the client. If two items have the same quality and\nspecificity, the one is returned that comes first.\n\nGet the position of an entry or return -1.\n\nkey \u2013 The key to be looked up.\n\nGet the position of an entry or raise `ValueError`.\n\nkey \u2013 The key to be looked up.\n\nChanged in version 0.5: This used to raise `IndexError`, which was\ninconsistent with the list API.\n\nReturns the quality of the key.\n\nNew in version 0.6: In previous versions you had to use the item-lookup syntax\n(eg: `obj[key]` instead of `obj.quality(key)`)\n\nConvert the header set into an HTTP header string.\n\nIterate over all values.\n\nLike `Accept` but with special methods and behavior for mimetypes.\n\nTrue if this object accepts HTML.\n\nTrue if this object accepts JSON.\n\nTrue if this object accepts XHTML.\n\nLike `Accept` but with normalization for charsets.\n\nLike `Accept` but with normalization for language tags.\n\nA cache control for requests. This is immutable and gives access to all the\nrequest-relevant cache control headers.\n\nTo get a header of the `RequestCacheControl` object again you can convert the\nobject into a string or call the `to_header()` method. If you plan to subclass\nit and add your own items have a look at the sourcecode for that class.\n\nNew in version 0.5: In previous versions a `CacheControl` class existed that\nwas used both for request and response.\n\naccessor for \u2018no-cache\u2019\n\naccessor for \u2018no-store\u2019\n\naccessor for \u2018max-age\u2019\n\naccessor for \u2018no-transform\u2019\n\naccessor for \u2018max-stale\u2019\n\naccessor for \u2018min-fresh\u2019\n\naccessor for \u2018only-if-cached\u2019\n\nA cache control for responses. Unlike `RequestCacheControl` this is mutable\nand gives access to response-relevant cache control headers.\n\nTo get a header of the `ResponseCacheControl` object again you can convert the\nobject into a string or call the `to_header()` method. If you plan to subclass\nit and add your own items have a look at the sourcecode for that class.\n\nNew in version 0.5: In previous versions a `CacheControl` class existed that\nwas used both for request and response.\n\naccessor for \u2018no-cache\u2019\n\naccessor for \u2018no-store\u2019\n\naccessor for \u2018max-age\u2019\n\naccessor for \u2018no-transform\u2019\n\naccessor for \u2018immutable\u2019\n\naccessor for \u2018must-revalidate\u2019\n\naccessor for \u2018private\u2019\n\naccessor for \u2018proxy-revalidate\u2019\n\naccessor for \u2018public\u2019\n\naccessor for \u2018s-maxage\u2019\n\nA set that can be used to check if one etag is present in a collection of\netags.\n\nConvert the `ETags` object into a python set. Per default all the weak etags\nare not part of this set.\n\nCheck if an etag is part of the set ignoring weak tags. It is also possible to\nuse the `in` operator.\n\nWhen passed a quoted tag it will check if this tag is part of the set. If the\ntag is weak it is checked against weak and strong tags, otherwise strong only.\n\nCheck if an etag is part of the set including weak and strong tags.\n\nCheck if an etag is strong.\n\nCheck if an etag is weak.\n\nConvert the etags set into a HTTP header string.\n\nRepresents an `Authorization` header sent by the client.\n\nThis is returned by `parse_authorization_header()`. It can be useful to create\nthe object manually to pass to the test `Client`.\n\nChanged in version 0.5: This object became immutable.\n\nIf the server sent a qop-header in the `WWW-Authenticate` header, the client\nhas to provide this value for HTTP digest auth. See the RFC for more details.\n\nThe nonce count value transmitted by clients if a qop-header is also\ntransmitted. HTTP digest auth only.\n\nThe nonce the server sent for digest auth, sent back by the client. A nonce\nshould be unique for every 401 response for HTTP digest auth.\n\nThe opaque header from the server returned unchanged by the client. It is\nrecommended that this string be base64 or hexadecimal data. Digest auth only.\n\nWhen the authentication type is basic this is the password transmitted by the\nclient, else `None`.\n\nIndicates what \u201cquality of protection\u201d the client has applied to the message\nfor HTTP digest auth. Note that this is a single token, not a quoted list of\nalternatives as in WWW-Authenticate.\n\nThis is the server realm sent back for HTTP digest auth.\n\nA string of 32 hex digits computed as defined in RFC 2617, which proves that\nthe user knows a password. Digest auth only.\n\nConvert to a string value for an `Authorization` header.\n\nNew in version 2.0: Added to support passing authorization to the test client.\n\nThe URI from Request-URI of the Request-Line; duplicated because proxies are\nallowed to change the Request-Line in transit. HTTP digest auth only.\n\nThe username transmitted. This is set for both basic and digest auth all the\ntime.\n\nProvides simple access to `WWW-Authenticate` headers.\n\nA string indicating a pair of algorithms used to produce the digest and a\nchecksum. If this is not present it is assumed to be \u201cMD5\u201d. If the algorithm\nis not understood, the challenge should be ignored (and a different one used,\nif there is more than one).\n\nA static helper function for Authentication subclasses to add extra\nauthentication system properties onto a class:\n\nFor more information have a look at the sourcecode to see how the regular\nproperties (`realm` etc.) are implemented.\n\nA list of URIs that define the protection space. If a URI is an absolute path,\nit is relative to the canonical root URL of the server being accessed.\n\nA server-specified data string which should be uniquely generated each time a\n401 response is made. It is recommended that this string be base64 or\nhexadecimal data.\n\nA string of data, specified by the server, which should be returned by the\nclient unchanged in the Authorization header of subsequent requests with URIs\nin the same protection space. It is recommended that this string be base64 or\nhexadecimal data.\n\nA set of quality-of-privacy directives such as auth and auth-int.\n\nA string to be displayed to users so they know which username and password to\nuse. This string should contain at least the name of the host performing the\nauthentication and might additionally indicate the collection of users who\nmight have access.\n\nClear the auth info and enable basic auth.\n\nClear the auth info and enable digest auth.\n\nA flag, indicating that the previous request from the client was rejected\nbecause the nonce value was stale.\n\nConvert the stored values into a WWW-Authenticate header.\n\nThe type of the auth mechanism. HTTP currently specifies `Basic` and `Digest`.\n\nVery simple object that represents the `If-Range` header in parsed form. It\nwill either have neither a etag or date or one of either but never both.\n\nNew in version 0.7.\n\nThe date in parsed format or `None`.\n\nThe etag parsed and unquoted. Ranges always operate on strong etags so the\nweakness information is not necessary.\n\nConverts the object back into an HTTP header.\n\nRepresents a `Range` header. All methods only support only bytes as the unit.\nStores a list of ranges if given, but the methods only work if only one range\nis provided.\n\nValueError \u2013 If the ranges provided are invalid.\n\nChanged in version 0.15: The ranges passed in are validated.\n\nNew in version 0.7.\n\nCreates a `ContentRange` object from the current range and given content\nlength.\n\nIf the range is for bytes, the length is not None and there is exactly one\nrange and it is satisfiable it returns a `(start, stop)` tuple, otherwise\n`None`.\n\nA list of `(begin, end)` tuples for the range header provided. The ranges are\nnon-inclusive.\n\nConverts the object into `Content-Range` HTTP header, based on given length\n\nConverts the object back into an HTTP header.\n\nThe units of this range. Usually \u201cbytes\u201d.\n\nRepresents the content range header.\n\nNew in version 0.7.\n\nThe length of the range or `None`.\n\nSimple method to update the ranges.\n\nThe start point of the range or `None`.\n\nThe stop point of the range (non-inclusive) or `None`. Can only be `None` if\nalso start is `None`.\n\nThe units to use, usually \u201cbytes\u201d\n\nSets the units to `None` which indicates that the header should no longer be\nused.\n\nThe `FileStorage` class is a thin wrapper over incoming files. It is used by\nthe request object to represent uploaded files. All the attributes of the\nwrapper stream are proxied by the file storage so it\u2019s possible to do\n`storage.read()` instead of the long form `storage.stream.read()`.\n\nThe input stream for the uploaded file. This usually points to an open\ntemporary file.\n\nThe filename of the file on the client.\n\nThe name of the form field.\n\nThe multipart headers as `Headers` object. This usually contains irrelevant\ninformation but in combination with custom multipart requests the raw headers\nmight be interesting.\n\nNew in version 0.6.\n\nClose the underlying file if possible.\n\nThe content-length sent in the header. Usually not available\n\nThe content-type sent in the header. Usually not available\n\nLike `content_type`, but without parameters (eg, without charset, type etc.)\nand always lowercase. For example if the content type is `text/HTML;\ncharset=utf-8` the mimetype would be `'text/html'`.\n\nNew in version 0.7.\n\nThe mimetype parameters as dict. For example if the content type is\n`text/html; charset=utf-8` the params would be `{'charset': 'utf-8'}`.\n\nNew in version 0.7.\n\nSave the file to a destination path or file object. If the destination is a\nfile object you have to close it yourself after the call. The buffer size is\nthe number of bytes held in memory during the copy process. It defaults to\n16KB.\n\nFor secure file saving also have a look at `secure_filename()`.\n\nChanged in version 1.0: Supports `pathlib`.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Dealing with Request Data", "path": "request_data/index", "type": "Other", "text": "\nThe most important rule about web development is \u201cDo not trust the user\u201d. This\nis especially true for incoming request data on the input stream. With WSGI\nthis is actually a bit harder than you would expect. Because of that Werkzeug\nwraps the request stream for you to save you from the most prominent problems\nwith it.\n\nThe input stream has no end-of-file marker. If you would call the `read()`\nmethod on the `wsgi.input` stream you would cause your application to hang on\nconforming servers. This is actually intentional however painful. Werkzeug\nsolves that problem by wrapping the input stream in a special `LimitedStream`.\nThe input stream is exposed on the request objects as `stream`. This one is\neither an empty stream (if the form data was parsed) or a limited stream with\nthe contents of the input stream.\n\nWerkzeug parses the incoming data under the following situations:\n\nThese calls are not interchangeable. If you invoke `parse_form_data()` you\nmust not use the request object or at least not the attributes that trigger\nthe parsing process.\n\nThis is also true if you read from the `wsgi.input` stream before the parsing.\n\nGeneral rule: Leave the WSGI input stream alone. Especially in WSGI\nmiddlewares. Use either the parsing functions or the request object. Do not\nmix multiple WSGI utility libraries for form data parsing or anything else\nthat works on the input stream.\n\nThe standard Werkzeug parsing behavior handles three cases:\n\nSpecial note on the `get_data` method: Calling this loads the full request\ndata into memory. This is only safe to do if the `max_content_length` is set.\nAlso you can either read the stream or call `get_data()`.\n\nTo avoid being the victim of a DDOS attack you can set the maximum accepted\ncontent length and request field sizes. The `Request` class has two attributes\nfor that: `max_content_length` and `max_form_memory_size`.\n\nThe first one can be used to limit the total content length. For example by\nsetting it to `1024 * 1024 * 16` the request won\u2019t accept more than 16MB of\ntransmitted data.\n\nBecause certain data can\u2019t be moved to the hard disk (regular post data)\nwhereas temporary files can, there is a second limit you can set. The\n`max_form_memory_size` limits the size of `POST` transmitted form data. By\nsetting it to `1024 * 1024 * 2` you can make sure that all in memory-stored\nfields are not more than 2MB in size.\n\nThis however does not affect in-memory stored files if the `stream_factory`\nused returns a in-memory file.\n\nModern web applications transmit a lot more than multipart form data or url\nencoded data. To extend the capabilities, subclass `Request` or `Request` and\nadd or extend methods.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "DebuggedApplication", "path": "debug/index#werkzeug.debug.DebuggedApplication", "type": "werkzeug.debug", "text": "\nEnables debugging support for a given application:\n\nThe `evalex` keyword argument allows evaluating expressions in a traceback\u2019s\nframe context.\n\nNone\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Debugging Applications", "path": "debug/index", "type": "Other", "text": "\nDepending on the WSGI gateway/server, exceptions are handled differently. Most\nof the time, exceptions go to stderr or the error log, and a generic \u201c500\nInternal Server Error\u201d message is displayed.\n\nSince this is not the best debugging environment, Werkzeug provides a WSGI\nmiddleware that renders nice tracebacks, optionally with an interactive debug\nconsole to execute code in any frame.\n\nDanger\n\nThe debugger allows the execution of arbitrary code which makes it a major\nsecurity risk. The debugger must never be used on production machines. We\ncannot stress this enough. Do not enable the debugger in production.\n\nNote\n\nThe interactive debugger does not work in forking environments, such as a\nserver that starts multiple processes. Most such environments are production\nservers, where the debugger should not be enabled anyway.\n\nEnable the debugger by wrapping the application with the `DebuggedApplication`\nmiddleware. Alternatively, you can pass `use_debugger=True` to `run_simple()`\nand it will do that for you.\n\nEnables debugging support for a given application:\n\nThe `evalex` keyword argument allows evaluating expressions in a traceback\u2019s\nframe context.\n\nNone\n\nOnce enabled and an error happens during a request you will see a detailed\ntraceback instead of a generic \u201cinternal server error\u201d. The traceback is still\noutput to the terminal as well.\n\nThe error message is displayed at the top. Clicking it jumps to the bottom of\nthe traceback. Frames that represent user code, as opposed to built-ins or\ninstalled packages, are highlighted blue. Clicking a frame will show more\nlines for context, clicking again will hide them.\n\nIf you have the `evalex` feature enabled you can get a console for every frame\nin the traceback by hovering over a frame and clicking the console icon that\nappears at the right. Once clicked a console opens where you can execute\nPython code in:\n\nInside the interactive consoles you can execute any kind of Python code.\nUnlike regular Python consoles the output of the object reprs is colored and\nstripped to a reasonable size by default. If the output is longer than what\nthe console decides to display a small plus sign is added to the repr and a\nclick will expand the repr.\n\nTo display all variables that are defined in the current frame you can use the\n`dump()` function. You can call it without arguments to get a detailed list of\nall variables and their values, or with an object as argument to get a\ndetailed list of all the attributes it has.\n\nStarting with Werkzeug 0.11 the debug console is protected by a PIN. This is a\nsecurity helper to make it less likely for the debugger to be exploited if you\nforget to disable it when deploying to production. The PIN based\nauthentication is enabled by default.\n\nThe first time a console is opened, a dialog will prompt for a PIN that is\nprinted to the command line. The PIN is generated in a stable way that is\nspecific to the project. An explicit PIN can be provided through the\nenvironment variable `WERKZEUG_DEBUG_PIN`. This can be set to a number and\nwill become the PIN. This variable can also be set to the value `off` to\ndisable the PIN check entirely.\n\nIf an incorrect PIN is entered too many times the server needs to be\nrestarted.\n\nThis feature is not meant to entirely secure the debugger. It is intended to\nmake it harder for an attacker to exploit the debugger. Never enable the\ndebugger in production.\n\nIf you click on the \u201cTraceback (most recent call last)\u201d header, the view\nswitches to a traditional text-based traceback. You can copy and paste this in\norder to provide information when asking a question or reporting an issue.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "DispatcherMiddleware", "path": "middleware/dispatcher/index#werkzeug.middleware.dispatcher.DispatcherMiddleware", "type": "werkzeug.middleware.dispatcher", "text": "\nCombine multiple applications as a single WSGI application. Requests are\ndispatched to an application based on the path it is mounted under.\n\nNone\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "dump_cookie()", "path": "http/index#werkzeug.http.dump_cookie", "type": "werkzeug.http", "text": "\nCreate a Set-Cookie header without the `Set-Cookie` prefix.\n\nThe return value is usually restricted to ascii as the vast majority of values\nare properly escaped, but that is no guarantee. It\u2019s tunneled through latin1\nas required by PEP 3333.\n\nThe return value is not ASCII safe if the key contains unicode characters.\nThis is technically against the specification but happens in the wild. It\u2019s\nstrongly recommended to not use non-ASCII values for the keys.\n\nstr\n\nChanged in version 1.0.0: The string `'None'` is accepted for `samesite`.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "dump_header()", "path": "http/index#werkzeug.http.dump_header", "type": "werkzeug.http", "text": "\nDump an HTTP header again. This is the reversal of `parse_list_header()`,\n`parse_set_header()` and `parse_dict_header()`. This also quotes strings that\ninclude an equals sign unless you pass it as dict of key, value pairs.\n\nstr\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "EndpointPrefix", "path": "routing/index#werkzeug.routing.EndpointPrefix", "type": "werkzeug.routing", "text": "\nPrefixes all endpoints (which must be strings for this factory) with another\nstring. This can be useful for sub applications:\n\nNone\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "EnvironBuilder", "path": "test/index#werkzeug.test.EnvironBuilder", "type": "werkzeug.test", "text": "\nThis class can be used to conveniently create a WSGI environment for testing\npurposes. It can be used to quickly create WSGI environments or request\nobjects from arbitrary data.\n\nThe signature of this class is also used in some other places as of Werkzeug\n0.5 (`create_environ()`, `Response.from_values()`, `Client.open()`). Because\nof this most of the functionality is available through the constructor alone.\n\nFiles and regular form data can be manipulated independently of each other\nwith the `form` and `files` attributes, but are passed with the same argument\nto the constructor: `data`.\n\n`data` can be any of these values:\n\na `dict` or `MultiDict`: The keys have to be strings. The values have to be\neither any of the following objects, or a list of any of the following\nobjects:\n\nNone\n\nChanged in version 2.0: `REQUEST_URI` and `RAW_URI` is the full raw URI\nincluding the query string, not only the path.\n\nChanged in version 2.0: The default `request_class` is `Request` instead of\n`BaseRequest`.\n\nNew in version 2.0: Added the `auth` parameter.\n\nNew in version 0.15: The `json` param and `json_dumps()` method.\n\nNew in version 0.15: The environ has keys `REQUEST_URI` and `RAW_URI`\ncontaining the path before perecent-decoding. This is not part of the WSGI\nPEP, but many WSGI servers include it.\n\nChanged in version 0.6: `path` and `base_url` can now be unicode strings that\nare encoded with `iri_to_uri()`.\n\nthe server protocol to use. defaults to HTTP/1.1\n\nthe wsgi version to use. defaults to (1, 0)\n\nalias of `werkzeug.wrappers.request.Request`\n\nThe serialization function used when `json` is passed.\n\nTurn an environ dict back into a builder. Any extra kwargs override the args\nextracted from the environ.\n\nChanged in version 2.0: Path and query values are passed through the WSGI\ndecoding dance to avoid double encoding.\n\nNew in version 0.15.\n\nEnvironBuilder\n\nThe base URL is used to extract the URL scheme, host name, port, and root\npath.\n\nThe content type for the request. Reflected from and to the `headers`. Do not\nset if you set `files` or `form` for auto detection.\n\nThe mimetype (content type without charset etc.)\n\nNew in version 0.14.\n\nThe mimetype parameters as dict. For example if the content type is\n`text/html; charset=utf-8` the params would be `{'charset': 'utf-8'}`.\n\nNew in version 0.14.\n\nThe content length as integer. Reflected from and to the `headers`. Do not set\nif you set `files` or `form` for auto detection.\n\nA `MultiDict` of form values.\n\nA `FileMultiDict` of uploaded files. Use `add_file()` to add new files.\n\nAn optional input stream. This is mutually exclusive with setting `form` and\n`files`, setting it will clear those. Do not provide this if the method is not\n`POST` or another method that has a body.\n\nThe query string. If you set this to a string `args` will no longer be\navailable.\n\nThe URL arguments as `MultiDict`.\n\nThe server name (read-only, use `host` to set)\n\nThe server port as integer (read-only, use `host` to set)\n\nCloses all files. If you put real `file` objects into the `files` dict you can\ncall this method to automatically close them all in one go.\n\nNone\n\nReturn the built environ.\n\nChanged in version 0.15: The content type and length headers are set based on\ninput stream detection. Previously this only set the WSGI keys.\n\nWSGIEnvironment\n\nReturns a request with the data. If the request class is not specified\n`request_class` is used.\n\ncls (Optional[Type[werkzeug.wrappers.request.Request]]) \u2013 The request wrapper\nto use.\n\nwerkzeug.wrappers.request.Request\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "EnvironBuilder.close()", "path": "test/index#werkzeug.test.EnvironBuilder.close", "type": "werkzeug.test", "text": "\nCloses all files. If you put real `file` objects into the `files` dict you can\ncall this method to automatically close them all in one go.\n\nNone\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "EnvironBuilder.from_environ()", "path": "test/index#werkzeug.test.EnvironBuilder.from_environ", "type": "werkzeug.test", "text": "\nTurn an environ dict back into a builder. Any extra kwargs override the args\nextracted from the environ.\n\nChanged in version 2.0: Path and query values are passed through the WSGI\ndecoding dance to avoid double encoding.\n\nNew in version 0.15.\n\nEnvironBuilder\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "EnvironBuilder.get_environ()", "path": "test/index#werkzeug.test.EnvironBuilder.get_environ", "type": "werkzeug.test", "text": "\nReturn the built environ.\n\nChanged in version 0.15: The content type and length headers are set based on\ninput stream detection. Previously this only set the WSGI keys.\n\nWSGIEnvironment\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "EnvironBuilder.get_request()", "path": "test/index#werkzeug.test.EnvironBuilder.get_request", "type": "werkzeug.test", "text": "\nReturns a request with the data. If the request class is not specified\n`request_class` is used.\n\ncls (Optional[Type[werkzeug.wrappers.request.Request]]) \u2013 The request wrapper\nto use.\n\nwerkzeug.wrappers.request.Request\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "EnvironBuilder.json_dumps()", "path": "test/index#werkzeug.test.EnvironBuilder.json_dumps", "type": "werkzeug.test", "text": "\nThe serialization function used when `json` is passed.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "EnvironBuilder.request_class", "path": "test/index#werkzeug.test.EnvironBuilder.request_class", "type": "werkzeug.test", "text": "\nalias of `werkzeug.wrappers.request.Request`\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "EnvironBuilder.server_protocol", "path": "test/index#werkzeug.test.EnvironBuilder.server_protocol", "type": "werkzeug.test", "text": "\nthe server protocol to use. defaults to HTTP/1.1\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "EnvironBuilder.wsgi_version", "path": "test/index#werkzeug.test.EnvironBuilder.wsgi_version", "type": "werkzeug.test", "text": "\nthe wsgi version to use. defaults to (1, 0)\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "EnvironHeaders", "path": "datastructures/index#werkzeug.datastructures.EnvironHeaders", "type": "werkzeug.datastructures", "text": "\nRead only version of the headers from a WSGI environment. This provides the\nsame interface as `Headers` and is constructed from a WSGI environment.\n\nFrom Werkzeug 0.3 onwards, the `KeyError` raised by this class is also a\nsubclass of the `BadRequest` HTTP exception and will render a page for a `400\nBAD REQUEST` if caught in a catch-all for HTTP exceptions.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "environ_property", "path": "utils/index#werkzeug.utils.environ_property", "type": "werkzeug.utils", "text": "\nMaps request attributes to environment variables. This works not only for the\nWerkzeug request object, but also any other class with an environ attribute:\n\nIf you pass it a second value it\u2019s used as default if the key does not exist,\nthe third one can be a converter that takes a value and converts it. If it\nraises `ValueError` or `TypeError` the default value is used. If no default\nvalue is provided `None` is used.\n\nPer default the property is read only. You have to explicitly enable it by\npassing `read_only=False` to the constructor.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "escape()", "path": "utils/index#werkzeug.utils.escape", "type": "werkzeug.utils", "text": "\nReplace `&`, `<`, `>`, `\"`, and `'` with HTML-safe sequences.\n\n`None` is escaped to an empty string.\n\nDeprecated since version 2.0: Will be removed in Werkzeug 2.1. Use MarkupSafe\ninstead.\n\ns (Any) \u2013\n\nstr\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "ETags", "path": "datastructures/index#werkzeug.datastructures.ETags", "type": "werkzeug.datastructures", "text": "\nA set that can be used to check if one etag is present in a collection of\netags.\n\nConvert the `ETags` object into a python set. Per default all the weak etags\nare not part of this set.\n\nCheck if an etag is part of the set ignoring weak tags. It is also possible to\nuse the `in` operator.\n\nWhen passed a quoted tag it will check if this tag is part of the set. If the\ntag is weak it is checked against weak and strong tags, otherwise strong only.\n\nCheck if an etag is part of the set including weak and strong tags.\n\nCheck if an etag is strong.\n\nCheck if an etag is weak.\n\nConvert the etags set into a HTTP header string.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "ETags.as_set()", "path": "datastructures/index#werkzeug.datastructures.ETags.as_set", "type": "werkzeug.datastructures", "text": "\nConvert the `ETags` object into a python set. Per default all the weak etags\nare not part of this set.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "ETags.contains()", "path": "datastructures/index#werkzeug.datastructures.ETags.contains", "type": "werkzeug.datastructures", "text": "\nCheck if an etag is part of the set ignoring weak tags. It is also possible to\nuse the `in` operator.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "ETags.contains_raw()", "path": "datastructures/index#werkzeug.datastructures.ETags.contains_raw", "type": "werkzeug.datastructures", "text": "\nWhen passed a quoted tag it will check if this tag is part of the set. If the\ntag is weak it is checked against weak and strong tags, otherwise strong only.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "ETags.contains_weak()", "path": "datastructures/index#werkzeug.datastructures.ETags.contains_weak", "type": "werkzeug.datastructures", "text": "\nCheck if an etag is part of the set including weak and strong tags.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "ETags.is_strong()", "path": "datastructures/index#werkzeug.datastructures.ETags.is_strong", "type": "werkzeug.datastructures", "text": "\nCheck if an etag is strong.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "ETags.is_weak()", "path": "datastructures/index#werkzeug.datastructures.ETags.is_weak", "type": "werkzeug.datastructures", "text": "\nCheck if an etag is weak.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "ETags.to_header()", "path": "datastructures/index#werkzeug.datastructures.ETags.to_header", "type": "werkzeug.datastructures", "text": "\nConvert the etags set into a HTTP header string.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "extract_path_info()", "path": "wsgi/index#werkzeug.wsgi.extract_path_info", "type": "werkzeug.wsgi", "text": "\nExtracts the path info from the given URL (or WSGI environment) and path. The\npath info returned is a string. The URLs might also be IRIs.\n\nIf the path info could not be determined, `None` is returned.\n\nSome examples:\n\nInstead of providing a base URL you can also pass a WSGI environment.\n\nOptional[str]\n\nChanged in version 0.15: The `errors` parameter defaults to leaving invalid\nbytes quoted instead of replacing them.\n\nNew in version 0.6.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "FastCGI", "path": "deployment/fastcgi/index", "type": "Other", "text": "\nA very popular deployment setup on servers like lighttpd and nginx is FastCGI.\nTo use your WSGI application with any of them you will need a FastCGI server\nfirst.\n\nThe most popular one is flup which we will use for this guide. Make sure to\nhave it installed.\n\nFirst you need to create the FastCGI server file. Let\u2019s call it\n`yourapplication.fcgi`:\n\nThis is enough for Apache to work, however ngingx and older versions of\nlighttpd need a socket to be explicitly passed to communicate with the FastCGI\nserver. For that to work you need to pass the path to the socket to the\n`WSGIServer`:\n\nThe path has to be the exact same path you define in the server config.\n\nSave the `yourapplication.fcgi` file somewhere you will find it again. It\nmakes sense to have that in `/var/www/yourapplication` or something similar.\n\nMake sure to set the executable bit on that file so that the servers can\nexecute it:\n\nA basic FastCGI configuration for lighttpd looks like this:\n\nRemember to enable the FastCGI, alias and rewrite modules. This configuration\nbinds the application to `/yourapplication`.\n\nSee the Lighty docs for more information on FastCGI and Python.\n\nInstalling FastCGI applications on nginx is a bit tricky because by default\nsome FastCGI parameters are not properly forwarded.\n\nA basic FastCGI configuration for nginx looks like this:\n\nThis configuration binds the application to `/yourapplication`. If you want to\nhave it in the URL root it\u2019s a bit easier because you don\u2019t have to figure out\nhow to calculate `PATH_INFO` and `SCRIPT_NAME`:\n\nSince Nginx doesn\u2019t load FastCGI apps, you have to do it by yourself. You can\neither write an `init.d` script for that or execute it inside a screen\nsession:\n\nFastCGI deployments tend to be hard to debug on most webservers. Very often\nthe only thing the server log tells you is something along the lines of\n\u201cpremature end of headers\u201d. In order to debug the application the only thing\nthat can really give you ideas why it breaks is switching to the correct user\nand executing the application by hand.\n\nThis example assumes your application is called `application.fcgi` and that\nyour webserver user is `www-data`:\n\nIn this case the error seems to be \u201cyourapplication\u201d not being on the python\npath. Common problems are:\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "FileMultiDict", "path": "datastructures/index#werkzeug.datastructures.FileMultiDict", "type": "werkzeug.datastructures", "text": "\nA special `MultiDict` that has convenience methods to add files to it. This is\nused for `EnvironBuilder` and generally useful for unittesting.\n\nNew in version 0.5.\n\nAdds a new file to the dict. `file` can be a file name or a `file`-like or a\n`FileStorage` object.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "FileMultiDict.add_file()", "path": "datastructures/index#werkzeug.datastructures.FileMultiDict.add_file", "type": "werkzeug.datastructures", "text": "\nAdds a new file to the dict. `file` can be a file name or a `file`-like or a\n`FileStorage` object.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "FileStorage", "path": "datastructures/index#werkzeug.datastructures.FileStorage", "type": "werkzeug.datastructures", "text": "\nThe `FileStorage` class is a thin wrapper over incoming files. It is used by\nthe request object to represent uploaded files. All the attributes of the\nwrapper stream are proxied by the file storage so it\u2019s possible to do\n`storage.read()` instead of the long form `storage.stream.read()`.\n\nThe input stream for the uploaded file. This usually points to an open\ntemporary file.\n\nThe filename of the file on the client.\n\nThe name of the form field.\n\nThe multipart headers as `Headers` object. This usually contains irrelevant\ninformation but in combination with custom multipart requests the raw headers\nmight be interesting.\n\nNew in version 0.6.\n\nClose the underlying file if possible.\n\nThe content-length sent in the header. Usually not available\n\nThe content-type sent in the header. Usually not available\n\nLike `content_type`, but without parameters (eg, without charset, type etc.)\nand always lowercase. For example if the content type is `text/HTML;\ncharset=utf-8` the mimetype would be `'text/html'`.\n\nNew in version 0.7.\n\nThe mimetype parameters as dict. For example if the content type is\n`text/html; charset=utf-8` the params would be `{'charset': 'utf-8'}`.\n\nNew in version 0.7.\n\nSave the file to a destination path or file object. If the destination is a\nfile object you have to close it yourself after the call. The buffer size is\nthe number of bytes held in memory during the copy process. It defaults to\n16KB.\n\nFor secure file saving also have a look at `secure_filename()`.\n\nChanged in version 1.0: Supports `pathlib`.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "FileStorage.close()", "path": "datastructures/index#werkzeug.datastructures.FileStorage.close", "type": "werkzeug.datastructures", "text": "\nClose the underlying file if possible.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "FileStorage.filename", "path": "datastructures/index#werkzeug.datastructures.FileStorage.filename", "type": "werkzeug.datastructures", "text": "\nThe filename of the file on the client.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "FileStorage.headers", "path": "datastructures/index#werkzeug.datastructures.FileStorage.headers", "type": "werkzeug.datastructures", "text": "\nThe multipart headers as `Headers` object. This usually contains irrelevant\ninformation but in combination with custom multipart requests the raw headers\nmight be interesting.\n\nNew in version 0.6.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "FileStorage.name", "path": "datastructures/index#werkzeug.datastructures.FileStorage.name", "type": "werkzeug.datastructures", "text": "\nThe name of the form field.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "FileStorage.save()", "path": "datastructures/index#werkzeug.datastructures.FileStorage.save", "type": "werkzeug.datastructures", "text": "\nSave the file to a destination path or file object. If the destination is a\nfile object you have to close it yourself after the call. The buffer size is\nthe number of bytes held in memory during the copy process. It defaults to\n16KB.\n\nFor secure file saving also have a look at `secure_filename()`.\n\nChanged in version 1.0: Supports `pathlib`.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "FileStorage.stream", "path": "datastructures/index#werkzeug.datastructures.FileStorage.stream", "type": "werkzeug.datastructures", "text": "\nThe input stream for the uploaded file. This usually points to an open\ntemporary file.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Filesystem Utilities", "path": "filesystem/index", "type": "Other", "text": "\nVarious utilities for the local filesystem.\n\nThe warning used by Werkzeug to signal a broken filesystem. Will only be used\nonce per runtime.\n\nReturns the filesystem encoding that should be used. Note that this is\ndifferent from the Python understanding of the filesystem encoding which might\nbe deeply flawed. Do not use this value against Python\u2019s string APIs because\nit might be different. See The Filesystem for the exact behavior.\n\nThe concept of a filesystem encoding in generally is not something you should\nrely on. As such if you ever need to use this function except for writing\nwrapper code reconsider.\n\nstr\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "FileWrapper", "path": "wsgi/index#werkzeug.wsgi.FileWrapper", "type": "werkzeug.wsgi", "text": "\nThis class can be used to convert a `file`-like object into an iterable. It\nyields `buffer_size` blocks until the file is fully read.\n\nYou should not use this class directly but rather use the `wrap_file()`\nfunction that uses the WSGI server\u2019s file wrapper support if it\u2019s available.\n\nNew in version 0.5.\n\nIf you\u2019re using this object together with a `Response` you have to use the\n`direct_passthrough` mode.\n\nNone\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "find_modules()", "path": "utils/index#werkzeug.utils.find_modules", "type": "werkzeug.utils", "text": "\nFinds all the modules below a package. This can be useful to automatically\nimport all views / controllers so that their metaclasses / function decorators\nhave a chance to register themselves on the application.\n\nPackages are not returned unless `include_packages` is `True`. This can also\nrecursively list modules but in that case it will import all the packages to\nget the correct load path of that module.\n\ngenerator\n\nIterator[str]\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "FloatConverter", "path": "routing/index#werkzeug.routing.FloatConverter", "type": "werkzeug.routing", "text": "\nThis converter only accepts floating point values:\n\nBy default it only accepts unsigned, positive values. The `signed` parameter\nwill enable signed, negative values.\n\nNone\n\nNew in version 0.15: The `signed` parameter.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "FormDataParser", "path": "http/index#werkzeug.formparser.FormDataParser", "type": "werkzeug.formparser", "text": "\nThis class implements parsing of form data for Werkzeug. By itself it can\nparse multipart and url encoded form data. It can be subclassed and extended\nbut for most mimetypes it is a better idea to use the untouched stream and\nexpose it as separate attributes on a request object.\n\nNew in version 0.8.\n\nNone\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "generate_etag()", "path": "http/index#werkzeug.http.generate_etag", "type": "werkzeug.http", "text": "\nGenerate an etag for some data.\n\nChanged in version 2.0: Use SHA-1. MD5 may not be available in some\nenvironments.\n\ndata (bytes) \u2013\n\nstr\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "generate_password_hash()", "path": "utils/index#werkzeug.security.generate_password_hash", "type": "werkzeug.security", "text": "\nHash a password with the given method and salt with a string of the given\nlength. The format of the string returned includes the method that was used so\nthat `check_password_hash()` can check the hash.\n\nThe format for the hashed string looks like this:\n\nThis method can not generate unsalted passwords but it is possible to set\nparam method=\u2019plain\u2019 in order to enforce plaintext passwords. If a salt is\nused, hmac is used internally to salt the password.\n\nIf PBKDF2 is wanted it can be enabled by setting the method to\n`pbkdf2:method:iterations` where iterations is optional:\n\nstr\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "get_content_length()", "path": "wsgi/index#werkzeug.wsgi.get_content_length", "type": "werkzeug.wsgi", "text": "\nReturns the content length from the WSGI environment as integer. If it\u2019s not\navailable or chunked transfer encoding is used, `None` is returned.\n\nNew in version 0.9.\n\nenviron (WSGIEnvironment) \u2013 the WSGI environ to fetch the content length from.\n\nOptional[int]\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "get_current_url()", "path": "wsgi/index#werkzeug.wsgi.get_current_url", "type": "werkzeug.wsgi", "text": "\nRecreate the URL for a request from the parts in a WSGI environment.\n\nThe URL is an IRI, not a URI, so it may contain Unicode characters. Use\n`iri_to_uri()` to convert it to ASCII.\n\nstr\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "get_filesystem_encoding()", "path": "filesystem/index#werkzeug.filesystem.get_filesystem_encoding", "type": "werkzeug.filesystem", "text": "\nReturns the filesystem encoding that should be used. Note that this is\ndifferent from the Python understanding of the filesystem encoding which might\nbe deeply flawed. Do not use this value against Python\u2019s string APIs because\nit might be different. See The Filesystem for the exact behavior.\n\nThe concept of a filesystem encoding in generally is not something you should\nrely on. As such if you ever need to use this function except for writing\nwrapper code reconsider.\n\nstr\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "get_host()", "path": "wsgi/index#werkzeug.wsgi.get_host", "type": "werkzeug.wsgi", "text": "\nReturn the host for the given WSGI environment.\n\nThe `Host` header is preferred, then `SERVER_NAME` if it\u2019s not set. The\nreturned host will only contain the port if it is different than the standard\nport for the protocol.\n\nOptionally, verify that the host is trusted using `host_is_trusted()` and\nraise a `SecurityError` if it is not.\n\nHost, with port if necessary.\n\nSecurityError \u2013 If the host is not trusted.\n\nstr\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "get_input_stream()", "path": "wsgi/index#werkzeug.wsgi.get_input_stream", "type": "werkzeug.wsgi", "text": "\nReturns the input stream from the WSGI environment and wraps it in the most\nsensible way possible. The stream returned is not the raw WSGI stream in most\ncases but one that is safe to read from without taking into account the\ncontent length.\n\nIf content length is not set, the stream will be empty for safety reasons. If\nthe WSGI server supports chunked or infinite streams, it should set the\n`wsgi.input_terminated` value in the WSGI environ to indicate that.\n\nNew in version 0.9.\n\nBinaryIO\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "get_path_info()", "path": "wsgi/index#werkzeug.wsgi.get_path_info", "type": "werkzeug.wsgi", "text": "\nReturn the `PATH_INFO` from the WSGI environment and decode it unless\n`charset` is `None`.\n\nstr\n\nNew in version 0.9.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "get_query_string()", "path": "wsgi/index#werkzeug.wsgi.get_query_string", "type": "werkzeug.wsgi", "text": "\nReturns the `QUERY_STRING` from the WSGI environment. This also takes care of\nthe WSGI decoding dance. The string returned will be restricted to ASCII\ncharacters.\n\nenviron (WSGIEnvironment) \u2013 WSGI environment to get the query string from.\n\nstr\n\nNew in version 0.9.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "get_script_name()", "path": "wsgi/index#werkzeug.wsgi.get_script_name", "type": "werkzeug.wsgi", "text": "\nReturn the `SCRIPT_NAME` from the WSGI environment and decode it unless\n`charset` is set to `None`.\n\nstr\n\nNew in version 0.9.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Headers", "path": "datastructures/index#werkzeug.datastructures.Headers", "type": "werkzeug.datastructures", "text": "\nAn object that stores some headers. It has a dict-like interface, but is\nordered, can store the same key multiple times, and iterating yields `(key,\nvalue)` pairs instead of only keys.\n\nThis data structure is useful if you want a nicer way to handle WSGI headers\nwhich are stored as tuples in a list.\n\nFrom Werkzeug 0.3 onwards, the `KeyError` raised by this class is also a\nsubclass of the `BadRequest` HTTP exception and will render a page for a `400\nBAD REQUEST` if caught in a catch-all for HTTP exceptions.\n\nHeaders is mostly compatible with the Python `wsgiref.headers.Headers` class,\nwith the exception of `__getitem__`. `wsgiref` will return `None` for\n`headers['missing']`, whereas `Headers` will raise a `KeyError`.\n\nTo create a new `Headers` object pass it a list or dict of headers which are\nused as default values. This does not reuse the list passed to the constructor\nfor internal usage.\n\ndefaults \u2013 The list of default values for the `Headers`.\n\nChanged in version 0.9: This data structure now stores unicode values similar\nto how the multi dicts do it. The main difference is that bytes can be set as\nwell which will automatically be latin1 decoded.\n\nChanged in version 0.9: The `linked()` function was removed without\nreplacement as it was an API that does not support the changes to the encoding\nmodel.\n\nAdd a new header tuple to the list.\n\nKeyword arguments can specify additional parameters for the header value, with\nunderscores converted to dashes:\n\nThe keyword argument dumping uses `dump_options_header()` behind the scenes.\n\nNew in version 0.4.1: keyword arguments were added for `wsgiref`\ncompatibility.\n\nAdd a new header tuple to the list.\n\nAn alias for `add()` for compatibility with the `wsgiref` `add_header()`\nmethod.\n\nClears all headers.\n\nExtend headers in this object with items from another object containing header\nitems as well as keyword arguments.\n\nTo replace existing keys instead of extending, use `update()` instead.\n\nIf provided, the first argument can be another `Headers` object, a\n`MultiDict`, `dict`, or iterable of pairs.\n\nChanged in version 1.0: Support `MultiDict`. Allow passing `kwargs`.\n\nReturn the default value if the requested data doesn\u2019t exist. If `type` is\nprovided and is a callable it should convert the value, return it or raise a\n`ValueError` if that is not possible. In this case the function will return\nthe default as if the value was not found:\n\nNew in version 0.9: Added support for `as_bytes`.\n\nReturn a list of all the values for the named field.\n\nThis method is compatible with the `wsgiref` `get_all()` method.\n\nReturn the list of items for a given key. If that key is not in the `Headers`,\nthe return value will be an empty list. Just like `get()`, `getlist()` accepts\na `type` parameter. All items will be converted with the callable defined\nthere.\n\nNew in version 0.9: Added support for `as_bytes`.\n\na `list` of all the values for the key.\n\nDeprecated since version 2.0: Will be removed in Werkzeug 2.1. Use `key in\ndata` instead.\n\nRemoves and returns a key or index.\n\nkey \u2013 The key to be popped. If this is an integer the item at that position is\nremoved, if it\u2019s a string the value for that key is. If the key is omitted or\n`None` the last item is removed.\n\nan item.\n\nRemoves a key or index and returns a (key, value) item.\n\nRemove a key.\n\nkey \u2013 The key to be removed.\n\nRemove all header tuples for `key` and add a new one. The newly added key\neither appears at the end of the list if there was no entry or replaces the\nfirst one.\n\nKeyword arguments can specify additional parameters for the header value, with\nunderscores converted to dashes. See `add()` for more information.\n\nChanged in version 0.6.1: `set()` now accepts the same arguments as `add()`.\n\nReturn the first value for the key if it is in the headers, otherwise set the\nheader to the value given by `default` and return that.\n\nRemove any existing values for a header and add new ones.\n\nNew in version 1.0.\n\nReturn the list of values for the key if it is in the headers, otherwise set\nthe header to the list of values given by `default` and return that.\n\nUnlike `MultiDict.setlistdefault()`, modifying the returned list will not\naffect the headers.\n\nNew in version 1.0.\n\nConvert the headers into a list suitable for WSGI.\n\nlist\n\nReplace headers in this object with items from another headers object and\nkeyword arguments.\n\nTo extend existing keys instead of replacing, use `extend()` instead.\n\nIf provided, the first argument can be another `Headers` object, a\n`MultiDict`, `dict`, or iterable of pairs.\n\nNew in version 1.0.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Headers.add()", "path": "datastructures/index#werkzeug.datastructures.Headers.add", "type": "werkzeug.datastructures", "text": "\nAdd a new header tuple to the list.\n\nKeyword arguments can specify additional parameters for the header value, with\nunderscores converted to dashes:\n\nThe keyword argument dumping uses `dump_options_header()` behind the scenes.\n\nNew in version 0.4.1: keyword arguments were added for `wsgiref`\ncompatibility.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Headers.add_header()", "path": "datastructures/index#werkzeug.datastructures.Headers.add_header", "type": "werkzeug.datastructures", "text": "\nAdd a new header tuple to the list.\n\nAn alias for `add()` for compatibility with the `wsgiref` `add_header()`\nmethod.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Headers.clear()", "path": "datastructures/index#werkzeug.datastructures.Headers.clear", "type": "werkzeug.datastructures", "text": "\nClears all headers.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Headers.extend()", "path": "datastructures/index#werkzeug.datastructures.Headers.extend", "type": "werkzeug.datastructures", "text": "\nExtend headers in this object with items from another object containing header\nitems as well as keyword arguments.\n\nTo replace existing keys instead of extending, use `update()` instead.\n\nIf provided, the first argument can be another `Headers` object, a\n`MultiDict`, `dict`, or iterable of pairs.\n\nChanged in version 1.0: Support `MultiDict`. Allow passing `kwargs`.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Headers.get()", "path": "datastructures/index#werkzeug.datastructures.Headers.get", "type": "werkzeug.datastructures", "text": "\nReturn the default value if the requested data doesn\u2019t exist. If `type` is\nprovided and is a callable it should convert the value, return it or raise a\n`ValueError` if that is not possible. In this case the function will return\nthe default as if the value was not found:\n\nNew in version 0.9: Added support for `as_bytes`.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Headers.getlist()", "path": "datastructures/index#werkzeug.datastructures.Headers.getlist", "type": "werkzeug.datastructures", "text": "\nReturn the list of items for a given key. If that key is not in the `Headers`,\nthe return value will be an empty list. Just like `get()`, `getlist()` accepts\na `type` parameter. All items will be converted with the callable defined\nthere.\n\nNew in version 0.9: Added support for `as_bytes`.\n\na `list` of all the values for the key.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Headers.get_all()", "path": "datastructures/index#werkzeug.datastructures.Headers.get_all", "type": "werkzeug.datastructures", "text": "\nReturn a list of all the values for the named field.\n\nThis method is compatible with the `wsgiref` `get_all()` method.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Headers.has_key()", "path": "datastructures/index#werkzeug.datastructures.Headers.has_key", "type": "werkzeug.datastructures", "text": "\nDeprecated since version 2.0: Will be removed in Werkzeug 2.1. Use `key in\ndata` instead.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Headers.pop()", "path": "datastructures/index#werkzeug.datastructures.Headers.pop", "type": "werkzeug.datastructures", "text": "\nRemoves and returns a key or index.\n\nkey \u2013 The key to be popped. If this is an integer the item at that position is\nremoved, if it\u2019s a string the value for that key is. If the key is omitted or\n`None` the last item is removed.\n\nan item.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Headers.popitem()", "path": "datastructures/index#werkzeug.datastructures.Headers.popitem", "type": "werkzeug.datastructures", "text": "\nRemoves a key or index and returns a (key, value) item.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Headers.remove()", "path": "datastructures/index#werkzeug.datastructures.Headers.remove", "type": "werkzeug.datastructures", "text": "\nRemove a key.\n\nkey \u2013 The key to be removed.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Headers.set()", "path": "datastructures/index#werkzeug.datastructures.Headers.set", "type": "werkzeug.datastructures", "text": "\nRemove all header tuples for `key` and add a new one. The newly added key\neither appears at the end of the list if there was no entry or replaces the\nfirst one.\n\nKeyword arguments can specify additional parameters for the header value, with\nunderscores converted to dashes. See `add()` for more information.\n\nChanged in version 0.6.1: `set()` now accepts the same arguments as `add()`.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Headers.setdefault()", "path": "datastructures/index#werkzeug.datastructures.Headers.setdefault", "type": "werkzeug.datastructures", "text": "\nReturn the first value for the key if it is in the headers, otherwise set the\nheader to the value given by `default` and return that.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Headers.setlist()", "path": "datastructures/index#werkzeug.datastructures.Headers.setlist", "type": "werkzeug.datastructures", "text": "\nRemove any existing values for a header and add new ones.\n\nNew in version 1.0.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Headers.setlistdefault()", "path": "datastructures/index#werkzeug.datastructures.Headers.setlistdefault", "type": "werkzeug.datastructures", "text": "\nReturn the list of values for the key if it is in the headers, otherwise set\nthe header to the list of values given by `default` and return that.\n\nUnlike `MultiDict.setlistdefault()`, modifying the returned list will not\naffect the headers.\n\nNew in version 1.0.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Headers.to_wsgi_list()", "path": "datastructures/index#werkzeug.datastructures.Headers.to_wsgi_list", "type": "werkzeug.datastructures", "text": "\nConvert the headers into a list suitable for WSGI.\n\nlist\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Headers.update()", "path": "datastructures/index#werkzeug.datastructures.Headers.update", "type": "werkzeug.datastructures", "text": "\nReplace headers in this object with items from another headers object and\nkeyword arguments.\n\nTo extend existing keys instead of replacing, use `extend()` instead.\n\nIf provided, the first argument can be another `Headers` object, a\n`MultiDict`, `dict`, or iterable of pairs.\n\nNew in version 1.0.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "HeaderSet", "path": "datastructures/index#werkzeug.datastructures.HeaderSet", "type": "werkzeug.datastructures", "text": "\nSimilar to the `ETags` class this implements a set-like structure. Unlike\n`ETags` this is case insensitive and used for vary, allow, and content-\nlanguage headers.\n\nIf not constructed using the `parse_set_header()` function the instantiation\nworks like this:\n\nAdd a new header to the set.\n\nReturn the set as real python set type. When calling this, all the items are\nconverted to lowercase and the ordering is lost.\n\npreserve_casing \u2013 if set to `True` the items in the set returned will have the\noriginal case like in the `HeaderSet`, otherwise they will be lowercase.\n\nClear the set.\n\nLike `remove()` but ignores errors.\n\nheader \u2013 the header to be discarded.\n\nReturn the index of the header in the set or return -1 if not found.\n\nheader \u2013 the header to be looked up.\n\nReturn the index of the header in the set or raise an `IndexError`.\n\nheader \u2013 the header to be looked up.\n\nRemove a header from the set. This raises an `KeyError` if the header is not\nin the set.\n\nChanged in version 0.5: In older versions a `IndexError` was raised instead of\na `KeyError` if the object was missing.\n\nheader \u2013 the header to be removed.\n\nConvert the header set into an HTTP header string.\n\nAdd all the headers from the iterable to the set.\n\niterable \u2013 updates the set with the items from the iterable.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "HeaderSet.add()", "path": "datastructures/index#werkzeug.datastructures.HeaderSet.add", "type": "werkzeug.datastructures", "text": "\nAdd a new header to the set.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "HeaderSet.as_set()", "path": "datastructures/index#werkzeug.datastructures.HeaderSet.as_set", "type": "werkzeug.datastructures", "text": "\nReturn the set as real python set type. When calling this, all the items are\nconverted to lowercase and the ordering is lost.\n\npreserve_casing \u2013 if set to `True` the items in the set returned will have the\noriginal case like in the `HeaderSet`, otherwise they will be lowercase.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "HeaderSet.clear()", "path": "datastructures/index#werkzeug.datastructures.HeaderSet.clear", "type": "werkzeug.datastructures", "text": "\nClear the set.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "HeaderSet.discard()", "path": "datastructures/index#werkzeug.datastructures.HeaderSet.discard", "type": "werkzeug.datastructures", "text": "\nLike `remove()` but ignores errors.\n\nheader \u2013 the header to be discarded.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "HeaderSet.find()", "path": "datastructures/index#werkzeug.datastructures.HeaderSet.find", "type": "werkzeug.datastructures", "text": "\nReturn the index of the header in the set or return -1 if not found.\n\nheader \u2013 the header to be looked up.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "HeaderSet.index()", "path": "datastructures/index#werkzeug.datastructures.HeaderSet.index", "type": "werkzeug.datastructures", "text": "\nReturn the index of the header in the set or raise an `IndexError`.\n\nheader \u2013 the header to be looked up.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "HeaderSet.remove()", "path": "datastructures/index#werkzeug.datastructures.HeaderSet.remove", "type": "werkzeug.datastructures", "text": "\nRemove a header from the set. This raises an `KeyError` if the header is not\nin the set.\n\nChanged in version 0.5: In older versions a `IndexError` was raised instead of\na `KeyError` if the object was missing.\n\nheader \u2013 the header to be removed.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "HeaderSet.to_header()", "path": "datastructures/index#werkzeug.datastructures.HeaderSet.to_header", "type": "werkzeug.datastructures", "text": "\nConvert the header set into an HTTP header string.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "HeaderSet.update()", "path": "datastructures/index#werkzeug.datastructures.HeaderSet.update", "type": "werkzeug.datastructures", "text": "\nAdd all the headers from the iterable to the set.\n\niterable \u2013 updates the set with the items from the iterable.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "header_property", "path": "utils/index#werkzeug.utils.header_property", "type": "werkzeug.utils", "text": "\nLike `environ_property` but for headers.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "host_is_trusted()", "path": "wsgi/index#werkzeug.wsgi.host_is_trusted", "type": "werkzeug.wsgi", "text": "\nCheck if a host matches a list of trusted names.\n\nbool\n\nNew in version 0.9.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Href", "path": "urls/index#werkzeug.urls.Href", "type": "werkzeug.urls", "text": "\nImplements a callable that constructs URLs with the given base. The function\ncan be called with any number of positional and keyword arguments which than\nare used to assemble the URL. Works with URLs and posix paths.\n\nPositional arguments are appended as individual segments to the path of the\nURL:\n\nIf any of the arguments (positional or keyword) evaluates to `None` it will be\nskipped. If no keyword arguments are given the last argument can be a `dict`\nor `MultiDict` (or any other dict subclass), otherwise the keyword arguments\nare used for the query parameters, cutting off the first trailing underscore\nof the parameter name:\n\nCombining of both methods is not allowed:\n\nAccessing attributes on the href object creates a new href object with the\nattribute name as prefix:\n\nIf `sort` is set to `True` the items are sorted by `key` or the default\nsorting algorithm:\n\nDeprecated since version 2.0: Will be removed in Werkzeug 2.1. Use\n`werkzeug.routing` instead.\n\nNew in version 0.5: `sort` and `key` were added.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "HTMLBuilder", "path": "utils/index#werkzeug.utils.HTMLBuilder", "type": "werkzeug.utils", "text": "\nHelper object for HTML generation.\n\nPer default there are two instances of that class. The `html` one, and the\n`xhtml` one for those two dialects. The class uses keyword parameters and\npositional parameters to generate small snippets of HTML.\n\nKeyword parameters are converted to XML/SGML attributes, positional arguments\nare used as children. Because Python accepts positional arguments before\nkeyword arguments it\u2019s a good idea to use a list with the star-syntax for some\nchildren:\n\nThis class works around some browser limitations and can not be used for\narbitrary SGML/XML generation. For that purpose lxml and similar libraries\nexist.\n\nCalling the builder escapes the string passed:\n\nDeprecated since version 2.0: Will be removed in Werkzeug 2.1.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "HTTP Exceptions", "path": "exceptions/index", "type": "Other", "text": "\nImplements a number of Python exceptions which can be raised from within a\nview to trigger a standard HTTP non-200 response.\n\nAs you can see from this example those exceptions are callable WSGI\napplications. However, they are not Werkzeug response objects. You can get a\nresponse object by calling `get_response()` on a HTTP exception.\n\nKeep in mind that you may have to pass an environ (WSGI) or scope (ASGI) to\n`get_response()` because some errors fetch additional information relating to\nthe request.\n\nIf you want to hook in a different exception page to say, a 404 status code,\nyou can add a second except for a specific subclass of an error:\n\nThe following error classes exist in Werkzeug:\n\n400 `Bad Request`\n\nRaise if the browser sends something to the application the application or\nserver cannot handle.\n\nNone\n\n401 `Unauthorized`\n\nRaise if the user is not authorized to access a resource.\n\nThe `www_authenticate` argument should be used to set the `WWW-Authenticate`\nheader. This is used for HTTP basic auth and other schemes. Use\n`WWWAuthenticate` to create correctly formatted values. Strictly speaking a\n401 response is invalid if it doesn\u2019t provide at least one value for this\nheader, although real clients typically don\u2019t care.\n\nNone\n\nChanged in version 2.0: Serialize multiple `www_authenticate` items into\nmultiple `WWW-Authenticate` headers, rather than joining them into a single\nvalue, for better interoperability.\n\nChanged in version 0.15.3: If the `www_authenticate` argument is not set, the\n`WWW-Authenticate` header is not set.\n\nChanged in version 0.15.3: The `response` argument was restored.\n\nChanged in version 0.15.1: `description` was moved back as the first argument,\nrestoring its previous position.\n\nChanged in version 0.15.0: `www_authenticate` was added as the first argument,\nahead of `description`.\n\n403 `Forbidden`\n\nRaise if the user doesn\u2019t have the permission for the requested resource but\nwas authenticated.\n\nNone\n\n404 `Not Found`\n\nRaise if a resource does not exist and never existed.\n\nNone\n\n405 `Method Not Allowed`\n\nRaise if the server used a method the resource does not handle. For example\n`POST` if the resource is view only. Especially useful for REST.\n\nThe first argument for this exception should be a list of allowed methods.\nStrictly speaking the response would be invalid if you don\u2019t provide valid\nmethods in the header which you can do with that list.\n\nTakes an optional list of valid http methods starting with werkzeug 0.3 the\nlist will be mandatory.\n\nNone\n\n406 `Not Acceptable`\n\nRaise if the server can\u2019t return any content conforming to the `Accept`\nheaders of the client.\n\nNone\n\n408 `Request Timeout`\n\nRaise to signalize a timeout.\n\nNone\n\n409 `Conflict`\n\nRaise to signal that a request cannot be completed because it conflicts with\nthe current state on the server.\n\nNew in version 0.7.\n\nNone\n\n410 `Gone`\n\nRaise if a resource existed previously and went away without new location.\n\nNone\n\n411 `Length Required`\n\nRaise if the browser submitted data but no `Content-Length` header which is\nrequired for the kind of processing the server does.\n\nNone\n\n412 `Precondition Failed`\n\nStatus code used in combination with `If-Match`, `If-None-Match`, or `If-\nUnmodified-Since`.\n\nNone\n\n413 `Request Entity Too Large`\n\nThe status code one should return if the data submitted exceeded a given\nlimit.\n\nNone\n\n414 `Request URI Too Large`\n\nLike 413 but for too long URLs.\n\nNone\n\n415 `Unsupported Media Type`\n\nThe status code returned if the server is unable to handle the media type the\nclient transmitted.\n\nNone\n\n416 `Requested Range Not Satisfiable`\n\nThe client asked for an invalid part of the file.\n\nNew in version 0.7.\n\nTakes an optional `Content-Range` header value based on `length` parameter.\n\nNone\n\n417 `Expectation Failed`\n\nThe server cannot meet the requirements of the Expect request-header.\n\nNew in version 0.7.\n\nNone\n\n418 `I\u2019m a teapot`\n\nThe server should return this if it is a teapot and someone attempted to brew\ncoffee with it.\n\nNew in version 0.7.\n\nNone\n\n422 `Unprocessable Entity`\n\nUsed if the request is well formed, but the instructions are otherwise\nincorrect.\n\nNone\n\n423 `Locked`\n\nUsed if the resource that is being accessed is locked.\n\nNone\n\n424 `Failed Dependency`\n\nUsed if the method could not be performed on the resource because the\nrequested action depended on another action and that action failed.\n\nNone\n\n428 `Precondition Required`\n\nThe server requires this request to be conditional, typically to prevent the\nlost update problem, which is a race condition between two or more clients\nattempting to update a resource through PUT or DELETE. By requiring each\nclient to include a conditional header (\u201cIf-Match\u201d or \u201cIf-Unmodified- Since\u201d)\nwith the proper value retained from a recent GET request, the server ensures\nthat each client has at least seen the previous revision of the resource.\n\nNone\n\n429 `Too Many Requests`\n\nThe server is limiting the rate at which this user receives responses, and\nthis request exceeds that rate. (The server may use any convenient method to\nidentify users and their request rates). The server may include a \u201cRetry-\nAfter\u201d header to indicate how long the user should wait before retrying.\n\nNone\n\nChanged in version 1.0: Added `retry_after` parameter.\n\n431 `Request Header Fields Too Large`\n\nThe server refuses to process the request because the header fields are too\nlarge. One or more individual fields may be too large, or the set of all\nheaders is too large.\n\nNone\n\n451 `Unavailable For Legal Reasons`\n\nThis status code indicates that the server is denying access to the resource\nas a consequence of a legal demand.\n\nNone\n\n500 `Internal Server Error`\n\nRaise if an internal server error occurred. This is a good fallback if an\nunknown error occurred in the dispatcher.\n\nChanged in version 1.0.0: Added the `original_exception` attribute.\n\nNone\n\nThe original exception that caused this 500 error. Can be used by frameworks\nto provide context when handling unexpected errors.\n\n501 `Not Implemented`\n\nRaise if the application does not support the action requested by the browser.\n\nNone\n\n502 `Bad Gateway`\n\nIf you do proxying in your application you should return this status code if\nyou received an invalid response from the upstream server it accessed in\nattempting to fulfill the request.\n\nNone\n\n503 `Service Unavailable`\n\nStatus code you should return if a service is temporarily unavailable.\n\nNone\n\nChanged in version 1.0: Added `retry_after` parameter.\n\n504 `Gateway Timeout`\n\nStatus code you should return if a connection to an upstream server times out.\n\nNone\n\n505 `HTTP Version Not Supported`\n\nThe server does not support the HTTP protocol version used in the request.\n\nNone\n\nInternal exception that is raised if Werkzeug detects a disconnected client.\nSince the client is already gone at that point attempting to send the error\nmessage to the client might not work and might ultimately result in another\nexception in the server. Mainly this is here so that it is silenced by default\nas far as Werkzeug is concerned.\n\nSince disconnections cannot be reliably detected and are unspecified by WSGI\nto a large extent this might or might not be raised if a client is gone.\n\nNew in version 0.8.\n\nNone\n\nRaised if something triggers a security error. This is otherwise exactly like\na bad request error.\n\nNew in version 0.9.\n\nNone\n\nAll the exceptions implement this common interface:\n\nThe base class for all HTTP exceptions. This exception can be called as a WSGI\napplication to render a default error page or you can catch the subclasses of\nit independently and render nicer error messages.\n\nNone\n\nCall the exception as WSGI application.\n\nIterable[bytes]\n\nGet a response object. If one was passed to the exception it\u2019s returned\ndirectly.\n\na `Response` object or a subclass thereof.\n\nResponse\n\nStarting with Werkzeug 0.3 some of the builtin classes raise exceptions that\nlook like regular python exceptions (eg `KeyError`) but are `BadRequest` HTTP\nexceptions at the same time. This decision was made to simplify a common\npattern where you want to abort if the client tampered with the submitted form\ndata in a way that the application can\u2019t recover properly and should abort\nwith `400 BAD REQUEST`.\n\nAssuming the application catches all HTTP exceptions and reacts to them\nproperly a view function could do the following safely and doesn\u2019t have to\ncheck if the keys exist:\n\nIf `title` or `body` are missing in the form, a special key error will be\nraised which behaves like a `KeyError` but also a `BadRequest` exception.\n\nAn exception that is used to signal both a `KeyError` and a `BadRequest`. Used\nby many of the datastructures.\n\nSometimes it\u2019s convenient to just raise an exception by the error code,\nwithout importing the exception and looking up the name etc. For this purpose\nthere is the `abort()` function.\n\nRaises an `HTTPException` for the given status code or WSGI application.\n\nIf a status code is given, it will be looked up in the list of exceptions and\nwill raise that exception. If passed a WSGI application, it will wrap it in a\nproxy WSGI exception and raise that:\n\nNoReturn\n\nIf you want to use this functionality with custom exceptions you can create an\ninstance of the aborter class:\n\nWhen passed a dict of code -> exception items it can be used as callable that\nraises exceptions. If the first argument to the callable is an integer it will\nbe looked up in the mapping, if it\u2019s a WSGI application it will be raised in a\nproxy exception.\n\nThe rest of the arguments are forwarded to the exception constructor.\n\nNone\n\nAs you can see from the list above not all status codes are available as\nerrors. Especially redirects and other non 200 status codes that do not\nrepresent errors are missing. For redirects you can use the `redirect()`\nfunction from the utilities.\n\nIf you want to add an error yourself you can subclass `HTTPException`:\n\nThis is the minimal code you need for your own exception. If you want to add\nmore logic to the errors you can override the `get_description()`,\n`get_body()`, `get_headers()` and `get_response()` methods. In any case you\nshould have a look at the sourcecode of the exceptions module.\n\nYou can override the default description in the constructor with the\n`description` parameter:\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "HTTP Proxying", "path": "deployment/proxying/index", "type": "Other", "text": "\nMany people prefer using a standalone Python HTTP server and proxying that\nserver via nginx, Apache etc.\n\nA very stable Python server is CherryPy. This part of the documentation shows\nyou how to combine your WSGI application with the CherryPy WSGI server and how\nto configure the webserver for proxying.\n\nTo run your application you need a `start-server.py` file that starts up the\nWSGI Server.\n\nIt looks something along these lines:\n\nIf you now start the file the server will listen on `localhost:8080`. Keep in\nmind that WSGI applications behave slightly different for proxied setups. If\nyou have not developed your application for proxying in mind, you can apply\nthe `ProxyFix` middleware.\n\nAs an example we show here how to configure nginx to proxy to the server.\n\nThe basic nginx configuration looks like this:\n\nSince Nginx doesn\u2019t start your server for you, you have to do it by yourself.\nYou can either write an `init.d` script for that or execute it inside a screen\nsession:\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "HTTP Utilities", "path": "http/index", "type": "Other", "text": "\nWerkzeug provides a couple of functions to parse and generate HTTP headers\nthat are useful when implementing WSGI middlewares or whenever you are\noperating on a lower level layer. All this functionality is also exposed from\nrequest and response objects.\n\nThese functions simplify working with times in an HTTP context. Werkzeug\nproduces timezone-aware `datetime` objects in UTC. When passing datetime\nobjects to Werkzeug, it assumes any naive datetime is in UTC.\n\nWhen comparing datetime values from Werkzeug, your own datetime objects must\nalso be timezone-aware, or you must make the values from Werkzeug naive.\n\nParse an RFC 2822 date into a timezone-aware `datetime.datetime` object, or\n`None` if parsing fails.\n\nThis is a wrapper for `email.utils.parsedate_to_datetime()`. It returns `None`\nif parsing fails instead of raising an exception, and always returns a\ntimezone-aware datetime object. If the string doesn\u2019t have timezone\ninformation, it is assumed to be UTC.\n\nvalue (Optional[str]) \u2013 A string with a supported date format.\n\nOptional[datetime.datetime]\n\nChanged in version 2.0: Return a timezone-aware datetime object. Use\n`email.utils.parsedate_to_datetime`.\n\nFormat a datetime object or timestamp into an RFC 2822 date string.\n\nThis is a wrapper for `email.utils.format_datetime()`. It assumes naive\ndatetime objects are in UTC instead of raising an exception.\n\ntimestamp (Optional[Union[datetime.datetime, datetime.date, int, float,\ntime.struct_time]]) \u2013 The datetime or timestamp to format. Defaults to the\ncurrent time.\n\nstr\n\nChanged in version 2.0: Use `email.utils.format_datetime`. Accept `date`\nobjects.\n\nFormat a datetime object or timestamp into an RFC 2822 date string for `Set-\nCookie expires`.\n\nDeprecated since version 2.0: Will be removed in Werkzeug 2.1. Use\n`http_date()` instead.\n\nexpires (Optional[Union[datetime.datetime, datetime.date, int, float,\ntime.struct_time]]) \u2013\n\nstr\n\nThe following functions can be used to parse incoming HTTP headers. Because\nPython does not provide data structures with the semantics required by RFC\n2616, Werkzeug implements some custom data structures that are documented\nseparately.\n\nParse a `Content-Type` like header into a tuple with the content type and the\noptions:\n\nThis should not be used to parse `Cache-Control` like headers that use a\nslightly different format. For these headers use the `parse_dict_header()`\nfunction.\n\nChanged in version 0.15: RFC 2231 parameter continuations are handled.\n\nNew in version 0.5.\n\n(mimetype, options) or (mimetype, options, mimetype, options, \u2026) if\nmultiple=True\n\nUnion[Tuple[str, Dict[str, str]], Tuple[Any, \u2026]]\n\nParse a set-like header and return a `HeaderSet` object:\n\nThe return value is an object that treats the items case-insensitively and\nkeeps the order of the items:\n\nTo create a header from the `HeaderSet` again, use the `dump_header()`\nfunction.\n\na `HeaderSet`\n\nwerkzeug.datastructures.HeaderSet\n\nParse lists as described by RFC 2068 Section 2.\n\nIn particular, parse comma-separated lists where the elements of the list may\ninclude quoted-strings. A quoted-string could contain a comma. A non-quoted\nstring could have quotes in the middle. Quotes are removed automatically after\nparsing.\n\nIt basically works like `parse_set_header()` just that items may appear\nmultiple times and case sensitivity is preserved.\n\nThe return value is a standard `list`:\n\nTo create a header from the `list` again, use the `dump_header()` function.\n\nvalue (str) \u2013 a string with a list header.\n\n`list`\n\nList[str]\n\nParse lists of key, value pairs as described by RFC 2068 Section 2 and convert\nthem into a python dict (or any other mapping object created from the type\nwith a dict like interface provided by the `cls` argument):\n\nIf there is no value for a key it will be `None`:\n\nTo create a header from the `dict` again, use the `dump_header()` function.\n\nChanged in version 0.9: Added support for `cls` argument.\n\nan instance of `cls`\n\nDict[str, str]\n\nParses an HTTP Accept-* header. This does not implement a complete valid\nalgorithm but one that supports at least value and quality extraction.\n\nReturns a new `Accept` object (basically a list of `(value, quality)` tuples\nsorted by the quality with some additional accessor methods).\n\nThe second parameter can be a subclass of `Accept` that is created with the\nparsed values and returned.\n\nan instance of `cls`.\n\nwerkzeug.http._TAnyAccept\n\nParse a cache control header. The RFC differs between response and request\ncache control, this method does not. It\u2019s your responsibility to not use the\nwrong control statements.\n\nNew in version 0.5: The `cls` was added. If not specified an immutable\n`RequestCacheControl` is returned.\n\na `cls` object.\n\nwerkzeug.http._TAnyCC\n\nParse an HTTP basic/digest authorization header transmitted by the web\nbrowser. The return value is either `None` if the header was invalid or not\ngiven, otherwise an `Authorization` object.\n\nvalue (Optional[str]) \u2013 the authorization header to parse.\n\na `Authorization` object or `None`.\n\nOptional[werkzeug.datastructures.Authorization]\n\nParse an HTTP WWW-Authenticate header into a `WWWAuthenticate` object.\n\na `WWWAuthenticate` object.\n\nwerkzeug.datastructures.WWWAuthenticate\n\nParses an if-range header which can be an etag or a date. Returns a `IfRange`\nobject.\n\nChanged in version 2.0: If the value represents a datetime, it is timezone-\naware.\n\nNew in version 0.7.\n\nvalue (Optional[str]) \u2013\n\nwerkzeug.datastructures.IfRange\n\nParses a range header into a `Range` object. If the header is missing or\nmalformed `None` is returned. `ranges` is a list of `(start, stop)` tuples\nwhere the ranges are non-inclusive.\n\nNew in version 0.7.\n\nOptional[werkzeug.datastructures.Range]\n\nParses a range header into a `ContentRange` object or `None` if parsing is not\npossible.\n\nNew in version 0.7.\n\nOptional[werkzeug.datastructures.ContentRange]\n\nThe following utilities operate on HTTP headers well but do not parse them.\nThey are useful if you\u2019re dealing with conditional responses or if you want to\nproxy arbitrary requests but want to remove WSGI-unsupported hop-by-hop\nheaders. Also there is a function to create HTTP header strings from the\nparsed data.\n\nCheck if a header is an entity header.\n\nNew in version 0.5.\n\nheader (str) \u2013 the header to test.\n\n`True` if it\u2019s an entity header, `False` otherwise.\n\nbool\n\nCheck if a header is an HTTP/1.1 \u201cHop-by-Hop\u201d header.\n\nNew in version 0.5.\n\nheader (str) \u2013 the header to test.\n\n`True` if it\u2019s an HTTP/1.1 \u201cHop-by-Hop\u201d header, `False` otherwise.\n\nbool\n\nRemove all entity headers from a list or `Headers` object. This operation\nworks in-place. `Expires` and `Content-Location` headers are by default not\nremoved. The reason for this is RFC 2616 section 10.3.5 which specifies some\nentity headers that should be sent.\n\nChanged in version 0.5: added `allowed` parameter.\n\nNone\n\nRemove all HTTP/1.1 \u201cHop-by-Hop\u201d headers from a list or `Headers` object. This\noperation works in-place.\n\nNew in version 0.5.\n\nheaders (Union[werkzeug.datastructures.Headers, List[Tuple[str, str]]]) \u2013 a\nlist or `Headers` object.\n\nNone\n\nChecks if a given byte content range is valid for the given length.\n\nNew in version 0.7.\n\nbool\n\nQuote a header value if necessary.\n\nNew in version 0.5.\n\nstr\n\nUnquotes a header value. (Reversal of `quote_header_value()`). This does not\nuse the real unquoting but what browsers are actually using for quoting.\n\nNew in version 0.5.\n\nstr\n\nDump an HTTP header again. This is the reversal of `parse_list_header()`,\n`parse_set_header()` and `parse_dict_header()`. This also quotes strings that\ninclude an equals sign unless you pass it as dict of key, value pairs.\n\nstr\n\nParse a cookie from a string or WSGI environ.\n\nThe same key can be provided multiple times, the values are stored in-order.\nThe default `MultiDict` will have the first value first, and all values can be\nretrieved with `MultiDict.getlist()`.\n\nds.MultiDict[str, str]\n\nChanged in version 1.0.0: Returns a `MultiDict` instead of a\n`TypeConversionDict`.\n\nChanged in version 0.5: Returns a `TypeConversionDict` instead of a regular\ndict. The `cls` parameter was added.\n\nCreate a Set-Cookie header without the `Set-Cookie` prefix.\n\nThe return value is usually restricted to ascii as the vast majority of values\nare properly escaped, but that is no guarantee. It\u2019s tunneled through latin1\nas required by PEP 3333.\n\nThe return value is not ASCII safe if the key contains unicode characters.\nThis is technically against the specification but happens in the wild. It\u2019s\nstrongly recommended to not use non-ASCII values for the keys.\n\nstr\n\nChanged in version 1.0.0: The string `'None'` is accepted for `samesite`.\n\nFor conditional responses the following functions might be useful:\n\nParse an etag header.\n\nvalue (Optional[str]) \u2013 the tag header to parse\n\nan `ETags` object.\n\nwerkzeug.datastructures.ETags\n\nQuote an etag.\n\nstr\n\nUnquote a single etag:\n\netag (Optional[str]) \u2013 the etag identifier to unquote.\n\na `(etag, weak)` tuple.\n\nUnion[Tuple[str, bool], Tuple[None, None]]\n\nGenerate an etag for some data.\n\nChanged in version 2.0: Use SHA-1. MD5 may not be available in some\nenvironments.\n\ndata (bytes) \u2013\n\nstr\n\nConvenience method for conditional requests.\n\n`True` if the resource was modified, otherwise `False`.\n\nbool\n\nChanged in version 2.0: SHA-1 is used to generate an etag value for the data.\nMD5 may not be available in some environments.\n\nChanged in version 1.0.0: The check is run for methods other than `GET` and\n`HEAD`.\n\nA dict of status code -> default status message pairs. This is used by the\nwrappers and other places where an integer status code is expanded to a string\nthroughout Werkzeug.\n\nWerkzeug provides the form parsing functions separately from the request\nobject so that you can access form data from a plain WSGI environment.\n\nThe following formats are currently supported by the form data parser:\n\nNested multipart is not currently supported (Werkzeug 0.9), but it isn\u2019t used\nby any of the modern web browsers.\n\nUsage example:\n\nNormally the WSGI environment is provided by the WSGI gateway with the\nincoming data as part of it. If you want to generate such fake-WSGI\nenvironments for unittesting you might want to use the `create_environ()`\nfunction or the `EnvironBuilder` instead.\n\nThis class implements parsing of form data for Werkzeug. By itself it can\nparse multipart and url encoded form data. It can be subclassed and extended\nbut for most mimetypes it is a better idea to use the untouched stream and\nexpose it as separate attributes on a request object.\n\nNew in version 0.8.\n\nNone\n\nParse the form data in the environ and return it as tuple in the form\n`(stream, form, files)`. You should only call this method if the transport\nmethod is `POST`, `PUT`, or `PATCH`.\n\nIf the mimetype of the data transmitted is `multipart/form-data` the files\nmultidict will be filled with `FileStorage` objects. If the mimetype is\nunknown the input stream is wrapped and returned as first argument, else the\nstream is empty.\n\nThis is a shortcut for the common usage of `FormDataParser`.\n\nHave a look at Dealing with Request Data for more details.\n\nNew in version 0.5.1: The optional `silent` flag was added.\n\nNew in version 0.5: The `max_form_memory_size`, `max_content_length` and `cls`\nparameters were added.\n\nA tuple in the form `(stream, form, files)`.\n\nt_parse_result\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "HTTPException.get_response()", "path": "exceptions/index#werkzeug.exceptions.HTTPException.get_response", "type": "werkzeug.exceptions", "text": "\nGet a response object. If one was passed to the exception it\u2019s returned\ndirectly.\n\na `Response` object or a subclass thereof.\n\nResponse\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "HTTPException.__call__()", "path": "exceptions/index#werkzeug.exceptions.HTTPException.__call__", "type": "werkzeug.exceptions", "text": "\nCall the exception as WSGI application.\n\nIterable[bytes]\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "http_date()", "path": "http/index#werkzeug.http.http_date", "type": "werkzeug.http", "text": "\nFormat a datetime object or timestamp into an RFC 2822 date string.\n\nThis is a wrapper for `email.utils.format_datetime()`. It assumes naive\ndatetime objects are in UTC instead of raising an exception.\n\ntimestamp (Optional[Union[datetime.datetime, datetime.date, int, float,\ntime.struct_time]]) \u2013 The datetime or timestamp to format. Defaults to the\ncurrent time.\n\nstr\n\nChanged in version 2.0: Use `email.utils.format_datetime`. Accept `date`\nobjects.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "IfRange", "path": "datastructures/index#werkzeug.datastructures.IfRange", "type": "werkzeug.datastructures", "text": "\nVery simple object that represents the `If-Range` header in parsed form. It\nwill either have neither a etag or date or one of either but never both.\n\nNew in version 0.7.\n\nThe date in parsed format or `None`.\n\nThe etag parsed and unquoted. Ranges always operate on strong etags so the\nweakness information is not necessary.\n\nConverts the object back into an HTTP header.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "IfRange.date", "path": "datastructures/index#werkzeug.datastructures.IfRange.date", "type": "werkzeug.datastructures", "text": "\nThe date in parsed format or `None`.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "IfRange.etag", "path": "datastructures/index#werkzeug.datastructures.IfRange.etag", "type": "werkzeug.datastructures", "text": "\nThe etag parsed and unquoted. Ranges always operate on strong etags so the\nweakness information is not necessary.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "IfRange.to_header()", "path": "datastructures/index#werkzeug.datastructures.IfRange.to_header", "type": "werkzeug.datastructures", "text": "\nConverts the object back into an HTTP header.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "ImmutableDict", "path": "datastructures/index#werkzeug.datastructures.ImmutableDict", "type": "werkzeug.datastructures", "text": "\nAn immutable `dict`.\n\nNew in version 0.5.\n\nReturn a shallow mutable copy of this object. Keep in mind that the standard\nlibrary\u2019s `copy()` function is a no-op for this class like for any other\npython immutable type (eg: `tuple`).\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "ImmutableDict.copy()", "path": "datastructures/index#werkzeug.datastructures.ImmutableDict.copy", "type": "werkzeug.datastructures", "text": "\nReturn a shallow mutable copy of this object. Keep in mind that the standard\nlibrary\u2019s `copy()` function is a no-op for this class like for any other\npython immutable type (eg: `tuple`).\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "ImmutableList", "path": "datastructures/index#werkzeug.datastructures.ImmutableList", "type": "werkzeug.datastructures", "text": "\nAn immutable `list`.\n\nNew in version 0.5.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "ImmutableMultiDict", "path": "datastructures/index#werkzeug.datastructures.ImmutableMultiDict", "type": "werkzeug.datastructures", "text": "\nAn immutable `MultiDict`.\n\nNew in version 0.5.\n\nReturn a shallow mutable copy of this object. Keep in mind that the standard\nlibrary\u2019s `copy()` function is a no-op for this class like for any other\npython immutable type (eg: `tuple`).\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "ImmutableMultiDict.copy()", "path": "datastructures/index#werkzeug.datastructures.ImmutableMultiDict.copy", "type": "werkzeug.datastructures", "text": "\nReturn a shallow mutable copy of this object. Keep in mind that the standard\nlibrary\u2019s `copy()` function is a no-op for this class like for any other\npython immutable type (eg: `tuple`).\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "ImmutableOrderedMultiDict", "path": "datastructures/index#werkzeug.datastructures.ImmutableOrderedMultiDict", "type": "werkzeug.datastructures", "text": "\nAn immutable `OrderedMultiDict`.\n\nNew in version 0.6.\n\nReturn a shallow mutable copy of this object. Keep in mind that the standard\nlibrary\u2019s `copy()` function is a no-op for this class like for any other\npython immutable type (eg: `tuple`).\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "ImmutableOrderedMultiDict.copy()", "path": "datastructures/index#werkzeug.datastructures.ImmutableOrderedMultiDict.copy", "type": "werkzeug.datastructures", "text": "\nReturn a shallow mutable copy of this object. Keep in mind that the standard\nlibrary\u2019s `copy()` function is a no-op for this class like for any other\npython immutable type (eg: `tuple`).\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "ImmutableTypeConversionDict", "path": "datastructures/index#werkzeug.datastructures.ImmutableTypeConversionDict", "type": "werkzeug.datastructures", "text": "\nWorks like a `TypeConversionDict` but does not support modifications.\n\nNew in version 0.5.\n\nReturn a shallow mutable copy of this object. Keep in mind that the standard\nlibrary\u2019s `copy()` function is a no-op for this class like for any other\npython immutable type (eg: `tuple`).\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "ImmutableTypeConversionDict.copy()", "path": "datastructures/index#werkzeug.datastructures.ImmutableTypeConversionDict.copy", "type": "werkzeug.datastructures", "text": "\nReturn a shallow mutable copy of this object. Keep in mind that the standard\nlibrary\u2019s `copy()` function is a no-op for this class like for any other\npython immutable type (eg: `tuple`).\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Important Terms", "path": "terms/index", "type": "Other", "text": "\nThis page covers important terms used in the documentation and Werkzeug\nitself.\n\nWSGI a specification for Python web applications Werkzeug follows. It was\nspecified in the PEP 3333 and is widely supported. Unlike previous solutions\nit guarantees that web applications, servers and utilities can work together.\n\nFor Werkzeug, a response object is an object that works like a WSGI\napplication but does not do any request processing. Usually you have a view\nfunction or controller method that processes the request and assembles a\nresponse object.\n\nA response object is not necessarily the `Response` class or a subclass\nthereof.\n\nFor example Pylons/webob provide a very similar response class that can be\nused as well (`webob.Response`).\n\nOften people speak of MVC (Model, View, Controller) when developing web\napplications. However, the Django framework coined MTV (Model, Template, View)\nwhich basically means the same but reduces the concept to the data model, a\nfunction that processes data from the request and the database and renders a\ntemplate.\n\nWerkzeug itself does not tell you how you should develop applications, but the\ndocumentation often speaks of view functions that work roughly the same. The\nidea of a view function is that it\u2019s called with a request object (and\noptionally some parameters from an URL rule) and returns a response object.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "import_string()", "path": "utils/index#werkzeug.utils.import_string", "type": "werkzeug.utils", "text": "\nImports an object based on a string. This is useful if you want to use import\npaths as endpoints or something similar. An import path can be specified\neither in dotted notation (`xml.sax.saxutils.escape`) or with a colon as\nobject delimiter (`xml.sax.saxutils:escape`).\n\nIf `silent` is True the return value will be `None` if the import fails.\n\nimported object\n\nAny\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Installation", "path": "installation/index", "type": "Other", "text": "\nWe recommend using the latest version of Python. Werkzeug supports Python 3.6\nand newer.\n\nWerkzeug does not have any direct dependencies.\n\nThese distributions will not be installed automatically. Werkzeug will detect\nand use them if you install them.\n\nUse a virtual environment to manage the dependencies for your project, both in\ndevelopment and in production.\n\nWhat problem does a virtual environment solve? The more Python projects you\nhave, the more likely it is that you need to work with different versions of\nPython libraries, or even Python itself. Newer versions of libraries for one\nproject can break compatibility in another project.\n\nVirtual environments are independent groups of Python libraries, one for each\nproject. Packages installed for one project will not affect other projects or\nthe operating system\u2019s packages.\n\nPython comes bundled with the `venv` module to create virtual environments.\n\nCreate a project folder and a `venv` folder within:\n\nOn Windows:\n\nBefore you work on your project, activate the corresponding environment:\n\nOn Windows:\n\nYour shell prompt will change to show the name of the activated environment.\n\nWithin the activated environment, use the following command to install\nWerkzeug:\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "IntegerConverter", "path": "routing/index#werkzeug.routing.IntegerConverter", "type": "werkzeug.routing", "text": "\nThis converter only accepts integer values:\n\nBy default it only accepts unsigned, positive values. The `signed` parameter\nwill enable signed, negative values.\n\nNone\n\nNew in version 0.15: The `signed` parameter.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "InternalServerError.original_exception", "path": "exceptions/index#werkzeug.exceptions.InternalServerError.original_exception", "type": "werkzeug.exceptions", "text": "\nThe original exception that caused this 500 error. Can be used by frameworks\nto provide context when handling unexpected errors.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "invalidate_cached_property()", "path": "utils/index#werkzeug.utils.invalidate_cached_property", "type": "werkzeug.utils", "text": "\nInvalidates the cache for a `cached_property`:\n\nYou must pass the name of the cached property as the second argument.\n\nDeprecated since version 2.0: Will be removed in Werkzeug 2.1. Use `del\nobj.name` instead.\n\nNone\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "iri_to_uri()", "path": "urls/index#werkzeug.urls.iri_to_uri", "type": "werkzeug.urls", "text": "\nConvert an IRI to a URI. All non-ASCII and unsafe characters are quoted. If\nthe URL has a domain, it is encoded to Punycode.\n\nstr\n\nThere is a general problem with IRI conversion with some protocols that are in\nviolation of the URI specification. Consider the following two IRIs:\n\nAfter parsing, we don\u2019t know if the scheme requires the `//`, which is dropped\nif empty, but conveys different meanings in the final URL if it\u2019s present or\nnot. In this case, you can use `safe_conversion`, which will return the URL\nunchanged if it only contains ASCII characters and no whitespace. This can\nresult in a URI with unquoted characters if it was not already quoted\ncorrectly, but preserves the URL\u2019s semantics. Werkzeug uses this for the\n`Location` header for redirects.\n\nChanged in version 0.15: All reserved characters remain unquoted. Previously,\nonly some reserved characters were left unquoted.\n\nChanged in version 0.9.6: The `safe_conversion` parameter was added.\n\nNew in version 0.6.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "is_byte_range_valid()", "path": "http/index#werkzeug.http.is_byte_range_valid", "type": "werkzeug.http", "text": "\nChecks if a given byte content range is valid for the given length.\n\nNew in version 0.7.\n\nbool\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "is_entity_header()", "path": "http/index#werkzeug.http.is_entity_header", "type": "werkzeug.http", "text": "\nCheck if a header is an entity header.\n\nNew in version 0.5.\n\nheader (str) \u2013 the header to test.\n\n`True` if it\u2019s an entity header, `False` otherwise.\n\nbool\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "is_hop_by_hop_header()", "path": "http/index#werkzeug.http.is_hop_by_hop_header", "type": "werkzeug.http", "text": "\nCheck if a header is an HTTP/1.1 \u201cHop-by-Hop\u201d header.\n\nNew in version 0.5.\n\nheader (str) \u2013 the header to test.\n\n`True` if it\u2019s an HTTP/1.1 \u201cHop-by-Hop\u201d header, `False` otherwise.\n\nbool\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "is_resource_modified()", "path": "http/index#werkzeug.http.is_resource_modified", "type": "werkzeug.http", "text": "\nConvenience method for conditional requests.\n\n`True` if the resource was modified, otherwise `False`.\n\nbool\n\nChanged in version 2.0: SHA-1 is used to generate an etag value for the data.\nMD5 may not be available in some environments.\n\nChanged in version 1.0.0: The check is run for methods other than `GET` and\n`HEAD`.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "is_running_from_reloader()", "path": "serving/index#werkzeug.serving.is_running_from_reloader", "type": "werkzeug.serving", "text": "\nChecks if the application is running from within the Werkzeug reloader\nsubprocess.\n\nNew in version 0.10.\n\nbool\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "LanguageAccept", "path": "datastructures/index#werkzeug.datastructures.LanguageAccept", "type": "werkzeug.datastructures", "text": "\nLike `Accept` but with normalization for language tags.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "LimitedStream", "path": "wsgi/index#werkzeug.wsgi.LimitedStream", "type": "werkzeug.wsgi", "text": "\nWraps a stream so that it doesn\u2019t read more than n bytes. If the stream is\nexhausted and the caller tries to get more bytes from it `on_exhausted()` is\ncalled which by default returns an empty string. The return value of that\nfunction is forwarded to the reader function. So if it returns an empty string\n`read()` will return an empty string as well.\n\nThe limit however must never be higher than what the stream can output.\nOtherwise `readlines()` will try to read past the limit.\n\nNote on WSGI compliance\n\ncalls to `readline()` and `readlines()` are not WSGI compliant because it\npasses a size argument to the readline methods. Unfortunately the WSGI PEP is\nnot safely implementable without a size argument to `readline()` because there\nis no EOF marker in the stream. As a result of that the use of `readline()` is\ndiscouraged.\n\nFor the same reason iterating over the `LimitedStream` is not portable. It\ninternally calls `readline()`.\n\nWe strongly suggest using `read()` only or using the `make_line_iter()` which\nsafely iterates line-based over a WSGI input stream.\n\nNone\n\nExhaust the stream. This consumes all the data left until the limit is\nreached.\n\nchunk_size (int) \u2013 the size for a chunk. It will read the chunk until the\nstream is exhausted and throw away the results.\n\nNone\n\nIf the stream is exhausted this attribute is `True`.\n\nWhat should happen if a disconnect is detected? The return value of this\nfunction is returned from read functions in case the client went away. By\ndefault a `ClientDisconnected` exception is raised.\n\nbytes\n\nThis is called when the stream tries to read past the limit. The return value\nof this function is returned from the reading function.\n\nbytes\n\nRead `size` bytes or if size is not provided everything is read.\n\nsize (Optional[int]) \u2013 the number of bytes read.\n\nbytes\n\nReturn whether object was opened for reading.\n\nIf False, read() will raise OSError.\n\nbool\n\nReads one line from the stream.\n\nsize (Optional[int]) \u2013\n\nbytes\n\nReads a file into a list of strings. It calls `readline()` until the file is\nread to the end. It does support the optional `size` argument if the\nunderlying stream supports it for `readline`.\n\nsize (Optional[int]) \u2013\n\nList[bytes]\n\nReturns the position of the stream.\n\nNew in version 0.9.\n\nint\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "LimitedStream.exhaust()", "path": "wsgi/index#werkzeug.wsgi.LimitedStream.exhaust", "type": "werkzeug.wsgi", "text": "\nExhaust the stream. This consumes all the data left until the limit is\nreached.\n\nchunk_size (int) \u2013 the size for a chunk. It will read the chunk until the\nstream is exhausted and throw away the results.\n\nNone\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "LimitedStream.on_disconnect()", "path": "wsgi/index#werkzeug.wsgi.LimitedStream.on_disconnect", "type": "werkzeug.wsgi", "text": "\nWhat should happen if a disconnect is detected? The return value of this\nfunction is returned from read functions in case the client went away. By\ndefault a `ClientDisconnected` exception is raised.\n\nbytes\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "LimitedStream.on_exhausted()", "path": "wsgi/index#werkzeug.wsgi.LimitedStream.on_exhausted", "type": "werkzeug.wsgi", "text": "\nThis is called when the stream tries to read past the limit. The return value\nof this function is returned from the reading function.\n\nbytes\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "LimitedStream.read()", "path": "wsgi/index#werkzeug.wsgi.LimitedStream.read", "type": "werkzeug.wsgi", "text": "\nRead `size` bytes or if size is not provided everything is read.\n\nsize (Optional[int]) \u2013 the number of bytes read.\n\nbytes\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "LimitedStream.readable()", "path": "wsgi/index#werkzeug.wsgi.LimitedStream.readable", "type": "werkzeug.wsgi", "text": "\nReturn whether object was opened for reading.\n\nIf False, read() will raise OSError.\n\nbool\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "LimitedStream.readline()", "path": "wsgi/index#werkzeug.wsgi.LimitedStream.readline", "type": "werkzeug.wsgi", "text": "\nReads one line from the stream.\n\nsize (Optional[int]) \u2013\n\nbytes\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "LimitedStream.readlines()", "path": "wsgi/index#werkzeug.wsgi.LimitedStream.readlines", "type": "werkzeug.wsgi", "text": "\nReads a file into a list of strings. It calls `readline()` until the file is\nread to the end. It does support the optional `size` argument if the\nunderlying stream supports it for `readline`.\n\nsize (Optional[int]) \u2013\n\nList[bytes]\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "LimitedStream.tell()", "path": "wsgi/index#werkzeug.wsgi.LimitedStream.tell", "type": "werkzeug.wsgi", "text": "\nReturns the position of the stream.\n\nNew in version 0.9.\n\nint\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "LintMiddleware", "path": "middleware/lint/index#werkzeug.middleware.lint.LintMiddleware", "type": "werkzeug.middleware.lint", "text": "\nWarns about common errors in the WSGI and HTTP behavior of the server and\nwrapped application. Some of the issues it checks are:\n\nError information is emitted using the `warnings` module.\n\napp (WSGIApplication) \u2013 The WSGI application to wrap.\n\nNone\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "LocalManager", "path": "local/index#werkzeug.local.LocalManager", "type": "werkzeug.local", "text": "\nLocal objects cannot manage themselves. For that you need a local manager. You\ncan pass a local manager multiple locals or add them later y appending them to\n`manager.locals`. Every time the manager cleans up, it will clean up all the\ndata left in the locals for this context.\n\nChanged in version 2.0: `ident_func` is deprecated and will be removed in\nWerkzeug 2.1.\n\nChanged in version 0.7: The `ident_func` parameter was added.\n\nChanged in version 0.6.1: The `release_local()` function can be used instead\nof a manager.\n\nNone\n\nManually clean up the data in the locals for this context. Call this at the\nend of the request or use `make_middleware()`.\n\nNone\n\nReturn the context identifier the local objects use internally for this\ncontext. You cannot override this method to change the behavior but use it to\nlink other context local objects (such as SQLAlchemy\u2019s scoped sessions) to the\nWerkzeug locals.\n\nDeprecated since version 2.0: Will be removed in Werkzeug 2.1.\n\nChanged in version 0.7: You can pass a different ident function to the local\nmanager that will then be propagated to all the locals passed to the\nconstructor.\n\nint\n\nWrap a WSGI application so that cleaning up happens after request end.\n\napp (WSGIApplication) \u2013\n\nWSGIApplication\n\nLike `make_middleware` but for decorating functions.\n\nExample usage:\n\nThe difference to `make_middleware` is that the function passed will have all\nthe arguments copied from the inner application (name, docstring, module).\n\nfunc (WSGIApplication) \u2013\n\nWSGIApplication\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "LocalManager.cleanup()", "path": "local/index#werkzeug.local.LocalManager.cleanup", "type": "werkzeug.local", "text": "\nManually clean up the data in the locals for this context. Call this at the\nend of the request or use `make_middleware()`.\n\nNone\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "LocalManager.get_ident()", "path": "local/index#werkzeug.local.LocalManager.get_ident", "type": "werkzeug.local", "text": "\nReturn the context identifier the local objects use internally for this\ncontext. You cannot override this method to change the behavior but use it to\nlink other context local objects (such as SQLAlchemy\u2019s scoped sessions) to the\nWerkzeug locals.\n\nDeprecated since version 2.0: Will be removed in Werkzeug 2.1.\n\nChanged in version 0.7: You can pass a different ident function to the local\nmanager that will then be propagated to all the locals passed to the\nconstructor.\n\nint\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "LocalManager.make_middleware()", "path": "local/index#werkzeug.local.LocalManager.make_middleware", "type": "werkzeug.local", "text": "\nWrap a WSGI application so that cleaning up happens after request end.\n\napp (WSGIApplication) \u2013\n\nWSGIApplication\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "LocalManager.middleware()", "path": "local/index#werkzeug.local.LocalManager.middleware", "type": "werkzeug.local", "text": "\nLike `make_middleware` but for decorating functions.\n\nExample usage:\n\nThe difference to `make_middleware` is that the function passed will have all\nthe arguments copied from the inner application (name, docstring, module).\n\nfunc (WSGIApplication) \u2013\n\nWSGIApplication\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "LocalProxy", "path": "local/index#werkzeug.local.LocalProxy", "type": "werkzeug.local", "text": "\nA proxy to the object bound to a `Local`. All operations on the proxy are\nforwarded to the bound object. If no object is bound, a `RuntimeError` is\nraised.\n\n`__repr__` and `__class__` are forwarded, so `repr(x)` and `isinstance(x,\ncls)` will look like the proxied object. Use `issubclass(type(x), LocalProxy)`\nto check if an object is a proxy.\n\nChanged in version 2.0: Updated proxied attributes and methods to reflect the\ncurrent data model.\n\nChanged in version 0.6.1: The class can be instantiated with a callable.\n\nReturn the current object. This is useful if you want the real object behind\nthe proxy at a time for performance reasons or because you want to pass the\nobject into a different context.\n\nAny\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "LocalProxy._get_current_object()", "path": "local/index#werkzeug.local.LocalProxy._get_current_object", "type": "werkzeug.local", "text": "\nReturn the current object. This is useful if you want the real object behind\nthe proxy at a time for performance reasons or because you want to pass the\nobject into a different context.\n\nAny\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "LocalStack", "path": "local/index#werkzeug.local.LocalStack", "type": "werkzeug.local", "text": "\nThis class works similar to a `Local` but keeps a stack of objects instead.\nThis is best explained with an example:\n\nThey can be force released by using a `LocalManager` or with the\n`release_local()` function but the correct way is to pop the item from the\nstack after using. When the stack is empty it will no longer be bound to the\ncurrent context (and as such released).\n\nBy calling the stack without arguments it returns a proxy that resolves to the\ntopmost item on the stack.\n\nNew in version 0.6.1.\n\nNone\n\nRemoves the topmost item from the stack, will return the old value or `None`\nif the stack was already empty.\n\nAny\n\nPushes a new item to the stack\n\nobj (Any) \u2013\n\nList[Any]\n\nThe topmost item on the stack. If the stack is empty, `None` is returned.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "LocalStack.pop()", "path": "local/index#werkzeug.local.LocalStack.pop", "type": "werkzeug.local", "text": "\nRemoves the topmost item from the stack, will return the old value or `None`\nif the stack was already empty.\n\nAny\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "LocalStack.push()", "path": "local/index#werkzeug.local.LocalStack.push", "type": "werkzeug.local", "text": "\nPushes a new item to the stack\n\nobj (Any) \u2013\n\nList[Any]\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "make_chunk_iter()", "path": "wsgi/index#werkzeug.wsgi.make_chunk_iter", "type": "werkzeug.wsgi", "text": "\nWorks like `make_line_iter()` but accepts a separator which divides chunks. If\nyou want newline based processing you should use `make_line_iter()` instead as\nit supports arbitrary newline markers.\n\nNew in version 0.11.10: added support for the `cap_at_buffer` parameter.\n\nNew in version 0.9: added support for iterators as input stream.\n\nNew in version 0.8.\n\nIterator[bytes]\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "make_line_iter()", "path": "wsgi/index#werkzeug.wsgi.make_line_iter", "type": "werkzeug.wsgi", "text": "\nSafely iterates line-based over an input stream. If the input stream is not a\n`LimitedStream` the `limit` parameter is mandatory.\n\nThis uses the stream\u2019s `read()` method internally as opposite to the\n`readline()` method that is unsafe and can only be used in violation of the\nWSGI specification. The same problem applies to the `__iter__` function of the\ninput stream which calls `readline()` without arguments.\n\nIf you need line-by-line processing it\u2019s strongly recommended to iterate over\nthe input stream using this helper function.\n\nNew in version 0.11.10: added support for the `cap_at_buffer` parameter.\n\nNew in version 0.9: added support for iterators as input stream.\n\nChanged in version 0.8: This function now ensures that the limit was reached.\n\nIterator[bytes]\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "make_ssl_devcert()", "path": "serving/index#werkzeug.serving.make_ssl_devcert", "type": "werkzeug.serving", "text": "\nCreates an SSL key for development. This should be used instead of the\n`'adhoc'` key which generates a new cert on each server start. It accepts a\npath for where it should store the key and cert and either a host or CN. If a\nhost is given it will use the CN `*.host/CN=host`.\n\nFor more information see `run_simple()`.\n\nNew in version 0.9.\n\nTuple[str, str]\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Map", "path": "routing/index#werkzeug.routing.Map", "type": "werkzeug.routing", "text": "\nThe map class stores all the URL rules and some configuration parameters. Some\nof the configuration values are only stored on the `Map` instance since those\naffect all rules, others are just defaults and can be overridden for each\nrule. Note that you have to specify all arguments besides the `rules` as\nkeyword arguments!\n\nNone\n\nChanged in version 1.0: If `url_scheme` is `ws` or `wss`, only WebSocket rules\nwill match.\n\nChanged in version 1.0: Added `merge_slashes`.\n\nChanged in version 0.7: Added `encoding_errors` and `host_matching`.\n\nChanged in version 0.5: Added `sort_parameters` and `sort_key`.\n\nThe dictionary of converters. This can be modified after the class was\ncreated, but will only affect rules added after the modification. If the rules\nare defined with the list passed to the class, the `converters` parameter to\nthe constructor has to be used instead.\n\nAdd a new rule or factory to the map and bind it. Requires that the rule is\nnot bound to another map.\n\nrulefactory (werkzeug.routing.RuleFactory) \u2013 a `Rule` or `RuleFactory`\n\nNone\n\nReturn a new `MapAdapter` with the details specified to the call. Note that\n`script_name` will default to `'/'` if not further specified or `None`. The\n`server_name` at least is a requirement because the HTTP RFC requires absolute\nURLs for redirects and so all redirect exceptions raised by Werkzeug will\ncontain the full canonical URL.\n\nIf no path_info is passed to `match()` it will use the default path info\npassed to bind. While this doesn\u2019t really make sense for manual bind calls,\nit\u2019s useful if you bind a map to a WSGI environment which already contains the\npath info.\n\n`subdomain` will default to the `default_subdomain` for this map if no\ndefined. If there is no `default_subdomain` you cannot use the subdomain\nfeature.\n\nChanged in version 1.0: If `url_scheme` is `ws` or `wss`, only WebSocket rules\nwill match.\n\nChanged in version 0.15: `path_info` defaults to `'/'` if `None`.\n\nChanged in version 0.8: `query_args` can be a string.\n\nChanged in version 0.7: Added `query_args`.\n\nwerkzeug.routing.MapAdapter\n\nLike `bind()` but you can pass it an WSGI environment and it will fetch the\ninformation from that dictionary. Note that because of limitations in the\nprotocol there is no way to get the current subdomain and real `server_name`\nfrom the environment. If you don\u2019t provide it, Werkzeug will use `SERVER_NAME`\nand `SERVER_PORT` (or `HTTP_HOST` if provided) as used `server_name` with\ndisabled subdomain feature.\n\nIf `subdomain` is `None` but an environment and a server name is provided it\nwill calculate the current subdomain automatically. Example: `server_name` is\n`'example.com'` and the `SERVER_NAME` in the wsgi `environ` is\n`'staging.dev.example.com'` the calculated subdomain will be `'staging.dev'`.\n\nIf the object passed as environ has an environ attribute, the value of this\nattribute is used instead. This allows you to pass request objects.\nAdditionally `PATH_INFO` added as a default of the `MapAdapter` so that you\ndon\u2019t have to pass the path info to the match method.\n\nChanged in version 1.0.0: If the passed server name specifies port 443, it\nwill match if the incoming scheme is `https` without a port.\n\nChanged in version 1.0.0: A warning is shown when the passed server name does\nnot match the incoming WSGI server name.\n\nChanged in version 0.8: This will no longer raise a ValueError when an\nunexpected server name was passed.\n\nChanged in version 0.5: previously this method accepted a bogus\n`calculate_subdomain` parameter that did not have any effect. It was removed\nbecause of that.\n\nMapAdapter\n\nA dict of default converters to be used.\n\nIterate over all rules and check if the endpoint expects the arguments\nprovided. This is for example useful if you have some URLs that expect a\nlanguage code and others that do not and you want to wrap the builder a bit so\nthat the current language code is automatically added if not provided but\nendpoints expect it.\n\nbool\n\nIterate over all rules or the rules of an endpoint.\n\nendpoint (Optional[str]) \u2013 if provided only the rules for that endpoint are\nreturned.\n\nan iterator\n\nIterator[werkzeug.routing.Rule]\n\nThe type of lock to use when updating.\n\nNew in version 1.0.\n\nCalled before matching and building to keep the compiled rules in the correct\norder after things changed.\n\nNone\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Map.add()", "path": "routing/index#werkzeug.routing.Map.add", "type": "werkzeug.routing", "text": "\nAdd a new rule or factory to the map and bind it. Requires that the rule is\nnot bound to another map.\n\nrulefactory (werkzeug.routing.RuleFactory) \u2013 a `Rule` or `RuleFactory`\n\nNone\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Map.bind()", "path": "routing/index#werkzeug.routing.Map.bind", "type": "werkzeug.routing", "text": "\nReturn a new `MapAdapter` with the details specified to the call. Note that\n`script_name` will default to `'/'` if not further specified or `None`. The\n`server_name` at least is a requirement because the HTTP RFC requires absolute\nURLs for redirects and so all redirect exceptions raised by Werkzeug will\ncontain the full canonical URL.\n\nIf no path_info is passed to `match()` it will use the default path info\npassed to bind. While this doesn\u2019t really make sense for manual bind calls,\nit\u2019s useful if you bind a map to a WSGI environment which already contains the\npath info.\n\n`subdomain` will default to the `default_subdomain` for this map if no\ndefined. If there is no `default_subdomain` you cannot use the subdomain\nfeature.\n\nChanged in version 1.0: If `url_scheme` is `ws` or `wss`, only WebSocket rules\nwill match.\n\nChanged in version 0.15: `path_info` defaults to `'/'` if `None`.\n\nChanged in version 0.8: `query_args` can be a string.\n\nChanged in version 0.7: Added `query_args`.\n\nwerkzeug.routing.MapAdapter\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Map.bind_to_environ()", "path": "routing/index#werkzeug.routing.Map.bind_to_environ", "type": "werkzeug.routing", "text": "\nLike `bind()` but you can pass it an WSGI environment and it will fetch the\ninformation from that dictionary. Note that because of limitations in the\nprotocol there is no way to get the current subdomain and real `server_name`\nfrom the environment. If you don\u2019t provide it, Werkzeug will use `SERVER_NAME`\nand `SERVER_PORT` (or `HTTP_HOST` if provided) as used `server_name` with\ndisabled subdomain feature.\n\nIf `subdomain` is `None` but an environment and a server name is provided it\nwill calculate the current subdomain automatically. Example: `server_name` is\n`'example.com'` and the `SERVER_NAME` in the wsgi `environ` is\n`'staging.dev.example.com'` the calculated subdomain will be `'staging.dev'`.\n\nIf the object passed as environ has an environ attribute, the value of this\nattribute is used instead. This allows you to pass request objects.\nAdditionally `PATH_INFO` added as a default of the `MapAdapter` so that you\ndon\u2019t have to pass the path info to the match method.\n\nChanged in version 1.0.0: If the passed server name specifies port 443, it\nwill match if the incoming scheme is `https` without a port.\n\nChanged in version 1.0.0: A warning is shown when the passed server name does\nnot match the incoming WSGI server name.\n\nChanged in version 0.8: This will no longer raise a ValueError when an\nunexpected server name was passed.\n\nChanged in version 0.5: previously this method accepted a bogus\n`calculate_subdomain` parameter that did not have any effect. It was removed\nbecause of that.\n\nMapAdapter\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Map.converters", "path": "routing/index#werkzeug.routing.Map.converters", "type": "werkzeug.routing", "text": "\nThe dictionary of converters. This can be modified after the class was\ncreated, but will only affect rules added after the modification. If the rules\nare defined with the list passed to the class, the `converters` parameter to\nthe constructor has to be used instead.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Map.default_converters", "path": "routing/index#werkzeug.routing.Map.default_converters", "type": "werkzeug.routing", "text": "\nA dict of default converters to be used.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Map.is_endpoint_expecting()", "path": "routing/index#werkzeug.routing.Map.is_endpoint_expecting", "type": "werkzeug.routing", "text": "\nIterate over all rules and check if the endpoint expects the arguments\nprovided. This is for example useful if you have some URLs that expect a\nlanguage code and others that do not and you want to wrap the builder a bit so\nthat the current language code is automatically added if not provided but\nendpoints expect it.\n\nbool\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Map.iter_rules()", "path": "routing/index#werkzeug.routing.Map.iter_rules", "type": "werkzeug.routing", "text": "\nIterate over all rules or the rules of an endpoint.\n\nendpoint (Optional[str]) \u2013 if provided only the rules for that endpoint are\nreturned.\n\nan iterator\n\nIterator[werkzeug.routing.Rule]\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Map.lock_class()", "path": "routing/index#werkzeug.routing.Map.lock_class", "type": "werkzeug.routing", "text": "\nThe type of lock to use when updating.\n\nNew in version 1.0.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Map.update()", "path": "routing/index#werkzeug.routing.Map.update", "type": "werkzeug.routing", "text": "\nCalled before matching and building to keep the compiled rules in the correct\norder after things changed.\n\nNone\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "MapAdapter", "path": "routing/index#werkzeug.routing.MapAdapter", "type": "werkzeug.routing", "text": "\nReturned by `Map.bind()` or `Map.bind_to_environ()` and does the URL matching\nand building based on runtime information.\n\nReturns the valid methods that match for a given path.\n\nNew in version 0.7.\n\npath_info (Optional[str]) \u2013\n\nIterable[str]\n\nBuilding URLs works pretty much the other way round. Instead of `match` you\ncall `build` and pass it the endpoint and a dict of arguments for the\nplaceholders.\n\nThe `build` function also accepts an argument called `force_external` which,\nif you set it to `True` will force external URLs. Per default external URLs\n(include the server name) will only be used if the target URL is on a\ndifferent subdomain.\n\nBecause URLs cannot contain non ASCII data you will always get bytes back. Non\nASCII characters are urlencoded with the charset defined on the map instance.\n\nAdditional values are converted to strings and appended to the URL as URL\nquerystring parameters:\n\nWhen processing those additional values, lists are furthermore interpreted as\nmultiple values (as per `werkzeug.datastructures.MultiDict`):\n\nPassing a `MultiDict` will also add multiple values:\n\nIf a rule does not exist when building a `BuildError` exception is raised.\n\nThe build method accepts an argument called `method` which allows you to\nspecify the method you want to have an URL built for if you have different\nmethods for the same endpoint specified.\n\nstr\n\nChanged in version 2.0: Added the `url_scheme` parameter.\n\nNew in version 0.6: Added the `append_unknown` parameter.\n\nDoes the complete dispatching process. `view_func` is called with the endpoint\nand a dict with the values for the view. It should look up the view function,\ncall it, and return a response object or WSGI application. http exceptions are\nnot caught by default so that applications can display nicer error messages by\njust catching them by hand. If you want to stick with the default error\nmessages you can pass it `catch_http_exceptions=True` and it will catch the\nhttp exceptions.\n\nHere a small example for the dispatch usage:\n\nKeep in mind that this method might return exception objects, too, so use\n`Response.force_type` to get a response object.\n\nWSGIApplication\n\nFigures out the full host name for the given domain part. The domain part is a\nsubdomain in case host matching is disabled or a full host name.\n\ndomain_part (Optional[str]) \u2013\n\nstr\n\nInternally called to make an alias redirect URL.\n\nstr\n\nThe usage is simple: you just pass the match method the current path info as\nwell as the method (which defaults to `GET`). The following things can then\nhappen:\n\nIf the path info is not passed to the match method the default path info of\nthe map is used (defaults to the root URL if not defined explicitly).\n\nAll of the exceptions raised are subclasses of `HTTPException` so they can be\nused as WSGI responses. They will all render generic error or redirect pages.\n\nHere is a small example for matching:\n\nAnd here is what happens on redirect and missing URLs:\n\nTuple[Union[str, werkzeug.routing.Rule], Mapping[str, Any]]\n\nNew in version 1.0: Added `websocket`.\n\nChanged in version 0.8: `query_args` can be a string.\n\nNew in version 0.7: Added `query_args`.\n\nNew in version 0.6: Added `return_rule`.\n\nTest if a rule would match. Works like `match` but returns `True` if the URL\nmatches, or `False` if it does not exist.\n\nbool\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "MapAdapter.allowed_methods()", "path": "routing/index#werkzeug.routing.MapAdapter.allowed_methods", "type": "werkzeug.routing", "text": "\nReturns the valid methods that match for a given path.\n\nNew in version 0.7.\n\npath_info (Optional[str]) \u2013\n\nIterable[str]\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "MapAdapter.build()", "path": "routing/index#werkzeug.routing.MapAdapter.build", "type": "werkzeug.routing", "text": "\nBuilding URLs works pretty much the other way round. Instead of `match` you\ncall `build` and pass it the endpoint and a dict of arguments for the\nplaceholders.\n\nThe `build` function also accepts an argument called `force_external` which,\nif you set it to `True` will force external URLs. Per default external URLs\n(include the server name) will only be used if the target URL is on a\ndifferent subdomain.\n\nBecause URLs cannot contain non ASCII data you will always get bytes back. Non\nASCII characters are urlencoded with the charset defined on the map instance.\n\nAdditional values are converted to strings and appended to the URL as URL\nquerystring parameters:\n\nWhen processing those additional values, lists are furthermore interpreted as\nmultiple values (as per `werkzeug.datastructures.MultiDict`):\n\nPassing a `MultiDict` will also add multiple values:\n\nIf a rule does not exist when building a `BuildError` exception is raised.\n\nThe build method accepts an argument called `method` which allows you to\nspecify the method you want to have an URL built for if you have different\nmethods for the same endpoint specified.\n\nstr\n\nChanged in version 2.0: Added the `url_scheme` parameter.\n\nNew in version 0.6: Added the `append_unknown` parameter.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "MapAdapter.dispatch()", "path": "routing/index#werkzeug.routing.MapAdapter.dispatch", "type": "werkzeug.routing", "text": "\nDoes the complete dispatching process. `view_func` is called with the endpoint\nand a dict with the values for the view. It should look up the view function,\ncall it, and return a response object or WSGI application. http exceptions are\nnot caught by default so that applications can display nicer error messages by\njust catching them by hand. If you want to stick with the default error\nmessages you can pass it `catch_http_exceptions=True` and it will catch the\nhttp exceptions.\n\nHere a small example for the dispatch usage:\n\nKeep in mind that this method might return exception objects, too, so use\n`Response.force_type` to get a response object.\n\nWSGIApplication\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "MapAdapter.get_host()", "path": "routing/index#werkzeug.routing.MapAdapter.get_host", "type": "werkzeug.routing", "text": "\nFigures out the full host name for the given domain part. The domain part is a\nsubdomain in case host matching is disabled or a full host name.\n\ndomain_part (Optional[str]) \u2013\n\nstr\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "MapAdapter.make_alias_redirect_url()", "path": "routing/index#werkzeug.routing.MapAdapter.make_alias_redirect_url", "type": "werkzeug.routing", "text": "\nInternally called to make an alias redirect URL.\n\nstr\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "MapAdapter.match()", "path": "routing/index#werkzeug.routing.MapAdapter.match", "type": "werkzeug.routing", "text": "\nThe usage is simple: you just pass the match method the current path info as\nwell as the method (which defaults to `GET`). The following things can then\nhappen:\n\nIf the path info is not passed to the match method the default path info of\nthe map is used (defaults to the root URL if not defined explicitly).\n\nAll of the exceptions raised are subclasses of `HTTPException` so they can be\nused as WSGI responses. They will all render generic error or redirect pages.\n\nHere is a small example for matching:\n\nAnd here is what happens on redirect and missing URLs:\n\nTuple[Union[str, werkzeug.routing.Rule], Mapping[str, Any]]\n\nNew in version 1.0: Added `websocket`.\n\nChanged in version 0.8: `query_args` can be a string.\n\nNew in version 0.7: Added `query_args`.\n\nNew in version 0.6: Added `return_rule`.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "MapAdapter.test()", "path": "routing/index#werkzeug.routing.MapAdapter.test", "type": "werkzeug.routing", "text": "\nTest if a rule would match. Works like `match` but returns `True` if the URL\nmatches, or `False` if it does not exist.\n\nbool\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Middleware", "path": "middleware/index", "type": "Other", "text": "\nA WSGI middleware is a WSGI application that wraps another application in\norder to observe or change its behavior. Werkzeug provides some middleware for\ncommon use cases.\n\nThe interactive debugger is also a middleware that can be applied manually,\nalthough it is typically used automatically with the development server.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "MIMEAccept", "path": "datastructures/index#werkzeug.datastructures.MIMEAccept", "type": "werkzeug.datastructures", "text": "\nLike `Accept` but with special methods and behavior for mimetypes.\n\nTrue if this object accepts HTML.\n\nTrue if this object accepts JSON.\n\nTrue if this object accepts XHTML.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "mod_wsgi (Apache)", "path": "deployment/mod_wsgi/index", "type": "Other", "text": "\nIf you are using the Apache webserver you should consider using mod_wsgi.\n\nIf you don\u2019t have `mod_wsgi` installed yet you have to either install it using\na package manager or compile it yourself.\n\nThe mod_wsgi installation instructions cover installation instructions for\nsource installations on UNIX systems.\n\nIf you are using ubuntu / debian you can apt-get it and activate it as\nfollows:\n\nOn FreeBSD install `mod_wsgi` by compiling the `www/mod_wsgi` port or by using\npkg_add:\n\nIf you are using pkgsrc you can install `mod_wsgi` by compiling the\n`www/ap2-wsgi` package.\n\nIf you encounter segfaulting child processes after the first apache reload you\ncan safely ignore them. Just restart the server.\n\nTo run your application you need a `yourapplication.wsgi` file. This file\ncontains the code `mod_wsgi` is executing on startup to get the application\nobject. The object called `application` in that file is then used as\napplication.\n\nFor most applications the following file should be sufficient:\n\nIf you don\u2019t have a factory function for application creation but a singleton\ninstance you can directly import that one as `application`.\n\nStore that file somewhere where you will find it again (eg:\n`/var/www/yourapplication`) and make sure that `yourapplication` and all the\nlibraries that are in use are on the python load path. If you don\u2019t want to\ninstall it system wide consider using a virtual python instance.\n\nThe last thing you have to do is to create an Apache configuration file for\nyour application. In this example we are telling `mod_wsgi` to execute the\napplication under a different user for security reasons:\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "MultiDict", "path": "datastructures/index#werkzeug.datastructures.MultiDict", "type": "werkzeug.datastructures", "text": "\nA `MultiDict` is a dictionary subclass customized to deal with multiple values\nfor the same key which is for example used by the parsing functions in the\nwrappers. This is necessary because some HTML form elements pass multiple\nvalues for the same key.\n\n`MultiDict` implements all standard dictionary methods. Internally, it saves\nall values for a key as a list, but the standard dict access methods will only\nreturn the first value for a key. If you want to gain access to the other\nvalues, too, you have to use the `list` methods as explained below.\n\nBasic Usage:\n\nIt behaves like a normal dict thus all dict functions will only return the\nfirst value when multiple values for one key are found.\n\nFrom Werkzeug 0.3 onwards, the `KeyError` raised by this class is also a\nsubclass of the `BadRequest` HTTP exception and will render a page for a `400\nBAD REQUEST` if caught in a catch-all for HTTP exceptions.\n\nA `MultiDict` can be constructed from an iterable of `(key, value)` tuples, a\ndict, a `MultiDict` or from Werkzeug 0.2 onwards some keyword parameters.\n\nmapping \u2013 the initial value for the `MultiDict`. Either a regular dict, an\niterable of `(key, value)` tuples or `None`.\n\nAdds a new value for the key.\n\nNew in version 0.6.\n\nReturn a shallow copy of this object.\n\nReturn a deep copy of this object.\n\nCreate a new dictionary with keys from iterable and values set to value.\n\nReturn the default value if the requested data doesn\u2019t exist. If `type` is\nprovided and is a callable it should convert the value, return it or raise a\n`ValueError` if that is not possible. In this case the function will return\nthe default as if the value was not found:\n\nReturn the list of items for a given key. If that key is not in the\n`MultiDict`, the return value will be an empty list. Just like `get`,\n`getlist` accepts a `type` parameter. All items will be converted with the\ncallable defined there.\n\na `list` of all the values for the key.\n\nReturn an iterator of `(key, value)` pairs.\n\nmulti \u2013 If set to `True` the iterator returned will have a pair for each value\nof each key. Otherwise it will only contain pairs for the first value of each\nkey.\n\nReturn a iterator of `(key, values)` pairs, where values is the list of all\nvalues associated with the key.\n\nReturn an iterator of all values associated with a key. Zipping `keys()` and\nthis is the same as calling `lists()`:\n\nPop the first item for a list on the dict. Afterwards the key is removed from\nthe dict, so additional values are discarded:\n\nPop an item from the dict.\n\nPop a `(key, list)` tuple from the dict.\n\nPop the list for a key from the dict. If the key is not in the dict an empty\nlist is returned.\n\nChanged in version 0.5: If the key does no longer exist a list is returned\ninstead of raising an error.\n\nReturns the value for the key if it is in the dict, otherwise it returns\n`default` and sets that value for `key`.\n\nRemove the old values for a key and add new ones. Note that the list you pass\nthe values in will be shallow-copied before it is inserted in the dictionary.\n\nLike `setdefault` but sets multiple values. The list returned is not a copy,\nbut the list that is actually used internally. This means that you can put new\nvalues into the dict by appending items to the list:\n\na `list`\n\nReturn the contents as regular dict. If `flat` is `True` the returned dict\nwill only have the first item present, if `flat` is `False` all values will be\nreturned as lists.\n\nflat \u2013 If set to `False` the dict returned will have lists with all the values\nin it. Otherwise it will only contain the first value for each key.\n\na `dict`\n\nupdate() extends rather than replaces existing key lists:\n\nIf the value list for a key in `other_dict` is empty, no new values will be\nadded to the dict and the key will not be created:\n\nReturns an iterator of the first value on every key\u2019s value list.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "MultiDict.add()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.add", "type": "werkzeug.datastructures", "text": "\nAdds a new value for the key.\n\nNew in version 0.6.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "MultiDict.clear()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.clear", "type": "werkzeug.datastructures", "text": "\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "MultiDict.copy()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.copy", "type": "werkzeug.datastructures", "text": "\nReturn a shallow copy of this object.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "MultiDict.deepcopy()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.deepcopy", "type": "werkzeug.datastructures", "text": "\nReturn a deep copy of this object.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "MultiDict.fromkeys()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.fromkeys", "type": "werkzeug.datastructures", "text": "\nCreate a new dictionary with keys from iterable and values set to value.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "MultiDict.get()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.get", "type": "werkzeug.datastructures", "text": "\nReturn the default value if the requested data doesn\u2019t exist. If `type` is\nprovided and is a callable it should convert the value, return it or raise a\n`ValueError` if that is not possible. In this case the function will return\nthe default as if the value was not found:\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "MultiDict.getlist()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.getlist", "type": "werkzeug.datastructures", "text": "\nReturn the list of items for a given key. If that key is not in the\n`MultiDict`, the return value will be an empty list. Just like `get`,\n`getlist` accepts a `type` parameter. All items will be converted with the\ncallable defined there.\n\na `list` of all the values for the key.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "MultiDict.items()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.items", "type": "werkzeug.datastructures", "text": "\nReturn an iterator of `(key, value)` pairs.\n\nmulti \u2013 If set to `True` the iterator returned will have a pair for each value\nof each key. Otherwise it will only contain pairs for the first value of each\nkey.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "MultiDict.keys()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.keys", "type": "werkzeug.datastructures", "text": "\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "MultiDict.lists()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.lists", "type": "werkzeug.datastructures", "text": "\nReturn a iterator of `(key, values)` pairs, where values is the list of all\nvalues associated with the key.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "MultiDict.listvalues()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.listvalues", "type": "werkzeug.datastructures", "text": "\nReturn an iterator of all values associated with a key. Zipping `keys()` and\nthis is the same as calling `lists()`:\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "MultiDict.pop()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.pop", "type": "werkzeug.datastructures", "text": "\nPop the first item for a list on the dict. Afterwards the key is removed from\nthe dict, so additional values are discarded:\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "MultiDict.popitem()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.popitem", "type": "werkzeug.datastructures", "text": "\nPop an item from the dict.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "MultiDict.popitemlist()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.popitemlist", "type": "werkzeug.datastructures", "text": "\nPop a `(key, list)` tuple from the dict.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "MultiDict.poplist()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.poplist", "type": "werkzeug.datastructures", "text": "\nPop the list for a key from the dict. If the key is not in the dict an empty\nlist is returned.\n\nChanged in version 0.5: If the key does no longer exist a list is returned\ninstead of raising an error.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "MultiDict.setdefault()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.setdefault", "type": "werkzeug.datastructures", "text": "\nReturns the value for the key if it is in the dict, otherwise it returns\n`default` and sets that value for `key`.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "MultiDict.setlist()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.setlist", "type": "werkzeug.datastructures", "text": "\nRemove the old values for a key and add new ones. Note that the list you pass\nthe values in will be shallow-copied before it is inserted in the dictionary.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "MultiDict.setlistdefault()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.setlistdefault", "type": "werkzeug.datastructures", "text": "\nLike `setdefault` but sets multiple values. The list returned is not a copy,\nbut the list that is actually used internally. This means that you can put new\nvalues into the dict by appending items to the list:\n\na `list`\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "MultiDict.to_dict()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.to_dict", "type": "werkzeug.datastructures", "text": "\nReturn the contents as regular dict. If `flat` is `True` the returned dict\nwill only have the first item present, if `flat` is `False` all values will be\nreturned as lists.\n\nflat \u2013 If set to `False` the dict returned will have lists with all the values\nin it. Otherwise it will only contain the first value for each key.\n\na `dict`\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "MultiDict.update()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.update", "type": "werkzeug.datastructures", "text": "\nupdate() extends rather than replaces existing key lists:\n\nIf the value list for a key in `other_dict` is empty, no new values will be\nadded to the dict and the key will not be created:\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "MultiDict.values()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.values", "type": "werkzeug.datastructures", "text": "\nReturns an iterator of the first value on every key\u2019s value list.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "OrderedMultiDict", "path": "datastructures/index#werkzeug.datastructures.OrderedMultiDict", "type": "werkzeug.datastructures", "text": "\nWorks like a regular `MultiDict` but preserves the order of the fields. To\nconvert the ordered multi dict into a list you can use the `items()` method\nand pass it `multi=True`.\n\nIn general an `OrderedMultiDict` is an order of magnitude slower than a\n`MultiDict`.\n\nnote\n\nDue to a limitation in Python you cannot convert an ordered multi dict into a\nregular dict by using `dict(multidict)`. Instead you have to use the\n`to_dict()` method, otherwise the internal bucket objects are exposed.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "parse_accept_header()", "path": "http/index#werkzeug.http.parse_accept_header", "type": "werkzeug.http", "text": "\nParses an HTTP Accept-* header. This does not implement a complete valid\nalgorithm but one that supports at least value and quality extraction.\n\nReturns a new `Accept` object (basically a list of `(value, quality)` tuples\nsorted by the quality with some additional accessor methods).\n\nThe second parameter can be a subclass of `Accept` that is created with the\nparsed values and returned.\n\nan instance of `cls`.\n\nwerkzeug.http._TAnyAccept\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "parse_authorization_header()", "path": "http/index#werkzeug.http.parse_authorization_header", "type": "werkzeug.http", "text": "\nParse an HTTP basic/digest authorization header transmitted by the web\nbrowser. The return value is either `None` if the header was invalid or not\ngiven, otherwise an `Authorization` object.\n\nvalue (Optional[str]) \u2013 the authorization header to parse.\n\na `Authorization` object or `None`.\n\nOptional[werkzeug.datastructures.Authorization]\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "parse_cache_control_header()", "path": "http/index#werkzeug.http.parse_cache_control_header", "type": "werkzeug.http", "text": "\nParse a cache control header. The RFC differs between response and request\ncache control, this method does not. It\u2019s your responsibility to not use the\nwrong control statements.\n\nNew in version 0.5: The `cls` was added. If not specified an immutable\n`RequestCacheControl` is returned.\n\na `cls` object.\n\nwerkzeug.http._TAnyCC\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "parse_content_range_header()", "path": "http/index#werkzeug.http.parse_content_range_header", "type": "werkzeug.http", "text": "\nParses a range header into a `ContentRange` object or `None` if parsing is not\npossible.\n\nNew in version 0.7.\n\nOptional[werkzeug.datastructures.ContentRange]\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "parse_cookie()", "path": "http/index#werkzeug.http.parse_cookie", "type": "werkzeug.http", "text": "\nParse a cookie from a string or WSGI environ.\n\nThe same key can be provided multiple times, the values are stored in-order.\nThe default `MultiDict` will have the first value first, and all values can be\nretrieved with `MultiDict.getlist()`.\n\nds.MultiDict[str, str]\n\nChanged in version 1.0.0: Returns a `MultiDict` instead of a\n`TypeConversionDict`.\n\nChanged in version 0.5: Returns a `TypeConversionDict` instead of a regular\ndict. The `cls` parameter was added.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "parse_date()", "path": "http/index#werkzeug.http.parse_date", "type": "werkzeug.http", "text": "\nParse an RFC 2822 date into a timezone-aware `datetime.datetime` object, or\n`None` if parsing fails.\n\nThis is a wrapper for `email.utils.parsedate_to_datetime()`. It returns `None`\nif parsing fails instead of raising an exception, and always returns a\ntimezone-aware datetime object. If the string doesn\u2019t have timezone\ninformation, it is assumed to be UTC.\n\nvalue (Optional[str]) \u2013 A string with a supported date format.\n\nOptional[datetime.datetime]\n\nChanged in version 2.0: Return a timezone-aware datetime object. Use\n`email.utils.parsedate_to_datetime`.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "parse_dict_header()", "path": "http/index#werkzeug.http.parse_dict_header", "type": "werkzeug.http", "text": "\nParse lists of key, value pairs as described by RFC 2068 Section 2 and convert\nthem into a python dict (or any other mapping object created from the type\nwith a dict like interface provided by the `cls` argument):\n\nIf there is no value for a key it will be `None`:\n\nTo create a header from the `dict` again, use the `dump_header()` function.\n\nChanged in version 0.9: Added support for `cls` argument.\n\nan instance of `cls`\n\nDict[str, str]\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "parse_etags()", "path": "http/index#werkzeug.http.parse_etags", "type": "werkzeug.http", "text": "\nParse an etag header.\n\nvalue (Optional[str]) \u2013 the tag header to parse\n\nan `ETags` object.\n\nwerkzeug.datastructures.ETags\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "parse_form_data()", "path": "http/index#werkzeug.formparser.parse_form_data", "type": "werkzeug.formparser", "text": "\nParse the form data in the environ and return it as tuple in the form\n`(stream, form, files)`. You should only call this method if the transport\nmethod is `POST`, `PUT`, or `PATCH`.\n\nIf the mimetype of the data transmitted is `multipart/form-data` the files\nmultidict will be filled with `FileStorage` objects. If the mimetype is\nunknown the input stream is wrapped and returned as first argument, else the\nstream is empty.\n\nThis is a shortcut for the common usage of `FormDataParser`.\n\nHave a look at Dealing with Request Data for more details.\n\nNew in version 0.5.1: The optional `silent` flag was added.\n\nNew in version 0.5: The `max_form_memory_size`, `max_content_length` and `cls`\nparameters were added.\n\nA tuple in the form `(stream, form, files)`.\n\nt_parse_result\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "parse_if_range_header()", "path": "http/index#werkzeug.http.parse_if_range_header", "type": "werkzeug.http", "text": "\nParses an if-range header which can be an etag or a date. Returns a `IfRange`\nobject.\n\nChanged in version 2.0: If the value represents a datetime, it is timezone-\naware.\n\nNew in version 0.7.\n\nvalue (Optional[str]) \u2013\n\nwerkzeug.datastructures.IfRange\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "parse_list_header()", "path": "http/index#werkzeug.http.parse_list_header", "type": "werkzeug.http", "text": "\nParse lists as described by RFC 2068 Section 2.\n\nIn particular, parse comma-separated lists where the elements of the list may\ninclude quoted-strings. A quoted-string could contain a comma. A non-quoted\nstring could have quotes in the middle. Quotes are removed automatically after\nparsing.\n\nIt basically works like `parse_set_header()` just that items may appear\nmultiple times and case sensitivity is preserved.\n\nThe return value is a standard `list`:\n\nTo create a header from the `list` again, use the `dump_header()` function.\n\nvalue (str) \u2013 a string with a list header.\n\n`list`\n\nList[str]\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "parse_options_header()", "path": "http/index#werkzeug.http.parse_options_header", "type": "werkzeug.http", "text": "\nParse a `Content-Type` like header into a tuple with the content type and the\noptions:\n\nThis should not be used to parse `Cache-Control` like headers that use a\nslightly different format. For these headers use the `parse_dict_header()`\nfunction.\n\nChanged in version 0.15: RFC 2231 parameter continuations are handled.\n\nNew in version 0.5.\n\n(mimetype, options) or (mimetype, options, mimetype, options, \u2026) if\nmultiple=True\n\nUnion[Tuple[str, Dict[str, str]], Tuple[Any, \u2026]]\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "parse_range_header()", "path": "http/index#werkzeug.http.parse_range_header", "type": "werkzeug.http", "text": "\nParses a range header into a `Range` object. If the header is missing or\nmalformed `None` is returned. `ranges` is a list of `(start, stop)` tuples\nwhere the ranges are non-inclusive.\n\nNew in version 0.7.\n\nOptional[werkzeug.datastructures.Range]\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "parse_set_header()", "path": "http/index#werkzeug.http.parse_set_header", "type": "werkzeug.http", "text": "\nParse a set-like header and return a `HeaderSet` object:\n\nThe return value is an object that treats the items case-insensitively and\nkeeps the order of the items:\n\nTo create a header from the `HeaderSet` again, use the `dump_header()`\nfunction.\n\na `HeaderSet`\n\nwerkzeug.datastructures.HeaderSet\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "parse_www_authenticate_header()", "path": "http/index#werkzeug.http.parse_www_authenticate_header", "type": "werkzeug.http", "text": "\nParse an HTTP WWW-Authenticate header into a `WWWAuthenticate` object.\n\na `WWWAuthenticate` object.\n\nwerkzeug.datastructures.WWWAuthenticate\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "PathConverter", "path": "routing/index#werkzeug.routing.PathConverter", "type": "werkzeug.routing", "text": "\nLike the default `UnicodeConverter`, but it also matches slashes. This is\nuseful for wikis and similar applications:\n\nNone\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "pbkdf2_bin()", "path": "utils/index#werkzeug.security.pbkdf2_bin", "type": "werkzeug.security", "text": "\nReturns a binary digest for the PBKDF2 hash algorithm of `data` with the given\n`salt`. It iterates `iterations` times and produces a key of `keylen` bytes.\nBy default, SHA-256 is used as hash function; a different hashlib `hashfunc`\ncan be provided.\n\nbytes\n\nDeprecated since version 2.0: Will be removed in Werkzeug 2.1. Use\n`hashlib.pbkdf2_hmac()` instead.\n\nNew in version 0.9.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "pbkdf2_hex()", "path": "utils/index#werkzeug.security.pbkdf2_hex", "type": "werkzeug.security", "text": "\nLike `pbkdf2_bin()`, but returns a hex-encoded string.\n\nstr\n\nDeprecated since version 2.0: Will be removed in Werkzeug 2.1. Use\n`hashlib.pbkdf2_hmac()` instead.\n\nNew in version 0.9.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "peek_path_info()", "path": "wsgi/index#werkzeug.wsgi.peek_path_info", "type": "werkzeug.wsgi", "text": "\nReturns the next segment on the `PATH_INFO` or `None` if there is none. Works\nlike `pop_path_info()` without modifying the environment:\n\nIf the `charset` is set to `None` bytes are returned.\n\nChanged in version 0.9: The path is now decoded and a charset and encoding\nparameter can be provided.\n\nNew in version 0.5.\n\nOptional[str]\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "pop_path_info()", "path": "wsgi/index#werkzeug.wsgi.pop_path_info", "type": "werkzeug.wsgi", "text": "\nRemoves and returns the next segment of `PATH_INFO`, pushing it onto\n`SCRIPT_NAME`. Returns `None` if there is nothing left on `PATH_INFO`.\n\nIf the `charset` is set to `None` bytes are returned.\n\nIf there are empty segments (`'/foo//bar`) these are ignored but properly\npushed to the `SCRIPT_NAME`:\n\nChanged in version 0.9: The path is now decoded and a charset and encoding\nparameter can be provided.\n\nNew in version 0.5.\n\nOptional[str]\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "ProfilerMiddleware", "path": "middleware/profiler/index#werkzeug.middleware.profiler.ProfilerMiddleware", "type": "werkzeug.middleware.profiler", "text": "\nWrap a WSGI application and profile the execution of each request. Responses\nare buffered so that timings are more exact.\n\nIf `stream` is given, `pstats.Stats` are written to it after each request. If\n`profile_dir` is given, `cProfile` data files are saved to that directory, one\nfile per request.\n\nThe filename can be customized by passing `filename_format`. If it is a\nstring, it will be formatted using `str.format()` with the following fields\navailable:\n\nIf it is a callable, it will be called with the WSGI `environ` dict and should\nreturn a filename.\n\nNone\n\nChanged in version 0.15: Stats are written even if `profile_dir` is given, and\ncan be disable by passing `stream=None`.\n\nNew in version 0.15: Added `filename_format`.\n\nNew in version 0.9: Added `restrictions` and `profile_dir`.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "ProxyFix", "path": "middleware/proxy_fix/index#werkzeug.middleware.proxy_fix.ProxyFix", "type": "werkzeug.middleware.proxy_fix", "text": "\nAdjust the WSGI environ based on `X-Forwarded-` that proxies in front of the\napplication may set.\n\nYou must tell the middleware how many proxies set each header so it knows what\nvalues to trust. It is a security issue to trust values that came from the\nclient rather than a proxy.\n\nThe original values of the headers are stored in the WSGI environ as\n`werkzeug.proxy_fix.orig`, a dict.\n\nNone\n\nChanged in version 1.0: Deprecated code has been removed:\n\nChanged in version 0.15: All headers support multiple values. The\n`num_proxies` argument is deprecated. Each header is configured with a\nseparate number of trusted proxies.\n\nChanged in version 0.15: Original WSGI environ values are stored in the\n`werkzeug.proxy_fix.orig` dict. `orig_remote_addr`, `orig_wsgi_url_scheme`,\nand `orig_http_host` are deprecated and will be removed in 1.0.\n\nChanged in version 0.15: Support `X-Forwarded-Port` and `X-Forwarded-Prefix`.\n\nChanged in version 0.15: `X-Forwarded-Host` and `X-Forwarded-Port` modify\n`SERVER_NAME` and `SERVER_PORT`.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "ProxyMiddleware", "path": "middleware/http_proxy/index#werkzeug.middleware.http_proxy.ProxyMiddleware", "type": "werkzeug.middleware.http_proxy", "text": "\nProxy requests under a path to an external server, routing other requests to\nthe app.\n\nThis middleware can only proxy HTTP requests, as HTTP is the only protocol\nhandled by the WSGI server. Other protocols, such as WebSocket requests,\ncannot be proxied at this layer. This should only be used for development, in\nproduction a real proxy server should be used.\n\nThe middleware takes a dict mapping a path prefix to a dict describing the\nhost to be proxied to:\n\nEach host has the following options:\n\nThe target URL to dispatch to. This is required.\n\nWhether to remove the prefix from the URL before dispatching it to the target.\nThe default is `False`.\n\nThe host header is automatically rewritten to the URL of the target.\n\nThe host header is unmodified from the client request.\n\nThe host header is overwritten with the value.\n\nA dictionary of headers to be sent with the request to the target. The default\nis `{}`.\n\nA `ssl.SSLContext` defining how to verify requests if the target is HTTPS. The\ndefault is `None`.\n\nIn the example above, everything under `\"/static/\"` is proxied to the server\non port 5001. The host header is rewritten to the target, and the `\"/static/\"`\nprefix is removed from the URLs.\n\nNone\n\nNew in version 0.14.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Quickstart", "path": "quickstart/index", "type": "Other", "text": "\nThis part of the documentation shows how to use the most important parts of\nWerkzeug. It\u2019s intended as a starting point for developers with basic\nunderstanding of PEP 3333 (WSGI) and RFC 2616 (HTTP).\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "quote_etag()", "path": "http/index#werkzeug.http.quote_etag", "type": "werkzeug.http", "text": "\nQuote an etag.\n\nstr\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "quote_header_value()", "path": "http/index#werkzeug.http.quote_header_value", "type": "werkzeug.http", "text": "\nQuote a header value if necessary.\n\nNew in version 0.5.\n\nstr\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Range", "path": "datastructures/index#werkzeug.datastructures.Range", "type": "werkzeug.datastructures", "text": "\nRepresents a `Range` header. All methods only support only bytes as the unit.\nStores a list of ranges if given, but the methods only work if only one range\nis provided.\n\nValueError \u2013 If the ranges provided are invalid.\n\nChanged in version 0.15: The ranges passed in are validated.\n\nNew in version 0.7.\n\nCreates a `ContentRange` object from the current range and given content\nlength.\n\nIf the range is for bytes, the length is not None and there is exactly one\nrange and it is satisfiable it returns a `(start, stop)` tuple, otherwise\n`None`.\n\nA list of `(begin, end)` tuples for the range header provided. The ranges are\nnon-inclusive.\n\nConverts the object into `Content-Range` HTTP header, based on given length\n\nConverts the object back into an HTTP header.\n\nThe units of this range. Usually \u201cbytes\u201d.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Range.make_content_range()", "path": "datastructures/index#werkzeug.datastructures.Range.make_content_range", "type": "werkzeug.datastructures", "text": "\nCreates a `ContentRange` object from the current range and given content\nlength.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Range.ranges", "path": "datastructures/index#werkzeug.datastructures.Range.ranges", "type": "werkzeug.datastructures", "text": "\nA list of `(begin, end)` tuples for the range header provided. The ranges are\nnon-inclusive.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Range.range_for_length()", "path": "datastructures/index#werkzeug.datastructures.Range.range_for_length", "type": "werkzeug.datastructures", "text": "\nIf the range is for bytes, the length is not None and there is exactly one\nrange and it is satisfiable it returns a `(start, stop)` tuple, otherwise\n`None`.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Range.to_content_range_header()", "path": "datastructures/index#werkzeug.datastructures.Range.to_content_range_header", "type": "werkzeug.datastructures", "text": "\nConverts the object into `Content-Range` HTTP header, based on given length\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Range.to_header()", "path": "datastructures/index#werkzeug.datastructures.Range.to_header", "type": "werkzeug.datastructures", "text": "\nConverts the object back into an HTTP header.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Range.units", "path": "datastructures/index#werkzeug.datastructures.Range.units", "type": "werkzeug.datastructures", "text": "\nThe units of this range. Usually \u201cbytes\u201d.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "redirect()", "path": "utils/index#werkzeug.utils.redirect", "type": "werkzeug.utils", "text": "\nReturns a response object (a WSGI application) that, if called, redirects the\nclient to the target location. Supported codes are 301, 302, 303, 305, 307,\nand 308. 300 is not supported because it\u2019s not a real redirect and 304 because\nit\u2019s the answer for a request with a request with defined If-Modified-Since\nheaders.\n\nNew in version 0.10: The class used for the Response object can now be passed\nin.\n\nNew in version 0.6: The location can now be a unicode string that is encoded\nusing the `iri_to_uri()` function.\n\nResponse\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "release_local()", "path": "local/index#werkzeug.local.release_local", "type": "werkzeug.local", "text": "\nReleases the contents of the local for the current context. This makes it\npossible to use locals without a manager.\n\nExample:\n\nWith this function one can release `Local` objects as well as `LocalStack`\nobjects. However it is not possible to release data held by proxies that way,\none always has to retain a reference to the underlying local object in order\nto be able to release it.\n\nNew in version 0.6.1.\n\nlocal (Union[werkzeug.local.Local, werkzeug.local.LocalStack]) \u2013\n\nNone\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "remove_entity_headers()", "path": "http/index#werkzeug.http.remove_entity_headers", "type": "werkzeug.http", "text": "\nRemove all entity headers from a list or `Headers` object. This operation\nworks in-place. `Expires` and `Content-Location` headers are by default not\nremoved. The reason for this is RFC 2616 section 10.3.5 which specifies some\nentity headers that should be sent.\n\nChanged in version 0.5: added `allowed` parameter.\n\nNone\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "remove_hop_by_hop_headers()", "path": "http/index#werkzeug.http.remove_hop_by_hop_headers", "type": "werkzeug.http", "text": "\nRemove all HTTP/1.1 \u201cHop-by-Hop\u201d headers from a list or `Headers` object. This\noperation works in-place.\n\nNew in version 0.5.\n\nheaders (Union[werkzeug.datastructures.Headers, List[Tuple[str, str]]]) \u2013 a\nlist or `Headers` object.\n\nNone\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Request", "path": "wrappers/index#werkzeug.wrappers.Request", "type": "werkzeug.wrappers", "text": "\nRepresents an incoming WSGI HTTP request, with headers and body taken from the\nWSGI environment. Has properties and methods for using the functionality\ndefined by various HTTP specs. The data in requests object is read-only.\n\nText data is assumed to use UTF-8 encoding, which should be true for the vast\nmajority of modern clients. Using an encoding set by the client is unsafe in\nPython due to extra encodings it provides, such as `zip`. To change the\nassumed encoding, subclass and replace `charset`.\n\nNone\n\nChanged in version 2.0: Combine `BaseRequest` and mixins into a single\n`Request` class. Using the old classes is deprecated and will be removed in\nWerkzeug 2.1.\n\nChanged in version 0.5: Read-only mode is enforced with immutable classes for\nall data.\n\nCalled to get a stream for the file upload.\n\nThis must provide a file-like class with `read()`, `readline()` and `seek()`\nmethods that is both writeable and readable.\n\nThe default implementation returns a temporary file if the total content\nlength is higher than 500KB. Because many browsers do not provide a content\nlength for the files only the total content length matters.\n\nBinaryIO\n\nList of charsets this client supports as `CharsetAccept` object.\n\nList of encodings this client accepts. Encodings in a HTTP term are\ncompression encodings such as gzip. For charsets have a look at\n`accept_charset`.\n\nList of languages this client accepts as `LanguageAccept` object.\n\nList of mimetypes this client supports as `MIMEAccept` object.\n\nSent with a preflight request to indicate which headers will be sent with the\ncross origin request. Set `access_control_allow_headers` on the response to\nindicate which headers are allowed.\n\nSent with a preflight request to indicate which method will be used for the\ncross origin request. Set `access_control_allow_methods` on the response to\nindicate which methods are allowed.\n\nIf a forwarded header exists this is a list of all ip addresses from the\nclient ip to the last proxy server.\n\nDecorate a function as responder that accepts the request as the last\nargument. This works like the `responder()` decorator but the function is\npassed the request object as the last argument and the request object will be\nclosed automatically:\n\nAs of Werkzeug 0.14 HTTP exceptions are automatically caught and converted to\nresponses instead of failing.\n\nf (Callable[[Request], WSGIApplication]) \u2013 the WSGI callable to decorate\n\na new WSGI callable\n\nWSGIApplication\n\nThe parsed URL parameters (the part in the URL after the question mark).\n\nBy default an `ImmutableMultiDict` is returned from this function. This can be\nchanged by setting `parameter_storage_class` to a different type. This might\nbe necessary if the order of the form data is important.\n\nThe `Authorization` object in parsed form.\n\nLike `url` but without the query string.\n\nA `RequestCacheControl` object for the incoming cache control headers.\n\nCloses associated resources of this request object. This closes all file\nhandles explicitly. You can also use the request object in a with statement\nwhich will automatically close it.\n\nNew in version 0.9.\n\nNone\n\nThe Content-Encoding entity-header field is used as a modifier to the media-\ntype. When present, its value indicates what additional content codings have\nbeen applied to the entity-body, and thus what decoding mechanisms must be\napplied in order to obtain the media-type referenced by the Content-Type\nheader field.\n\nNew in version 0.9.\n\nThe Content-Length entity-header field indicates the size of the entity-body\nin bytes or, in the case of the HEAD method, the size of the entity-body that\nwould have been sent had the request been a GET.\n\nThe Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest\nof the entity-body for the purpose of providing an end-to-end message\nintegrity check (MIC) of the entity-body. (Note: a MIC is good for detecting\naccidental modification of the entity-body in transit, but is not proof\nagainst malicious attacks.)\n\nNew in version 0.9.\n\nThe Content-Type entity-header field indicates the media type of the entity-\nbody sent to the recipient or, in the case of the HEAD method, the media type\nthat would have been sent had the request been a GET.\n\nA `dict` with the contents of all cookies transmitted with the request.\n\nContains the incoming request data as string in case it came with a mimetype\nWerkzeug does not handle.\n\nThe Date general-header field represents the date and time at which the\nmessage was originated, having the same semantics as orig-date in RFC 822.\n\nChanged in version 2.0: The datetime object is timezone-aware.\n\nalias of `werkzeug.datastructures.ImmutableMultiDict`\n\nDisable the `data` property to avoid reading from the input stream.\n\nDeprecated since version 2.0: Will be removed in Werkzeug 2.1. Create the\nrequest with `shallow=True` instead.\n\nNew in version 0.9.\n\nThe WSGI environment containing HTTP headers and information from the WSGI\nserver.\n\n`MultiDict` object containing all uploaded files. Each key in `files` is the\nname from the `<input type=\"file\" name=\"\">`. Each value in `files` is a\nWerkzeug `FileStorage` object.\n\nIt basically behaves like a standard file object you know from Python, with\nthe difference that it also has a `save()` function that can store the file on\nthe filesystem.\n\nNote that `files` will only contain data if the request method was POST, PUT\nor PATCH and the `<form>` that posted to the request had\n`enctype=\"multipart/form-data\"`. It will be empty otherwise.\n\nSee the `MultiDict` / `FileStorage` documentation for more details about the\nused data structure.\n\nThe form parameters. By default an `ImmutableMultiDict` is returned from this\nfunction. This can be changed by setting `parameter_storage_class` to a\ndifferent type. This might be necessary if the order of the form data is\nimportant.\n\nPlease keep in mind that file uploads will not end up here, but instead in the\n`files` attribute.\n\nChanged in version 0.9: Previous to Werkzeug 0.9 this would only contain form\ndata for POST and PUT requests.\n\nalias of `werkzeug.formparser.FormDataParser`\n\nCreate a new request object based on the values provided. If environ is given\nmissing values are filled from there. This method is useful for small scripts\nwhen you need to simulate a request from an URL. Do not use this method for\nunittesting, there is a full featured client object (`Client`) that allows to\ncreate multipart requests, support for cookies etc.\n\nThis accepts the same options as the `EnvironBuilder`.\n\nChanged in version 0.5: This method now accepts the same arguments as\n`EnvironBuilder`. Because of this the `environ` parameter is now called\n`environ_overrides`.\n\nrequest object\n\nwerkzeug.wrappers.request.Request\n\nRequested path, including the query string.\n\nThis reads the buffered incoming data from the client into one bytes object.\nBy default this is cached but that behavior can be changed by setting `cache`\nto `False`.\n\nUsually it\u2019s a bad idea to call this method without checking the content\nlength first as a client could send dozens of megabytes or more to cause\nmemory problems on the server.\n\nNote that if the form data was already parsed this method will not return\nanything as form data parsing does not cache the data like this method does.\nTo implicitly invoke form data parsing function set `parse_form_data` to\n`True`. When this is done the return value of this method will be an empty\nstring if the form parser handles the data. This generally is not necessary as\nif the whole data is cached (which is the default) the form parser will used\nthe cached data to parse the form data. Please be generally aware of checking\nthe content length first in any case before calling this method to avoid\nexhausting server memory.\n\nIf `as_text` is set to `True` the return value will be a decoded string.\n\nNew in version 0.9.\n\nUnion[bytes, str]\n\nParse `data` as JSON.\n\nIf the mimetype does not indicate JSON (application/json, see `is_json()`),\nthis returns `None`.\n\nIf parsing fails, `on_json_loading_failed()` is called and its return value is\nused as the return value.\n\nOptional[Any]\n\nThe headers received with the request.\n\nThe host name the request was made to, including the port if it\u2019s non-\nstandard. Validated with `trusted_hosts`.\n\nThe request URL scheme and host only.\n\nAn object containing all the etags in the `If-Match` header.\n\n`ETags`\n\nThe parsed `If-Modified-Since` header as a datetime object.\n\nChanged in version 2.0: The datetime object is timezone-aware.\n\nAn object containing all the etags in the `If-None-Match` header.\n\n`ETags`\n\nThe parsed `If-Range` header.\n\nChanged in version 2.0: `IfRange.date` is timezone-aware.\n\nNew in version 0.7.\n\nThe parsed `If-Unmodified-Since` header as a datetime object.\n\nChanged in version 2.0: The datetime object is timezone-aware.\n\nThe WSGI input stream.\n\nIn general it\u2019s a bad idea to use this one because you can easily read past\nthe boundary. Use the `stream` instead.\n\nCheck if the mimetype indicates JSON data, either application/json or\napplication/*+json.\n\nboolean that is `True` if the application is served by a WSGI server that\nspawns multiple processes.\n\nboolean that is `True` if the application is served by a multithreaded WSGI\nserver.\n\nboolean that is `True` if the application will be executed only once in a\nprocess lifetime. This is the case for CGI for example, but it\u2019s not\nguaranteed that the execution only happens one time.\n\n`True` if the request was made with a secure protocol (HTTPS or WSS).\n\nThe parsed JSON data if `mimetype` indicates JSON (application/json, see\n`is_json()`).\n\nCalls `get_json()` with default arguments.\n\nA module or other object that has `dumps` and `loads` functions that match the\nAPI of the built-in `json` module.\n\nalias of `werkzeug.datastructures.ImmutableList`\n\nCreates the form data parser. Instantiates the `form_data_parser_class` with\nsome parameters.\n\nNew in version 0.8.\n\nwerkzeug.formparser.FormDataParser\n\nthe maximum content length. This is forwarded to the form data parsing\nfunction (`parse_form_data()`). When set and the `form` or `files` attribute\nis accessed and the parsing fails because more than the specified value is\ntransmitted a `RequestEntityTooLarge` exception is raised.\n\nHave a look at Dealing with Request Data for more details.\n\nNew in version 0.5.\n\nthe maximum form field size. This is forwarded to the form data parsing\nfunction (`parse_form_data()`). When set and the `form` or `files` attribute\nis accessed and the data in memory for post data is longer than the specified\nvalue a `RequestEntityTooLarge` exception is raised.\n\nHave a look at Dealing with Request Data for more details.\n\nNew in version 0.5.\n\nThe Max-Forwards request-header field provides a mechanism with the TRACE and\nOPTIONS methods to limit the number of proxies or gateways that can forward\nthe request to the next inbound server.\n\nThe method the request was made with, such as `GET`.\n\nLike `content_type`, but without parameters (eg, without charset, type etc.)\nand always lowercase. For example if the content type is `text/HTML;\ncharset=utf-8` the mimetype would be `'text/html'`.\n\nThe mimetype parameters as dict. For example if the content type is\n`text/html; charset=utf-8` the params would be `{'charset': 'utf-8'}`.\n\nCalled if `get_json()` parsing fails and isn\u2019t silenced. If this method\nreturns a value, it is used as the return value for `get_json()`. The default\nimplementation raises `BadRequest`.\n\ne (ValueError) \u2013\n\nAny\n\nThe host that the request originated from. Set `access_control_allow_origin`\non the response to indicate which origins are allowed.\n\nalias of `werkzeug.datastructures.ImmutableMultiDict`\n\nThe path part of the URL after `root_path`. This is the path used for routing\nwithin the application.\n\nThe Pragma general-header field is used to include implementation-specific\ndirectives that might apply to any recipient along the request/response chain.\nAll pragma directives specify optional behavior from the viewpoint of the\nprotocol; however, some systems MAY require that behavior be consistent with\nthe directives.\n\nThe part of the URL after the \u201c?\u201d. This is the raw value, use `args` for the\nparsed values.\n\nThe parsed `Range` header.\n\nNew in version 0.7.\n\n`Range`\n\nThe Referer[sic] request-header field allows the client to specify, for the\nserver\u2019s benefit, the address (URI) of the resource from which the Request-URI\nwas obtained (the \u201creferrer\u201d, although the header field is misspelled).\n\nThe address of the client sending the request.\n\nIf the server supports user authentication, and the script is protected, this\nattribute contains the username the user has authenticated as.\n\nThe prefix that the application is mounted under, without a trailing slash.\n`path` comes after this.\n\nThe request URL scheme, host, and root path. This is the root that the\napplication is accessed from.\n\nThe URL scheme of the protocol the request used, such as `https` or `wss`.\n\nAlias for `self.root_path`. `environ[\"SCRIPT_ROOT\"]` without a trailing slash.\n\nThe address of the server. `(host, port)`, `(path, None)` for unix sockets, or\n`None` if not known.\n\nSet when creating the request object. If `True`, reading from the request body\nwill cause a `RuntimeException`. Useful to prevent modifying the stream from\nmiddleware.\n\nIf the incoming form data was not encoded with a known mimetype the data is\nstored unmodified in this stream for consumption. Most of the time it is a\nbetter idea to use `data` which will give you that data as a string. The\nstream only returns the data once.\n\nUnlike `input_stream` this stream is properly guarded that you can\u2019t\naccidentally read past the length of the input. Werkzeug will internally\nalways refer to this stream to read data which makes it possible to wrap this\nobject with a stream that does filtering.\n\nChanged in version 0.9: This stream is now always available but might be\nconsumed by the form parser later on. Previously the stream was only set if no\nparsing happened.\n\nThe full request URL with the scheme, host, root path, path, and query string.\n\nThe charset that is assumed for URLs. Defaults to the value of `charset`.\n\nNew in version 0.6.\n\nAlias for `root_url`. The URL with scheme, host, and root path. For example,\n`https://example.com/app/`.\n\nThe user agent. Use `user_agent.string` to get the header value. Set\n`user_agent_class` to a subclass of `UserAgent` to provide parsing for the\nother properties or other extended data.\n\nChanged in version 2.0: The built in parser is deprecated and will be removed\nin Werkzeug 2.1. A `UserAgent` subclass must be set to parse data from the\nstring.\n\nalias of `werkzeug.useragents._UserAgent`\n\nA `werkzeug.datastructures.CombinedMultiDict` that combines `args` and `form`.\n\nFor GET requests, only `args` are present, not `form`.\n\nChanged in version 2.0: For GET requests, only `args` are present, not `form`.\n\n`True` if the request method carries content. By default this is true if a\n`Content-Type` is sent.\n\nNew in version 0.8.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Request / Response Objects", "path": "wrappers/index", "type": "Other", "text": "\nThe request and response objects wrap the WSGI environment or the return value\nfrom a WSGI application so that it is another WSGI application (wraps a whole\napplication).\n\nYour WSGI application is always passed two arguments. The WSGI \u201cenvironment\u201d\nand the WSGI `start_response` function that is used to start the response\nphase. The `Request` class wraps the `environ` for easier access to request\nvariables (form data, request headers etc.).\n\nThe `Response` on the other hand is a standard WSGI application that you can\ncreate. The simple hello world in Werkzeug looks like this:\n\nTo make it more useful you can replace it with a function and do some\nprocessing:\n\nBecause this is a very common task the `Request` object provides a helper for\nthat. The above code can be rewritten like this:\n\nThe `application` is still a valid WSGI application that accepts the\nenvironment and `start_response` callable.\n\nThe implementation of the Werkzeug request and response objects are trying to\nguard you from common pitfalls by disallowing certain things as much as\npossible. This serves two purposes: high performance and avoiding of pitfalls.\n\nFor the request object the following rules apply:\n\nFor the response object the following rules apply:\n\nRepresents an incoming WSGI HTTP request, with headers and body taken from the\nWSGI environment. Has properties and methods for using the functionality\ndefined by various HTTP specs. The data in requests object is read-only.\n\nText data is assumed to use UTF-8 encoding, which should be true for the vast\nmajority of modern clients. Using an encoding set by the client is unsafe in\nPython due to extra encodings it provides, such as `zip`. To change the\nassumed encoding, subclass and replace `charset`.\n\nNone\n\nChanged in version 2.0: Combine `BaseRequest` and mixins into a single\n`Request` class. Using the old classes is deprecated and will be removed in\nWerkzeug 2.1.\n\nChanged in version 0.5: Read-only mode is enforced with immutable classes for\nall data.\n\nCalled to get a stream for the file upload.\n\nThis must provide a file-like class with `read()`, `readline()` and `seek()`\nmethods that is both writeable and readable.\n\nThe default implementation returns a temporary file if the total content\nlength is higher than 500KB. Because many browsers do not provide a content\nlength for the files only the total content length matters.\n\nBinaryIO\n\nList of charsets this client supports as `CharsetAccept` object.\n\nList of encodings this client accepts. Encodings in a HTTP term are\ncompression encodings such as gzip. For charsets have a look at\n`accept_charset`.\n\nList of languages this client accepts as `LanguageAccept` object.\n\nList of mimetypes this client supports as `MIMEAccept` object.\n\nSent with a preflight request to indicate which headers will be sent with the\ncross origin request. Set `access_control_allow_headers` on the response to\nindicate which headers are allowed.\n\nSent with a preflight request to indicate which method will be used for the\ncross origin request. Set `access_control_allow_methods` on the response to\nindicate which methods are allowed.\n\nIf a forwarded header exists this is a list of all ip addresses from the\nclient ip to the last proxy server.\n\nDecorate a function as responder that accepts the request as the last\nargument. This works like the `responder()` decorator but the function is\npassed the request object as the last argument and the request object will be\nclosed automatically:\n\nAs of Werkzeug 0.14 HTTP exceptions are automatically caught and converted to\nresponses instead of failing.\n\nf (Callable[[Request], WSGIApplication]) \u2013 the WSGI callable to decorate\n\na new WSGI callable\n\nWSGIApplication\n\nThe parsed URL parameters (the part in the URL after the question mark).\n\nBy default an `ImmutableMultiDict` is returned from this function. This can be\nchanged by setting `parameter_storage_class` to a different type. This might\nbe necessary if the order of the form data is important.\n\nThe `Authorization` object in parsed form.\n\nLike `url` but without the query string.\n\nA `RequestCacheControl` object for the incoming cache control headers.\n\nCloses associated resources of this request object. This closes all file\nhandles explicitly. You can also use the request object in a with statement\nwhich will automatically close it.\n\nNew in version 0.9.\n\nNone\n\nThe Content-Encoding entity-header field is used as a modifier to the media-\ntype. When present, its value indicates what additional content codings have\nbeen applied to the entity-body, and thus what decoding mechanisms must be\napplied in order to obtain the media-type referenced by the Content-Type\nheader field.\n\nNew in version 0.9.\n\nThe Content-Length entity-header field indicates the size of the entity-body\nin bytes or, in the case of the HEAD method, the size of the entity-body that\nwould have been sent had the request been a GET.\n\nThe Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest\nof the entity-body for the purpose of providing an end-to-end message\nintegrity check (MIC) of the entity-body. (Note: a MIC is good for detecting\naccidental modification of the entity-body in transit, but is not proof\nagainst malicious attacks.)\n\nNew in version 0.9.\n\nThe Content-Type entity-header field indicates the media type of the entity-\nbody sent to the recipient or, in the case of the HEAD method, the media type\nthat would have been sent had the request been a GET.\n\nA `dict` with the contents of all cookies transmitted with the request.\n\nContains the incoming request data as string in case it came with a mimetype\nWerkzeug does not handle.\n\nThe Date general-header field represents the date and time at which the\nmessage was originated, having the same semantics as orig-date in RFC 822.\n\nChanged in version 2.0: The datetime object is timezone-aware.\n\nalias of `werkzeug.datastructures.ImmutableMultiDict`\n\nDisable the `data` property to avoid reading from the input stream.\n\nDeprecated since version 2.0: Will be removed in Werkzeug 2.1. Create the\nrequest with `shallow=True` instead.\n\nNew in version 0.9.\n\nThe WSGI environment containing HTTP headers and information from the WSGI\nserver.\n\n`MultiDict` object containing all uploaded files. Each key in `files` is the\nname from the `<input type=\"file\" name=\"\">`. Each value in `files` is a\nWerkzeug `FileStorage` object.\n\nIt basically behaves like a standard file object you know from Python, with\nthe difference that it also has a `save()` function that can store the file on\nthe filesystem.\n\nNote that `files` will only contain data if the request method was POST, PUT\nor PATCH and the `<form>` that posted to the request had\n`enctype=\"multipart/form-data\"`. It will be empty otherwise.\n\nSee the `MultiDict` / `FileStorage` documentation for more details about the\nused data structure.\n\nThe form parameters. By default an `ImmutableMultiDict` is returned from this\nfunction. This can be changed by setting `parameter_storage_class` to a\ndifferent type. This might be necessary if the order of the form data is\nimportant.\n\nPlease keep in mind that file uploads will not end up here, but instead in the\n`files` attribute.\n\nChanged in version 0.9: Previous to Werkzeug 0.9 this would only contain form\ndata for POST and PUT requests.\n\nalias of `werkzeug.formparser.FormDataParser`\n\nCreate a new request object based on the values provided. If environ is given\nmissing values are filled from there. This method is useful for small scripts\nwhen you need to simulate a request from an URL. Do not use this method for\nunittesting, there is a full featured client object (`Client`) that allows to\ncreate multipart requests, support for cookies etc.\n\nThis accepts the same options as the `EnvironBuilder`.\n\nChanged in version 0.5: This method now accepts the same arguments as\n`EnvironBuilder`. Because of this the `environ` parameter is now called\n`environ_overrides`.\n\nrequest object\n\nwerkzeug.wrappers.request.Request\n\nRequested path, including the query string.\n\nThis reads the buffered incoming data from the client into one bytes object.\nBy default this is cached but that behavior can be changed by setting `cache`\nto `False`.\n\nUsually it\u2019s a bad idea to call this method without checking the content\nlength first as a client could send dozens of megabytes or more to cause\nmemory problems on the server.\n\nNote that if the form data was already parsed this method will not return\nanything as form data parsing does not cache the data like this method does.\nTo implicitly invoke form data parsing function set `parse_form_data` to\n`True`. When this is done the return value of this method will be an empty\nstring if the form parser handles the data. This generally is not necessary as\nif the whole data is cached (which is the default) the form parser will used\nthe cached data to parse the form data. Please be generally aware of checking\nthe content length first in any case before calling this method to avoid\nexhausting server memory.\n\nIf `as_text` is set to `True` the return value will be a decoded string.\n\nNew in version 0.9.\n\nUnion[bytes, str]\n\nParse `data` as JSON.\n\nIf the mimetype does not indicate JSON (application/json, see `is_json()`),\nthis returns `None`.\n\nIf parsing fails, `on_json_loading_failed()` is called and its return value is\nused as the return value.\n\nOptional[Any]\n\nThe headers received with the request.\n\nThe host name the request was made to, including the port if it\u2019s non-\nstandard. Validated with `trusted_hosts`.\n\nThe request URL scheme and host only.\n\nAn object containing all the etags in the `If-Match` header.\n\n`ETags`\n\nThe parsed `If-Modified-Since` header as a datetime object.\n\nChanged in version 2.0: The datetime object is timezone-aware.\n\nAn object containing all the etags in the `If-None-Match` header.\n\n`ETags`\n\nThe parsed `If-Range` header.\n\nChanged in version 2.0: `IfRange.date` is timezone-aware.\n\nNew in version 0.7.\n\nThe parsed `If-Unmodified-Since` header as a datetime object.\n\nChanged in version 2.0: The datetime object is timezone-aware.\n\nThe WSGI input stream.\n\nIn general it\u2019s a bad idea to use this one because you can easily read past\nthe boundary. Use the `stream` instead.\n\nCheck if the mimetype indicates JSON data, either application/json or\napplication/*+json.\n\nboolean that is `True` if the application is served by a WSGI server that\nspawns multiple processes.\n\nboolean that is `True` if the application is served by a multithreaded WSGI\nserver.\n\nboolean that is `True` if the application will be executed only once in a\nprocess lifetime. This is the case for CGI for example, but it\u2019s not\nguaranteed that the execution only happens one time.\n\n`True` if the request was made with a secure protocol (HTTPS or WSS).\n\nThe parsed JSON data if `mimetype` indicates JSON (application/json, see\n`is_json()`).\n\nCalls `get_json()` with default arguments.\n\nA module or other object that has `dumps` and `loads` functions that match the\nAPI of the built-in `json` module.\n\nalias of `werkzeug.datastructures.ImmutableList`\n\nCreates the form data parser. Instantiates the `form_data_parser_class` with\nsome parameters.\n\nNew in version 0.8.\n\nwerkzeug.formparser.FormDataParser\n\nthe maximum content length. This is forwarded to the form data parsing\nfunction (`parse_form_data()`). When set and the `form` or `files` attribute\nis accessed and the parsing fails because more than the specified value is\ntransmitted a `RequestEntityTooLarge` exception is raised.\n\nHave a look at Dealing with Request Data for more details.\n\nNew in version 0.5.\n\nthe maximum form field size. This is forwarded to the form data parsing\nfunction (`parse_form_data()`). When set and the `form` or `files` attribute\nis accessed and the data in memory for post data is longer than the specified\nvalue a `RequestEntityTooLarge` exception is raised.\n\nHave a look at Dealing with Request Data for more details.\n\nNew in version 0.5.\n\nThe Max-Forwards request-header field provides a mechanism with the TRACE and\nOPTIONS methods to limit the number of proxies or gateways that can forward\nthe request to the next inbound server.\n\nThe method the request was made with, such as `GET`.\n\nLike `content_type`, but without parameters (eg, without charset, type etc.)\nand always lowercase. For example if the content type is `text/HTML;\ncharset=utf-8` the mimetype would be `'text/html'`.\n\nThe mimetype parameters as dict. For example if the content type is\n`text/html; charset=utf-8` the params would be `{'charset': 'utf-8'}`.\n\nCalled if `get_json()` parsing fails and isn\u2019t silenced. If this method\nreturns a value, it is used as the return value for `get_json()`. The default\nimplementation raises `BadRequest`.\n\ne (ValueError) \u2013\n\nAny\n\nThe host that the request originated from. Set `access_control_allow_origin`\non the response to indicate which origins are allowed.\n\nalias of `werkzeug.datastructures.ImmutableMultiDict`\n\nThe path part of the URL after `root_path`. This is the path used for routing\nwithin the application.\n\nThe Pragma general-header field is used to include implementation-specific\ndirectives that might apply to any recipient along the request/response chain.\nAll pragma directives specify optional behavior from the viewpoint of the\nprotocol; however, some systems MAY require that behavior be consistent with\nthe directives.\n\nThe part of the URL after the \u201c?\u201d. This is the raw value, use `args` for the\nparsed values.\n\nThe parsed `Range` header.\n\nNew in version 0.7.\n\n`Range`\n\nThe Referer[sic] request-header field allows the client to specify, for the\nserver\u2019s benefit, the address (URI) of the resource from which the Request-URI\nwas obtained (the \u201creferrer\u201d, although the header field is misspelled).\n\nThe address of the client sending the request.\n\nIf the server supports user authentication, and the script is protected, this\nattribute contains the username the user has authenticated as.\n\nThe prefix that the application is mounted under, without a trailing slash.\n`path` comes after this.\n\nThe request URL scheme, host, and root path. This is the root that the\napplication is accessed from.\n\nThe URL scheme of the protocol the request used, such as `https` or `wss`.\n\nAlias for `self.root_path`. `environ[\"SCRIPT_ROOT\"]` without a trailing slash.\n\nThe address of the server. `(host, port)`, `(path, None)` for unix sockets, or\n`None` if not known.\n\nSet when creating the request object. If `True`, reading from the request body\nwill cause a `RuntimeException`. Useful to prevent modifying the stream from\nmiddleware.\n\nIf the incoming form data was not encoded with a known mimetype the data is\nstored unmodified in this stream for consumption. Most of the time it is a\nbetter idea to use `data` which will give you that data as a string. The\nstream only returns the data once.\n\nUnlike `input_stream` this stream is properly guarded that you can\u2019t\naccidentally read past the length of the input. Werkzeug will internally\nalways refer to this stream to read data which makes it possible to wrap this\nobject with a stream that does filtering.\n\nChanged in version 0.9: This stream is now always available but might be\nconsumed by the form parser later on. Previously the stream was only set if no\nparsing happened.\n\nThe full request URL with the scheme, host, root path, path, and query string.\n\nThe charset that is assumed for URLs. Defaults to the value of `charset`.\n\nNew in version 0.6.\n\nAlias for `root_url`. The URL with scheme, host, and root path. For example,\n`https://example.com/app/`.\n\nThe user agent. Use `user_agent.string` to get the header value. Set\n`user_agent_class` to a subclass of `UserAgent` to provide parsing for the\nother properties or other extended data.\n\nChanged in version 2.0: The built in parser is deprecated and will be removed\nin Werkzeug 2.1. A `UserAgent` subclass must be set to parse data from the\nstring.\n\nalias of `werkzeug.useragents._UserAgent`\n\nA `werkzeug.datastructures.CombinedMultiDict` that combines `args` and `form`.\n\nFor GET requests, only `args` are present, not `form`.\n\nChanged in version 2.0: For GET requests, only `args` are present, not `form`.\n\n`True` if the request method carries content. By default this is true if a\n`Content-Type` is sent.\n\nNew in version 0.8.\n\nRepresents an outgoing WSGI HTTP response with body, status, and headers. Has\nproperties and methods for using the functionality defined by various HTTP\nspecs.\n\nThe response body is flexible to support different use cases. The simple form\nis passing bytes, or a string which will be encoded as UTF-8. Passing an\niterable of bytes or strings makes this a streaming response. A generator is\nparticularly useful for building a CSV file in memory or using SSE (Server\nSent Events). A file-like object is also iterable, although the `send_file()`\nhelper should be used in that case.\n\nThe response object is itself a WSGI application callable. When called\n(`__call__()`) with `environ` and `start_response`, it will pass its status\nand headers to `start_response` then return its body as an iterable.\n\nNone\n\nChanged in version 2.0: Combine `BaseResponse` and mixins into a single\n`Response` class. Using the old classes is deprecated and will be removed in\nWerkzeug 2.1.\n\nChanged in version 0.5: The `direct_passthrough` parameter was added.\n\nProcess this response as WSGI application.\n\nan application iterator\n\nIterable[bytes]\n\nThis method can be called by methods that need a sequence. If `mutable` is\ntrue, it will also ensure that the response sequence is a standard Python\nlist.\n\nNew in version 0.6.\n\nmutable (bool) \u2013\n\nNone\n\nThe `Accept-Ranges` header. Even though the name would indicate that multiple\nvalues are supported, it must be one string token only.\n\nThe values `'bytes'` and `'none'` are common.\n\nNew in version 0.7.\n\nWhether credentials can be shared by the browser to JavaScript code. As part\nof the preflight request it indicates whether credentials can be used on the\ncross origin request.\n\nWhich headers can be sent with the cross origin request.\n\nWhich methods can be used for the cross origin request.\n\nThe origin or \u2018*\u2019 for any origin that may make cross origin requests.\n\nWhich headers can be shared by the browser to JavaScript code.\n\nThe maximum age in seconds the access control settings can be cached for.\n\nAdd an etag for the current response if there is none yet.\n\nChanged in version 2.0: SHA-1 is used to generate the value. MD5 may not be\navailable in some environments.\n\nNone\n\nThe Age response-header field conveys the sender\u2019s estimate of the amount of\ntime since the response (or its revalidation) was generated at the origin\nserver.\n\nAge values are non-negative decimal integers, representing time in seconds.\n\nThe Allow entity-header field lists the set of methods supported by the\nresource identified by the Request-URI. The purpose of this field is strictly\nto inform the recipient of valid methods associated with the resource. An\nAllow header field MUST be present in a 405 (Method Not Allowed) response.\n\nShould this response object correct the location header to be RFC conformant?\nThis is true by default.\n\nNew in version 0.8.\n\nShould this response object automatically set the content-length header if\npossible? This is true by default.\n\nNew in version 0.8.\n\nThe Cache-Control general-header field is used to specify directives that MUST\nbe obeyed by all caching mechanisms along the request/response chain.\n\nReturns the content length if available or `None` otherwise.\n\nOptional[int]\n\nAdds a function to the internal list of functions that should be called as\npart of closing down the response. Since 0.7 this function also returns the\nfunction that was passed so that this can be used as a decorator.\n\nNew in version 0.6.\n\nfunc (Callable[[], Any]) \u2013\n\nCallable[[], Any]\n\nClose the wrapped response if possible. You can also use the object in a with\nstatement which will automatically close it.\n\nNew in version 0.9: Can now be used in a with statement.\n\nNone\n\nThe Content-Encoding entity-header field is used as a modifier to the media-\ntype. When present, its value indicates what additional content codings have\nbeen applied to the entity-body, and thus what decoding mechanisms must be\napplied in order to obtain the media-type referenced by the Content-Type\nheader field.\n\nThe Content-Language entity-header field describes the natural language(s) of\nthe intended audience for the enclosed entity. Note that this might not be\nequivalent to all the languages used within the entity-body.\n\nThe Content-Length entity-header field indicates the size of the entity-body,\nin decimal number of OCTETs, sent to the recipient or, in the case of the HEAD\nmethod, the size of the entity-body that would have been sent had the request\nbeen a GET.\n\nThe Content-Location entity-header field MAY be used to supply the resource\nlocation for the entity enclosed in the message when that entity is accessible\nfrom a location separate from the requested resource\u2019s URI.\n\nThe Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest\nof the entity-body for the purpose of providing an end-to-end message\nintegrity check (MIC) of the entity-body. (Note: a MIC is good for detecting\naccidental modification of the entity-body in transit, but is not proof\nagainst malicious attacks.)\n\nThe `Content-Range` header as a `ContentRange` object. Available even if the\nheader is not set.\n\nNew in version 0.7.\n\nThe Content-Security-Policy header adds an additional layer of security to\nhelp detect and mitigate certain types of attacks.\n\nThe Content-Security-Policy-Report-Only header adds a csp policy that is not\nenforced but is reported thereby helping detect certain types of attacks.\n\nThe Content-Type entity-header field indicates the media type of the entity-\nbody sent to the recipient or, in the case of the HEAD method, the media type\nthat would have been sent had the request been a GET.\n\nPrevents a document from loading any cross-origin resources that do not\nexplicitly grant the document permission. Values must be a member of the\n`werkzeug.http.COEP` enum.\n\nAllows control over sharing of browsing context group with cross-origin\ndocuments. Values must be a member of the `werkzeug.http.COOP` enum.\n\nA descriptor that calls `get_data()` and `set_data()`.\n\nThe Date general-header field represents the date and time at which the\nmessage was originated, having the same semantics as orig-date in RFC 822.\n\nChanged in version 2.0: The datetime object is timezone-aware.\n\nDelete a cookie. Fails silently if key doesn\u2019t exist.\n\nNone\n\nPass the response body directly through as the WSGI iterable. This can be used\nwhen the body is a binary file or other iterator of bytes, to skip some\nunnecessary checks. Use `send_file()` instead of setting this manually.\n\nThe Expires entity-header field gives the date/time after which the response\nis considered stale. A stale cache entry may not normally be returned by a\ncache.\n\nChanged in version 2.0: The datetime object is timezone-aware.\n\nEnforce that the WSGI response is a response object of the current type.\nWerkzeug will use the `Response` internally in many situations like the\nexceptions. If you call `get_response()` on an exception you will get back a\nregular `Response` object, even if you are using a custom subclass.\n\nThis method can enforce a given response type, and it will also convert\narbitrary WSGI callables into response objects if an environ is provided:\n\nThis is especially useful if you want to post-process responses in the main\ndispatcher and use functionality provided by your subclass.\n\nKeep in mind that this will modify response objects in place if possible!\n\na response object.\n\nResponse\n\nMake the response object ready to be pickled. Does the following:\n\nChanged in version 2.0: An `ETag` header is added, the `no_etag` parameter is\ndeprecated and will be removed in Werkzeug 2.1.\n\nChanged in version 0.6: The `Content-Length` header is set.\n\nno_etag (None) \u2013\n\nNone\n\nCreate a new response object from an application output. This works best if\nyou pass it an application that returns a generator all the time. Sometimes\napplications may use the `write()` callable returned by the `start_response`\nfunction. This tries to resolve such edge cases automatically. But if you\ndon\u2019t get the expected output you should set `buffered` to `True` which\nenforces buffering.\n\na response object.\n\nResponse\n\nReturns the application iterator for the given environ. Depending on the\nrequest method and the current status code the return value might be an empty\nresponse rather than the one from the response.\n\nIf the request method is `HEAD` or the status code is in a range where the\nHTTP specification requires an empty response, an empty iterable is returned.\n\nNew in version 0.6.\n\nenviron (WSGIEnvironment) \u2013 the WSGI environment of the request.\n\na response iterable.\n\nIterable[bytes]\n\nThe string representation of the response body. Whenever you call this\nproperty the response iterable is encoded and flattened. This can lead to\nunwanted behavior if you stream big data.\n\nThis behavior can be disabled by setting `implicit_sequence_conversion` to\n`False`.\n\nIf `as_text` is set to `True` the return value will be a decoded string.\n\nNew in version 0.9.\n\nas_text (bool) \u2013\n\nUnion[bytes, str]\n\nReturn a tuple in the form `(etag, is_weak)`. If there is no ETag the return\nvalue is `(None, None)`.\n\nUnion[Tuple[str, bool], Tuple[None, None]]\n\nParse `data` as JSON. Useful during testing.\n\nIf the mimetype does not indicate JSON (application/json, see `is_json()`),\nthis returns `None`.\n\nUnlike `Request.get_json()`, the result is not cached.\n\nOptional[Any]\n\nThis is automatically called right before the response is started and returns\nheaders modified for the given environment. It returns a copy of the headers\nfrom the response with some modifications applied if necessary.\n\nFor example the location header (if present) is joined with the root URL of\nthe environment. Also the content length is automatically set to zero here for\ncertain status codes.\n\nChanged in version 0.6: Previously that function was called `fix_headers` and\nmodified the response object in place. Also since 0.6, IRIs in location and\ncontent-location headers are handled properly.\n\nAlso starting with 0.6, Werkzeug will attempt to set the content length if it\nis able to figure it out on its own. This is the case if all the strings in\nthe response iterable are already encoded and the iterable is buffered.\n\nenviron (WSGIEnvironment) \u2013 the WSGI environment of the request.\n\nreturns a new `Headers` object.\n\nwerkzeug.datastructures.Headers\n\nReturns the final WSGI response as tuple. The first item in the tuple is the\napplication iterator, the second the status and the third the list of headers.\nThe response returned is created specially for the given environment. For\nexample if the request method in the WSGI environment is `'HEAD'` the response\nwill be empty and only the headers and status code will be present.\n\nNew in version 0.6.\n\nenviron (WSGIEnvironment) \u2013 the WSGI environment of the request.\n\nan `(app_iter, status, headers)` tuple.\n\nTuple[Iterable[bytes], str, List[Tuple[str, str]]]\n\nif set to `False` accessing properties on the response object will not try to\nconsume the response iterator and convert it into a list.\n\nNew in version 0.6.2: That attribute was previously called\n`implicit_seqence_conversion`. (Notice the typo). If you did use this feature,\nyou have to adapt your code to the name change.\n\nCheck if the mimetype indicates JSON data, either application/json or\napplication/*+json.\n\nIf the iterator is buffered, this property will be `True`. A response object\nwill consider an iterator to be buffered if the response attribute is a list\nor tuple.\n\nNew in version 0.6.\n\nIf the response is streamed (the response is not an iterable with a length\ninformation) this property is `True`. In this case streamed means that there\nis no information about the number of iterations. This is usually `True` if a\ngenerator is passed to the response object.\n\nThis is useful for checking before applying some sort of post filtering that\nshould not take place for streamed responses.\n\nIter the response encoded with the encoding of the response. If the response\nobject is invoked as WSGI application the return value of this method is used\nas application iterator unless `direct_passthrough` was activated.\n\nIterator[bytes]\n\nThe parsed JSON data if `mimetype` indicates JSON (application/json, see\n`is_json()`).\n\nCalls `get_json()` with default arguments.\n\nA module or other object that has `dumps` and `loads` functions that match the\nAPI of the built-in `json` module.\n\nThe Last-Modified entity-header field indicates the date and time at which the\norigin server believes the variant was last modified.\n\nChanged in version 2.0: The datetime object is timezone-aware.\n\nThe Location response-header field is used to redirect the recipient to a\nlocation other than the Request-URI for completion of the request or\nidentification of a new resource.\n\nMake the response conditional to the request. This method works best if an\netag was defined for the response already. The `add_etag` method can be used\nto do that. If called without etag just the date header is set.\n\nThis does nothing if the request method in the request or environ is anything\nbut GET or HEAD.\n\nFor optimal performance when handling range requests, it\u2019s recommended that\nyour response data object implements `seekable`, `seek` and `tell` methods as\ndescribed by `io.IOBase`. Objects returned by `wrap_file()` automatically\nimplement those methods.\n\nIt does not remove the body of the response because that\u2019s something the\n`__call__()` function does for us automatically.\n\nReturns self so that you can do `return resp.make_conditional(req)` but\nmodifies the object in-place.\n\n`RequestedRangeNotSatisfiable` if `Range` header could not be parsed or\nsatisfied.\n\nResponse\n\nChanged in version 2.0: Range processing is skipped if length is 0 instead of\nraising a 416 Range Not Satisfiable error.\n\nConverts the response iterator in a list. By default this happens\nautomatically if required. If `implicit_sequence_conversion` is disabled, this\nmethod is not automatically called and some properties might raise exceptions.\nThis also encodes all the items.\n\nNew in version 0.6.\n\nNone\n\nThe mimetype (content type without charset etc.)\n\nThe mimetype parameters as dict. For example if the content type is\n`text/html; charset=utf-8` the params would be `{'charset': 'utf-8'}`.\n\nNew in version 0.5.\n\nThe response body to send as the WSGI iterable. A list of strings or bytes\nrepresents a fixed-length response, any other iterable is a streaming\nresponse. Strings are encoded to bytes as UTF-8.\n\nDo not set to a plain string or bytes, that will cause sending the response to\nbe very inefficient as it will iterate one byte at a time.\n\nThe Retry-After response-header field can be used with a 503 (Service\nUnavailable) response to indicate how long the service is expected to be\nunavailable to the requesting client.\n\nTime in seconds until expiration or date.\n\nChanged in version 2.0: The datetime object is timezone-aware.\n\nSets a cookie.\n\nA warning is raised if the size of the cookie header exceeds\n`max_cookie_size`, but the header will still be set.\n\nNone\n\nSets a new string as response. The value must be a string or bytes. If a\nstring is set it\u2019s encoded to the charset of the response (utf-8 by default).\n\nNew in version 0.9.\n\nvalue (Union[bytes, str]) \u2013\n\nNone\n\nSet the etag, and override the old one if there was one.\n\nNone\n\nThe HTTP status code as a string.\n\nThe HTTP status code as a number.\n\nThe response iterable as write-only stream.\n\nThe Vary field value indicates the set of request-header fields that fully\ndetermines, while the response is fresh, whether a cache is permitted to use\nthe response to reply to a subsequent request without revalidation.\n\nThe `WWW-Authenticate` header in a parsed form.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Request.access_control_request_headers", "path": "wrappers/index#werkzeug.wrappers.Request.access_control_request_headers", "type": "werkzeug.wrappers", "text": "\nSent with a preflight request to indicate which headers will be sent with the\ncross origin request. Set `access_control_allow_headers` on the response to\nindicate which headers are allowed.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Request.access_control_request_method", "path": "wrappers/index#werkzeug.wrappers.Request.access_control_request_method", "type": "werkzeug.wrappers", "text": "\nSent with a preflight request to indicate which method will be used for the\ncross origin request. Set `access_control_allow_methods` on the response to\nindicate which methods are allowed.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Request.application()", "path": "wrappers/index#werkzeug.wrappers.Request.application", "type": "werkzeug.wrappers", "text": "\nDecorate a function as responder that accepts the request as the last\nargument. This works like the `responder()` decorator but the function is\npassed the request object as the last argument and the request object will be\nclosed automatically:\n\nAs of Werkzeug 0.14 HTTP exceptions are automatically caught and converted to\nresponses instead of failing.\n\nf (Callable[[Request], WSGIApplication]) \u2013 the WSGI callable to decorate\n\na new WSGI callable\n\nWSGIApplication\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Request.close()", "path": "wrappers/index#werkzeug.wrappers.Request.close", "type": "werkzeug.wrappers", "text": "\nCloses associated resources of this request object. This closes all file\nhandles explicitly. You can also use the request object in a with statement\nwhich will automatically close it.\n\nNew in version 0.9.\n\nNone\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Request.content_encoding", "path": "wrappers/index#werkzeug.wrappers.Request.content_encoding", "type": "werkzeug.wrappers", "text": "\nThe Content-Encoding entity-header field is used as a modifier to the media-\ntype. When present, its value indicates what additional content codings have\nbeen applied to the entity-body, and thus what decoding mechanisms must be\napplied in order to obtain the media-type referenced by the Content-Type\nheader field.\n\nNew in version 0.9.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Request.content_md5", "path": "wrappers/index#werkzeug.wrappers.Request.content_md5", "type": "werkzeug.wrappers", "text": "\nThe Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest\nof the entity-body for the purpose of providing an end-to-end message\nintegrity check (MIC) of the entity-body. (Note: a MIC is good for detecting\naccidental modification of the entity-body in transit, but is not proof\nagainst malicious attacks.)\n\nNew in version 0.9.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Request.content_type", "path": "wrappers/index#werkzeug.wrappers.Request.content_type", "type": "werkzeug.wrappers", "text": "\nThe Content-Type entity-header field indicates the media type of the entity-\nbody sent to the recipient or, in the case of the HEAD method, the media type\nthat would have been sent had the request been a GET.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Request.date", "path": "wrappers/index#werkzeug.wrappers.Request.date", "type": "werkzeug.wrappers", "text": "\nThe Date general-header field represents the date and time at which the\nmessage was originated, having the same semantics as orig-date in RFC 822.\n\nChanged in version 2.0: The datetime object is timezone-aware.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Request.dict_storage_class", "path": "wrappers/index#werkzeug.wrappers.Request.dict_storage_class", "type": "werkzeug.wrappers", "text": "\nalias of `werkzeug.datastructures.ImmutableMultiDict`\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Request.disable_data_descriptor", "path": "wrappers/index#werkzeug.wrappers.Request.disable_data_descriptor", "type": "werkzeug.wrappers", "text": "\nDisable the `data` property to avoid reading from the input stream.\n\nDeprecated since version 2.0: Will be removed in Werkzeug 2.1. Create the\nrequest with `shallow=True` instead.\n\nNew in version 0.9.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Request.environ", "path": "wrappers/index#werkzeug.wrappers.Request.environ", "type": "werkzeug.wrappers", "text": "\nThe WSGI environment containing HTTP headers and information from the WSGI\nserver.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Request.form_data_parser_class", "path": "wrappers/index#werkzeug.wrappers.Request.form_data_parser_class", "type": "werkzeug.wrappers", "text": "\nalias of `werkzeug.formparser.FormDataParser`\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Request.from_values()", "path": "wrappers/index#werkzeug.wrappers.Request.from_values", "type": "werkzeug.wrappers", "text": "\nCreate a new request object based on the values provided. If environ is given\nmissing values are filled from there. This method is useful for small scripts\nwhen you need to simulate a request from an URL. Do not use this method for\nunittesting, there is a full featured client object (`Client`) that allows to\ncreate multipart requests, support for cookies etc.\n\nThis accepts the same options as the `EnvironBuilder`.\n\nChanged in version 0.5: This method now accepts the same arguments as\n`EnvironBuilder`. Because of this the `environ` parameter is now called\n`environ_overrides`.\n\nrequest object\n\nwerkzeug.wrappers.request.Request\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Request.get_data()", "path": "wrappers/index#werkzeug.wrappers.Request.get_data", "type": "werkzeug.wrappers", "text": "\nThis reads the buffered incoming data from the client into one bytes object.\nBy default this is cached but that behavior can be changed by setting `cache`\nto `False`.\n\nUsually it\u2019s a bad idea to call this method without checking the content\nlength first as a client could send dozens of megabytes or more to cause\nmemory problems on the server.\n\nNote that if the form data was already parsed this method will not return\nanything as form data parsing does not cache the data like this method does.\nTo implicitly invoke form data parsing function set `parse_form_data` to\n`True`. When this is done the return value of this method will be an empty\nstring if the form parser handles the data. This generally is not necessary as\nif the whole data is cached (which is the default) the form parser will used\nthe cached data to parse the form data. Please be generally aware of checking\nthe content length first in any case before calling this method to avoid\nexhausting server memory.\n\nIf `as_text` is set to `True` the return value will be a decoded string.\n\nNew in version 0.9.\n\nUnion[bytes, str]\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Request.get_json()", "path": "wrappers/index#werkzeug.wrappers.Request.get_json", "type": "werkzeug.wrappers", "text": "\nParse `data` as JSON.\n\nIf the mimetype does not indicate JSON (application/json, see `is_json()`),\nthis returns `None`.\n\nIf parsing fails, `on_json_loading_failed()` is called and its return value is\nused as the return value.\n\nOptional[Any]\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Request.headers", "path": "wrappers/index#werkzeug.wrappers.Request.headers", "type": "werkzeug.wrappers", "text": "\nThe headers received with the request.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Request.input_stream", "path": "wrappers/index#werkzeug.wrappers.Request.input_stream", "type": "werkzeug.wrappers", "text": "\nThe WSGI input stream.\n\nIn general it\u2019s a bad idea to use this one because you can easily read past\nthe boundary. Use the `stream` instead.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Request.is_multiprocess", "path": "wrappers/index#werkzeug.wrappers.Request.is_multiprocess", "type": "werkzeug.wrappers", "text": "\nboolean that is `True` if the application is served by a WSGI server that\nspawns multiple processes.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Request.is_multithread", "path": "wrappers/index#werkzeug.wrappers.Request.is_multithread", "type": "werkzeug.wrappers", "text": "\nboolean that is `True` if the application is served by a multithreaded WSGI\nserver.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Request.is_run_once", "path": "wrappers/index#werkzeug.wrappers.Request.is_run_once", "type": "werkzeug.wrappers", "text": "\nboolean that is `True` if the application will be executed only once in a\nprocess lifetime. This is the case for CGI for example, but it\u2019s not\nguaranteed that the execution only happens one time.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Request.json_module", "path": "wrappers/index#werkzeug.wrappers.Request.json_module", "type": "werkzeug.wrappers", "text": "\nA module or other object that has `dumps` and `loads` functions that match the\nAPI of the built-in `json` module.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Request.list_storage_class", "path": "wrappers/index#werkzeug.wrappers.Request.list_storage_class", "type": "werkzeug.wrappers", "text": "\nalias of `werkzeug.datastructures.ImmutableList`\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Request.make_form_data_parser()", "path": "wrappers/index#werkzeug.wrappers.Request.make_form_data_parser", "type": "werkzeug.wrappers", "text": "\nCreates the form data parser. Instantiates the `form_data_parser_class` with\nsome parameters.\n\nNew in version 0.8.\n\nwerkzeug.formparser.FormDataParser\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Request.max_content_length", "path": "wrappers/index#werkzeug.wrappers.Request.max_content_length", "type": "werkzeug.wrappers", "text": "\nthe maximum content length. This is forwarded to the form data parsing\nfunction (`parse_form_data()`). When set and the `form` or `files` attribute\nis accessed and the parsing fails because more than the specified value is\ntransmitted a `RequestEntityTooLarge` exception is raised.\n\nHave a look at Dealing with Request Data for more details.\n\nNew in version 0.5.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Request.max_form_memory_size", "path": "wrappers/index#werkzeug.wrappers.Request.max_form_memory_size", "type": "werkzeug.wrappers", "text": "\nthe maximum form field size. This is forwarded to the form data parsing\nfunction (`parse_form_data()`). When set and the `form` or `files` attribute\nis accessed and the data in memory for post data is longer than the specified\nvalue a `RequestEntityTooLarge` exception is raised.\n\nHave a look at Dealing with Request Data for more details.\n\nNew in version 0.5.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Request.max_forwards", "path": "wrappers/index#werkzeug.wrappers.Request.max_forwards", "type": "werkzeug.wrappers", "text": "\nThe Max-Forwards request-header field provides a mechanism with the TRACE and\nOPTIONS methods to limit the number of proxies or gateways that can forward\nthe request to the next inbound server.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Request.method", "path": "wrappers/index#werkzeug.wrappers.Request.method", "type": "werkzeug.wrappers", "text": "\nThe method the request was made with, such as `GET`.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Request.on_json_loading_failed()", "path": "wrappers/index#werkzeug.wrappers.Request.on_json_loading_failed", "type": "werkzeug.wrappers", "text": "\nCalled if `get_json()` parsing fails and isn\u2019t silenced. If this method\nreturns a value, it is used as the return value for `get_json()`. The default\nimplementation raises `BadRequest`.\n\ne (ValueError) \u2013\n\nAny\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Request.origin", "path": "wrappers/index#werkzeug.wrappers.Request.origin", "type": "werkzeug.wrappers", "text": "\nThe host that the request originated from. Set `access_control_allow_origin`\non the response to indicate which origins are allowed.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Request.parameter_storage_class", "path": "wrappers/index#werkzeug.wrappers.Request.parameter_storage_class", "type": "werkzeug.wrappers", "text": "\nalias of `werkzeug.datastructures.ImmutableMultiDict`\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Request.path", "path": "wrappers/index#werkzeug.wrappers.Request.path", "type": "werkzeug.wrappers", "text": "\nThe path part of the URL after `root_path`. This is the path used for routing\nwithin the application.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Request.query_string", "path": "wrappers/index#werkzeug.wrappers.Request.query_string", "type": "werkzeug.wrappers", "text": "\nThe part of the URL after the \u201c?\u201d. This is the raw value, use `args` for the\nparsed values.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Request.referrer", "path": "wrappers/index#werkzeug.wrappers.Request.referrer", "type": "werkzeug.wrappers", "text": "\nThe Referer[sic] request-header field allows the client to specify, for the\nserver\u2019s benefit, the address (URI) of the resource from which the Request-URI\nwas obtained (the \u201creferrer\u201d, although the header field is misspelled).\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Request.remote_addr", "path": "wrappers/index#werkzeug.wrappers.Request.remote_addr", "type": "werkzeug.wrappers", "text": "\nThe address of the client sending the request.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Request.remote_user", "path": "wrappers/index#werkzeug.wrappers.Request.remote_user", "type": "werkzeug.wrappers", "text": "\nIf the server supports user authentication, and the script is protected, this\nattribute contains the username the user has authenticated as.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Request.root_path", "path": "wrappers/index#werkzeug.wrappers.Request.root_path", "type": "werkzeug.wrappers", "text": "\nThe prefix that the application is mounted under, without a trailing slash.\n`path` comes after this.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Request.scheme", "path": "wrappers/index#werkzeug.wrappers.Request.scheme", "type": "werkzeug.wrappers", "text": "\nThe URL scheme of the protocol the request used, such as `https` or `wss`.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Request.server", "path": "wrappers/index#werkzeug.wrappers.Request.server", "type": "werkzeug.wrappers", "text": "\nThe address of the server. `(host, port)`, `(path, None)` for unix sockets, or\n`None` if not known.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Request.shallow", "path": "wrappers/index#werkzeug.wrappers.Request.shallow", "type": "werkzeug.wrappers", "text": "\nSet when creating the request object. If `True`, reading from the request body\nwill cause a `RuntimeException`. Useful to prevent modifying the stream from\nmiddleware.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Request.user_agent_class", "path": "wrappers/index#werkzeug.wrappers.Request.user_agent_class", "type": "werkzeug.wrappers", "text": "\nalias of `werkzeug.useragents._UserAgent`\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Request._get_file_stream()", "path": "wrappers/index#werkzeug.wrappers.Request._get_file_stream", "type": "werkzeug.wrappers", "text": "\nCalled to get a stream for the file upload.\n\nThis must provide a file-like class with `read()`, `readline()` and `seek()`\nmethods that is both writeable and readable.\n\nThe default implementation returns a temporary file if the total content\nlength is higher than 500KB. Because many browsers do not provide a content\nlength for the files only the total content length matters.\n\nBinaryIO\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "RequestCacheControl", "path": "datastructures/index#werkzeug.datastructures.RequestCacheControl", "type": "werkzeug.datastructures", "text": "\nA cache control for requests. This is immutable and gives access to all the\nrequest-relevant cache control headers.\n\nTo get a header of the `RequestCacheControl` object again you can convert the\nobject into a string or call the `to_header()` method. If you plan to subclass\nit and add your own items have a look at the sourcecode for that class.\n\nNew in version 0.5: In previous versions a `CacheControl` class existed that\nwas used both for request and response.\n\naccessor for \u2018no-cache\u2019\n\naccessor for \u2018no-store\u2019\n\naccessor for \u2018max-age\u2019\n\naccessor for \u2018no-transform\u2019\n\naccessor for \u2018max-stale\u2019\n\naccessor for \u2018min-fresh\u2019\n\naccessor for \u2018only-if-cached\u2019\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "RequestCacheControl.max_age", "path": "datastructures/index#werkzeug.datastructures.RequestCacheControl.max_age", "type": "werkzeug.datastructures", "text": "\naccessor for \u2018max-age\u2019\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "RequestCacheControl.no_cache", "path": "datastructures/index#werkzeug.datastructures.RequestCacheControl.no_cache", "type": "werkzeug.datastructures", "text": "\naccessor for \u2018no-cache\u2019\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "RequestCacheControl.no_store", "path": "datastructures/index#werkzeug.datastructures.RequestCacheControl.no_store", "type": "werkzeug.datastructures", "text": "\naccessor for \u2018no-store\u2019\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "RequestCacheControl.no_transform", "path": "datastructures/index#werkzeug.datastructures.RequestCacheControl.no_transform", "type": "werkzeug.datastructures", "text": "\naccessor for \u2018no-transform\u2019\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "responder()", "path": "wsgi/index#werkzeug.wsgi.responder", "type": "werkzeug.wsgi", "text": "\nMarks a function as responder. Decorate a function with it and it will\nautomatically call the return value as WSGI application.\n\nExample:\n\nf (Callable[[...], WSGIApplication]) \u2013\n\nWSGIApplication\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response", "path": "wrappers/index#werkzeug.wrappers.Response", "type": "werkzeug.wrappers", "text": "\nRepresents an outgoing WSGI HTTP response with body, status, and headers. Has\nproperties and methods for using the functionality defined by various HTTP\nspecs.\n\nThe response body is flexible to support different use cases. The simple form\nis passing bytes, or a string which will be encoded as UTF-8. Passing an\niterable of bytes or strings makes this a streaming response. A generator is\nparticularly useful for building a CSV file in memory or using SSE (Server\nSent Events). A file-like object is also iterable, although the `send_file()`\nhelper should be used in that case.\n\nThe response object is itself a WSGI application callable. When called\n(`__call__()`) with `environ` and `start_response`, it will pass its status\nand headers to `start_response` then return its body as an iterable.\n\nNone\n\nChanged in version 2.0: Combine `BaseResponse` and mixins into a single\n`Response` class. Using the old classes is deprecated and will be removed in\nWerkzeug 2.1.\n\nChanged in version 0.5: The `direct_passthrough` parameter was added.\n\nProcess this response as WSGI application.\n\nan application iterator\n\nIterable[bytes]\n\nThis method can be called by methods that need a sequence. If `mutable` is\ntrue, it will also ensure that the response sequence is a standard Python\nlist.\n\nNew in version 0.6.\n\nmutable (bool) \u2013\n\nNone\n\nThe `Accept-Ranges` header. Even though the name would indicate that multiple\nvalues are supported, it must be one string token only.\n\nThe values `'bytes'` and `'none'` are common.\n\nNew in version 0.7.\n\nWhether credentials can be shared by the browser to JavaScript code. As part\nof the preflight request it indicates whether credentials can be used on the\ncross origin request.\n\nWhich headers can be sent with the cross origin request.\n\nWhich methods can be used for the cross origin request.\n\nThe origin or \u2018*\u2019 for any origin that may make cross origin requests.\n\nWhich headers can be shared by the browser to JavaScript code.\n\nThe maximum age in seconds the access control settings can be cached for.\n\nAdd an etag for the current response if there is none yet.\n\nChanged in version 2.0: SHA-1 is used to generate the value. MD5 may not be\navailable in some environments.\n\nNone\n\nThe Age response-header field conveys the sender\u2019s estimate of the amount of\ntime since the response (or its revalidation) was generated at the origin\nserver.\n\nAge values are non-negative decimal integers, representing time in seconds.\n\nThe Allow entity-header field lists the set of methods supported by the\nresource identified by the Request-URI. The purpose of this field is strictly\nto inform the recipient of valid methods associated with the resource. An\nAllow header field MUST be present in a 405 (Method Not Allowed) response.\n\nShould this response object correct the location header to be RFC conformant?\nThis is true by default.\n\nNew in version 0.8.\n\nShould this response object automatically set the content-length header if\npossible? This is true by default.\n\nNew in version 0.8.\n\nThe Cache-Control general-header field is used to specify directives that MUST\nbe obeyed by all caching mechanisms along the request/response chain.\n\nReturns the content length if available or `None` otherwise.\n\nOptional[int]\n\nAdds a function to the internal list of functions that should be called as\npart of closing down the response. Since 0.7 this function also returns the\nfunction that was passed so that this can be used as a decorator.\n\nNew in version 0.6.\n\nfunc (Callable[[], Any]) \u2013\n\nCallable[[], Any]\n\nClose the wrapped response if possible. You can also use the object in a with\nstatement which will automatically close it.\n\nNew in version 0.9: Can now be used in a with statement.\n\nNone\n\nThe Content-Encoding entity-header field is used as a modifier to the media-\ntype. When present, its value indicates what additional content codings have\nbeen applied to the entity-body, and thus what decoding mechanisms must be\napplied in order to obtain the media-type referenced by the Content-Type\nheader field.\n\nThe Content-Language entity-header field describes the natural language(s) of\nthe intended audience for the enclosed entity. Note that this might not be\nequivalent to all the languages used within the entity-body.\n\nThe Content-Length entity-header field indicates the size of the entity-body,\nin decimal number of OCTETs, sent to the recipient or, in the case of the HEAD\nmethod, the size of the entity-body that would have been sent had the request\nbeen a GET.\n\nThe Content-Location entity-header field MAY be used to supply the resource\nlocation for the entity enclosed in the message when that entity is accessible\nfrom a location separate from the requested resource\u2019s URI.\n\nThe Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest\nof the entity-body for the purpose of providing an end-to-end message\nintegrity check (MIC) of the entity-body. (Note: a MIC is good for detecting\naccidental modification of the entity-body in transit, but is not proof\nagainst malicious attacks.)\n\nThe `Content-Range` header as a `ContentRange` object. Available even if the\nheader is not set.\n\nNew in version 0.7.\n\nThe Content-Security-Policy header adds an additional layer of security to\nhelp detect and mitigate certain types of attacks.\n\nThe Content-Security-Policy-Report-Only header adds a csp policy that is not\nenforced but is reported thereby helping detect certain types of attacks.\n\nThe Content-Type entity-header field indicates the media type of the entity-\nbody sent to the recipient or, in the case of the HEAD method, the media type\nthat would have been sent had the request been a GET.\n\nPrevents a document from loading any cross-origin resources that do not\nexplicitly grant the document permission. Values must be a member of the\n`werkzeug.http.COEP` enum.\n\nAllows control over sharing of browsing context group with cross-origin\ndocuments. Values must be a member of the `werkzeug.http.COOP` enum.\n\nA descriptor that calls `get_data()` and `set_data()`.\n\nThe Date general-header field represents the date and time at which the\nmessage was originated, having the same semantics as orig-date in RFC 822.\n\nChanged in version 2.0: The datetime object is timezone-aware.\n\nDelete a cookie. Fails silently if key doesn\u2019t exist.\n\nNone\n\nPass the response body directly through as the WSGI iterable. This can be used\nwhen the body is a binary file or other iterator of bytes, to skip some\nunnecessary checks. Use `send_file()` instead of setting this manually.\n\nThe Expires entity-header field gives the date/time after which the response\nis considered stale. A stale cache entry may not normally be returned by a\ncache.\n\nChanged in version 2.0: The datetime object is timezone-aware.\n\nEnforce that the WSGI response is a response object of the current type.\nWerkzeug will use the `Response` internally in many situations like the\nexceptions. If you call `get_response()` on an exception you will get back a\nregular `Response` object, even if you are using a custom subclass.\n\nThis method can enforce a given response type, and it will also convert\narbitrary WSGI callables into response objects if an environ is provided:\n\nThis is especially useful if you want to post-process responses in the main\ndispatcher and use functionality provided by your subclass.\n\nKeep in mind that this will modify response objects in place if possible!\n\na response object.\n\nResponse\n\nMake the response object ready to be pickled. Does the following:\n\nChanged in version 2.0: An `ETag` header is added, the `no_etag` parameter is\ndeprecated and will be removed in Werkzeug 2.1.\n\nChanged in version 0.6: The `Content-Length` header is set.\n\nno_etag (None) \u2013\n\nNone\n\nCreate a new response object from an application output. This works best if\nyou pass it an application that returns a generator all the time. Sometimes\napplications may use the `write()` callable returned by the `start_response`\nfunction. This tries to resolve such edge cases automatically. But if you\ndon\u2019t get the expected output you should set `buffered` to `True` which\nenforces buffering.\n\na response object.\n\nResponse\n\nReturns the application iterator for the given environ. Depending on the\nrequest method and the current status code the return value might be an empty\nresponse rather than the one from the response.\n\nIf the request method is `HEAD` or the status code is in a range where the\nHTTP specification requires an empty response, an empty iterable is returned.\n\nNew in version 0.6.\n\nenviron (WSGIEnvironment) \u2013 the WSGI environment of the request.\n\na response iterable.\n\nIterable[bytes]\n\nThe string representation of the response body. Whenever you call this\nproperty the response iterable is encoded and flattened. This can lead to\nunwanted behavior if you stream big data.\n\nThis behavior can be disabled by setting `implicit_sequence_conversion` to\n`False`.\n\nIf `as_text` is set to `True` the return value will be a decoded string.\n\nNew in version 0.9.\n\nas_text (bool) \u2013\n\nUnion[bytes, str]\n\nReturn a tuple in the form `(etag, is_weak)`. If there is no ETag the return\nvalue is `(None, None)`.\n\nUnion[Tuple[str, bool], Tuple[None, None]]\n\nParse `data` as JSON. Useful during testing.\n\nIf the mimetype does not indicate JSON (application/json, see `is_json()`),\nthis returns `None`.\n\nUnlike `Request.get_json()`, the result is not cached.\n\nOptional[Any]\n\nThis is automatically called right before the response is started and returns\nheaders modified for the given environment. It returns a copy of the headers\nfrom the response with some modifications applied if necessary.\n\nFor example the location header (if present) is joined with the root URL of\nthe environment. Also the content length is automatically set to zero here for\ncertain status codes.\n\nChanged in version 0.6: Previously that function was called `fix_headers` and\nmodified the response object in place. Also since 0.6, IRIs in location and\ncontent-location headers are handled properly.\n\nAlso starting with 0.6, Werkzeug will attempt to set the content length if it\nis able to figure it out on its own. This is the case if all the strings in\nthe response iterable are already encoded and the iterable is buffered.\n\nenviron (WSGIEnvironment) \u2013 the WSGI environment of the request.\n\nreturns a new `Headers` object.\n\nwerkzeug.datastructures.Headers\n\nReturns the final WSGI response as tuple. The first item in the tuple is the\napplication iterator, the second the status and the third the list of headers.\nThe response returned is created specially for the given environment. For\nexample if the request method in the WSGI environment is `'HEAD'` the response\nwill be empty and only the headers and status code will be present.\n\nNew in version 0.6.\n\nenviron (WSGIEnvironment) \u2013 the WSGI environment of the request.\n\nan `(app_iter, status, headers)` tuple.\n\nTuple[Iterable[bytes], str, List[Tuple[str, str]]]\n\nif set to `False` accessing properties on the response object will not try to\nconsume the response iterator and convert it into a list.\n\nNew in version 0.6.2: That attribute was previously called\n`implicit_seqence_conversion`. (Notice the typo). If you did use this feature,\nyou have to adapt your code to the name change.\n\nCheck if the mimetype indicates JSON data, either application/json or\napplication/*+json.\n\nIf the iterator is buffered, this property will be `True`. A response object\nwill consider an iterator to be buffered if the response attribute is a list\nor tuple.\n\nNew in version 0.6.\n\nIf the response is streamed (the response is not an iterable with a length\ninformation) this property is `True`. In this case streamed means that there\nis no information about the number of iterations. This is usually `True` if a\ngenerator is passed to the response object.\n\nThis is useful for checking before applying some sort of post filtering that\nshould not take place for streamed responses.\n\nIter the response encoded with the encoding of the response. If the response\nobject is invoked as WSGI application the return value of this method is used\nas application iterator unless `direct_passthrough` was activated.\n\nIterator[bytes]\n\nThe parsed JSON data if `mimetype` indicates JSON (application/json, see\n`is_json()`).\n\nCalls `get_json()` with default arguments.\n\nA module or other object that has `dumps` and `loads` functions that match the\nAPI of the built-in `json` module.\n\nThe Last-Modified entity-header field indicates the date and time at which the\norigin server believes the variant was last modified.\n\nChanged in version 2.0: The datetime object is timezone-aware.\n\nThe Location response-header field is used to redirect the recipient to a\nlocation other than the Request-URI for completion of the request or\nidentification of a new resource.\n\nMake the response conditional to the request. This method works best if an\netag was defined for the response already. The `add_etag` method can be used\nto do that. If called without etag just the date header is set.\n\nThis does nothing if the request method in the request or environ is anything\nbut GET or HEAD.\n\nFor optimal performance when handling range requests, it\u2019s recommended that\nyour response data object implements `seekable`, `seek` and `tell` methods as\ndescribed by `io.IOBase`. Objects returned by `wrap_file()` automatically\nimplement those methods.\n\nIt does not remove the body of the response because that\u2019s something the\n`__call__()` function does for us automatically.\n\nReturns self so that you can do `return resp.make_conditional(req)` but\nmodifies the object in-place.\n\n`RequestedRangeNotSatisfiable` if `Range` header could not be parsed or\nsatisfied.\n\nResponse\n\nChanged in version 2.0: Range processing is skipped if length is 0 instead of\nraising a 416 Range Not Satisfiable error.\n\nConverts the response iterator in a list. By default this happens\nautomatically if required. If `implicit_sequence_conversion` is disabled, this\nmethod is not automatically called and some properties might raise exceptions.\nThis also encodes all the items.\n\nNew in version 0.6.\n\nNone\n\nThe mimetype (content type without charset etc.)\n\nThe mimetype parameters as dict. For example if the content type is\n`text/html; charset=utf-8` the params would be `{'charset': 'utf-8'}`.\n\nNew in version 0.5.\n\nThe response body to send as the WSGI iterable. A list of strings or bytes\nrepresents a fixed-length response, any other iterable is a streaming\nresponse. Strings are encoded to bytes as UTF-8.\n\nDo not set to a plain string or bytes, that will cause sending the response to\nbe very inefficient as it will iterate one byte at a time.\n\nThe Retry-After response-header field can be used with a 503 (Service\nUnavailable) response to indicate how long the service is expected to be\nunavailable to the requesting client.\n\nTime in seconds until expiration or date.\n\nChanged in version 2.0: The datetime object is timezone-aware.\n\nSets a cookie.\n\nA warning is raised if the size of the cookie header exceeds\n`max_cookie_size`, but the header will still be set.\n\nNone\n\nSets a new string as response. The value must be a string or bytes. If a\nstring is set it\u2019s encoded to the charset of the response (utf-8 by default).\n\nNew in version 0.9.\n\nvalue (Union[bytes, str]) \u2013\n\nNone\n\nSet the etag, and override the old one if there was one.\n\nNone\n\nThe HTTP status code as a string.\n\nThe HTTP status code as a number.\n\nThe response iterable as write-only stream.\n\nThe Vary field value indicates the set of request-header fields that fully\ndetermines, while the response is fresh, whether a cache is permitted to use\nthe response to reply to a subsequent request without revalidation.\n\nThe `WWW-Authenticate` header in a parsed form.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.accept_ranges", "path": "wrappers/index#werkzeug.wrappers.Response.accept_ranges", "type": "werkzeug.wrappers", "text": "\nThe `Accept-Ranges` header. Even though the name would indicate that multiple\nvalues are supported, it must be one string token only.\n\nThe values `'bytes'` and `'none'` are common.\n\nNew in version 0.7.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.access_control_allow_headers", "path": "wrappers/index#werkzeug.wrappers.Response.access_control_allow_headers", "type": "werkzeug.wrappers", "text": "\nWhich headers can be sent with the cross origin request.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.access_control_allow_methods", "path": "wrappers/index#werkzeug.wrappers.Response.access_control_allow_methods", "type": "werkzeug.wrappers", "text": "\nWhich methods can be used for the cross origin request.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.access_control_allow_origin", "path": "wrappers/index#werkzeug.wrappers.Response.access_control_allow_origin", "type": "werkzeug.wrappers", "text": "\nThe origin or \u2018*\u2019 for any origin that may make cross origin requests.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.access_control_expose_headers", "path": "wrappers/index#werkzeug.wrappers.Response.access_control_expose_headers", "type": "werkzeug.wrappers", "text": "\nWhich headers can be shared by the browser to JavaScript code.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.access_control_max_age", "path": "wrappers/index#werkzeug.wrappers.Response.access_control_max_age", "type": "werkzeug.wrappers", "text": "\nThe maximum age in seconds the access control settings can be cached for.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.add_etag()", "path": "wrappers/index#werkzeug.wrappers.Response.add_etag", "type": "werkzeug.wrappers", "text": "\nAdd an etag for the current response if there is none yet.\n\nChanged in version 2.0: SHA-1 is used to generate the value. MD5 may not be\navailable in some environments.\n\nNone\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.age", "path": "wrappers/index#werkzeug.wrappers.Response.age", "type": "werkzeug.wrappers", "text": "\nThe Age response-header field conveys the sender\u2019s estimate of the amount of\ntime since the response (or its revalidation) was generated at the origin\nserver.\n\nAge values are non-negative decimal integers, representing time in seconds.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.autocorrect_location_header", "path": "wrappers/index#werkzeug.wrappers.Response.autocorrect_location_header", "type": "werkzeug.wrappers", "text": "\nShould this response object correct the location header to be RFC conformant?\nThis is true by default.\n\nNew in version 0.8.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.automatically_set_content_length", "path": "wrappers/index#werkzeug.wrappers.Response.automatically_set_content_length", "type": "werkzeug.wrappers", "text": "\nShould this response object automatically set the content-length header if\npossible? This is true by default.\n\nNew in version 0.8.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.calculate_content_length()", "path": "wrappers/index#werkzeug.wrappers.Response.calculate_content_length", "type": "werkzeug.wrappers", "text": "\nReturns the content length if available or `None` otherwise.\n\nOptional[int]\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.call_on_close()", "path": "wrappers/index#werkzeug.wrappers.Response.call_on_close", "type": "werkzeug.wrappers", "text": "\nAdds a function to the internal list of functions that should be called as\npart of closing down the response. Since 0.7 this function also returns the\nfunction that was passed so that this can be used as a decorator.\n\nNew in version 0.6.\n\nfunc (Callable[[], Any]) \u2013\n\nCallable[[], Any]\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.close()", "path": "wrappers/index#werkzeug.wrappers.Response.close", "type": "werkzeug.wrappers", "text": "\nClose the wrapped response if possible. You can also use the object in a with\nstatement which will automatically close it.\n\nNew in version 0.9: Can now be used in a with statement.\n\nNone\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.content_encoding", "path": "wrappers/index#werkzeug.wrappers.Response.content_encoding", "type": "werkzeug.wrappers", "text": "\nThe Content-Encoding entity-header field is used as a modifier to the media-\ntype. When present, its value indicates what additional content codings have\nbeen applied to the entity-body, and thus what decoding mechanisms must be\napplied in order to obtain the media-type referenced by the Content-Type\nheader field.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.content_length", "path": "wrappers/index#werkzeug.wrappers.Response.content_length", "type": "werkzeug.wrappers", "text": "\nThe Content-Length entity-header field indicates the size of the entity-body,\nin decimal number of OCTETs, sent to the recipient or, in the case of the HEAD\nmethod, the size of the entity-body that would have been sent had the request\nbeen a GET.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.content_location", "path": "wrappers/index#werkzeug.wrappers.Response.content_location", "type": "werkzeug.wrappers", "text": "\nThe Content-Location entity-header field MAY be used to supply the resource\nlocation for the entity enclosed in the message when that entity is accessible\nfrom a location separate from the requested resource\u2019s URI.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.content_md5", "path": "wrappers/index#werkzeug.wrappers.Response.content_md5", "type": "werkzeug.wrappers", "text": "\nThe Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest\nof the entity-body for the purpose of providing an end-to-end message\nintegrity check (MIC) of the entity-body. (Note: a MIC is good for detecting\naccidental modification of the entity-body in transit, but is not proof\nagainst malicious attacks.)\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.content_security_policy", "path": "wrappers/index#werkzeug.wrappers.Response.content_security_policy", "type": "werkzeug.wrappers", "text": "\nThe Content-Security-Policy header adds an additional layer of security to\nhelp detect and mitigate certain types of attacks.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.content_security_policy_report_only", "path": "wrappers/index#werkzeug.wrappers.Response.content_security_policy_report_only", "type": "werkzeug.wrappers", "text": "\nThe Content-Security-Policy-Report-Only header adds a csp policy that is not\nenforced but is reported thereby helping detect certain types of attacks.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.content_type", "path": "wrappers/index#werkzeug.wrappers.Response.content_type", "type": "werkzeug.wrappers", "text": "\nThe Content-Type entity-header field indicates the media type of the entity-\nbody sent to the recipient or, in the case of the HEAD method, the media type\nthat would have been sent had the request been a GET.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.cross_origin_embedder_policy", "path": "wrappers/index#werkzeug.wrappers.Response.cross_origin_embedder_policy", "type": "werkzeug.wrappers", "text": "\nPrevents a document from loading any cross-origin resources that do not\nexplicitly grant the document permission. Values must be a member of the\n`werkzeug.http.COEP` enum.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.cross_origin_opener_policy", "path": "wrappers/index#werkzeug.wrappers.Response.cross_origin_opener_policy", "type": "werkzeug.wrappers", "text": "\nAllows control over sharing of browsing context group with cross-origin\ndocuments. Values must be a member of the `werkzeug.http.COOP` enum.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.date", "path": "wrappers/index#werkzeug.wrappers.Response.date", "type": "werkzeug.wrappers", "text": "\nThe Date general-header field represents the date and time at which the\nmessage was originated, having the same semantics as orig-date in RFC 822.\n\nChanged in version 2.0: The datetime object is timezone-aware.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.delete_cookie()", "path": "wrappers/index#werkzeug.wrappers.Response.delete_cookie", "type": "werkzeug.wrappers", "text": "\nDelete a cookie. Fails silently if key doesn\u2019t exist.\n\nNone\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.direct_passthrough", "path": "wrappers/index#werkzeug.wrappers.Response.direct_passthrough", "type": "werkzeug.wrappers", "text": "\nPass the response body directly through as the WSGI iterable. This can be used\nwhen the body is a binary file or other iterator of bytes, to skip some\nunnecessary checks. Use `send_file()` instead of setting this manually.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.expires", "path": "wrappers/index#werkzeug.wrappers.Response.expires", "type": "werkzeug.wrappers", "text": "\nThe Expires entity-header field gives the date/time after which the response\nis considered stale. A stale cache entry may not normally be returned by a\ncache.\n\nChanged in version 2.0: The datetime object is timezone-aware.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.force_type()", "path": "wrappers/index#werkzeug.wrappers.Response.force_type", "type": "werkzeug.wrappers", "text": "\nEnforce that the WSGI response is a response object of the current type.\nWerkzeug will use the `Response` internally in many situations like the\nexceptions. If you call `get_response()` on an exception you will get back a\nregular `Response` object, even if you are using a custom subclass.\n\nThis method can enforce a given response type, and it will also convert\narbitrary WSGI callables into response objects if an environ is provided:\n\nThis is especially useful if you want to post-process responses in the main\ndispatcher and use functionality provided by your subclass.\n\nKeep in mind that this will modify response objects in place if possible!\n\na response object.\n\nResponse\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.freeze()", "path": "wrappers/index#werkzeug.wrappers.Response.freeze", "type": "werkzeug.wrappers", "text": "\nMake the response object ready to be pickled. Does the following:\n\nChanged in version 2.0: An `ETag` header is added, the `no_etag` parameter is\ndeprecated and will be removed in Werkzeug 2.1.\n\nChanged in version 0.6: The `Content-Length` header is set.\n\nno_etag (None) \u2013\n\nNone\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.from_app()", "path": "wrappers/index#werkzeug.wrappers.Response.from_app", "type": "werkzeug.wrappers", "text": "\nCreate a new response object from an application output. This works best if\nyou pass it an application that returns a generator all the time. Sometimes\napplications may use the `write()` callable returned by the `start_response`\nfunction. This tries to resolve such edge cases automatically. But if you\ndon\u2019t get the expected output you should set `buffered` to `True` which\nenforces buffering.\n\na response object.\n\nResponse\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.get_app_iter()", "path": "wrappers/index#werkzeug.wrappers.Response.get_app_iter", "type": "werkzeug.wrappers", "text": "\nReturns the application iterator for the given environ. Depending on the\nrequest method and the current status code the return value might be an empty\nresponse rather than the one from the response.\n\nIf the request method is `HEAD` or the status code is in a range where the\nHTTP specification requires an empty response, an empty iterable is returned.\n\nNew in version 0.6.\n\nenviron (WSGIEnvironment) \u2013 the WSGI environment of the request.\n\na response iterable.\n\nIterable[bytes]\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.get_data()", "path": "wrappers/index#werkzeug.wrappers.Response.get_data", "type": "werkzeug.wrappers", "text": "\nThe string representation of the response body. Whenever you call this\nproperty the response iterable is encoded and flattened. This can lead to\nunwanted behavior if you stream big data.\n\nThis behavior can be disabled by setting `implicit_sequence_conversion` to\n`False`.\n\nIf `as_text` is set to `True` the return value will be a decoded string.\n\nNew in version 0.9.\n\nas_text (bool) \u2013\n\nUnion[bytes, str]\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.get_etag()", "path": "wrappers/index#werkzeug.wrappers.Response.get_etag", "type": "werkzeug.wrappers", "text": "\nReturn a tuple in the form `(etag, is_weak)`. If there is no ETag the return\nvalue is `(None, None)`.\n\nUnion[Tuple[str, bool], Tuple[None, None]]\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.get_json()", "path": "wrappers/index#werkzeug.wrappers.Response.get_json", "type": "werkzeug.wrappers", "text": "\nParse `data` as JSON. Useful during testing.\n\nIf the mimetype does not indicate JSON (application/json, see `is_json()`),\nthis returns `None`.\n\nUnlike `Request.get_json()`, the result is not cached.\n\nOptional[Any]\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.get_wsgi_headers()", "path": "wrappers/index#werkzeug.wrappers.Response.get_wsgi_headers", "type": "werkzeug.wrappers", "text": "\nThis is automatically called right before the response is started and returns\nheaders modified for the given environment. It returns a copy of the headers\nfrom the response with some modifications applied if necessary.\n\nFor example the location header (if present) is joined with the root URL of\nthe environment. Also the content length is automatically set to zero here for\ncertain status codes.\n\nChanged in version 0.6: Previously that function was called `fix_headers` and\nmodified the response object in place. Also since 0.6, IRIs in location and\ncontent-location headers are handled properly.\n\nAlso starting with 0.6, Werkzeug will attempt to set the content length if it\nis able to figure it out on its own. This is the case if all the strings in\nthe response iterable are already encoded and the iterable is buffered.\n\nenviron (WSGIEnvironment) \u2013 the WSGI environment of the request.\n\nreturns a new `Headers` object.\n\nwerkzeug.datastructures.Headers\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.get_wsgi_response()", "path": "wrappers/index#werkzeug.wrappers.Response.get_wsgi_response", "type": "werkzeug.wrappers", "text": "\nReturns the final WSGI response as tuple. The first item in the tuple is the\napplication iterator, the second the status and the third the list of headers.\nThe response returned is created specially for the given environment. For\nexample if the request method in the WSGI environment is `'HEAD'` the response\nwill be empty and only the headers and status code will be present.\n\nNew in version 0.6.\n\nenviron (WSGIEnvironment) \u2013 the WSGI environment of the request.\n\nan `(app_iter, status, headers)` tuple.\n\nTuple[Iterable[bytes], str, List[Tuple[str, str]]]\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.implicit_sequence_conversion", "path": "wrappers/index#werkzeug.wrappers.Response.implicit_sequence_conversion", "type": "werkzeug.wrappers", "text": "\nif set to `False` accessing properties on the response object will not try to\nconsume the response iterator and convert it into a list.\n\nNew in version 0.6.2: That attribute was previously called\n`implicit_seqence_conversion`. (Notice the typo). If you did use this feature,\nyou have to adapt your code to the name change.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.iter_encoded()", "path": "wrappers/index#werkzeug.wrappers.Response.iter_encoded", "type": "werkzeug.wrappers", "text": "\nIter the response encoded with the encoding of the response. If the response\nobject is invoked as WSGI application the return value of this method is used\nas application iterator unless `direct_passthrough` was activated.\n\nIterator[bytes]\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.json_module", "path": "wrappers/index#werkzeug.wrappers.Response.json_module", "type": "werkzeug.wrappers", "text": "\nA module or other object that has `dumps` and `loads` functions that match the\nAPI of the built-in `json` module.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.last_modified", "path": "wrappers/index#werkzeug.wrappers.Response.last_modified", "type": "werkzeug.wrappers", "text": "\nThe Last-Modified entity-header field indicates the date and time at which the\norigin server believes the variant was last modified.\n\nChanged in version 2.0: The datetime object is timezone-aware.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.location", "path": "wrappers/index#werkzeug.wrappers.Response.location", "type": "werkzeug.wrappers", "text": "\nThe Location response-header field is used to redirect the recipient to a\nlocation other than the Request-URI for completion of the request or\nidentification of a new resource.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.make_conditional()", "path": "wrappers/index#werkzeug.wrappers.Response.make_conditional", "type": "werkzeug.wrappers", "text": "\nMake the response conditional to the request. This method works best if an\netag was defined for the response already. The `add_etag` method can be used\nto do that. If called without etag just the date header is set.\n\nThis does nothing if the request method in the request or environ is anything\nbut GET or HEAD.\n\nFor optimal performance when handling range requests, it\u2019s recommended that\nyour response data object implements `seekable`, `seek` and `tell` methods as\ndescribed by `io.IOBase`. Objects returned by `wrap_file()` automatically\nimplement those methods.\n\nIt does not remove the body of the response because that\u2019s something the\n`__call__()` function does for us automatically.\n\nReturns self so that you can do `return resp.make_conditional(req)` but\nmodifies the object in-place.\n\n`RequestedRangeNotSatisfiable` if `Range` header could not be parsed or\nsatisfied.\n\nResponse\n\nChanged in version 2.0: Range processing is skipped if length is 0 instead of\nraising a 416 Range Not Satisfiable error.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.make_sequence()", "path": "wrappers/index#werkzeug.wrappers.Response.make_sequence", "type": "werkzeug.wrappers", "text": "\nConverts the response iterator in a list. By default this happens\nautomatically if required. If `implicit_sequence_conversion` is disabled, this\nmethod is not automatically called and some properties might raise exceptions.\nThis also encodes all the items.\n\nNew in version 0.6.\n\nNone\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.response", "path": "wrappers/index#werkzeug.wrappers.Response.response", "type": "werkzeug.wrappers", "text": "\nThe response body to send as the WSGI iterable. A list of strings or bytes\nrepresents a fixed-length response, any other iterable is a streaming\nresponse. Strings are encoded to bytes as UTF-8.\n\nDo not set to a plain string or bytes, that will cause sending the response to\nbe very inefficient as it will iterate one byte at a time.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.set_cookie()", "path": "wrappers/index#werkzeug.wrappers.Response.set_cookie", "type": "werkzeug.wrappers", "text": "\nSets a cookie.\n\nA warning is raised if the size of the cookie header exceeds\n`max_cookie_size`, but the header will still be set.\n\nNone\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.set_data()", "path": "wrappers/index#werkzeug.wrappers.Response.set_data", "type": "werkzeug.wrappers", "text": "\nSets a new string as response. The value must be a string or bytes. If a\nstring is set it\u2019s encoded to the charset of the response (utf-8 by default).\n\nNew in version 0.9.\n\nvalue (Union[bytes, str]) \u2013\n\nNone\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.set_etag()", "path": "wrappers/index#werkzeug.wrappers.Response.set_etag", "type": "werkzeug.wrappers", "text": "\nSet the etag, and override the old one if there was one.\n\nNone\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response._ensure_sequence()", "path": "wrappers/index#werkzeug.wrappers.Response._ensure_sequence", "type": "werkzeug.wrappers", "text": "\nThis method can be called by methods that need a sequence. If `mutable` is\ntrue, it will also ensure that the response sequence is a standard Python\nlist.\n\nNew in version 0.6.\n\nmutable (bool) \u2013\n\nNone\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Response.__call__()", "path": "wrappers/index#werkzeug.wrappers.Response.__call__", "type": "werkzeug.wrappers", "text": "\nProcess this response as WSGI application.\n\nan application iterator\n\nIterable[bytes]\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "ResponseCacheControl", "path": "datastructures/index#werkzeug.datastructures.ResponseCacheControl", "type": "werkzeug.datastructures", "text": "\nA cache control for responses. Unlike `RequestCacheControl` this is mutable\nand gives access to response-relevant cache control headers.\n\nTo get a header of the `ResponseCacheControl` object again you can convert the\nobject into a string or call the `to_header()` method. If you plan to subclass\nit and add your own items have a look at the sourcecode for that class.\n\nNew in version 0.5: In previous versions a `CacheControl` class existed that\nwas used both for request and response.\n\naccessor for \u2018no-cache\u2019\n\naccessor for \u2018no-store\u2019\n\naccessor for \u2018max-age\u2019\n\naccessor for \u2018no-transform\u2019\n\naccessor for \u2018immutable\u2019\n\naccessor for \u2018must-revalidate\u2019\n\naccessor for \u2018private\u2019\n\naccessor for \u2018proxy-revalidate\u2019\n\naccessor for \u2018public\u2019\n\naccessor for \u2018s-maxage\u2019\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "ResponseCacheControl.max_age", "path": "datastructures/index#werkzeug.datastructures.ResponseCacheControl.max_age", "type": "werkzeug.datastructures", "text": "\naccessor for \u2018max-age\u2019\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "ResponseCacheControl.no_cache", "path": "datastructures/index#werkzeug.datastructures.ResponseCacheControl.no_cache", "type": "werkzeug.datastructures", "text": "\naccessor for \u2018no-cache\u2019\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "ResponseCacheControl.no_store", "path": "datastructures/index#werkzeug.datastructures.ResponseCacheControl.no_store", "type": "werkzeug.datastructures", "text": "\naccessor for \u2018no-store\u2019\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "ResponseCacheControl.no_transform", "path": "datastructures/index#werkzeug.datastructures.ResponseCacheControl.no_transform", "type": "werkzeug.datastructures", "text": "\naccessor for \u2018no-transform\u2019\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Rule", "path": "routing/index#werkzeug.routing.Rule", "type": "werkzeug.routing", "text": "\nA Rule represents one URL pattern. There are some options for `Rule` that\nchange the way it behaves and are passed to the `Rule` constructor. Note that\nbesides the rule-string all arguments must be keyword arguments in order to\nnot break the application on Werkzeug upgrades.\n\nRule strings basically are just normal URL paths with placeholders in the\nformat `<converter(arguments):name>` where the converter and the arguments are\noptional. If no converter is defined the `default` converter is used which\nmeans `string` in the normal configuration.\n\nURL rules that end with a slash are branch URLs, others are leaves. If you\nhave `strict_slashes` enabled (which is the default), all branch URLs that are\nmatched without a trailing slash will trigger a redirect to the same URL with\nthe missing slash appended.\n\nThe converters are defined on the `Map`.\n\nThe endpoint for this rule. This can be anything. A reference to a function, a\nstring, a number etc. The preferred way is using a string because the endpoint\nis used for URL generation.\n\nAn optional dict with defaults for other rules with the same endpoint. This is\na bit tricky but useful if you want to have unique URLs:\n\nIf a user now visits `http://example.com/all/page/1` he will be redirected to\n`http://example.com/all/`. If `redirect_defaults` is disabled on the `Map`\ninstance this will only affect the URL generation.\n\nThe subdomain rule string for this rule. If not specified the rule only\nmatches for the `default_subdomain` of the map. If the map is not bound to a\nsubdomain this feature is disabled.\n\nCan be useful if you want to have user profiles on different subdomains and\nall subdomains are forwarded to your application:\n\nA sequence of http methods this rule applies to. If not specified, all methods\nare allowed. For example this can be useful if you want different endpoints\nfor `POST` and `GET`. If methods are defined and the path matches but the\nmethod matched against is not in this list or in the list of another rule for\nthat path the error raised is of the type `MethodNotAllowed` rather than\n`NotFound`. If `GET` is present in the list of methods and `HEAD` is not,\n`HEAD` is added automatically.\n\nOverride the `Map` setting for `strict_slashes` only for this rule. If not\nspecified the `Map` setting is used.\n\nOverride `Map.merge_slashes` for this rule.\n\nSet this to True and the rule will never match but will create a URL that can\nbe build. This is useful if you have resources on a subdomain or folder that\nare not handled by the WSGI application (like static data)\n\nIf given this must be either a string or callable. In case of a callable it\u2019s\ncalled with the url adapter that triggered the match and the values of the URL\nas keyword arguments and has to return the target for the redirect, otherwise\nit has to be a string with placeholders in rule syntax:\n\nWhen the rule is matched the routing system will raise a `RequestRedirect`\nexception with the target for the redirect.\n\nKeep in mind that the URL will be joined against the URL root of the script so\ndon\u2019t use a leading slash on the target URL unless you really mean root of\nthat domain.\n\nIf enabled this rule serves as an alias for another rule with the same\nendpoint and arguments.\n\nIf provided and the URL map has host matching enabled this can be used to\nprovide a match rule for the whole host. This also means that the subdomain\nfeature is disabled.\n\nIf `True`, this rule is only matches for WebSocket (`ws://`, `wss://`)\nrequests. By default, rules will only match for HTTP requests.\n\nNew in version 1.0: Added `websocket`.\n\nNew in version 1.0: Added `merge_slashes`.\n\nNew in version 0.7: Added `alias` and `host`.\n\nChanged in version 0.6.1: `HEAD` is added to `methods` if `GET` is present.\n\nNone\n\nReturn an unbound copy of this rule.\n\nThis can be useful if want to reuse an already bound URL for another map. See\n`get_empty_kwargs` to override what keyword arguments are provided to the new\ncopy.\n\nwerkzeug.routing.Rule\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Rule.empty()", "path": "routing/index#werkzeug.routing.Rule.empty", "type": "werkzeug.routing", "text": "\nReturn an unbound copy of this rule.\n\nThis can be useful if want to reuse an already bound URL for another map. See\n`get_empty_kwargs` to override what keyword arguments are provided to the new\ncopy.\n\nwerkzeug.routing.Rule\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "RuleFactory", "path": "routing/index#werkzeug.routing.RuleFactory", "type": "werkzeug.routing", "text": "\nAs soon as you have more complex URL setups it\u2019s a good idea to use rule\nfactories to avoid repetitive tasks. Some of them are builtin, others can be\nadded by subclassing `RuleFactory` and overriding `get_rules`.\n\nSubclasses of `RuleFactory` have to override this method and return an\niterable of rules.\n\nmap (werkzeug.routing.Map) \u2013\n\nIterable[werkzeug.routing.Rule]\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "RuleFactory.get_rules()", "path": "routing/index#werkzeug.routing.RuleFactory.get_rules", "type": "werkzeug.routing", "text": "\nSubclasses of `RuleFactory` have to override this method and return an\niterable of rules.\n\nmap (werkzeug.routing.Map) \u2013\n\nIterable[werkzeug.routing.Rule]\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "RuleTemplate", "path": "routing/index#werkzeug.routing.RuleTemplate", "type": "werkzeug.routing", "text": "\nReturns copies of the rules wrapped and expands string templates in the\nendpoint, rule, defaults or subdomain sections.\n\nHere a small example for such a rule template:\n\nWhen a rule template is called the keyword arguments are used to replace the\nplaceholders in all the string parameters.\n\nrules (Iterable[Rule]) \u2013\n\nNone\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "run_simple()", "path": "serving/index#werkzeug.serving.run_simple", "type": "werkzeug.serving", "text": "\nStart a WSGI application. Optional features include a reloader, multithreading\nand fork support.\n\nThis function has a command-line interface too:\n\nChanged in version 2.0: Added `exclude_patterns` parameter.\n\nChanged in version 0.15: Bind to a Unix socket by passing a path that starts\nwith `unix://` as the `hostname`.\n\nNew in version 0.10: Improved the reloader and added support for changing the\nbackend through the `reloader_type` parameter. See Reloader for more\ninformation.\n\nNew in version 0.9: Added command-line interface.\n\nNew in version 0.8: Added support for automatically loading a SSL context from\ncertificate file and private key.\n\nNew in version 0.6: support for SSL was added.\n\nNew in version 0.5: `static_files` was added to simplify serving of static\nfiles as well as `passthrough_errors`.\n\nNone\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "run_wsgi_app()", "path": "test/index#werkzeug.test.run_wsgi_app", "type": "werkzeug.test", "text": "\nReturn a tuple in the form (app_iter, status, headers) of the application\noutput. This works best if you pass it an application that returns an iterator\nall the time.\n\nSometimes applications may use the `write()` callable returned by the\n`start_response` function. This tries to resolve such edge cases\nautomatically. But if you don\u2019t get the expected output you should set\n`buffered` to `True` which enforces buffering.\n\nIf passed an invalid WSGI application the behavior of this function is\nundefined. Never pass non-conforming WSGI applications to this function.\n\ntuple in the form `(app_iter, status, headers)`\n\nTuple[Iterable[bytes], str, werkzeug.datastructures.Headers]\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "safe_join()", "path": "utils/index#werkzeug.security.safe_join", "type": "werkzeug.security", "text": "\nSafely join zero or more untrusted path components to a base directory to\navoid escaping the base directory.\n\nA safe path, otherwise `None`.\n\nOptional[str]\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "safe_str_cmp()", "path": "utils/index#werkzeug.security.safe_str_cmp", "type": "werkzeug.security", "text": "\nThis function compares strings in somewhat constant time. This requires that\nthe length of at least one string is known in advance.\n\nReturns `True` if the two strings are equal, or `False` if they are not.\n\nDeprecated since version 2.0: Will be removed in Werkzeug 2.1. Use\n`hmac.compare_digest()` instead.\n\nNew in version 0.7.\n\nbool\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "secure_filename()", "path": "utils/index#werkzeug.utils.secure_filename", "type": "werkzeug.utils", "text": "\nPass it a filename and it will return a secure version of it. This filename\ncan then safely be stored on a regular file system and passed to\n`os.path.join()`. The filename returned is an ASCII only string for maximum\nportability.\n\nOn windows systems the function also makes sure that the file is not named\nafter one of the special device files.\n\nThe function might return an empty filename. It\u2019s your responsibility to\nensure that the filename is unique and that you abort or generate a random\nfilename if the function returned an empty one.\n\nNew in version 0.5.\n\nfilename (str) \u2013 the filename to secure\n\nstr\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "send_file()", "path": "utils/index#werkzeug.utils.send_file", "type": "werkzeug.utils", "text": "\nSend the contents of a file to the client.\n\nThe first argument can be a file path or a file-like object. Paths are\npreferred in most cases because Werkzeug can manage the file and get extra\ninformation from the path. Passing a file-like object requires that the file\nis opened in binary mode, and is mostly useful when building a file in memory\nwith `io.BytesIO`.\n\nNever pass file paths provided by a user. The path is assumed to be trusted,\nso a user could craft a path to access a file you didn\u2019t intend.\n\nIf the WSGI server sets a `file_wrapper` in `environ`, it is used, otherwise\nWerkzeug\u2019s built-in wrapper is used. Alternatively, if the HTTP server\nsupports `X-Sendfile`, `use_x_sendfile=True` will tell the server to send the\ngiven path, which is much more efficient than reading it in Python.\n\nResponse\n\nNew in version 2.0: Adapted from Flask\u2019s implementation.\n\nChanged in version 2.0: `download_name` replaces Flask\u2019s `attachment_filename`\nparameter. If `as_attachment=False`, it is passed with `Content-Disposition:\ninline` instead.\n\nChanged in version 2.0: `max_age` replaces Flask\u2019s `cache_timeout` parameter.\n`conditional` is enabled and `max_age` is not set by default.\n\nChanged in version 2.0: `etag` replaces Flask\u2019s `add_etags` parameter. It can\nbe a string to use instead of generating one.\n\nChanged in version 2.0: If an encoding is returned when guessing `mimetype`\nfrom `download_name`, set the `Content-Encoding` header.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Serve Shared Static Files", "path": "middleware/shared_data/index", "type": "Other", "text": "\nA WSGI middleware which provides static content for development environments\nor simple server setups. Its usage is quite simple:\n\nThe contents of the folder `./shared` will now be available on\n`http://example.com/shared/`. This is pretty useful during development because\na standalone media server is not required. Files can also be mounted on the\nroot folder and still continue to use the application because the shared data\nmiddleware forwards all unhandled requests to the application, even if the\nrequests are below one of the shared folders.\n\nIf `pkg_resources` is available you can also tell the middleware to serve\nfiles from package data:\n\nThis will then serve the `static` folder in the `myapplication` Python\npackage.\n\nThe optional `disallow` parameter can be a list of `fnmatch()` rules for files\nthat are not accessible from the web. If `cache` is set to `False` no caching\nheaders are sent.\n\nCurrently the middleware does not support non-ASCII filenames. If the encoding\non the file system happens to match the encoding of the URI it may work but\nthis could also be by accident. We strongly suggest using ASCII only file\nnames for static files.\n\nThe middleware will guess the mimetype using the Python `mimetype` module. If\nit\u2019s unable to figure out the charset it will fall back to\n`fallback_mimetype`.\n\nNone\n\nChanged in version 1.0: The default `fallback_mimetype` is `application/octet-\nstream`. If a filename looks like a text mimetype, the `utf-8` charset is\nadded to it.\n\nNew in version 0.6: Added `fallback_mimetype`.\n\nChanged in version 0.5: Added `cache_timeout`.\n\nSubclasses can override this method to disallow the access to certain files.\nHowever by providing `disallow` in the constructor this method is overwritten.\n\nfilename (str) \u2013\n\nbool\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Serving WSGI Applications", "path": "serving/index", "type": "Other", "text": "\nThere are many ways to serve a WSGI application. While you\u2019re developing it,\nyou usually don\u2019t want to have a full-blown webserver like Apache up and\nrunning, but instead a simple standalone one. Because of that Werkzeug comes\nwith a builtin development server.\n\nThe easiest way is creating a small `start-myproject.py` file that runs the\napplication using the builtin server:\n\nYou can also pass it the `extra_files` keyword argument with a list of\nadditional files (like configuration files) you want to observe.\n\nStart a WSGI application. Optional features include a reloader, multithreading\nand fork support.\n\nThis function has a command-line interface too:\n\nChanged in version 2.0: Added `exclude_patterns` parameter.\n\nChanged in version 0.15: Bind to a Unix socket by passing a path that starts\nwith `unix://` as the `hostname`.\n\nNew in version 0.10: Improved the reloader and added support for changing the\nbackend through the `reloader_type` parameter. See Reloader for more\ninformation.\n\nNew in version 0.9: Added command-line interface.\n\nNew in version 0.8: Added support for automatically loading a SSL context from\ncertificate file and private key.\n\nNew in version 0.6: support for SSL was added.\n\nNew in version 0.5: `static_files` was added to simplify serving of static\nfiles as well as `passthrough_errors`.\n\nNone\n\nChecks if the application is running from within the Werkzeug reloader\nsubprocess.\n\nNew in version 0.10.\n\nbool\n\nCreates an SSL key for development. This should be used instead of the\n`'adhoc'` key which generates a new cert on each server start. It accepts a\npath for where it should store the key and cert and either a host or CN. If a\nhost is given it will use the CN `*.host/CN=host`.\n\nFor more information see `run_simple()`.\n\nNew in version 0.9.\n\nTuple[str, str]\n\nInformation\n\nThe development server is not intended to be used on production systems. It\nwas designed especially for development purposes and performs poorly under\nhigh load. For deployment setups have a look at the Application Deployment\npages.\n\nChanged in version 0.10.\n\nThe Werkzeug reloader constantly monitors modules and paths of your web\napplication, and restarts the server if any of the observed files change.\n\nSince version 0.10, there are two backends the reloader supports: `stat` and\n`watchdog`.\n\nIf `watchdog` is installed and available it will automatically be used instead\nof the builtin `stat` reloader.\n\nTo switch between the backends you can use the `reloader_type` parameter of\nthe `run_simple()` function. `'stat'` sets it to the default stat based\npolling and `'watchdog'` forces it to the watchdog backend.\n\nNote\n\nSome edge cases, like modules that failed to import correctly, are not handled\nby the stat reloader for performance reasons. The watchdog reloader monitors\nsuch files too.\n\nThe development server highlights the request logs in different colors based\non the status code. On Windows, Colorama must be installed as well to enable\nthis.\n\nMany web applications utilize multiple subdomains. This can be a bit tricky to\nsimulate locally. Fortunately there is the hosts file that can be used to\nassign the local computer multiple names.\n\nThis allows you to call your local computer `yourapplication.local` and\n`api.yourapplication.local` (or anything else) in addition to `localhost`.\n\nYou can find the hosts file on the following location:\n\nWindows\n\n`%SystemRoot%\\system32\\drivers\\etc\\hosts`\n\nLinux / OS X\n\n`/etc/hosts`\n\nYou can open the file with your favorite text editor and add a new name after\n`localhost`:\n\nSave the changes and after a while you should be able to access the\ndevelopment server on these host names as well. You can use the URL Routing\nsystem to dispatch between different hosts or parse `request.host` yourself.\n\nNew in version 0.7.\n\nStarting with Werkzeug 0.7 the development server provides a way to shut down\nthe server after a request. This currently only works with Python 2.6 and\nlater and will only work with the development server. To initiate the shutdown\nyou have to call a function named `'werkzeug.server.shutdown'` in the WSGI\nenvironment:\n\nOn operating systems that support ipv6 and have it configured such as modern\nLinux systems, OS X 10.4 or higher as well as Windows Vista some browsers can\nbe painfully slow if accessing your local server. The reason for this is that\nsometimes \u201clocalhost\u201d is configured to be available on both ipv4 and ipv6\nsockets and some browsers will try to access ipv6 first and then ipv4.\n\nAt the current time the integrated webserver does not support ipv6 and ipv4 at\nthe same time and for better portability ipv4 is the default.\n\nIf you notice that the web browser takes ages to load the page there are two\nways around this issue. If you don\u2019t need ipv6 support you can disable the\nipv6 entry in the hosts file by removing this line:\n\nAlternatively you can also disable ipv6 support in your browser. For example\nif Firefox shows this behavior you can disable it by going to `about:config`\nand disabling the `network.dns.disableIPv6` key. This however is not\nrecommended as of Werkzeug 0.6.1!\n\nStarting with Werkzeug 0.6.1, the server will now switch between ipv4 and ipv6\nbased on your operating system\u2019s configuration. This means if that you\ndisabled ipv6 support in your browser but your operating system is preferring\nipv6, you will be unable to connect to your server. In that situation, you can\neither remove the localhost entry for `::1` or explicitly bind the hostname to\nan ipv4 address (`127.0.0.1`)\n\nNew in version 0.6.\n\nThe builtin server supports SSL for testing purposes. If an SSL context is\nprovided it will be used. That means a server can either run in HTTP or HTTPS\nmode, but not both.\n\nThe easiest way to do SSL based development with Werkzeug is by using it to\ngenerate an SSL certificate and private key and storing that somewhere and to\nthen put it there. For the certificate you need to provide the name of your\nserver on generation or a `CN`.\n\nGenerate an SSL key and store it somewhere:\n\nNow this tuple can be passed as `ssl_context` to the `run_simple()` method:\n\nYou will have to acknowledge the certificate in your browser once then.\n\nYou can use a `ssl.SSLContext` object instead of a tuple for full control over\nthe TLS configuration.\n\nA key and certificate can be created in advance using the openssl tool instead\nof the `make_ssl_devcert()`. This requires that you have the `openssl` command\ninstalled on your system:\n\nThe easiest way to enable SSL is to start the server in adhoc-mode. In that\ncase Werkzeug will generate an SSL certificate for you:\n\nThe downside of this of course is that you will have to acknowledge the\ncertificate each time the server is reloaded. Adhoc certificates are\ndiscouraged because modern browsers do a bad job at supporting them for\nsecurity reasons.\n\nThis feature requires the cryptography library to be installed.\n\nThe dev server can bind to a Unix socket instead of a TCP socket.\n`run_simple()` will bind to a Unix socket if the `hostname` parameter starts\nwith `'unix://'`.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "SharedDataMiddleware", "path": "middleware/shared_data/index#werkzeug.middleware.shared_data.SharedDataMiddleware", "type": "werkzeug.middleware.shared_data", "text": "\nA WSGI middleware which provides static content for development environments\nor simple server setups. Its usage is quite simple:\n\nThe contents of the folder `./shared` will now be available on\n`http://example.com/shared/`. This is pretty useful during development because\na standalone media server is not required. Files can also be mounted on the\nroot folder and still continue to use the application because the shared data\nmiddleware forwards all unhandled requests to the application, even if the\nrequests are below one of the shared folders.\n\nIf `pkg_resources` is available you can also tell the middleware to serve\nfiles from package data:\n\nThis will then serve the `static` folder in the `myapplication` Python\npackage.\n\nThe optional `disallow` parameter can be a list of `fnmatch()` rules for files\nthat are not accessible from the web. If `cache` is set to `False` no caching\nheaders are sent.\n\nCurrently the middleware does not support non-ASCII filenames. If the encoding\non the file system happens to match the encoding of the URI it may work but\nthis could also be by accident. We strongly suggest using ASCII only file\nnames for static files.\n\nThe middleware will guess the mimetype using the Python `mimetype` module. If\nit\u2019s unable to figure out the charset it will fall back to\n`fallback_mimetype`.\n\nNone\n\nChanged in version 1.0: The default `fallback_mimetype` is `application/octet-\nstream`. If a filename looks like a text mimetype, the `utf-8` charset is\nadded to it.\n\nNew in version 0.6: Added `fallback_mimetype`.\n\nChanged in version 0.5: Added `cache_timeout`.\n\nSubclasses can override this method to disallow the access to certain files.\nHowever by providing `disallow` in the constructor this method is overwritten.\n\nfilename (str) \u2013\n\nbool\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "SharedDataMiddleware.is_allowed()", "path": "middleware/shared_data/index#werkzeug.middleware.shared_data.SharedDataMiddleware.is_allowed", "type": "werkzeug.middleware.shared_data", "text": "\nSubclasses can override this method to disallow the access to certain files.\nHowever by providing `disallow` in the constructor this method is overwritten.\n\nfilename (str) \u2013\n\nbool\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Subdomain", "path": "routing/index#werkzeug.routing.Subdomain", "type": "werkzeug.routing", "text": "\nAll URLs provided by this factory have the subdomain set to a specific domain.\nFor example if you want to use the subdomain for the current language this can\nbe a good setup:\n\nAll the rules except for the `'#select_language'` endpoint will now listen on\na two letter long subdomain that holds the language code for the current\nrequest.\n\nNone\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Submount", "path": "routing/index#werkzeug.routing.Submount", "type": "werkzeug.routing", "text": "\nLike `Subdomain` but prefixes the URL rule with a given string:\n\nNow the rule `'blog/show'` matches `/blog/entry/<entry_slug>`.\n\nNone\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Testing WSGI Applications", "path": "test/index", "type": "Other", "text": "\nWerkzeug provides a `Client` to simulate requests to a WSGI application\nwithout starting a server. The client has methods for making different types\nof requests, as well as managing cookies across requests.\n\nThe client\u2019s request methods return instances of `TestResponse`. This provides\nextra attributes and methods on top of `Response` that are useful for testing.\n\nBy passing a dict to `data`, the client will construct a request body with\nfile and form data. It will set the content type to `application/x-www-form-\nurlencoded` if there are no files, or `multipart/form-data` there are.\n\nPass a string, bytes, or file-like object to `data` to use that as the raw\nrequest body. In that case, you should set the content type appropriately. For\nexample, to post YAML:\n\nA shortcut when testing JSON APIs is to pass a dict to `json` instead of using\n`data`. This will automatically call `json.dumps()` and set the content type\nto `application/json`. Additionally, if the app returns JSON, `response.json`\nwill automatically call `json.loads()`.\n\n`EnvironBuilder` is used to construct a WSGI environ dict. The test client\nuses this internally to prepare its requests. The arguments passed to the\nclient request methods are the same as the builder.\n\nSometimes, it can be useful to construct a WSGI environment manually. An\nenviron builder or dict can be passed to the test client request methods in\nplace of other arguments to use a custom environ.\n\nThe test client responses make this available through `TestResponse.request`\nand `response.request.environ`.\n\nThis class allows you to send requests to a wrapped application.\n\nThe use_cookies parameter indicates whether cookies should be stored and sent\nfor subsequent requests. This is True by default, but passing False will\ndisable this behaviour.\n\nIf you want to request some subdomain of your application you may set\n`allow_subdomain_redirects` to `True` as if not no external redirects are\nallowed.\n\nChanged in version 2.0: `response_wrapper` is always a subclass of\n:class:`TestResponse`.\n\nChanged in version 0.5: Added the `use_cookies` parameter.\n\nNone\n\nSets a cookie in the client\u2019s cookie jar. The server name is required and has\nto match the one that is also passed to the open call.\n\nNone\n\nDeletes a cookie in the test client.\n\nNone\n\nGenerate an environ dict from the given arguments, make a request to the\napplication using it, and return the response.\n\nwerkzeug.test.TestResponse\n\nChanged in version 2.0: `as_tuple` is deprecated and will be removed in\nWerkzeug 2.1. Use `TestResponse.request` and `request.environ` instead.\n\nChanged in version 2.0: The request input stream is closed when calling\n`response.close()`. Input streams for redirects are automatically closed.\n\nChanged in version 0.5: If a dict is provided as file in the dict for the\n`data` parameter the content type has to be called `content_type` instead of\n`mimetype`. This change was made for consistency with `werkzeug.FileWrapper`.\n\nChanged in version 0.5: Added the `follow_redirects` parameter.\n\nCall `open()` with `method` set to `GET`.\n\nwerkzeug.test.TestResponse\n\nCall `open()` with `method` set to `POST`.\n\nwerkzeug.test.TestResponse\n\nCall `open()` with `method` set to `PUT`.\n\nwerkzeug.test.TestResponse\n\nCall `open()` with `method` set to `DELETE`.\n\nwerkzeug.test.TestResponse\n\nCall `open()` with `method` set to `PATCH`.\n\nwerkzeug.test.TestResponse\n\nCall `open()` with `method` set to `OPTIONS`.\n\nwerkzeug.test.TestResponse\n\nCall `open()` with `method` set to `HEAD`.\n\nwerkzeug.test.TestResponse\n\nCall `open()` with `method` set to `TRACE`.\n\nwerkzeug.test.TestResponse\n\n`Response` subclass that provides extra information about requests made with\nthe test `Client`.\n\nTest client requests will always return an instance of this class. If a custom\nresponse class is passed to the client, it is subclassed along with this to\nsupport test information.\n\nIf the test request included large files, or if the application is serving a\nfile, call `close()` to close any open files and prevent Python showing a\n`ResourceWarning`.\n\nNone\n\nA request object with the environ used to make the request that resulted in\nthis response.\n\nA list of intermediate responses. Populated when the test request is made with\n`follow_redirects` enabled.\n\nThis class can be used to conveniently create a WSGI environment for testing\npurposes. It can be used to quickly create WSGI environments or request\nobjects from arbitrary data.\n\nThe signature of this class is also used in some other places as of Werkzeug\n0.5 (`create_environ()`, `Response.from_values()`, `Client.open()`). Because\nof this most of the functionality is available through the constructor alone.\n\nFiles and regular form data can be manipulated independently of each other\nwith the `form` and `files` attributes, but are passed with the same argument\nto the constructor: `data`.\n\n`data` can be any of these values:\n\na `dict` or `MultiDict`: The keys have to be strings. The values have to be\neither any of the following objects, or a list of any of the following\nobjects:\n\nNone\n\nChanged in version 2.0: `REQUEST_URI` and `RAW_URI` is the full raw URI\nincluding the query string, not only the path.\n\nChanged in version 2.0: The default `request_class` is `Request` instead of\n`BaseRequest`.\n\nNew in version 2.0: Added the `auth` parameter.\n\nNew in version 0.15: The `json` param and `json_dumps()` method.\n\nNew in version 0.15: The environ has keys `REQUEST_URI` and `RAW_URI`\ncontaining the path before perecent-decoding. This is not part of the WSGI\nPEP, but many WSGI servers include it.\n\nChanged in version 0.6: `path` and `base_url` can now be unicode strings that\nare encoded with `iri_to_uri()`.\n\nthe server protocol to use. defaults to HTTP/1.1\n\nthe wsgi version to use. defaults to (1, 0)\n\nalias of `werkzeug.wrappers.request.Request`\n\nThe serialization function used when `json` is passed.\n\nTurn an environ dict back into a builder. Any extra kwargs override the args\nextracted from the environ.\n\nChanged in version 2.0: Path and query values are passed through the WSGI\ndecoding dance to avoid double encoding.\n\nNew in version 0.15.\n\nEnvironBuilder\n\nThe base URL is used to extract the URL scheme, host name, port, and root\npath.\n\nThe content type for the request. Reflected from and to the `headers`. Do not\nset if you set `files` or `form` for auto detection.\n\nThe mimetype (content type without charset etc.)\n\nNew in version 0.14.\n\nThe mimetype parameters as dict. For example if the content type is\n`text/html; charset=utf-8` the params would be `{'charset': 'utf-8'}`.\n\nNew in version 0.14.\n\nThe content length as integer. Reflected from and to the `headers`. Do not set\nif you set `files` or `form` for auto detection.\n\nA `MultiDict` of form values.\n\nA `FileMultiDict` of uploaded files. Use `add_file()` to add new files.\n\nAn optional input stream. This is mutually exclusive with setting `form` and\n`files`, setting it will clear those. Do not provide this if the method is not\n`POST` or another method that has a body.\n\nThe query string. If you set this to a string `args` will no longer be\navailable.\n\nThe URL arguments as `MultiDict`.\n\nThe server name (read-only, use `host` to set)\n\nThe server port as integer (read-only, use `host` to set)\n\nCloses all files. If you put real `file` objects into the `files` dict you can\ncall this method to automatically close them all in one go.\n\nNone\n\nReturn the built environ.\n\nChanged in version 0.15: The content type and length headers are set based on\ninput stream detection. Previously this only set the WSGI keys.\n\nWSGIEnvironment\n\nReturns a request with the data. If the request class is not specified\n`request_class` is used.\n\ncls (Optional[Type[werkzeug.wrappers.request.Request]]) \u2013 The request wrapper\nto use.\n\nwerkzeug.wrappers.request.Request\n\nCreate a new WSGI environ dict based on the values passed. The first parameter\nshould be the path of the request which defaults to \u2018/\u2019. The second one can\neither be an absolute path (in that case the host is localhost:80) or a full\npath to the request with scheme, netloc port and the path to the script.\n\nThis accepts the same arguments as the `EnvironBuilder` constructor.\n\nChanged in version 0.5: This function is now a thin wrapper over\n`EnvironBuilder` which was added in 0.5. The `headers`, `environ_base`,\n`environ_overrides` and `charset` parameters were added.\n\nWSGIEnvironment\n\nReturn a tuple in the form (app_iter, status, headers) of the application\noutput. This works best if you pass it an application that returns an iterator\nall the time.\n\nSometimes applications may use the `write()` callable returned by the\n`start_response` function. This tries to resolve such edge cases\nautomatically. But if you don\u2019t get the expected output you should set\n`buffered` to `True` which enforces buffering.\n\nIf passed an invalid WSGI application the behavior of this function is\nundefined. Never pass non-conforming WSGI applications to this function.\n\ntuple in the form `(app_iter, status, headers)`\n\nTuple[Iterable[bytes], str, werkzeug.datastructures.Headers]\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "TestResponse", "path": "test/index#werkzeug.test.TestResponse", "type": "werkzeug.test", "text": "\n`Response` subclass that provides extra information about requests made with\nthe test `Client`.\n\nTest client requests will always return an instance of this class. If a custom\nresponse class is passed to the client, it is subclassed along with this to\nsupport test information.\n\nIf the test request included large files, or if the application is serving a\nfile, call `close()` to close any open files and prevent Python showing a\n`ResourceWarning`.\n\nNone\n\nA request object with the environ used to make the request that resulted in\nthis response.\n\nA list of intermediate responses. Populated when the test request is made with\n`follow_redirects` enabled.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "TestResponse.history", "path": "test/index#werkzeug.test.TestResponse.history", "type": "werkzeug.test", "text": "\nA list of intermediate responses. Populated when the test request is made with\n`follow_redirects` enabled.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "TestResponse.request", "path": "test/index#werkzeug.test.TestResponse.request", "type": "werkzeug.test", "text": "\nA request object with the environ used to make the request that resulted in\nthis response.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "test_app()", "path": "wsgi/index#werkzeug.testapp.test_app", "type": "werkzeug.testapp", "text": "\nSimple test application that dumps the environment. You can use it to check if\nWerkzeug is working properly:\n\nThe application displays important information from the WSGI environment, the\nPython interpreter and the installed libraries.\n\nIterable[bytes]\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "TypeConversionDict", "path": "datastructures/index#werkzeug.datastructures.TypeConversionDict", "type": "werkzeug.datastructures", "text": "\nWorks like a regular dict but the `get()` method can perform type conversions.\n`MultiDict` and `CombinedMultiDict` are subclasses of this class and provide\nthe same feature.\n\nNew in version 0.5.\n\nReturn the default value if the requested data doesn\u2019t exist. If `type` is\nprovided and is a callable it should convert the value, return it or raise a\n`ValueError` if that is not possible. In this case the function will return\nthe default as if the value was not found:\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "TypeConversionDict.get()", "path": "datastructures/index#werkzeug.datastructures.TypeConversionDict.get", "type": "werkzeug.datastructures", "text": "\nReturn the default value if the requested data doesn\u2019t exist. If `type` is\nprovided and is a callable it should convert the value, return it or raise a\n`ValueError` if that is not possible. In this case the function will return\nthe default as if the value was not found:\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "unescape()", "path": "utils/index#werkzeug.utils.unescape", "type": "werkzeug.utils", "text": "\nThe reverse of `escape()`. This unescapes all the HTML entities, not only\nthose inserted by `escape`.\n\nDeprecated since version 2.0: Will be removed in Werkzeug 2.1. Use MarkupSafe\ninstead.\n\ns (str) \u2013\n\nstr\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Unicode", "path": "unicode/index", "type": "Other", "text": "\nWerkzeug uses strings internally everwhere text data is assumed, even if the\nHTTP standard is not Unicode aware. Basically all incoming data is decoded\nfrom the charset (UTF-8 by default) so that you don\u2019t work with bytes\ndirectly. Outgoing data is encoded into the target charset.\n\nImagine you have the German Umlaut `\u00f6`. In ASCII you cannot represent that\ncharacter, but in the `latin-1` and `utf-8` character sets you can represent\nit, but they look different when encoded:\n\nAn `\u00f6` looks different depending on the encoding which makes it hard to work\nwith it as bytes. Instead, Python treats strings as Unicode text and stores\nthe information `LATIN SMALL LETTER O WITH DIAERESIS` instead of the bytes for\n`\u00f6` in a specific encoding. The length of a string with 1 character will be 1,\nwhere the length of the bytes might be some other value.\n\nHowever, the HTTP spec was written in a time where ASCII bytes were the common\nway data was represented. To work around this for the modern web, Werkzeug\ndecodes and encodes incoming and outgoing data automatically. Data sent from\nthe browser to the web application is decoded from UTF-8 bytes into a string.\nData sent from the application back to the browser is encoded back to UTF-8.\n\nFunctions that do internal encoding or decoding accept an `errors` keyword\nargument that is passed to `str.decode()` and `str.encode()`. The default is\n`'replace'` so that errors are easy to spot. It might be useful to set it to\n`'strict'` in order to catch the error and report the bad data to the client.\n\nIn most cases, you should stick with Werkzeug\u2019s default encoding of UTF-8. If\nyou have a specific reason to, you can subclass `wrappers.Request` and\n`wrappers.Response` to change the encoding and error handling.\n\nThe error handling can only be changed for the request. Werkzeug will always\nraise errors when encoding to bytes in the response. It\u2019s your responsibility\nto not create data that is not present in the target charset. This is not an\nissue for UTF-8.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "UnicodeConverter", "path": "routing/index#werkzeug.routing.UnicodeConverter", "type": "werkzeug.routing", "text": "\nThis converter is the default converter and accepts any string but only one\npath segment. Thus the string can not include a slash.\n\nThis is the default validator.\n\nExample:\n\nNone\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "unquote_etag()", "path": "http/index#werkzeug.http.unquote_etag", "type": "werkzeug.http", "text": "\nUnquote a single etag:\n\netag (Optional[str]) \u2013 the etag identifier to unquote.\n\na `(etag, weak)` tuple.\n\nUnion[Tuple[str, bool], Tuple[None, None]]\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "unquote_header_value()", "path": "http/index#werkzeug.http.unquote_header_value", "type": "werkzeug.http", "text": "\nUnquotes a header value. (Reversal of `quote_header_value()`). This does not\nuse the real unquoting but what browsers are actually using for quoting.\n\nNew in version 0.5.\n\nstr\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "uri_to_iri()", "path": "urls/index#werkzeug.urls.uri_to_iri", "type": "werkzeug.urls", "text": "\nConvert a URI to an IRI. All valid UTF-8 characters are unquoted, leaving all\nreserved and invalid characters quoted. If the URL has a domain, it is decoded\nfrom Punycode.\n\nstr\n\nChanged in version 0.15: All reserved and invalid characters remain quoted.\nPreviously, only some reserved characters were preserved, and invalid bytes\nwere replaced instead of left quoted.\n\nNew in version 0.6.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "URL", "path": "urls/index#werkzeug.urls.URL", "type": "werkzeug.urls", "text": "\nRepresents a parsed URL. This behaves like a regular tuple but also has some\nextra attributes that give further insight into the URL.\n\nCreate new instance of _URLTuple(scheme, netloc, path, query, fragment)\n\nEncodes the URL to a tuple made out of bytes. The charset is only being used\nfor the path, query and fragment.\n\nwerkzeug.urls.BytesURL\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "URL Helpers", "path": "urls/index", "type": "Other", "text": "\nFunctions for working with URLs.\n\nContains implementations of functions from `urllib.parse` that handle bytes\nand strings.\n\nSuperclass of `URL` and `BytesURL`.\n\nCreate new instance of _URLTuple(scheme, netloc, path, query, fragment)\n\nWorks exactly like `host` but will return a result that is restricted to\nASCII. If it finds a netloc that is not ASCII it will attempt to idna decode\nit. This is useful for socket operations when the URL might include\ninternationalized characters.\n\nThe authentication part in the URL if available, `None` otherwise.\n\nDecodes the netloc part into a string.\n\nstr\n\nDecodes the query part of the URL. Ths is a shortcut for calling\n`url_decode()` on the query argument. The arguments and keyword arguments are\nforwarded to `url_decode()` unchanged.\n\nds.MultiDict[str, str]\n\nEncodes the netloc part to an ASCII safe URL as bytes.\n\nstr\n\nReturns a tuple with the location of the file in the form `(server,\nlocation)`. If the netloc is empty in the URL or points to localhost, it\u2019s\nrepresented as `None`.\n\nThe `pathformat` by default is autodetection but needs to be set when working\nwith URLs of a specific system. The supported values are `'windows'` when\nworking with Windows or DOS paths and `'posix'` when working with posix paths.\n\nIf the URL does not point to a local file, the server and location are both\nrepresented as `None`.\n\npathformat (Optional[str]) \u2013 The expected format of the path component.\nCurrently `'windows'` and `'posix'` are supported. Defaults to `None` which is\nautodetect.\n\nTuple[Optional[str], Optional[str]]\n\nThe host part of the URL if available, otherwise `None`. The host is either\nthe hostname or the IP address mentioned in the URL. It will not contain the\nport.\n\nJoins this URL with another one. This is just a convenience function for\ncalling into `url_join()` and then parsing the return value again.\n\nwerkzeug.urls.BaseURL\n\nThe password if it was part of the URL, `None` otherwise. This undergoes URL\ndecoding and will always be a string.\n\nThe port in the URL as an integer if it was present, `None` otherwise. This\ndoes not fill in default ports.\n\nThe password if it was part of the URL, `None` otherwise. Unlike `password`\nthis one is not being decoded.\n\nThe username if it was part of the URL, `None` otherwise. Unlike `username`\nthis one is not being decoded.\n\nReturn an URL with the same values, except for those parameters given new\nvalues by whichever keyword arguments are specified.\n\nkwargs (Any) \u2013\n\nwerkzeug.urls.BaseURL\n\nReturns a `URL` tuple that holds a IRI. This will try to decode as much\ninformation as possible in the URL without losing information similar to how a\nweb browser does it for the URL bar.\n\nIt\u2019s usually more interesting to directly call `uri_to_iri()` which will\nreturn a string.\n\nwerkzeug.urls.BaseURL\n\nReturns a `BytesURL` tuple that holds a URI. This will encode all the\ninformation in the URL properly to ASCII using the rules a web browser would\nfollow.\n\nIt\u2019s usually more interesting to directly call `iri_to_uri()` which will\nreturn a string.\n\nwerkzeug.urls.BaseURL\n\nReturns a URL string or bytes depending on the type of the information stored.\nThis is just a convenience function for calling `url_unparse()` for this URL.\n\nstr\n\nThe username if it was part of the URL, `None` otherwise. This undergoes URL\ndecoding and will always be a string.\n\nRepresents a parsed URL in bytes.\n\nCreate new instance of _URLTuple(scheme, netloc, path, query, fragment)\n\nDecodes the URL to a tuple made out of strings. The charset is only being used\nfor the path, query and fragment.\n\nwerkzeug.urls.URL\n\nReturns the netloc unchanged as bytes.\n\nbytes\n\nImplements a callable that constructs URLs with the given base. The function\ncan be called with any number of positional and keyword arguments which than\nare used to assemble the URL. Works with URLs and posix paths.\n\nPositional arguments are appended as individual segments to the path of the\nURL:\n\nIf any of the arguments (positional or keyword) evaluates to `None` it will be\nskipped. If no keyword arguments are given the last argument can be a `dict`\nor `MultiDict` (or any other dict subclass), otherwise the keyword arguments\nare used for the query parameters, cutting off the first trailing underscore\nof the parameter name:\n\nCombining of both methods is not allowed:\n\nAccessing attributes on the href object creates a new href object with the\nattribute name as prefix:\n\nIf `sort` is set to `True` the items are sorted by `key` or the default\nsorting algorithm:\n\nDeprecated since version 2.0: Will be removed in Werkzeug 2.1. Use\n`werkzeug.routing` instead.\n\nNew in version 0.5: `sort` and `key` were added.\n\nRepresents a parsed URL. This behaves like a regular tuple but also has some\nextra attributes that give further insight into the URL.\n\nCreate new instance of _URLTuple(scheme, netloc, path, query, fragment)\n\nEncodes the URL to a tuple made out of bytes. The charset is only being used\nfor the path, query and fragment.\n\nwerkzeug.urls.BytesURL\n\nConvert an IRI to a URI. All non-ASCII and unsafe characters are quoted. If\nthe URL has a domain, it is encoded to Punycode.\n\nstr\n\nThere is a general problem with IRI conversion with some protocols that are in\nviolation of the URI specification. Consider the following two IRIs:\n\nAfter parsing, we don\u2019t know if the scheme requires the `//`, which is dropped\nif empty, but conveys different meanings in the final URL if it\u2019s present or\nnot. In this case, you can use `safe_conversion`, which will return the URL\nunchanged if it only contains ASCII characters and no whitespace. This can\nresult in a URI with unquoted characters if it was not already quoted\ncorrectly, but preserves the URL\u2019s semantics. Werkzeug uses this for the\n`Location` header for redirects.\n\nChanged in version 0.15: All reserved characters remain unquoted. Previously,\nonly some reserved characters were left unquoted.\n\nChanged in version 0.9.6: The `safe_conversion` parameter was added.\n\nNew in version 0.6.\n\nConvert a URI to an IRI. All valid UTF-8 characters are unquoted, leaving all\nreserved and invalid characters quoted. If the URL has a domain, it is decoded\nfrom Punycode.\n\nstr\n\nChanged in version 0.15: All reserved and invalid characters remain quoted.\nPreviously, only some reserved characters were preserved, and invalid bytes\nwere replaced instead of left quoted.\n\nNew in version 0.6.\n\nParse a query string and return it as a `MultiDict`.\n\nds.MultiDict[str, str]\n\nChanged in version 2.0: The `decode_keys` parameter is deprecated and will be\nremoved in Werkzeug 2.1.\n\nChanged in version 0.5: In previous versions \u201c;\u201d and \u201c&\u201d could be used for url\ndecoding. Now only \u201c&\u201d is supported. If you want to use \u201c;\u201d, a different\n`separator` can be provided.\n\nChanged in version 0.5: The `cls` parameter was added.\n\nWorks like `url_decode()` but decodes a stream. The behavior of stream and\nlimit follows functions like `make_line_iter()`. The generator of pairs is\ndirectly fed to the `cls` so you can consume the data while it\u2019s parsed.\n\nds.MultiDict[str, str]\n\nChanged in version 2.0: The `decode_keys` and `return_iterator` parameters are\ndeprecated and will be removed in Werkzeug 2.1.\n\nNew in version 0.8.\n\nURL encode a dict/`MultiDict`. If a value is `None` it will not appear in the\nresult string. Per default only values are encoded into the target charset\nstrings.\n\nstr\n\nChanged in version 2.0: The `encode_keys` parameter is deprecated and will be\nremoved in Werkzeug 2.1.\n\nChanged in version 0.5: Added the `sort`, `key`, and `separator` parameters.\n\nLike `url_encode()` but writes the results to a stream object. If the stream\nis `None` a generator over all encoded pairs is returned.\n\nNone\n\nChanged in version 2.0: The `encode_keys` parameter is deprecated and will be\nremoved in Werkzeug 2.1.\n\nNew in version 0.8.\n\nSometimes you get an URL by a user that just isn\u2019t a real URL because it\ncontains unsafe characters like \u2018 \u2018 and so on. This function can fix some of\nthe problems in a similar way browsers handle data entered by the user:\n\nstr\n\nJoin a base URL and a possibly relative URL to form an absolute interpretation\nof the latter.\n\nstr\n\nParses a URL from a string into a `URL` tuple. If the URL is lacking a scheme\nit can be provided as second argument. Otherwise, it is ignored. Optionally\nfragments can be stripped from the URL by setting `allow_fragments` to\n`False`.\n\nThe inverse of this function is `url_unparse()`.\n\nwerkzeug.urls.BaseURL\n\nURL encode a single string with a given encoding.\n\nstr\n\nNew in version 0.9.2: The `unsafe` parameter was added.\n\nURL encode a single string with the given encoding and convert whitespace to\n\u201c+\u201d.\n\nstr\n\nThe reverse operation to `url_parse()`. This accepts arbitrary as well as\n`URL` tuples and returns a URL as a string.\n\ncomponents (Tuple[str, str, str, str, str]) \u2013 the parsed URL as tuple which\nshould be converted into a URL string.\n\nstr\n\nURL decode a single string with a given encoding. If the charset is set to\n`None` no decoding is performed and raw bytes are returned.\n\nstr\n\nURL decode a single string with the given `charset` and decode \u201c+\u201d to\nwhitespace.\n\nPer default encoding errors are ignored. If you want a different behavior you\ncan set `errors` to `'replace'` or `'strict'`.\n\nstr\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "URL Routing", "path": "routing/index", "type": "Other", "text": "\nWhen it comes to combining multiple controller or view functions (however you\nwant to call them), you need a dispatcher. A simple way would be applying\nregular expression tests on `PATH_INFO` and call registered callback functions\nthat return the value.\n\nWerkzeug provides a much more powerful system, similar to Routes. All the\nobjects mentioned on this page must be imported from `werkzeug.routing`, not\nfrom `werkzeug`!\n\nHere is a simple example which could be the URL definition for a blog:\n\nSo what does that do? First of all we create a new `Map` which stores a bunch\nof URL rules. Then we pass it a list of `Rule` objects.\n\nEach `Rule` object is instantiated with a string that represents a rule and an\nendpoint which will be the alias for what view the rule represents. Multiple\nrules can have the same endpoint, but should have different arguments to allow\nURL construction.\n\nThe format for the URL rules is straightforward, but explained in detail\nbelow.\n\nInside the WSGI application we bind the url_map to the current request which\nwill return a new `MapAdapter`. This url_map adapter can then be used to match\nor build domains for the current request.\n\nThe `MapAdapter.match()` method can then either return a tuple in the form\n`(endpoint, args)` or raise one of the three exceptions `NotFound`,\n`MethodNotAllowed`, or `RequestRedirect`. For more details about those\nexceptions have a look at the documentation of the `MapAdapter.match()`\nmethod.\n\nRule strings are URL paths with placeholders for variable parts in the format\n`<converter(arguments):name>`. `converter` and `arguments` (with parentheses)\nare optional. If no converter is given, the `default` converter is used\n(`string` by default). The available converters are discussed below.\n\nRules that end with a slash are \u201cbranches\u201d, others are \u201cleaves\u201d. If\n`strict_slashes` is enabled (the default), visiting a branch URL without a\ntrailing slash will redirect to the URL with a slash appended.\n\nMany HTTP servers merge consecutive slashes into one when receiving requests.\nIf `merge_slashes` is enabled (the default), rules will merge slashes in non-\nvariable parts when matching and building. Visiting a URL with consecutive\nslashes will redirect to the URL with slashes merged. If you want to disable\n`merge_slashes` for a `Rule` or `Map`, you\u2019ll also need to configure your web\nserver appropriately.\n\nConverters for common types of URL variables are built-in. The available\nconverters can be overridden or extended through `Map.converters`.\n\nThis converter is the default converter and accepts any string but only one\npath segment. Thus the string can not include a slash.\n\nThis is the default validator.\n\nExample:\n\nNone\n\nLike the default `UnicodeConverter`, but it also matches slashes. This is\nuseful for wikis and similar applications:\n\nNone\n\nMatches one of the items provided. Items can either be Python identifiers or\nstrings:\n\nNone\n\nThis converter only accepts integer values:\n\nBy default it only accepts unsigned, positive values. The `signed` parameter\nwill enable signed, negative values.\n\nNone\n\nNew in version 0.15: The `signed` parameter.\n\nThis converter only accepts floating point values:\n\nBy default it only accepts unsigned, positive values. The `signed` parameter\nwill enable signed, negative values.\n\nNone\n\nNew in version 0.15: The `signed` parameter.\n\nThis converter only accepts UUID strings:\n\nNew in version 0.10.\n\nNone\n\nThe map class stores all the URL rules and some configuration parameters. Some\nof the configuration values are only stored on the `Map` instance since those\naffect all rules, others are just defaults and can be overridden for each\nrule. Note that you have to specify all arguments besides the `rules` as\nkeyword arguments!\n\nNone\n\nChanged in version 1.0: If `url_scheme` is `ws` or `wss`, only WebSocket rules\nwill match.\n\nChanged in version 1.0: Added `merge_slashes`.\n\nChanged in version 0.7: Added `encoding_errors` and `host_matching`.\n\nChanged in version 0.5: Added `sort_parameters` and `sort_key`.\n\nThe dictionary of converters. This can be modified after the class was\ncreated, but will only affect rules added after the modification. If the rules\nare defined with the list passed to the class, the `converters` parameter to\nthe constructor has to be used instead.\n\nAdd a new rule or factory to the map and bind it. Requires that the rule is\nnot bound to another map.\n\nrulefactory (werkzeug.routing.RuleFactory) \u2013 a `Rule` or `RuleFactory`\n\nNone\n\nReturn a new `MapAdapter` with the details specified to the call. Note that\n`script_name` will default to `'/'` if not further specified or `None`. The\n`server_name` at least is a requirement because the HTTP RFC requires absolute\nURLs for redirects and so all redirect exceptions raised by Werkzeug will\ncontain the full canonical URL.\n\nIf no path_info is passed to `match()` it will use the default path info\npassed to bind. While this doesn\u2019t really make sense for manual bind calls,\nit\u2019s useful if you bind a map to a WSGI environment which already contains the\npath info.\n\n`subdomain` will default to the `default_subdomain` for this map if no\ndefined. If there is no `default_subdomain` you cannot use the subdomain\nfeature.\n\nChanged in version 1.0: If `url_scheme` is `ws` or `wss`, only WebSocket rules\nwill match.\n\nChanged in version 0.15: `path_info` defaults to `'/'` if `None`.\n\nChanged in version 0.8: `query_args` can be a string.\n\nChanged in version 0.7: Added `query_args`.\n\nwerkzeug.routing.MapAdapter\n\nLike `bind()` but you can pass it an WSGI environment and it will fetch the\ninformation from that dictionary. Note that because of limitations in the\nprotocol there is no way to get the current subdomain and real `server_name`\nfrom the environment. If you don\u2019t provide it, Werkzeug will use `SERVER_NAME`\nand `SERVER_PORT` (or `HTTP_HOST` if provided) as used `server_name` with\ndisabled subdomain feature.\n\nIf `subdomain` is `None` but an environment and a server name is provided it\nwill calculate the current subdomain automatically. Example: `server_name` is\n`'example.com'` and the `SERVER_NAME` in the wsgi `environ` is\n`'staging.dev.example.com'` the calculated subdomain will be `'staging.dev'`.\n\nIf the object passed as environ has an environ attribute, the value of this\nattribute is used instead. This allows you to pass request objects.\nAdditionally `PATH_INFO` added as a default of the `MapAdapter` so that you\ndon\u2019t have to pass the path info to the match method.\n\nChanged in version 1.0.0: If the passed server name specifies port 443, it\nwill match if the incoming scheme is `https` without a port.\n\nChanged in version 1.0.0: A warning is shown when the passed server name does\nnot match the incoming WSGI server name.\n\nChanged in version 0.8: This will no longer raise a ValueError when an\nunexpected server name was passed.\n\nChanged in version 0.5: previously this method accepted a bogus\n`calculate_subdomain` parameter that did not have any effect. It was removed\nbecause of that.\n\nMapAdapter\n\nA dict of default converters to be used.\n\nIterate over all rules and check if the endpoint expects the arguments\nprovided. This is for example useful if you have some URLs that expect a\nlanguage code and others that do not and you want to wrap the builder a bit so\nthat the current language code is automatically added if not provided but\nendpoints expect it.\n\nbool\n\nIterate over all rules or the rules of an endpoint.\n\nendpoint (Optional[str]) \u2013 if provided only the rules for that endpoint are\nreturned.\n\nan iterator\n\nIterator[werkzeug.routing.Rule]\n\nThe type of lock to use when updating.\n\nNew in version 1.0.\n\nCalled before matching and building to keep the compiled rules in the correct\norder after things changed.\n\nNone\n\nReturned by `Map.bind()` or `Map.bind_to_environ()` and does the URL matching\nand building based on runtime information.\n\nReturns the valid methods that match for a given path.\n\nNew in version 0.7.\n\npath_info (Optional[str]) \u2013\n\nIterable[str]\n\nBuilding URLs works pretty much the other way round. Instead of `match` you\ncall `build` and pass it the endpoint and a dict of arguments for the\nplaceholders.\n\nThe `build` function also accepts an argument called `force_external` which,\nif you set it to `True` will force external URLs. Per default external URLs\n(include the server name) will only be used if the target URL is on a\ndifferent subdomain.\n\nBecause URLs cannot contain non ASCII data you will always get bytes back. Non\nASCII characters are urlencoded with the charset defined on the map instance.\n\nAdditional values are converted to strings and appended to the URL as URL\nquerystring parameters:\n\nWhen processing those additional values, lists are furthermore interpreted as\nmultiple values (as per `werkzeug.datastructures.MultiDict`):\n\nPassing a `MultiDict` will also add multiple values:\n\nIf a rule does not exist when building a `BuildError` exception is raised.\n\nThe build method accepts an argument called `method` which allows you to\nspecify the method you want to have an URL built for if you have different\nmethods for the same endpoint specified.\n\nstr\n\nChanged in version 2.0: Added the `url_scheme` parameter.\n\nNew in version 0.6: Added the `append_unknown` parameter.\n\nDoes the complete dispatching process. `view_func` is called with the endpoint\nand a dict with the values for the view. It should look up the view function,\ncall it, and return a response object or WSGI application. http exceptions are\nnot caught by default so that applications can display nicer error messages by\njust catching them by hand. If you want to stick with the default error\nmessages you can pass it `catch_http_exceptions=True` and it will catch the\nhttp exceptions.\n\nHere a small example for the dispatch usage:\n\nKeep in mind that this method might return exception objects, too, so use\n`Response.force_type` to get a response object.\n\nWSGIApplication\n\nFigures out the full host name for the given domain part. The domain part is a\nsubdomain in case host matching is disabled or a full host name.\n\ndomain_part (Optional[str]) \u2013\n\nstr\n\nInternally called to make an alias redirect URL.\n\nstr\n\nThe usage is simple: you just pass the match method the current path info as\nwell as the method (which defaults to `GET`). The following things can then\nhappen:\n\nIf the path info is not passed to the match method the default path info of\nthe map is used (defaults to the root URL if not defined explicitly).\n\nAll of the exceptions raised are subclasses of `HTTPException` so they can be\nused as WSGI responses. They will all render generic error or redirect pages.\n\nHere is a small example for matching:\n\nAnd here is what happens on redirect and missing URLs:\n\nTuple[Union[str, werkzeug.routing.Rule], Mapping[str, Any]]\n\nNew in version 1.0: Added `websocket`.\n\nChanged in version 0.8: `query_args` can be a string.\n\nNew in version 0.7: Added `query_args`.\n\nNew in version 0.6: Added `return_rule`.\n\nTest if a rule would match. Works like `match` but returns `True` if the URL\nmatches, or `False` if it does not exist.\n\nbool\n\nA Rule represents one URL pattern. There are some options for `Rule` that\nchange the way it behaves and are passed to the `Rule` constructor. Note that\nbesides the rule-string all arguments must be keyword arguments in order to\nnot break the application on Werkzeug upgrades.\n\nRule strings basically are just normal URL paths with placeholders in the\nformat `<converter(arguments):name>` where the converter and the arguments are\noptional. If no converter is defined the `default` converter is used which\nmeans `string` in the normal configuration.\n\nURL rules that end with a slash are branch URLs, others are leaves. If you\nhave `strict_slashes` enabled (which is the default), all branch URLs that are\nmatched without a trailing slash will trigger a redirect to the same URL with\nthe missing slash appended.\n\nThe converters are defined on the `Map`.\n\nThe endpoint for this rule. This can be anything. A reference to a function, a\nstring, a number etc. The preferred way is using a string because the endpoint\nis used for URL generation.\n\nAn optional dict with defaults for other rules with the same endpoint. This is\na bit tricky but useful if you want to have unique URLs:\n\nIf a user now visits `http://example.com/all/page/1` he will be redirected to\n`http://example.com/all/`. If `redirect_defaults` is disabled on the `Map`\ninstance this will only affect the URL generation.\n\nThe subdomain rule string for this rule. If not specified the rule only\nmatches for the `default_subdomain` of the map. If the map is not bound to a\nsubdomain this feature is disabled.\n\nCan be useful if you want to have user profiles on different subdomains and\nall subdomains are forwarded to your application:\n\nA sequence of http methods this rule applies to. If not specified, all methods\nare allowed. For example this can be useful if you want different endpoints\nfor `POST` and `GET`. If methods are defined and the path matches but the\nmethod matched against is not in this list or in the list of another rule for\nthat path the error raised is of the type `MethodNotAllowed` rather than\n`NotFound`. If `GET` is present in the list of methods and `HEAD` is not,\n`HEAD` is added automatically.\n\nOverride the `Map` setting for `strict_slashes` only for this rule. If not\nspecified the `Map` setting is used.\n\nOverride `Map.merge_slashes` for this rule.\n\nSet this to True and the rule will never match but will create a URL that can\nbe build. This is useful if you have resources on a subdomain or folder that\nare not handled by the WSGI application (like static data)\n\nIf given this must be either a string or callable. In case of a callable it\u2019s\ncalled with the url adapter that triggered the match and the values of the URL\nas keyword arguments and has to return the target for the redirect, otherwise\nit has to be a string with placeholders in rule syntax:\n\nWhen the rule is matched the routing system will raise a `RequestRedirect`\nexception with the target for the redirect.\n\nKeep in mind that the URL will be joined against the URL root of the script so\ndon\u2019t use a leading slash on the target URL unless you really mean root of\nthat domain.\n\nIf enabled this rule serves as an alias for another rule with the same\nendpoint and arguments.\n\nIf provided and the URL map has host matching enabled this can be used to\nprovide a match rule for the whole host. This also means that the subdomain\nfeature is disabled.\n\nIf `True`, this rule is only matches for WebSocket (`ws://`, `wss://`)\nrequests. By default, rules will only match for HTTP requests.\n\nNew in version 1.0: Added `websocket`.\n\nNew in version 1.0: Added `merge_slashes`.\n\nNew in version 0.7: Added `alias` and `host`.\n\nChanged in version 0.6.1: `HEAD` is added to `methods` if `GET` is present.\n\nNone\n\nReturn an unbound copy of this rule.\n\nThis can be useful if want to reuse an already bound URL for another map. See\n`get_empty_kwargs` to override what keyword arguments are provided to the new\ncopy.\n\nwerkzeug.routing.Rule\n\nAs soon as you have more complex URL setups it\u2019s a good idea to use rule\nfactories to avoid repetitive tasks. Some of them are builtin, others can be\nadded by subclassing `RuleFactory` and overriding `get_rules`.\n\nSubclasses of `RuleFactory` have to override this method and return an\niterable of rules.\n\nmap (werkzeug.routing.Map) \u2013\n\nIterable[werkzeug.routing.Rule]\n\nAll URLs provided by this factory have the subdomain set to a specific domain.\nFor example if you want to use the subdomain for the current language this can\nbe a good setup:\n\nAll the rules except for the `'#select_language'` endpoint will now listen on\na two letter long subdomain that holds the language code for the current\nrequest.\n\nNone\n\nLike `Subdomain` but prefixes the URL rule with a given string:\n\nNow the rule `'blog/show'` matches `/blog/entry/<entry_slug>`.\n\nNone\n\nPrefixes all endpoints (which must be strings for this factory) with another\nstring. This can be useful for sub applications:\n\nNone\n\nReturns copies of the rules wrapped and expands string templates in the\nendpoint, rule, defaults or subdomain sections.\n\nHere a small example for such a rule template:\n\nWhen a rule template is called the keyword arguments are used to replace the\nplaceholders in all the string parameters.\n\nrules (Iterable[Rule]) \u2013\n\nNone\n\nYou can add custom converters that add behaviors not provided by the built-in\nconverters. To make a custom converter, subclass `BaseConverter` then pass the\nnew class to the `Map` `converters` parameter, or add it to\n`url_map.converters`.\n\nThe converter should have a `regex` attribute with a regular expression to\nmatch with. If the converter can take arguments in a URL rule, it should\naccept them in its `__init__` method.\n\nIt can implement a `to_python` method to convert the matched string to some\nother object. This can also do extra validation that wasn\u2019t possible with the\n`regex` attribute, and should raise a `werkzeug.routing.ValidationError` in\nthat case. Raising any other errors will cause a 500 error.\n\nIt can implement a `to_url` method to convert a Python object to a string when\nbuilding a URL. Any error raised here will be converted to a\n`werkzeug.routing.BuildError` and eventually cause a 500 error.\n\nThis example implements a `BooleanConverter` that will match the strings\n`\"yes\"`, `\"no\"`, and `\"maybe\"`, returning a random value for `\"maybe\"`.\n\nIf you want to change the default converter, assign a different converter to\nthe `\"default\"` key.\n\nNew in version 0.7.\n\nStarting with Werkzeug 0.7 it\u2019s also possible to do matching on the whole host\nnames instead of just the subdomain. To enable this feature you need to pass\n`host_matching=True` to the `Map` constructor and provide the `host` argument\nto all routes:\n\nVariable parts are of course also possible in the host section:\n\nNew in version 1.0.\n\nIf a `Rule` is created with `websocket=True`, it will only match if the `Map`\nis bound to a request with a `url_scheme` of `ws` or `wss`.\n\nNote\n\nWerkzeug has no further WebSocket support beyond routing. This functionality\nis mostly of use to ASGI projects.\n\nIf the only match is a WebSocket rule and the bind is HTTP (or the only match\nis HTTP and the bind is WebSocket) a `WebsocketMismatch` (derives from\n`BadRequest`) exception is raised.\n\nAs WebSocket URLs have a different scheme, rules are always built with a\nscheme and host, `force_external=True` is implied.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "URL.encode()", "path": "urls/index#werkzeug.urls.URL.encode", "type": "werkzeug.urls", "text": "\nEncodes the URL to a tuple made out of bytes. The charset is only being used\nfor the path, query and fragment.\n\nwerkzeug.urls.BytesURL\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "url_decode()", "path": "urls/index#werkzeug.urls.url_decode", "type": "werkzeug.urls", "text": "\nParse a query string and return it as a `MultiDict`.\n\nds.MultiDict[str, str]\n\nChanged in version 2.0: The `decode_keys` parameter is deprecated and will be\nremoved in Werkzeug 2.1.\n\nChanged in version 0.5: In previous versions \u201c;\u201d and \u201c&\u201d could be used for url\ndecoding. Now only \u201c&\u201d is supported. If you want to use \u201c;\u201d, a different\n`separator` can be provided.\n\nChanged in version 0.5: The `cls` parameter was added.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "url_decode_stream()", "path": "urls/index#werkzeug.urls.url_decode_stream", "type": "werkzeug.urls", "text": "\nWorks like `url_decode()` but decodes a stream. The behavior of stream and\nlimit follows functions like `make_line_iter()`. The generator of pairs is\ndirectly fed to the `cls` so you can consume the data while it\u2019s parsed.\n\nds.MultiDict[str, str]\n\nChanged in version 2.0: The `decode_keys` and `return_iterator` parameters are\ndeprecated and will be removed in Werkzeug 2.1.\n\nNew in version 0.8.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "url_encode()", "path": "urls/index#werkzeug.urls.url_encode", "type": "werkzeug.urls", "text": "\nURL encode a dict/`MultiDict`. If a value is `None` it will not appear in the\nresult string. Per default only values are encoded into the target charset\nstrings.\n\nstr\n\nChanged in version 2.0: The `encode_keys` parameter is deprecated and will be\nremoved in Werkzeug 2.1.\n\nChanged in version 0.5: Added the `sort`, `key`, and `separator` parameters.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "url_encode_stream()", "path": "urls/index#werkzeug.urls.url_encode_stream", "type": "werkzeug.urls", "text": "\nLike `url_encode()` but writes the results to a stream object. If the stream\nis `None` a generator over all encoded pairs is returned.\n\nNone\n\nChanged in version 2.0: The `encode_keys` parameter is deprecated and will be\nremoved in Werkzeug 2.1.\n\nNew in version 0.8.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "url_fix()", "path": "urls/index#werkzeug.urls.url_fix", "type": "werkzeug.urls", "text": "\nSometimes you get an URL by a user that just isn\u2019t a real URL because it\ncontains unsafe characters like \u2018 \u2018 and so on. This function can fix some of\nthe problems in a similar way browsers handle data entered by the user:\n\nstr\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "url_join()", "path": "urls/index#werkzeug.urls.url_join", "type": "werkzeug.urls", "text": "\nJoin a base URL and a possibly relative URL to form an absolute interpretation\nof the latter.\n\nstr\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "url_parse()", "path": "urls/index#werkzeug.urls.url_parse", "type": "werkzeug.urls", "text": "\nParses a URL from a string into a `URL` tuple. If the URL is lacking a scheme\nit can be provided as second argument. Otherwise, it is ignored. Optionally\nfragments can be stripped from the URL by setting `allow_fragments` to\n`False`.\n\nThe inverse of this function is `url_unparse()`.\n\nwerkzeug.urls.BaseURL\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "url_quote()", "path": "urls/index#werkzeug.urls.url_quote", "type": "werkzeug.urls", "text": "\nURL encode a single string with a given encoding.\n\nstr\n\nNew in version 0.9.2: The `unsafe` parameter was added.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "url_quote_plus()", "path": "urls/index#werkzeug.urls.url_quote_plus", "type": "werkzeug.urls", "text": "\nURL encode a single string with the given encoding and convert whitespace to\n\u201c+\u201d.\n\nstr\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "url_unparse()", "path": "urls/index#werkzeug.urls.url_unparse", "type": "werkzeug.urls", "text": "\nThe reverse operation to `url_parse()`. This accepts arbitrary as well as\n`URL` tuples and returns a URL as a string.\n\ncomponents (Tuple[str, str, str, str, str]) \u2013 the parsed URL as tuple which\nshould be converted into a URL string.\n\nstr\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "url_unquote()", "path": "urls/index#werkzeug.urls.url_unquote", "type": "werkzeug.urls", "text": "\nURL decode a single string with a given encoding. If the charset is set to\n`None` no decoding is performed and raw bytes are returned.\n\nstr\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "url_unquote_plus()", "path": "urls/index#werkzeug.urls.url_unquote_plus", "type": "werkzeug.urls", "text": "\nURL decode a single string with the given `charset` and decode \u201c+\u201d to\nwhitespace.\n\nPer default encoding errors are ignored. If you want a different behavior you\ncan set `errors` to `'replace'` or `'strict'`.\n\nstr\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "UserAgent", "path": "utils/index#werkzeug.user_agent.UserAgent", "type": "werkzeug.user_agent", "text": "\nRepresents a parsed user agent header value.\n\nThe default implementation does no parsing, only the `string` attribute is\nset. A subclass may parse the string to set the common attributes or expose\nother information. Set `werkzeug.wrappers.Request.user_agent_class` to use a\nsubclass.\n\nstring (str) \u2013 The header value to parse.\n\nNone\n\nNew in version 2.0: This replaces the previous `useragents` module, but does\nnot provide a built-in parser.\n\nThe OS name, if it could be parsed from the string.\n\nThe browser name, if it could be parsed from the string.\n\nThe browser version, if it could be parsed from the string.\n\nThe browser language, if it could be parsed from the string.\n\nThe original header value.\n\nConvert to a header value.\n\nstr\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "UserAgent", "path": "utils/index#werkzeug.useragents.UserAgent", "type": "werkzeug.useragents", "text": "\nRepresents a parsed user agent header value.\n\nThis uses a basic parser to try to extract some information from the header.\n\nenviron_or_string (t.Union[str, WSGIEnvironment]) \u2013 The header value to parse,\nor a WSGI environ containing the header.\n\nNone\n\nDeprecated since version 2.0: Will be removed in Werkzeug 2.1. Subclass\n`werkzeug.user_agent.UserAgent` (note the new module name) to use a dedicated\nparser instead.\n\nChanged in version 2.0: Passing a WSGI environ is deprecated and will be\nremoved in 2.1.\n\nConvert to a header value.\n\nstr\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "UserAgent.browser", "path": "utils/index#werkzeug.user_agent.UserAgent.browser", "type": "werkzeug.user_agent", "text": "\nThe browser name, if it could be parsed from the string.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "UserAgent.language", "path": "utils/index#werkzeug.user_agent.UserAgent.language", "type": "werkzeug.user_agent", "text": "\nThe browser language, if it could be parsed from the string.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "UserAgent.platform", "path": "utils/index#werkzeug.user_agent.UserAgent.platform", "type": "werkzeug.user_agent", "text": "\nThe OS name, if it could be parsed from the string.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "UserAgent.string", "path": "utils/index#werkzeug.user_agent.UserAgent.string", "type": "werkzeug.user_agent", "text": "\nThe original header value.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "UserAgent.to_header()", "path": "utils/index#werkzeug.user_agent.UserAgent.to_header", "type": "werkzeug.user_agent", "text": "\nConvert to a header value.\n\nstr\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "UserAgent.to_header()", "path": "utils/index#werkzeug.useragents.UserAgent.to_header", "type": "werkzeug.useragents", "text": "\nConvert to a header value.\n\nstr\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "UserAgent.version", "path": "utils/index#werkzeug.user_agent.UserAgent.version", "type": "werkzeug.user_agent", "text": "\nThe browser version, if it could be parsed from the string.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Utilities", "path": "utils/index", "type": "Other", "text": "\nVarious utility functions shipped with Werkzeug.\n\nHelper object for HTML generation.\n\nPer default there are two instances of that class. The `html` one, and the\n`xhtml` one for those two dialects. The class uses keyword parameters and\npositional parameters to generate small snippets of HTML.\n\nKeyword parameters are converted to XML/SGML attributes, positional arguments\nare used as children. Because Python accepts positional arguments before\nkeyword arguments it\u2019s a good idea to use a list with the star-syntax for some\nchildren:\n\nThis class works around some browser limitations and can not be used for\narbitrary SGML/XML generation. For that purpose lxml and similar libraries\nexist.\n\nCalling the builder escapes the string passed:\n\nDeprecated since version 2.0: Will be removed in Werkzeug 2.1.\n\nReplace `&`, `<`, `>`, `\"`, and `'` with HTML-safe sequences.\n\n`None` is escaped to an empty string.\n\nDeprecated since version 2.0: Will be removed in Werkzeug 2.1. Use MarkupSafe\ninstead.\n\ns (Any) \u2013\n\nstr\n\nThe reverse of `escape()`. This unescapes all the HTML entities, not only\nthose inserted by `escape`.\n\nDeprecated since version 2.0: Will be removed in Werkzeug 2.1. Use MarkupSafe\ninstead.\n\ns (str) \u2013\n\nstr\n\nA `property()` that is only evaluated once. Subsequent access returns the\ncached value. Setting the property sets the cached value. Deleting the\nproperty clears the cached value, accessing it again will evaluate it again.\n\nThe class must have a `__dict__` for this to work.\n\nChanged in version 2.0: `del obj.name` clears the cached value.\n\nNone\n\nInvalidates the cache for a `cached_property`:\n\nYou must pass the name of the cached property as the second argument.\n\nDeprecated since version 2.0: Will be removed in Werkzeug 2.1. Use `del\nobj.name` instead.\n\nNone\n\nMaps request attributes to environment variables. This works not only for the\nWerkzeug request object, but also any other class with an environ attribute:\n\nIf you pass it a second value it\u2019s used as default if the key does not exist,\nthe third one can be a converter that takes a value and converts it. If it\nraises `ValueError` or `TypeError` the default value is used. If no default\nvalue is provided `None` is used.\n\nPer default the property is read only. You have to explicitly enable it by\npassing `read_only=False` to the constructor.\n\nLike `environ_property` but for headers.\n\nReturns a response object (a WSGI application) that, if called, redirects the\nclient to the target location. Supported codes are 301, 302, 303, 305, 307,\nand 308. 300 is not supported because it\u2019s not a real redirect and 304 because\nit\u2019s the answer for a request with a request with defined If-Modified-Since\nheaders.\n\nNew in version 0.10: The class used for the Response object can now be passed\nin.\n\nNew in version 0.6: The location can now be a unicode string that is encoded\nusing the `iri_to_uri()` function.\n\nResponse\n\nRedirects to the same URL but with a slash appended. The behavior of this\nfunction is undefined if the path ends with a slash already.\n\nResponse\n\nSend the contents of a file to the client.\n\nThe first argument can be a file path or a file-like object. Paths are\npreferred in most cases because Werkzeug can manage the file and get extra\ninformation from the path. Passing a file-like object requires that the file\nis opened in binary mode, and is mostly useful when building a file in memory\nwith `io.BytesIO`.\n\nNever pass file paths provided by a user. The path is assumed to be trusted,\nso a user could craft a path to access a file you didn\u2019t intend.\n\nIf the WSGI server sets a `file_wrapper` in `environ`, it is used, otherwise\nWerkzeug\u2019s built-in wrapper is used. Alternatively, if the HTTP server\nsupports `X-Sendfile`, `use_x_sendfile=True` will tell the server to send the\ngiven path, which is much more efficient than reading it in Python.\n\nResponse\n\nNew in version 2.0: Adapted from Flask\u2019s implementation.\n\nChanged in version 2.0: `download_name` replaces Flask\u2019s `attachment_filename`\nparameter. If `as_attachment=False`, it is passed with `Content-Disposition:\ninline` instead.\n\nChanged in version 2.0: `max_age` replaces Flask\u2019s `cache_timeout` parameter.\n`conditional` is enabled and `max_age` is not set by default.\n\nChanged in version 2.0: `etag` replaces Flask\u2019s `add_etags` parameter. It can\nbe a string to use instead of generating one.\n\nChanged in version 2.0: If an encoding is returned when guessing `mimetype`\nfrom `download_name`, set the `Content-Encoding` header.\n\nImports an object based on a string. This is useful if you want to use import\npaths as endpoints or something similar. An import path can be specified\neither in dotted notation (`xml.sax.saxutils.escape`) or with a colon as\nobject delimiter (`xml.sax.saxutils:escape`).\n\nIf `silent` is True the return value will be `None` if the import fails.\n\nimported object\n\nAny\n\nFinds all the modules below a package. This can be useful to automatically\nimport all views / controllers so that their metaclasses / function decorators\nhave a chance to register themselves on the application.\n\nPackages are not returned unless `include_packages` is `True`. This can also\nrecursively list modules but in that case it will import all the packages to\nget the correct load path of that module.\n\ngenerator\n\nIterator[str]\n\nChecks if the function accepts the arguments and keyword arguments. Returns a\nnew `(args, kwargs)` tuple that can safely be passed to the function without\ncausing a `TypeError` because the function signature is incompatible. If\n`drop_extra` is set to `True` (which is the default) any extra positional or\nkeyword arguments are dropped automatically.\n\nThe exception raised provides three attributes:\n\nA set of argument names that the function expected but where missing.\n\nA dict of keyword arguments that the function can not handle but where\nprovided.\n\nA list of values that where given by positional argument but the function\ncannot accept.\n\nThis can be useful for decorators that forward user submitted data to a view\nfunction:\n\ntuple in the form `(args, kwargs)`.\n\nDeprecated since version 2.0: Will be removed in Werkzeug 2.1. Use\n`inspect.signature()` instead.\n\nPass it a filename and it will return a secure version of it. This filename\ncan then safely be stored on a regular file system and passed to\n`os.path.join()`. The filename returned is an ASCII only string for maximum\nportability.\n\nOn windows systems the function also makes sure that the file is not named\nafter one of the special device files.\n\nThe function might return an empty filename. It\u2019s your responsibility to\nensure that the filename is unique and that you abort or generate a random\nfilename if the function returned an empty one.\n\nNew in version 0.5.\n\nfilename (str) \u2013 the filename to secure\n\nstr\n\nBind the arguments provided into a dict. When passed a function, a tuple of\narguments and a dict of keyword arguments `bind_arguments` returns a dict of\nnames as the function would see it. This can be useful to implement a cache\ndecorator that uses the function arguments to build the cache key based on the\nvalues of the arguments.\n\na `dict` of bound keyword arguments.\n\nDeprecated since version 2.0: Will be removed in Werkzeug 2.1. Use\n`Signature.bind()` instead.\n\nPlease refer to URL Helpers.\n\nRepresents a parsed user agent header value.\n\nThe default implementation does no parsing, only the `string` attribute is\nset. A subclass may parse the string to set the common attributes or expose\nother information. Set `werkzeug.wrappers.Request.user_agent_class` to use a\nsubclass.\n\nstring (str) \u2013 The header value to parse.\n\nNone\n\nNew in version 2.0: This replaces the previous `useragents` module, but does\nnot provide a built-in parser.\n\nThe OS name, if it could be parsed from the string.\n\nThe browser name, if it could be parsed from the string.\n\nThe browser version, if it could be parsed from the string.\n\nThe browser language, if it could be parsed from the string.\n\nThe original header value.\n\nConvert to a header value.\n\nstr\n\nDeprecated since version 2.0: This module will be removed in Werkzeug 2.1.\nSubclass `werkzeug.user_agent.UserAgent` to use a dedicated parser instead.\n\nRepresents a parsed user agent header value.\n\nThis uses a basic parser to try to extract some information from the header.\n\nenviron_or_string (t.Union[str, WSGIEnvironment]) \u2013 The header value to parse,\nor a WSGI environ containing the header.\n\nNone\n\nDeprecated since version 2.0: Will be removed in Werkzeug 2.1. Subclass\n`werkzeug.user_agent.UserAgent` (note the new module name) to use a dedicated\nparser instead.\n\nChanged in version 2.0: Passing a WSGI environ is deprecated and will be\nremoved in 2.1.\n\nConvert to a header value.\n\nstr\n\nNew in version 0.6.1.\n\nHash a password with the given method and salt with a string of the given\nlength. The format of the string returned includes the method that was used so\nthat `check_password_hash()` can check the hash.\n\nThe format for the hashed string looks like this:\n\nThis method can not generate unsalted passwords but it is possible to set\nparam method=\u2019plain\u2019 in order to enforce plaintext passwords. If a salt is\nused, hmac is used internally to salt the password.\n\nIf PBKDF2 is wanted it can be enabled by setting the method to\n`pbkdf2:method:iterations` where iterations is optional:\n\nstr\n\nCheck a password against a given salted and hashed password value. In order to\nsupport unsalted legacy passwords this method supports plain text passwords,\nmd5 and sha1 hashes (both salted and unsalted).\n\nReturns `True` if the password matched, `False` otherwise.\n\nbool\n\nThis function compares strings in somewhat constant time. This requires that\nthe length of at least one string is known in advance.\n\nReturns `True` if the two strings are equal, or `False` if they are not.\n\nDeprecated since version 2.0: Will be removed in Werkzeug 2.1. Use\n`hmac.compare_digest()` instead.\n\nNew in version 0.7.\n\nbool\n\nSafely join zero or more untrusted path components to a base directory to\navoid escaping the base directory.\n\nA safe path, otherwise `None`.\n\nOptional[str]\n\nLike `pbkdf2_bin()`, but returns a hex-encoded string.\n\nstr\n\nDeprecated since version 2.0: Will be removed in Werkzeug 2.1. Use\n`hashlib.pbkdf2_hmac()` instead.\n\nNew in version 0.9.\n\nReturns a binary digest for the PBKDF2 hash algorithm of `data` with the given\n`salt`. It iterates `iterations` times and produces a key of `keylen` bytes.\nBy default, SHA-256 is used as hash function; a different hashlib `hashfunc`\ncan be provided.\n\nbytes\n\nDeprecated since version 2.0: Will be removed in Werkzeug 2.1. Use\n`hashlib.pbkdf2_hmac()` instead.\n\nNew in version 0.9.\n\nWerkzeug uses standard Python `logging`. The logger is named `\"werkzeug\"`.\n\nIf the logger level is not set, it will be set to `INFO` on first use. If\nthere is no handler for that level, a `StreamHandler` is added.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "UUIDConverter", "path": "routing/index#werkzeug.routing.UUIDConverter", "type": "werkzeug.routing", "text": "\nThis converter only accepts UUID strings:\n\nNew in version 0.10.\n\nNone\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "validate_arguments()", "path": "utils/index#werkzeug.utils.validate_arguments", "type": "werkzeug.utils", "text": "\nChecks if the function accepts the arguments and keyword arguments. Returns a\nnew `(args, kwargs)` tuple that can safely be passed to the function without\ncausing a `TypeError` because the function signature is incompatible. If\n`drop_extra` is set to `True` (which is the default) any extra positional or\nkeyword arguments are dropped automatically.\n\nThe exception raised provides three attributes:\n\nA set of argument names that the function expected but where missing.\n\nA dict of keyword arguments that the function can not handle but where\nprovided.\n\nA list of values that where given by positional argument but the function\ncannot accept.\n\nThis can be useful for decorators that forward user submitted data to a view\nfunction:\n\ntuple in the form `(args, kwargs)`.\n\nDeprecated since version 2.0: Will be removed in Werkzeug 2.1. Use\n`inspect.signature()` instead.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "Werkzeug Tutorial", "path": "tutorial/index", "type": "Other", "text": "\nWelcome to the Werkzeug tutorial in which we will create a TinyURL clone that\nstores URLs in a redis instance. The libraries we will use for this\napplications are Jinja 2 for the templates, redis for the database layer and,\nof course, Werkzeug for the WSGI layer.\n\nYou can use `pip` to install the required libraries:\n\nAlso make sure to have a redis server running on your local machine. If you\nare on OS X, you can use `brew` to install it:\n\nIf you are on Ubuntu or Debian, you can use apt-get:\n\nRedis was developed for UNIX systems and was never really designed to work on\nWindows. For development purposes, the unofficial ports however work well\nenough. You can get them from github.\n\nIn this tutorial, we will together create a simple URL shortener service with\nWerkzeug. Please keep in mind that Werkzeug is not a framework, it\u2019s a library\nwith utilities to create your own framework or application and as such is very\nflexible. The approach we use here is just one of many you can use.\n\nAs data store, we will use redis here instead of a relational database to keep\nthis simple and because that\u2019s the kind of job that redis excels at.\n\nThe final result will look something like this:\n\nWerkzeug is a utility library for WSGI. WSGI itself is a protocol or\nconvention that ensures that your web application can speak with the webserver\nand more importantly that web applications work nicely together.\n\nA basic \u201cHello World\u201d application in WSGI without the help of Werkzeug looks\nlike this:\n\nA WSGI application is something you can call and pass an environ dict and a\n`start_response` callable. The environ contains all incoming information, the\n`start_response` function can be used to indicate the start of the response.\nWith Werkzeug you don\u2019t have to deal directly with either as request and\nresponse objects are provided to work with them.\n\nThe request data takes the environ object and allows you to access the data\nfrom that environ in a nice manner. The response object is a WSGI application\nin itself and provides a much nicer way to create responses.\n\nHere is how you would write that application with response objects:\n\nAnd here an expanded version that looks at the query string in the URL (more\nimportantly at the `name` parameter in the URL to substitute \u201cWorld\u201d against\nanother word):\n\nAnd that\u2019s all you need to know about WSGI.\n\nBefore we get started, let\u2019s create the folders needed for this application:\n\nThe shortly folder is not a python package, but just something where we drop\nour files. Directly into this folder we will then put our main module in the\nfollowing steps. The files inside the static folder are available to users of\nthe application via HTTP. This is the place where CSS and JavaScript files go.\nInside the templates folder we will make Jinja2 look for templates. The\ntemplates you create later in the tutorial will go in this directory.\n\nNow let\u2019s get right into it and create a module for our application. Let\u2019s\ncreate a file called `shortly.py` in the `shortly` folder. At first we will\nneed a bunch of imports. I will pull in all the imports here, even if they are\nnot used right away, to keep it from being confusing:\n\nThen we can create the basic structure for our application and a function to\ncreate a new instance of it, optionally with a piece of WSGI middleware that\nexports all the files on the `static` folder on the web:\n\nLastly we can add a piece of code that will start a local development server\nwith automatic code reloading and a debugger:\n\nThe basic idea here is that our `Shortly` class is an actual WSGI application.\nThe `__call__` method directly dispatches to `wsgi_app`. This is done so that\nwe can wrap `wsgi_app` to apply middlewares like we do in the `create_app`\nfunction. The actual `wsgi_app` method then creates a `Request` object and\ncalls the `dispatch_request` method which then has to return a `Response`\nobject which is then evaluated as WSGI application again. As you can see:\nturtles all the way down. Both the `Shortly` class we create, as well as any\nrequest object in Werkzeug implements the WSGI interface. As a result of that\nyou could even return another WSGI application from the `dispatch_request`\nmethod.\n\nThe `create_app` factory function can be used to create a new instance of our\napplication. Not only will it pass some parameters as configuration to the\napplication but also optionally add a WSGI middleware that exports static\nfiles. This way we have access to the files from the static folder even when\nwe are not configuring our server to provide them which is very helpful for\ndevelopment.\n\nNow you should be able to execute the file with `python` and see a server on\nyour local machine:\n\nIt also tells you that the reloader is active. It will use various techniques\nto figure out if any file changed on the disk and then automatically restart.\n\nJust go to the URL and you should see \u201cHello World!\u201d.\n\nNow that we have the basic application class, we can make the constructor do\nsomething useful and provide a few helpers on there that can come in handy. We\nwill need to be able to render templates and connect to redis, so let\u2019s extend\nthe class a bit:\n\nNext up is routing. Routing is the process of matching and parsing the URL to\nsomething we can use. Werkzeug provides a flexible integrated routing system\nwhich we can use for that. The way it works is that you create a `Map`\ninstance and add a bunch of `Rule` objects. Each rule has a pattern it will\ntry to match the URL against and an \u201cendpoint\u201d. The endpoint is typically a\nstring and can be used to uniquely identify the URL. We could also use this to\nautomatically reverse the URL, but that\u2019s not what we will do in this\ntutorial.\n\nJust put this into the constructor:\n\nHere we create a URL map with three rules. `/` for the root of the URL space\nwhere we will just dispatch to a function that implements the logic to create\na new URL. And then one that follows the short link to the target URL and\nanother one with the same rule but a plus (`+`) at the end to show the link\ndetails.\n\nSo how do we find our way from the endpoint to a function? That\u2019s up to you.\nThe way we will do it in this tutorial is by calling the method `on_` \\+\nendpoint on the class itself. Here is how this works:\n\nWe bind the URL map to the current environment and get back a `URLAdapter`.\nThe adapter can be used to match the request but also to reverse URLs. The\nmatch method will return the endpoint and a dictionary of values in the URL.\nFor instance the rule for `follow_short_link` has a variable part called\n`short_id`. When we go to `http://localhost:5000/foo` we will get the\nfollowing values back:\n\nIf it does not match anything, it will raise a `NotFound` exception, which is\nan `HTTPException`. All HTTP exceptions are also WSGI applications by\nthemselves which render a default error page. So we just catch all of them\ndown and return the error itself.\n\nIf all works well, we call the function `on_` \\+ endpoint and pass it the\nrequest as argument as well as all the URL arguments as keyword arguments and\nreturn the response object that method returns.\n\nLet\u2019s start with the first view: the one for new URLs:\n\nThis logic should be easy to understand. Basically we are checking that the\nrequest method is POST, in which case we validate the URL and add a new entry\nto the database, then redirect to the detail page. This means we need to write\na function and a helper method. For URL validation this is good enough:\n\nFor inserting the URL, all we need is this little method on our class:\n\n`reverse-url:` \\+ the URL will store the short id. If the URL was already\nsubmitted this won\u2019t be None and we can just return that value which will be\nthe short ID. Otherwise we increment the `last-url-id` key and convert it to\nbase36. Then we store the link and the reverse entry in redis. And here the\nfunction to convert to base 36:\n\nSo what is missing for this view to work is the template. We will create this\nlater, let\u2019s first also write the other views and then do the templates in one\ngo.\n\nThe redirect view is easy. All it has to do is to look for the link in redis\nand redirect to it. Additionally we will also increment a counter so that we\nknow how often a link was clicked:\n\nIn this case we will raise a `NotFound` exception by hand if the URL does not\nexist, which will bubble up to the `dispatch_request` function and be\nconverted into a default 404 response.\n\nThe link detail view is very similar, we just render a template again. In\naddition to looking up the target, we also ask redis for the number of times\nthe link was clicked and let it default to zero if such a key does not yet\nexist:\n\nPlease be aware that redis always works with strings, so you have to convert\nthe click count to `int` by hand.\n\nAnd here are all the templates. Just drop them into the `templates` folder.\nJinja2 supports template inheritance, so the first thing we will do is create\na layout template with blocks that act as placeholders. We also set up Jinja2\nso that it automatically escapes strings with HTML rules, so we don\u2019t have to\nspend time on that ourselves. This prevents XSS attacks and rendering errors.\n\nlayout.html:\n\nnew_url.html:\n\nshort_link_details.html:\n\nFor this to look better than ugly black and white, here a simple stylesheet\nthat goes along:\n\nstatic/style.css:\n\nLook at the implementation in the example dictionary in the Werkzeug\nrepository to see a version of this tutorial with some small refinements such\nas a custom 404 page.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "wrap_file()", "path": "wsgi/index#werkzeug.wsgi.wrap_file", "type": "werkzeug.wsgi", "text": "\nWraps a file. This uses the WSGI server\u2019s file wrapper if available or\notherwise the generic `FileWrapper`.\n\nNew in version 0.5.\n\nIf the file wrapper from the WSGI server is used it\u2019s important to not iterate\nover it from inside the application but to pass it through unchanged. If you\nwant to pass out a file wrapper inside a response object you have to set\n`Response.direct_passthrough` to `True`.\n\nMore information about file wrappers are available in PEP 333.\n\nIterable[bytes]\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "WSGI Helpers", "path": "wsgi/index", "type": "Other", "text": "\nThe following classes and functions are designed to make working with the WSGI\nspecification easier or operate on the WSGI layer. All the functionality from\nthis module is available on the high-level Request / Response Objects.\n\nThese classes and functions simplify working with the WSGI application\niterator and the input stream.\n\nThe WSGI specification requires that all middlewares and gateways respect the\n`close` callback of the iterable returned by the application. Because it is\nuseful to add another close action to a returned iterable and adding a custom\niterable is a boring task this class can be used for that:\n\nIf there is just one close function it can be passed instead of the list.\n\nA closing iterator is not needed if the application uses response objects and\nfinishes the processing if the response is started:\n\nNone\n\nThis class can be used to convert a `file`-like object into an iterable. It\nyields `buffer_size` blocks until the file is fully read.\n\nYou should not use this class directly but rather use the `wrap_file()`\nfunction that uses the WSGI server\u2019s file wrapper support if it\u2019s available.\n\nNew in version 0.5.\n\nIf you\u2019re using this object together with a `Response` you have to use the\n`direct_passthrough` mode.\n\nNone\n\nWraps a stream so that it doesn\u2019t read more than n bytes. If the stream is\nexhausted and the caller tries to get more bytes from it `on_exhausted()` is\ncalled which by default returns an empty string. The return value of that\nfunction is forwarded to the reader function. So if it returns an empty string\n`read()` will return an empty string as well.\n\nThe limit however must never be higher than what the stream can output.\nOtherwise `readlines()` will try to read past the limit.\n\nNote on WSGI compliance\n\ncalls to `readline()` and `readlines()` are not WSGI compliant because it\npasses a size argument to the readline methods. Unfortunately the WSGI PEP is\nnot safely implementable without a size argument to `readline()` because there\nis no EOF marker in the stream. As a result of that the use of `readline()` is\ndiscouraged.\n\nFor the same reason iterating over the `LimitedStream` is not portable. It\ninternally calls `readline()`.\n\nWe strongly suggest using `read()` only or using the `make_line_iter()` which\nsafely iterates line-based over a WSGI input stream.\n\nNone\n\nExhaust the stream. This consumes all the data left until the limit is\nreached.\n\nchunk_size (int) \u2013 the size for a chunk. It will read the chunk until the\nstream is exhausted and throw away the results.\n\nNone\n\nIf the stream is exhausted this attribute is `True`.\n\nWhat should happen if a disconnect is detected? The return value of this\nfunction is returned from read functions in case the client went away. By\ndefault a `ClientDisconnected` exception is raised.\n\nbytes\n\nThis is called when the stream tries to read past the limit. The return value\nof this function is returned from the reading function.\n\nbytes\n\nRead `size` bytes or if size is not provided everything is read.\n\nsize (Optional[int]) \u2013 the number of bytes read.\n\nbytes\n\nReturn whether object was opened for reading.\n\nIf False, read() will raise OSError.\n\nbool\n\nReads one line from the stream.\n\nsize (Optional[int]) \u2013\n\nbytes\n\nReads a file into a list of strings. It calls `readline()` until the file is\nread to the end. It does support the optional `size` argument if the\nunderlying stream supports it for `readline`.\n\nsize (Optional[int]) \u2013\n\nList[bytes]\n\nReturns the position of the stream.\n\nNew in version 0.9.\n\nint\n\nSafely iterates line-based over an input stream. If the input stream is not a\n`LimitedStream` the `limit` parameter is mandatory.\n\nThis uses the stream\u2019s `read()` method internally as opposite to the\n`readline()` method that is unsafe and can only be used in violation of the\nWSGI specification. The same problem applies to the `__iter__` function of the\ninput stream which calls `readline()` without arguments.\n\nIf you need line-by-line processing it\u2019s strongly recommended to iterate over\nthe input stream using this helper function.\n\nNew in version 0.11.10: added support for the `cap_at_buffer` parameter.\n\nNew in version 0.9: added support for iterators as input stream.\n\nChanged in version 0.8: This function now ensures that the limit was reached.\n\nIterator[bytes]\n\nWorks like `make_line_iter()` but accepts a separator which divides chunks. If\nyou want newline based processing you should use `make_line_iter()` instead as\nit supports arbitrary newline markers.\n\nNew in version 0.11.10: added support for the `cap_at_buffer` parameter.\n\nNew in version 0.9: added support for iterators as input stream.\n\nNew in version 0.8.\n\nIterator[bytes]\n\nWraps a file. This uses the WSGI server\u2019s file wrapper if available or\notherwise the generic `FileWrapper`.\n\nNew in version 0.5.\n\nIf the file wrapper from the WSGI server is used it\u2019s important to not iterate\nover it from inside the application but to pass it through unchanged. If you\nwant to pass out a file wrapper inside a response object you have to set\n`Response.direct_passthrough` to `True`.\n\nMore information about file wrappers are available in PEP 333.\n\nIterable[bytes]\n\nThese functions operate on the WSGI environment. They extract useful\ninformation or perform common manipulations:\n\nReturn the host for the given WSGI environment.\n\nThe `Host` header is preferred, then `SERVER_NAME` if it\u2019s not set. The\nreturned host will only contain the port if it is different than the standard\nport for the protocol.\n\nOptionally, verify that the host is trusted using `host_is_trusted()` and\nraise a `SecurityError` if it is not.\n\nHost, with port if necessary.\n\nSecurityError \u2013 If the host is not trusted.\n\nstr\n\nReturns the content length from the WSGI environment as integer. If it\u2019s not\navailable or chunked transfer encoding is used, `None` is returned.\n\nNew in version 0.9.\n\nenviron (WSGIEnvironment) \u2013 the WSGI environ to fetch the content length from.\n\nOptional[int]\n\nReturns the input stream from the WSGI environment and wraps it in the most\nsensible way possible. The stream returned is not the raw WSGI stream in most\ncases but one that is safe to read from without taking into account the\ncontent length.\n\nIf content length is not set, the stream will be empty for safety reasons. If\nthe WSGI server supports chunked or infinite streams, it should set the\n`wsgi.input_terminated` value in the WSGI environ to indicate that.\n\nNew in version 0.9.\n\nBinaryIO\n\nRecreate the URL for a request from the parts in a WSGI environment.\n\nThe URL is an IRI, not a URI, so it may contain Unicode characters. Use\n`iri_to_uri()` to convert it to ASCII.\n\nstr\n\nReturns the `QUERY_STRING` from the WSGI environment. This also takes care of\nthe WSGI decoding dance. The string returned will be restricted to ASCII\ncharacters.\n\nenviron (WSGIEnvironment) \u2013 WSGI environment to get the query string from.\n\nstr\n\nNew in version 0.9.\n\nReturn the `SCRIPT_NAME` from the WSGI environment and decode it unless\n`charset` is set to `None`.\n\nstr\n\nNew in version 0.9.\n\nReturn the `PATH_INFO` from the WSGI environment and decode it unless\n`charset` is `None`.\n\nstr\n\nNew in version 0.9.\n\nRemoves and returns the next segment of `PATH_INFO`, pushing it onto\n`SCRIPT_NAME`. Returns `None` if there is nothing left on `PATH_INFO`.\n\nIf the `charset` is set to `None` bytes are returned.\n\nIf there are empty segments (`'/foo//bar`) these are ignored but properly\npushed to the `SCRIPT_NAME`:\n\nChanged in version 0.9: The path is now decoded and a charset and encoding\nparameter can be provided.\n\nNew in version 0.5.\n\nOptional[str]\n\nReturns the next segment on the `PATH_INFO` or `None` if there is none. Works\nlike `pop_path_info()` without modifying the environment:\n\nIf the `charset` is set to `None` bytes are returned.\n\nChanged in version 0.9: The path is now decoded and a charset and encoding\nparameter can be provided.\n\nNew in version 0.5.\n\nOptional[str]\n\nExtracts the path info from the given URL (or WSGI environment) and path. The\npath info returned is a string. The URLs might also be IRIs.\n\nIf the path info could not be determined, `None` is returned.\n\nSome examples:\n\nInstead of providing a base URL you can also pass a WSGI environment.\n\nOptional[str]\n\nChanged in version 0.15: The `errors` parameter defaults to leaving invalid\nbytes quoted instead of replacing them.\n\nNew in version 0.6.\n\nCheck if a host matches a list of trusted names.\n\nbool\n\nNew in version 0.9.\n\nMarks a function as responder. Decorate a function with it and it will\nautomatically call the return value as WSGI application.\n\nExample:\n\nf (Callable[[...], WSGIApplication]) \u2013\n\nWSGIApplication\n\nSimple test application that dumps the environment. You can use it to check if\nWerkzeug is working properly:\n\nThe application displays important information from the WSGI environment, the\nPython interpreter and the installed libraries.\n\nIterable[bytes]\n\nThe values in HTTP requests come in as bytes representing (or encoded to)\nASCII. The WSGI specification (PEP 3333) decided to always use the `str` type\nto represent values. To accomplish this, the raw bytes are decoded using the\nISO-8859-1 charset to produce a string.\n\nStrings in the WSGI environment are restricted to ISO-8859-1 code points. If a\nstring read from the environment might contain characters outside that\ncharset, it must first be decoded to bytes as ISO-8859-1, then encoded to a\nstring using the proper charset (typically UTF-8). The reverse is done when\nwriting to the environ. This is known as the \u201cWSGI encoding dance\u201d.\n\nWerkzeug provides functions to deal with this automatically so that you don\u2019t\nneed to be aware of the inner workings. Use the functions on this page as well\nas `EnvironHeaders()` to read data out of the WSGI environment.\n\nApplications should avoid manually creating or modifying a WSGI environment\nunless they take care of the proper encoding or decoding step. All high level\ninterfaces in Werkzeug will apply the encoding and decoding as necessary.\n\nThe `PATH_INFO` in the environ is the path value after percent-decoding. For\nexample, the raw path `/hello%2fworld` would show up from the WSGI server to\nWerkzeug as `/hello/world`. This loses the information that the slash was a\nraw character as opposed to a path separator.\n\nThe WSGI specification (PEP 3333) does not provide a way to get the original\nvalue, so it is impossible to route some types of data in the path. The most\ncompatible way to work around this is to send problematic data in the query\nstring instead of the path.\n\nHowever, many WSGI servers add a non-standard environ key with the raw path.\nTo match this behavior, Werkzeug\u2019s test client and development server will add\nthe raw value to both the `REQUEST_URI` and `RAW_URI` keys. If you want to\nroute based on this value, you can use middleware to replace `PATH_INFO` in\nthe environ before it reaches the application. However, keep in mind that\nthese keys are non-standard and not guaranteed to be present.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "WSGI Protocol Linter", "path": "middleware/lint/index", "type": "Other", "text": "\nThis module provides a middleware that performs sanity checks on the behavior\nof the WSGI server and application. It checks that the PEP 3333 WSGI spec is\nproperly implemented. It also warns on some common HTTP errors such as non-\nempty responses for 304 status codes.\n\nWarns about common errors in the WSGI and HTTP behavior of the server and\nwrapped application. Some of the issues it checks are:\n\nError information is emitted using the `warnings` module.\n\napp (WSGIApplication) \u2013 The WSGI application to wrap.\n\nNone\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "WWWAuthenticate", "path": "datastructures/index#werkzeug.datastructures.WWWAuthenticate", "type": "werkzeug.datastructures", "text": "\nProvides simple access to `WWW-Authenticate` headers.\n\nA string indicating a pair of algorithms used to produce the digest and a\nchecksum. If this is not present it is assumed to be \u201cMD5\u201d. If the algorithm\nis not understood, the challenge should be ignored (and a different one used,\nif there is more than one).\n\nA static helper function for Authentication subclasses to add extra\nauthentication system properties onto a class:\n\nFor more information have a look at the sourcecode to see how the regular\nproperties (`realm` etc.) are implemented.\n\nA list of URIs that define the protection space. If a URI is an absolute path,\nit is relative to the canonical root URL of the server being accessed.\n\nA server-specified data string which should be uniquely generated each time a\n401 response is made. It is recommended that this string be base64 or\nhexadecimal data.\n\nA string of data, specified by the server, which should be returned by the\nclient unchanged in the Authorization header of subsequent requests with URIs\nin the same protection space. It is recommended that this string be base64 or\nhexadecimal data.\n\nA set of quality-of-privacy directives such as auth and auth-int.\n\nA string to be displayed to users so they know which username and password to\nuse. This string should contain at least the name of the host performing the\nauthentication and might additionally indicate the collection of users who\nmight have access.\n\nClear the auth info and enable basic auth.\n\nClear the auth info and enable digest auth.\n\nA flag, indicating that the previous request from the client was rejected\nbecause the nonce value was stale.\n\nConvert the stored values into a WWW-Authenticate header.\n\nThe type of the auth mechanism. HTTP currently specifies `Basic` and `Digest`.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "WWWAuthenticate.auth_property()", "path": "datastructures/index#werkzeug.datastructures.WWWAuthenticate.auth_property", "type": "werkzeug.datastructures", "text": "\nA static helper function for Authentication subclasses to add extra\nauthentication system properties onto a class:\n\nFor more information have a look at the sourcecode to see how the regular\nproperties (`realm` etc.) are implemented.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "WWWAuthenticate.set_basic()", "path": "datastructures/index#werkzeug.datastructures.WWWAuthenticate.set_basic", "type": "werkzeug.datastructures", "text": "\nClear the auth info and enable basic auth.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "WWWAuthenticate.set_digest()", "path": "datastructures/index#werkzeug.datastructures.WWWAuthenticate.set_digest", "type": "werkzeug.datastructures", "text": "\nClear the auth info and enable digest auth.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "WWWAuthenticate.to_header()", "path": "datastructures/index#werkzeug.datastructures.WWWAuthenticate.to_header", "type": "werkzeug.datastructures", "text": "\nConvert the stored values into a WWW-Authenticate header.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}, {"name": "X-Forwarded-For Proxy Fix", "path": "middleware/proxy_fix/index", "type": "Other", "text": "\nThis module provides a middleware that adjusts the WSGI environ based on\n`X-Forwarded-` headers that proxies in front of an application may set.\n\nWhen an application is running behind a proxy server, WSGI may see the request\nas coming from that server rather than the real client. Proxies set various\nheaders to track where the request actually came from.\n\nThis middleware should only be used if the application is actually behind such\na proxy, and should be configured with the number of proxies that are chained\nin front of it. Not all proxies set all the headers. Since incoming headers\ncan be faked, you must set how many proxies are setting each header so the\nmiddleware knows what to trust.\n\nAdjust the WSGI environ based on `X-Forwarded-` that proxies in front of the\napplication may set.\n\nYou must tell the middleware how many proxies set each header so it knows what\nvalues to trust. It is a security issue to trust values that came from the\nclient rather than a proxy.\n\nThe original values of the headers are stored in the WSGI environ as\n`werkzeug.proxy_fix.orig`, a dict.\n\nNone\n\nChanged in version 1.0: Deprecated code has been removed:\n\nChanged in version 0.15: All headers support multiple values. The\n`num_proxies` argument is deprecated. Each header is configured with a\nseparate number of trusted proxies.\n\nChanged in version 0.15: Original WSGI environ values are stored in the\n`werkzeug.proxy_fix.orig` dict. `orig_remote_addr`, `orig_wsgi_url_scheme`,\nand `orig_http_host` are deprecated and will be removed in 1.0.\n\nChanged in version 0.15: Support `X-Forwarded-Port` and `X-Forwarded-Prefix`.\n\nChanged in version 0.15: `X-Forwarded-Host` and `X-Forwarded-Port` modify\n`SERVER_NAME` and `SERVER_PORT`.\n\n  *[FIFO]: first-in, first-out\n  *[LIFO]: last-in, first-out\n\n"}]