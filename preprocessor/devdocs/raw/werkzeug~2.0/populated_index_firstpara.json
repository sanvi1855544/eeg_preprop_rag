[{"name": "abort()", "path": "exceptions/index#werkzeug.exceptions.abort", "type": "werkzeug.exceptions", "text": "\nRaises an `HTTPException` for the given status code or WSGI application.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Aborter", "path": "exceptions/index#werkzeug.exceptions.Aborter", "type": "werkzeug.exceptions", "text": "\nWhen passed a dict of code -> exception items it can be used as callable that\nraises exceptions. If the first argument to the callable is an integer it will\nbe looked up in the mapping, if it\u2019s a WSGI application it will be raised in a\nproxy exception.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Accept", "path": "datastructures/index#werkzeug.datastructures.Accept", "type": "werkzeug.datastructures", "text": "\nAn `Accept` object is just a list subclass for lists of `(value, quality)`\ntuples. It is automatically sorted by specificity and quality.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Accept.best_match()", "path": "datastructures/index#werkzeug.datastructures.Accept.best_match", "type": "werkzeug.datastructures", "text": "\nReturns the best match from a list of possible matches based on the\nspecificity and quality of the client. If two items have the same quality and\nspecificity, the one is returned that comes first.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Accept.find()", "path": "datastructures/index#werkzeug.datastructures.Accept.find", "type": "werkzeug.datastructures", "text": "\nGet the position of an entry or return -1.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Accept.index()", "path": "datastructures/index#werkzeug.datastructures.Accept.index", "type": "werkzeug.datastructures", "text": "\nGet the position of an entry or raise `ValueError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Accept.quality()", "path": "datastructures/index#werkzeug.datastructures.Accept.quality", "type": "werkzeug.datastructures", "text": "\nReturns the quality of the key.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Accept.to_header()", "path": "datastructures/index#werkzeug.datastructures.Accept.to_header", "type": "werkzeug.datastructures", "text": "\nConvert the header set into an HTTP header string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Accept.values()", "path": "datastructures/index#werkzeug.datastructures.Accept.values", "type": "werkzeug.datastructures", "text": "\nIterate over all values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "AnyConverter", "path": "routing/index#werkzeug.routing.AnyConverter", "type": "werkzeug.routing", "text": "\nMatches one of the items provided. Items can either be Python identifiers or\nstrings:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "API Levels", "path": "levels/index", "type": "Other", "text": "\nWerkzeug is intended to be a utility rather than a framework. Because of that\nthe user-friendly API is separated from the lower-level API so that Werkzeug\ncan easily be used to extend another system.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "append_slash_redirect()", "path": "utils/index#werkzeug.utils.append_slash_redirect", "type": "werkzeug.utils", "text": "\nRedirects to the same URL but with a slash appended. The behavior of this\nfunction is undefined if the path ends with a slash already.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Application Deployment", "path": "deployment/index", "type": "Other", "text": "\nThis section covers running your application in production on a web server\nsuch as Apache or lighttpd.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Application Dispatcher", "path": "middleware/dispatcher/index", "type": "Other", "text": "\nThis middleware creates a single WSGI application that dispatches to multiple\nother WSGI applications mounted at different URL paths.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Application Profiler", "path": "middleware/profiler/index", "type": "Other", "text": "\nThis module provides a middleware that profiles each request with the\n`cProfile` module. This can help identify bottlenecks in your code that may be\nslowing down your application.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Authorization", "path": "datastructures/index#werkzeug.datastructures.Authorization", "type": "werkzeug.datastructures", "text": "\nRepresents an `Authorization` header sent by the client.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Authorization.to_header()", "path": "datastructures/index#werkzeug.datastructures.Authorization.to_header", "type": "werkzeug.datastructures", "text": "\nConvert to a string value for an `Authorization` header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "BaseURL", "path": "urls/index#werkzeug.urls.BaseURL", "type": "werkzeug.urls", "text": "\nSuperclass of `URL` and `BytesURL`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "BaseURL.decode_netloc()", "path": "urls/index#werkzeug.urls.BaseURL.decode_netloc", "type": "werkzeug.urls", "text": "\nDecodes the netloc part into a string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "BaseURL.decode_query()", "path": "urls/index#werkzeug.urls.BaseURL.decode_query", "type": "werkzeug.urls", "text": "\nDecodes the query part of the URL. Ths is a shortcut for calling\n`url_decode()` on the query argument. The arguments and keyword arguments are\nforwarded to `url_decode()` unchanged.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "BaseURL.encode_netloc()", "path": "urls/index#werkzeug.urls.BaseURL.encode_netloc", "type": "werkzeug.urls", "text": "\nEncodes the netloc part to an ASCII safe URL as bytes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "BaseURL.get_file_location()", "path": "urls/index#werkzeug.urls.BaseURL.get_file_location", "type": "werkzeug.urls", "text": "\nReturns a tuple with the location of the file in the form `(server,\nlocation)`. If the netloc is empty in the URL or points to localhost, it\u2019s\nrepresented as `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "BaseURL.join()", "path": "urls/index#werkzeug.urls.BaseURL.join", "type": "werkzeug.urls", "text": "\nJoins this URL with another one. This is just a convenience function for\ncalling into `url_join()` and then parsing the return value again.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "BaseURL.replace()", "path": "urls/index#werkzeug.urls.BaseURL.replace", "type": "werkzeug.urls", "text": "\nReturn an URL with the same values, except for those parameters given new\nvalues by whichever keyword arguments are specified.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "BaseURL.to_iri_tuple()", "path": "urls/index#werkzeug.urls.BaseURL.to_iri_tuple", "type": "werkzeug.urls", "text": "\nReturns a `URL` tuple that holds a IRI. This will try to decode as much\ninformation as possible in the URL without losing information similar to how a\nweb browser does it for the URL bar.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "BaseURL.to_uri_tuple()", "path": "urls/index#werkzeug.urls.BaseURL.to_uri_tuple", "type": "werkzeug.urls", "text": "\nReturns a `BytesURL` tuple that holds a URI. This will encode all the\ninformation in the URL properly to ASCII using the rules a web browser would\nfollow.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "BaseURL.to_url()", "path": "urls/index#werkzeug.urls.BaseURL.to_url", "type": "werkzeug.urls", "text": "\nReturns a URL string or bytes depending on the type of the information stored.\nThis is just a convenience function for calling `url_unparse()` for this URL.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Basic HTTP Proxy", "path": "middleware/http_proxy/index", "type": "Other", "text": "\nProxy requests under a path to an external server, routing other requests to\nthe app.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "bind_arguments()", "path": "utils/index#werkzeug.utils.bind_arguments", "type": "werkzeug.utils", "text": "\nBind the arguments provided into a dict. When passed a function, a tuple of\narguments and a dict of keyword arguments `bind_arguments` returns a dict of\nnames as the function would see it. This can be useful to implement a cache\ndecorator that uses the function arguments to build the cache key based on the\nvalues of the arguments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "BrokenFilesystemWarning", "path": "filesystem/index#werkzeug.filesystem.BrokenFilesystemWarning", "type": "werkzeug.filesystem", "text": "\nThe warning used by Werkzeug to signal a broken filesystem. Will only be used\nonce per runtime.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "BSD-3-Clause License", "path": "license/index", "type": "Other", "text": "\nCopyright 2007 Pallets\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "BytesURL", "path": "urls/index#werkzeug.urls.BytesURL", "type": "werkzeug.urls", "text": "\nRepresents a parsed URL in bytes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "BytesURL.decode()", "path": "urls/index#werkzeug.urls.BytesURL.decode", "type": "werkzeug.urls", "text": "\nDecodes the URL to a tuple made out of strings. The charset is only being used\nfor the path, query and fragment.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "BytesURL.encode_netloc()", "path": "urls/index#werkzeug.urls.BytesURL.encode_netloc", "type": "werkzeug.urls", "text": "\nReturns the netloc unchanged as bytes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "cached_property", "path": "utils/index#werkzeug.utils.cached_property", "type": "werkzeug.utils", "text": "\nA `property()` that is only evaluated once. Subsequent access returns the\ncached value. Setting the property sets the cached value. Deleting the\nproperty clears the cached value, accessing it again will evaluate it again.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "CGI", "path": "deployment/cgi/index", "type": "Other", "text": "\nIf all other deployment methods do not work, CGI will work for sure. CGI is\nsupported by all major servers but usually has a less-than-optimal\nperformance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "CharsetAccept", "path": "datastructures/index#werkzeug.datastructures.CharsetAccept", "type": "werkzeug.datastructures", "text": "\nLike `Accept` but with normalization for charsets.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "check_password_hash()", "path": "utils/index#werkzeug.security.check_password_hash", "type": "werkzeug.security", "text": "\nCheck a password against a given salted and hashed password value. In order to\nsupport unsalted legacy passwords this method supports plain text passwords,\nmd5 and sha1 hashes (both salted and unsalted).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Client", "path": "test/index#werkzeug.test.Client", "type": "werkzeug.test", "text": "\nThis class allows you to send requests to a wrapped application.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Client.delete()", "path": "test/index#werkzeug.test.Client.delete", "type": "werkzeug.test", "text": "\nCall `open()` with `method` set to `DELETE`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Client.delete_cookie()", "path": "test/index#werkzeug.test.Client.delete_cookie", "type": "werkzeug.test", "text": "\nDeletes a cookie in the test client.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Client.get()", "path": "test/index#werkzeug.test.Client.get", "type": "werkzeug.test", "text": "\nCall `open()` with `method` set to `GET`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Client.head()", "path": "test/index#werkzeug.test.Client.head", "type": "werkzeug.test", "text": "\nCall `open()` with `method` set to `HEAD`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Client.open()", "path": "test/index#werkzeug.test.Client.open", "type": "werkzeug.test", "text": "\nGenerate an environ dict from the given arguments, make a request to the\napplication using it, and return the response.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Client.options()", "path": "test/index#werkzeug.test.Client.options", "type": "werkzeug.test", "text": "\nCall `open()` with `method` set to `OPTIONS`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Client.patch()", "path": "test/index#werkzeug.test.Client.patch", "type": "werkzeug.test", "text": "\nCall `open()` with `method` set to `PATCH`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Client.post()", "path": "test/index#werkzeug.test.Client.post", "type": "werkzeug.test", "text": "\nCall `open()` with `method` set to `POST`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Client.put()", "path": "test/index#werkzeug.test.Client.put", "type": "werkzeug.test", "text": "\nCall `open()` with `method` set to `PUT`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Client.set_cookie()", "path": "test/index#werkzeug.test.Client.set_cookie", "type": "werkzeug.test", "text": "\nSets a cookie in the client\u2019s cookie jar. The server name is required and has\nto match the one that is also passed to the open call.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Client.trace()", "path": "test/index#werkzeug.test.Client.trace", "type": "werkzeug.test", "text": "\nCall `open()` with `method` set to `TRACE`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ClosingIterator", "path": "wsgi/index#werkzeug.wsgi.ClosingIterator", "type": "werkzeug.wsgi", "text": "\nThe WSGI specification requires that all middlewares and gateways respect the\n`close` callback of the iterable returned by the application. Because it is\nuseful to add another close action to a returned iterable and adding a custom\niterable is a boring task this class can be used for that:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "CombinedMultiDict", "path": "datastructures/index#werkzeug.datastructures.CombinedMultiDict", "type": "werkzeug.datastructures", "text": "\nA read only `MultiDict` that you can pass multiple `MultiDict` instances as\nsequence and it will combine the return values of all wrapped dicts:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ContentRange", "path": "datastructures/index#werkzeug.datastructures.ContentRange", "type": "werkzeug.datastructures", "text": "\nRepresents the content range header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ContentRange.set()", "path": "datastructures/index#werkzeug.datastructures.ContentRange.set", "type": "werkzeug.datastructures", "text": "\nSimple method to update the ranges.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ContentRange.unset()", "path": "datastructures/index#werkzeug.datastructures.ContentRange.unset", "type": "werkzeug.datastructures", "text": "\nSets the units to `None` which indicates that the header should no longer be\nused.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Context Locals", "path": "local/index", "type": "Other", "text": "\nSooner or later you have some things you want to have in every single view or\nhelper function or whatever. In PHP the way to go are global variables.\nHowever, that isn\u2019t possible in WSGI applications without a major drawback: As\nsoon as you operate on the global namespace your application isn\u2019t thread-safe\nany longer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "cookie_date()", "path": "http/index#werkzeug.http.cookie_date", "type": "werkzeug.http", "text": "\nFormat a datetime object or timestamp into an RFC 2822 date string for `Set-\nCookie expires`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "create_environ()", "path": "test/index#werkzeug.test.create_environ", "type": "werkzeug.test", "text": "\nCreate a new WSGI environ dict based on the values passed. The first parameter\nshould be the path of the request which defaults to \u2018/\u2019. The second one can\neither be an absolute path (in that case the host is localhost:80) or a full\npath to the request with scheme, netloc port and the path to the script.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Data Structures", "path": "datastructures/index", "type": "Other", "text": "\nWerkzeug provides some subclasses of common Python objects to extend them with\nadditional features. Some of them are used to make them immutable, others are\nused to change some semantics to better work with HTTP.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Dealing with Request Data", "path": "request_data/index", "type": "Other", "text": "\nThe most important rule about web development is \u201cDo not trust the user\u201d. This\nis especially true for incoming request data on the input stream. With WSGI\nthis is actually a bit harder than you would expect. Because of that Werkzeug\nwraps the request stream for you to save you from the most prominent problems\nwith it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "DebuggedApplication", "path": "debug/index#werkzeug.debug.DebuggedApplication", "type": "werkzeug.debug", "text": "\nEnables debugging support for a given application:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Debugging Applications", "path": "debug/index", "type": "Other", "text": "\nDepending on the WSGI gateway/server, exceptions are handled differently. Most\nof the time, exceptions go to stderr or the error log, and a generic \u201c500\nInternal Server Error\u201d message is displayed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "DispatcherMiddleware", "path": "middleware/dispatcher/index#werkzeug.middleware.dispatcher.DispatcherMiddleware", "type": "werkzeug.middleware.dispatcher", "text": "\nCombine multiple applications as a single WSGI application. Requests are\ndispatched to an application based on the path it is mounted under.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dump_cookie()", "path": "http/index#werkzeug.http.dump_cookie", "type": "werkzeug.http", "text": "\nCreate a Set-Cookie header without the `Set-Cookie` prefix.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "dump_header()", "path": "http/index#werkzeug.http.dump_header", "type": "werkzeug.http", "text": "\nDump an HTTP header again. This is the reversal of `parse_list_header()`,\n`parse_set_header()` and `parse_dict_header()`. This also quotes strings that\ninclude an equals sign unless you pass it as dict of key, value pairs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "EndpointPrefix", "path": "routing/index#werkzeug.routing.EndpointPrefix", "type": "werkzeug.routing", "text": "\nPrefixes all endpoints (which must be strings for this factory) with another\nstring. This can be useful for sub applications:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "EnvironBuilder", "path": "test/index#werkzeug.test.EnvironBuilder", "type": "werkzeug.test", "text": "\nThis class can be used to conveniently create a WSGI environment for testing\npurposes. It can be used to quickly create WSGI environments or request\nobjects from arbitrary data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "EnvironBuilder.close()", "path": "test/index#werkzeug.test.EnvironBuilder.close", "type": "werkzeug.test", "text": "\nCloses all files. If you put real `file` objects into the `files` dict you can\ncall this method to automatically close them all in one go.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "EnvironBuilder.from_environ()", "path": "test/index#werkzeug.test.EnvironBuilder.from_environ", "type": "werkzeug.test", "text": "\nTurn an environ dict back into a builder. Any extra kwargs override the args\nextracted from the environ.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "EnvironBuilder.get_environ()", "path": "test/index#werkzeug.test.EnvironBuilder.get_environ", "type": "werkzeug.test", "text": "\nReturn the built environ.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "EnvironBuilder.get_request()", "path": "test/index#werkzeug.test.EnvironBuilder.get_request", "type": "werkzeug.test", "text": "\nReturns a request with the data. If the request class is not specified\n`request_class` is used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "EnvironBuilder.json_dumps()", "path": "test/index#werkzeug.test.EnvironBuilder.json_dumps", "type": "werkzeug.test", "text": "\nThe serialization function used when `json` is passed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "EnvironBuilder.request_class", "path": "test/index#werkzeug.test.EnvironBuilder.request_class", "type": "werkzeug.test", "text": "\nalias of `werkzeug.wrappers.request.Request`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "EnvironBuilder.server_protocol", "path": "test/index#werkzeug.test.EnvironBuilder.server_protocol", "type": "werkzeug.test", "text": "\nthe server protocol to use. defaults to HTTP/1.1\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "EnvironBuilder.wsgi_version", "path": "test/index#werkzeug.test.EnvironBuilder.wsgi_version", "type": "werkzeug.test", "text": "\nthe wsgi version to use. defaults to (1, 0)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "EnvironHeaders", "path": "datastructures/index#werkzeug.datastructures.EnvironHeaders", "type": "werkzeug.datastructures", "text": "\nRead only version of the headers from a WSGI environment. This provides the\nsame interface as `Headers` and is constructed from a WSGI environment.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "environ_property", "path": "utils/index#werkzeug.utils.environ_property", "type": "werkzeug.utils", "text": "\nMaps request attributes to environment variables. This works not only for the\nWerkzeug request object, but also any other class with an environ attribute:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "escape()", "path": "utils/index#werkzeug.utils.escape", "type": "werkzeug.utils", "text": "\nReplace `&`, `<`, `>`, `\"`, and `'` with HTML-safe sequences.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ETags", "path": "datastructures/index#werkzeug.datastructures.ETags", "type": "werkzeug.datastructures", "text": "\nA set that can be used to check if one etag is present in a collection of\netags.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ETags.as_set()", "path": "datastructures/index#werkzeug.datastructures.ETags.as_set", "type": "werkzeug.datastructures", "text": "\nConvert the `ETags` object into a python set. Per default all the weak etags\nare not part of this set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ETags.contains()", "path": "datastructures/index#werkzeug.datastructures.ETags.contains", "type": "werkzeug.datastructures", "text": "\nCheck if an etag is part of the set ignoring weak tags. It is also possible to\nuse the `in` operator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ETags.contains_raw()", "path": "datastructures/index#werkzeug.datastructures.ETags.contains_raw", "type": "werkzeug.datastructures", "text": "\nWhen passed a quoted tag it will check if this tag is part of the set. If the\ntag is weak it is checked against weak and strong tags, otherwise strong only.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ETags.contains_weak()", "path": "datastructures/index#werkzeug.datastructures.ETags.contains_weak", "type": "werkzeug.datastructures", "text": "\nCheck if an etag is part of the set including weak and strong tags.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ETags.is_strong()", "path": "datastructures/index#werkzeug.datastructures.ETags.is_strong", "type": "werkzeug.datastructures", "text": "\nCheck if an etag is strong.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ETags.is_weak()", "path": "datastructures/index#werkzeug.datastructures.ETags.is_weak", "type": "werkzeug.datastructures", "text": "\nCheck if an etag is weak.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ETags.to_header()", "path": "datastructures/index#werkzeug.datastructures.ETags.to_header", "type": "werkzeug.datastructures", "text": "\nConvert the etags set into a HTTP header string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "extract_path_info()", "path": "wsgi/index#werkzeug.wsgi.extract_path_info", "type": "werkzeug.wsgi", "text": "\nExtracts the path info from the given URL (or WSGI environment) and path. The\npath info returned is a string. The URLs might also be IRIs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "FastCGI", "path": "deployment/fastcgi/index", "type": "Other", "text": "\nA very popular deployment setup on servers like lighttpd and nginx is FastCGI.\nTo use your WSGI application with any of them you will need a FastCGI server\nfirst.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "FileMultiDict", "path": "datastructures/index#werkzeug.datastructures.FileMultiDict", "type": "werkzeug.datastructures", "text": "\nA special `MultiDict` that has convenience methods to add files to it. This is\nused for `EnvironBuilder` and generally useful for unittesting.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "FileMultiDict.add_file()", "path": "datastructures/index#werkzeug.datastructures.FileMultiDict.add_file", "type": "werkzeug.datastructures", "text": "\nAdds a new file to the dict. `file` can be a file name or a `file`-like or a\n`FileStorage` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "FileStorage", "path": "datastructures/index#werkzeug.datastructures.FileStorage", "type": "werkzeug.datastructures", "text": "\nThe `FileStorage` class is a thin wrapper over incoming files. It is used by\nthe request object to represent uploaded files. All the attributes of the\nwrapper stream are proxied by the file storage so it\u2019s possible to do\n`storage.read()` instead of the long form `storage.stream.read()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "FileStorage.close()", "path": "datastructures/index#werkzeug.datastructures.FileStorage.close", "type": "werkzeug.datastructures", "text": "\nClose the underlying file if possible.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "FileStorage.filename", "path": "datastructures/index#werkzeug.datastructures.FileStorage.filename", "type": "werkzeug.datastructures", "text": "\nThe filename of the file on the client.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "FileStorage.headers", "path": "datastructures/index#werkzeug.datastructures.FileStorage.headers", "type": "werkzeug.datastructures", "text": "\nThe multipart headers as `Headers` object. This usually contains irrelevant\ninformation but in combination with custom multipart requests the raw headers\nmight be interesting.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "FileStorage.name", "path": "datastructures/index#werkzeug.datastructures.FileStorage.name", "type": "werkzeug.datastructures", "text": "\nThe name of the form field.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "FileStorage.save()", "path": "datastructures/index#werkzeug.datastructures.FileStorage.save", "type": "werkzeug.datastructures", "text": "\nSave the file to a destination path or file object. If the destination is a\nfile object you have to close it yourself after the call. The buffer size is\nthe number of bytes held in memory during the copy process. It defaults to\n16KB.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "FileStorage.stream", "path": "datastructures/index#werkzeug.datastructures.FileStorage.stream", "type": "werkzeug.datastructures", "text": "\nThe input stream for the uploaded file. This usually points to an open\ntemporary file.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Filesystem Utilities", "path": "filesystem/index", "type": "Other", "text": "\nVarious utilities for the local filesystem.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "FileWrapper", "path": "wsgi/index#werkzeug.wsgi.FileWrapper", "type": "werkzeug.wsgi", "text": "\nThis class can be used to convert a `file`-like object into an iterable. It\nyields `buffer_size` blocks until the file is fully read.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "find_modules()", "path": "utils/index#werkzeug.utils.find_modules", "type": "werkzeug.utils", "text": "\nFinds all the modules below a package. This can be useful to automatically\nimport all views / controllers so that their metaclasses / function decorators\nhave a chance to register themselves on the application.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "FloatConverter", "path": "routing/index#werkzeug.routing.FloatConverter", "type": "werkzeug.routing", "text": "\nThis converter only accepts floating point values:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "FormDataParser", "path": "http/index#werkzeug.formparser.FormDataParser", "type": "werkzeug.formparser", "text": "\nThis class implements parsing of form data for Werkzeug. By itself it can\nparse multipart and url encoded form data. It can be subclassed and extended\nbut for most mimetypes it is a better idea to use the untouched stream and\nexpose it as separate attributes on a request object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "generate_etag()", "path": "http/index#werkzeug.http.generate_etag", "type": "werkzeug.http", "text": "\nGenerate an etag for some data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "generate_password_hash()", "path": "utils/index#werkzeug.security.generate_password_hash", "type": "werkzeug.security", "text": "\nHash a password with the given method and salt with a string of the given\nlength. The format of the string returned includes the method that was used so\nthat `check_password_hash()` can check the hash.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "get_content_length()", "path": "wsgi/index#werkzeug.wsgi.get_content_length", "type": "werkzeug.wsgi", "text": "\nReturns the content length from the WSGI environment as integer. If it\u2019s not\navailable or chunked transfer encoding is used, `None` is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "get_current_url()", "path": "wsgi/index#werkzeug.wsgi.get_current_url", "type": "werkzeug.wsgi", "text": "\nRecreate the URL for a request from the parts in a WSGI environment.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "get_filesystem_encoding()", "path": "filesystem/index#werkzeug.filesystem.get_filesystem_encoding", "type": "werkzeug.filesystem", "text": "\nReturns the filesystem encoding that should be used. Note that this is\ndifferent from the Python understanding of the filesystem encoding which might\nbe deeply flawed. Do not use this value against Python\u2019s string APIs because\nit might be different. See The Filesystem for the exact behavior.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "get_host()", "path": "wsgi/index#werkzeug.wsgi.get_host", "type": "werkzeug.wsgi", "text": "\nReturn the host for the given WSGI environment.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "get_input_stream()", "path": "wsgi/index#werkzeug.wsgi.get_input_stream", "type": "werkzeug.wsgi", "text": "\nReturns the input stream from the WSGI environment and wraps it in the most\nsensible way possible. The stream returned is not the raw WSGI stream in most\ncases but one that is safe to read from without taking into account the\ncontent length.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "get_path_info()", "path": "wsgi/index#werkzeug.wsgi.get_path_info", "type": "werkzeug.wsgi", "text": "\nReturn the `PATH_INFO` from the WSGI environment and decode it unless\n`charset` is `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "get_query_string()", "path": "wsgi/index#werkzeug.wsgi.get_query_string", "type": "werkzeug.wsgi", "text": "\nReturns the `QUERY_STRING` from the WSGI environment. This also takes care of\nthe WSGI decoding dance. The string returned will be restricted to ASCII\ncharacters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "get_script_name()", "path": "wsgi/index#werkzeug.wsgi.get_script_name", "type": "werkzeug.wsgi", "text": "\nReturn the `SCRIPT_NAME` from the WSGI environment and decode it unless\n`charset` is set to `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Headers", "path": "datastructures/index#werkzeug.datastructures.Headers", "type": "werkzeug.datastructures", "text": "\nAn object that stores some headers. It has a dict-like interface, but is\nordered, can store the same key multiple times, and iterating yields `(key,\nvalue)` pairs instead of only keys.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Headers.add()", "path": "datastructures/index#werkzeug.datastructures.Headers.add", "type": "werkzeug.datastructures", "text": "\nAdd a new header tuple to the list.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Headers.add_header()", "path": "datastructures/index#werkzeug.datastructures.Headers.add_header", "type": "werkzeug.datastructures", "text": "\nAdd a new header tuple to the list.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Headers.clear()", "path": "datastructures/index#werkzeug.datastructures.Headers.clear", "type": "werkzeug.datastructures", "text": "\nClears all headers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Headers.extend()", "path": "datastructures/index#werkzeug.datastructures.Headers.extend", "type": "werkzeug.datastructures", "text": "\nExtend headers in this object with items from another object containing header\nitems as well as keyword arguments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Headers.get()", "path": "datastructures/index#werkzeug.datastructures.Headers.get", "type": "werkzeug.datastructures", "text": "\nReturn the default value if the requested data doesn\u2019t exist. If `type` is\nprovided and is a callable it should convert the value, return it or raise a\n`ValueError` if that is not possible. In this case the function will return\nthe default as if the value was not found:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Headers.getlist()", "path": "datastructures/index#werkzeug.datastructures.Headers.getlist", "type": "werkzeug.datastructures", "text": "\nReturn the list of items for a given key. If that key is not in the `Headers`,\nthe return value will be an empty list. Just like `get()`, `getlist()` accepts\na `type` parameter. All items will be converted with the callable defined\nthere.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Headers.get_all()", "path": "datastructures/index#werkzeug.datastructures.Headers.get_all", "type": "werkzeug.datastructures", "text": "\nReturn a list of all the values for the named field.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Headers.has_key()", "path": "datastructures/index#werkzeug.datastructures.Headers.has_key", "type": "werkzeug.datastructures", "text": "\nDeprecated since version 2.0: Will be removed in Werkzeug 2.1. Use `key in\ndata` instead.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Headers.pop()", "path": "datastructures/index#werkzeug.datastructures.Headers.pop", "type": "werkzeug.datastructures", "text": "\nRemoves and returns a key or index.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Headers.popitem()", "path": "datastructures/index#werkzeug.datastructures.Headers.popitem", "type": "werkzeug.datastructures", "text": "\nRemoves a key or index and returns a (key, value) item.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Headers.remove()", "path": "datastructures/index#werkzeug.datastructures.Headers.remove", "type": "werkzeug.datastructures", "text": "\nRemove a key.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Headers.set()", "path": "datastructures/index#werkzeug.datastructures.Headers.set", "type": "werkzeug.datastructures", "text": "\nRemove all header tuples for `key` and add a new one. The newly added key\neither appears at the end of the list if there was no entry or replaces the\nfirst one.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Headers.setdefault()", "path": "datastructures/index#werkzeug.datastructures.Headers.setdefault", "type": "werkzeug.datastructures", "text": "\nReturn the first value for the key if it is in the headers, otherwise set the\nheader to the value given by `default` and return that.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Headers.setlist()", "path": "datastructures/index#werkzeug.datastructures.Headers.setlist", "type": "werkzeug.datastructures", "text": "\nRemove any existing values for a header and add new ones.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Headers.setlistdefault()", "path": "datastructures/index#werkzeug.datastructures.Headers.setlistdefault", "type": "werkzeug.datastructures", "text": "\nReturn the list of values for the key if it is in the headers, otherwise set\nthe header to the list of values given by `default` and return that.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Headers.to_wsgi_list()", "path": "datastructures/index#werkzeug.datastructures.Headers.to_wsgi_list", "type": "werkzeug.datastructures", "text": "\nConvert the headers into a list suitable for WSGI.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Headers.update()", "path": "datastructures/index#werkzeug.datastructures.Headers.update", "type": "werkzeug.datastructures", "text": "\nReplace headers in this object with items from another headers object and\nkeyword arguments.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "HeaderSet", "path": "datastructures/index#werkzeug.datastructures.HeaderSet", "type": "werkzeug.datastructures", "text": "\nSimilar to the `ETags` class this implements a set-like structure. Unlike\n`ETags` this is case insensitive and used for vary, allow, and content-\nlanguage headers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "HeaderSet.add()", "path": "datastructures/index#werkzeug.datastructures.HeaderSet.add", "type": "werkzeug.datastructures", "text": "\nAdd a new header to the set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "HeaderSet.as_set()", "path": "datastructures/index#werkzeug.datastructures.HeaderSet.as_set", "type": "werkzeug.datastructures", "text": "\nReturn the set as real python set type. When calling this, all the items are\nconverted to lowercase and the ordering is lost.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "HeaderSet.clear()", "path": "datastructures/index#werkzeug.datastructures.HeaderSet.clear", "type": "werkzeug.datastructures", "text": "\nClear the set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "HeaderSet.discard()", "path": "datastructures/index#werkzeug.datastructures.HeaderSet.discard", "type": "werkzeug.datastructures", "text": "\nLike `remove()` but ignores errors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "HeaderSet.find()", "path": "datastructures/index#werkzeug.datastructures.HeaderSet.find", "type": "werkzeug.datastructures", "text": "\nReturn the index of the header in the set or return -1 if not found.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "HeaderSet.index()", "path": "datastructures/index#werkzeug.datastructures.HeaderSet.index", "type": "werkzeug.datastructures", "text": "\nReturn the index of the header in the set or raise an `IndexError`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "HeaderSet.remove()", "path": "datastructures/index#werkzeug.datastructures.HeaderSet.remove", "type": "werkzeug.datastructures", "text": "\nRemove a header from the set. This raises an `KeyError` if the header is not\nin the set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "HeaderSet.to_header()", "path": "datastructures/index#werkzeug.datastructures.HeaderSet.to_header", "type": "werkzeug.datastructures", "text": "\nConvert the header set into an HTTP header string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "HeaderSet.update()", "path": "datastructures/index#werkzeug.datastructures.HeaderSet.update", "type": "werkzeug.datastructures", "text": "\nAdd all the headers from the iterable to the set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "header_property", "path": "utils/index#werkzeug.utils.header_property", "type": "werkzeug.utils", "text": "\nLike `environ_property` but for headers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "host_is_trusted()", "path": "wsgi/index#werkzeug.wsgi.host_is_trusted", "type": "werkzeug.wsgi", "text": "\nCheck if a host matches a list of trusted names.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Href", "path": "urls/index#werkzeug.urls.Href", "type": "werkzeug.urls", "text": "\nImplements a callable that constructs URLs with the given base. The function\ncan be called with any number of positional and keyword arguments which than\nare used to assemble the URL. Works with URLs and posix paths.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "HTMLBuilder", "path": "utils/index#werkzeug.utils.HTMLBuilder", "type": "werkzeug.utils", "text": "\nHelper object for HTML generation.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "HTTP Exceptions", "path": "exceptions/index", "type": "Other", "text": "\nImplements a number of Python exceptions which can be raised from within a\nview to trigger a standard HTTP non-200 response.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "HTTP Proxying", "path": "deployment/proxying/index", "type": "Other", "text": "\nMany people prefer using a standalone Python HTTP server and proxying that\nserver via nginx, Apache etc.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "HTTP Utilities", "path": "http/index", "type": "Other", "text": "\nWerkzeug provides a couple of functions to parse and generate HTTP headers\nthat are useful when implementing WSGI middlewares or whenever you are\noperating on a lower level layer. All this functionality is also exposed from\nrequest and response objects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "HTTPException.get_response()", "path": "exceptions/index#werkzeug.exceptions.HTTPException.get_response", "type": "werkzeug.exceptions", "text": "\nGet a response object. If one was passed to the exception it\u2019s returned\ndirectly.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "HTTPException.__call__()", "path": "exceptions/index#werkzeug.exceptions.HTTPException.__call__", "type": "werkzeug.exceptions", "text": "\nCall the exception as WSGI application.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "http_date()", "path": "http/index#werkzeug.http.http_date", "type": "werkzeug.http", "text": "\nFormat a datetime object or timestamp into an RFC 2822 date string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "IfRange", "path": "datastructures/index#werkzeug.datastructures.IfRange", "type": "werkzeug.datastructures", "text": "\nVery simple object that represents the `If-Range` header in parsed form. It\nwill either have neither a etag or date or one of either but never both.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "IfRange.date", "path": "datastructures/index#werkzeug.datastructures.IfRange.date", "type": "werkzeug.datastructures", "text": "\nThe date in parsed format or `None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "IfRange.etag", "path": "datastructures/index#werkzeug.datastructures.IfRange.etag", "type": "werkzeug.datastructures", "text": "\nThe etag parsed and unquoted. Ranges always operate on strong etags so the\nweakness information is not necessary.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "IfRange.to_header()", "path": "datastructures/index#werkzeug.datastructures.IfRange.to_header", "type": "werkzeug.datastructures", "text": "\nConverts the object back into an HTTP header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ImmutableDict", "path": "datastructures/index#werkzeug.datastructures.ImmutableDict", "type": "werkzeug.datastructures", "text": "\nAn immutable `dict`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ImmutableDict.copy()", "path": "datastructures/index#werkzeug.datastructures.ImmutableDict.copy", "type": "werkzeug.datastructures", "text": "\nReturn a shallow mutable copy of this object. Keep in mind that the standard\nlibrary\u2019s `copy()` function is a no-op for this class like for any other\npython immutable type (eg: `tuple`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ImmutableList", "path": "datastructures/index#werkzeug.datastructures.ImmutableList", "type": "werkzeug.datastructures", "text": "\nAn immutable `list`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ImmutableMultiDict", "path": "datastructures/index#werkzeug.datastructures.ImmutableMultiDict", "type": "werkzeug.datastructures", "text": "\nAn immutable `MultiDict`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ImmutableMultiDict.copy()", "path": "datastructures/index#werkzeug.datastructures.ImmutableMultiDict.copy", "type": "werkzeug.datastructures", "text": "\nReturn a shallow mutable copy of this object. Keep in mind that the standard\nlibrary\u2019s `copy()` function is a no-op for this class like for any other\npython immutable type (eg: `tuple`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ImmutableOrderedMultiDict", "path": "datastructures/index#werkzeug.datastructures.ImmutableOrderedMultiDict", "type": "werkzeug.datastructures", "text": "\nAn immutable `OrderedMultiDict`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ImmutableOrderedMultiDict.copy()", "path": "datastructures/index#werkzeug.datastructures.ImmutableOrderedMultiDict.copy", "type": "werkzeug.datastructures", "text": "\nReturn a shallow mutable copy of this object. Keep in mind that the standard\nlibrary\u2019s `copy()` function is a no-op for this class like for any other\npython immutable type (eg: `tuple`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ImmutableTypeConversionDict", "path": "datastructures/index#werkzeug.datastructures.ImmutableTypeConversionDict", "type": "werkzeug.datastructures", "text": "\nWorks like a `TypeConversionDict` but does not support modifications.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ImmutableTypeConversionDict.copy()", "path": "datastructures/index#werkzeug.datastructures.ImmutableTypeConversionDict.copy", "type": "werkzeug.datastructures", "text": "\nReturn a shallow mutable copy of this object. Keep in mind that the standard\nlibrary\u2019s `copy()` function is a no-op for this class like for any other\npython immutable type (eg: `tuple`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Important Terms", "path": "terms/index", "type": "Other", "text": "\nThis page covers important terms used in the documentation and Werkzeug\nitself.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "import_string()", "path": "utils/index#werkzeug.utils.import_string", "type": "werkzeug.utils", "text": "\nImports an object based on a string. This is useful if you want to use import\npaths as endpoints or something similar. An import path can be specified\neither in dotted notation (`xml.sax.saxutils.escape`) or with a colon as\nobject delimiter (`xml.sax.saxutils:escape`).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Installation", "path": "installation/index", "type": "Other", "text": "\nWe recommend using the latest version of Python. Werkzeug supports Python 3.6\nand newer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "IntegerConverter", "path": "routing/index#werkzeug.routing.IntegerConverter", "type": "werkzeug.routing", "text": "\nThis converter only accepts integer values:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "InternalServerError.original_exception", "path": "exceptions/index#werkzeug.exceptions.InternalServerError.original_exception", "type": "werkzeug.exceptions", "text": "\nThe original exception that caused this 500 error. Can be used by frameworks\nto provide context when handling unexpected errors.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "invalidate_cached_property()", "path": "utils/index#werkzeug.utils.invalidate_cached_property", "type": "werkzeug.utils", "text": "\nInvalidates the cache for a `cached_property`:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "iri_to_uri()", "path": "urls/index#werkzeug.urls.iri_to_uri", "type": "werkzeug.urls", "text": "\nConvert an IRI to a URI. All non-ASCII and unsafe characters are quoted. If\nthe URL has a domain, it is encoded to Punycode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "is_byte_range_valid()", "path": "http/index#werkzeug.http.is_byte_range_valid", "type": "werkzeug.http", "text": "\nChecks if a given byte content range is valid for the given length.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "is_entity_header()", "path": "http/index#werkzeug.http.is_entity_header", "type": "werkzeug.http", "text": "\nCheck if a header is an entity header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "is_hop_by_hop_header()", "path": "http/index#werkzeug.http.is_hop_by_hop_header", "type": "werkzeug.http", "text": "\nCheck if a header is an HTTP/1.1 \u201cHop-by-Hop\u201d header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "is_resource_modified()", "path": "http/index#werkzeug.http.is_resource_modified", "type": "werkzeug.http", "text": "\nConvenience method for conditional requests.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "is_running_from_reloader()", "path": "serving/index#werkzeug.serving.is_running_from_reloader", "type": "werkzeug.serving", "text": "\nChecks if the application is running from within the Werkzeug reloader\nsubprocess.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "LanguageAccept", "path": "datastructures/index#werkzeug.datastructures.LanguageAccept", "type": "werkzeug.datastructures", "text": "\nLike `Accept` but with normalization for language tags.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "LimitedStream", "path": "wsgi/index#werkzeug.wsgi.LimitedStream", "type": "werkzeug.wsgi", "text": "\nWraps a stream so that it doesn\u2019t read more than n bytes. If the stream is\nexhausted and the caller tries to get more bytes from it `on_exhausted()` is\ncalled which by default returns an empty string. The return value of that\nfunction is forwarded to the reader function. So if it returns an empty string\n`read()` will return an empty string as well.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "LimitedStream.exhaust()", "path": "wsgi/index#werkzeug.wsgi.LimitedStream.exhaust", "type": "werkzeug.wsgi", "text": "\nExhaust the stream. This consumes all the data left until the limit is\nreached.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "LimitedStream.on_disconnect()", "path": "wsgi/index#werkzeug.wsgi.LimitedStream.on_disconnect", "type": "werkzeug.wsgi", "text": "\nWhat should happen if a disconnect is detected? The return value of this\nfunction is returned from read functions in case the client went away. By\ndefault a `ClientDisconnected` exception is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "LimitedStream.on_exhausted()", "path": "wsgi/index#werkzeug.wsgi.LimitedStream.on_exhausted", "type": "werkzeug.wsgi", "text": "\nThis is called when the stream tries to read past the limit. The return value\nof this function is returned from the reading function.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "LimitedStream.read()", "path": "wsgi/index#werkzeug.wsgi.LimitedStream.read", "type": "werkzeug.wsgi", "text": "\nRead `size` bytes or if size is not provided everything is read.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "LimitedStream.readable()", "path": "wsgi/index#werkzeug.wsgi.LimitedStream.readable", "type": "werkzeug.wsgi", "text": "\nReturn whether object was opened for reading.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "LimitedStream.readline()", "path": "wsgi/index#werkzeug.wsgi.LimitedStream.readline", "type": "werkzeug.wsgi", "text": "\nReads one line from the stream.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "LimitedStream.readlines()", "path": "wsgi/index#werkzeug.wsgi.LimitedStream.readlines", "type": "werkzeug.wsgi", "text": "\nReads a file into a list of strings. It calls `readline()` until the file is\nread to the end. It does support the optional `size` argument if the\nunderlying stream supports it for `readline`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "LimitedStream.tell()", "path": "wsgi/index#werkzeug.wsgi.LimitedStream.tell", "type": "werkzeug.wsgi", "text": "\nReturns the position of the stream.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "LintMiddleware", "path": "middleware/lint/index#werkzeug.middleware.lint.LintMiddleware", "type": "werkzeug.middleware.lint", "text": "\nWarns about common errors in the WSGI and HTTP behavior of the server and\nwrapped application. Some of the issues it checks are:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "LocalManager", "path": "local/index#werkzeug.local.LocalManager", "type": "werkzeug.local", "text": "\nLocal objects cannot manage themselves. For that you need a local manager. You\ncan pass a local manager multiple locals or add them later y appending them to\n`manager.locals`. Every time the manager cleans up, it will clean up all the\ndata left in the locals for this context.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "LocalManager.cleanup()", "path": "local/index#werkzeug.local.LocalManager.cleanup", "type": "werkzeug.local", "text": "\nManually clean up the data in the locals for this context. Call this at the\nend of the request or use `make_middleware()`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "LocalManager.get_ident()", "path": "local/index#werkzeug.local.LocalManager.get_ident", "type": "werkzeug.local", "text": "\nReturn the context identifier the local objects use internally for this\ncontext. You cannot override this method to change the behavior but use it to\nlink other context local objects (such as SQLAlchemy\u2019s scoped sessions) to the\nWerkzeug locals.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "LocalManager.make_middleware()", "path": "local/index#werkzeug.local.LocalManager.make_middleware", "type": "werkzeug.local", "text": "\nWrap a WSGI application so that cleaning up happens after request end.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "LocalManager.middleware()", "path": "local/index#werkzeug.local.LocalManager.middleware", "type": "werkzeug.local", "text": "\nLike `make_middleware` but for decorating functions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "LocalProxy", "path": "local/index#werkzeug.local.LocalProxy", "type": "werkzeug.local", "text": "\nA proxy to the object bound to a `Local`. All operations on the proxy are\nforwarded to the bound object. If no object is bound, a `RuntimeError` is\nraised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "LocalProxy._get_current_object()", "path": "local/index#werkzeug.local.LocalProxy._get_current_object", "type": "werkzeug.local", "text": "\nReturn the current object. This is useful if you want the real object behind\nthe proxy at a time for performance reasons or because you want to pass the\nobject into a different context.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "LocalStack", "path": "local/index#werkzeug.local.LocalStack", "type": "werkzeug.local", "text": "\nThis class works similar to a `Local` but keeps a stack of objects instead.\nThis is best explained with an example:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "LocalStack.pop()", "path": "local/index#werkzeug.local.LocalStack.pop", "type": "werkzeug.local", "text": "\nRemoves the topmost item from the stack, will return the old value or `None`\nif the stack was already empty.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "LocalStack.push()", "path": "local/index#werkzeug.local.LocalStack.push", "type": "werkzeug.local", "text": "\nPushes a new item to the stack\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "make_chunk_iter()", "path": "wsgi/index#werkzeug.wsgi.make_chunk_iter", "type": "werkzeug.wsgi", "text": "\nWorks like `make_line_iter()` but accepts a separator which divides chunks. If\nyou want newline based processing you should use `make_line_iter()` instead as\nit supports arbitrary newline markers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "make_line_iter()", "path": "wsgi/index#werkzeug.wsgi.make_line_iter", "type": "werkzeug.wsgi", "text": "\nSafely iterates line-based over an input stream. If the input stream is not a\n`LimitedStream` the `limit` parameter is mandatory.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "make_ssl_devcert()", "path": "serving/index#werkzeug.serving.make_ssl_devcert", "type": "werkzeug.serving", "text": "\nCreates an SSL key for development. This should be used instead of the\n`'adhoc'` key which generates a new cert on each server start. It accepts a\npath for where it should store the key and cert and either a host or CN. If a\nhost is given it will use the CN `*.host/CN=host`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Map", "path": "routing/index#werkzeug.routing.Map", "type": "werkzeug.routing", "text": "\nThe map class stores all the URL rules and some configuration parameters. Some\nof the configuration values are only stored on the `Map` instance since those\naffect all rules, others are just defaults and can be overridden for each\nrule. Note that you have to specify all arguments besides the `rules` as\nkeyword arguments!\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Map.add()", "path": "routing/index#werkzeug.routing.Map.add", "type": "werkzeug.routing", "text": "\nAdd a new rule or factory to the map and bind it. Requires that the rule is\nnot bound to another map.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Map.bind()", "path": "routing/index#werkzeug.routing.Map.bind", "type": "werkzeug.routing", "text": "\nReturn a new `MapAdapter` with the details specified to the call. Note that\n`script_name` will default to `'/'` if not further specified or `None`. The\n`server_name` at least is a requirement because the HTTP RFC requires absolute\nURLs for redirects and so all redirect exceptions raised by Werkzeug will\ncontain the full canonical URL.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Map.bind_to_environ()", "path": "routing/index#werkzeug.routing.Map.bind_to_environ", "type": "werkzeug.routing", "text": "\nLike `bind()` but you can pass it an WSGI environment and it will fetch the\ninformation from that dictionary. Note that because of limitations in the\nprotocol there is no way to get the current subdomain and real `server_name`\nfrom the environment. If you don\u2019t provide it, Werkzeug will use `SERVER_NAME`\nand `SERVER_PORT` (or `HTTP_HOST` if provided) as used `server_name` with\ndisabled subdomain feature.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Map.converters", "path": "routing/index#werkzeug.routing.Map.converters", "type": "werkzeug.routing", "text": "\nThe dictionary of converters. This can be modified after the class was\ncreated, but will only affect rules added after the modification. If the rules\nare defined with the list passed to the class, the `converters` parameter to\nthe constructor has to be used instead.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Map.default_converters", "path": "routing/index#werkzeug.routing.Map.default_converters", "type": "werkzeug.routing", "text": "\nA dict of default converters to be used.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Map.is_endpoint_expecting()", "path": "routing/index#werkzeug.routing.Map.is_endpoint_expecting", "type": "werkzeug.routing", "text": "\nIterate over all rules and check if the endpoint expects the arguments\nprovided. This is for example useful if you have some URLs that expect a\nlanguage code and others that do not and you want to wrap the builder a bit so\nthat the current language code is automatically added if not provided but\nendpoints expect it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Map.iter_rules()", "path": "routing/index#werkzeug.routing.Map.iter_rules", "type": "werkzeug.routing", "text": "\nIterate over all rules or the rules of an endpoint.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Map.lock_class()", "path": "routing/index#werkzeug.routing.Map.lock_class", "type": "werkzeug.routing", "text": "\nThe type of lock to use when updating.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Map.update()", "path": "routing/index#werkzeug.routing.Map.update", "type": "werkzeug.routing", "text": "\nCalled before matching and building to keep the compiled rules in the correct\norder after things changed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "MapAdapter", "path": "routing/index#werkzeug.routing.MapAdapter", "type": "werkzeug.routing", "text": "\nReturned by `Map.bind()` or `Map.bind_to_environ()` and does the URL matching\nand building based on runtime information.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "MapAdapter.allowed_methods()", "path": "routing/index#werkzeug.routing.MapAdapter.allowed_methods", "type": "werkzeug.routing", "text": "\nReturns the valid methods that match for a given path.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "MapAdapter.build()", "path": "routing/index#werkzeug.routing.MapAdapter.build", "type": "werkzeug.routing", "text": "\nBuilding URLs works pretty much the other way round. Instead of `match` you\ncall `build` and pass it the endpoint and a dict of arguments for the\nplaceholders.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "MapAdapter.dispatch()", "path": "routing/index#werkzeug.routing.MapAdapter.dispatch", "type": "werkzeug.routing", "text": "\nDoes the complete dispatching process. `view_func` is called with the endpoint\nand a dict with the values for the view. It should look up the view function,\ncall it, and return a response object or WSGI application. http exceptions are\nnot caught by default so that applications can display nicer error messages by\njust catching them by hand. If you want to stick with the default error\nmessages you can pass it `catch_http_exceptions=True` and it will catch the\nhttp exceptions.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "MapAdapter.get_host()", "path": "routing/index#werkzeug.routing.MapAdapter.get_host", "type": "werkzeug.routing", "text": "\nFigures out the full host name for the given domain part. The domain part is a\nsubdomain in case host matching is disabled or a full host name.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "MapAdapter.make_alias_redirect_url()", "path": "routing/index#werkzeug.routing.MapAdapter.make_alias_redirect_url", "type": "werkzeug.routing", "text": "\nInternally called to make an alias redirect URL.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "MapAdapter.match()", "path": "routing/index#werkzeug.routing.MapAdapter.match", "type": "werkzeug.routing", "text": "\nThe usage is simple: you just pass the match method the current path info as\nwell as the method (which defaults to `GET`). The following things can then\nhappen:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "MapAdapter.test()", "path": "routing/index#werkzeug.routing.MapAdapter.test", "type": "werkzeug.routing", "text": "\nTest if a rule would match. Works like `match` but returns `True` if the URL\nmatches, or `False` if it does not exist.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Middleware", "path": "middleware/index", "type": "Other", "text": "\nA WSGI middleware is a WSGI application that wraps another application in\norder to observe or change its behavior. Werkzeug provides some middleware for\ncommon use cases.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "MIMEAccept", "path": "datastructures/index#werkzeug.datastructures.MIMEAccept", "type": "werkzeug.datastructures", "text": "\nLike `Accept` but with special methods and behavior for mimetypes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "mod_wsgi (Apache)", "path": "deployment/mod_wsgi/index", "type": "Other", "text": "\nIf you are using the Apache webserver you should consider using mod_wsgi.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "MultiDict", "path": "datastructures/index#werkzeug.datastructures.MultiDict", "type": "werkzeug.datastructures", "text": "\nA `MultiDict` is a dictionary subclass customized to deal with multiple values\nfor the same key which is for example used by the parsing functions in the\nwrappers. This is necessary because some HTML form elements pass multiple\nvalues for the same key.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "MultiDict.add()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.add", "type": "werkzeug.datastructures", "text": "\nAdds a new value for the key.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "MultiDict.clear()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.clear", "type": "werkzeug.datastructures", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "MultiDict.copy()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.copy", "type": "werkzeug.datastructures", "text": "\nReturn a shallow copy of this object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "MultiDict.deepcopy()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.deepcopy", "type": "werkzeug.datastructures", "text": "\nReturn a deep copy of this object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "MultiDict.fromkeys()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.fromkeys", "type": "werkzeug.datastructures", "text": "\nCreate a new dictionary with keys from iterable and values set to value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "MultiDict.get()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.get", "type": "werkzeug.datastructures", "text": "\nReturn the default value if the requested data doesn\u2019t exist. If `type` is\nprovided and is a callable it should convert the value, return it or raise a\n`ValueError` if that is not possible. In this case the function will return\nthe default as if the value was not found:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "MultiDict.getlist()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.getlist", "type": "werkzeug.datastructures", "text": "\nReturn the list of items for a given key. If that key is not in the\n`MultiDict`, the return value will be an empty list. Just like `get`,\n`getlist` accepts a `type` parameter. All items will be converted with the\ncallable defined there.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "MultiDict.items()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.items", "type": "werkzeug.datastructures", "text": "\nReturn an iterator of `(key, value)` pairs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "MultiDict.keys()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.keys", "type": "werkzeug.datastructures", "text": "\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "MultiDict.lists()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.lists", "type": "werkzeug.datastructures", "text": "\nReturn a iterator of `(key, values)` pairs, where values is the list of all\nvalues associated with the key.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "MultiDict.listvalues()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.listvalues", "type": "werkzeug.datastructures", "text": "\nReturn an iterator of all values associated with a key. Zipping `keys()` and\nthis is the same as calling `lists()`:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "MultiDict.pop()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.pop", "type": "werkzeug.datastructures", "text": "\nPop the first item for a list on the dict. Afterwards the key is removed from\nthe dict, so additional values are discarded:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "MultiDict.popitem()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.popitem", "type": "werkzeug.datastructures", "text": "\nPop an item from the dict.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "MultiDict.popitemlist()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.popitemlist", "type": "werkzeug.datastructures", "text": "\nPop a `(key, list)` tuple from the dict.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "MultiDict.poplist()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.poplist", "type": "werkzeug.datastructures", "text": "\nPop the list for a key from the dict. If the key is not in the dict an empty\nlist is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "MultiDict.setdefault()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.setdefault", "type": "werkzeug.datastructures", "text": "\nReturns the value for the key if it is in the dict, otherwise it returns\n`default` and sets that value for `key`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "MultiDict.setlist()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.setlist", "type": "werkzeug.datastructures", "text": "\nRemove the old values for a key and add new ones. Note that the list you pass\nthe values in will be shallow-copied before it is inserted in the dictionary.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "MultiDict.setlistdefault()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.setlistdefault", "type": "werkzeug.datastructures", "text": "\nLike `setdefault` but sets multiple values. The list returned is not a copy,\nbut the list that is actually used internally. This means that you can put new\nvalues into the dict by appending items to the list:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "MultiDict.to_dict()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.to_dict", "type": "werkzeug.datastructures", "text": "\nReturn the contents as regular dict. If `flat` is `True` the returned dict\nwill only have the first item present, if `flat` is `False` all values will be\nreturned as lists.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "MultiDict.update()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.update", "type": "werkzeug.datastructures", "text": "\nupdate() extends rather than replaces existing key lists:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "MultiDict.values()", "path": "datastructures/index#werkzeug.datastructures.MultiDict.values", "type": "werkzeug.datastructures", "text": "\nReturns an iterator of the first value on every key\u2019s value list.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "OrderedMultiDict", "path": "datastructures/index#werkzeug.datastructures.OrderedMultiDict", "type": "werkzeug.datastructures", "text": "\nWorks like a regular `MultiDict` but preserves the order of the fields. To\nconvert the ordered multi dict into a list you can use the `items()` method\nand pass it `multi=True`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "parse_accept_header()", "path": "http/index#werkzeug.http.parse_accept_header", "type": "werkzeug.http", "text": "\nParses an HTTP Accept-* header. This does not implement a complete valid\nalgorithm but one that supports at least value and quality extraction.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "parse_authorization_header()", "path": "http/index#werkzeug.http.parse_authorization_header", "type": "werkzeug.http", "text": "\nParse an HTTP basic/digest authorization header transmitted by the web\nbrowser. The return value is either `None` if the header was invalid or not\ngiven, otherwise an `Authorization` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "parse_cache_control_header()", "path": "http/index#werkzeug.http.parse_cache_control_header", "type": "werkzeug.http", "text": "\nParse a cache control header. The RFC differs between response and request\ncache control, this method does not. It\u2019s your responsibility to not use the\nwrong control statements.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "parse_content_range_header()", "path": "http/index#werkzeug.http.parse_content_range_header", "type": "werkzeug.http", "text": "\nParses a range header into a `ContentRange` object or `None` if parsing is not\npossible.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "parse_cookie()", "path": "http/index#werkzeug.http.parse_cookie", "type": "werkzeug.http", "text": "\nParse a cookie from a string or WSGI environ.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "parse_date()", "path": "http/index#werkzeug.http.parse_date", "type": "werkzeug.http", "text": "\nParse an RFC 2822 date into a timezone-aware `datetime.datetime` object, or\n`None` if parsing fails.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "parse_dict_header()", "path": "http/index#werkzeug.http.parse_dict_header", "type": "werkzeug.http", "text": "\nParse lists of key, value pairs as described by RFC 2068 Section 2 and convert\nthem into a python dict (or any other mapping object created from the type\nwith a dict like interface provided by the `cls` argument):\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "parse_etags()", "path": "http/index#werkzeug.http.parse_etags", "type": "werkzeug.http", "text": "\nParse an etag header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "parse_form_data()", "path": "http/index#werkzeug.formparser.parse_form_data", "type": "werkzeug.formparser", "text": "\nParse the form data in the environ and return it as tuple in the form\n`(stream, form, files)`. You should only call this method if the transport\nmethod is `POST`, `PUT`, or `PATCH`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "parse_if_range_header()", "path": "http/index#werkzeug.http.parse_if_range_header", "type": "werkzeug.http", "text": "\nParses an if-range header which can be an etag or a date. Returns a `IfRange`\nobject.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "parse_list_header()", "path": "http/index#werkzeug.http.parse_list_header", "type": "werkzeug.http", "text": "\nParse lists as described by RFC 2068 Section 2.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "parse_options_header()", "path": "http/index#werkzeug.http.parse_options_header", "type": "werkzeug.http", "text": "\nParse a `Content-Type` like header into a tuple with the content type and the\noptions:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "parse_range_header()", "path": "http/index#werkzeug.http.parse_range_header", "type": "werkzeug.http", "text": "\nParses a range header into a `Range` object. If the header is missing or\nmalformed `None` is returned. `ranges` is a list of `(start, stop)` tuples\nwhere the ranges are non-inclusive.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "parse_set_header()", "path": "http/index#werkzeug.http.parse_set_header", "type": "werkzeug.http", "text": "\nParse a set-like header and return a `HeaderSet` object:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "parse_www_authenticate_header()", "path": "http/index#werkzeug.http.parse_www_authenticate_header", "type": "werkzeug.http", "text": "\nParse an HTTP WWW-Authenticate header into a `WWWAuthenticate` object.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "PathConverter", "path": "routing/index#werkzeug.routing.PathConverter", "type": "werkzeug.routing", "text": "\nLike the default `UnicodeConverter`, but it also matches slashes. This is\nuseful for wikis and similar applications:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pbkdf2_bin()", "path": "utils/index#werkzeug.security.pbkdf2_bin", "type": "werkzeug.security", "text": "\nReturns a binary digest for the PBKDF2 hash algorithm of `data` with the given\n`salt`. It iterates `iterations` times and produces a key of `keylen` bytes.\nBy default, SHA-256 is used as hash function; a different hashlib `hashfunc`\ncan be provided.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pbkdf2_hex()", "path": "utils/index#werkzeug.security.pbkdf2_hex", "type": "werkzeug.security", "text": "\nLike `pbkdf2_bin()`, but returns a hex-encoded string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "peek_path_info()", "path": "wsgi/index#werkzeug.wsgi.peek_path_info", "type": "werkzeug.wsgi", "text": "\nReturns the next segment on the `PATH_INFO` or `None` if there is none. Works\nlike `pop_path_info()` without modifying the environment:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "pop_path_info()", "path": "wsgi/index#werkzeug.wsgi.pop_path_info", "type": "werkzeug.wsgi", "text": "\nRemoves and returns the next segment of `PATH_INFO`, pushing it onto\n`SCRIPT_NAME`. Returns `None` if there is nothing left on `PATH_INFO`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ProfilerMiddleware", "path": "middleware/profiler/index#werkzeug.middleware.profiler.ProfilerMiddleware", "type": "werkzeug.middleware.profiler", "text": "\nWrap a WSGI application and profile the execution of each request. Responses\nare buffered so that timings are more exact.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ProxyFix", "path": "middleware/proxy_fix/index#werkzeug.middleware.proxy_fix.ProxyFix", "type": "werkzeug.middleware.proxy_fix", "text": "\nAdjust the WSGI environ based on `X-Forwarded-` that proxies in front of the\napplication may set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ProxyMiddleware", "path": "middleware/http_proxy/index#werkzeug.middleware.http_proxy.ProxyMiddleware", "type": "werkzeug.middleware.http_proxy", "text": "\nProxy requests under a path to an external server, routing other requests to\nthe app.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Quickstart", "path": "quickstart/index", "type": "Other", "text": "\nThis part of the documentation shows how to use the most important parts of\nWerkzeug. It\u2019s intended as a starting point for developers with basic\nunderstanding of PEP 3333 (WSGI) and RFC 2616 (HTTP).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "quote_etag()", "path": "http/index#werkzeug.http.quote_etag", "type": "werkzeug.http", "text": "\nQuote an etag.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "quote_header_value()", "path": "http/index#werkzeug.http.quote_header_value", "type": "werkzeug.http", "text": "\nQuote a header value if necessary.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Range", "path": "datastructures/index#werkzeug.datastructures.Range", "type": "werkzeug.datastructures", "text": "\nRepresents a `Range` header. All methods only support only bytes as the unit.\nStores a list of ranges if given, but the methods only work if only one range\nis provided.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Range.make_content_range()", "path": "datastructures/index#werkzeug.datastructures.Range.make_content_range", "type": "werkzeug.datastructures", "text": "\nCreates a `ContentRange` object from the current range and given content\nlength.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Range.ranges", "path": "datastructures/index#werkzeug.datastructures.Range.ranges", "type": "werkzeug.datastructures", "text": "\nA list of `(begin, end)` tuples for the range header provided. The ranges are\nnon-inclusive.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Range.range_for_length()", "path": "datastructures/index#werkzeug.datastructures.Range.range_for_length", "type": "werkzeug.datastructures", "text": "\nIf the range is for bytes, the length is not None and there is exactly one\nrange and it is satisfiable it returns a `(start, stop)` tuple, otherwise\n`None`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Range.to_content_range_header()", "path": "datastructures/index#werkzeug.datastructures.Range.to_content_range_header", "type": "werkzeug.datastructures", "text": "\nConverts the object into `Content-Range` HTTP header, based on given length\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Range.to_header()", "path": "datastructures/index#werkzeug.datastructures.Range.to_header", "type": "werkzeug.datastructures", "text": "\nConverts the object back into an HTTP header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Range.units", "path": "datastructures/index#werkzeug.datastructures.Range.units", "type": "werkzeug.datastructures", "text": "\nThe units of this range. Usually \u201cbytes\u201d.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "redirect()", "path": "utils/index#werkzeug.utils.redirect", "type": "werkzeug.utils", "text": "\nReturns a response object (a WSGI application) that, if called, redirects the\nclient to the target location. Supported codes are 301, 302, 303, 305, 307,\nand 308. 300 is not supported because it\u2019s not a real redirect and 304 because\nit\u2019s the answer for a request with a request with defined If-Modified-Since\nheaders.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "release_local()", "path": "local/index#werkzeug.local.release_local", "type": "werkzeug.local", "text": "\nReleases the contents of the local for the current context. This makes it\npossible to use locals without a manager.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "remove_entity_headers()", "path": "http/index#werkzeug.http.remove_entity_headers", "type": "werkzeug.http", "text": "\nRemove all entity headers from a list or `Headers` object. This operation\nworks in-place. `Expires` and `Content-Location` headers are by default not\nremoved. The reason for this is RFC 2616 section 10.3.5 which specifies some\nentity headers that should be sent.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "remove_hop_by_hop_headers()", "path": "http/index#werkzeug.http.remove_hop_by_hop_headers", "type": "werkzeug.http", "text": "\nRemove all HTTP/1.1 \u201cHop-by-Hop\u201d headers from a list or `Headers` object. This\noperation works in-place.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Request", "path": "wrappers/index#werkzeug.wrappers.Request", "type": "werkzeug.wrappers", "text": "\nRepresents an incoming WSGI HTTP request, with headers and body taken from the\nWSGI environment. Has properties and methods for using the functionality\ndefined by various HTTP specs. The data in requests object is read-only.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Request / Response Objects", "path": "wrappers/index", "type": "Other", "text": "\nThe request and response objects wrap the WSGI environment or the return value\nfrom a WSGI application so that it is another WSGI application (wraps a whole\napplication).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Request.access_control_request_headers", "path": "wrappers/index#werkzeug.wrappers.Request.access_control_request_headers", "type": "werkzeug.wrappers", "text": "\nSent with a preflight request to indicate which headers will be sent with the\ncross origin request. Set `access_control_allow_headers` on the response to\nindicate which headers are allowed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Request.access_control_request_method", "path": "wrappers/index#werkzeug.wrappers.Request.access_control_request_method", "type": "werkzeug.wrappers", "text": "\nSent with a preflight request to indicate which method will be used for the\ncross origin request. Set `access_control_allow_methods` on the response to\nindicate which methods are allowed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Request.application()", "path": "wrappers/index#werkzeug.wrappers.Request.application", "type": "werkzeug.wrappers", "text": "\nDecorate a function as responder that accepts the request as the last\nargument. This works like the `responder()` decorator but the function is\npassed the request object as the last argument and the request object will be\nclosed automatically:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Request.close()", "path": "wrappers/index#werkzeug.wrappers.Request.close", "type": "werkzeug.wrappers", "text": "\nCloses associated resources of this request object. This closes all file\nhandles explicitly. You can also use the request object in a with statement\nwhich will automatically close it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Request.content_encoding", "path": "wrappers/index#werkzeug.wrappers.Request.content_encoding", "type": "werkzeug.wrappers", "text": "\nThe Content-Encoding entity-header field is used as a modifier to the media-\ntype. When present, its value indicates what additional content codings have\nbeen applied to the entity-body, and thus what decoding mechanisms must be\napplied in order to obtain the media-type referenced by the Content-Type\nheader field.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Request.content_md5", "path": "wrappers/index#werkzeug.wrappers.Request.content_md5", "type": "werkzeug.wrappers", "text": "\nThe Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest\nof the entity-body for the purpose of providing an end-to-end message\nintegrity check (MIC) of the entity-body. (Note: a MIC is good for detecting\naccidental modification of the entity-body in transit, but is not proof\nagainst malicious attacks.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Request.content_type", "path": "wrappers/index#werkzeug.wrappers.Request.content_type", "type": "werkzeug.wrappers", "text": "\nThe Content-Type entity-header field indicates the media type of the entity-\nbody sent to the recipient or, in the case of the HEAD method, the media type\nthat would have been sent had the request been a GET.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Request.date", "path": "wrappers/index#werkzeug.wrappers.Request.date", "type": "werkzeug.wrappers", "text": "\nThe Date general-header field represents the date and time at which the\nmessage was originated, having the same semantics as orig-date in RFC 822.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Request.dict_storage_class", "path": "wrappers/index#werkzeug.wrappers.Request.dict_storage_class", "type": "werkzeug.wrappers", "text": "\nalias of `werkzeug.datastructures.ImmutableMultiDict`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Request.disable_data_descriptor", "path": "wrappers/index#werkzeug.wrappers.Request.disable_data_descriptor", "type": "werkzeug.wrappers", "text": "\nDisable the `data` property to avoid reading from the input stream.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Request.environ", "path": "wrappers/index#werkzeug.wrappers.Request.environ", "type": "werkzeug.wrappers", "text": "\nThe WSGI environment containing HTTP headers and information from the WSGI\nserver.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Request.form_data_parser_class", "path": "wrappers/index#werkzeug.wrappers.Request.form_data_parser_class", "type": "werkzeug.wrappers", "text": "\nalias of `werkzeug.formparser.FormDataParser`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Request.from_values()", "path": "wrappers/index#werkzeug.wrappers.Request.from_values", "type": "werkzeug.wrappers", "text": "\nCreate a new request object based on the values provided. If environ is given\nmissing values are filled from there. This method is useful for small scripts\nwhen you need to simulate a request from an URL. Do not use this method for\nunittesting, there is a full featured client object (`Client`) that allows to\ncreate multipart requests, support for cookies etc.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Request.get_data()", "path": "wrappers/index#werkzeug.wrappers.Request.get_data", "type": "werkzeug.wrappers", "text": "\nThis reads the buffered incoming data from the client into one bytes object.\nBy default this is cached but that behavior can be changed by setting `cache`\nto `False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Request.get_json()", "path": "wrappers/index#werkzeug.wrappers.Request.get_json", "type": "werkzeug.wrappers", "text": "\nParse `data` as JSON.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Request.headers", "path": "wrappers/index#werkzeug.wrappers.Request.headers", "type": "werkzeug.wrappers", "text": "\nThe headers received with the request.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Request.input_stream", "path": "wrappers/index#werkzeug.wrappers.Request.input_stream", "type": "werkzeug.wrappers", "text": "\nThe WSGI input stream.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Request.is_multiprocess", "path": "wrappers/index#werkzeug.wrappers.Request.is_multiprocess", "type": "werkzeug.wrappers", "text": "\nboolean that is `True` if the application is served by a WSGI server that\nspawns multiple processes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Request.is_multithread", "path": "wrappers/index#werkzeug.wrappers.Request.is_multithread", "type": "werkzeug.wrappers", "text": "\nboolean that is `True` if the application is served by a multithreaded WSGI\nserver.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Request.is_run_once", "path": "wrappers/index#werkzeug.wrappers.Request.is_run_once", "type": "werkzeug.wrappers", "text": "\nboolean that is `True` if the application will be executed only once in a\nprocess lifetime. This is the case for CGI for example, but it\u2019s not\nguaranteed that the execution only happens one time.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Request.json_module", "path": "wrappers/index#werkzeug.wrappers.Request.json_module", "type": "werkzeug.wrappers", "text": "\nA module or other object that has `dumps` and `loads` functions that match the\nAPI of the built-in `json` module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Request.list_storage_class", "path": "wrappers/index#werkzeug.wrappers.Request.list_storage_class", "type": "werkzeug.wrappers", "text": "\nalias of `werkzeug.datastructures.ImmutableList`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Request.make_form_data_parser()", "path": "wrappers/index#werkzeug.wrappers.Request.make_form_data_parser", "type": "werkzeug.wrappers", "text": "\nCreates the form data parser. Instantiates the `form_data_parser_class` with\nsome parameters.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Request.max_content_length", "path": "wrappers/index#werkzeug.wrappers.Request.max_content_length", "type": "werkzeug.wrappers", "text": "\nthe maximum content length. This is forwarded to the form data parsing\nfunction (`parse_form_data()`). When set and the `form` or `files` attribute\nis accessed and the parsing fails because more than the specified value is\ntransmitted a `RequestEntityTooLarge` exception is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Request.max_form_memory_size", "path": "wrappers/index#werkzeug.wrappers.Request.max_form_memory_size", "type": "werkzeug.wrappers", "text": "\nthe maximum form field size. This is forwarded to the form data parsing\nfunction (`parse_form_data()`). When set and the `form` or `files` attribute\nis accessed and the data in memory for post data is longer than the specified\nvalue a `RequestEntityTooLarge` exception is raised.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Request.max_forwards", "path": "wrappers/index#werkzeug.wrappers.Request.max_forwards", "type": "werkzeug.wrappers", "text": "\nThe Max-Forwards request-header field provides a mechanism with the TRACE and\nOPTIONS methods to limit the number of proxies or gateways that can forward\nthe request to the next inbound server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Request.method", "path": "wrappers/index#werkzeug.wrappers.Request.method", "type": "werkzeug.wrappers", "text": "\nThe method the request was made with, such as `GET`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Request.on_json_loading_failed()", "path": "wrappers/index#werkzeug.wrappers.Request.on_json_loading_failed", "type": "werkzeug.wrappers", "text": "\nCalled if `get_json()` parsing fails and isn\u2019t silenced. If this method\nreturns a value, it is used as the return value for `get_json()`. The default\nimplementation raises `BadRequest`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Request.origin", "path": "wrappers/index#werkzeug.wrappers.Request.origin", "type": "werkzeug.wrappers", "text": "\nThe host that the request originated from. Set `access_control_allow_origin`\non the response to indicate which origins are allowed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Request.parameter_storage_class", "path": "wrappers/index#werkzeug.wrappers.Request.parameter_storage_class", "type": "werkzeug.wrappers", "text": "\nalias of `werkzeug.datastructures.ImmutableMultiDict`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Request.path", "path": "wrappers/index#werkzeug.wrappers.Request.path", "type": "werkzeug.wrappers", "text": "\nThe path part of the URL after `root_path`. This is the path used for routing\nwithin the application.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Request.query_string", "path": "wrappers/index#werkzeug.wrappers.Request.query_string", "type": "werkzeug.wrappers", "text": "\nThe part of the URL after the \u201c?\u201d. This is the raw value, use `args` for the\nparsed values.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Request.referrer", "path": "wrappers/index#werkzeug.wrappers.Request.referrer", "type": "werkzeug.wrappers", "text": "\nThe Referer[sic] request-header field allows the client to specify, for the\nserver\u2019s benefit, the address (URI) of the resource from which the Request-URI\nwas obtained (the \u201creferrer\u201d, although the header field is misspelled).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Request.remote_addr", "path": "wrappers/index#werkzeug.wrappers.Request.remote_addr", "type": "werkzeug.wrappers", "text": "\nThe address of the client sending the request.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Request.remote_user", "path": "wrappers/index#werkzeug.wrappers.Request.remote_user", "type": "werkzeug.wrappers", "text": "\nIf the server supports user authentication, and the script is protected, this\nattribute contains the username the user has authenticated as.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Request.root_path", "path": "wrappers/index#werkzeug.wrappers.Request.root_path", "type": "werkzeug.wrappers", "text": "\nThe prefix that the application is mounted under, without a trailing slash.\n`path` comes after this.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Request.scheme", "path": "wrappers/index#werkzeug.wrappers.Request.scheme", "type": "werkzeug.wrappers", "text": "\nThe URL scheme of the protocol the request used, such as `https` or `wss`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Request.server", "path": "wrappers/index#werkzeug.wrappers.Request.server", "type": "werkzeug.wrappers", "text": "\nThe address of the server. `(host, port)`, `(path, None)` for unix sockets, or\n`None` if not known.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Request.shallow", "path": "wrappers/index#werkzeug.wrappers.Request.shallow", "type": "werkzeug.wrappers", "text": "\nSet when creating the request object. If `True`, reading from the request body\nwill cause a `RuntimeException`. Useful to prevent modifying the stream from\nmiddleware.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Request.user_agent_class", "path": "wrappers/index#werkzeug.wrappers.Request.user_agent_class", "type": "werkzeug.wrappers", "text": "\nalias of `werkzeug.useragents._UserAgent`\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Request._get_file_stream()", "path": "wrappers/index#werkzeug.wrappers.Request._get_file_stream", "type": "werkzeug.wrappers", "text": "\nCalled to get a stream for the file upload.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "RequestCacheControl", "path": "datastructures/index#werkzeug.datastructures.RequestCacheControl", "type": "werkzeug.datastructures", "text": "\nA cache control for requests. This is immutable and gives access to all the\nrequest-relevant cache control headers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "RequestCacheControl.max_age", "path": "datastructures/index#werkzeug.datastructures.RequestCacheControl.max_age", "type": "werkzeug.datastructures", "text": "\naccessor for \u2018max-age\u2019\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "RequestCacheControl.no_cache", "path": "datastructures/index#werkzeug.datastructures.RequestCacheControl.no_cache", "type": "werkzeug.datastructures", "text": "\naccessor for \u2018no-cache\u2019\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "RequestCacheControl.no_store", "path": "datastructures/index#werkzeug.datastructures.RequestCacheControl.no_store", "type": "werkzeug.datastructures", "text": "\naccessor for \u2018no-store\u2019\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "RequestCacheControl.no_transform", "path": "datastructures/index#werkzeug.datastructures.RequestCacheControl.no_transform", "type": "werkzeug.datastructures", "text": "\naccessor for \u2018no-transform\u2019\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "responder()", "path": "wsgi/index#werkzeug.wsgi.responder", "type": "werkzeug.wsgi", "text": "\nMarks a function as responder. Decorate a function with it and it will\nautomatically call the return value as WSGI application.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response", "path": "wrappers/index#werkzeug.wrappers.Response", "type": "werkzeug.wrappers", "text": "\nRepresents an outgoing WSGI HTTP response with body, status, and headers. Has\nproperties and methods for using the functionality defined by various HTTP\nspecs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.accept_ranges", "path": "wrappers/index#werkzeug.wrappers.Response.accept_ranges", "type": "werkzeug.wrappers", "text": "\nThe `Accept-Ranges` header. Even though the name would indicate that multiple\nvalues are supported, it must be one string token only.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.access_control_allow_headers", "path": "wrappers/index#werkzeug.wrappers.Response.access_control_allow_headers", "type": "werkzeug.wrappers", "text": "\nWhich headers can be sent with the cross origin request.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.access_control_allow_methods", "path": "wrappers/index#werkzeug.wrappers.Response.access_control_allow_methods", "type": "werkzeug.wrappers", "text": "\nWhich methods can be used for the cross origin request.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.access_control_allow_origin", "path": "wrappers/index#werkzeug.wrappers.Response.access_control_allow_origin", "type": "werkzeug.wrappers", "text": "\nThe origin or \u2018*\u2019 for any origin that may make cross origin requests.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.access_control_expose_headers", "path": "wrappers/index#werkzeug.wrappers.Response.access_control_expose_headers", "type": "werkzeug.wrappers", "text": "\nWhich headers can be shared by the browser to JavaScript code.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.access_control_max_age", "path": "wrappers/index#werkzeug.wrappers.Response.access_control_max_age", "type": "werkzeug.wrappers", "text": "\nThe maximum age in seconds the access control settings can be cached for.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.add_etag()", "path": "wrappers/index#werkzeug.wrappers.Response.add_etag", "type": "werkzeug.wrappers", "text": "\nAdd an etag for the current response if there is none yet.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.age", "path": "wrappers/index#werkzeug.wrappers.Response.age", "type": "werkzeug.wrappers", "text": "\nThe Age response-header field conveys the sender\u2019s estimate of the amount of\ntime since the response (or its revalidation) was generated at the origin\nserver.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.autocorrect_location_header", "path": "wrappers/index#werkzeug.wrappers.Response.autocorrect_location_header", "type": "werkzeug.wrappers", "text": "\nShould this response object correct the location header to be RFC conformant?\nThis is true by default.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.automatically_set_content_length", "path": "wrappers/index#werkzeug.wrappers.Response.automatically_set_content_length", "type": "werkzeug.wrappers", "text": "\nShould this response object automatically set the content-length header if\npossible? This is true by default.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.calculate_content_length()", "path": "wrappers/index#werkzeug.wrappers.Response.calculate_content_length", "type": "werkzeug.wrappers", "text": "\nReturns the content length if available or `None` otherwise.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.call_on_close()", "path": "wrappers/index#werkzeug.wrappers.Response.call_on_close", "type": "werkzeug.wrappers", "text": "\nAdds a function to the internal list of functions that should be called as\npart of closing down the response. Since 0.7 this function also returns the\nfunction that was passed so that this can be used as a decorator.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.close()", "path": "wrappers/index#werkzeug.wrappers.Response.close", "type": "werkzeug.wrappers", "text": "\nClose the wrapped response if possible. You can also use the object in a with\nstatement which will automatically close it.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.content_encoding", "path": "wrappers/index#werkzeug.wrappers.Response.content_encoding", "type": "werkzeug.wrappers", "text": "\nThe Content-Encoding entity-header field is used as a modifier to the media-\ntype. When present, its value indicates what additional content codings have\nbeen applied to the entity-body, and thus what decoding mechanisms must be\napplied in order to obtain the media-type referenced by the Content-Type\nheader field.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.content_length", "path": "wrappers/index#werkzeug.wrappers.Response.content_length", "type": "werkzeug.wrappers", "text": "\nThe Content-Length entity-header field indicates the size of the entity-body,\nin decimal number of OCTETs, sent to the recipient or, in the case of the HEAD\nmethod, the size of the entity-body that would have been sent had the request\nbeen a GET.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.content_location", "path": "wrappers/index#werkzeug.wrappers.Response.content_location", "type": "werkzeug.wrappers", "text": "\nThe Content-Location entity-header field MAY be used to supply the resource\nlocation for the entity enclosed in the message when that entity is accessible\nfrom a location separate from the requested resource\u2019s URI.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.content_md5", "path": "wrappers/index#werkzeug.wrappers.Response.content_md5", "type": "werkzeug.wrappers", "text": "\nThe Content-MD5 entity-header field, as defined in RFC 1864, is an MD5 digest\nof the entity-body for the purpose of providing an end-to-end message\nintegrity check (MIC) of the entity-body. (Note: a MIC is good for detecting\naccidental modification of the entity-body in transit, but is not proof\nagainst malicious attacks.)\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.content_security_policy", "path": "wrappers/index#werkzeug.wrappers.Response.content_security_policy", "type": "werkzeug.wrappers", "text": "\nThe Content-Security-Policy header adds an additional layer of security to\nhelp detect and mitigate certain types of attacks.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.content_security_policy_report_only", "path": "wrappers/index#werkzeug.wrappers.Response.content_security_policy_report_only", "type": "werkzeug.wrappers", "text": "\nThe Content-Security-Policy-Report-Only header adds a csp policy that is not\nenforced but is reported thereby helping detect certain types of attacks.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.content_type", "path": "wrappers/index#werkzeug.wrappers.Response.content_type", "type": "werkzeug.wrappers", "text": "\nThe Content-Type entity-header field indicates the media type of the entity-\nbody sent to the recipient or, in the case of the HEAD method, the media type\nthat would have been sent had the request been a GET.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.cross_origin_embedder_policy", "path": "wrappers/index#werkzeug.wrappers.Response.cross_origin_embedder_policy", "type": "werkzeug.wrappers", "text": "\nPrevents a document from loading any cross-origin resources that do not\nexplicitly grant the document permission. Values must be a member of the\n`werkzeug.http.COEP` enum.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.cross_origin_opener_policy", "path": "wrappers/index#werkzeug.wrappers.Response.cross_origin_opener_policy", "type": "werkzeug.wrappers", "text": "\nAllows control over sharing of browsing context group with cross-origin\ndocuments. Values must be a member of the `werkzeug.http.COOP` enum.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.date", "path": "wrappers/index#werkzeug.wrappers.Response.date", "type": "werkzeug.wrappers", "text": "\nThe Date general-header field represents the date and time at which the\nmessage was originated, having the same semantics as orig-date in RFC 822.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.delete_cookie()", "path": "wrappers/index#werkzeug.wrappers.Response.delete_cookie", "type": "werkzeug.wrappers", "text": "\nDelete a cookie. Fails silently if key doesn\u2019t exist.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.direct_passthrough", "path": "wrappers/index#werkzeug.wrappers.Response.direct_passthrough", "type": "werkzeug.wrappers", "text": "\nPass the response body directly through as the WSGI iterable. This can be used\nwhen the body is a binary file or other iterator of bytes, to skip some\nunnecessary checks. Use `send_file()` instead of setting this manually.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.expires", "path": "wrappers/index#werkzeug.wrappers.Response.expires", "type": "werkzeug.wrappers", "text": "\nThe Expires entity-header field gives the date/time after which the response\nis considered stale. A stale cache entry may not normally be returned by a\ncache.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.force_type()", "path": "wrappers/index#werkzeug.wrappers.Response.force_type", "type": "werkzeug.wrappers", "text": "\nEnforce that the WSGI response is a response object of the current type.\nWerkzeug will use the `Response` internally in many situations like the\nexceptions. If you call `get_response()` on an exception you will get back a\nregular `Response` object, even if you are using a custom subclass.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.freeze()", "path": "wrappers/index#werkzeug.wrappers.Response.freeze", "type": "werkzeug.wrappers", "text": "\nMake the response object ready to be pickled. Does the following:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.from_app()", "path": "wrappers/index#werkzeug.wrappers.Response.from_app", "type": "werkzeug.wrappers", "text": "\nCreate a new response object from an application output. This works best if\nyou pass it an application that returns a generator all the time. Sometimes\napplications may use the `write()` callable returned by the `start_response`\nfunction. This tries to resolve such edge cases automatically. But if you\ndon\u2019t get the expected output you should set `buffered` to `True` which\nenforces buffering.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.get_app_iter()", "path": "wrappers/index#werkzeug.wrappers.Response.get_app_iter", "type": "werkzeug.wrappers", "text": "\nReturns the application iterator for the given environ. Depending on the\nrequest method and the current status code the return value might be an empty\nresponse rather than the one from the response.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.get_data()", "path": "wrappers/index#werkzeug.wrappers.Response.get_data", "type": "werkzeug.wrappers", "text": "\nThe string representation of the response body. Whenever you call this\nproperty the response iterable is encoded and flattened. This can lead to\nunwanted behavior if you stream big data.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.get_etag()", "path": "wrappers/index#werkzeug.wrappers.Response.get_etag", "type": "werkzeug.wrappers", "text": "\nReturn a tuple in the form `(etag, is_weak)`. If there is no ETag the return\nvalue is `(None, None)`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.get_json()", "path": "wrappers/index#werkzeug.wrappers.Response.get_json", "type": "werkzeug.wrappers", "text": "\nParse `data` as JSON. Useful during testing.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.get_wsgi_headers()", "path": "wrappers/index#werkzeug.wrappers.Response.get_wsgi_headers", "type": "werkzeug.wrappers", "text": "\nThis is automatically called right before the response is started and returns\nheaders modified for the given environment. It returns a copy of the headers\nfrom the response with some modifications applied if necessary.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.get_wsgi_response()", "path": "wrappers/index#werkzeug.wrappers.Response.get_wsgi_response", "type": "werkzeug.wrappers", "text": "\nReturns the final WSGI response as tuple. The first item in the tuple is the\napplication iterator, the second the status and the third the list of headers.\nThe response returned is created specially for the given environment. For\nexample if the request method in the WSGI environment is `'HEAD'` the response\nwill be empty and only the headers and status code will be present.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.implicit_sequence_conversion", "path": "wrappers/index#werkzeug.wrappers.Response.implicit_sequence_conversion", "type": "werkzeug.wrappers", "text": "\nif set to `False` accessing properties on the response object will not try to\nconsume the response iterator and convert it into a list.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.iter_encoded()", "path": "wrappers/index#werkzeug.wrappers.Response.iter_encoded", "type": "werkzeug.wrappers", "text": "\nIter the response encoded with the encoding of the response. If the response\nobject is invoked as WSGI application the return value of this method is used\nas application iterator unless `direct_passthrough` was activated.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.json_module", "path": "wrappers/index#werkzeug.wrappers.Response.json_module", "type": "werkzeug.wrappers", "text": "\nA module or other object that has `dumps` and `loads` functions that match the\nAPI of the built-in `json` module.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.last_modified", "path": "wrappers/index#werkzeug.wrappers.Response.last_modified", "type": "werkzeug.wrappers", "text": "\nThe Last-Modified entity-header field indicates the date and time at which the\norigin server believes the variant was last modified.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.location", "path": "wrappers/index#werkzeug.wrappers.Response.location", "type": "werkzeug.wrappers", "text": "\nThe Location response-header field is used to redirect the recipient to a\nlocation other than the Request-URI for completion of the request or\nidentification of a new resource.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.make_conditional()", "path": "wrappers/index#werkzeug.wrappers.Response.make_conditional", "type": "werkzeug.wrappers", "text": "\nMake the response conditional to the request. This method works best if an\netag was defined for the response already. The `add_etag` method can be used\nto do that. If called without etag just the date header is set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.make_sequence()", "path": "wrappers/index#werkzeug.wrappers.Response.make_sequence", "type": "werkzeug.wrappers", "text": "\nConverts the response iterator in a list. By default this happens\nautomatically if required. If `implicit_sequence_conversion` is disabled, this\nmethod is not automatically called and some properties might raise exceptions.\nThis also encodes all the items.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.response", "path": "wrappers/index#werkzeug.wrappers.Response.response", "type": "werkzeug.wrappers", "text": "\nThe response body to send as the WSGI iterable. A list of strings or bytes\nrepresents a fixed-length response, any other iterable is a streaming\nresponse. Strings are encoded to bytes as UTF-8.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.set_cookie()", "path": "wrappers/index#werkzeug.wrappers.Response.set_cookie", "type": "werkzeug.wrappers", "text": "\nSets a cookie.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.set_data()", "path": "wrappers/index#werkzeug.wrappers.Response.set_data", "type": "werkzeug.wrappers", "text": "\nSets a new string as response. The value must be a string or bytes. If a\nstring is set it\u2019s encoded to the charset of the response (utf-8 by default).\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.set_etag()", "path": "wrappers/index#werkzeug.wrappers.Response.set_etag", "type": "werkzeug.wrappers", "text": "\nSet the etag, and override the old one if there was one.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response._ensure_sequence()", "path": "wrappers/index#werkzeug.wrappers.Response._ensure_sequence", "type": "werkzeug.wrappers", "text": "\nThis method can be called by methods that need a sequence. If `mutable` is\ntrue, it will also ensure that the response sequence is a standard Python\nlist.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Response.__call__()", "path": "wrappers/index#werkzeug.wrappers.Response.__call__", "type": "werkzeug.wrappers", "text": "\nProcess this response as WSGI application.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ResponseCacheControl", "path": "datastructures/index#werkzeug.datastructures.ResponseCacheControl", "type": "werkzeug.datastructures", "text": "\nA cache control for responses. Unlike `RequestCacheControl` this is mutable\nand gives access to response-relevant cache control headers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ResponseCacheControl.max_age", "path": "datastructures/index#werkzeug.datastructures.ResponseCacheControl.max_age", "type": "werkzeug.datastructures", "text": "\naccessor for \u2018max-age\u2019\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ResponseCacheControl.no_cache", "path": "datastructures/index#werkzeug.datastructures.ResponseCacheControl.no_cache", "type": "werkzeug.datastructures", "text": "\naccessor for \u2018no-cache\u2019\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ResponseCacheControl.no_store", "path": "datastructures/index#werkzeug.datastructures.ResponseCacheControl.no_store", "type": "werkzeug.datastructures", "text": "\naccessor for \u2018no-store\u2019\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "ResponseCacheControl.no_transform", "path": "datastructures/index#werkzeug.datastructures.ResponseCacheControl.no_transform", "type": "werkzeug.datastructures", "text": "\naccessor for \u2018no-transform\u2019\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Rule", "path": "routing/index#werkzeug.routing.Rule", "type": "werkzeug.routing", "text": "\nA Rule represents one URL pattern. There are some options for `Rule` that\nchange the way it behaves and are passed to the `Rule` constructor. Note that\nbesides the rule-string all arguments must be keyword arguments in order to\nnot break the application on Werkzeug upgrades.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Rule.empty()", "path": "routing/index#werkzeug.routing.Rule.empty", "type": "werkzeug.routing", "text": "\nReturn an unbound copy of this rule.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "RuleFactory", "path": "routing/index#werkzeug.routing.RuleFactory", "type": "werkzeug.routing", "text": "\nAs soon as you have more complex URL setups it\u2019s a good idea to use rule\nfactories to avoid repetitive tasks. Some of them are builtin, others can be\nadded by subclassing `RuleFactory` and overriding `get_rules`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "RuleFactory.get_rules()", "path": "routing/index#werkzeug.routing.RuleFactory.get_rules", "type": "werkzeug.routing", "text": "\nSubclasses of `RuleFactory` have to override this method and return an\niterable of rules.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "RuleTemplate", "path": "routing/index#werkzeug.routing.RuleTemplate", "type": "werkzeug.routing", "text": "\nReturns copies of the rules wrapped and expands string templates in the\nendpoint, rule, defaults or subdomain sections.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "run_simple()", "path": "serving/index#werkzeug.serving.run_simple", "type": "werkzeug.serving", "text": "\nStart a WSGI application. Optional features include a reloader, multithreading\nand fork support.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "run_wsgi_app()", "path": "test/index#werkzeug.test.run_wsgi_app", "type": "werkzeug.test", "text": "\nReturn a tuple in the form (app_iter, status, headers) of the application\noutput. This works best if you pass it an application that returns an iterator\nall the time.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "safe_join()", "path": "utils/index#werkzeug.security.safe_join", "type": "werkzeug.security", "text": "\nSafely join zero or more untrusted path components to a base directory to\navoid escaping the base directory.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "safe_str_cmp()", "path": "utils/index#werkzeug.security.safe_str_cmp", "type": "werkzeug.security", "text": "\nThis function compares strings in somewhat constant time. This requires that\nthe length of at least one string is known in advance.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "secure_filename()", "path": "utils/index#werkzeug.utils.secure_filename", "type": "werkzeug.utils", "text": "\nPass it a filename and it will return a secure version of it. This filename\ncan then safely be stored on a regular file system and passed to\n`os.path.join()`. The filename returned is an ASCII only string for maximum\nportability.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "send_file()", "path": "utils/index#werkzeug.utils.send_file", "type": "werkzeug.utils", "text": "\nSend the contents of a file to the client.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Serve Shared Static Files", "path": "middleware/shared_data/index", "type": "Other", "text": "\nA WSGI middleware which provides static content for development environments\nor simple server setups. Its usage is quite simple:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Serving WSGI Applications", "path": "serving/index", "type": "Other", "text": "\nThere are many ways to serve a WSGI application. While you\u2019re developing it,\nyou usually don\u2019t want to have a full-blown webserver like Apache up and\nrunning, but instead a simple standalone one. Because of that Werkzeug comes\nwith a builtin development server.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "SharedDataMiddleware", "path": "middleware/shared_data/index#werkzeug.middleware.shared_data.SharedDataMiddleware", "type": "werkzeug.middleware.shared_data", "text": "\nA WSGI middleware which provides static content for development environments\nor simple server setups. Its usage is quite simple:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "SharedDataMiddleware.is_allowed()", "path": "middleware/shared_data/index#werkzeug.middleware.shared_data.SharedDataMiddleware.is_allowed", "type": "werkzeug.middleware.shared_data", "text": "\nSubclasses can override this method to disallow the access to certain files.\nHowever by providing `disallow` in the constructor this method is overwritten.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Subdomain", "path": "routing/index#werkzeug.routing.Subdomain", "type": "werkzeug.routing", "text": "\nAll URLs provided by this factory have the subdomain set to a specific domain.\nFor example if you want to use the subdomain for the current language this can\nbe a good setup:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Submount", "path": "routing/index#werkzeug.routing.Submount", "type": "werkzeug.routing", "text": "\nLike `Subdomain` but prefixes the URL rule with a given string:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Testing WSGI Applications", "path": "test/index", "type": "Other", "text": "\nWerkzeug provides a `Client` to simulate requests to a WSGI application\nwithout starting a server. The client has methods for making different types\nof requests, as well as managing cookies across requests.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "TestResponse", "path": "test/index#werkzeug.test.TestResponse", "type": "werkzeug.test", "text": "\n`Response` subclass that provides extra information about requests made with\nthe test `Client`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "TestResponse.history", "path": "test/index#werkzeug.test.TestResponse.history", "type": "werkzeug.test", "text": "\nA list of intermediate responses. Populated when the test request is made with\n`follow_redirects` enabled.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "TestResponse.request", "path": "test/index#werkzeug.test.TestResponse.request", "type": "werkzeug.test", "text": "\nA request object with the environ used to make the request that resulted in\nthis response.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "test_app()", "path": "wsgi/index#werkzeug.testapp.test_app", "type": "werkzeug.testapp", "text": "\nSimple test application that dumps the environment. You can use it to check if\nWerkzeug is working properly:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "TypeConversionDict", "path": "datastructures/index#werkzeug.datastructures.TypeConversionDict", "type": "werkzeug.datastructures", "text": "\nWorks like a regular dict but the `get()` method can perform type conversions.\n`MultiDict` and `CombinedMultiDict` are subclasses of this class and provide\nthe same feature.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "TypeConversionDict.get()", "path": "datastructures/index#werkzeug.datastructures.TypeConversionDict.get", "type": "werkzeug.datastructures", "text": "\nReturn the default value if the requested data doesn\u2019t exist. If `type` is\nprovided and is a callable it should convert the value, return it or raise a\n`ValueError` if that is not possible. In this case the function will return\nthe default as if the value was not found:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unescape()", "path": "utils/index#werkzeug.utils.unescape", "type": "werkzeug.utils", "text": "\nThe reverse of `escape()`. This unescapes all the HTML entities, not only\nthose inserted by `escape`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Unicode", "path": "unicode/index", "type": "Other", "text": "\nWerkzeug uses strings internally everwhere text data is assumed, even if the\nHTTP standard is not Unicode aware. Basically all incoming data is decoded\nfrom the charset (UTF-8 by default) so that you don\u2019t work with bytes\ndirectly. Outgoing data is encoded into the target charset.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "UnicodeConverter", "path": "routing/index#werkzeug.routing.UnicodeConverter", "type": "werkzeug.routing", "text": "\nThis converter is the default converter and accepts any string but only one\npath segment. Thus the string can not include a slash.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unquote_etag()", "path": "http/index#werkzeug.http.unquote_etag", "type": "werkzeug.http", "text": "\nUnquote a single etag:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "unquote_header_value()", "path": "http/index#werkzeug.http.unquote_header_value", "type": "werkzeug.http", "text": "\nUnquotes a header value. (Reversal of `quote_header_value()`). This does not\nuse the real unquoting but what browsers are actually using for quoting.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "uri_to_iri()", "path": "urls/index#werkzeug.urls.uri_to_iri", "type": "werkzeug.urls", "text": "\nConvert a URI to an IRI. All valid UTF-8 characters are unquoted, leaving all\nreserved and invalid characters quoted. If the URL has a domain, it is decoded\nfrom Punycode.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "URL", "path": "urls/index#werkzeug.urls.URL", "type": "werkzeug.urls", "text": "\nRepresents a parsed URL. This behaves like a regular tuple but also has some\nextra attributes that give further insight into the URL.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "URL Helpers", "path": "urls/index", "type": "Other", "text": "\nFunctions for working with URLs.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "URL Routing", "path": "routing/index", "type": "Other", "text": "\nWhen it comes to combining multiple controller or view functions (however you\nwant to call them), you need a dispatcher. A simple way would be applying\nregular expression tests on `PATH_INFO` and call registered callback functions\nthat return the value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "URL.encode()", "path": "urls/index#werkzeug.urls.URL.encode", "type": "werkzeug.urls", "text": "\nEncodes the URL to a tuple made out of bytes. The charset is only being used\nfor the path, query and fragment.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "url_decode()", "path": "urls/index#werkzeug.urls.url_decode", "type": "werkzeug.urls", "text": "\nParse a query string and return it as a `MultiDict`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "url_decode_stream()", "path": "urls/index#werkzeug.urls.url_decode_stream", "type": "werkzeug.urls", "text": "\nWorks like `url_decode()` but decodes a stream. The behavior of stream and\nlimit follows functions like `make_line_iter()`. The generator of pairs is\ndirectly fed to the `cls` so you can consume the data while it\u2019s parsed.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "url_encode()", "path": "urls/index#werkzeug.urls.url_encode", "type": "werkzeug.urls", "text": "\nURL encode a dict/`MultiDict`. If a value is `None` it will not appear in the\nresult string. Per default only values are encoded into the target charset\nstrings.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "url_encode_stream()", "path": "urls/index#werkzeug.urls.url_encode_stream", "type": "werkzeug.urls", "text": "\nLike `url_encode()` but writes the results to a stream object. If the stream\nis `None` a generator over all encoded pairs is returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "url_fix()", "path": "urls/index#werkzeug.urls.url_fix", "type": "werkzeug.urls", "text": "\nSometimes you get an URL by a user that just isn\u2019t a real URL because it\ncontains unsafe characters like \u2018 \u2018 and so on. This function can fix some of\nthe problems in a similar way browsers handle data entered by the user:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "url_join()", "path": "urls/index#werkzeug.urls.url_join", "type": "werkzeug.urls", "text": "\nJoin a base URL and a possibly relative URL to form an absolute interpretation\nof the latter.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "url_parse()", "path": "urls/index#werkzeug.urls.url_parse", "type": "werkzeug.urls", "text": "\nParses a URL from a string into a `URL` tuple. If the URL is lacking a scheme\nit can be provided as second argument. Otherwise, it is ignored. Optionally\nfragments can be stripped from the URL by setting `allow_fragments` to\n`False`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "url_quote()", "path": "urls/index#werkzeug.urls.url_quote", "type": "werkzeug.urls", "text": "\nURL encode a single string with a given encoding.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "url_quote_plus()", "path": "urls/index#werkzeug.urls.url_quote_plus", "type": "werkzeug.urls", "text": "\nURL encode a single string with the given encoding and convert whitespace to\n\u201c+\u201d.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "url_unparse()", "path": "urls/index#werkzeug.urls.url_unparse", "type": "werkzeug.urls", "text": "\nThe reverse operation to `url_parse()`. This accepts arbitrary as well as\n`URL` tuples and returns a URL as a string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "url_unquote()", "path": "urls/index#werkzeug.urls.url_unquote", "type": "werkzeug.urls", "text": "\nURL decode a single string with a given encoding. If the charset is set to\n`None` no decoding is performed and raw bytes are returned.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "url_unquote_plus()", "path": "urls/index#werkzeug.urls.url_unquote_plus", "type": "werkzeug.urls", "text": "\nURL decode a single string with the given `charset` and decode \u201c+\u201d to\nwhitespace.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "UserAgent", "path": "utils/index#werkzeug.user_agent.UserAgent", "type": "werkzeug.user_agent", "text": "\nRepresents a parsed user agent header value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "UserAgent", "path": "utils/index#werkzeug.useragents.UserAgent", "type": "werkzeug.useragents", "text": "\nRepresents a parsed user agent header value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "UserAgent.browser", "path": "utils/index#werkzeug.user_agent.UserAgent.browser", "type": "werkzeug.user_agent", "text": "\nThe browser name, if it could be parsed from the string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "UserAgent.language", "path": "utils/index#werkzeug.user_agent.UserAgent.language", "type": "werkzeug.user_agent", "text": "\nThe browser language, if it could be parsed from the string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "UserAgent.platform", "path": "utils/index#werkzeug.user_agent.UserAgent.platform", "type": "werkzeug.user_agent", "text": "\nThe OS name, if it could be parsed from the string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "UserAgent.string", "path": "utils/index#werkzeug.user_agent.UserAgent.string", "type": "werkzeug.user_agent", "text": "\nThe original header value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "UserAgent.to_header()", "path": "utils/index#werkzeug.user_agent.UserAgent.to_header", "type": "werkzeug.user_agent", "text": "\nConvert to a header value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "UserAgent.to_header()", "path": "utils/index#werkzeug.useragents.UserAgent.to_header", "type": "werkzeug.useragents", "text": "\nConvert to a header value.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "UserAgent.version", "path": "utils/index#werkzeug.user_agent.UserAgent.version", "type": "werkzeug.user_agent", "text": "\nThe browser version, if it could be parsed from the string.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Utilities", "path": "utils/index", "type": "Other", "text": "\nVarious utility functions shipped with Werkzeug.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "UUIDConverter", "path": "routing/index#werkzeug.routing.UUIDConverter", "type": "werkzeug.routing", "text": "\nThis converter only accepts UUID strings:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "validate_arguments()", "path": "utils/index#werkzeug.utils.validate_arguments", "type": "werkzeug.utils", "text": "\nChecks if the function accepts the arguments and keyword arguments. Returns a\nnew `(args, kwargs)` tuple that can safely be passed to the function without\ncausing a `TypeError` because the function signature is incompatible. If\n`drop_extra` is set to `True` (which is the default) any extra positional or\nkeyword arguments are dropped automatically.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "Werkzeug Tutorial", "path": "tutorial/index", "type": "Other", "text": "\nWelcome to the Werkzeug tutorial in which we will create a TinyURL clone that\nstores URLs in a redis instance. The libraries we will use for this\napplications are Jinja 2 for the templates, redis for the database layer and,\nof course, Werkzeug for the WSGI layer.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "wrap_file()", "path": "wsgi/index#werkzeug.wsgi.wrap_file", "type": "werkzeug.wsgi", "text": "\nWraps a file. This uses the WSGI server\u2019s file wrapper if available or\notherwise the generic `FileWrapper`.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "WSGI Helpers", "path": "wsgi/index", "type": "Other", "text": "\nThe following classes and functions are designed to make working with the WSGI\nspecification easier or operate on the WSGI layer. All the functionality from\nthis module is available on the high-level Request / Response Objects.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "WSGI Protocol Linter", "path": "middleware/lint/index", "type": "Other", "text": "\nThis module provides a middleware that performs sanity checks on the behavior\nof the WSGI server and application. It checks that the PEP 3333 WSGI spec is\nproperly implemented. It also warns on some common HTTP errors such as non-\nempty responses for 304 status codes.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "WWWAuthenticate", "path": "datastructures/index#werkzeug.datastructures.WWWAuthenticate", "type": "werkzeug.datastructures", "text": "\nProvides simple access to `WWW-Authenticate` headers.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "WWWAuthenticate.auth_property()", "path": "datastructures/index#werkzeug.datastructures.WWWAuthenticate.auth_property", "type": "werkzeug.datastructures", "text": "\nA static helper function for Authentication subclasses to add extra\nauthentication system properties onto a class:\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "WWWAuthenticate.set_basic()", "path": "datastructures/index#werkzeug.datastructures.WWWAuthenticate.set_basic", "type": "werkzeug.datastructures", "text": "\nClear the auth info and enable basic auth.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "WWWAuthenticate.set_digest()", "path": "datastructures/index#werkzeug.datastructures.WWWAuthenticate.set_digest", "type": "werkzeug.datastructures", "text": "\nClear the auth info and enable digest auth.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "WWWAuthenticate.to_header()", "path": "datastructures/index#werkzeug.datastructures.WWWAuthenticate.to_header", "type": "werkzeug.datastructures", "text": "\nConvert the stored values into a WWW-Authenticate header.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}, {"name": "X-Forwarded-For Proxy Fix", "path": "middleware/proxy_fix/index", "type": "Other", "text": "\nThis module provides a middleware that adjusts the WSGI environ based on\n`X-Forwarded-` headers that proxies in front of an application may set.\n\n  *[LIFO]: last-in, first-out\n  *[FIFO]: first-in, first-out\n\n"}]