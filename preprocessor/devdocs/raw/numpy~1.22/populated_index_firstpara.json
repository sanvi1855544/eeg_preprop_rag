[{"name": "()", "path": "glossary", "type": "Glossary", "text": "\nA parenthesized number followed by a comma denotes a tuple with one element.\nThe trailing comma distinguishes a one-element tuple from a parenthesized `n`.\n\n"}, {"name": "--overwrite-signature", "path": "f2py/usage", "type": "Using F2PY", "text": "\nF2PY can be used either as a command line tool `f2py` or as a Python module\n`numpy.f2py`. While we try to provide the command line tool as part of the\nnumpy setup, some platforms like Windows make it difficult to reliably put the\nexecutables on the `PATH`. We will refer to `f2py` in this document but you\nmay have to run it as a module:\n\n"}, {"name": "1", "path": "reference/arrays.scalars", "type": "Scalars", "text": "\nPython defines only one type of a particular data class (there is only one\ninteger type, one floating-point type, etc.). This can be convenient in\napplications that don\u2019t need to be concerned with all the ways data can be\nrepresented in a computer. For scientific computing, however, more control is\noften needed.\n\n"}, {"name": "1", "path": "reference/random/parallel", "type": "Parallel Applications", "text": "\nThere are three strategies implemented that can be used to produce repeatable\npseudo-random numbers across multiple processes (local or distributed).\n\n"}, {"name": "1", "path": "user/basics.broadcasting", "type": "User Guide", "text": "\nSee also\n\n"}, {"name": "1", "path": "reference/routines.polynomials", "type": "Polynomials", "text": "\nPolynomials in NumPy can be created, manipulated, and even fitted using the\nconvenience classes of the `numpy.polynomial` package, introduced in NumPy\n1.4.\n\n"}, {"name": "1", "path": "reference/routines.polynomials.chebyshev", "type": "Chebyshev Series ( \n        \n         numpy.polynomial.chebyshev\n        \n        )", "text": "\nThis module provides a number of objects (mostly functions) useful for dealing\nwith Chebyshev series, including a `Chebyshev` class that encapsulates the\nusual arithmetic operations. (General information on how this module\nrepresents and works with such polynomials is in the docstring for its\n\u201cparent\u201d sub-package, `numpy.polynomial`).\n\n"}, {"name": "add_data_dir()", "path": "reference/distutils#numpy.distutils.misc_util.Configuration.add_data_dir", "type": "Packaging ( \n    \n     numpy.distutils\n    \n    )", "text": "\nRecursively add files under data_path to data_files list.\n\n"}, {"name": "add_data_files()", "path": "reference/distutils#numpy.distutils.misc_util.Configuration.add_data_files", "type": "Packaging ( \n    \n     numpy.distutils\n    \n    )", "text": "\nAdd data files to configuration data_files.\n\n"}, {"name": "add_extension()", "path": "reference/distutils#numpy.distutils.misc_util.Configuration.add_extension", "type": "Packaging ( \n    \n     numpy.distutils\n    \n    )", "text": "\nAdd extension to configuration.\n\n"}, {"name": "add_headers()", "path": "reference/distutils#numpy.distutils.misc_util.Configuration.add_headers", "type": "Packaging ( \n    \n     numpy.distutils\n    \n    )", "text": "\nAdd installable headers to configuration.\n\n"}, {"name": "add_include_dirs()", "path": "reference/distutils#numpy.distutils.misc_util.Configuration.add_include_dirs", "type": "Packaging ( \n    \n     numpy.distutils\n    \n    )", "text": "\nAdd paths to configuration include directories.\n\n"}, {"name": "add_installed_library()", "path": "reference/distutils#numpy.distutils.misc_util.Configuration.add_installed_library", "type": "Packaging ( \n    \n     numpy.distutils\n    \n    )", "text": "\nSimilar to add_library, but the specified library is installed.\n\n"}, {"name": "add_library()", "path": "reference/distutils#numpy.distutils.misc_util.Configuration.add_library", "type": "Packaging ( \n    \n     numpy.distutils\n    \n    )", "text": "\nAdd library to configuration.\n\n"}, {"name": "add_npy_pkg_config()", "path": "reference/distutils#numpy.distutils.misc_util.Configuration.add_npy_pkg_config", "type": "Packaging ( \n    \n     numpy.distutils\n    \n    )", "text": "\nGenerate and install a npy-pkg config file from a template.\n\n"}, {"name": "add_scripts()", "path": "reference/distutils#numpy.distutils.misc_util.Configuration.add_scripts", "type": "Packaging ( \n    \n     numpy.distutils\n    \n    )", "text": "\nAdd scripts to configuration.\n\n"}, {"name": "add_subpackage()", "path": "reference/distutils#numpy.distutils.misc_util.Configuration.add_subpackage", "type": "Packaging ( \n    \n     numpy.distutils\n    \n    )", "text": "\nAdd a sub-package to the current Configuration instance.\n\n"}, {"name": "Additional Git Resources", "path": "dev/gitwash/git_resources", "type": "Development", "text": "\nThere are many ways of working with git; here are some posts on the rules of\nthumb that other projects have come up with:\n\n"}, {"name": "Advanced debugging tools", "path": "dev/development_advanced_debugging", "type": "Development", "text": "\nIf you reached here, you want to dive into, or use, more advanced tooling.\nThis is usually not necessary for first time contributors and most day-to-day\ndevelopment. These are used more rarely, for example close to a new NumPy\nrelease, or when a large or particular complex change was made.\n\n"}, {"name": "Advanced F2PY use cases", "path": "f2py/advanced", "type": "Advanced F2PY use cases", "text": "\nUser-defined Python C/API functions can be defined inside signature files\nusing `usercode` and `pymethoddef` statements (they must be used inside the\n`python module` block). For example, the following signature file `spam.pyf`\n\n"}, {"name": "Array creation", "path": "user/basics.creation", "type": "User Guide", "text": "\nSee also\n\n"}, {"name": "Array creation routines", "path": "reference/routines.array-creation", "type": "Array creation routines", "text": "\nSee also\n\n"}, {"name": "Array manipulation routines", "path": "reference/routines.array-manipulation", "type": "Array manipulation routines", "text": "\n`copyto`(dst, src[, casting, where])\n\n"}, {"name": "Array objects", "path": "reference/arrays", "type": "Array objects", "text": "\nNumPy provides an N-dimensional array type, the ndarray, which describes a\ncollection of \u201citems\u201d of the same type. The items can be indexed using for\nexample N integers.\n\n"}, {"name": "Binary operations", "path": "reference/routines.bitwise", "type": "Binary operations", "text": "\n`bitwise_and`(x1, x2, /[, out, where, ...])\n\n"}, {"name": "Bit Generators", "path": "reference/random/bit_generators/index", "type": "Bit Generators", "text": "\nThe random values produced by `Generator` originate in a BitGenerator. The\nBitGenerators do not directly provide random numbers and only contains methods\nused for seeding, getting or setting the state, jumping or advancing the\nstate, and for accessing low-level wrappers for consumption by code that can\nefficiently access the functions provided, e.g., numba.\n\n"}, {"name": "broadcast.index", "path": "reference/generated/numpy.broadcast.index", "type": "Standard array subclasses", "text": "\nattribute\n\n"}, {"name": "broadcast.iters", "path": "reference/generated/numpy.broadcast.iters", "type": "Standard array subclasses", "text": "\nattribute\n\n"}, {"name": "broadcast.nd", "path": "reference/generated/numpy.broadcast.nd", "type": "Standard array subclasses", "text": "\nattribute\n\n"}, {"name": "broadcast.ndim", "path": "reference/generated/numpy.broadcast.ndim", "type": "Standard array subclasses", "text": "\nattribute\n\n"}, {"name": "broadcast.numiter", "path": "reference/generated/numpy.broadcast.numiter", "type": "Standard array subclasses", "text": "\nattribute\n\n"}, {"name": "broadcast.reset()", "path": "reference/generated/numpy.broadcast.reset", "type": "numpy.broadcast.reset", "text": "\nmethod\n\n"}, {"name": "broadcast.size", "path": "reference/generated/numpy.broadcast.size", "type": "Standard array subclasses", "text": "\nattribute\n\n"}, {"name": "build_src", "path": "f2py/buildtools/distutils", "type": "Using via \n        \n         numpy.distutils", "text": "\n`numpy.distutils` is part of NumPy, and extends the standard Python\n`distutils` module to deal with Fortran sources and F2PY signature files, e.g.\ncompile Fortran sources, call F2PY to construct extension modules, etc.\n\n"}, {"name": "Building from source", "path": "user/building", "type": "User Guide", "text": "\nThere are two options for building NumPy- building with Gitpod or locally from\nsource. Your choice depends on your operating system and familiarity with the\ncommand line.\n\n"}, {"name": "Building the NumPy API and reference docs", "path": "dev/howto_build_docs", "type": "Development", "text": "\nIf you only want to get the documentation, note that pre-built versions can be\nfound at\n\n"}, {"name": "busdaycalendar.holidays", "path": "reference/generated/numpy.busdaycalendar.holidays", "type": "Datetime support functions", "text": "\nattribute\n\n"}, {"name": "busdaycalendar.weekmask", "path": "reference/generated/numpy.busdaycalendar.weekmask", "type": "Datetime support functions", "text": "\nattribute\n\n"}, {"name": "Byte-swapping", "path": "user/basics.byteswapping", "type": "User Guide", "text": "\nThe `ndarray` is an object that provide a python array interface to data in\nmemory.\n\n"}, {"name": "C API Deprecations", "path": "reference/c-api/deprecations", "type": "C API Deprecations", "text": "\nThe API exposed by NumPy for third-party extensions has grown over years of\nreleases, and has allowed programmers to directly access NumPy functionality\nfrom C. This API can be best described as \u201corganic\u201d. It has emerged from\nmultiple competing desires and from multiple points of view over the years,\nstrongly influenced by the desire to make it easy for users to move to NumPy\nfrom Numeric and Numarray. The core API originated with Numeric in 1995 and\nthere are patterns such as the heavy use of macros written to mimic Python\u2019s\nC-API as well as account for compiler technology of the late 90\u2019s. There is\nalso only a small group of volunteers who have had very little time to spend\non improving this API.\n\n"}, {"name": "char **NpyIter_GetDataPtrArray()", "path": "reference/c-api/iterator#c.NpyIter_GetDataPtrArray", "type": "Array Iterator API", "text": "\nThis gives back a pointer to the `nop` data pointers. If\n`NPY_ITER_EXTERNAL_LOOP` was not specified, each data pointer points to the\ncurrent data item of the iterator. If no inner iteration was specified, it\npoints to the first data item of the inner loop.\n\n"}, {"name": "char **NpyIter_GetInitialDataPtrArray()", "path": "reference/c-api/iterator#c.NpyIter_GetInitialDataPtrArray", "type": "Array Iterator API", "text": "\nGets the array of data pointers directly into the arrays (never into the\nbuffers), corresponding to iteration index 0.\n\n"}, {"name": "char *core_signature", "path": "reference/c-api/types-and-structures#c.PyUFuncObject.core_signature", "type": "Python Types and C-Structures", "text": "\nCore signature string\n\n"}, {"name": "char *data", "path": "reference/c-api/types-and-structures#c.NPY_AO.data", "type": "Python Types and C-Structures", "text": "\nAccessible via `PyArray_DATA`, this data member is a pointer to the first\nelement of the array. This pointer can (and normally should) be recast to the\ndata type of the array.\n\n"}, {"name": "char *dataptr", "path": "reference/c-api/types-and-structures#c.PyArrayIterObject.dataptr", "type": "Python Types and C-Structures", "text": "\nThis member points to an element in the ndarray indicated by the index.\n\n"}, {"name": "char *doc", "path": "reference/c-api/types-and-structures#c.PyUFuncObject.doc", "type": "Python Types and C-Structures", "text": "\nDocumentation for the ufunc. Should not contain the function signature as this\nis generated dynamically when __doc__ is retrieved.\n\n"}, {"name": "char *name", "path": "reference/c-api/types-and-structures#c.PyUFuncObject.name", "type": "Python Types and C-Structures", "text": "\nA string name for the ufunc. This is used dynamically to build the __doc__\nattribute of ufuncs.\n\n"}, {"name": "char *PyArray_BYTES()", "path": "reference/c-api/array#c.PyArray_BYTES", "type": "Array API", "text": "\nThese two macros are similar and obtain the pointer to the data-buffer for the\narray. The first macro can (and should be) assigned to a particular pointer\nwhere the second is for generic processing. If you have not guaranteed a\ncontiguous and/or aligned array then be sure you understand how to access the\ndata in the array to avoid memory and/or alignment problems.\n\n"}, {"name": "char *PyArray_One()", "path": "reference/c-api/array#c.PyArray_One", "type": "Array API", "text": "\nA pointer to newly created memory of size arr ->itemsize that holds the\nrepresentation of 1 for that type. The returned pointer, ret, must be freed\nusing `PyDataMem_FREE` (ret) when it is not needed anymore.\n\n"}, {"name": "char *PyArray_Zero()", "path": "reference/c-api/array#c.PyArray_Zero", "type": "Array API", "text": "\nA pointer to newly created memory of size arr ->itemsize that holds the\nrepresentation of 0 for that type. The returned pointer, ret, must be freed\nusing `PyDataMem_FREE` (ret) when it is not needed anymore.\n\n"}, {"name": "char *PyDataMem_RENEW()", "path": "reference/c-api/array#c.PyDataMem_RENEW", "type": "Array API", "text": "\nMacros to allocate, free, and reallocate memory. These macros are used\ninternally to create arrays.\n\n"}, {"name": "char *types", "path": "reference/c-api/types-and-structures#c.PyUFuncObject.types", "type": "Python Types and C-Structures", "text": "\nAn array of \\\\(nargs \\times ntypes\\\\) 8-bit type_numbers which contains the\ntype signature for the function for each of the supported (builtin) data\ntypes. For each of the ntypes functions, the corresponding set of type numbers\nin this array shows how the args argument should be interpreted in the 1-d\nvector loop. These type numbers do not have to be the same type and mixed-type\nufuncs are supported.\n\n"}, {"name": "char byteorder", "path": "reference/c-api/types-and-structures#c.PyArray_Descr.byteorder", "type": "Python Types and C-Structures", "text": "\nA character indicating the byte-order: \u2018>\u2019 (big-endian), \u2018<\u2019 (little- endian),\n\u2018=\u2019 (native), \u2018|\u2019 (irrelevant, ignore). All builtin data- types have byteorder\n\u2018=\u2019.\n\n"}, {"name": "char flags", "path": "reference/c-api/types-and-structures#c.PyArray_Descr.flags", "type": "Python Types and C-Structures", "text": "\nA data-type bit-flag that determines if the data-type exhibits object- array\nlike behavior. Each bit in this member is a flag which are named as:\n\n"}, {"name": "char kind", "path": "reference/c-api/types-and-structures#c.PyArray_Descr.kind", "type": "Python Types and C-Structures", "text": "\nA character code indicating the kind of array (using the array interface\ntypestring notation). A \u2018b\u2019 represents Boolean, a \u2018i\u2019 represents signed\ninteger, a \u2018u\u2019 represents unsigned integer, \u2018f\u2019 represents floating point, \u2018c\u2019\nrepresents complex floating point, \u2018S\u2019 represents 8-bit zero-terminated bytes,\n\u2018U\u2019 represents 32-bit/character unicode string, and \u2018V\u2019 represents arbitrary.\n\n"}, {"name": "char type", "path": "reference/c-api/types-and-structures#c.PyArray_Descr.type", "type": "Python Types and C-Structures", "text": "\nA traditional character code indicating the data type.\n\n"}, {"name": "char typekind", "path": "reference/c-api/types-and-structures#c.PyArrayInterface.typekind", "type": "Python Types and C-Structures", "text": "\nA character indicating what kind of array is present according to the\ntypestring convention with \u2018t\u2019 -> bitfield, \u2018b\u2019 -> Boolean, \u2018i\u2019 -> signed\ninteger, \u2018u\u2019 -> unsigned integer, \u2018f\u2019 -> floating point, \u2018c\u2019 -> complex\nfloating point, \u2018O\u2019 -> object, \u2018S\u2019 -> (byte-)string, \u2018U\u2019 -> unicode, \u2018V\u2019 ->\nvoid.\n\n"}, {"name": "char.add()", "path": "reference/generated/numpy.char.add", "type": "numpy.char.add", "text": "\nReturn element-wise string concatenation for two arrays of str or unicode.\n\n"}, {"name": "char.array()", "path": "reference/generated/numpy.char.array", "type": "numpy.char.array", "text": "\nCreate a `chararray`.\n\n"}, {"name": "char.asarray()", "path": "reference/generated/numpy.char.asarray", "type": "numpy.char.asarray", "text": "\nConvert the input to a `chararray`, copying the data only if necessary.\n\n"}, {"name": "char.capitalize()", "path": "reference/generated/numpy.char.capitalize", "type": "numpy.char.capitalize", "text": "\nReturn a copy of `a` with only the first character of each element\ncapitalized.\n\n"}, {"name": "char.center()", "path": "reference/generated/numpy.char.center", "type": "numpy.char.center", "text": "\nReturn a copy of `a` with its elements centered in a string of length `width`.\n\n"}, {"name": "char.chararray.argsort()", "path": "reference/generated/numpy.char.chararray.argsort", "type": "numpy.char.chararray.argsort", "text": "\nmethod\n\n"}, {"name": "char.chararray.astype()", "path": "reference/generated/numpy.char.chararray.astype", "type": "numpy.char.chararray.astype", "text": "\nmethod\n\n"}, {"name": "char.chararray.base", "path": "reference/generated/numpy.char.chararray.base", "type": "String operations", "text": "\nattribute\n\n"}, {"name": "char.chararray.copy()", "path": "reference/generated/numpy.char.chararray.copy", "type": "numpy.char.chararray.copy", "text": "\nmethod\n\n"}, {"name": "char.chararray.count()", "path": "reference/generated/numpy.char.chararray.count", "type": "numpy.char.chararray.count", "text": "\nmethod\n\n"}, {"name": "char.chararray.ctypes", "path": "reference/generated/numpy.char.chararray.ctypes", "type": "String operations", "text": "\nattribute\n\n"}, {"name": "char.chararray.data", "path": "reference/generated/numpy.char.chararray.data", "type": "String operations", "text": "\nattribute\n\n"}, {"name": "char.chararray.decode()", "path": "reference/generated/numpy.char.chararray.decode", "type": "numpy.char.chararray.decode", "text": "\nmethod\n\n"}, {"name": "char.chararray.dtype", "path": "reference/generated/numpy.char.chararray.dtype", "type": "String operations", "text": "\nattribute\n\n"}, {"name": "char.chararray.dump()", "path": "reference/generated/numpy.char.chararray.dump", "type": "numpy.char.chararray.dump", "text": "\nmethod\n\n"}, {"name": "char.chararray.dumps()", "path": "reference/generated/numpy.char.chararray.dumps", "type": "numpy.char.chararray.dumps", "text": "\nmethod\n\n"}, {"name": "char.chararray.encode()", "path": "reference/generated/numpy.char.chararray.encode", "type": "numpy.char.chararray.encode", "text": "\nmethod\n\n"}, {"name": "char.chararray.endswith()", "path": "reference/generated/numpy.char.chararray.endswith", "type": "numpy.char.chararray.endswith", "text": "\nmethod\n\n"}, {"name": "char.chararray.expandtabs()", "path": "reference/generated/numpy.char.chararray.expandtabs", "type": "numpy.char.chararray.expandtabs", "text": "\nmethod\n\n"}, {"name": "char.chararray.fill()", "path": "reference/generated/numpy.char.chararray.fill", "type": "numpy.char.chararray.fill", "text": "\nmethod\n\n"}, {"name": "char.chararray.find()", "path": "reference/generated/numpy.char.chararray.find", "type": "numpy.char.chararray.find", "text": "\nmethod\n\n"}, {"name": "char.chararray.flags", "path": "reference/generated/numpy.char.chararray.flags", "type": "String operations", "text": "\nattribute\n\n"}, {"name": "char.chararray.flat", "path": "reference/generated/numpy.char.chararray.flat", "type": "String operations", "text": "\nattribute\n\n"}, {"name": "char.chararray.flatten()", "path": "reference/generated/numpy.char.chararray.flatten", "type": "numpy.char.chararray.flatten", "text": "\nmethod\n\n"}, {"name": "char.chararray.getfield()", "path": "reference/generated/numpy.char.chararray.getfield", "type": "numpy.char.chararray.getfield", "text": "\nmethod\n\n"}, {"name": "char.chararray.imag", "path": "reference/generated/numpy.char.chararray.imag", "type": "String operations", "text": "\nattribute\n\n"}, {"name": "char.chararray.index()", "path": "reference/generated/numpy.char.chararray.index", "type": "numpy.char.chararray.index", "text": "\nmethod\n\n"}, {"name": "char.chararray.isalnum()", "path": "reference/generated/numpy.char.chararray.isalnum", "type": "numpy.char.chararray.isalnum", "text": "\nmethod\n\n"}, {"name": "char.chararray.isalpha()", "path": "reference/generated/numpy.char.chararray.isalpha", "type": "numpy.char.chararray.isalpha", "text": "\nmethod\n\n"}, {"name": "char.chararray.isdecimal()", "path": "reference/generated/numpy.char.chararray.isdecimal", "type": "numpy.char.chararray.isdecimal", "text": "\nmethod\n\n"}, {"name": "char.chararray.isdigit()", "path": "reference/generated/numpy.char.chararray.isdigit", "type": "numpy.char.chararray.isdigit", "text": "\nmethod\n\n"}, {"name": "char.chararray.islower()", "path": "reference/generated/numpy.char.chararray.islower", "type": "numpy.char.chararray.islower", "text": "\nmethod\n\n"}, {"name": "char.chararray.isnumeric()", "path": "reference/generated/numpy.char.chararray.isnumeric", "type": "numpy.char.chararray.isnumeric", "text": "\nmethod\n\n"}, {"name": "char.chararray.isspace()", "path": "reference/generated/numpy.char.chararray.isspace", "type": "numpy.char.chararray.isspace", "text": "\nmethod\n\n"}, {"name": "char.chararray.istitle()", "path": "reference/generated/numpy.char.chararray.istitle", "type": "numpy.char.chararray.istitle", "text": "\nmethod\n\n"}, {"name": "char.chararray.isupper()", "path": "reference/generated/numpy.char.chararray.isupper", "type": "numpy.char.chararray.isupper", "text": "\nmethod\n\n"}, {"name": "char.chararray.item()", "path": "reference/generated/numpy.char.chararray.item", "type": "numpy.char.chararray.item", "text": "\nmethod\n\n"}, {"name": "char.chararray.itemsize", "path": "reference/generated/numpy.char.chararray.itemsize", "type": "String operations", "text": "\nattribute\n\n"}, {"name": "char.chararray.join()", "path": "reference/generated/numpy.char.chararray.join", "type": "numpy.char.chararray.join", "text": "\nmethod\n\n"}, {"name": "char.chararray.ljust()", "path": "reference/generated/numpy.char.chararray.ljust", "type": "numpy.char.chararray.ljust", "text": "\nmethod\n\n"}, {"name": "char.chararray.lower()", "path": "reference/generated/numpy.char.chararray.lower", "type": "numpy.char.chararray.lower", "text": "\nmethod\n\n"}, {"name": "char.chararray.lstrip()", "path": "reference/generated/numpy.char.chararray.lstrip", "type": "numpy.char.chararray.lstrip", "text": "\nmethod\n\n"}, {"name": "char.chararray.nbytes", "path": "reference/generated/numpy.char.chararray.nbytes", "type": "String operations", "text": "\nattribute\n\n"}, {"name": "char.chararray.ndim", "path": "reference/generated/numpy.char.chararray.ndim", "type": "String operations", "text": "\nattribute\n\n"}, {"name": "char.chararray.nonzero()", "path": "reference/generated/numpy.char.chararray.nonzero", "type": "numpy.char.chararray.nonzero", "text": "\nmethod\n\n"}, {"name": "char.chararray.put()", "path": "reference/generated/numpy.char.chararray.put", "type": "numpy.char.chararray.put", "text": "\nmethod\n\n"}, {"name": "char.chararray.ravel()", "path": "reference/generated/numpy.char.chararray.ravel", "type": "numpy.char.chararray.ravel", "text": "\nmethod\n\n"}, {"name": "char.chararray.real", "path": "reference/generated/numpy.char.chararray.real", "type": "String operations", "text": "\nattribute\n\n"}, {"name": "char.chararray.repeat()", "path": "reference/generated/numpy.char.chararray.repeat", "type": "numpy.char.chararray.repeat", "text": "\nmethod\n\n"}, {"name": "char.chararray.replace()", "path": "reference/generated/numpy.char.chararray.replace", "type": "numpy.char.chararray.replace", "text": "\nmethod\n\n"}, {"name": "char.chararray.reshape()", "path": "reference/generated/numpy.char.chararray.reshape", "type": "numpy.char.chararray.reshape", "text": "\nmethod\n\n"}, {"name": "char.chararray.resize()", "path": "reference/generated/numpy.char.chararray.resize", "type": "numpy.char.chararray.resize", "text": "\nmethod\n\n"}, {"name": "char.chararray.rfind()", "path": "reference/generated/numpy.char.chararray.rfind", "type": "numpy.char.chararray.rfind", "text": "\nmethod\n\n"}, {"name": "char.chararray.rindex()", "path": "reference/generated/numpy.char.chararray.rindex", "type": "numpy.char.chararray.rindex", "text": "\nmethod\n\n"}, {"name": "char.chararray.rjust()", "path": "reference/generated/numpy.char.chararray.rjust", "type": "numpy.char.chararray.rjust", "text": "\nmethod\n\n"}, {"name": "char.chararray.rsplit()", "path": "reference/generated/numpy.char.chararray.rsplit", "type": "numpy.char.chararray.rsplit", "text": "\nmethod\n\n"}, {"name": "char.chararray.rstrip()", "path": "reference/generated/numpy.char.chararray.rstrip", "type": "numpy.char.chararray.rstrip", "text": "\nmethod\n\n"}, {"name": "char.chararray.searchsorted()", "path": "reference/generated/numpy.char.chararray.searchsorted", "type": "numpy.char.chararray.searchsorted", "text": "\nmethod\n\n"}, {"name": "char.chararray.setfield()", "path": "reference/generated/numpy.char.chararray.setfield", "type": "numpy.char.chararray.setfield", "text": "\nmethod\n\n"}, {"name": "char.chararray.setflags()", "path": "reference/generated/numpy.char.chararray.setflags", "type": "numpy.char.chararray.setflags", "text": "\nmethod\n\n"}, {"name": "char.chararray.shape", "path": "reference/generated/numpy.char.chararray.shape", "type": "String operations", "text": "\nattribute\n\n"}, {"name": "char.chararray.size", "path": "reference/generated/numpy.char.chararray.size", "type": "String operations", "text": "\nattribute\n\n"}, {"name": "char.chararray.sort()", "path": "reference/generated/numpy.char.chararray.sort", "type": "numpy.char.chararray.sort", "text": "\nmethod\n\n"}, {"name": "char.chararray.split()", "path": "reference/generated/numpy.char.chararray.split", "type": "numpy.char.chararray.split", "text": "\nmethod\n\n"}, {"name": "char.chararray.splitlines()", "path": "reference/generated/numpy.char.chararray.splitlines", "type": "numpy.char.chararray.splitlines", "text": "\nmethod\n\n"}, {"name": "char.chararray.squeeze()", "path": "reference/generated/numpy.char.chararray.squeeze", "type": "numpy.char.chararray.squeeze", "text": "\nmethod\n\n"}, {"name": "char.chararray.startswith()", "path": "reference/generated/numpy.char.chararray.startswith", "type": "numpy.char.chararray.startswith", "text": "\nmethod\n\n"}, {"name": "char.chararray.strides", "path": "reference/generated/numpy.char.chararray.strides", "type": "String operations", "text": "\nattribute\n\n"}, {"name": "char.chararray.strip()", "path": "reference/generated/numpy.char.chararray.strip", "type": "numpy.char.chararray.strip", "text": "\nmethod\n\n"}, {"name": "char.chararray.swapaxes()", "path": "reference/generated/numpy.char.chararray.swapaxes", "type": "numpy.char.chararray.swapaxes", "text": "\nmethod\n\n"}, {"name": "char.chararray.swapcase()", "path": "reference/generated/numpy.char.chararray.swapcase", "type": "numpy.char.chararray.swapcase", "text": "\nmethod\n\n"}, {"name": "char.chararray.T", "path": "reference/generated/numpy.char.chararray.t", "type": "String operations", "text": "\nattribute\n\n"}, {"name": "char.chararray.take()", "path": "reference/generated/numpy.char.chararray.take", "type": "numpy.char.chararray.take", "text": "\nmethod\n\n"}, {"name": "char.chararray.title()", "path": "reference/generated/numpy.char.chararray.title", "type": "numpy.char.chararray.title", "text": "\nmethod\n\n"}, {"name": "char.chararray.tobytes()", "path": "reference/generated/numpy.char.chararray.tobytes", "type": "String operations", "text": "\nmethod\n\n"}, {"name": "char.chararray.tofile()", "path": "reference/generated/numpy.char.chararray.tofile", "type": "numpy.char.chararray.tofile", "text": "\nmethod\n\n"}, {"name": "char.chararray.tolist()", "path": "reference/generated/numpy.char.chararray.tolist", "type": "numpy.char.chararray.tolist", "text": "\nmethod\n\n"}, {"name": "char.chararray.tostring()", "path": "reference/generated/numpy.char.chararray.tostring", "type": "numpy.char.chararray.tostring", "text": "\nmethod\n\n"}, {"name": "char.chararray.translate()", "path": "reference/generated/numpy.char.chararray.translate", "type": "numpy.char.chararray.translate", "text": "\nmethod\n\n"}, {"name": "char.chararray.transpose()", "path": "reference/generated/numpy.char.chararray.transpose", "type": "numpy.char.chararray.transpose", "text": "\nmethod\n\n"}, {"name": "char.chararray.upper()", "path": "reference/generated/numpy.char.chararray.upper", "type": "numpy.char.chararray.upper", "text": "\nmethod\n\n"}, {"name": "char.chararray.view()", "path": "reference/generated/numpy.char.chararray.view", "type": "numpy.char.chararray.view", "text": "\nmethod\n\n"}, {"name": "char.chararray.zfill()", "path": "reference/generated/numpy.char.chararray.zfill", "type": "numpy.char.chararray.zfill", "text": "\nmethod\n\n"}, {"name": "char.compare_chararrays()", "path": "reference/generated/numpy.char.compare_chararrays", "type": "numpy.char.compare_chararrays", "text": "\nPerforms element-wise comparison of two string arrays using the comparison\noperator specified by `cmp_op`.\n\n"}, {"name": "char.count()", "path": "reference/generated/numpy.char.count", "type": "numpy.char.count", "text": "\nReturns an array with the number of non-overlapping occurrences of substring\n`sub` in the range [`start`, `end`].\n\n"}, {"name": "char.decode()", "path": "reference/generated/numpy.char.decode", "type": "numpy.char.decode", "text": "\nCalls `str.decode` element-wise.\n\n"}, {"name": "char.encode()", "path": "reference/generated/numpy.char.encode", "type": "numpy.char.encode", "text": "\nCalls `str.encode` element-wise.\n\n"}, {"name": "char.endswith()", "path": "reference/generated/numpy.char.endswith", "type": "numpy.char.endswith", "text": "\nReturns a boolean array which is `True` where the string element in `a` ends\nwith `suffix`, otherwise `False`.\n\n"}, {"name": "char.equal()", "path": "reference/generated/numpy.char.equal", "type": "numpy.char.equal", "text": "\nReturn (x1 == x2) element-wise.\n\n"}, {"name": "char.expandtabs()", "path": "reference/generated/numpy.char.expandtabs", "type": "numpy.char.expandtabs", "text": "\nReturn a copy of each string element where all tab characters are replaced by\none or more spaces.\n\n"}, {"name": "char.find()", "path": "reference/generated/numpy.char.find", "type": "numpy.char.find", "text": "\nFor each element, return the lowest index in the string where substring `sub`\nis found.\n\n"}, {"name": "char.greater()", "path": "reference/generated/numpy.char.greater", "type": "numpy.char.greater", "text": "\nReturn (x1 > x2) element-wise.\n\n"}, {"name": "char.greater_equal()", "path": "reference/generated/numpy.char.greater_equal", "type": "numpy.char.greater_equal", "text": "\nReturn (x1 >= x2) element-wise.\n\n"}, {"name": "char.index()", "path": "reference/generated/numpy.char.index", "type": "numpy.char.index", "text": "\nLike `find`, but raises `ValueError` when the substring is not found.\n\n"}, {"name": "char.isalnum()", "path": "reference/generated/numpy.char.isalnum", "type": "numpy.char.isalnum", "text": "\nReturns true for each element if all characters in the string are alphanumeric\nand there is at least one character, false otherwise.\n\n"}, {"name": "char.isalpha()", "path": "reference/generated/numpy.char.isalpha", "type": "numpy.char.isalpha", "text": "\nReturns true for each element if all characters in the string are alphabetic\nand there is at least one character, false otherwise.\n\n"}, {"name": "char.isdecimal()", "path": "reference/generated/numpy.char.isdecimal", "type": "numpy.char.isdecimal", "text": "\nFor each element, return True if there are only decimal characters in the\nelement.\n\n"}, {"name": "char.isdigit()", "path": "reference/generated/numpy.char.isdigit", "type": "numpy.char.isdigit", "text": "\nReturns true for each element if all characters in the string are digits and\nthere is at least one character, false otherwise.\n\n"}, {"name": "char.islower()", "path": "reference/generated/numpy.char.islower", "type": "numpy.char.islower", "text": "\nReturns true for each element if all cased characters in the string are\nlowercase and there is at least one cased character, false otherwise.\n\n"}, {"name": "char.isnumeric()", "path": "reference/generated/numpy.char.isnumeric", "type": "numpy.char.isnumeric", "text": "\nFor each element, return True if there are only numeric characters in the\nelement.\n\n"}, {"name": "char.isspace()", "path": "reference/generated/numpy.char.isspace", "type": "numpy.char.isspace", "text": "\nReturns true for each element if there are only whitespace characters in the\nstring and there is at least one character, false otherwise.\n\n"}, {"name": "char.istitle()", "path": "reference/generated/numpy.char.istitle", "type": "numpy.char.istitle", "text": "\nReturns true for each element if the element is a titlecased string and there\nis at least one character, false otherwise.\n\n"}, {"name": "char.isupper()", "path": "reference/generated/numpy.char.isupper", "type": "numpy.char.isupper", "text": "\nReturns true for each element if all cased characters in the string are\nuppercase and there is at least one character, false otherwise.\n\n"}, {"name": "char.join()", "path": "reference/generated/numpy.char.join", "type": "numpy.char.join", "text": "\nReturn a string which is the concatenation of the strings in the sequence\n`seq`.\n\n"}, {"name": "char.less()", "path": "reference/generated/numpy.char.less", "type": "numpy.char.less", "text": "\nReturn (x1 < x2) element-wise.\n\n"}, {"name": "char.less_equal()", "path": "reference/generated/numpy.char.less_equal", "type": "numpy.char.less_equal", "text": "\nReturn (x1 <= x2) element-wise.\n\n"}, {"name": "char.ljust()", "path": "reference/generated/numpy.char.ljust", "type": "numpy.char.ljust", "text": "\nReturn an array with the elements of `a` left-justified in a string of length\n`width`.\n\n"}, {"name": "char.lower()", "path": "reference/generated/numpy.char.lower", "type": "numpy.char.lower", "text": "\nReturn an array with the elements converted to lowercase.\n\n"}, {"name": "char.lstrip()", "path": "reference/generated/numpy.char.lstrip", "type": "numpy.char.lstrip", "text": "\nFor each element in `a`, return a copy with the leading characters removed.\n\n"}, {"name": "char.mod()", "path": "reference/generated/numpy.char.mod", "type": "numpy.char.mod", "text": "\nReturn (a % i), that is pre-Python 2.6 string formatting (interpolation),\nelement-wise for a pair of array_likes of str or unicode.\n\n"}, {"name": "char.multiply()", "path": "reference/generated/numpy.char.multiply", "type": "numpy.char.multiply", "text": "\nReturn (a * i), that is string multiple concatenation, element-wise.\n\n"}, {"name": "char.not_equal()", "path": "reference/generated/numpy.char.not_equal", "type": "numpy.char.not_equal", "text": "\nReturn (x1 != x2) element-wise.\n\n"}, {"name": "char.partition()", "path": "reference/generated/numpy.char.partition", "type": "numpy.char.partition", "text": "\nPartition each element in `a` around `sep`.\n\n"}, {"name": "char.replace()", "path": "reference/generated/numpy.char.replace", "type": "numpy.char.replace", "text": "\nFor each element in `a`, return a copy of the string with all occurrences of\nsubstring `old` replaced by `new`.\n\n"}, {"name": "char.rfind()", "path": "reference/generated/numpy.char.rfind", "type": "numpy.char.rfind", "text": "\nFor each element in `a`, return the highest index in the string where\nsubstring `sub` is found, such that `sub` is contained within [`start`,\n`end`].\n\n"}, {"name": "char.rindex()", "path": "reference/generated/numpy.char.rindex", "type": "numpy.char.rindex", "text": "\nLike `rfind`, but raises `ValueError` when the substring `sub` is not found.\n\n"}, {"name": "char.rjust()", "path": "reference/generated/numpy.char.rjust", "type": "numpy.char.rjust", "text": "\nReturn an array with the elements of `a` right-justified in a string of length\n`width`.\n\n"}, {"name": "char.rpartition()", "path": "reference/generated/numpy.char.rpartition", "type": "numpy.char.rpartition", "text": "\nPartition (split) each element around the right-most separator.\n\n"}, {"name": "char.rsplit()", "path": "reference/generated/numpy.char.rsplit", "type": "numpy.char.rsplit", "text": "\nFor each element in `a`, return a list of the words in the string, using `sep`\nas the delimiter string.\n\n"}, {"name": "char.rstrip()", "path": "reference/generated/numpy.char.rstrip", "type": "numpy.char.rstrip", "text": "\nFor each element in `a`, return a copy with the trailing characters removed.\n\n"}, {"name": "char.split()", "path": "reference/generated/numpy.char.split", "type": "numpy.char.split", "text": "\nFor each element in `a`, return a list of the words in the string, using `sep`\nas the delimiter string.\n\n"}, {"name": "char.splitlines()", "path": "reference/generated/numpy.char.splitlines", "type": "numpy.char.splitlines", "text": "\nFor each element in `a`, return a list of the lines in the element, breaking\nat line boundaries.\n\n"}, {"name": "char.startswith()", "path": "reference/generated/numpy.char.startswith", "type": "numpy.char.startswith", "text": "\nReturns a boolean array which is `True` where the string element in `a` starts\nwith `prefix`, otherwise `False`.\n\n"}, {"name": "char.str_len()", "path": "reference/generated/numpy.char.str_len", "type": "numpy.char.str_len", "text": "\nReturn len(a) element-wise.\n\n"}, {"name": "char.strip()", "path": "reference/generated/numpy.char.strip", "type": "numpy.char.strip", "text": "\nFor each element in `a`, return a copy with the leading and trailing\ncharacters removed.\n\n"}, {"name": "char.swapcase()", "path": "reference/generated/numpy.char.swapcase", "type": "numpy.char.swapcase", "text": "\nReturn element-wise a copy of the string with uppercase characters converted\nto lowercase and vice versa.\n\n"}, {"name": "char.title()", "path": "reference/generated/numpy.char.title", "type": "numpy.char.title", "text": "\nReturn element-wise title cased version of string or unicode.\n\n"}, {"name": "char.translate()", "path": "reference/generated/numpy.char.translate", "type": "numpy.char.translate", "text": "\nFor each element in `a`, return a copy of the string where all characters\noccurring in the optional argument `deletechars` are removed, and the\nremaining characters have been mapped through the given translation table.\n\n"}, {"name": "char.upper()", "path": "reference/generated/numpy.char.upper", "type": "numpy.char.upper", "text": "\nReturn an array with the elements converted to uppercase.\n\n"}, {"name": "char.zfill()", "path": "reference/generated/numpy.char.zfill", "type": "numpy.char.zfill", "text": "\nReturn the numeric string left-filled with zeros\n\n"}, {"name": "chararray.argsort()", "path": "reference/generated/numpy.chararray.argsort", "type": "numpy.chararray.argsort", "text": "\nmethod\n\n"}, {"name": "chararray.astype()", "path": "reference/generated/numpy.chararray.astype", "type": "numpy.chararray.astype", "text": "\nmethod\n\n"}, {"name": "chararray.base", "path": "reference/generated/numpy.chararray.base", "type": "String operations", "text": "\nattribute\n\n"}, {"name": "chararray.copy()", "path": "reference/generated/numpy.chararray.copy", "type": "numpy.chararray.copy", "text": "\nmethod\n\n"}, {"name": "chararray.count()", "path": "reference/generated/numpy.chararray.count", "type": "numpy.chararray.count", "text": "\nmethod\n\n"}, {"name": "chararray.ctypes", "path": "reference/generated/numpy.chararray.ctypes", "type": "String operations", "text": "\nattribute\n\n"}, {"name": "chararray.data", "path": "reference/generated/numpy.chararray.data", "type": "String operations", "text": "\nattribute\n\n"}, {"name": "chararray.decode()", "path": "reference/generated/numpy.chararray.decode", "type": "numpy.chararray.decode", "text": "\nmethod\n\n"}, {"name": "chararray.dump()", "path": "reference/generated/numpy.chararray.dump", "type": "numpy.chararray.dump", "text": "\nmethod\n\n"}, {"name": "chararray.dumps()", "path": "reference/generated/numpy.chararray.dumps", "type": "numpy.chararray.dumps", "text": "\nmethod\n\n"}, {"name": "chararray.encode()", "path": "reference/generated/numpy.chararray.encode", "type": "numpy.chararray.encode", "text": "\nmethod\n\n"}, {"name": "chararray.endswith()", "path": "reference/generated/numpy.chararray.endswith", "type": "numpy.chararray.endswith", "text": "\nmethod\n\n"}, {"name": "chararray.expandtabs()", "path": "reference/generated/numpy.chararray.expandtabs", "type": "numpy.chararray.expandtabs", "text": "\nmethod\n\n"}, {"name": "chararray.fill()", "path": "reference/generated/numpy.chararray.fill", "type": "numpy.chararray.fill", "text": "\nmethod\n\n"}, {"name": "chararray.find()", "path": "reference/generated/numpy.chararray.find", "type": "numpy.chararray.find", "text": "\nmethod\n\n"}, {"name": "chararray.flags", "path": "reference/generated/numpy.chararray.flags", "type": "String operations", "text": "\nattribute\n\n"}, {"name": "chararray.flat", "path": "reference/generated/numpy.chararray.flat", "type": "String operations", "text": "\nattribute\n\n"}, {"name": "chararray.flatten()", "path": "reference/generated/numpy.chararray.flatten", "type": "numpy.chararray.flatten", "text": "\nmethod\n\n"}, {"name": "chararray.getfield()", "path": "reference/generated/numpy.chararray.getfield", "type": "numpy.chararray.getfield", "text": "\nmethod\n\n"}, {"name": "chararray.index()", "path": "reference/generated/numpy.chararray.index", "type": "numpy.chararray.index", "text": "\nmethod\n\n"}, {"name": "chararray.isalnum()", "path": "reference/generated/numpy.chararray.isalnum", "type": "numpy.chararray.isalnum", "text": "\nmethod\n\n"}, {"name": "chararray.isalpha()", "path": "reference/generated/numpy.chararray.isalpha", "type": "numpy.chararray.isalpha", "text": "\nmethod\n\n"}, {"name": "chararray.isdecimal()", "path": "reference/generated/numpy.chararray.isdecimal", "type": "numpy.chararray.isdecimal", "text": "\nmethod\n\n"}, {"name": "chararray.isdigit()", "path": "reference/generated/numpy.chararray.isdigit", "type": "numpy.chararray.isdigit", "text": "\nmethod\n\n"}, {"name": "chararray.islower()", "path": "reference/generated/numpy.chararray.islower", "type": "numpy.chararray.islower", "text": "\nmethod\n\n"}, {"name": "chararray.isnumeric()", "path": "reference/generated/numpy.chararray.isnumeric", "type": "numpy.chararray.isnumeric", "text": "\nmethod\n\n"}, {"name": "chararray.isspace()", "path": "reference/generated/numpy.chararray.isspace", "type": "numpy.chararray.isspace", "text": "\nmethod\n\n"}, {"name": "chararray.istitle()", "path": "reference/generated/numpy.chararray.istitle", "type": "numpy.chararray.istitle", "text": "\nmethod\n\n"}, {"name": "chararray.isupper()", "path": "reference/generated/numpy.chararray.isupper", "type": "numpy.chararray.isupper", "text": "\nmethod\n\n"}, {"name": "chararray.item()", "path": "reference/generated/numpy.chararray.item", "type": "numpy.chararray.item", "text": "\nmethod\n\n"}, {"name": "chararray.itemsize", "path": "reference/generated/numpy.chararray.itemsize", "type": "String operations", "text": "\nattribute\n\n"}, {"name": "chararray.join()", "path": "reference/generated/numpy.chararray.join", "type": "numpy.chararray.join", "text": "\nmethod\n\n"}, {"name": "chararray.ljust()", "path": "reference/generated/numpy.chararray.ljust", "type": "numpy.chararray.ljust", "text": "\nmethod\n\n"}, {"name": "chararray.lower()", "path": "reference/generated/numpy.chararray.lower", "type": "numpy.chararray.lower", "text": "\nmethod\n\n"}, {"name": "chararray.lstrip()", "path": "reference/generated/numpy.chararray.lstrip", "type": "numpy.chararray.lstrip", "text": "\nmethod\n\n"}, {"name": "chararray.nbytes", "path": "reference/generated/numpy.chararray.nbytes", "type": "String operations", "text": "\nattribute\n\n"}, {"name": "chararray.ndim", "path": "reference/generated/numpy.chararray.ndim", "type": "String operations", "text": "\nattribute\n\n"}, {"name": "chararray.nonzero()", "path": "reference/generated/numpy.chararray.nonzero", "type": "numpy.chararray.nonzero", "text": "\nmethod\n\n"}, {"name": "chararray.put()", "path": "reference/generated/numpy.chararray.put", "type": "numpy.chararray.put", "text": "\nmethod\n\n"}, {"name": "chararray.ravel()", "path": "reference/generated/numpy.chararray.ravel", "type": "numpy.chararray.ravel", "text": "\nmethod\n\n"}, {"name": "chararray.repeat()", "path": "reference/generated/numpy.chararray.repeat", "type": "numpy.chararray.repeat", "text": "\nmethod\n\n"}, {"name": "chararray.replace()", "path": "reference/generated/numpy.chararray.replace", "type": "numpy.chararray.replace", "text": "\nmethod\n\n"}, {"name": "chararray.reshape()", "path": "reference/generated/numpy.chararray.reshape", "type": "numpy.chararray.reshape", "text": "\nmethod\n\n"}, {"name": "chararray.resize()", "path": "reference/generated/numpy.chararray.resize", "type": "numpy.chararray.resize", "text": "\nmethod\n\n"}, {"name": "chararray.rfind()", "path": "reference/generated/numpy.chararray.rfind", "type": "numpy.chararray.rfind", "text": "\nmethod\n\n"}, {"name": "chararray.rindex()", "path": "reference/generated/numpy.chararray.rindex", "type": "numpy.chararray.rindex", "text": "\nmethod\n\n"}, {"name": "chararray.rjust()", "path": "reference/generated/numpy.chararray.rjust", "type": "numpy.chararray.rjust", "text": "\nmethod\n\n"}, {"name": "chararray.rsplit()", "path": "reference/generated/numpy.chararray.rsplit", "type": "numpy.chararray.rsplit", "text": "\nmethod\n\n"}, {"name": "chararray.rstrip()", "path": "reference/generated/numpy.chararray.rstrip", "type": "numpy.chararray.rstrip", "text": "\nmethod\n\n"}, {"name": "chararray.searchsorted()", "path": "reference/generated/numpy.chararray.searchsorted", "type": "numpy.chararray.searchsorted", "text": "\nmethod\n\n"}, {"name": "chararray.setfield()", "path": "reference/generated/numpy.chararray.setfield", "type": "numpy.chararray.setfield", "text": "\nmethod\n\n"}, {"name": "chararray.setflags()", "path": "reference/generated/numpy.chararray.setflags", "type": "numpy.chararray.setflags", "text": "\nmethod\n\n"}, {"name": "chararray.size", "path": "reference/generated/numpy.chararray.size", "type": "String operations", "text": "\nattribute\n\n"}, {"name": "chararray.sort()", "path": "reference/generated/numpy.chararray.sort", "type": "numpy.chararray.sort", "text": "\nmethod\n\n"}, {"name": "chararray.split()", "path": "reference/generated/numpy.chararray.split", "type": "numpy.chararray.split", "text": "\nmethod\n\n"}, {"name": "chararray.splitlines()", "path": "reference/generated/numpy.chararray.splitlines", "type": "numpy.chararray.splitlines", "text": "\nmethod\n\n"}, {"name": "chararray.squeeze()", "path": "reference/generated/numpy.chararray.squeeze", "type": "numpy.chararray.squeeze", "text": "\nmethod\n\n"}, {"name": "chararray.startswith()", "path": "reference/generated/numpy.chararray.startswith", "type": "numpy.chararray.startswith", "text": "\nmethod\n\n"}, {"name": "chararray.strides", "path": "reference/generated/numpy.chararray.strides", "type": "String operations", "text": "\nattribute\n\n"}, {"name": "chararray.strip()", "path": "reference/generated/numpy.chararray.strip", "type": "numpy.chararray.strip", "text": "\nmethod\n\n"}, {"name": "chararray.swapaxes()", "path": "reference/generated/numpy.chararray.swapaxes", "type": "numpy.chararray.swapaxes", "text": "\nmethod\n\n"}, {"name": "chararray.swapcase()", "path": "reference/generated/numpy.chararray.swapcase", "type": "numpy.chararray.swapcase", "text": "\nmethod\n\n"}, {"name": "chararray.T", "path": "reference/generated/numpy.chararray.t", "type": "String operations", "text": "\nattribute\n\n"}, {"name": "chararray.take()", "path": "reference/generated/numpy.chararray.take", "type": "numpy.chararray.take", "text": "\nmethod\n\n"}, {"name": "chararray.title()", "path": "reference/generated/numpy.chararray.title", "type": "numpy.chararray.title", "text": "\nmethod\n\n"}, {"name": "chararray.tobytes()", "path": "reference/generated/numpy.chararray.tobytes", "type": "String operations", "text": "\nmethod\n\n"}, {"name": "chararray.tofile()", "path": "reference/generated/numpy.chararray.tofile", "type": "numpy.chararray.tofile", "text": "\nmethod\n\n"}, {"name": "chararray.tolist()", "path": "reference/generated/numpy.chararray.tolist", "type": "numpy.chararray.tolist", "text": "\nmethod\n\n"}, {"name": "chararray.tostring()", "path": "reference/generated/numpy.chararray.tostring", "type": "numpy.chararray.tostring", "text": "\nmethod\n\n"}, {"name": "chararray.translate()", "path": "reference/generated/numpy.chararray.translate", "type": "numpy.chararray.translate", "text": "\nmethod\n\n"}, {"name": "chararray.transpose()", "path": "reference/generated/numpy.chararray.transpose", "type": "numpy.chararray.transpose", "text": "\nmethod\n\n"}, {"name": "chararray.upper()", "path": "reference/generated/numpy.chararray.upper", "type": "numpy.chararray.upper", "text": "\nmethod\n\n"}, {"name": "chararray.view()", "path": "reference/generated/numpy.chararray.view", "type": "numpy.chararray.view", "text": "\nmethod\n\n"}, {"name": "chararray.zfill()", "path": "reference/generated/numpy.chararray.zfill", "type": "numpy.chararray.zfill", "text": "\nmethod\n\n"}, {"name": "class.__array__()", "path": "reference/arrays.classes#numpy.class.__array__", "type": "Standard array subclasses", "text": "\nIf a class (ndarray subclass or not) having the `__array__` method is used as\nthe output object of an ufunc, results will not be written to the object\nreturned by `__array__`. This practice will return `TypeError`.\n\n"}, {"name": "class.__array_finalize__()", "path": "reference/arrays.classes#numpy.class.__array_finalize__", "type": "Standard array subclasses", "text": "\nThis method is called whenever the system internally allocates a new array\nfrom obj, where obj is a subclass (subtype) of the `ndarray`. It can be used\nto change attributes of self after construction (so as to ensure a 2-d matrix\nfor example), or to update meta-information from the \u201cparent.\u201d Subclasses\ninherit a default implementation of this method that does nothing.\n\n"}, {"name": "class.__array_function__()", "path": "reference/arrays.classes#numpy.class.__array_function__", "type": "Standard array subclasses", "text": "\nNew in version 1.16.\n\n"}, {"name": "class.__array_prepare__()", "path": "reference/arrays.classes#numpy.class.__array_prepare__", "type": "Standard array subclasses", "text": "\nAt the beginning of every ufunc, this method is called on the input object\nwith the highest array priority, or the output object if one was specified.\nThe output array is passed in and whatever is returned is passed to the ufunc.\nSubclasses inherit a default implementation of this method which simply\nreturns the output array unmodified. Subclasses may opt to use this method to\ntransform the output array into an instance of the subclass and update\nmetadata before returning the array to the ufunc for computation.\n\n"}, {"name": "class.__array_priority__", "path": "reference/arrays.classes#numpy.class.__array_priority__", "type": "Standard array subclasses", "text": "\nThe value of this attribute is used to determine what type of object to return\nin situations where there is more than one possibility for the Python type of\nthe returned object. Subclasses inherit a default value of 0.0 for this\nattribute.\n\n"}, {"name": "class.__array_ufunc__()", "path": "reference/arrays.classes", "type": "Standard array subclasses", "text": "\nNote\n\n"}, {"name": "class.__array_wrap__()", "path": "reference/arrays.classes#numpy.class.__array_wrap__", "type": "Standard array subclasses", "text": "\nAt the end of every ufunc, this method is called on the input object with the\nhighest array priority, or the output object if one was specified. The ufunc-\ncomputed array is passed in and whatever is returned is passed to the user.\nSubclasses inherit a default implementation of this method, which transforms\nthe array into a new instance of the object\u2019s class. Subclasses may opt to use\nthis method to transform the output array into an instance of the subclass and\nupdate metadata before returning the array to the user.\n\n"}, {"name": "config.add_library()", "path": "reference/distutils_guide", "type": "NumPy Distutils - Users Guide", "text": "\nCurrently SciPy project consists of two packages:\n\n"}, {"name": "const Tp *data()", "path": "dev/howto-docs#_CPPv4N9DoxyLimbo4dataEv", "type": "Development", "text": "\nReturns the raw data for the limbo.\n\n"}, {"name": "Contributing to NumPy", "path": "dev/index", "type": "Development", "text": "\nNot a coder? Not a problem! NumPy is multi-faceted, and we can use a lot of\nhelp. These are all activities we\u2019d like to get help with (they\u2019re all\nimportant, so we list them in alphabetical order):\n\n"}, {"name": "Convenience Classes", "path": "reference/routines.polynomials.package", "type": "Convenience classes", "text": "\nThe following lists the various constants and methods common to all of the\nclasses representing the various kinds of polynomials. In the following, the\nterm `Poly` represents any one of the convenience classes (e.g. `Polynomial`,\n`Chebyshev`, `Hermite`, etc.) while the lowercase `p` represents an instance\nof a polynomial class.\n\n"}, {"name": "Copies and views", "path": "user/basics.copies", "type": "User Guide", "text": "\nWhen operating on NumPy arrays, it is possible to access the internal data\nbuffer directly using a view without copying data around. This ensures good\nperformance but can also cause unwanted problems if the user is not aware of\nhow this works. Hence, it is important to know the difference between these\ntwo terms and to know which operations return copies and which return views.\n\n"}, {"name": "core.defchararray.array()", "path": "reference/generated/numpy.core.defchararray.array", "type": "numpy.core.defchararray.array", "text": "\nCreate a `chararray`.\n\n"}, {"name": "core.defchararray.asarray()", "path": "reference/generated/numpy.core.defchararray.asarray", "type": "numpy.core.defchararray.asarray", "text": "\nConvert the input to a `chararray`, copying the data only if necessary.\n\n"}, {"name": "core.records.array()", "path": "reference/generated/numpy.core.records.array", "type": "numpy.core.records.array", "text": "\nConstruct a record array from a wide-variety of objects.\n\n"}, {"name": "core.records.fromarrays()", "path": "reference/generated/numpy.core.records.fromarrays", "type": "numpy.core.records.fromarrays", "text": "\nCreate a record array from a (flat) list of arrays\n\n"}, {"name": "core.records.fromfile()", "path": "reference/generated/numpy.core.records.fromfile", "type": "numpy.core.records.fromfile", "text": "\nCreate an array from binary file data\n\n"}, {"name": "core.records.fromrecords()", "path": "reference/generated/numpy.core.records.fromrecords", "type": "numpy.core.records.fromrecords", "text": "\nCreate a recarray from a list of records in text form.\n\n"}, {"name": "core.records.fromstring()", "path": "reference/generated/numpy.core.records.fromstring", "type": "numpy.core.records.fromstring", "text": "\nCreate a record array from binary data\n\n"}, {"name": "CT", "path": "reference/routines.fft", "type": "Discrete Fourier Transform ( \n      \n       numpy.fft\n      \n      )", "text": "\nThe SciPy module `scipy.fft` is a more comprehensive superset of `numpy.fft`,\nwhich includes only a basic set of routines.\n\n"}, {"name": "Data type routines", "path": "reference/routines.dtype", "type": "Data type routines", "text": "\n`can_cast`(from_, to[, casting])\n\n"}, {"name": "Data types", "path": "user/basics.types", "type": "User Guide", "text": "\nSee also\n\n"}, {"name": "DataSource.abspath()", "path": "reference/generated/numpy.datasource.abspath", "type": "numpy.DataSource.abspath", "text": "\nmethod\n\n"}, {"name": "DataSource.exists()", "path": "reference/generated/numpy.datasource.exists", "type": "numpy.DataSource.exists", "text": "\nmethod\n\n"}, {"name": "DataSource.open()", "path": "reference/generated/numpy.datasource.open", "type": "numpy.DataSource.open", "text": "\nmethod\n\n"}, {"name": "Datetime Support Functions", "path": "reference/routines.datetime", "type": "Datetime Support Functions", "text": "\n`datetime_as_string`(arr[, unit, timezone, ...])\n\n"}, {"name": "Datetimes and Timedeltas", "path": "reference/arrays.datetime", "type": "Datetimes and Timedeltas", "text": "\nNew in version 1.7.0.\n\n"}, {"name": "deletechars", "path": "user/basics.io.genfromtxt", "type": "User Guide", "text": "\nNumPy provides several functions to create arrays from tabular data. We focus\nhere on the `genfromtxt` function.\n\n"}, {"name": "Development workflow", "path": "dev/development_workflow", "type": "Development", "text": "\nYou already have your own forked copy of the NumPy repository, by following\nCreate a NumPy fork, Make the local copy, you have configured git by following\nGit configuration, and have linked the upstream repository as explained in\nLinking your repository to the upstream repo.\n\n"}, {"name": "distutils.ccompiler.CCompiler_compile()", "path": "reference/generated/numpy.distutils.ccompiler.ccompiler_compile", "type": "numpy.distutils.ccompiler.CCompiler_compile", "text": "\nCompile one or more source files.\n\n"}, {"name": "distutils.ccompiler.CCompiler_customize()", "path": "reference/generated/numpy.distutils.ccompiler.ccompiler_customize", "type": "numpy.distutils.ccompiler.CCompiler_customize", "text": "\nDo any platform-specific customization of a compiler instance.\n\n"}, {"name": "distutils.ccompiler.CCompiler_customize_cmd()", "path": "reference/generated/numpy.distutils.ccompiler.ccompiler_customize_cmd", "type": "numpy.distutils.ccompiler.CCompiler_customize_cmd", "text": "\nCustomize compiler using distutils command.\n\n"}, {"name": "distutils.ccompiler.CCompiler_cxx_compiler()", "path": "reference/generated/numpy.distutils.ccompiler.ccompiler_cxx_compiler", "type": "numpy.distutils.ccompiler.CCompiler_cxx_compiler", "text": "\nReturn the C++ compiler.\n\n"}, {"name": "distutils.ccompiler.CCompiler_find_executables()", "path": "reference/generated/numpy.distutils.ccompiler.ccompiler_find_executables", "type": "numpy.distutils.ccompiler.CCompiler_find_executables", "text": "\nDoes nothing here, but is called by the get_version method and can be\noverridden by subclasses. In particular it is redefined in the `FCompiler`\nclass where more documentation can be found.\n\n"}, {"name": "distutils.ccompiler.CCompiler_get_version()", "path": "reference/generated/numpy.distutils.ccompiler.ccompiler_get_version", "type": "numpy.distutils.ccompiler.CCompiler_get_version", "text": "\nReturn compiler version, or None if compiler is not available.\n\n"}, {"name": "distutils.ccompiler.CCompiler_object_filenames()", "path": "reference/generated/numpy.distutils.ccompiler.ccompiler_object_filenames", "type": "numpy.distutils.ccompiler.CCompiler_object_filenames", "text": "\nReturn the name of the object files for the given source files.\n\n"}, {"name": "distutils.ccompiler.CCompiler_show_customization()", "path": "reference/generated/numpy.distutils.ccompiler.ccompiler_show_customization", "type": "numpy.distutils.ccompiler.CCompiler_show_customization", "text": "\nPrint the compiler customizations to stdout.\n\n"}, {"name": "distutils.ccompiler.CCompiler_spawn()", "path": "reference/generated/numpy.distutils.ccompiler.ccompiler_spawn", "type": "numpy.distutils.ccompiler.CCompiler_spawn", "text": "\nExecute a command in a sub-process.\n\n"}, {"name": "distutils.ccompiler.gen_lib_options()", "path": "reference/generated/numpy.distutils.ccompiler.gen_lib_options", "type": "numpy.distutils.ccompiler.gen_lib_options", "text": "\n\n"}, {"name": "distutils.ccompiler.new_compiler()", "path": "reference/generated/numpy.distutils.ccompiler.new_compiler", "type": "numpy.distutils.ccompiler.new_compiler", "text": "\n\n"}, {"name": "distutils.ccompiler.replace_method()", "path": "reference/generated/numpy.distutils.ccompiler.replace_method", "type": "numpy.distutils.ccompiler.replace_method", "text": "\n\n"}, {"name": "distutils.ccompiler.simple_version_match()", "path": "reference/generated/numpy.distutils.ccompiler.simple_version_match", "type": "numpy.distutils.ccompiler.simple_version_match", "text": "\nSimple matching of version numbers, for use in CCompiler and FCompiler.\n\n"}, {"name": "distutils.ccompiler_opt.CCompilerOpt.cache_flush()", "path": "reference/generated/numpy.distutils.ccompiler_opt.ccompileropt.cache_flush", "type": "numpy.distutils.ccompiler_opt.CCompilerOpt.cache_flush", "text": "\nmethod\n\n"}, {"name": "distutils.ccompiler_opt.CCompilerOpt.cc_normalize_flags()", "path": "reference/generated/numpy.distutils.ccompiler_opt.ccompileropt.cc_normalize_flags", "type": "numpy.distutils.ccompiler_opt.CCompilerOpt.cc_normalize_flags", "text": "\nmethod\n\n"}, {"name": "distutils.ccompiler_opt.CCompilerOpt.conf_features", "path": "reference/generated/numpy.distutils.ccompiler_opt.ccompileropt.conf_features", "type": "NumPy.distutils.ccompiler_opt.ccompileropt.conf_features", "text": "\nattribute\n\n"}, {"name": "distutils.ccompiler_opt.CCompilerOpt.conf_features_partial()", "path": "reference/generated/numpy.distutils.ccompiler_opt.ccompileropt.conf_features_partial", "type": "numpy.distutils.ccompiler_opt.CCompilerOpt.conf_features_partial", "text": "\nmethod\n\n"}, {"name": "distutils.ccompiler_opt.CCompilerOpt.cpu_baseline_flags()", "path": "reference/generated/numpy.distutils.ccompiler_opt.ccompileropt.cpu_baseline_flags", "type": "numpy.distutils.ccompiler_opt.CCompilerOpt.cpu_baseline_flags", "text": "\nmethod\n\n"}, {"name": "distutils.ccompiler_opt.CCompilerOpt.cpu_baseline_names()", "path": "reference/generated/numpy.distutils.ccompiler_opt.ccompileropt.cpu_baseline_names", "type": "numpy.distutils.ccompiler_opt.CCompilerOpt.cpu_baseline_names", "text": "\nmethod\n\n"}, {"name": "distutils.ccompiler_opt.CCompilerOpt.cpu_dispatch_names()", "path": "reference/generated/numpy.distutils.ccompiler_opt.ccompileropt.cpu_dispatch_names", "type": "numpy.distutils.ccompiler_opt.CCompilerOpt.cpu_dispatch_names", "text": "\nmethod\n\n"}, {"name": "distutils.ccompiler_opt.CCompilerOpt.dist_compile()", "path": "reference/generated/numpy.distutils.ccompiler_opt.ccompileropt.dist_compile", "type": "numpy.distutils.ccompiler_opt.CCompilerOpt.dist_compile", "text": "\nmethod\n\n"}, {"name": "distutils.ccompiler_opt.CCompilerOpt.dist_info()", "path": "reference/generated/numpy.distutils.ccompiler_opt.ccompileropt.dist_info", "type": "numpy.distutils.ccompiler_opt.CCompilerOpt.dist_info", "text": "\nmethod\n\n"}, {"name": "distutils.ccompiler_opt.CCompilerOpt.dist_test()", "path": "reference/generated/numpy.distutils.ccompiler_opt.ccompileropt.dist_test", "type": "numpy.distutils.ccompiler_opt.CCompilerOpt.dist_test", "text": "\nmethod\n\n"}, {"name": "distutils.ccompiler_opt.CCompilerOpt.feature_ahead()", "path": "reference/generated/numpy.distutils.ccompiler_opt.ccompileropt.feature_ahead", "type": "numpy.distutils.ccompiler_opt.CCompilerOpt.feature_ahead", "text": "\nmethod\n\n"}, {"name": "distutils.ccompiler_opt.CCompilerOpt.feature_c_preprocessor()", "path": "reference/generated/numpy.distutils.ccompiler_opt.ccompileropt.feature_c_preprocessor", "type": "numpy.distutils.ccompiler_opt.CCompilerOpt.feature_c_preprocessor", "text": "\nmethod\n\n"}, {"name": "distutils.ccompiler_opt.CCompilerOpt.feature_detect()", "path": "reference/generated/numpy.distutils.ccompiler_opt.ccompileropt.feature_detect", "type": "numpy.distutils.ccompiler_opt.CCompilerOpt.feature_detect", "text": "\nmethod\n\n"}, {"name": "distutils.ccompiler_opt.CCompilerOpt.feature_get_til()", "path": "reference/generated/numpy.distutils.ccompiler_opt.ccompileropt.feature_get_til", "type": "numpy.distutils.ccompiler_opt.CCompilerOpt.feature_get_til", "text": "\nmethod\n\n"}, {"name": "distutils.ccompiler_opt.CCompilerOpt.feature_implies()", "path": "reference/generated/numpy.distutils.ccompiler_opt.ccompileropt.feature_implies", "type": "numpy.distutils.ccompiler_opt.CCompilerOpt.feature_implies", "text": "\nmethod\n\n"}, {"name": "distutils.ccompiler_opt.CCompilerOpt.feature_implies_c()", "path": "reference/generated/numpy.distutils.ccompiler_opt.ccompileropt.feature_implies_c", "type": "numpy.distutils.ccompiler_opt.CCompilerOpt.feature_implies_c", "text": "\nmethod\n\n"}, {"name": "distutils.ccompiler_opt.CCompilerOpt.feature_is_exist()", "path": "reference/generated/numpy.distutils.ccompiler_opt.ccompileropt.feature_is_exist", "type": "numpy.distutils.ccompiler_opt.CCompilerOpt.feature_is_exist", "text": "\nmethod\n\n"}, {"name": "distutils.ccompiler_opt.CCompilerOpt.feature_names()", "path": "reference/generated/numpy.distutils.ccompiler_opt.ccompileropt.feature_names", "type": "numpy.distutils.ccompiler_opt.CCompilerOpt.feature_names", "text": "\nmethod\n\n"}, {"name": "distutils.ccompiler_opt.CCompilerOpt.feature_sorted()", "path": "reference/generated/numpy.distutils.ccompiler_opt.ccompileropt.feature_sorted", "type": "numpy.distutils.ccompiler_opt.CCompilerOpt.feature_sorted", "text": "\nmethod\n\n"}, {"name": "distutils.ccompiler_opt.CCompilerOpt.feature_untied()", "path": "reference/generated/numpy.distutils.ccompiler_opt.ccompileropt.feature_untied", "type": "numpy.distutils.ccompiler_opt.CCompilerOpt.feature_untied", "text": "\nmethod\n\n"}, {"name": "distutils.ccompiler_opt.CCompilerOpt.generate_dispatch_header()", "path": "reference/generated/numpy.distutils.ccompiler_opt.ccompileropt.generate_dispatch_header", "type": "numpy.distutils.ccompiler_opt.CCompilerOpt.generate_dispatch_header", "text": "\nmethod\n\n"}, {"name": "distutils.ccompiler_opt.CCompilerOpt.is_cached()", "path": "reference/generated/numpy.distutils.ccompiler_opt.ccompileropt.is_cached", "type": "numpy.distutils.ccompiler_opt.CCompilerOpt.is_cached", "text": "\nmethod\n\n"}, {"name": "distutils.ccompiler_opt.CCompilerOpt.parse_targets()", "path": "reference/generated/numpy.distutils.ccompiler_opt.ccompileropt.parse_targets", "type": "numpy.distutils.ccompiler_opt.CCompilerOpt.parse_targets", "text": "\nmethod\n\n"}, {"name": "distutils.ccompiler_opt.CCompilerOpt.try_dispatch()", "path": "reference/generated/numpy.distutils.ccompiler_opt.ccompileropt.try_dispatch", "type": "numpy.distutils.ccompiler_opt.CCompilerOpt.try_dispatch", "text": "\nmethod\n\n"}, {"name": "distutils.ccompiler_opt.new_ccompiler_opt()", "path": "reference/generated/numpy.distutils.ccompiler_opt.new_ccompiler_opt", "type": "numpy.distutils.ccompiler_opt.new_ccompiler_opt", "text": "\nCreate a new instance of \u2018CCompilerOpt\u2019 and generate the dispatch header which\ncontains the #definitions and headers of platform-specific instruction-sets\nfor the enabled CPU baseline and dispatch-able features.\n\n"}, {"name": "distutils.cpuinfo.cpu", "path": "reference/generated/numpy.distutils.cpuinfo.cpu", "type": "numpy.distutils.cpuinfo.cpu", "text": "\n\n"}, {"name": "distutils.exec_command.exec_command()", "path": "reference/generated/numpy.distutils.exec_command.exec_command", "type": "numpy.distutils.exec_command.exec_command", "text": "\nReturn (status,output) of executed command.\n\n"}, {"name": "distutils.exec_command.filepath_from_subprocess_output()", "path": "reference/generated/numpy.distutils.exec_command.filepath_from_subprocess_output", "type": "numpy.distutils.exec_command.filepath_from_subprocess_output", "text": "\nConvert `bytes` in the encoding used by a subprocess into a filesystem-\nappropriate `str`.\n\n"}, {"name": "distutils.exec_command.find_executable()", "path": "reference/generated/numpy.distutils.exec_command.find_executable", "type": "numpy.distutils.exec_command.find_executable", "text": "\nReturn full path of a executable or None.\n\n"}, {"name": "distutils.exec_command.forward_bytes_to_stdout()", "path": "reference/generated/numpy.distutils.exec_command.forward_bytes_to_stdout", "type": "numpy.distutils.exec_command.forward_bytes_to_stdout", "text": "\nForward bytes from a subprocess call to the console, without attempting to\ndecode them.\n\n"}, {"name": "distutils.exec_command.get_pythonexe()", "path": "reference/generated/numpy.distutils.exec_command.get_pythonexe", "type": "numpy.distutils.exec_command.get_pythonexe", "text": "\n\n"}, {"name": "distutils.exec_command.temp_file_name()", "path": "reference/generated/numpy.distutils.exec_command.temp_file_name", "type": "numpy.distutils.exec_command.temp_file_name", "text": "\n\n"}, {"name": "distutils.log.set_verbosity()", "path": "reference/generated/numpy.distutils.log.set_verbosity", "type": "numpy.distutils.log.set_verbosity", "text": "\n\n"}, {"name": "distutils.system_info.get_info()", "path": "reference/generated/numpy.distutils.system_info.get_info", "type": "numpy.distutils.system_info.get_info", "text": "\n0 - do nothing 1 - display warning message 2 - raise error\n\n"}, {"name": "distutils.system_info.get_standard_file()", "path": "reference/generated/numpy.distutils.system_info.get_standard_file", "type": "numpy.distutils.system_info.get_standard_file", "text": "\nReturns a list of files named \u2018fname\u2019 from 1) System-wide directory\n(directory-location of this module) 2) Users HOME directory\n(os.environ[\u2018HOME\u2019]) 3) Local directory\n\n"}, {"name": "double npy_half_to_double()", "path": "reference/c-api/coremath#c.npy_half_to_double", "type": "NumPy core libraries", "text": "\nConverts a half-precision float to a double-precision float.\n\n"}, {"name": "double npy_spacing()", "path": "reference/c-api/coremath#c.npy_spacing", "type": "NumPy core libraries", "text": "\nThis is a function equivalent to Fortran intrinsic. Return distance between x\nand next representable floating point value from x, e.g. spacing(1) == eps.\nspacing of nan and +/- inf return nan. Single and extended precisions are\navailable with suffix f and l.\n\n"}, {"name": "double PyArray_GetPriority()", "path": "reference/c-api/array#c.PyArray_GetPriority", "type": "Array API", "text": "\nReturn the `__array_priority__` attribute (converted to a double) of obj or\ndef if no attribute of that name exists. Fast returns that avoid the attribute\nlookup are provided for objects of type `PyArray_Type`.\n\n"}, {"name": "double random_beta()", "path": "reference/random/c-api#c.random_beta", "type": "C API for random", "text": "\n\n"}, {"name": "double random_chisquare()", "path": "reference/random/c-api#c.random_chisquare", "type": "C API for random", "text": "\n\n"}, {"name": "double random_exponential()", "path": "reference/random/c-api#c.random_exponential", "type": "C API for random", "text": "\n\n"}, {"name": "double random_f()", "path": "reference/random/c-api#c.random_f", "type": "C API for random", "text": "\n\n"}, {"name": "double random_gamma()", "path": "reference/random/c-api#c.random_gamma", "type": "C API for random", "text": "\n\n"}, {"name": "double random_gumbel()", "path": "reference/random/c-api#c.random_gumbel", "type": "C API for random", "text": "\n\n"}, {"name": "double random_laplace()", "path": "reference/random/c-api#c.random_laplace", "type": "C API for random", "text": "\n\n"}, {"name": "double random_logistic()", "path": "reference/random/c-api#c.random_logistic", "type": "C API for random", "text": "\n\n"}, {"name": "double random_lognormal()", "path": "reference/random/c-api#c.random_lognormal", "type": "C API for random", "text": "\n\n"}, {"name": "double random_noncentral_chisquare()", "path": "reference/random/c-api#c.random_noncentral_chisquare", "type": "C API for random", "text": "\n\n"}, {"name": "double random_noncentral_f()", "path": "reference/random/c-api#c.random_noncentral_f", "type": "C API for random", "text": "\n\n"}, {"name": "double random_normal()", "path": "reference/random/c-api#c.random_normal", "type": "C API for random", "text": "\n\n"}, {"name": "double random_pareto()", "path": "reference/random/c-api#c.random_pareto", "type": "C API for random", "text": "\n\n"}, {"name": "double random_power()", "path": "reference/random/c-api#c.random_power", "type": "C API for random", "text": "\n\n"}, {"name": "double random_rayleigh()", "path": "reference/random/c-api#c.random_rayleigh", "type": "C API for random", "text": "\n\n"}, {"name": "double random_standard_cauchy()", "path": "reference/random/c-api#c.random_standard_cauchy", "type": "C API for random", "text": "\n\n"}, {"name": "double random_standard_exponential()", "path": "reference/random/c-api#c.random_standard_exponential", "type": "C API for random", "text": "\n\n"}, {"name": "double random_standard_gamma()", "path": "reference/random/c-api#c.random_standard_gamma", "type": "C API for random", "text": "\n\n"}, {"name": "double random_standard_normal()", "path": "reference/random/c-api#c.random_standard_normal", "type": "C API for random", "text": "\n\n"}, {"name": "double random_standard_t()", "path": "reference/random/c-api#c.random_standard_t", "type": "C API for random", "text": "\n\n"}, {"name": "double random_standard_uniform()", "path": "reference/random/c-api#c.random_standard_uniform", "type": "C API for random", "text": "\n\n"}, {"name": "double random_triangular()", "path": "reference/random/c-api#c.random_triangular", "type": "C API for random", "text": "\n\n"}, {"name": "double random_uniform()", "path": "reference/random/c-api#c.random_uniform", "type": "C API for random", "text": "\n\n"}, {"name": "double random_vonmises()", "path": "reference/random/c-api#c.random_vonmises", "type": "C API for random", "text": "\n\n"}, {"name": "double random_wald()", "path": "reference/random/c-api#c.random_wald", "type": "C API for random", "text": "\n\n"}, {"name": "double random_weibull()", "path": "reference/random/c-api#c.random_weibull", "type": "C API for random", "text": "\n\n"}, {"name": "DoxyLimbo()", "path": "dev/howto-docs#_CPPv4N9DoxyLimbo9DoxyLimboERK9DoxyLimboI2Tp1NE", "type": "Development", "text": "\nSet Default behavior for copy the limbo.\n\n"}, {"name": "dtype object", "path": "reference/arrays.dtypes", "type": "Data type objects ( \n      \n       dtype\n      \n      )", "text": "\nA data type object (an instance of `numpy.dtype` class) describes how the\nbytes in the fixed-size block of memory corresponding to an array item should\nbe interpreted. It describes the following aspects of the data:\n\n"}, {"name": "dtype.__class_getitem__()", "path": "reference/generated/numpy.dtype.__class_getitem__", "type": "numpy.dtype.__class_getitem__", "text": "\nmethod\n\n"}, {"name": "dtype.__ge__()", "path": "reference/generated/numpy.dtype.__ge__", "type": "numpy.dtype.__ge__", "text": "\nmethod\n\n"}, {"name": "dtype.__gt__()", "path": "reference/generated/numpy.dtype.__gt__", "type": "numpy.dtype.__gt__", "text": "\nmethod\n\n"}, {"name": "dtype.__le__()", "path": "reference/generated/numpy.dtype.__le__", "type": "numpy.dtype.__le__", "text": "\nmethod\n\n"}, {"name": "dtype.__lt__()", "path": "reference/generated/numpy.dtype.__lt__", "type": "numpy.dtype.__lt__", "text": "\nmethod\n\n"}, {"name": "dtype.__reduce__()", "path": "reference/generated/numpy.dtype.__reduce__", "type": "numpy.dtype.__reduce__", "text": "\nmethod\n\n"}, {"name": "dtype.__setstate__()", "path": "reference/generated/numpy.dtype.__setstate__", "type": "numpy.dtype.__setstate__", "text": "\nmethod\n\n"}, {"name": "dtype.alignment", "path": "reference/generated/numpy.dtype.alignment", "type": "numpy.dtype.alignment", "text": "\nattribute\n\n"}, {"name": "dtype.base", "path": "reference/generated/numpy.dtype.base", "type": "numpy.dtype.base", "text": "\nattribute\n\n"}, {"name": "dtype.byteorder", "path": "reference/generated/numpy.dtype.byteorder", "type": "numpy.dtype.byteorder", "text": "\nattribute\n\n"}, {"name": "dtype.char", "path": "reference/generated/numpy.dtype.char", "type": "numpy.dtype.char", "text": "\nattribute\n\n"}, {"name": "dtype.descr", "path": "reference/generated/numpy.dtype.descr", "type": "numpy.dtype.descr", "text": "\nattribute\n\n"}, {"name": "dtype.fields", "path": "reference/generated/numpy.dtype.fields", "type": "numpy.dtype.fields", "text": "\nattribute\n\n"}, {"name": "dtype.flags", "path": "reference/generated/numpy.dtype.flags", "type": "numpy.dtype.flags", "text": "\nattribute\n\n"}, {"name": "dtype.hasobject", "path": "reference/generated/numpy.dtype.hasobject", "type": "numpy.dtype.hasobject", "text": "\nattribute\n\n"}, {"name": "dtype.isalignedstruct", "path": "reference/generated/numpy.dtype.isalignedstruct", "type": "Data type objects", "text": "\nattribute\n\n"}, {"name": "dtype.isbuiltin", "path": "reference/generated/numpy.dtype.isbuiltin", "type": "numpy.dtype.isbuiltin", "text": "\nattribute\n\n"}, {"name": "dtype.isnative", "path": "reference/generated/numpy.dtype.isnative", "type": "numpy.dtype.isnative", "text": "\nattribute\n\n"}, {"name": "dtype.itemsize", "path": "reference/generated/numpy.dtype.itemsize", "type": "numpy.dtype.itemsize", "text": "\nattribute\n\n"}, {"name": "dtype.kind", "path": "reference/generated/numpy.dtype.kind", "type": "numpy.dtype.kind", "text": "\nattribute\n\n"}, {"name": "dtype.metadata", "path": "reference/generated/numpy.dtype.metadata", "type": "numpy.dtype.metadata", "text": "\nattribute\n\n"}, {"name": "dtype.name", "path": "reference/generated/numpy.dtype.name", "type": "numpy.dtype.name", "text": "\nattribute\n\n"}, {"name": "dtype.names", "path": "reference/generated/numpy.dtype.names", "type": "numpy.dtype.names", "text": "\nattribute\n\n"}, {"name": "dtype.ndim", "path": "reference/generated/numpy.dtype.ndim", "type": "Data type objects", "text": "\nattribute\n\n"}, {"name": "dtype.newbyteorder()", "path": "reference/generated/numpy.dtype.newbyteorder", "type": "numpy.dtype.newbyteorder", "text": "\nmethod\n\n"}, {"name": "dtype.num", "path": "reference/generated/numpy.dtype.num", "type": "numpy.dtype.num", "text": "\nattribute\n\n"}, {"name": "dtype.shape", "path": "reference/generated/numpy.dtype.shape", "type": "numpy.dtype.shape", "text": "\nattribute\n\n"}, {"name": "dtype.str", "path": "reference/generated/numpy.dtype.str", "type": "numpy.dtype.str", "text": "\nattribute\n\n"}, {"name": "dtype.subdtype", "path": "reference/generated/numpy.dtype.subdtype", "type": "numpy.dtype.subdtype", "text": "\nattribute\n\n"}, {"name": "dtype.type", "path": "reference/generated/numpy.dtype.type", "type": "numpy.dtype.type", "text": "\nattribute\n\n"}, {"name": "Elementary Function", "path": "reference/c-api/generalized-ufuncs", "type": "Generalized Universal Function API", "text": "\nThere is a general need for looping over not only functions on scalars but\nalso over functions on vectors (or arrays). This concept is realized in NumPy\nby generalizing the universal functions (ufuncs). In regular ufuncs, the\nelementary function is limited to element-by-element operations, whereas the\ngeneralized version (gufuncs) supports \u201csub-array\u201d by \u201csub-array\u201d operations.\nThe Perl vector library PDL provides a similar functionality and its terms are\nre-used in the following.\n\n"}, {"name": "enum NPY_CASTING", "path": "reference/c-api/array#c.NPY_CASTING", "type": "Array API", "text": "\nNew in version 1.6.\n\n"}, {"name": "enum NPY_CLIPMODE", "path": "reference/c-api/array#c.NPY_CLIPMODE", "type": "Array API", "text": "\nA variable type indicating the kind of clipping that should be applied in\ncertain functions.\n\n"}, {"name": "enum NPY_ORDER", "path": "reference/c-api/array#c.NPY_ORDER", "type": "Array API", "text": "\nAn enumeration type indicating the element order that an array should be\ninterpreted in. When a brand new array is created, generally only NPY_CORDER\nand NPY_FORTRANORDER are used, whereas when one or more inputs are provided,\nthe order can be based on them.\n\n"}, {"name": "enum NPY_SCALARKIND", "path": "reference/c-api/array#c.NPY_SCALARKIND", "type": "Array API", "text": "\nA special variable type indicating the number of \u201ckinds\u201d of scalars\ndistinguished in determining scalar-coercion rules. This variable can take on\nthe values:\n\n"}, {"name": "enum NPY_SEARCHSIDE", "path": "reference/c-api/array#c.NPY_SEARCHSIDE", "type": "Array API", "text": "\nA variable type indicating whether the index returned should be that of the\nfirst suitable location (if `NPY_SEARCHLEFT`) or of the last (if\n`NPY_SEARCHRIGHT`).\n\n"}, {"name": "enum NPY_SELECTKIND", "path": "reference/c-api/array#c.NPY_SELECTKIND", "type": "Array API", "text": "\nA variable type indicating the selection algorithm being used.\n\n"}, {"name": "enumerator NPY_BOOL", "path": "reference/c-api/dtype#c.NPY_BOOL", "type": "Data Type API", "text": "\nThe enumeration value for the boolean type, stored as one byte. It may only be\nset to the values 0 and 1.\n\n"}, {"name": "enumerator NPY_BOOL_SCALAR", "path": "reference/c-api/array#c.NPY_SCALARKIND.NPY_BOOL_SCALAR", "type": "Array API", "text": "\n\n"}, {"name": "enumerator NPY_BYTE", "path": "reference/c-api/dtype#c.NPY_BYTE", "type": "Data Type API", "text": "\n\n"}, {"name": "enumerator NPY_CDOUBLE", "path": "reference/c-api/dtype#c.NPY_CDOUBLE", "type": "Data Type API", "text": "\n\n"}, {"name": "enumerator NPY_CFLOAT", "path": "reference/c-api/dtype#c.NPY_CFLOAT", "type": "Data Type API", "text": "\n\n"}, {"name": "enumerator NPY_CLIP", "path": "reference/c-api/array#c.NPY_CLIPMODE.NPY_CLIP", "type": "Array API", "text": "\nClips an index to the valid range if it is out of bounds.\n\n"}, {"name": "enumerator NPY_CLONGDOUBLE", "path": "reference/c-api/dtype#c.NPY_CLONGDOUBLE", "type": "Data Type API", "text": "\nThe enumeration value for a platform-specific complex floating point type\nwhich is made up of two NPY_LONGDOUBLE values.\n\n"}, {"name": "enumerator NPY_COMPLEX128", "path": "reference/c-api/dtype#c.NPY_COMPLEX128", "type": "Data Type API", "text": "\nThe enumeration value for a 128-bit/16-byte complex type made up of two\nNPY_DOUBLE values.\n\n"}, {"name": "enumerator NPY_COMPLEX64", "path": "reference/c-api/dtype#c.NPY_COMPLEX64", "type": "Data Type API", "text": "\nThe enumeration value for a 64-bit/8-byte complex type made up of two\nNPY_FLOAT values.\n\n"}, {"name": "enumerator NPY_COMPLEX_SCALAR", "path": "reference/c-api/array#c.NPY_SCALARKIND.NPY_COMPLEX_SCALAR", "type": "Array API", "text": "\n\n"}, {"name": "enumerator NPY_CORDER", "path": "reference/c-api/array#c.NPY_ORDER.NPY_CORDER", "type": "Array API", "text": "\nC order.\n\n"}, {"name": "enumerator NPY_DATETIME", "path": "reference/c-api/dtype#c.NPY_DATETIME", "type": "Data Type API", "text": "\nThe enumeration value for a data type which holds dates or datetimes with a\nprecision based on selectable date or time units.\n\n"}, {"name": "enumerator NPY_DEFAULT_TYPE", "path": "reference/c-api/dtype#c.NPY_DEFAULT_TYPE", "type": "Data Type API", "text": "\nThe default type to use when no dtype is explicitly specified, for example\nwhen calling np.zero(shape). This is equivalent to `NPY_DOUBLE`.\n\n"}, {"name": "enumerator NPY_DOUBLE", "path": "reference/c-api/dtype#c.NPY_DOUBLE", "type": "Data Type API", "text": "\n\n"}, {"name": "enumerator NPY_EQUIV_CASTING", "path": "reference/c-api/array#c.NPY_CASTING.NPY_EQUIV_CASTING", "type": "Array API", "text": "\nAllow identical and casts involving byte swapping.\n\n"}, {"name": "enumerator NPY_FLOAT", "path": "reference/c-api/dtype#c.NPY_FLOAT", "type": "Data Type API", "text": "\n\n"}, {"name": "enumerator NPY_FLOAT16", "path": "reference/c-api/dtype#c.NPY_FLOAT16", "type": "Data Type API", "text": "\nThe enumeration value for a 16-bit/2-byte IEEE 754-2008 compatible floating\npoint type.\n\n"}, {"name": "enumerator NPY_FLOAT32", "path": "reference/c-api/dtype#c.NPY_FLOAT32", "type": "Data Type API", "text": "\nThe enumeration value for a 32-bit/4-byte IEEE 754 compatible floating point\ntype.\n\n"}, {"name": "enumerator NPY_FLOAT64", "path": "reference/c-api/dtype#c.NPY_FLOAT64", "type": "Data Type API", "text": "\nThe enumeration value for a 64-bit/8-byte IEEE 754 compatible floating point\ntype.\n\n"}, {"name": "enumerator NPY_FLOAT_SCALAR", "path": "reference/c-api/array#c.NPY_SCALARKIND.NPY_FLOAT_SCALAR", "type": "Array API", "text": "\n\n"}, {"name": "enumerator NPY_FORTRANORDER", "path": "reference/c-api/array#c.NPY_ORDER.NPY_FORTRANORDER", "type": "Array API", "text": "\nFortran order.\n\n"}, {"name": "enumerator NPY_HALF", "path": "reference/c-api/dtype#c.NPY_HALF", "type": "Data Type API", "text": "\n\n"}, {"name": "enumerator NPY_HEAPSORT", "path": "reference/c-api/array#c.NPY_SORTKIND.NPY_HEAPSORT", "type": "Array API", "text": "\n\n"}, {"name": "enumerator NPY_INT", "path": "reference/c-api/dtype#c.NPY_INT", "type": "Data Type API", "text": "\n\n"}, {"name": "enumerator NPY_INT16", "path": "reference/c-api/dtype#c.NPY_INT16", "type": "Data Type API", "text": "\nThe enumeration value for a 16-bit/2-byte signed integer.\n\n"}, {"name": "enumerator NPY_INT32", "path": "reference/c-api/dtype#c.NPY_INT32", "type": "Data Type API", "text": "\nThe enumeration value for a 32-bit/4-byte signed integer.\n\n"}, {"name": "enumerator NPY_INT64", "path": "reference/c-api/dtype#c.NPY_INT64", "type": "Data Type API", "text": "\nThe enumeration value for a 64-bit/8-byte signed integer.\n\n"}, {"name": "enumerator NPY_INT8", "path": "reference/c-api/dtype#c.NPY_INT8", "type": "Data Type API", "text": "\nThe enumeration value for an 8-bit/1-byte signed integer.\n\n"}, {"name": "enumerator NPY_INTNEG_SCALAR", "path": "reference/c-api/array#c.NPY_SCALARKIND.NPY_INTNEG_SCALAR", "type": "Array API", "text": "\n\n"}, {"name": "enumerator NPY_INTP", "path": "reference/c-api/dtype#c.NPY_INTP", "type": "Data Type API", "text": "\nThe enumeration value for a signed integer type which is the same size as a\n(void *) pointer. This is the type used by all arrays of indices.\n\n"}, {"name": "enumerator NPY_INTPOS_SCALAR", "path": "reference/c-api/array#c.NPY_SCALARKIND.NPY_INTPOS_SCALAR", "type": "Array API", "text": "\n\n"}, {"name": "enumerator NPY_KEEPORDER", "path": "reference/c-api/array#c.NPY_ORDER.NPY_KEEPORDER", "type": "Array API", "text": "\nAn order as close to the order of the inputs as possible, even if the input is\nin neither C nor Fortran order.\n\n"}, {"name": "enumerator NPY_LONG", "path": "reference/c-api/dtype#c.NPY_LONG", "type": "Data Type API", "text": "\nEquivalent to either NPY_INT or NPY_LONGLONG, depending on the platform.\n\n"}, {"name": "enumerator NPY_LONGDOUBLE", "path": "reference/c-api/dtype#c.NPY_LONGDOUBLE", "type": "Data Type API", "text": "\nThe enumeration value for a platform-specific floating point type which is at\nleast as large as NPY_DOUBLE, but larger on many platforms.\n\n"}, {"name": "enumerator NPY_LONGLONG", "path": "reference/c-api/dtype#c.NPY_LONGLONG", "type": "Data Type API", "text": "\n\n"}, {"name": "enumerator NPY_MASK", "path": "reference/c-api/dtype#c.NPY_MASK", "type": "Data Type API", "text": "\nThe enumeration value of the type used for masks, such as with the\n`NPY_ITER_ARRAYMASK` iterator flag. This is equivalent to `NPY_UINT8`.\n\n"}, {"name": "enumerator NPY_MERGESORT", "path": "reference/c-api/array#c.NPY_SORTKIND.NPY_MERGESORT", "type": "Array API", "text": "\n\n"}, {"name": "enumerator NPY_NSCALARKINDS", "path": "reference/c-api/array#c.NPY_SCALARKIND.NPY_NSCALARKINDS", "type": "Array API", "text": "\nDefined to be the number of scalar kinds (not including `NPY_NOSCALAR`).\n\n"}, {"name": "enumerator NPY_NSORTS", "path": "reference/c-api/array#c.NPY_SORTKIND.NPY_NSORTS", "type": "Array API", "text": "\nDefined to be the number of sorts. It is fixed at three by the need for\nbackwards compatibility, and consequently `NPY_MERGESORT` and `NPY_STABLESORT`\nare aliased to each other and may refer to one of several stable sorting\nalgorithms depending on the data type.\n\n"}, {"name": "enumerator NPY_OBJECT", "path": "reference/c-api/dtype#c.NPY_OBJECT", "type": "Data Type API", "text": "\nThe enumeration value for references to arbitrary Python objects.\n\n"}, {"name": "enumerator NPY_OBJECT_SCALAR", "path": "reference/c-api/array#c.NPY_SCALARKIND.NPY_OBJECT_SCALAR", "type": "Array API", "text": "\n\n"}, {"name": "enumerator NPY_SAFE_CASTING", "path": "reference/c-api/array#c.NPY_CASTING.NPY_SAFE_CASTING", "type": "Array API", "text": "\nOnly allow casts which will not cause values to be rounded, truncated, or\notherwise changed.\n\n"}, {"name": "enumerator NPY_SAME_KIND_CASTING", "path": "reference/c-api/array#c.NPY_CASTING.NPY_SAME_KIND_CASTING", "type": "Array API", "text": "\nAllow any safe casts, and casts between types of the same kind. For example,\nfloat64 -> float32 is permitted with this rule.\n\n"}, {"name": "enumerator NPY_SEARCHRIGHT", "path": "reference/c-api/array#c.NPY_SEARCHSIDE.NPY_SEARCHRIGHT", "type": "Array API", "text": "\n\n"}, {"name": "enumerator NPY_SHORT", "path": "reference/c-api/dtype#c.NPY_SHORT", "type": "Data Type API", "text": "\n\n"}, {"name": "enumerator NPY_STABLESORT", "path": "reference/c-api/array#c.NPY_SORTKIND.NPY_STABLESORT", "type": "Array API", "text": "\nUsed as an alias of `NPY_MERGESORT` and vica versa.\n\n"}, {"name": "enumerator NPY_STRING", "path": "reference/c-api/dtype#c.NPY_STRING", "type": "Data Type API", "text": "\nThe enumeration value for ASCII strings of a selectable size. The strings have\na fixed maximum size within a given array.\n\n"}, {"name": "enumerator NPY_TIMEDELTA", "path": "reference/c-api/dtype#c.NPY_TIMEDELTA", "type": "Data Type API", "text": "\nThe enumeration value for a data type which holds lengths of times in integers\nof selectable date or time units.\n\n"}, {"name": "enumerator NPY_TYPES", "path": "reference/c-api/dtype", "type": "Data Type API", "text": "\nThe standard array can have 24 different data types (and has some support for\nadding your own types). These data types all have an enumerated type, an\nenumerated type-character, and a corresponding array scalar Python type object\n(placed in a hierarchy). There are also standard C typedefs to make it easier\nto manipulate elements of the given data type. For the numeric types, there\nare also bit-width equivalent C typedefs and named typenumbers that make it\neasier to select the precision desired.\n\n"}, {"name": "enumerator NPY_UBYTE", "path": "reference/c-api/dtype#c.NPY_UBYTE", "type": "Data Type API", "text": "\n\n"}, {"name": "enumerator NPY_UINT", "path": "reference/c-api/dtype#c.NPY_UINT", "type": "Data Type API", "text": "\n\n"}, {"name": "enumerator NPY_UINT16", "path": "reference/c-api/dtype#c.NPY_UINT16", "type": "Data Type API", "text": "\nThe enumeration value for a 16-bit/2-byte unsigned integer.\n\n"}, {"name": "enumerator NPY_UINT32", "path": "reference/c-api/dtype#c.NPY_UINT32", "type": "Data Type API", "text": "\nThe enumeration value for a 32-bit/4-byte unsigned integer.\n\n"}, {"name": "enumerator NPY_UINT64", "path": "reference/c-api/dtype#c.NPY_UINT64", "type": "Data Type API", "text": "\nThe enumeration value for a 64-bit/8-byte unsigned integer.\n\n"}, {"name": "enumerator NPY_UINT8", "path": "reference/c-api/dtype#c.NPY_UINT8", "type": "Data Type API", "text": "\nThe enumeration value for an 8-bit/1-byte unsigned integer.\n\n"}, {"name": "enumerator NPY_UINTP", "path": "reference/c-api/dtype#c.NPY_UINTP", "type": "Data Type API", "text": "\nThe enumeration value for an unsigned integer type which is the same size as a\n(void *) pointer.\n\n"}, {"name": "enumerator NPY_ULONG", "path": "reference/c-api/dtype#c.NPY_ULONG", "type": "Data Type API", "text": "\nEquivalent to either NPY_UINT or NPY_ULONGLONG, depending on the platform.\n\n"}, {"name": "enumerator NPY_ULONGLONG", "path": "reference/c-api/dtype#c.NPY_ULONGLONG", "type": "Data Type API", "text": "\n\n"}, {"name": "enumerator NPY_UNICODE", "path": "reference/c-api/dtype#c.NPY_UNICODE", "type": "Data Type API", "text": "\nThe enumeration value for UCS4 strings of a selectable size. The strings have\na fixed maximum size within a given array.\n\n"}, {"name": "enumerator NPY_UNSAFE_CASTING", "path": "reference/c-api/array#c.NPY_CASTING.NPY_UNSAFE_CASTING", "type": "Array API", "text": "\nAllow any cast, no matter what kind of data loss may occur.\n\n"}, {"name": "enumerator NPY_USHORT", "path": "reference/c-api/dtype#c.NPY_USHORT", "type": "Data Type API", "text": "\n\n"}, {"name": "enumerator NPY_VOID", "path": "reference/c-api/dtype#c.NPY_VOID", "type": "Data Type API", "text": "\nPrimarily used to hold struct dtypes, but can contain arbitrary binary data.\n\n"}, {"name": "enumerator NPY_WRAP", "path": "reference/c-api/array#c.NPY_CLIPMODE.NPY_WRAP", "type": "Array API", "text": "\nWraps an index to the valid range if it is out of bounds.\n\n"}, {"name": "errstate.__call__()", "path": "reference/generated/numpy.errstate.__call__", "type": "numpy.errstate.__call__", "text": "\nmethod\n\n"}, {"name": "exec_command", "path": "reference/generated/numpy.distutils.exec_command", "type": "numpy.distutils.exec_command", "text": "\nexec_command\n\n"}, {"name": "Extending", "path": "reference/random/extending", "type": "Examples of using Numba, Cython, CFFI", "text": "\nThe BitGenerators have been designed to be extendable using standard tools for\nhigh-performance Python \u2013 numba and Cython. The `Generator` object can also be\nused with user-provided BitGenerators as long as these export a small set of\nrequired functions.\n\n"}, {"name": "Extending numpy.random via Cython", "path": "reference/random/examples/cython/index", "type": "Cython", "text": "\n\n"}, {"name": "Extending via CFFI", "path": "reference/random/examples/cffi", "type": "CFFI", "text": "\n\n"}, {"name": "Extending via Numba", "path": "reference/random/examples/numba", "type": "Numba", "text": "\n\n"}, {"name": "Extending via Numba and CFFI", "path": "reference/random/examples/numba_cffi", "type": "CFFI + Numba", "text": "\n\n"}, {"name": "extending.pyx", "path": "reference/random/examples/cython/extending.pyx", "type": "Cython", "text": "\n\n"}, {"name": "extending_distributions.pyx", "path": "reference/random/examples/cython/extending_distributions.pyx", "type": "Cython", "text": "\n\n"}, {"name": "F2PY user guide and reference manual", "path": "f2py/index", "type": "F2PY user guide and reference manual", "text": "\nThe purpose of the `F2PY` \u2013Fortran to Python interface generator\u2013 utility is\nto provide a connection between Python and Fortran languages. F2PY is a part\nof NumPy (`numpy.f2py`) and also available as a standalone command line tool\n`f2py` when `numpy` is installed that facilitates creating/building Python\nC/API extension modules that make it possible\n\n"}, {"name": "fft.fft()", "path": "reference/generated/numpy.fft.fft", "type": "numpy.fft.fft", "text": "\nCompute the one-dimensional discrete Fourier Transform.\n\n"}, {"name": "fft.fft2()", "path": "reference/generated/numpy.fft.fft2", "type": "numpy.fft.fft2", "text": "\nCompute the 2-dimensional discrete Fourier Transform.\n\n"}, {"name": "fft.fftfreq()", "path": "reference/generated/numpy.fft.fftfreq", "type": "numpy.fft.fftfreq", "text": "\nReturn the Discrete Fourier Transform sample frequencies.\n\n"}, {"name": "fft.fftn()", "path": "reference/generated/numpy.fft.fftn", "type": "numpy.fft.fftn", "text": "\nCompute the N-dimensional discrete Fourier Transform.\n\n"}, {"name": "fft.fftshift()", "path": "reference/generated/numpy.fft.fftshift", "type": "numpy.fft.fftshift", "text": "\nShift the zero-frequency component to the center of the spectrum.\n\n"}, {"name": "fft.hfft()", "path": "reference/generated/numpy.fft.hfft", "type": "numpy.fft.hfft", "text": "\nCompute the FFT of a signal that has Hermitian symmetry, i.e., a real\nspectrum.\n\n"}, {"name": "fft.ifft()", "path": "reference/generated/numpy.fft.ifft", "type": "numpy.fft.ifft", "text": "\nCompute the one-dimensional inverse discrete Fourier Transform.\n\n"}, {"name": "fft.ifft2()", "path": "reference/generated/numpy.fft.ifft2", "type": "numpy.fft.ifft2", "text": "\nCompute the 2-dimensional inverse discrete Fourier Transform.\n\n"}, {"name": "fft.ifftn()", "path": "reference/generated/numpy.fft.ifftn", "type": "numpy.fft.ifftn", "text": "\nCompute the N-dimensional inverse discrete Fourier Transform.\n\n"}, {"name": "fft.ifftshift()", "path": "reference/generated/numpy.fft.ifftshift", "type": "numpy.fft.ifftshift", "text": "\nThe inverse of `fftshift`. Although identical for even-length `x`, the\nfunctions differ by one sample for odd-length `x`.\n\n"}, {"name": "fft.ihfft()", "path": "reference/generated/numpy.fft.ihfft", "type": "numpy.fft.ihfft", "text": "\nCompute the inverse FFT of a signal that has Hermitian symmetry.\n\n"}, {"name": "fft.irfft()", "path": "reference/generated/numpy.fft.irfft", "type": "numpy.fft.irfft", "text": "\nComputes the inverse of `rfft`.\n\n"}, {"name": "fft.irfft2()", "path": "reference/generated/numpy.fft.irfft2", "type": "numpy.fft.irfft2", "text": "\nComputes the inverse of `rfft2`.\n\n"}, {"name": "fft.irfftn()", "path": "reference/generated/numpy.fft.irfftn", "type": "numpy.fft.irfftn", "text": "\nComputes the inverse of `rfftn`.\n\n"}, {"name": "fft.rfft()", "path": "reference/generated/numpy.fft.rfft", "type": "numpy.fft.rfft", "text": "\nCompute the one-dimensional discrete Fourier Transform for real input.\n\n"}, {"name": "fft.rfft2()", "path": "reference/generated/numpy.fft.rfft2", "type": "numpy.fft.rfft2", "text": "\nCompute the 2-dimensional FFT of a real array.\n\n"}, {"name": "fft.rfftfreq()", "path": "reference/generated/numpy.fft.rfftfreq", "type": "numpy.fft.rfftfreq", "text": "\nReturn the Discrete Fourier Transform sample frequencies (for usage with rfft,\nirfft).\n\n"}, {"name": "fft.rfftn()", "path": "reference/generated/numpy.fft.rfftn", "type": "numpy.fft.rfftn", "text": "\nCompute the N-dimensional discrete Fourier Transform for real input.\n\n"}, {"name": "final class numpy.typing.NBitBase", "path": "reference/typing#numpy.typing.NBitBase", "type": "Typing ( \n    \n     numpy.typing\n    \n    )", "text": "\nA type representing `numpy.number` precision during static type checking.\n\n"}, {"name": "flatiter.base", "path": "reference/generated/numpy.flatiter.base", "type": "Indexing routines", "text": "\nattribute\n\n"}, {"name": "flatiter.coords", "path": "reference/generated/numpy.flatiter.coords", "type": "Indexing routines", "text": "\nattribute\n\n"}, {"name": "flatiter.copy()", "path": "reference/generated/numpy.flatiter.copy", "type": "numpy.flatiter.copy", "text": "\nmethod\n\n"}, {"name": "flatiter.index", "path": "reference/generated/numpy.flatiter.index", "type": "Indexing routines", "text": "\nattribute\n\n"}, {"name": "float npy_half_to_float()", "path": "reference/c-api/coremath#c.npy_half_to_float", "type": "NumPy core libraries", "text": "\nConverts a half-precision float to a single-precision float.\n\n"}, {"name": "float random_gamma_f()", "path": "reference/random/c-api#c.random_gamma_f", "type": "C API for random", "text": "\n\n"}, {"name": "float random_standard_exponential_f()", "path": "reference/random/c-api#c.random_standard_exponential_f", "type": "C API for random", "text": "\n\n"}, {"name": "float random_standard_gamma_f()", "path": "reference/random/c-api#c.random_standard_gamma_f", "type": "C API for random", "text": "\n\n"}, {"name": "float random_standard_normal_f()", "path": "reference/random/c-api#c.random_standard_normal_f", "type": "C API for random", "text": "\n\n"}, {"name": "float random_standard_uniform_f()", "path": "reference/random/c-api#c.random_standard_uniform_f", "type": "C API for random", "text": "\n\n"}, {"name": "Floating point error handling", "path": "reference/routines.err", "type": "Floating point error handling", "text": "\n`seterr`([all, divide, over, under, invalid])\n\n"}, {"name": "For downstream package authors", "path": "user/depending_on_numpy", "type": "User Guide", "text": "\nThis document aims to explain some best practices for authoring a package that\ndepends on NumPy.\n\n"}, {"name": "Fortran 77 programs", "path": "f2py/buildtools/index", "type": "F2PY and Build Systems", "text": "\nIn this section we will cover the various popular build systems and their\nusage with `f2py`.\n\n"}, {"name": "Functional programming", "path": "reference/routines.functional", "type": "Functional programming", "text": "\n`apply_along_axis`(func1d, axis, arr, *args, ...)\n\n"}, {"name": "generic.__array__()", "path": "reference/generated/numpy.generic.__array__", "type": "numpy.generic.__array__", "text": "\nmethod\n\n"}, {"name": "generic.__array_interface__", "path": "reference/generated/numpy.generic.__array_interface__", "type": "numpy.generic.__array_interface__", "text": "\nattribute\n\n"}, {"name": "generic.__array_priority__", "path": "reference/generated/numpy.generic.__array_priority__", "type": "numpy.generic.__array_priority__", "text": "\nattribute\n\n"}, {"name": "generic.__array_struct__", "path": "reference/generated/numpy.generic.__array_struct__", "type": "numpy.generic.__array_struct__", "text": "\nattribute\n\n"}, {"name": "generic.__array_wrap__()", "path": "reference/generated/numpy.generic.__array_wrap__", "type": "numpy.generic.__array_wrap__", "text": "\nmethod\n\n"}, {"name": "generic.__reduce__()", "path": "reference/generated/numpy.generic.__reduce__", "type": "numpy.generic.__reduce__", "text": "\nmethod\n\n"}, {"name": "generic.__setstate__()", "path": "reference/generated/numpy.generic.__setstate__", "type": "numpy.generic.__setstate__", "text": "\nmethod\n\n"}, {"name": "generic.base", "path": "reference/generated/numpy.generic.base", "type": "numpy.generic.base", "text": "\nattribute\n\n"}, {"name": "generic.byteswap()", "path": "reference/generated/numpy.generic.byteswap", "type": "numpy.generic.byteswap", "text": "\nmethod\n\n"}, {"name": "generic.data", "path": "reference/generated/numpy.generic.data", "type": "numpy.generic.data", "text": "\nattribute\n\n"}, {"name": "generic.dtype", "path": "reference/generated/numpy.generic.dtype", "type": "numpy.generic.dtype", "text": "\nattribute\n\n"}, {"name": "generic.flags", "path": "reference/generated/numpy.generic.flags", "type": "numpy.generic.flags", "text": "\nattribute\n\n"}, {"name": "generic.flat", "path": "reference/generated/numpy.generic.flat", "type": "numpy.generic.flat", "text": "\nattribute\n\n"}, {"name": "generic.imag", "path": "reference/generated/numpy.generic.imag", "type": "numpy.generic.imag", "text": "\nattribute\n\n"}, {"name": "generic.itemsize", "path": "reference/generated/numpy.generic.itemsize", "type": "numpy.generic.itemsize", "text": "\nattribute\n\n"}, {"name": "generic.ndim", "path": "reference/generated/numpy.generic.ndim", "type": "numpy.generic.ndim", "text": "\nattribute\n\n"}, {"name": "generic.real", "path": "reference/generated/numpy.generic.real", "type": "numpy.generic.real", "text": "\nattribute\n\n"}, {"name": "generic.setflags()", "path": "reference/generated/numpy.generic.setflags", "type": "numpy.generic.setflags", "text": "\nmethod\n\n"}, {"name": "generic.shape", "path": "reference/generated/numpy.generic.shape", "type": "numpy.generic.shape", "text": "\nattribute\n\n"}, {"name": "generic.size", "path": "reference/generated/numpy.generic.size", "type": "numpy.generic.size", "text": "\nattribute\n\n"}, {"name": "generic.squeeze()", "path": "reference/generated/numpy.generic.squeeze", "type": "numpy.generic.squeeze", "text": "\nmethod\n\n"}, {"name": "generic.strides", "path": "reference/generated/numpy.generic.strides", "type": "numpy.generic.strides", "text": "\nattribute\n\n"}, {"name": "generic.T", "path": "reference/generated/numpy.generic.t", "type": "numpy.generic.T", "text": "\nattribute\n\n"}, {"name": "Get the local copy of the code", "path": "dev/gitwash/following_latest", "type": "Development", "text": "\nFrom the command line:\n\n"}, {"name": "get_build_temp_dir()", "path": "reference/distutils#numpy.distutils.misc_util.Configuration.get_build_temp_dir", "type": "Packaging ( \n    \n     numpy.distutils\n    \n    )", "text": "\nReturn a path to a temporary directory where temporary files should be placed.\n\n"}, {"name": "get_config_cmd()", "path": "reference/distutils#numpy.distutils.misc_util.Configuration.get_config_cmd", "type": "Packaging ( \n    \n     numpy.distutils\n    \n    )", "text": "\nReturns the numpy.distutils config command instance.\n\n"}, {"name": "get_distribution()", "path": "reference/distutils#numpy.distutils.misc_util.Configuration.get_distribution", "type": "Packaging ( \n    \n     numpy.distutils\n    \n    )", "text": "\nReturn the distutils distribution object for self.\n\n"}, {"name": "get_info()", "path": "reference/distutils#numpy.distutils.misc_util.Configuration.get_info", "type": "Packaging ( \n    \n     numpy.distutils\n    \n    )", "text": "\nGet resources information.\n\n"}, {"name": "get_subpackage()", "path": "reference/distutils#numpy.distutils.misc_util.Configuration.get_subpackage", "type": "Packaging ( \n    \n     numpy.distutils\n    \n    )", "text": "\nReturn list of subpackage configurations.\n\n"}, {"name": "get_version()", "path": "reference/distutils#numpy.distutils.misc_util.Configuration.get_version", "type": "Packaging ( \n    \n     numpy.distutils\n    \n    )", "text": "\nTry to get version string of a package.\n\n"}, {"name": "Git configuration", "path": "dev/gitwash/configure_git", "type": "Development", "text": "\nYour personal git configurations are saved in the `.gitconfig` file in your\nhome directory. Here is an example `.gitconfig` file:\n\n"}, {"name": "Git for development", "path": "dev/gitwash/index", "type": "Development", "text": "\nThese pages describe a general git and github workflow.\n\n"}, {"name": "Global State", "path": "reference/global_state", "type": "Global State", "text": "\nNumPy has a few import-time, compile-time, or runtime options which change the\nglobal behaviour. Most of these are related to performance or for debugging\npurposes and will not be interesting to the vast majority of users.\n\n"}, {"name": "have_f77c()", "path": "reference/distutils#numpy.distutils.misc_util.Configuration.have_f77c", "type": "Packaging ( \n    \n     numpy.distutils\n    \n    )", "text": "\nCheck for availability of Fortran 77 compiler.\n\n"}, {"name": "have_f90c()", "path": "reference/distutils#numpy.distutils.misc_util.Configuration.have_f90c", "type": "Packaging ( \n    \n     numpy.distutils\n    \n    )", "text": "\nCheck for availability of Fortran 90 compiler.\n\n"}, {"name": "Hermite Series, \u201cPhysicists\u201d (numpy.polynomial.hermite)", "path": "reference/routines.polynomials.hermite", "type": "Hermite Series, \u201cPhysicists\u201d ( \n        \n         numpy.polynomial.hermite\n        \n        )", "text": "\nThis module provides a number of objects (mostly functions) useful for dealing\nwith Hermite series, including a `Hermite` class that encapsulates the usual\narithmetic operations. (General information on how this module represents and\nworks with such polynomials is in the docstring for its \u201cparent\u201d sub-package,\n`numpy.polynomial`).\n\n"}, {"name": "HermiteE Series, \u201cProbabilists\u201d (numpy.polynomial.hermite_e)", "path": "reference/routines.polynomials.hermite_e", "type": "HermiteE Series, \u201cProbabilists\u201d ( \n        \n         numpy.polynomial.hermite_e\n        \n        )", "text": "\nThis module provides a number of objects (mostly functions) useful for dealing\nwith Hermite_e series, including a `HermiteE` class that encapsulates the\nusual arithmetic operations. (General information on how this module\nrepresents and works with such polynomials is in the docstring for its\n\u201cparent\u201d sub-package, `numpy.polynomial`).\n\n"}, {"name": "How to write a NumPy how-to", "path": "user/how-to-how-to", "type": "User Guide", "text": "\nHow-tos get straight to the point \u2013 they\n\n"}, {"name": "I/O with NumPy", "path": "user/basics.io", "type": "User Guide", "text": "\n\n"}, {"name": "include statements", "path": "f2py/signature-file", "type": "Signature file", "text": "\nThe syntax specification for signature files (.pyf files) is modeled on the\nFortran 90/95 language specification. Almost all Fortran 90/95 standard\nconstructs are understood, both in free and fixed format (recall that Fortran\n77 is a subset of Fortran 90/95). F2PY introduces some extensions to the\nFortran 90/95 language specification that help in the design of the Fortran to\nPython interface, making it more \u201cPythonic\u201d.\n\n"}, {"name": "Indexing on ndarrays", "path": "user/basics.indexing", "type": "User Guide", "text": "\nSee also\n\n"}, {"name": "Indexing routines", "path": "reference/arrays.indexing", "type": "Indexing routines", "text": "\nSee also\n\n"}, {"name": "Input and output", "path": "reference/routines.io", "type": "Input and output", "text": "\n`load`(file[, mmap_mode, allow_pickle, ...])\n\n"}, {"name": "Install git", "path": "dev/gitwash/git_intro", "type": "Development", "text": "\nDeveloping with git can be done entirely without github. Git is a distributed\nversion control system. In order to use git on your machine you must install\nit.\n\n"}, {"name": "int **cancastscalarkindto", "path": "reference/c-api/types-and-structures#c.PyArray_ArrFuncs.cancastscalarkindto", "type": "Python Types and C-Structures", "text": "\nEither `NULL` or an array of `NPY_NSCALARKINDS` pointers. These pointers\nshould each be either `NULL` or a pointer to an array of integers (terminated\nby `NPY_NOTYPE`) indicating data-types that a scalar of this data-type of the\nspecified kind can be cast to safely (this usually means without losing\nprecision).\n\n"}, {"name": "int *cancastto", "path": "reference/c-api/types-and-structures#c.PyArray_ArrFuncs.cancastto", "type": "Python Types and C-Structures", "text": "\nEither `NULL` or an array of integers (terminated by `NPY_NOTYPE` ) indicated\ndata-types that this data-type can be cast to safely (this usually means\nwithout losing precision).\n\n"}, {"name": "int *core_dim_ixs", "path": "reference/c-api/types-and-structures#c.PyUFuncObject.core_dim_ixs", "type": "Python Types and C-Structures", "text": "\nDimension indices in a flattened form; indices of argument `k` are stored in\n`core_dim_ixs[core_offsets[k] : core_offsets[k] + core_numdims[k]]`\n\n"}, {"name": "int *core_num_dims", "path": "reference/c-api/types-and-structures#c.PyUFuncObject.core_num_dims", "type": "Python Types and C-Structures", "text": "\nNumber of core dimensions of each argument\n\n"}, {"name": "int *core_offsets", "path": "reference/c-api/types-and-structures#c.PyUFuncObject.core_offsets", "type": "Python Types and C-Structures", "text": "\nPosition of 1st core dimension of each argument in `core_dim_ixs`, equivalent\nto cumsum(`core_num_dims`)\n\n"}, {"name": "int alignment", "path": "reference/c-api/types-and-structures#c.NPY_USE_SETITEM.alignment", "type": "Python Types and C-Structures", "text": "\nA number providing alignment information for this data type. Specifically, it\nshows how far from the start of a 2-element structure (whose first element is\na `char` ), the compiler places an item of this type: `offsetof(struct {char\nc; type v;}, v)`\n\n"}, {"name": "int argmax()", "path": "reference/c-api/types-and-structures#c.PyArray_ArrFuncs.argmax", "type": "Python Types and C-Structures", "text": "\nA pointer to a function that retrieves the index of the largest of `n`\nelements in `arr` beginning at the element pointed to by `data`. This function\nrequires that the memory segment be contiguous and behaved. The return value\nis always 0. The index of the largest element is returned in `max_ind`.\n\n"}, {"name": "int argmin()", "path": "reference/c-api/types-and-structures#c.PyArray_ArrFuncs.argmin", "type": "Python Types and C-Structures", "text": "\nA pointer to a function that retrieves the index of the smallest of `n`\nelements in `arr` beginning at the element pointed to by `data`. This function\nrequires that the memory segment be contiguous and behaved. The return value\nis always 0. The index of the smallest element is returned in `min_ind`.\n\n"}, {"name": "int argsort()", "path": "reference/c-api/types-and-structures#c.PyArray_ArrFuncs.argsort", "type": "Python Types and C-Structures", "text": "\nAn array of function pointers to sorting algorithms for this data type. The\nsame sorting algorithms as for sort are available. The indices producing the\nsort are returned in `result` (which must be initialized with indices 0 to\n`length-1` inclusive).\n\n"}, {"name": "int compare()", "path": "reference/c-api/types-and-structures#c.PyArray_ArrFuncs.compare", "type": "Python Types and C-Structures", "text": "\nA pointer to a function that compares two elements of the array, `arr`,\npointed to by `d1` and `d2`. This function requires behaved (aligned and not\nswapped) arrays. The return value is 1 if * `d1` > * `d2`, 0 if * `d1` == *\n`d2`, and -1 if * `d1` < * `d2`. The array object `arr` is used to retrieve\nitemsize and field information for flexible arrays.\n\n"}, {"name": "int core_enabled", "path": "reference/c-api/types-and-structures#c.PyUFuncObject.core_enabled", "type": "Python Types and C-Structures", "text": "\n0 for scalar ufuncs; 1 for generalized ufuncs\n\n"}, {"name": "int core_num_dim_ix", "path": "reference/c-api/types-and-structures#c.PyUFuncObject.core_num_dim_ix", "type": "Python Types and C-Structures", "text": "\nNumber of distinct core dimension names in the signature\n\n"}, {"name": "int doxy_javadoc_example()", "path": "dev/howto-docs", "type": "Development", "text": "\nThis guide will help you decide what to contribute and how to submit it to the\nofficial NumPy documentation.\n\n"}, {"name": "int elsize", "path": "reference/c-api/types-and-structures#c.NPY_USE_SETITEM.elsize", "type": "Python Types and C-Structures", "text": "\nFor data types that are always the same size (such as long), this holds the\nsize of the data type. For flexible data types where different arrays can have\na different elementsize, this should be 0.\n\n"}, {"name": "int flags", "path": "reference/c-api/types-and-structures#c.PyArray_Chunk.flags", "type": "Python Types and C-Structures", "text": "\nAny data flags (e.g. `NPY_ARRAY_WRITEABLE` ) that should be used to interpret\nthe memory.\n\n"}, {"name": "int flags", "path": "reference/c-api/types-and-structures#c.NPY_AO.flags", "type": "Python Types and C-Structures", "text": "\nPointed to by the macro `PyArray_FLAGS`, this data member represents the flags\nindicating how the memory pointed to by data is to be interpreted. Possible\nflags are `NPY_ARRAY_C_CONTIGUOUS`, `NPY_ARRAY_F_CONTIGUOUS`,\n`NPY_ARRAY_OWNDATA`, `NPY_ARRAY_ALIGNED`, `NPY_ARRAY_WRITEABLE`,\n`NPY_ARRAY_WRITEBACKIFCOPY`, and `NPY_ARRAY_UPDATEIFCOPY`.\n\n"}, {"name": "int flags", "path": "reference/c-api/types-and-structures#c.PyArrayInterface.flags", "type": "Python Types and C-Structures", "text": "\nAny of the bits `NPY_ARRAY_C_CONTIGUOUS` (1), `NPY_ARRAY_F_CONTIGUOUS` (2),\n`NPY_ARRAY_ALIGNED` (0x100), `NPY_ARRAY_NOTSWAPPED` (0x200), or\n`NPY_ARRAY_WRITEABLE` (0x400) to indicate something about the data. The\n`NPY_ARRAY_ALIGNED`, `NPY_ARRAY_C_CONTIGUOUS`, and `NPY_ARRAY_F_CONTIGUOUS`\nflags can actually be determined from the other parameters. The flag\n`NPY_ARR_HAS_DESCR` (0x800) can also be set to indicate to objects consuming\nthe version 3 array interface that the descr member of the structure is\npresent (it will be ignored by objects consuming version 2 of the array\ninterface).\n\n"}, {"name": "int fromstr()", "path": "reference/c-api/types-and-structures#c.PyArray_ArrFuncs.fromstr", "type": "Python Types and C-Structures", "text": "\nA pointer to a function that converts the string pointed to by `str` to one\nelement of the corresponding type and places it in the memory location pointed\nto by `ip`. After the conversion is completed, `*endptr` points to the rest of\nthe string. The last argument `arr` is the array into which ip points (needed\nfor variable-size data- types). Returns 0 on success or -1 on failure.\nRequires a behaved array. This function should be called without holding the\nPython GIL, and has to grab it for error reporting.\n\n"}, {"name": "int identity", "path": "reference/c-api/types-and-structures#c.PyUFuncObject.identity", "type": "Python Types and C-Structures", "text": "\nEither `PyUFunc_One`, `PyUFunc_Zero`, `PyUFunc_MinusOne`, `PyUFunc_None`,\n`PyUFunc_ReorderableNone`, or `PyUFunc_IdentityValue` to indicate the identity\nfor this operation. It is only used for a reduce-like call on an empty array.\n\n"}, {"name": "int itemsize", "path": "reference/c-api/types-and-structures#c.PyArrayInterface.itemsize", "type": "Python Types and C-Structures", "text": "\nThe number of bytes each item in the array requires.\n\n"}, {"name": "int len", "path": "reference/c-api/types-and-structures#c.PyArray_Dims.len", "type": "Python Types and C-Structures", "text": "\nThe length of the list of integers. It is assumed safe to access ptr [0] to\nptr [len-1].\n\n"}, {"name": "int nargs", "path": "reference/c-api/types-and-structures#c.PyUFuncObject.nargs", "type": "Python Types and C-Structures", "text": "\nThe total number of arguments (nin \\+ nout). This must be less than\n`NPY_MAXARGS`.\n\n"}, {"name": "int nd", "path": "reference/c-api/types-and-structures#c.NPY_AO.nd", "type": "Python Types and C-Structures", "text": "\nAn integer providing the number of dimensions for this array. When nd is 0,\nthe array is sometimes called a rank-0 array. Such arrays have undefined\ndimensions and strides and cannot be accessed. Macro `PyArray_NDIM` defined in\n`ndarraytypes.h` points to this data member. `NPY_MAXDIMS` is the largest\nnumber of dimensions for any array.\n\n"}, {"name": "int nd", "path": "reference/c-api/types-and-structures#c.PyArrayMultiIterObject.nd", "type": "Python Types and C-Structures", "text": "\nThe number of dimensions in the broadcasted result.\n\n"}, {"name": "int nd", "path": "reference/c-api/types-and-structures#c.PyArrayInterface.nd", "type": "Python Types and C-Structures", "text": "\nthe number of dimensions in the array.\n\n"}, {"name": "int nout", "path": "reference/c-api/types-and-structures#c.PyUFuncObject.nout", "type": "Python Types and C-Structures", "text": "\nThe number of output arguments.\n\n"}, {"name": "int npy_clear_floatstatus()", "path": "reference/c-api/coremath#c.npy_clear_floatstatus", "type": "NumPy core libraries", "text": "\nClears the floating point status. Returns the previous status mask.\n\n"}, {"name": "int npy_clear_floatstatus_barrier()", "path": "reference/c-api/coremath#c.npy_clear_floatstatus_barrier", "type": "NumPy core libraries", "text": "\nClears the floating point status. A pointer to a local variable is passed in\nto prevent aggressive compiler optimizations from reordering this function\ncall. Returns the previous status mask.\n\n"}, {"name": "int npy_get_floatstatus()", "path": "reference/c-api/coremath#c.npy_get_floatstatus", "type": "NumPy core libraries", "text": "\nGet floating point status. Returns a bitmask with following possible flags:\n\n"}, {"name": "int npy_get_floatstatus_barrier()", "path": "reference/c-api/coremath#c.npy_get_floatstatus_barrier", "type": "NumPy core libraries", "text": "\nGet floating point status. A pointer to a local variable is passed in to\nprevent aggressive compiler optimizations from reordering this function call\nrelative to the code setting the status, which could lead to incorrect\nresults.\n\n"}, {"name": "int npy_half_eq()", "path": "reference/c-api/coremath#c.npy_half_eq", "type": "NumPy core libraries", "text": "\nCompares two half-precision floats (h1 == h2).\n\n"}, {"name": "int npy_half_eq_nonan()", "path": "reference/c-api/coremath#c.npy_half_eq_nonan", "type": "NumPy core libraries", "text": "\nCompares two half-precision floats that are known to not be NaN (h1 == h2). If\na value is NaN, the result is undefined.\n\n"}, {"name": "int npy_half_ge()", "path": "reference/c-api/coremath#c.npy_half_ge", "type": "NumPy core libraries", "text": "\nCompares two half-precision floats (h1 >= h2).\n\n"}, {"name": "int npy_half_gt()", "path": "reference/c-api/coremath#c.npy_half_gt", "type": "NumPy core libraries", "text": "\nCompares two half-precision floats (h1 > h2).\n\n"}, {"name": "int npy_half_isfinite()", "path": "reference/c-api/coremath#c.npy_half_isfinite", "type": "NumPy core libraries", "text": "\nTests whether the half-precision float is finite (not NaN or Inf).\n\n"}, {"name": "int npy_half_isinf()", "path": "reference/c-api/coremath#c.npy_half_isinf", "type": "NumPy core libraries", "text": "\nTests whether the half-precision float is plus or minus Inf.\n\n"}, {"name": "int npy_half_isnan()", "path": "reference/c-api/coremath#c.npy_half_isnan", "type": "NumPy core libraries", "text": "\nTests whether the half-precision float is a NaN.\n\n"}, {"name": "int npy_half_iszero()", "path": "reference/c-api/coremath#c.npy_half_iszero", "type": "NumPy core libraries", "text": "\nTests whether the half-precision float has a value equal to zero. This may be\nslightly faster than calling npy_half_eq(h, NPY_ZERO).\n\n"}, {"name": "int npy_half_le()", "path": "reference/c-api/coremath#c.npy_half_le", "type": "NumPy core libraries", "text": "\nCompares two half-precision floats (h1 <= h2).\n\n"}, {"name": "int npy_half_le_nonan()", "path": "reference/c-api/coremath#c.npy_half_le_nonan", "type": "NumPy core libraries", "text": "\nCompares two half-precision floats that are known to not be NaN (h1 <= h2). If\na value is NaN, the result is undefined.\n\n"}, {"name": "int npy_half_lt()", "path": "reference/c-api/coremath#c.npy_half_lt", "type": "NumPy core libraries", "text": "\nCompares two half-precision floats (h1 < h2).\n\n"}, {"name": "int npy_half_lt_nonan()", "path": "reference/c-api/coremath#c.npy_half_lt_nonan", "type": "NumPy core libraries", "text": "\nCompares two half-precision floats that are known to not be NaN (h1 < h2). If\na value is NaN, the result is undefined.\n\n"}, {"name": "int npy_half_ne()", "path": "reference/c-api/coremath#c.npy_half_ne", "type": "NumPy core libraries", "text": "\nCompares two half-precision floats (h1 != h2).\n\n"}, {"name": "int npy_half_signbit()", "path": "reference/c-api/coremath#c.npy_half_signbit", "type": "NumPy core libraries", "text": "\nReturns 1 is h is negative, 0 otherwise.\n\n"}, {"name": "int NpyIter_CreateCompatibleStrides()", "path": "reference/c-api/iterator#c.NpyIter_CreateCompatibleStrides", "type": "Array Iterator API", "text": "\nBuilds a set of strides which are the same as the strides of an output array\ncreated using the `NPY_ITER_ALLOCATE` flag, where NULL was passed for op_axes.\nThis is for data packed contiguously, but not necessarily in C or Fortran\norder. This should be used together with `NpyIter_GetShape` and\n`NpyIter_GetNDim` with the flag `NPY_ITER_MULTI_INDEX` passed into the\nconstructor.\n\n"}, {"name": "int NpyIter_Deallocate()", "path": "reference/c-api/iterator#c.NpyIter_Deallocate", "type": "Array Iterator API", "text": "\nDeallocates the iterator object and resolves any needed writebacks.\n\n"}, {"name": "int NpyIter_EnableExternalLoop()", "path": "reference/c-api/iterator#c.NpyIter_EnableExternalLoop", "type": "Array Iterator API", "text": "\nIf `NpyIter_RemoveMultiIndex` was called, you may want to enable the flag\n`NPY_ITER_EXTERNAL_LOOP`. This flag is not permitted together with\n`NPY_ITER_MULTI_INDEX`, so this function is provided to enable the feature\nafter `NpyIter_RemoveMultiIndex` is called. This function also resets the\niterator to its initial state.\n\n"}, {"name": "int NpyIter_GetNDim()", "path": "reference/c-api/iterator#c.NpyIter_GetNDim", "type": "Array Iterator API", "text": "\nReturns the number of dimensions being iterated. If a multi-index was not\nrequested in the iterator constructor, this value may be smaller than the\nnumber of dimensions in the original objects.\n\n"}, {"name": "int NpyIter_GetNOp()", "path": "reference/c-api/iterator#c.NpyIter_GetNOp", "type": "Array Iterator API", "text": "\nReturns the number of operands in the iterator.\n\n"}, {"name": "int NpyIter_GetShape()", "path": "reference/c-api/iterator#c.NpyIter_GetShape", "type": "Array Iterator API", "text": "\nReturns the broadcast shape of the iterator in `outshape`. This can only be\ncalled on an iterator which is tracking a multi-index.\n\n"}, {"name": "int NpyIter_GotoIndex()", "path": "reference/c-api/iterator#c.NpyIter_GotoIndex", "type": "Array Iterator API", "text": "\nAdjusts the iterator to point to the `index` specified. If the iterator was\nconstructed with the flag `NPY_ITER_C_INDEX`, `index` is the C-order index,\nand if the iterator was constructed with the flag `NPY_ITER_F_INDEX`, `index`\nis the Fortran-order index. Returns an error if there is no index being\ntracked, the index is out of bounds, or inner loop iteration is disabled.\n\n"}, {"name": "int NpyIter_GotoIterIndex()", "path": "reference/c-api/iterator#c.NpyIter_GotoIterIndex", "type": "Array Iterator API", "text": "\nAdjusts the iterator to point to the `iterindex` specified. The IterIndex is\nan index matching the iteration order of the iterator. Returns an error if the\n`iterindex` is out of bounds, buffering is enabled, or inner loop iteration is\ndisabled.\n\n"}, {"name": "int NpyIter_GotoMultiIndex()", "path": "reference/c-api/iterator#c.NpyIter_GotoMultiIndex", "type": "Array Iterator API", "text": "\nAdjusts the iterator to point to the `ndim` indices pointed to by\n`multi_index`. Returns an error if a multi-index is not being tracked, the\nindices are out of bounds, or inner loop iteration is disabled.\n\n"}, {"name": "int NpyIter_RemoveAxis()", "path": "reference/c-api/iterator#c.NpyIter_RemoveAxis", "type": "Array Iterator API", "text": "\nRemoves an axis from iteration. This requires that `NPY_ITER_MULTI_INDEX` was\nset for iterator creation, and does not work if buffering is enabled or an\nindex is being tracked. This function also resets the iterator to its initial\nstate.\n\n"}, {"name": "int NpyIter_RemoveMultiIndex()", "path": "reference/c-api/iterator#c.NpyIter_RemoveMultiIndex", "type": "Array Iterator API", "text": "\nIf the iterator is tracking a multi-index, this strips support for them, and\ndoes further iterator optimizations that are possible if multi-indices are not\nneeded. This function also resets the iterator to its initial state.\n\n"}, {"name": "int NpyIter_Reset()", "path": "reference/c-api/iterator#c.NpyIter_Reset", "type": "Array Iterator API", "text": "\nResets the iterator back to its initial state, at the beginning of the\niteration range.\n\n"}, {"name": "int NpyIter_ResetBasePointers()", "path": "reference/c-api/iterator#c.NpyIter_ResetBasePointers", "type": "Array Iterator API", "text": "\nResets the iterator back to its initial state, but using the values in\n`baseptrs` for the data instead of the pointers from the arrays being\niterated. This functions is intended to be used, together with the `op_axes`\nparameter, by nested iteration code with two or more iterators.\n\n"}, {"name": "int NpyIter_ResetToIterIndexRange()", "path": "reference/c-api/iterator#c.NpyIter_ResetToIterIndexRange", "type": "Array Iterator API", "text": "\nResets the iterator and restricts it to the `iterindex` range `[istart,\niend)`. See `NpyIter_Copy` for an explanation of how to use this for multi-\nthreaded iteration. This requires that the flag `NPY_ITER_RANGED` was passed\nto the iterator constructor.\n\n"}, {"name": "int ntypes", "path": "reference/c-api/types-and-structures#c.PyUFuncObject.ntypes", "type": "Python Types and C-Structures", "text": "\nThe number of supported data types for the ufunc. This number specifies how\nmany different 1-d loops (of the builtin data types) are available.\n\n"}, {"name": "int PyArray_AxisConverter()", "path": "reference/c-api/array#c.PyArray_AxisConverter", "type": "Array API", "text": "\nConvert a Python object, obj, representing an axis argument to the proper\nvalue for passing to the functions that take an integer axis. Specifically, if\nobj is None, axis is set to `NPY_MAXDIMS` which is interpreted correctly by\nthe C-API functions that take axis arguments.\n\n"}, {"name": "int PyArray_BoolConverter()", "path": "reference/c-api/array#c.PyArray_BoolConverter", "type": "Array API", "text": "\nConvert any Python object, obj, to `NPY_TRUE` or `NPY_FALSE`, and place the\nresult in value.\n\n"}, {"name": "int PyArray_Broadcast()", "path": "reference/c-api/array#c.PyArray_Broadcast", "type": "Array API", "text": "\nThis function encapsulates the broadcasting rules. The mit container should\nalready contain iterators for all the arrays that need to be broadcast. On\nreturn, these iterators will be adjusted so that iteration over each\nsimultaneously will accomplish the broadcasting. A negative number is returned\nif an error occurs.\n\n"}, {"name": "int PyArray_BufferConverter()", "path": "reference/c-api/array#c.PyArray_BufferConverter", "type": "Array API", "text": "\nConvert any Python object, obj, with a (single-segment) buffer interface to a\nvariable with members that detail the object\u2019s use of its chunk of memory. The\nbuf variable is a pointer to a structure with base, ptr, len, and flags\nmembers. The `PyArray_Chunk` structure is binary compatible with the Python\u2019s\nbuffer object (through its len member on 32-bit platforms and its ptr member\non 64-bit platforms or in Python 2.5). On return, the base member is set to\nobj (or its base if obj is already a buffer object pointing to another\nobject). If you need to hold on to the memory be sure to INCREF the base\nmember. The chunk of memory is pointed to by buf ->ptr member and has length\nbuf ->len. The flags member of buf is `NPY_ARRAY_ALIGNED` with the\n`NPY_ARRAY_WRITEABLE` flag set if obj has a writeable buffer interface.\n\n"}, {"name": "int PyArray_ByteorderConverter()", "path": "reference/c-api/array#c.PyArray_ByteorderConverter", "type": "Array API", "text": "\nConvert Python strings into the corresponding byte-order character: \u2018>\u2019, \u2018<\u2019,\n\u2018s\u2019, \u2018=\u2019, or \u2018|\u2019.\n\n"}, {"name": "int PyArray_CanCastArrayTo()", "path": "reference/c-api/array#c.PyArray_CanCastArrayTo", "type": "Array API", "text": "\nNew in version 1.6.\n\n"}, {"name": "int PyArray_CanCastSafely()", "path": "reference/c-api/array#c.PyArray_CanCastSafely", "type": "Array API", "text": "\nReturns non-zero if an array of data type fromtype can be cast to an array of\ndata type totype without losing information. An exception is that 64-bit\nintegers are allowed to be cast to 64-bit floating point values even though\nthis can lose precision on large integers so as not to proliferate the use of\nlong doubles without explicit requests. Flexible array types are not checked\naccording to their lengths with this function.\n\n"}, {"name": "int PyArray_CanCastTo()", "path": "reference/c-api/array#c.PyArray_CanCastTo", "type": "Array API", "text": "\n`PyArray_CanCastTypeTo` supersedes this function in NumPy 1.6 and later.\n\n"}, {"name": "int PyArray_CanCastTypeTo()", "path": "reference/c-api/array#c.PyArray_CanCastTypeTo", "type": "Array API", "text": "\nNew in version 1.6.\n\n"}, {"name": "int PyArray_CanCoerceScalar()", "path": "reference/c-api/array#c.PyArray_CanCoerceScalar", "type": "Array API", "text": "\nSee the function `PyArray_ResultType` for details of NumPy type promotion,\nupdated in NumPy 1.6.0.\n\n"}, {"name": "int PyArray_CastingConverter()", "path": "reference/c-api/array#c.PyArray_CastingConverter", "type": "Array API", "text": "\nConvert the Python strings \u2018no\u2019, \u2018equiv\u2019, \u2018safe\u2019, \u2018same_kind\u2019, and \u2018unsafe\u2019\ninto the `NPY_CASTING` enumeration `NPY_NO_CASTING`, `NPY_EQUIV_CASTING`,\n`NPY_SAFE_CASTING`, `NPY_SAME_KIND_CASTING`, and `NPY_UNSAFE_CASTING`.\n\n"}, {"name": "int PyArray_CastTo()", "path": "reference/c-api/array#c.PyArray_CastTo", "type": "Array API", "text": "\nAs of 1.6, this function simply calls `PyArray_CopyInto`, which handles the\ncasting.\n\n"}, {"name": "int PyArray_CheckAnyScalar()", "path": "reference/c-api/array#c.PyArray_CheckAnyScalar", "type": "Array API", "text": "\nEvaluates true if op is a Python scalar object (see `PyArray_IsPythonScalar`),\nan array scalar (an instance of a sub-type of `PyGenericArr_Type`) or an\ninstance of a sub-type of `PyArray_Type` whose dimensionality is 0.\n\n"}, {"name": "int PyArray_CheckExact()", "path": "reference/c-api/array#c.PyArray_CheckExact", "type": "Array API", "text": "\nEvaluates true if op is a Python object with type `PyArray_Type`.\n\n"}, {"name": "int PyArray_CheckScalar()", "path": "reference/c-api/array#c.PyArray_CheckScalar", "type": "Array API", "text": "\nEvaluates true if op is either an array scalar (an instance of a sub-type of\n`PyGenericArr_Type` ), or an instance of (a sub-class of) `PyArray_Type` whose\ndimensionality is 0.\n\n"}, {"name": "int PyArray_ClipmodeConverter()", "path": "reference/c-api/array#c.PyArray_ClipmodeConverter", "type": "Array API", "text": "\nConvert the Python strings \u2018clip\u2019, \u2018wrap\u2019, and \u2018raise\u2019 into the `NPY_CLIPMODE`\nenumeration `NPY_CLIP`, `NPY_WRAP`, and `NPY_RAISE`.\n\n"}, {"name": "int PyArray_CompareLists()", "path": "reference/c-api/array#c.PyArray_CompareLists", "type": "Array API", "text": "\nGiven two n -length arrays of integers, l1, and l2, return 1 if the lists are\nidentical; otherwise, return 0.\n\n"}, {"name": "int PyArray_ConvertClipmodeSequence()", "path": "reference/c-api/array#c.PyArray_ConvertClipmodeSequence", "type": "Array API", "text": "\nConverts either a sequence of clipmodes or a single clipmode into a C array of\n`NPY_CLIPMODE` values. The number of clipmodes n must be known before calling\nthis function. This function is provided to help functions allow a different\nclipmode for each dimension.\n\n"}, {"name": "int PyArray_CopyInto()", "path": "reference/c-api/array#c.PyArray_CopyInto", "type": "Array API", "text": "\nCopy from the source array, `src`, into the destination array, `dest`,\nperforming a data-type conversion if necessary. If an error occurs return -1\n(otherwise 0). The shape of `src` must be broadcastable to the shape of\n`dest`. The data areas of dest and src must not overlap.\n\n"}, {"name": "int PyArray_CopyObject()", "path": "reference/c-api/array#c.PyArray_CopyObject", "type": "Array API", "text": "\nAssign an object `src` to a NumPy array `dest` according to array-coercion\nrules. This is basically identical to `PyArray_FromAny`, but assigns directly\nto the output array. Returns 0 on success and -1 on failures.\n\n"}, {"name": "int Pyarray_DescrAlignConverter()", "path": "reference/c-api/array#c.Pyarray_DescrAlignConverter", "type": "Array API", "text": "\nLike `PyArray_DescrConverter` except it aligns C-struct-like objects on word-\nboundaries as the compiler would.\n\n"}, {"name": "int Pyarray_DescrAlignConverter2()", "path": "reference/c-api/array#c.Pyarray_DescrAlignConverter2", "type": "Array API", "text": "\nLike `PyArray_DescrConverter2` except it aligns C-struct-like objects on word-\nboundaries as the compiler would.\n\n"}, {"name": "int PyArray_DescrConverter()", "path": "reference/c-api/array#c.PyArray_DescrConverter", "type": "Array API", "text": "\nConvert any compatible Python object, obj, to a data-type object in dtype. A\nlarge number of Python objects can be converted to data-type objects. See Data\ntype objects (dtype) for a complete description. This version of the converter\nconverts None objects to a `NPY_DEFAULT_TYPE` data-type object. This function\ncan be used with the \u201cO&\u201d character code in `PyArg_ParseTuple` processing.\n\n"}, {"name": "int PyArray_DescrConverter2()", "path": "reference/c-api/array#c.PyArray_DescrConverter2", "type": "Array API", "text": "\nConvert any compatible Python object, obj, to a data-type object in dtype.\nThis version of the converter converts None objects so that the returned data-\ntype is `NULL`. This function can also be used with the \u201cO&\u201d character in\nPyArg_ParseTuple processing.\n\n"}, {"name": "int PyArray_Dump()", "path": "reference/c-api/array#c.PyArray_Dump", "type": "Array API", "text": "\nPickle the object in self to the given file (either a string or a Python file\nobject). If file is a Python string it is considered to be the name of a file\nwhich is then opened in binary mode. The given protocol is used (if protocol\nis negative, or the highest available is used). This is a simple wrapper\naround cPickle.dump(self, file, protocol).\n\n"}, {"name": "int PyArray_EquivByteorders()", "path": "reference/c-api/array#c.PyArray_EquivByteorders", "type": "Array API", "text": "\nTrue if byteorder characters b1 and b2 ( `NPY_LITTLE`, `NPY_BIG`,\n`NPY_NATIVE`, `NPY_IGNORE` ) are either equal or equivalent as to their\nspecification of a native byte order. Thus, on a little-endian machine\n`NPY_LITTLE` and `NPY_NATIVE` are equivalent where they are not equivalent on\na big-endian machine.\n\n"}, {"name": "int PyArray_FillWithScalar()", "path": "reference/c-api/array#c.PyArray_FillWithScalar", "type": "Array API", "text": "\nFill the array, arr, with the given scalar object, obj. The object is first\nconverted to the data type of arr, and then copied into every location. A -1\nis returned if an error occurs, otherwise 0 is returned.\n\n"}, {"name": "int PyArray_FinalizeFunc()", "path": "reference/c-api/array#c.PyArray_FinalizeFunc", "type": "Array API", "text": "\nThe function pointed to by the CObject `__array_finalize__`. The first\nargument is the newly created sub-type. The second argument (if not NULL) is\nthe \u201cparent\u201d array (if the array was created using slicing or some other\noperation where a clearly-distinguishable parent is present). This routine can\ndo anything it wants to. It should return a -1 on error and 0 otherwise.\n\n"}, {"name": "int PyArray_FLAGS()", "path": "reference/c-api/array#c.PyArray_FLAGS", "type": "Array API", "text": "\nReturns an integer representing the array-flags.\n\n"}, {"name": "int PyArray_Free()", "path": "reference/c-api/array#c.PyArray_Free", "type": "Array API", "text": "\nMust be called with the same objects and memory locations returned from\n`PyArray_AsCArray` (\u2026). This function cleans up memory that otherwise would\nget leaked.\n\n"}, {"name": "int PyArray_GetArrayParamsFromObject()", "path": "reference/c-api/array#c.PyArray_GetArrayParamsFromObject", "type": "Array API", "text": "\nDeprecated since version NumPy: 1.19\n\n"}, {"name": "int PyArray_GetEndianness()", "path": "reference/c-api/config#c.PyArray_GetEndianness", "type": "System configuration", "text": "\nNew in version 1.3.0.\n\n"}, {"name": "int PyArray_HasArrayInterface()", "path": "reference/c-api/array#c.PyArray_HasArrayInterface", "type": "Array API", "text": "\nIf `op` implements any part of the array interface, then `out` will contain a\nnew reference to the newly created ndarray using the interface or `out` will\ncontain `NULL` if an error during conversion occurs. Otherwise, out will\ncontain a borrowed reference to `Py_NotImplemented` and no error condition is\nset.\n\n"}, {"name": "int PyArray_HasArrayInterfaceType()", "path": "reference/c-api/array#c.PyArray_HasArrayInterfaceType", "type": "Array API", "text": "\nIf `op` implements any part of the array interface, then `out` will contain a\nnew reference to the newly created ndarray using the interface or `out` will\ncontain `NULL` if an error during conversion occurs. Otherwise, out will\ncontain a borrowed reference to Py_NotImplemented and no error condition is\nset. This version allows setting of the dtype in the part of the array\ninterface that looks for the `__array__` attribute. `context` is unused.\n\n"}, {"name": "int PyArray_HASFIELDS()", "path": "reference/c-api/array#c.PyArray_HASFIELDS", "type": "Array API", "text": "\nType has fields associated with it.\n\n"}, {"name": "int PyArray_IntpConverter()", "path": "reference/c-api/array#c.PyArray_IntpConverter", "type": "Array API", "text": "\nConvert any Python sequence, obj, smaller than `NPY_MAXDIMS` to a C-array of\n`npy_intp`. The Python object could also be a single number. The seq variable\nis a pointer to a structure with members ptr and len. On successful return,\nseq ->ptr contains a pointer to memory that must be freed, by calling\n`PyDimMem_FREE`, to avoid a memory leak. The restriction on memory size allows\nthis converter to be conveniently used for sequences intended to be\ninterpreted as array shapes.\n\n"}, {"name": "int PyArray_IntpFromSequence()", "path": "reference/c-api/array#c.PyArray_IntpFromSequence", "type": "Array API", "text": "\nConvert any Python sequence (or single Python number) passed in as seq to (up\nto) maxvals pointer-sized integers and place them in the vals array. The\nsequence can be smaller then maxvals as the number of converted objects is\nreturned.\n\n"}, {"name": "int PyArray_IS_C_CONTIGUOUS()", "path": "reference/c-api/array#c.PyArray_IS_C_CONTIGUOUS", "type": "Array API", "text": "\nEvaluates true if arr is C-style contiguous.\n\n"}, {"name": "int PyArray_IS_F_CONTIGUOUS()", "path": "reference/c-api/array#c.PyArray_IS_F_CONTIGUOUS", "type": "Array API", "text": "\nEvaluates true if arr is Fortran-style contiguous.\n\n"}, {"name": "int PyArray_ISALIGNED()", "path": "reference/c-api/array#c.PyArray_ISALIGNED", "type": "Array API", "text": "\nEvaluates true if the data area of arr is properly aligned on the machine.\n\n"}, {"name": "int PyArray_IsAnyScalar()", "path": "reference/c-api/array#c.PyArray_IsAnyScalar", "type": "Array API", "text": "\nEvaluates true if op is either a Python scalar object (see\n`PyArray_IsPythonScalar`) or an array scalar (an instance of a sub- type of\n`PyGenericArr_Type` ).\n\n"}, {"name": "int PyArray_ISBEHAVED()", "path": "reference/c-api/array#c.PyArray_ISBEHAVED", "type": "Array API", "text": "\nEvaluates true if the data area of arr is aligned and writeable and in machine\nbyte-order according to its descriptor.\n\n"}, {"name": "int PyArray_ISBEHAVED_RO()", "path": "reference/c-api/array#c.PyArray_ISBEHAVED_RO", "type": "Array API", "text": "\nEvaluates true if the data area of arr is aligned and in machine byte-order.\n\n"}, {"name": "int PyArray_ISBOOL()", "path": "reference/c-api/array#c.PyArray_ISBOOL", "type": "Array API", "text": "\nType represents Boolean data type.\n\n"}, {"name": "int PyArray_ISBYTESWAPPED()", "path": "reference/c-api/array#c.PyArray_ISBYTESWAPPED", "type": "Array API", "text": "\nEvaluates true if the data area of the ndarray m is not in machine byte-order\naccording to the array\u2019s data-type descriptor.\n\n"}, {"name": "int PyArray_ISCARRAY()", "path": "reference/c-api/array#c.PyArray_ISCARRAY", "type": "Array API", "text": "\nEvaluates true if the data area of arr is C-style contiguous, and\n`PyArray_ISBEHAVED` (arr) is true.\n\n"}, {"name": "int PyArray_ISCARRAY_RO()", "path": "reference/c-api/array#c.PyArray_ISCARRAY_RO", "type": "Array API", "text": "\nEvaluates true if the data area of arr is C-style contiguous, aligned, and in\nmachine byte-order.\n\n"}, {"name": "int PyArray_ISCOMPLEX()", "path": "reference/c-api/array#c.PyArray_ISCOMPLEX", "type": "Array API", "text": "\nType represents any complex floating point number.\n\n"}, {"name": "int PyArray_ISEXTENDED()", "path": "reference/c-api/array#c.PyArray_ISEXTENDED", "type": "Array API", "text": "\nType is either flexible or user-defined.\n\n"}, {"name": "int PyArray_ISFARRAY()", "path": "reference/c-api/array#c.PyArray_ISFARRAY", "type": "Array API", "text": "\nEvaluates true if the data area of arr is Fortran-style contiguous and\n`PyArray_ISBEHAVED` (arr) is true.\n\n"}, {"name": "int PyArray_ISFARRAY_RO()", "path": "reference/c-api/array#c.PyArray_ISFARRAY_RO", "type": "Array API", "text": "\nEvaluates true if the data area of arr is Fortran-style contiguous, aligned,\nand in machine byte-order .\n\n"}, {"name": "int PyArray_ISFLEXIBLE()", "path": "reference/c-api/array#c.PyArray_ISFLEXIBLE", "type": "Array API", "text": "\nType represents one of the flexible array types ( `NPY_STRING`, `NPY_UNICODE`,\nor `NPY_VOID` ).\n\n"}, {"name": "int PyArray_ISFLOAT()", "path": "reference/c-api/array#c.PyArray_ISFLOAT", "type": "Array API", "text": "\nType represents any floating point number.\n\n"}, {"name": "int PyArray_ISFORTRAN()", "path": "reference/c-api/array#c.PyArray_ISFORTRAN", "type": "Array API", "text": "\nEvaluates true if arr is Fortran-style contiguous and not C-style contiguous.\n`PyArray_IS_F_CONTIGUOUS` is the correct way to test for Fortran-style\ncontiguity.\n\n"}, {"name": "int PyArray_ISINTEGER()", "path": "reference/c-api/array#c.PyArray_ISINTEGER", "type": "Array API", "text": "\nType represents any integer.\n\n"}, {"name": "int PyArray_ISNOTSWAPPED()", "path": "reference/c-api/array#c.PyArray_ISNOTSWAPPED", "type": "Array API", "text": "\nEvaluates true if the data area of the ndarray m is in machine byte-order\naccording to the array\u2019s data-type descriptor.\n\n"}, {"name": "int PyArray_ISNUMBER()", "path": "reference/c-api/array#c.PyArray_ISNUMBER", "type": "Array API", "text": "\nType represents any integer, floating point, or complex floating point number.\n\n"}, {"name": "int PyArray_ISOBJECT()", "path": "reference/c-api/array#c.PyArray_ISOBJECT", "type": "Array API", "text": "\nType represents object data type.\n\n"}, {"name": "int PyArray_ISONESEGMENT()", "path": "reference/c-api/array#c.PyArray_ISONESEGMENT", "type": "Array API", "text": "\nEvaluates true if the data area of arr consists of a single (C-style or\nFortran-style) contiguous segment.\n\n"}, {"name": "int PyArray_ISPYTHON()", "path": "reference/c-api/array#c.PyArray_ISPYTHON", "type": "Array API", "text": "\nType represents an enumerated type corresponding to one of the standard Python\nscalar (bool, int, float, or complex).\n\n"}, {"name": "int PyArray_IsPythonNumber()", "path": "reference/c-api/array#c.PyArray_IsPythonNumber", "type": "Array API", "text": "\nEvaluates true if op is an instance of a builtin numeric type (int, float,\ncomplex, long, bool)\n\n"}, {"name": "int PyArray_IsPythonScalar()", "path": "reference/c-api/array#c.PyArray_IsPythonScalar", "type": "Array API", "text": "\nEvaluates true if op is a builtin Python scalar object (int, float, complex,\nbytes, str, long, bool).\n\n"}, {"name": "int PyArray_ISSIGNED()", "path": "reference/c-api/array#c.PyArray_ISSIGNED", "type": "Array API", "text": "\nType represents a signed integer.\n\n"}, {"name": "int PyArray_ISSTRING()", "path": "reference/c-api/array#c.PyArray_ISSTRING", "type": "Array API", "text": "\nType represents a string data type.\n\n"}, {"name": "int PyArray_ISUNSIGNED()", "path": "reference/c-api/array#c.PyArray_ISUNSIGNED", "type": "Array API", "text": "\nType represents an unsigned integer.\n\n"}, {"name": "int PyArray_ISUSERDEF()", "path": "reference/c-api/array#c.PyArray_ISUSERDEF", "type": "Array API", "text": "\nType represents a user-defined type.\n\n"}, {"name": "int PyArray_ISWRITEABLE()", "path": "reference/c-api/array#c.PyArray_ISWRITEABLE", "type": "Array API", "text": "\nEvaluates true if the data area of arr can be written to\n\n"}, {"name": "int PyArray_IsZeroDim()", "path": "reference/c-api/array#c.PyArray_IsZeroDim", "type": "Array API", "text": "\nEvaluates true if op is an instance of (a subclass of) `PyArray_Type` and has\n0 dimensions.\n\n"}, {"name": "int PyArray_ITER_NOTDONE()", "path": "reference/c-api/array#c.PyArray_ITER_NOTDONE", "type": "Array API", "text": "\nEvaluates TRUE as long as the iterator has not looped through all of the\nelements, otherwise it evaluates FALSE.\n\n"}, {"name": "int PyArray_MoveInto()", "path": "reference/c-api/array#c.PyArray_MoveInto", "type": "Array API", "text": "\nMove data from the source array, `src`, into the destination array, `dest`,\nperforming a data-type conversion if necessary. If an error occurs return -1\n(otherwise 0). The shape of `src` must be broadcastable to the shape of\n`dest`. The data areas of dest and src may overlap.\n\n"}, {"name": "int PyArray_MultiIter_NOTDONE()", "path": "reference/c-api/array#c.PyArray_MultiIter_NOTDONE", "type": "Array API", "text": "\nEvaluates TRUE as long as the multi-iterator has not looped through all of the\nelements (of the broadcasted result), otherwise it evaluates FALSE.\n\n"}, {"name": "int PyArray_MultiplyIntList()", "path": "reference/c-api/array#c.PyArray_MultiplyIntList", "type": "Array API", "text": "\nBoth of these routines multiply an n -length array, seq, of integers and\nreturn the result. No overflow checking is performed.\n\n"}, {"name": "int PyArray_NDIM()", "path": "reference/c-api/array", "type": "Array API", "text": "\nThese macros access the `PyArrayObject` structure members and are defined in\n`ndarraytypes.h`. The input argument, arr, can be any PyObject* that is\ndirectly interpretable as a PyArrayObject* (any instance of the `PyArray_Type`\nand its sub-types).\n\n"}, {"name": "int PyArray_ObjectType()", "path": "reference/c-api/array#c.PyArray_ObjectType", "type": "Array API", "text": "\nThis function is superseded by `PyArray_MinScalarType` and/or\n`PyArray_ResultType`.\n\n"}, {"name": "int PyArray_OrderConverter()", "path": "reference/c-api/array#c.PyArray_OrderConverter", "type": "Array API", "text": "\nConvert the Python strings \u2018C\u2019, \u2018F\u2019, \u2018A\u2019, and \u2018K\u2019 into the `NPY_ORDER`\nenumeration `NPY_CORDER`, `NPY_FORTRANORDER`, `NPY_ANYORDER`, and\n`NPY_KEEPORDER`.\n\n"}, {"name": "int PyArray_OutputConverter()", "path": "reference/c-api/array#c.PyArray_OutputConverter", "type": "Array API", "text": "\nThis is a default converter for output arrays given to functions. If obj is\n`Py_None` or `NULL`, then *address will be `NULL` but the call will succeed.\nIf `PyArray_Check` ( obj) is TRUE then it is returned in *address without\nincrementing its reference count.\n\n"}, {"name": "int PyArray_Partition()", "path": "reference/c-api/array#c.PyArray_Partition", "type": "Array API", "text": "\nEquivalent to `ndarray.partition` (self, ktharray, axis, kind). Partitions the\narray so that the values of the element indexed by ktharray are in the\npositions they would be if the array is fully sorted and places all elements\nsmaller than the kth before and all elements equal or greater after the kth\nelement. The ordering of all elements within the partitions is undefined. If\nself->descr is a data-type with fields defined, then self->descr->names is\nused to determine the sort order. A comparison where the first field is equal\nwill use the second field and so on. To alter the sort order of a structured\narray, create a new data-type with a different order of names and construct a\nview of the array with that new data-type. Returns zero on success and -1 on\nfailure.\n\n"}, {"name": "int PyArray_RegisterCanCast()", "path": "reference/c-api/array#c.PyArray_RegisterCanCast", "type": "Array API", "text": "\nRegister the data-type number, totype, as castable from data-type object,\ndescr, of the given scalar kind. Use scalar = `NPY_NOSCALAR` to register that\nan array of data-type descr can be cast safely to a data-type whose\ntype_number is totype. The return value is 0 on success or -1 on failure.\n\n"}, {"name": "int PyArray_RegisterCastFunc()", "path": "reference/c-api/array#c.PyArray_RegisterCastFunc", "type": "Array API", "text": "\nRegister a low-level casting function, castfunc, to convert from the data-\ntype, descr, to the given data-type number, totype. Any old casting function\nis over-written. A `0` is returned on success or a `-1` on failure.\n\n"}, {"name": "int PyArray_RegisterDataType()", "path": "reference/c-api/array#c.PyArray_RegisterDataType", "type": "Array API", "text": "\nRegister a data-type as a new user-defined data type for arrays. The type must\nhave most of its entries filled in. This is not always checked and errors can\nproduce segfaults. In particular, the typeobj member of the `dtype` structure\nmust be filled with a Python type that has a fixed-size element-size that\ncorresponds to the elsize member of dtype. Also the `f` member must have the\nrequired functions: nonzero, copyswap, copyswapn, getitem, setitem, and cast\n(some of the cast functions may be `NULL` if no support is desired). To avoid\nconfusion, you should choose a unique character typecode but this is not\nenforced and not relied on internally.\n\n"}, {"name": "int PyArray_RemoveSmallest()", "path": "reference/c-api/array#c.PyArray_RemoveSmallest", "type": "Array API", "text": "\nThis function takes a multi-iterator object that has been previously\n\u201cbroadcasted,\u201d finds the dimension with the smallest \u201csum of strides\u201d in the\nbroadcasted result and adapts all the iterators so as not to iterate over that\ndimension (by effectively making them of length-1 in that dimension). The\ncorresponding dimension is returned unless mit ->nd is 0, then -1 is returned.\nThis function is useful for constructing ufunc-like routines that broadcast\ntheir inputs correctly and then call a strided 1-d version of the routine as\nthe inner-loop. This 1-d version is usually optimized for speed and for this\nreason the loop should be performed over the axis that won\u2019t require large\nstride jumps.\n\n"}, {"name": "int PyArray_ResolveWritebackIfCopy()", "path": "reference/c-api/array#c.PyArray_ResolveWritebackIfCopy", "type": "Array API", "text": "\nIf `obj.flags` has `NPY_ARRAY_WRITEBACKIFCOPY` or (deprecated)\n`NPY_ARRAY_UPDATEIFCOPY`, this function clears the flags, `DECREF` s\n`obj->base` and makes it writeable, and sets `obj->base` to NULL. It then\ncopies `obj->data` to `obj->base->data`, and returns the error state of the\ncopy operation. This is the opposite of `PyArray_SetWritebackIfCopyBase`.\nUsually this is called once you are finished with `obj`, just before\n`Py_DECREF(obj)`. It may be called multiple times, or with `NULL` input. See\nalso `PyArray_DiscardWritebackIfCopy`.\n\n"}, {"name": "int PyArray_SearchsideConverter()", "path": "reference/c-api/array#c.PyArray_SearchsideConverter", "type": "Array API", "text": "\nConvert Python strings into one of `NPY_SEARCHLEFT` (starts with \u2018l\u2019 or \u2018L\u2019),\nor `NPY_SEARCHRIGHT` (starts with \u2018r\u2019 or \u2018R\u2019).\n\n"}, {"name": "int PyArray_SetBaseObject()", "path": "reference/c-api/array#c.PyArray_SetBaseObject", "type": "Array API", "text": "\nNew in version 1.7.\n\n"}, {"name": "int PyArray_SetField()", "path": "reference/c-api/array#c.PyArray_SetField", "type": "Array API", "text": "\nEquivalent to `ndarray.setfield` (self, val, dtype, offset ). Set the field\nstarting at offset in bytes and of the given dtype to val. The offset plus\ndtype ->elsize must be less than self ->descr->elsize or an error is raised.\nOtherwise, the val argument is converted to an array and copied into the field\npointed to. If necessary, the elements of val are repeated to fill the\ndestination array, But, the number of elements in the destination must be an\ninteger multiple of the number of elements in val.\n\n"}, {"name": "int PyArray_SETITEM()", "path": "reference/c-api/array#c.PyArray_SETITEM", "type": "Array API", "text": "\nConvert obj and place it in the ndarray, arr, at the place pointed to by\nitemptr. Return -1 if an error occurs or 0 on success.\n\n"}, {"name": "int PyArray_SetUpdateIfCopyBase()", "path": "reference/c-api/array#c.PyArray_SetUpdateIfCopyBase", "type": "Array API", "text": "\nPrecondition: `arr` is a copy of `base` (though possibly with different\nstrides, ordering, etc.) Set the UPDATEIFCOPY flag and `arr->base` so that\nwhen `arr` is destructed, it will copy any changes back to `base`. DEPRECATED,\nuse `PyArray_SetWritebackIfCopyBase`.\n\n"}, {"name": "int PyArray_SetWritebackIfCopyBase()", "path": "reference/c-api/array#c.PyArray_SetWritebackIfCopyBase", "type": "Array API", "text": "\nPrecondition: `arr` is a copy of `base` (though possibly with different\nstrides, ordering, etc.) Sets the `NPY_ARRAY_WRITEBACKIFCOPY` flag and\n`arr->base`, and set `base` to READONLY. Call `PyArray_ResolveWritebackIfCopy`\nbefore calling `Py_DECREF` in order copy any changes back to `base` and reset\nthe READONLY flag.\n\n"}, {"name": "int PyArray_SortkindConverter()", "path": "reference/c-api/array#c.PyArray_SortkindConverter", "type": "Array API", "text": "\nConvert Python strings into one of `NPY_QUICKSORT` (starts with \u2018q\u2019 or \u2018Q\u2019),\n`NPY_HEAPSORT` (starts with \u2018h\u2019 or \u2018H\u2019), `NPY_MERGESORT` (starts with \u2018m\u2019 or\n\u2018M\u2019) or `NPY_STABLESORT` (starts with \u2018t\u2019 or \u2018T\u2019). `NPY_MERGESORT` and\n`NPY_STABLESORT` are aliased to each other for backwards compatibility and may\nrefer to one of several stable sorting algorithms depending on the data type.\n\n"}, {"name": "int PyArray_TYPE()", "path": "reference/c-api/array#c.PyArray_TYPE", "type": "Array API", "text": "\nReturn the (builtin) typenumber for the elements of this array.\n\n"}, {"name": "int PyArray_TypeNumFromName()", "path": "reference/c-api/array#c.PyArray_TypeNumFromName", "type": "Array API", "text": "\nGiven a string return the type-number for the data-type with that string as\nthe type-object name. Returns `NPY_NOTYPE` without setting an error if no type\ncan be found. Only works for user-defined data-types.\n\n"}, {"name": "int PyArray_TypestrConvert()", "path": "reference/c-api/array#c.PyArray_TypestrConvert", "type": "Array API", "text": "\nConvert typestring characters (with itemsize) to basic enumerated data types.\nThe typestring character corresponding to signed and unsigned integers,\nfloating point numbers, and complex-floating point numbers are recognized and\nconverted. Other values of gentype are returned. This function can be used to\nconvert, for example, the string \u2018f4\u2019 to `NPY_FLOAT32`.\n\n"}, {"name": "int PyArray_ValidType()", "path": "reference/c-api/array#c.PyArray_ValidType", "type": "Array API", "text": "\nReturns `NPY_TRUE` if typenum represents a valid type-number (builtin or user-\ndefined or character code). Otherwise, this function returns `NPY_FALSE`.\n\n"}, {"name": "int PyArray_XDECREF()", "path": "reference/c-api/array#c.PyArray_XDECREF", "type": "Array API", "text": "\nUsed for an array, op, that contains any Python objects. It decrements the\nreference count of every object in the array according to the data-type of op.\nNormal return value is 0. A -1 is returned if an error occurs.\n\n"}, {"name": "int PyArrayIter_Check()", "path": "reference/c-api/array#c.PyArrayIter_Check", "type": "Array API", "text": "\nEvaluates true if op is an array iterator (or instance of a subclass of the\narray iterator type).\n\n"}, {"name": "int PyArrayNeighborhoodIter_Next()", "path": "reference/c-api/array#c.PyArrayNeighborhoodIter_Next", "type": "Array API", "text": "\nAfter this call, iter->dataptr points to the next point of the neighborhood.\nCalling this function after every point of the neighborhood has been visited\nis undefined.\n\n"}, {"name": "int PyArrayNeighborhoodIter_Reset()", "path": "reference/c-api/array#c.PyArrayNeighborhoodIter_Reset", "type": "Array API", "text": "\nReset the iterator position to the first point of the neighborhood. This\nshould be called whenever the iter argument given at\nPyArray_NeighborhoodIterObject is changed (see example)\n\n"}, {"name": "int PyDataType_FLAGCHK()", "path": "reference/c-api/types-and-structures#c.NPY_USE_SETITEM.PyDataType_FLAGCHK", "type": "Python Types and C-Structures", "text": "\nReturn true if all the given flags are set for the data-type object.\n\n"}, {"name": "int PyDataType_HASFIELDS()", "path": "reference/c-api/array#c.PyDataType_HASFIELDS", "type": "Array API", "text": "\n\n"}, {"name": "int PyDataType_ISBOOL()", "path": "reference/c-api/array#c.PyDataType_ISBOOL", "type": "Array API", "text": "\n\n"}, {"name": "int PyDataType_ISCOMPLEX()", "path": "reference/c-api/array#c.PyDataType_ISCOMPLEX", "type": "Array API", "text": "\n\n"}, {"name": "int PyDataType_ISEXTENDED()", "path": "reference/c-api/array#c.PyDataType_ISEXTENDED", "type": "Array API", "text": "\n\n"}, {"name": "int PyDataType_ISFLEXIBLE()", "path": "reference/c-api/array#c.PyDataType_ISFLEXIBLE", "type": "Array API", "text": "\n\n"}, {"name": "int PyDataType_ISFLOAT()", "path": "reference/c-api/array#c.PyDataType_ISFLOAT", "type": "Array API", "text": "\n\n"}, {"name": "int PyDataType_ISINTEGER()", "path": "reference/c-api/array#c.PyDataType_ISINTEGER", "type": "Array API", "text": "\n\n"}, {"name": "int PyDataType_ISNUMBER()", "path": "reference/c-api/array#c.PyDataType_ISNUMBER", "type": "Array API", "text": "\n\n"}, {"name": "int PyDataType_ISOBJECT()", "path": "reference/c-api/array#c.PyDataType_ISOBJECT", "type": "Array API", "text": "\n\n"}, {"name": "int PyDataType_ISPYTHON()", "path": "reference/c-api/array#c.PyDataType_ISPYTHON", "type": "Array API", "text": "\n\n"}, {"name": "int PyDataType_ISSIGNED()", "path": "reference/c-api/array#c.PyDataType_ISSIGNED", "type": "Array API", "text": "\n\n"}, {"name": "int PyDataType_ISSTRING()", "path": "reference/c-api/array#c.PyDataType_ISSTRING", "type": "Array API", "text": "\n\n"}, {"name": "int PyDataType_ISUNSIGNED()", "path": "reference/c-api/array#c.PyDataType_ISUNSIGNED", "type": "Array API", "text": "\n\n"}, {"name": "int PyDataType_ISUNSIZED()", "path": "reference/c-api/array#c.PyDataType_ISUNSIZED", "type": "Array API", "text": "\nType has no size information attached, and can be resized. Should only be\ncalled on flexible dtypes. Types that are attached to an array will always be\nsized, hence the array form of this macro not existing.\n\n"}, {"name": "int PyDataType_ISUSERDEF()", "path": "reference/c-api/array#c.PyDataType_ISUSERDEF", "type": "Array API", "text": "\n\n"}, {"name": "int PyDataType_REFCHK()", "path": "reference/c-api/types-and-structures#c.NPY_USE_SETITEM.PyDataType_REFCHK", "type": "Python Types and C-Structures", "text": "\nEquivalent to `PyDataType_FLAGCHK` (dtype, `NPY_ITEM_REFCOUNT`).\n\n"}, {"name": "int PyModule_AddIntConstant()", "path": "user/c-info.how-to-extend#c.PyModule_AddIntConstant", "type": "User Guide", "text": "\n\n"}, {"name": "int PyModule_AddObject()", "path": "user/c-info.how-to-extend", "type": "User Guide", "text": "\nWhile the ndarray object is designed to allow rapid computation in Python, it\nis also designed to be general-purpose and satisfy a wide- variety of\ncomputational needs. As a result, if absolute speed is essential, there is no\nreplacement for a well-crafted, compiled loop specific to your application and\nhardware. This is one of the reasons that numpy includes f2py so that an easy-\nto-use mechanisms for linking (simple) C/C++ and (arbitrary) Fortran code\ndirectly into Python are available. You are encouraged to use and improve this\nmechanism. The purpose of this section is not to document this tool but to\ndocument the more basic steps to writing an extension module that this tool\ndepends on.\n\n"}, {"name": "int PyModule_AddStringConstant()", "path": "user/c-info.how-to-extend#c.PyModule_AddStringConstant", "type": "User Guide", "text": "\nAll three of these functions require the module object (the return value of\nPy_InitModule). The name is a string that labels the value in the module.\nDepending on which function is called, the value argument is either a general\nobject (`PyModule_AddObject` steals a reference to it), an integer constant,\nor a string constant.\n\n"}, {"name": "int PyTypeNum_ISBOOL()", "path": "reference/c-api/array#c.PyTypeNum_ISBOOL", "type": "Array API", "text": "\n\n"}, {"name": "int PyTypeNum_ISCOMPLEX()", "path": "reference/c-api/array#c.PyTypeNum_ISCOMPLEX", "type": "Array API", "text": "\n\n"}, {"name": "int PyTypeNum_ISEXTENDED()", "path": "reference/c-api/array#c.PyTypeNum_ISEXTENDED", "type": "Array API", "text": "\n\n"}, {"name": "int PyTypeNum_ISFLEXIBLE()", "path": "reference/c-api/array#c.PyTypeNum_ISFLEXIBLE", "type": "Array API", "text": "\n\n"}, {"name": "int PyTypeNum_ISFLOAT()", "path": "reference/c-api/array#c.PyTypeNum_ISFLOAT", "type": "Array API", "text": "\n\n"}, {"name": "int PyTypeNum_ISINTEGER()", "path": "reference/c-api/array#c.PyTypeNum_ISINTEGER", "type": "Array API", "text": "\n\n"}, {"name": "int PyTypeNum_ISNUMBER()", "path": "reference/c-api/array#c.PyTypeNum_ISNUMBER", "type": "Array API", "text": "\n\n"}, {"name": "int PyTypeNum_ISOBJECT()", "path": "reference/c-api/array#c.PyTypeNum_ISOBJECT", "type": "Array API", "text": "\n\n"}, {"name": "int PyTypeNum_ISPYTHON()", "path": "reference/c-api/array#c.PyTypeNum_ISPYTHON", "type": "Array API", "text": "\n\n"}, {"name": "int PyTypeNum_ISSIGNED()", "path": "reference/c-api/array#c.PyTypeNum_ISSIGNED", "type": "Array API", "text": "\n\n"}, {"name": "int PyTypeNum_ISSTRING()", "path": "reference/c-api/array#c.PyTypeNum_ISSTRING", "type": "Array API", "text": "\n\n"}, {"name": "int PyTypeNum_ISUSERDEF()", "path": "reference/c-api/array#c.PyTypeNum_ISUSERDEF", "type": "Array API", "text": "\n\n"}, {"name": "int PyUFunc_checkfperr()", "path": "reference/c-api/ufunc#c.PyUFunc_checkfperr", "type": "UFunc API", "text": "\nA simple interface to the IEEE error-flag checking support. The errmask\nargument is a mask of `UFUNC_MASK_{ERR}` bitmasks indicating which errors to\ncheck for (and how to check for them). The errobj must be a Python tuple with\ntwo elements: a string containing the name which will be used in any\ncommunication of error and either a callable Python object (call-back\nfunction) or `Py_None`. The callable object will only be used if\n`UFUNC_ERR_CALL` is set as the desired error checking method. This routine\nmanages the GIL and is safe to call even after releasing the GIL. If an error\nin the IEEE-compatible hardware is determined a -1 is returned, otherwise a 0\nis returned.\n\n"}, {"name": "int PyUFunc_RegisterLoopForDescr()", "path": "reference/c-api/ufunc#c.PyUFunc_RegisterLoopForDescr", "type": "UFunc API", "text": "\nThis function behaves like PyUFunc_RegisterLoopForType above, except that it\nallows the user to register a 1-d loop using PyArray_Descr objects instead of\ndtype type num values. This allows a 1-d loop to be registered for structured\narray data-dtypes and custom data-types instead of scalar data-types.\n\n"}, {"name": "int PyUFunc_RegisterLoopForType()", "path": "reference/c-api/ufunc#c.PyUFunc_RegisterLoopForType", "type": "UFunc API", "text": "\nThis function allows the user to register a 1-d loop with an already- created\nufunc to be used whenever the ufunc is called with any of its input arguments\nas the user-defined data-type. This is needed in order to make ufuncs work\nwith built-in data-types. The data-type must have been previously registered\nwith the numpy system. The loop is passed in as function. This loop can take\narbitrary data which should be passed in as data. The data-types the loop\nrequires are passed in as arg_types which must be a pointer to memory at least\nas large as ufunc->nargs.\n\n"}, {"name": "int PyUFunc_ReplaceLoopBySignature()", "path": "reference/c-api/ufunc#c.PyUFunc_ReplaceLoopBySignature", "type": "UFunc API", "text": "\nReplace a 1-d loop matching the given signature in the already-created ufunc\nwith the new 1-d loop newfunc. Return the old 1-d loop function in oldfunc.\nReturn 0 on success and -1 on failure. This function works only with built-in\ntypes (use `PyUFunc_RegisterLoopForType` for user-defined types). A signature\nis an array of data-type numbers indicating the inputs followed by the outputs\nassumed by the 1-d loop.\n\n"}, {"name": "int random_multivariate_hypergeometric_count()", "path": "reference/random/c-api#c.random_multivariate_hypergeometric_count", "type": "C API for random", "text": "\n\n"}, {"name": "int reserved1", "path": "reference/c-api/types-and-structures#c.PyUFuncObject.reserved1", "type": "Python Types and C-Structures", "text": "\nUnused.\n\n"}, {"name": "int scanfunc()", "path": "reference/c-api/types-and-structures#c.PyArray_ArrFuncs.scanfunc", "type": "Python Types and C-Structures", "text": "\nA pointer to a function that scans (scanf style) one element of the\ncorresponding type from the file descriptor `fd` into the array memory pointed\nto by `ip`. The array is assumed to be behaved. The last argument `arr` is the\narray to be scanned into. Returns number of receiving arguments successfully\nassigned (which may be zero in case a matching failure occurred before the\nfirst receiving argument was assigned), or EOF if input failure occurs before\nthe first receiving argument was assigned. This function should be called\nwithout holding the Python GIL, and has to grab it for error reporting.\n\n"}, {"name": "int setitem()", "path": "reference/c-api/types-and-structures#c.PyArray_ArrFuncs.setitem", "type": "Python Types and C-Structures", "text": "\nA pointer to a function that sets the Python object item into the array, arr,\nat the position pointed to by data . This function deals with \u201cmisbehaved\u201d\narrays. If successful, a zero is returned, otherwise, a negative one is\nreturned (and a Python error set).\n\n"}, {"name": "int sort()", "path": "reference/c-api/types-and-structures#c.PyArray_ArrFuncs.sort", "type": "Python Types and C-Structures", "text": "\nAn array of function pointers to a particular sorting algorithms. A particular\nsorting algorithm is obtained using a key (so far `NPY_QUICKSORT`,\n`NPY_HEAPSORT`, and `NPY_MERGESORT` are defined). These sorts are done in-\nplace assuming contiguous and aligned data.\n\n"}, {"name": "Internal organization of NumPy arrays", "path": "dev/internals", "type": "Development", "text": "\nIt helps to understand a bit about how NumPy arrays are handled under the\ncovers to help understand NumPy better. This section will not go into great\ndetail. Those wishing to understand the full details are requested to refer to\nTravis Oliphant\u2019s book Guide to NumPy.\n\n"}, {"name": "Is the intended behavior clear under all conditions? Some things to watch:", "path": "dev/reviewer_guidelines", "type": "Development", "text": "\nReviewing open pull requests (PRs) helps move the project forward. We\nencourage people outside the project to get involved as well; it\u2019s a great way\nto get familiar with the codebase.\n\n"}, {"name": "is_array()", "path": "reference/swig.interface-file", "type": "numpy.i: a SWIG Interface File for NumPy", "text": "\nThe Simple Wrapper and Interface Generator (or SWIG) is a powerful tool for\ngenerating wrapper code for interfacing to a wide variety of scripting\nlanguages. SWIG can parse header files, and using only the code prototypes,\ncreate an interface to the target language. But SWIG is not omnipotent. For\nexample, it cannot know from the prototype:\n\n"}, {"name": "Iterating Over Arrays", "path": "reference/arrays.nditer", "type": "Iterating Over Arrays", "text": "\nNote\n\n"}, {"name": "Laguerre Series (numpy.polynomial.laguerre)", "path": "reference/routines.polynomials.laguerre", "type": "Laguerre Series ( \n        \n         numpy.polynomial.laguerre\n        \n        )", "text": "\nThis module provides a number of objects (mostly functions) useful for dealing\nwith Laguerre series, including a `Laguerre` class that encapsulates the usual\narithmetic operations. (General information on how this module represents and\nworks with such polynomials is in the docstring for its \u201cparent\u201d sub-package,\n`numpy.polynomial`).\n\n"}, {"name": "Legendre Series (numpy.polynomial.legendre)", "path": "reference/routines.polynomials.legendre", "type": "Legendre Series ( \n        \n         numpy.polynomial.legendre\n        \n        )", "text": "\nThis module provides a number of objects (mostly functions) useful for dealing\nwith Legendre series, including a `Legendre` class that encapsulates the usual\narithmetic operations. (General information on how this module represents and\nworks with such polynomials is in the docstring for its \u201cparent\u201d sub-package,\n`numpy.polynomial`).\n\n"}, {"name": "lib.format.descr_to_dtype()", "path": "reference/generated/numpy.lib.format.descr_to_dtype", "type": "numpy.lib.format.descr_to_dtype", "text": "\nReturns a dtype based off the given description.\n\n"}, {"name": "lib.format.dtype_to_descr()", "path": "reference/generated/numpy.lib.format.dtype_to_descr", "type": "numpy.lib.format.dtype_to_descr", "text": "\nGet a serializable descriptor from the dtype.\n\n"}, {"name": "lib.format.header_data_from_array_1_0()", "path": "reference/generated/numpy.lib.format.header_data_from_array_1_0", "type": "numpy.lib.format.header_data_from_array_1_0", "text": "\nGet the dictionary of header metadata from a numpy.ndarray.\n\n"}, {"name": "lib.format.magic()", "path": "reference/generated/numpy.lib.format.magic", "type": "numpy.lib.format.magic", "text": "\nReturn the magic string for the given file format version.\n\n"}, {"name": "lib.format.open_memmap()", "path": "reference/generated/numpy.lib.format.open_memmap", "type": "numpy.lib.format.open_memmap", "text": "\nOpen a .npy file as a memory-mapped array.\n\n"}, {"name": "lib.format.read_array()", "path": "reference/generated/numpy.lib.format.read_array", "type": "numpy.lib.format.read_array", "text": "\nRead an array from an NPY file.\n\n"}, {"name": "lib.format.read_array_header_1_0()", "path": "reference/generated/numpy.lib.format.read_array_header_1_0", "type": "numpy.lib.format.read_array_header_1_0", "text": "\nRead an array header from a filelike object using the 1.0 file format version.\n\n"}, {"name": "lib.format.read_array_header_2_0()", "path": "reference/generated/numpy.lib.format.read_array_header_2_0", "type": "numpy.lib.format.read_array_header_2_0", "text": "\nRead an array header from a filelike object using the 2.0 file format version.\n\n"}, {"name": "lib.format.read_magic()", "path": "reference/generated/numpy.lib.format.read_magic", "type": "numpy.lib.format.read_magic", "text": "\nRead the magic string to get the version of the file format.\n\n"}, {"name": "lib.format.write_array()", "path": "reference/generated/numpy.lib.format.write_array", "type": "numpy.lib.format.write_array", "text": "\nWrite an array to an NPY file, including a header.\n\n"}, {"name": "lib.format.write_array_header_1_0()", "path": "reference/generated/numpy.lib.format.write_array_header_1_0", "type": "numpy.lib.format.write_array_header_1_0", "text": "\nWrite the header for an array using the 1.0 format.\n\n"}, {"name": "lib.format.write_array_header_2_0()", "path": "reference/generated/numpy.lib.format.write_array_header_2_0", "type": "numpy.lib.format.write_array_header_2_0", "text": "\nThe 2.0 format allows storing very large structured arrays.\n\n"}, {"name": "lib.scimath.arccos()", "path": "reference/generated/numpy.lib.scimath.arccos", "type": "numpy.lib.scimath.arccos", "text": "\nCompute the inverse cosine of x.\n\n"}, {"name": "lib.scimath.arcsin()", "path": "reference/generated/numpy.lib.scimath.arcsin", "type": "numpy.lib.scimath.arcsin", "text": "\nCompute the inverse sine of x.\n\n"}, {"name": "lib.scimath.arctanh()", "path": "reference/generated/numpy.lib.scimath.arctanh", "type": "numpy.lib.scimath.arctanh", "text": "\nCompute the inverse hyperbolic tangent of `x`.\n\n"}, {"name": "lib.scimath.log()", "path": "reference/generated/numpy.lib.scimath.log", "type": "numpy.lib.scimath.log", "text": "\nCompute the natural logarithm of `x`.\n\n"}, {"name": "lib.scimath.log10()", "path": "reference/generated/numpy.lib.scimath.log10", "type": "numpy.lib.scimath.log10", "text": "\nCompute the logarithm base 10 of `x`.\n\n"}, {"name": "lib.scimath.log2()", "path": "reference/generated/numpy.lib.scimath.log2", "type": "numpy.lib.scimath.log2", "text": "\nCompute the logarithm base 2 of `x`.\n\n"}, {"name": "lib.scimath.logn()", "path": "reference/generated/numpy.lib.scimath.logn", "type": "numpy.lib.scimath.logn", "text": "\nTake log base n of x.\n\n"}, {"name": "lib.scimath.power()", "path": "reference/generated/numpy.lib.scimath.power", "type": "numpy.lib.scimath.power", "text": "\nReturn x to the power p, (x**p).\n\n"}, {"name": "lib.scimath.sqrt()", "path": "reference/generated/numpy.lib.scimath.sqrt", "type": "numpy.lib.scimath.sqrt", "text": "\nCompute the square root of x.\n\n"}, {"name": "lib.stride_tricks.as_strided()", "path": "reference/generated/numpy.lib.stride_tricks.as_strided", "type": "numpy.lib.stride_tricks.as_strided", "text": "\nCreate a view into the array with the given shape and strides.\n\n"}, {"name": "lib.stride_tricks.sliding_window_view()", "path": "reference/generated/numpy.lib.stride_tricks.sliding_window_view", "type": "numpy.lib.stride_tricks.sliding_window_view", "text": "\nCreate a sliding window view into the array with the given window shape.\n\n"}, {"name": "linalg.cholesky()", "path": "reference/generated/numpy.linalg.cholesky", "type": "numpy.linalg.cholesky", "text": "\nCholesky decomposition.\n\n"}, {"name": "linalg.cond()", "path": "reference/generated/numpy.linalg.cond", "type": "numpy.linalg.cond", "text": "\nCompute the condition number of a matrix.\n\n"}, {"name": "linalg.det()", "path": "reference/generated/numpy.linalg.det", "type": "numpy.linalg.det", "text": "\nCompute the determinant of an array.\n\n"}, {"name": "linalg.eig()", "path": "reference/generated/numpy.linalg.eig", "type": "numpy.linalg.eig", "text": "\nCompute the eigenvalues and right eigenvectors of a square array.\n\n"}, {"name": "linalg.eigh()", "path": "reference/generated/numpy.linalg.eigh", "type": "numpy.linalg.eigh", "text": "\nReturn the eigenvalues and eigenvectors of a complex Hermitian (conjugate\nsymmetric) or a real symmetric matrix.\n\n"}, {"name": "linalg.eigvals()", "path": "reference/generated/numpy.linalg.eigvals", "type": "numpy.linalg.eigvals", "text": "\nCompute the eigenvalues of a general matrix.\n\n"}, {"name": "linalg.eigvalsh()", "path": "reference/generated/numpy.linalg.eigvalsh", "type": "numpy.linalg.eigvalsh", "text": "\nCompute the eigenvalues of a complex Hermitian or real symmetric matrix.\n\n"}, {"name": "linalg.inv()", "path": "reference/generated/numpy.linalg.inv", "type": "numpy.linalg.inv", "text": "\nCompute the (multiplicative) inverse of a matrix.\n\n"}, {"name": "linalg.LinAlgError", "path": "reference/generated/numpy.linalg.linalgerror", "type": "numpy.linalg.LinAlgError", "text": "\nGeneric Python-exception-derived object raised by linalg functions.\n\n"}, {"name": "linalg.lstsq()", "path": "reference/generated/numpy.linalg.lstsq", "type": "numpy.linalg.lstsq", "text": "\nReturn the least-squares solution to a linear matrix equation.\n\n"}, {"name": "linalg.matrix_power()", "path": "reference/generated/numpy.linalg.matrix_power", "type": "numpy.linalg.matrix_power", "text": "\nRaise a square matrix to the (integer) power `n`.\n\n"}, {"name": "linalg.matrix_rank()", "path": "reference/generated/numpy.linalg.matrix_rank", "type": "numpy.linalg.matrix_rank", "text": "\nReturn matrix rank of array using SVD method\n\n"}, {"name": "linalg.multi_dot()", "path": "reference/generated/numpy.linalg.multi_dot", "type": "numpy.linalg.multi_dot", "text": "\nCompute the dot product of two or more arrays in a single function call, while\nautomatically selecting the fastest evaluation order.\n\n"}, {"name": "linalg.norm()", "path": "reference/generated/numpy.linalg.norm", "type": "numpy.linalg.norm", "text": "\nMatrix or vector norm.\n\n"}, {"name": "linalg.pinv()", "path": "reference/generated/numpy.linalg.pinv", "type": "numpy.linalg.pinv", "text": "\nCompute the (Moore-Penrose) pseudo-inverse of a matrix.\n\n"}, {"name": "linalg.qr()", "path": "reference/generated/numpy.linalg.qr", "type": "numpy.linalg.qr", "text": "\nCompute the qr factorization of a matrix.\n\n"}, {"name": "linalg.slogdet()", "path": "reference/generated/numpy.linalg.slogdet", "type": "numpy.linalg.slogdet", "text": "\nCompute the sign and (natural) logarithm of the determinant of an array.\n\n"}, {"name": "linalg.solve()", "path": "reference/generated/numpy.linalg.solve", "type": "numpy.linalg.solve", "text": "\nSolve a linear matrix equation, or system of linear scalar equations.\n\n"}, {"name": "linalg.svd()", "path": "reference/generated/numpy.linalg.svd", "type": "numpy.linalg.svd", "text": "\nSingular Value Decomposition.\n\n"}, {"name": "linalg.tensorinv()", "path": "reference/generated/numpy.linalg.tensorinv", "type": "numpy.linalg.tensorinv", "text": "\nCompute the \u2018inverse\u2019 of an N-dimensional array.\n\n"}, {"name": "linalg.tensorsolve()", "path": "reference/generated/numpy.linalg.tensorsolve", "type": "numpy.linalg.tensorsolve", "text": "\nSolve the tensor equation `a x = b` for x.\n\n"}, {"name": "Linear algebra (numpy.linalg)", "path": "reference/routines.linalg", "type": "Linear algebra ( \n      \n       numpy.linalg\n      \n      )", "text": "\nThe NumPy linear algebra functions rely on BLAS and LAPACK to provide\nefficient low level implementations of standard linear algebra algorithms.\nThose libraries may be provided by NumPy itself using C versions of a subset\nof their reference implementations but, when possible, highly optimized\nlibraries that take advantage of specialized processor functionality are\npreferred. Examples of such libraries are OpenBLAS, MKL (TM), and ATLAS.\nBecause those libraries are multithreaded and processor dependent,\nenvironmental variables and external packages such as threadpoolctl may be\nneeded to control the number of threads or specify the processor architecture.\n\n"}, {"name": "Logic functions", "path": "reference/routines.logic", "type": "Logic functions", "text": "\n`all`(a[, axis, out, keepdims, where])\n\n"}, {"name": "ma.all()", "path": "reference/generated/numpy.ma.all", "type": "numpy.ma.all", "text": "\nReturns True if all elements evaluate to True.\n\n"}, {"name": "ma.allclose()", "path": "reference/generated/numpy.ma.allclose", "type": "numpy.ma.allclose", "text": "\nReturns True if two arrays are element-wise equal within a tolerance.\n\n"}, {"name": "ma.allequal()", "path": "reference/generated/numpy.ma.allequal", "type": "numpy.ma.allequal", "text": "\nReturn True if all entries of a and b are equal, using fill_value as a truth\nvalue where either or both are masked.\n\n"}, {"name": "ma.anom()", "path": "reference/generated/numpy.ma.anom", "type": "numpy.ma.anom", "text": "\nCompute the anomalies (deviations from the arithmetic mean) along the given\naxis.\n\n"}, {"name": "ma.anomalies()", "path": "reference/generated/numpy.ma.anomalies", "type": "numpy.ma.anomalies", "text": "\nCompute the anomalies (deviations from the arithmetic mean) along the given\naxis.\n\n"}, {"name": "ma.any()", "path": "reference/generated/numpy.ma.any", "type": "numpy.ma.any", "text": "\nReturns True if any of the elements of `a` evaluate to True.\n\n"}, {"name": "ma.append()", "path": "reference/generated/numpy.ma.append", "type": "numpy.ma.append", "text": "\nAppend values to the end of an array.\n\n"}, {"name": "ma.apply_along_axis()", "path": "reference/generated/numpy.ma.apply_along_axis", "type": "numpy.ma.apply_along_axis", "text": "\nApply a function to 1-D slices along the given axis.\n\n"}, {"name": "ma.apply_over_axes()", "path": "reference/generated/numpy.ma.apply_over_axes", "type": "numpy.ma.apply_over_axes", "text": "\nApply a function repeatedly over multiple axes.\n\n"}, {"name": "ma.arange()", "path": "reference/generated/numpy.ma.arange", "type": "numpy.ma.arange", "text": "\nReturn evenly spaced values within a given interval.\n\n"}, {"name": "ma.argmax()", "path": "reference/generated/numpy.ma.argmax", "type": "numpy.ma.argmax", "text": "\nReturns array of indices of the maximum values along the given axis. Masked\nvalues are treated as if they had the value fill_value.\n\n"}, {"name": "ma.argmin()", "path": "reference/generated/numpy.ma.argmin", "type": "numpy.ma.argmin", "text": "\nReturn array of indices to the minimum values along the given axis.\n\n"}, {"name": "ma.argsort()", "path": "reference/generated/numpy.ma.argsort", "type": "numpy.ma.argsort", "text": "\nReturn an ndarray of indices that sort the array along the specified axis.\nMasked values are filled beforehand to `fill_value`.\n\n"}, {"name": "ma.around", "path": "reference/generated/numpy.ma.around", "type": "numpy.ma.around", "text": "\nRound an array to the given number of decimals.\n\n"}, {"name": "ma.array()", "path": "reference/generated/numpy.ma.array", "type": "numpy.ma.array", "text": "\nAn array class with possibly masked values.\n\n"}, {"name": "ma.asanyarray()", "path": "reference/generated/numpy.ma.asanyarray", "type": "numpy.ma.asanyarray", "text": "\nConvert the input to a masked array, conserving subclasses.\n\n"}, {"name": "ma.asarray()", "path": "reference/generated/numpy.ma.asarray", "type": "numpy.ma.asarray", "text": "\nConvert the input to a masked array of the given data-type.\n\n"}, {"name": "ma.atleast_1d()", "path": "reference/generated/numpy.ma.atleast_1d", "type": "numpy.ma.atleast_1d", "text": "\nConvert inputs to arrays with at least one dimension.\n\n"}, {"name": "ma.atleast_2d()", "path": "reference/generated/numpy.ma.atleast_2d", "type": "numpy.ma.atleast_2d", "text": "\nView inputs as arrays with at least two dimensions.\n\n"}, {"name": "ma.atleast_3d()", "path": "reference/generated/numpy.ma.atleast_3d", "type": "numpy.ma.atleast_3d", "text": "\nView inputs as arrays with at least three dimensions.\n\n"}, {"name": "ma.average()", "path": "reference/generated/numpy.ma.average", "type": "numpy.ma.average", "text": "\nReturn the weighted average of array over the given axis.\n\n"}, {"name": "ma.choose()", "path": "reference/generated/numpy.ma.choose", "type": "numpy.ma.choose", "text": "\nUse an index array to construct a new array from a list of choices.\n\n"}, {"name": "ma.clip()", "path": "reference/generated/numpy.ma.clip", "type": "numpy.ma.clip", "text": "\nClip (limit) the values in an array.\n\n"}, {"name": "ma.clump_masked()", "path": "reference/generated/numpy.ma.clump_masked", "type": "numpy.ma.clump_masked", "text": "\nReturns a list of slices corresponding to the masked clumps of a 1-D array. (A\n\u201cclump\u201d is defined as a contiguous region of the array).\n\n"}, {"name": "ma.clump_unmasked()", "path": "reference/generated/numpy.ma.clump_unmasked", "type": "numpy.ma.clump_unmasked", "text": "\nReturn list of slices corresponding to the unmasked clumps of a 1-D array. (A\n\u201cclump\u201d is defined as a contiguous region of the array).\n\n"}, {"name": "ma.column_stack()", "path": "reference/generated/numpy.ma.column_stack", "type": "numpy.ma.column_stack", "text": "\nStack 1-D arrays as columns into a 2-D array.\n\n"}, {"name": "ma.common_fill_value()", "path": "reference/generated/numpy.ma.common_fill_value", "type": "numpy.ma.common_fill_value", "text": "\nReturn the common filling value of two masked arrays, if any.\n\n"}, {"name": "ma.compress_cols()", "path": "reference/generated/numpy.ma.compress_cols", "type": "numpy.ma.compress_cols", "text": "\nSuppress whole columns of a 2-D array that contain masked values.\n\n"}, {"name": "ma.compress_rowcols()", "path": "reference/generated/numpy.ma.compress_rowcols", "type": "numpy.ma.compress_rowcols", "text": "\nSuppress the rows and/or columns of a 2-D array that contain masked values.\n\n"}, {"name": "ma.compress_rows()", "path": "reference/generated/numpy.ma.compress_rows", "type": "numpy.ma.compress_rows", "text": "\nSuppress whole rows of a 2-D array that contain masked values.\n\n"}, {"name": "ma.compressed()", "path": "reference/generated/numpy.ma.compressed", "type": "numpy.ma.compressed", "text": "\nReturn all the non-masked data as a 1-D array.\n\n"}, {"name": "ma.concatenate()", "path": "reference/generated/numpy.ma.concatenate", "type": "numpy.ma.concatenate", "text": "\nConcatenate a sequence of arrays along the given axis.\n\n"}, {"name": "ma.conjugate()", "path": "reference/generated/numpy.ma.conjugate", "type": "numpy.ma.conjugate", "text": "\nReturn the complex conjugate, element-wise.\n\n"}, {"name": "ma.copy()", "path": "reference/generated/numpy.ma.copy", "type": "numpy.ma.copy", "text": "\nReturn a copy of the array.\n\n"}, {"name": "ma.corrcoef()", "path": "reference/generated/numpy.ma.corrcoef", "type": "numpy.ma.corrcoef", "text": "\nReturn Pearson product-moment correlation coefficients.\n\n"}, {"name": "ma.count()", "path": "reference/generated/numpy.ma.count", "type": "numpy.ma.count", "text": "\nCount the non-masked elements of the array along the given axis.\n\n"}, {"name": "ma.count_masked()", "path": "reference/generated/numpy.ma.count_masked", "type": "numpy.ma.count_masked", "text": "\nCount the number of masked elements along the given axis.\n\n"}, {"name": "ma.cov()", "path": "reference/generated/numpy.ma.cov", "type": "numpy.ma.cov", "text": "\nEstimate the covariance matrix.\n\n"}, {"name": "ma.cumprod()", "path": "reference/generated/numpy.ma.cumprod", "type": "numpy.ma.cumprod", "text": "\nReturn the cumulative product of the array elements over the given axis.\n\n"}, {"name": "ma.cumsum()", "path": "reference/generated/numpy.ma.cumsum", "type": "numpy.ma.cumsum", "text": "\nReturn the cumulative sum of the array elements over the given axis.\n\n"}, {"name": "ma.default_fill_value()", "path": "reference/generated/numpy.ma.default_fill_value", "type": "numpy.ma.default_fill_value", "text": "\nReturn the default fill value for the argument object.\n\n"}, {"name": "ma.diag()", "path": "reference/generated/numpy.ma.diag", "type": "numpy.ma.diag", "text": "\nExtract a diagonal or construct a diagonal array.\n\n"}, {"name": "ma.diff()", "path": "reference/generated/numpy.ma.diff", "type": "numpy.ma.diff", "text": "\nCalculate the n-th discrete difference along the given axis.\n\n"}, {"name": "ma.dot()", "path": "reference/generated/numpy.ma.dot", "type": "numpy.ma.dot", "text": "\nReturn the dot product of two arrays.\n\n"}, {"name": "ma.dstack()", "path": "reference/generated/numpy.ma.dstack", "type": "numpy.ma.dstack", "text": "\nStack arrays in sequence depth wise (along third axis).\n\n"}, {"name": "ma.ediff1d()", "path": "reference/generated/numpy.ma.ediff1d", "type": "numpy.ma.ediff1d", "text": "\nCompute the differences between consecutive elements of an array.\n\n"}, {"name": "ma.empty()", "path": "reference/generated/numpy.ma.empty", "type": "numpy.ma.empty", "text": "\nReturn a new array of given shape and type, without initializing entries.\n\n"}, {"name": "ma.empty_like()", "path": "reference/generated/numpy.ma.empty_like", "type": "numpy.ma.empty_like", "text": "\nReturn a new array with the same shape and type as a given array.\n\n"}, {"name": "ma.expand_dims()", "path": "reference/generated/numpy.ma.expand_dims", "type": "numpy.ma.expand_dims", "text": "\nExpand the shape of an array.\n\n"}, {"name": "ma.filled()", "path": "reference/generated/numpy.ma.filled", "type": "numpy.ma.filled", "text": "\nReturn input as an array with masked data replaced by a fill value.\n\n"}, {"name": "ma.fix_invalid()", "path": "reference/generated/numpy.ma.fix_invalid", "type": "numpy.ma.fix_invalid", "text": "\nReturn input with invalid data masked and replaced by a fill value.\n\n"}, {"name": "ma.flatnotmasked_contiguous()", "path": "reference/generated/numpy.ma.flatnotmasked_contiguous", "type": "numpy.ma.flatnotmasked_contiguous", "text": "\nFind contiguous unmasked data in a masked array along the given axis.\n\n"}, {"name": "ma.flatnotmasked_edges()", "path": "reference/generated/numpy.ma.flatnotmasked_edges", "type": "numpy.ma.flatnotmasked_edges", "text": "\nFind the indices of the first and last unmasked values.\n\n"}, {"name": "ma.frombuffer()", "path": "reference/generated/numpy.ma.frombuffer", "type": "numpy.ma.frombuffer", "text": "\nInterpret a buffer as a 1-dimensional array.\n\n"}, {"name": "ma.fromfunction()", "path": "reference/generated/numpy.ma.fromfunction", "type": "numpy.ma.fromfunction", "text": "\nConstruct an array by executing a function over each coordinate.\n\n"}, {"name": "ma.getdata()", "path": "reference/generated/numpy.ma.getdata", "type": "numpy.ma.getdata", "text": "\nReturn the data of a masked array as an ndarray.\n\n"}, {"name": "ma.getmask()", "path": "reference/generated/numpy.ma.getmask", "type": "numpy.ma.getmask", "text": "\nReturn the mask of a masked array, or nomask.\n\n"}, {"name": "ma.getmaskarray()", "path": "reference/generated/numpy.ma.getmaskarray", "type": "numpy.ma.getmaskarray", "text": "\nReturn the mask of a masked array, or full boolean array of False.\n\n"}, {"name": "ma.harden_mask()", "path": "reference/generated/numpy.ma.harden_mask", "type": "numpy.ma.harden_mask", "text": "\nForce the mask to hard.\n\n"}, {"name": "ma.hsplit()", "path": "reference/generated/numpy.ma.hsplit", "type": "numpy.ma.hsplit", "text": "\nSplit an array into multiple sub-arrays horizontally (column-wise).\n\n"}, {"name": "ma.hstack()", "path": "reference/generated/numpy.ma.hstack", "type": "numpy.ma.hstack", "text": "\nStack arrays in sequence horizontally (column wise).\n\n"}, {"name": "ma.identity()", "path": "reference/generated/numpy.ma.identity", "type": "numpy.ma.identity", "text": "\nReturn the identity array.\n\n"}, {"name": "ma.indices()", "path": "reference/generated/numpy.ma.indices", "type": "numpy.ma.indices", "text": "\nReturn an array representing the indices of a grid.\n\n"}, {"name": "ma.inner()", "path": "reference/generated/numpy.ma.inner", "type": "numpy.ma.inner", "text": "\nInner product of two arrays.\n\n"}, {"name": "ma.innerproduct()", "path": "reference/generated/numpy.ma.innerproduct", "type": "numpy.ma.innerproduct", "text": "\nInner product of two arrays.\n\n"}, {"name": "ma.is_mask()", "path": "reference/generated/numpy.ma.is_mask", "type": "numpy.ma.is_mask", "text": "\nReturn True if m is a valid, standard mask.\n\n"}, {"name": "ma.is_masked()", "path": "reference/generated/numpy.ma.is_masked", "type": "numpy.ma.is_masked", "text": "\nDetermine whether input has masked values.\n\n"}, {"name": "ma.isarray()", "path": "reference/generated/numpy.ma.isarray", "type": "numpy.ma.isarray", "text": "\nTest whether input is an instance of MaskedArray.\n\n"}, {"name": "ma.isMA()", "path": "reference/generated/numpy.ma.isma", "type": "numpy.ma.isMA", "text": "\nTest whether input is an instance of MaskedArray.\n\n"}, {"name": "ma.isMaskedArray()", "path": "reference/generated/numpy.ma.ismaskedarray", "type": "numpy.ma.isMaskedArray", "text": "\nTest whether input is an instance of MaskedArray.\n\n"}, {"name": "ma.make_mask()", "path": "reference/generated/numpy.ma.make_mask", "type": "numpy.ma.make_mask", "text": "\nCreate a boolean mask from an array.\n\n"}, {"name": "ma.make_mask_descr()", "path": "reference/generated/numpy.ma.make_mask_descr", "type": "numpy.ma.make_mask_descr", "text": "\nConstruct a dtype description list from a given dtype.\n\n"}, {"name": "ma.make_mask_none()", "path": "reference/generated/numpy.ma.make_mask_none", "type": "numpy.ma.make_mask_none", "text": "\nReturn a boolean mask of the given shape, filled with False.\n\n"}, {"name": "ma.mask_cols()", "path": "reference/generated/numpy.ma.mask_cols", "type": "numpy.ma.mask_cols", "text": "\nMask columns of a 2D array that contain masked values.\n\n"}, {"name": "ma.mask_or()", "path": "reference/generated/numpy.ma.mask_or", "type": "numpy.ma.mask_or", "text": "\nCombine two masks with the `logical_or` operator.\n\n"}, {"name": "ma.mask_rowcols()", "path": "reference/generated/numpy.ma.mask_rowcols", "type": "numpy.ma.mask_rowcols", "text": "\nMask rows and/or columns of a 2D array that contain masked values.\n\n"}, {"name": "ma.mask_rows()", "path": "reference/generated/numpy.ma.mask_rows", "type": "numpy.ma.mask_rows", "text": "\nMask rows of a 2D array that contain masked values.\n\n"}, {"name": "ma.masked_all()", "path": "reference/generated/numpy.ma.masked_all", "type": "numpy.ma.masked_all", "text": "\nEmpty masked array with all elements masked.\n\n"}, {"name": "ma.masked_all_like()", "path": "reference/generated/numpy.ma.masked_all_like", "type": "numpy.ma.masked_all_like", "text": "\nEmpty masked array with the properties of an existing array.\n\n"}, {"name": "ma.masked_equal()", "path": "reference/generated/numpy.ma.masked_equal", "type": "numpy.ma.masked_equal", "text": "\nMask an array where equal to a given value.\n\n"}, {"name": "ma.masked_greater()", "path": "reference/generated/numpy.ma.masked_greater", "type": "numpy.ma.masked_greater", "text": "\nMask an array where greater than a given value.\n\n"}, {"name": "ma.masked_greater_equal()", "path": "reference/generated/numpy.ma.masked_greater_equal", "type": "numpy.ma.masked_greater_equal", "text": "\nMask an array where greater than or equal to a given value.\n\n"}, {"name": "ma.masked_inside()", "path": "reference/generated/numpy.ma.masked_inside", "type": "numpy.ma.masked_inside", "text": "\nMask an array inside a given interval.\n\n"}, {"name": "ma.masked_invalid()", "path": "reference/generated/numpy.ma.masked_invalid", "type": "numpy.ma.masked_invalid", "text": "\nMask an array where invalid values occur (NaNs or infs).\n\n"}, {"name": "ma.masked_less()", "path": "reference/generated/numpy.ma.masked_less", "type": "numpy.ma.masked_less", "text": "\nMask an array where less than a given value.\n\n"}, {"name": "ma.masked_less_equal()", "path": "reference/generated/numpy.ma.masked_less_equal", "type": "numpy.ma.masked_less_equal", "text": "\nMask an array where less than or equal to a given value.\n\n"}, {"name": "ma.masked_not_equal()", "path": "reference/generated/numpy.ma.masked_not_equal", "type": "numpy.ma.masked_not_equal", "text": "\nMask an array where `not` equal to a given value.\n\n"}, {"name": "ma.masked_object()", "path": "reference/generated/numpy.ma.masked_object", "type": "numpy.ma.masked_object", "text": "\nMask the array `x` where the data are exactly equal to value.\n\n"}, {"name": "ma.masked_outside()", "path": "reference/generated/numpy.ma.masked_outside", "type": "numpy.ma.masked_outside", "text": "\nMask an array outside a given interval.\n\n"}, {"name": "ma.masked_values()", "path": "reference/generated/numpy.ma.masked_values", "type": "numpy.ma.masked_values", "text": "\nMask using floating point equality.\n\n"}, {"name": "ma.masked_where()", "path": "reference/generated/numpy.ma.masked_where", "type": "numpy.ma.masked_where", "text": "\nMask an array where a condition is met.\n\n"}, {"name": "ma.MaskedArray.__abs__()", "path": "reference/generated/numpy.ma.maskedarray.__abs__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__add__()", "path": "reference/generated/numpy.ma.maskedarray.__add__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__and__()", "path": "reference/generated/numpy.ma.maskedarray.__and__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__array__()", "path": "reference/generated/numpy.ma.maskedarray.__array__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__array_priority__", "path": "reference/generated/numpy.ma.maskedarray.__array_priority__", "type": "Masked arrays", "text": "\nattribute\n\n"}, {"name": "ma.MaskedArray.__array_wrap__()", "path": "reference/generated/numpy.ma.maskedarray.__array_wrap__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__bool__()", "path": "reference/generated/numpy.ma.maskedarray.__bool__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__contains__()", "path": "reference/generated/numpy.ma.maskedarray.__contains__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__copy__()", "path": "reference/generated/numpy.ma.maskedarray.__copy__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__deepcopy__()", "path": "reference/generated/numpy.ma.maskedarray.__deepcopy__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__delitem__()", "path": "reference/generated/numpy.ma.maskedarray.__delitem__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__div__()", "path": "reference/generated/numpy.ma.maskedarray.__div__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__divmod__()", "path": "reference/generated/numpy.ma.maskedarray.__divmod__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__eq__()", "path": "reference/generated/numpy.ma.maskedarray.__eq__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__float__()", "path": "reference/generated/numpy.ma.maskedarray.__float__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__floordiv__()", "path": "reference/generated/numpy.ma.maskedarray.__floordiv__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__ge__()", "path": "reference/generated/numpy.ma.maskedarray.__ge__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__getitem__()", "path": "reference/generated/numpy.ma.maskedarray.__getitem__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__getstate__()", "path": "reference/generated/numpy.ma.maskedarray.__getstate__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__gt__()", "path": "reference/generated/numpy.ma.maskedarray.__gt__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__iadd__()", "path": "reference/generated/numpy.ma.maskedarray.__iadd__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__iand__()", "path": "reference/generated/numpy.ma.maskedarray.__iand__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__idiv__()", "path": "reference/generated/numpy.ma.maskedarray.__idiv__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__ifloordiv__()", "path": "reference/generated/numpy.ma.maskedarray.__ifloordiv__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__ilshift__()", "path": "reference/generated/numpy.ma.maskedarray.__ilshift__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__imod__()", "path": "reference/generated/numpy.ma.maskedarray.__imod__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__imul__()", "path": "reference/generated/numpy.ma.maskedarray.__imul__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__int__()", "path": "reference/generated/numpy.ma.maskedarray.__int__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__ior__()", "path": "reference/generated/numpy.ma.maskedarray.__ior__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__ipow__()", "path": "reference/generated/numpy.ma.maskedarray.__ipow__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__irshift__()", "path": "reference/generated/numpy.ma.maskedarray.__irshift__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__isub__()", "path": "reference/generated/numpy.ma.maskedarray.__isub__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__itruediv__()", "path": "reference/generated/numpy.ma.maskedarray.__itruediv__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__ixor__()", "path": "reference/generated/numpy.ma.maskedarray.__ixor__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__le__()", "path": "reference/generated/numpy.ma.maskedarray.__le__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__len__()", "path": "reference/generated/numpy.ma.maskedarray.__len__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__lshift__()", "path": "reference/generated/numpy.ma.maskedarray.__lshift__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__lt__()", "path": "reference/generated/numpy.ma.maskedarray.__lt__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__mod__()", "path": "reference/generated/numpy.ma.maskedarray.__mod__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__mul__()", "path": "reference/generated/numpy.ma.maskedarray.__mul__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__ne__()", "path": "reference/generated/numpy.ma.maskedarray.__ne__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__or__()", "path": "reference/generated/numpy.ma.maskedarray.__or__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__pow__()", "path": "reference/generated/numpy.ma.maskedarray.__pow__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__radd__()", "path": "reference/generated/numpy.ma.maskedarray.__radd__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__rand__()", "path": "reference/generated/numpy.ma.maskedarray.__rand__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__rdivmod__()", "path": "reference/generated/numpy.ma.maskedarray.__rdivmod__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__reduce__()", "path": "reference/generated/numpy.ma.maskedarray.__reduce__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__repr__()", "path": "reference/generated/numpy.ma.maskedarray.__repr__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__rfloordiv__()", "path": "reference/generated/numpy.ma.maskedarray.__rfloordiv__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__rlshift__()", "path": "reference/generated/numpy.ma.maskedarray.__rlshift__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__rmod__()", "path": "reference/generated/numpy.ma.maskedarray.__rmod__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__rmul__()", "path": "reference/generated/numpy.ma.maskedarray.__rmul__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__ror__()", "path": "reference/generated/numpy.ma.maskedarray.__ror__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__rpow__()", "path": "reference/generated/numpy.ma.maskedarray.__rpow__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__rrshift__()", "path": "reference/generated/numpy.ma.maskedarray.__rrshift__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__rshift__()", "path": "reference/generated/numpy.ma.maskedarray.__rshift__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__rsub__()", "path": "reference/generated/numpy.ma.maskedarray.__rsub__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__rtruediv__()", "path": "reference/generated/numpy.ma.maskedarray.__rtruediv__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__rxor__()", "path": "reference/generated/numpy.ma.maskedarray.__rxor__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__setitem__()", "path": "reference/generated/numpy.ma.maskedarray.__setitem__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__setmask__()", "path": "reference/generated/numpy.ma.maskedarray.__setmask__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__setstate__()", "path": "reference/generated/numpy.ma.maskedarray.__setstate__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__str__()", "path": "reference/generated/numpy.ma.maskedarray.__str__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__sub__()", "path": "reference/generated/numpy.ma.maskedarray.__sub__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__truediv__()", "path": "reference/generated/numpy.ma.maskedarray.__truediv__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.__xor__()", "path": "reference/generated/numpy.ma.maskedarray.__xor__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.all()", "path": "reference/generated/numpy.ma.maskedarray.all", "type": "numpy.ma.MaskedArray.all", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.anom()", "path": "reference/generated/numpy.ma.maskedarray.anom", "type": "numpy.ma.MaskedArray.anom", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.any()", "path": "reference/generated/numpy.ma.maskedarray.any", "type": "numpy.ma.MaskedArray.any", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.argmax()", "path": "reference/generated/numpy.ma.maskedarray.argmax", "type": "numpy.ma.MaskedArray.argmax", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.argmin()", "path": "reference/generated/numpy.ma.maskedarray.argmin", "type": "numpy.ma.MaskedArray.argmin", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.argsort()", "path": "reference/generated/numpy.ma.maskedarray.argsort", "type": "numpy.ma.MaskedArray.argsort", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.astype()", "path": "reference/generated/numpy.ma.maskedarray.astype", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.base", "path": "reference/generated/numpy.ma.maskedarray.base", "type": "Masked arrays", "text": "\nattribute\n\n"}, {"name": "ma.MaskedArray.byteswap()", "path": "reference/generated/numpy.ma.maskedarray.byteswap", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.choose()", "path": "reference/generated/numpy.ma.maskedarray.choose", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.clip()", "path": "reference/generated/numpy.ma.maskedarray.clip", "type": "numpy.ma.MaskedArray.clip", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.compress()", "path": "reference/generated/numpy.ma.maskedarray.compress", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.compressed()", "path": "reference/generated/numpy.ma.maskedarray.compressed", "type": "numpy.ma.MaskedArray.compressed", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.conj()", "path": "reference/generated/numpy.ma.maskedarray.conj", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.conjugate()", "path": "reference/generated/numpy.ma.maskedarray.conjugate", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.copy()", "path": "reference/generated/numpy.ma.maskedarray.copy", "type": "numpy.ma.MaskedArray.copy", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.count()", "path": "reference/generated/numpy.ma.maskedarray.count", "type": "numpy.ma.MaskedArray.count", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.ctypes", "path": "reference/generated/numpy.ma.maskedarray.ctypes", "type": "Masked arrays", "text": "\nattribute\n\n"}, {"name": "ma.MaskedArray.cumprod()", "path": "reference/generated/numpy.ma.maskedarray.cumprod", "type": "numpy.ma.MaskedArray.cumprod", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.cumsum()", "path": "reference/generated/numpy.ma.maskedarray.cumsum", "type": "numpy.ma.MaskedArray.cumsum", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.diagonal()", "path": "reference/generated/numpy.ma.maskedarray.diagonal", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.dump()", "path": "reference/generated/numpy.ma.maskedarray.dump", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.dumps()", "path": "reference/generated/numpy.ma.maskedarray.dumps", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.fill()", "path": "reference/generated/numpy.ma.maskedarray.fill", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.filled()", "path": "reference/generated/numpy.ma.maskedarray.filled", "type": "numpy.ma.MaskedArray.filled", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.flags", "path": "reference/generated/numpy.ma.maskedarray.flags", "type": "Masked arrays", "text": "\nattribute\n\n"}, {"name": "ma.MaskedArray.flatten()", "path": "reference/generated/numpy.ma.maskedarray.flatten", "type": "numpy.ma.MaskedArray.flatten", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.get_fill_value()", "path": "reference/generated/numpy.ma.maskedarray.get_fill_value", "type": "numpy.ma.MaskedArray.get_fill_value", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.harden_mask()", "path": "reference/generated/numpy.ma.maskedarray.harden_mask", "type": "numpy.ma.MaskedArray.harden_mask", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.ids()", "path": "reference/generated/numpy.ma.maskedarray.ids", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.iscontiguous()", "path": "reference/generated/numpy.ma.maskedarray.iscontiguous", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.item()", "path": "reference/generated/numpy.ma.maskedarray.item", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.itemsize", "path": "reference/generated/numpy.ma.maskedarray.itemsize", "type": "Masked arrays", "text": "\nattribute\n\n"}, {"name": "ma.MaskedArray.max()", "path": "reference/generated/numpy.ma.maskedarray.max", "type": "numpy.ma.MaskedArray.max", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.mean()", "path": "reference/generated/numpy.ma.maskedarray.mean", "type": "numpy.ma.MaskedArray.mean", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.min()", "path": "reference/generated/numpy.ma.maskedarray.min", "type": "numpy.ma.MaskedArray.min", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.nbytes", "path": "reference/generated/numpy.ma.maskedarray.nbytes", "type": "Masked arrays", "text": "\nattribute\n\n"}, {"name": "ma.MaskedArray.ndim", "path": "reference/generated/numpy.ma.maskedarray.ndim", "type": "Masked arrays", "text": "\nattribute\n\n"}, {"name": "ma.MaskedArray.nonzero()", "path": "reference/generated/numpy.ma.maskedarray.nonzero", "type": "numpy.ma.MaskedArray.nonzero", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.prod()", "path": "reference/generated/numpy.ma.maskedarray.prod", "type": "numpy.ma.MaskedArray.prod", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.product()", "path": "reference/generated/numpy.ma.maskedarray.product", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.ptp()", "path": "reference/generated/numpy.ma.maskedarray.ptp", "type": "numpy.ma.MaskedArray.ptp", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.put()", "path": "reference/generated/numpy.ma.maskedarray.put", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.ravel()", "path": "reference/generated/numpy.ma.maskedarray.ravel", "type": "numpy.ma.MaskedArray.ravel", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.repeat()", "path": "reference/generated/numpy.ma.maskedarray.repeat", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.reshape()", "path": "reference/generated/numpy.ma.maskedarray.reshape", "type": "numpy.ma.MaskedArray.reshape", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.resize()", "path": "reference/generated/numpy.ma.maskedarray.resize", "type": "numpy.ma.MaskedArray.resize", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.round()", "path": "reference/generated/numpy.ma.maskedarray.round", "type": "numpy.ma.MaskedArray.round", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.searchsorted()", "path": "reference/generated/numpy.ma.maskedarray.searchsorted", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.set_fill_value()", "path": "reference/generated/numpy.ma.maskedarray.set_fill_value", "type": "numpy.ma.MaskedArray.set_fill_value", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.shrink_mask()", "path": "reference/generated/numpy.ma.maskedarray.shrink_mask", "type": "numpy.ma.MaskedArray.shrink_mask", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.size", "path": "reference/generated/numpy.ma.maskedarray.size", "type": "Masked arrays", "text": "\nattribute\n\n"}, {"name": "ma.MaskedArray.soften_mask()", "path": "reference/generated/numpy.ma.maskedarray.soften_mask", "type": "numpy.ma.MaskedArray.soften_mask", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.sort()", "path": "reference/generated/numpy.ma.maskedarray.sort", "type": "numpy.ma.MaskedArray.sort", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.squeeze()", "path": "reference/generated/numpy.ma.maskedarray.squeeze", "type": "numpy.ma.MaskedArray.squeeze", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.std()", "path": "reference/generated/numpy.ma.maskedarray.std", "type": "numpy.ma.MaskedArray.std", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.strides", "path": "reference/generated/numpy.ma.maskedarray.strides", "type": "Masked arrays", "text": "\nattribute\n\n"}, {"name": "ma.MaskedArray.sum()", "path": "reference/generated/numpy.ma.maskedarray.sum", "type": "numpy.ma.MaskedArray.sum", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.swapaxes()", "path": "reference/generated/numpy.ma.maskedarray.swapaxes", "type": "numpy.ma.MaskedArray.swapaxes", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.take()", "path": "reference/generated/numpy.ma.maskedarray.take", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.tobytes()", "path": "reference/generated/numpy.ma.maskedarray.tobytes", "type": "numpy.ma.MaskedArray.tobytes", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.tofile()", "path": "reference/generated/numpy.ma.maskedarray.tofile", "type": "numpy.ma.MaskedArray.tofile", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.toflex()", "path": "reference/generated/numpy.ma.maskedarray.toflex", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.tolist()", "path": "reference/generated/numpy.ma.maskedarray.tolist", "type": "numpy.ma.MaskedArray.tolist", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.torecords()", "path": "reference/generated/numpy.ma.maskedarray.torecords", "type": "numpy.ma.MaskedArray.torecords", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.tostring()", "path": "reference/generated/numpy.ma.maskedarray.tostring", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.trace()", "path": "reference/generated/numpy.ma.maskedarray.trace", "type": "numpy.ma.MaskedArray.trace", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.transpose()", "path": "reference/generated/numpy.ma.maskedarray.transpose", "type": "numpy.ma.MaskedArray.transpose", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.unshare_mask()", "path": "reference/generated/numpy.ma.maskedarray.unshare_mask", "type": "numpy.ma.MaskedArray.unshare_mask", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.var()", "path": "reference/generated/numpy.ma.maskedarray.var", "type": "numpy.ma.MaskedArray.var", "text": "\nmethod\n\n"}, {"name": "ma.MaskedArray.view()", "path": "reference/generated/numpy.ma.maskedarray.view", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "ma.max()", "path": "reference/generated/numpy.ma.max", "type": "numpy.ma.max", "text": "\nReturn the maximum along a given axis.\n\n"}, {"name": "ma.maximum_fill_value()", "path": "reference/generated/numpy.ma.maximum_fill_value", "type": "numpy.ma.maximum_fill_value", "text": "\nReturn the minimum value that can be represented by the dtype of an object.\n\n"}, {"name": "ma.mean()", "path": "reference/generated/numpy.ma.mean", "type": "numpy.ma.mean", "text": "\nReturns the average of the array elements along given axis.\n\n"}, {"name": "ma.median()", "path": "reference/generated/numpy.ma.median", "type": "numpy.ma.median", "text": "\nCompute the median along the specified axis.\n\n"}, {"name": "ma.min()", "path": "reference/generated/numpy.ma.min", "type": "numpy.ma.min", "text": "\nReturn the minimum along a given axis.\n\n"}, {"name": "ma.minimum_fill_value()", "path": "reference/generated/numpy.ma.minimum_fill_value", "type": "numpy.ma.minimum_fill_value", "text": "\nReturn the maximum value that can be represented by the dtype of an object.\n\n"}, {"name": "ma.mr_", "path": "reference/generated/numpy.ma.mr_", "type": "numpy.ma.mr_", "text": "\nTranslate slice objects to concatenation along the first axis.\n\n"}, {"name": "ma.nonzero()", "path": "reference/generated/numpy.ma.nonzero", "type": "numpy.ma.nonzero", "text": "\nReturn the indices of unmasked elements that are not zero.\n\n"}, {"name": "ma.notmasked_contiguous()", "path": "reference/generated/numpy.ma.notmasked_contiguous", "type": "numpy.ma.notmasked_contiguous", "text": "\nFind contiguous unmasked data in a masked array along the given axis.\n\n"}, {"name": "ma.notmasked_edges()", "path": "reference/generated/numpy.ma.notmasked_edges", "type": "numpy.ma.notmasked_edges", "text": "\nFind the indices of the first and last unmasked values along an axis.\n\n"}, {"name": "ma.ones()", "path": "reference/generated/numpy.ma.ones", "type": "numpy.ma.ones", "text": "\nReturn a new array of given shape and type, filled with ones.\n\n"}, {"name": "ma.ones_like()", "path": "reference/generated/numpy.ma.ones_like", "type": "numpy.ma.ones_like", "text": "\nReturn an array of ones with the same shape and type as a given array.\n\n"}, {"name": "ma.outer()", "path": "reference/generated/numpy.ma.outer", "type": "numpy.ma.outer", "text": "\nCompute the outer product of two vectors.\n\n"}, {"name": "ma.outerproduct()", "path": "reference/generated/numpy.ma.outerproduct", "type": "numpy.ma.outerproduct", "text": "\nCompute the outer product of two vectors.\n\n"}, {"name": "ma.polyfit()", "path": "reference/generated/numpy.ma.polyfit", "type": "numpy.ma.polyfit", "text": "\nLeast squares polynomial fit.\n\n"}, {"name": "ma.power()", "path": "reference/generated/numpy.ma.power", "type": "numpy.ma.power", "text": "\nReturns element-wise base array raised to power from second array.\n\n"}, {"name": "ma.prod()", "path": "reference/generated/numpy.ma.prod", "type": "numpy.ma.prod", "text": "\nReturn the product of the array elements over the given axis.\n\n"}, {"name": "ma.ptp()", "path": "reference/generated/numpy.ma.ptp", "type": "numpy.ma.ptp", "text": "\nReturn (maximum - minimum) along the given dimension (i.e. peak-to-peak\nvalue).\n\n"}, {"name": "ma.ravel()", "path": "reference/generated/numpy.ma.ravel", "type": "numpy.ma.ravel", "text": "\nReturns a 1D version of self, as a view.\n\n"}, {"name": "ma.reshape()", "path": "reference/generated/numpy.ma.reshape", "type": "numpy.ma.reshape", "text": "\nReturns an array containing the same data with a new shape.\n\n"}, {"name": "ma.resize()", "path": "reference/generated/numpy.ma.resize", "type": "numpy.ma.resize", "text": "\nReturn a new masked array with the specified size and shape.\n\n"}, {"name": "ma.round()", "path": "reference/generated/numpy.ma.round", "type": "numpy.ma.round", "text": "\nReturn a copy of a, rounded to \u2018decimals\u2019 places.\n\n"}, {"name": "ma.row_stack()", "path": "reference/generated/numpy.ma.row_stack", "type": "numpy.ma.row_stack", "text": "\nStack arrays in sequence vertically (row wise).\n\n"}, {"name": "ma.set_fill_value()", "path": "reference/generated/numpy.ma.set_fill_value", "type": "numpy.ma.set_fill_value", "text": "\nSet the filling value of a, if a is a masked array.\n\n"}, {"name": "ma.shape()", "path": "reference/generated/numpy.ma.shape", "type": "numpy.ma.shape", "text": "\nReturn the shape of an array.\n\n"}, {"name": "ma.size()", "path": "reference/generated/numpy.ma.size", "type": "numpy.ma.size", "text": "\nReturn the number of elements along a given axis.\n\n"}, {"name": "ma.soften_mask()", "path": "reference/generated/numpy.ma.soften_mask", "type": "numpy.ma.soften_mask", "text": "\nForce the mask to soft.\n\n"}, {"name": "ma.sort()", "path": "reference/generated/numpy.ma.sort", "type": "numpy.ma.sort", "text": "\nReturn a sorted copy of the masked array.\n\n"}, {"name": "ma.squeeze()", "path": "reference/generated/numpy.ma.squeeze", "type": "numpy.ma.squeeze", "text": "\nRemove axes of length one from `a`.\n\n"}, {"name": "ma.stack()", "path": "reference/generated/numpy.ma.stack", "type": "numpy.ma.stack", "text": "\nJoin a sequence of arrays along a new axis.\n\n"}, {"name": "ma.std()", "path": "reference/generated/numpy.ma.std", "type": "numpy.ma.std", "text": "\nReturns the standard deviation of the array elements along given axis.\n\n"}, {"name": "ma.sum()", "path": "reference/generated/numpy.ma.sum", "type": "numpy.ma.sum", "text": "\nReturn the sum of the array elements over the given axis.\n\n"}, {"name": "ma.swapaxes()", "path": "reference/generated/numpy.ma.swapaxes", "type": "numpy.ma.swapaxes", "text": "\nReturn a view of the array with `axis1` and `axis2` interchanged.\n\n"}, {"name": "ma.trace()", "path": "reference/generated/numpy.ma.trace", "type": "numpy.ma.trace", "text": "\nReturn the sum along diagonals of the array.\n\n"}, {"name": "ma.transpose()", "path": "reference/generated/numpy.ma.transpose", "type": "numpy.ma.transpose", "text": "\nPermute the dimensions of an array.\n\n"}, {"name": "ma.vander()", "path": "reference/generated/numpy.ma.vander", "type": "numpy.ma.vander", "text": "\nGenerate a Vandermonde matrix.\n\n"}, {"name": "ma.var()", "path": "reference/generated/numpy.ma.var", "type": "numpy.ma.var", "text": "\nCompute the variance along the specified axis.\n\n"}, {"name": "ma.vstack()", "path": "reference/generated/numpy.ma.vstack", "type": "numpy.ma.vstack", "text": "\nStack arrays in sequence vertically (row wise).\n\n"}, {"name": "ma.where()", "path": "reference/generated/numpy.ma.where", "type": "numpy.ma.where", "text": "\nReturn a masked array with elements from `x` or `y`, depending on condition.\n\n"}, {"name": "ma.zeros()", "path": "reference/generated/numpy.ma.zeros", "type": "numpy.ma.zeros", "text": "\nReturn a new array of given shape and type, filled with zeros.\n\n"}, {"name": "ma.zeros_like()", "path": "reference/generated/numpy.ma.zeros_like", "type": "numpy.ma.zeros_like", "text": "\nReturn an array of zeros with the same shape and type as a given array.\n\n"}, {"name": "make_config_py()", "path": "reference/distutils#numpy.distutils.misc_util.Configuration.make_config_py", "type": "Packaging ( \n    \n     numpy.distutils\n    \n    )", "text": "\nGenerate package __config__.py file containing system_info information used\nduring building the package.\n\n"}, {"name": "make_svn_version_py()", "path": "reference/distutils#numpy.distutils.misc_util.Configuration.make_svn_version_py", "type": "Packaging ( \n    \n     numpy.distutils\n    \n    )", "text": "\nAppends a data function to the data_files list that will generate\n__svn_version__.py file to the current package directory.\n\n"}, {"name": "Masked array operations", "path": "reference/routines.ma", "type": "Masked array operations", "text": "\n`ma.MaskType`\n\n"}, {"name": "Masked arrays", "path": "reference/maskedarray", "type": "Masked arrays", "text": "\nMasked arrays are arrays that may have missing or invalid entries. The\n`numpy.ma` module provides a nearly work-alike replacement for numpy that\nsupports data arrays with masks.\n\n"}, {"name": "MaskedArray.baseclass", "path": "reference/maskedarray.baseclass#numpy.ma.MaskedArray.baseclass", "type": "Constants of the \n        \n         numpy.ma\n        \n        module", "text": "\nIn addition to the `MaskedArray` class, the `numpy.ma` module defines several\nconstants.\n\n"}, {"name": "MaskedArray.fill_value", "path": "reference/maskedarray.baseclass#numpy.ma.MaskedArray.fill_value", "type": "Constants of the \n        \n         numpy.ma\n        \n        module", "text": "\nIn addition to the `MaskedArray` class, the `numpy.ma` module defines several\nconstants.\n\n"}, {"name": "MaskedArray.hardmask", "path": "reference/maskedarray.baseclass#numpy.ma.MaskedArray.hardmask", "type": "Constants of the \n        \n         numpy.ma\n        \n        module", "text": "\nIn addition to the `MaskedArray` class, the `numpy.ma` module defines several\nconstants.\n\n"}, {"name": "MaskedArray.mask", "path": "reference/maskedarray.baseclass#numpy.ma.MaskedArray.mask", "type": "Constants of the \n        \n         numpy.ma\n        \n        module", "text": "\nIn addition to the `MaskedArray` class, the `numpy.ma` module defines several\nconstants.\n\n"}, {"name": "MaskedArray.recordmask", "path": "reference/maskedarray.baseclass#numpy.ma.MaskedArray.recordmask", "type": "Constants of the \n        \n         numpy.ma\n        \n        module", "text": "\nIn addition to the `MaskedArray` class, the `numpy.ma` module defines several\nconstants.\n\n"}, {"name": "MaskedArray.sharedmask", "path": "reference/maskedarray.baseclass#numpy.ma.MaskedArray.sharedmask", "type": "Constants of the \n        \n         numpy.ma\n        \n        module", "text": "\nIn addition to the `MaskedArray` class, the `numpy.ma` module defines several\nconstants.\n\n"}, {"name": "Mathematical functions", "path": "reference/routines.math", "type": "Mathematical functions", "text": "\n`sin`(x, /[, out, where, casting, order, ...])\n\n"}, {"name": "Mathematical functions with automatic domain (numpy.emath)", "path": "reference/routines.emath", "type": "Mathematical functions with automatic domain ( \n      \n       numpy.emath\n      \n      )", "text": "\nNote\n\n"}, {"name": "matlib.empty()", "path": "reference/generated/numpy.matlib.empty", "type": "numpy.matlib.empty", "text": "\nReturn a new matrix of given shape and type, without initializing entries.\n\n"}, {"name": "matlib.eye()", "path": "reference/generated/numpy.matlib.eye", "type": "numpy.matlib.eye", "text": "\nReturn a matrix with ones on the diagonal and zeros elsewhere.\n\n"}, {"name": "matlib.identity()", "path": "reference/generated/numpy.matlib.identity", "type": "numpy.matlib.identity", "text": "\nReturns the square identity matrix of given size.\n\n"}, {"name": "matlib.ones()", "path": "reference/generated/numpy.matlib.ones", "type": "numpy.matlib.ones", "text": "\nMatrix of ones.\n\n"}, {"name": "matlib.rand()", "path": "reference/generated/numpy.matlib.rand", "type": "numpy.matlib.rand", "text": "\nReturn a matrix of random values with given shape.\n\n"}, {"name": "matlib.randn()", "path": "reference/generated/numpy.matlib.randn", "type": "numpy.matlib.randn", "text": "\nReturn a random matrix with data from the \u201cstandard normal\u201d distribution.\n\n"}, {"name": "matlib.repmat()", "path": "reference/generated/numpy.matlib.repmat", "type": "numpy.matlib.repmat", "text": "\nRepeat a 0-D to 2-D array or matrix MxN times.\n\n"}, {"name": "matlib.zeros()", "path": "reference/generated/numpy.matlib.zeros", "type": "numpy.matlib.zeros", "text": "\nReturn a matrix of given shape and type, filled with zeros.\n\n"}, {"name": "Matrix library (numpy.matlib)", "path": "reference/routines.matlib", "type": "Matrix library ( \n      \n       numpy.matlib\n      \n      )", "text": "\nThis module contains all functions in the `numpy` namespace, with the\nfollowing replacement functions that return `matrices` instead of `ndarrays`.\n\n"}, {"name": "matrix.all()", "path": "reference/generated/numpy.matrix.all", "type": "numpy.matrix.all", "text": "\nmethod\n\n"}, {"name": "matrix.any()", "path": "reference/generated/numpy.matrix.any", "type": "numpy.matrix.any", "text": "\nmethod\n\n"}, {"name": "matrix.argmax()", "path": "reference/generated/numpy.matrix.argmax", "type": "numpy.matrix.argmax", "text": "\nmethod\n\n"}, {"name": "matrix.argmin()", "path": "reference/generated/numpy.matrix.argmin", "type": "numpy.matrix.argmin", "text": "\nmethod\n\n"}, {"name": "matrix.argpartition()", "path": "reference/generated/numpy.matrix.argpartition", "type": "numpy.matrix.argpartition", "text": "\nmethod\n\n"}, {"name": "matrix.argsort()", "path": "reference/generated/numpy.matrix.argsort", "type": "numpy.matrix.argsort", "text": "\nmethod\n\n"}, {"name": "matrix.astype()", "path": "reference/generated/numpy.matrix.astype", "type": "numpy.matrix.astype", "text": "\nmethod\n\n"}, {"name": "matrix.base", "path": "reference/generated/numpy.matrix.base", "type": "Standard array subclasses", "text": "\nattribute\n\n"}, {"name": "matrix.byteswap()", "path": "reference/generated/numpy.matrix.byteswap", "type": "numpy.matrix.byteswap", "text": "\nmethod\n\n"}, {"name": "matrix.choose()", "path": "reference/generated/numpy.matrix.choose", "type": "numpy.matrix.choose", "text": "\nmethod\n\n"}, {"name": "matrix.clip()", "path": "reference/generated/numpy.matrix.clip", "type": "numpy.matrix.clip", "text": "\nmethod\n\n"}, {"name": "matrix.compress()", "path": "reference/generated/numpy.matrix.compress", "type": "numpy.matrix.compress", "text": "\nmethod\n\n"}, {"name": "matrix.conj()", "path": "reference/generated/numpy.matrix.conj", "type": "numpy.matrix.conj", "text": "\nmethod\n\n"}, {"name": "matrix.conjugate()", "path": "reference/generated/numpy.matrix.conjugate", "type": "numpy.matrix.conjugate", "text": "\nmethod\n\n"}, {"name": "matrix.copy()", "path": "reference/generated/numpy.matrix.copy", "type": "numpy.matrix.copy", "text": "\nmethod\n\n"}, {"name": "matrix.ctypes", "path": "reference/generated/numpy.matrix.ctypes", "type": "Standard array subclasses", "text": "\nattribute\n\n"}, {"name": "matrix.cumprod()", "path": "reference/generated/numpy.matrix.cumprod", "type": "numpy.matrix.cumprod", "text": "\nmethod\n\n"}, {"name": "matrix.cumsum()", "path": "reference/generated/numpy.matrix.cumsum", "type": "numpy.matrix.cumsum", "text": "\nmethod\n\n"}, {"name": "matrix.data", "path": "reference/generated/numpy.matrix.data", "type": "Standard array subclasses", "text": "\nattribute\n\n"}, {"name": "matrix.diagonal()", "path": "reference/generated/numpy.matrix.diagonal", "type": "numpy.matrix.diagonal", "text": "\nmethod\n\n"}, {"name": "matrix.dump()", "path": "reference/generated/numpy.matrix.dump", "type": "numpy.matrix.dump", "text": "\nmethod\n\n"}, {"name": "matrix.dumps()", "path": "reference/generated/numpy.matrix.dumps", "type": "numpy.matrix.dumps", "text": "\nmethod\n\n"}, {"name": "matrix.fill()", "path": "reference/generated/numpy.matrix.fill", "type": "numpy.matrix.fill", "text": "\nmethod\n\n"}, {"name": "matrix.flags", "path": "reference/generated/numpy.matrix.flags", "type": "Standard array subclasses", "text": "\nattribute\n\n"}, {"name": "matrix.flat", "path": "reference/generated/numpy.matrix.flat", "type": "Standard array subclasses", "text": "\nattribute\n\n"}, {"name": "matrix.flatten()", "path": "reference/generated/numpy.matrix.flatten", "type": "numpy.matrix.flatten", "text": "\nmethod\n\n"}, {"name": "matrix.getA()", "path": "reference/generated/numpy.matrix.geta", "type": "numpy.matrix.getA", "text": "\nmethod\n\n"}, {"name": "matrix.getA1()", "path": "reference/generated/numpy.matrix.geta1", "type": "numpy.matrix.getA1", "text": "\nmethod\n\n"}, {"name": "matrix.getfield()", "path": "reference/generated/numpy.matrix.getfield", "type": "numpy.matrix.getfield", "text": "\nmethod\n\n"}, {"name": "matrix.getH()", "path": "reference/generated/numpy.matrix.geth", "type": "numpy.matrix.getH", "text": "\nmethod\n\n"}, {"name": "matrix.getI()", "path": "reference/generated/numpy.matrix.geti", "type": "numpy.matrix.getI", "text": "\nmethod\n\n"}, {"name": "matrix.getT()", "path": "reference/generated/numpy.matrix.gett", "type": "numpy.matrix.getT", "text": "\nmethod\n\n"}, {"name": "matrix.item()", "path": "reference/generated/numpy.matrix.item", "type": "numpy.matrix.item", "text": "\nmethod\n\n"}, {"name": "matrix.itemset()", "path": "reference/generated/numpy.matrix.itemset", "type": "numpy.matrix.itemset", "text": "\nmethod\n\n"}, {"name": "matrix.itemsize", "path": "reference/generated/numpy.matrix.itemsize", "type": "Standard array subclasses", "text": "\nattribute\n\n"}, {"name": "matrix.max()", "path": "reference/generated/numpy.matrix.max", "type": "numpy.matrix.max", "text": "\nmethod\n\n"}, {"name": "matrix.mean()", "path": "reference/generated/numpy.matrix.mean", "type": "numpy.matrix.mean", "text": "\nmethod\n\n"}, {"name": "matrix.min()", "path": "reference/generated/numpy.matrix.min", "type": "numpy.matrix.min", "text": "\nmethod\n\n"}, {"name": "matrix.nbytes", "path": "reference/generated/numpy.matrix.nbytes", "type": "Standard array subclasses", "text": "\nattribute\n\n"}, {"name": "matrix.ndim", "path": "reference/generated/numpy.matrix.ndim", "type": "Standard array subclasses", "text": "\nattribute\n\n"}, {"name": "matrix.newbyteorder()", "path": "reference/generated/numpy.matrix.newbyteorder", "type": "numpy.matrix.newbyteorder", "text": "\nmethod\n\n"}, {"name": "matrix.nonzero()", "path": "reference/generated/numpy.matrix.nonzero", "type": "numpy.matrix.nonzero", "text": "\nmethod\n\n"}, {"name": "matrix.partition()", "path": "reference/generated/numpy.matrix.partition", "type": "numpy.matrix.partition", "text": "\nmethod\n\n"}, {"name": "matrix.prod()", "path": "reference/generated/numpy.matrix.prod", "type": "numpy.matrix.prod", "text": "\nmethod\n\n"}, {"name": "matrix.ptp()", "path": "reference/generated/numpy.matrix.ptp", "type": "numpy.matrix.ptp", "text": "\nmethod\n\n"}, {"name": "matrix.put()", "path": "reference/generated/numpy.matrix.put", "type": "numpy.matrix.put", "text": "\nmethod\n\n"}, {"name": "matrix.ravel()", "path": "reference/generated/numpy.matrix.ravel", "type": "numpy.matrix.ravel", "text": "\nmethod\n\n"}, {"name": "matrix.repeat()", "path": "reference/generated/numpy.matrix.repeat", "type": "numpy.matrix.repeat", "text": "\nmethod\n\n"}, {"name": "matrix.reshape()", "path": "reference/generated/numpy.matrix.reshape", "type": "numpy.matrix.reshape", "text": "\nmethod\n\n"}, {"name": "matrix.resize()", "path": "reference/generated/numpy.matrix.resize", "type": "numpy.matrix.resize", "text": "\nmethod\n\n"}, {"name": "matrix.round()", "path": "reference/generated/numpy.matrix.round", "type": "numpy.matrix.round", "text": "\nmethod\n\n"}, {"name": "matrix.searchsorted()", "path": "reference/generated/numpy.matrix.searchsorted", "type": "numpy.matrix.searchsorted", "text": "\nmethod\n\n"}, {"name": "matrix.setfield()", "path": "reference/generated/numpy.matrix.setfield", "type": "numpy.matrix.setfield", "text": "\nmethod\n\n"}, {"name": "matrix.setflags()", "path": "reference/generated/numpy.matrix.setflags", "type": "numpy.matrix.setflags", "text": "\nmethod\n\n"}, {"name": "matrix.size", "path": "reference/generated/numpy.matrix.size", "type": "Standard array subclasses", "text": "\nattribute\n\n"}, {"name": "matrix.sort()", "path": "reference/generated/numpy.matrix.sort", "type": "numpy.matrix.sort", "text": "\nmethod\n\n"}, {"name": "matrix.squeeze()", "path": "reference/generated/numpy.matrix.squeeze", "type": "numpy.matrix.squeeze", "text": "\nmethod\n\n"}, {"name": "matrix.std()", "path": "reference/generated/numpy.matrix.std", "type": "numpy.matrix.std", "text": "\nmethod\n\n"}, {"name": "matrix.strides", "path": "reference/generated/numpy.matrix.strides", "type": "Standard array subclasses", "text": "\nattribute\n\n"}, {"name": "matrix.sum()", "path": "reference/generated/numpy.matrix.sum", "type": "numpy.matrix.sum", "text": "\nmethod\n\n"}, {"name": "matrix.swapaxes()", "path": "reference/generated/numpy.matrix.swapaxes", "type": "numpy.matrix.swapaxes", "text": "\nmethod\n\n"}, {"name": "matrix.take()", "path": "reference/generated/numpy.matrix.take", "type": "numpy.matrix.take", "text": "\nmethod\n\n"}, {"name": "matrix.tobytes()", "path": "reference/generated/numpy.matrix.tobytes", "type": "numpy.matrix.tobytes", "text": "\nmethod\n\n"}, {"name": "matrix.tofile()", "path": "reference/generated/numpy.matrix.tofile", "type": "numpy.matrix.tofile", "text": "\nmethod\n\n"}, {"name": "matrix.tolist()", "path": "reference/generated/numpy.matrix.tolist", "type": "numpy.matrix.tolist", "text": "\nmethod\n\n"}, {"name": "matrix.tostring()", "path": "reference/generated/numpy.matrix.tostring", "type": "numpy.matrix.tostring", "text": "\nmethod\n\n"}, {"name": "matrix.trace()", "path": "reference/generated/numpy.matrix.trace", "type": "numpy.matrix.trace", "text": "\nmethod\n\n"}, {"name": "matrix.transpose()", "path": "reference/generated/numpy.matrix.transpose", "type": "numpy.matrix.transpose", "text": "\nmethod\n\n"}, {"name": "matrix.var()", "path": "reference/generated/numpy.matrix.var", "type": "numpy.matrix.var", "text": "\nmethod\n\n"}, {"name": "matrix.view()", "path": "reference/generated/numpy.matrix.view", "type": "numpy.matrix.view", "text": "\nmethod\n\n"}, {"name": "memmap.flush()", "path": "reference/generated/numpy.memmap.flush", "type": "numpy.memmap.flush", "text": "\nmethod\n\n"}, {"name": "Miscellaneous", "path": "user/misc", "type": "User Guide", "text": "\nSpecial values defined in numpy: nan, inf,\n\n"}, {"name": "Miscellaneous routines", "path": "reference/routines.other", "type": "Miscellaneous routines", "text": "\n`setbufsize`(size)\n\n"}, {"name": "Multithreaded Generation", "path": "reference/random/multithreading", "type": "Multithreaded Generation", "text": "\nThe four core distributions (`random`, `standard_normal`,\n`standard_exponential`, and `standard_gamma`) all allow existing arrays to be\nfilled using the `out` keyword argument. Existing arrays need to be contiguous\nand well-behaved (writable and aligned). Under normal circumstances, arrays\ncreated using the common constructors such as `numpy.empty` will satisfy these\nrequirements.\n\n"}, {"name": "NATIVE: Enables all CPU features that supported by the current", "path": "reference/simd/simd-optimizations", "type": "SIMD Optimizations", "text": "\nNumPy provides a set of macros that define Universal Intrinsics to abstract\nout typical platform-specific intrinsics so SIMD code needs to be written only\nonce. There are three layers:\n\n"}, {"name": "ndarray.__abs__()", "path": "reference/generated/numpy.ndarray.__abs__", "type": "numpy.ndarray.__abs__", "text": "\nmethod\n\n"}, {"name": "ndarray.__add__()", "path": "reference/generated/numpy.ndarray.__add__", "type": "numpy.ndarray.__add__", "text": "\nmethod\n\n"}, {"name": "ndarray.__and__()", "path": "reference/generated/numpy.ndarray.__and__", "type": "numpy.ndarray.__and__", "text": "\nmethod\n\n"}, {"name": "ndarray.__array__()", "path": "reference/generated/numpy.ndarray.__array__", "type": "numpy.ndarray.__array__", "text": "\nmethod\n\n"}, {"name": "ndarray.__array_wrap__()", "path": "reference/generated/numpy.ndarray.__array_wrap__", "type": "numpy.ndarray.__array_wrap__", "text": "\nmethod\n\n"}, {"name": "ndarray.__bool__()", "path": "reference/generated/numpy.ndarray.__bool__", "type": "numpy.ndarray.__bool__", "text": "\nmethod\n\n"}, {"name": "ndarray.__class_getitem__()", "path": "reference/generated/numpy.ndarray.__class_getitem__", "type": "numpy.ndarray.__class_getitem__", "text": "\nmethod\n\n"}, {"name": "ndarray.__complex__()", "path": "reference/generated/numpy.ndarray.__complex__", "type": "numpy.ndarray.__complex__", "text": "\nmethod\n\n"}, {"name": "ndarray.__contains__()", "path": "reference/generated/numpy.ndarray.__contains__", "type": "numpy.ndarray.__contains__", "text": "\nmethod\n\n"}, {"name": "ndarray.__copy__()", "path": "reference/generated/numpy.ndarray.__copy__", "type": "numpy.ndarray.__copy__", "text": "\nmethod\n\n"}, {"name": "ndarray.__deepcopy__()", "path": "reference/generated/numpy.ndarray.__deepcopy__", "type": "numpy.ndarray.__deepcopy__", "text": "\nmethod\n\n"}, {"name": "ndarray.__divmod__()", "path": "reference/generated/numpy.ndarray.__divmod__", "type": "numpy.ndarray.__divmod__", "text": "\nmethod\n\n"}, {"name": "ndarray.__eq__()", "path": "reference/generated/numpy.ndarray.__eq__", "type": "numpy.ndarray.__eq__", "text": "\nmethod\n\n"}, {"name": "ndarray.__float__()", "path": "reference/generated/numpy.ndarray.__float__", "type": "numpy.ndarray.__float__", "text": "\nmethod\n\n"}, {"name": "ndarray.__floordiv__()", "path": "reference/generated/numpy.ndarray.__floordiv__", "type": "numpy.ndarray.__floordiv__", "text": "\nmethod\n\n"}, {"name": "ndarray.__ge__()", "path": "reference/generated/numpy.ndarray.__ge__", "type": "numpy.ndarray.__ge__", "text": "\nmethod\n\n"}, {"name": "ndarray.__getitem__()", "path": "reference/generated/numpy.ndarray.__getitem__", "type": "numpy.ndarray.__getitem__", "text": "\nmethod\n\n"}, {"name": "ndarray.__gt__()", "path": "reference/generated/numpy.ndarray.__gt__", "type": "numpy.ndarray.__gt__", "text": "\nmethod\n\n"}, {"name": "ndarray.__iadd__()", "path": "reference/generated/numpy.ndarray.__iadd__", "type": "numpy.ndarray.__iadd__", "text": "\nmethod\n\n"}, {"name": "ndarray.__iand__()", "path": "reference/generated/numpy.ndarray.__iand__", "type": "numpy.ndarray.__iand__", "text": "\nmethod\n\n"}, {"name": "ndarray.__ifloordiv__()", "path": "reference/generated/numpy.ndarray.__ifloordiv__", "type": "numpy.ndarray.__ifloordiv__", "text": "\nmethod\n\n"}, {"name": "ndarray.__ilshift__()", "path": "reference/generated/numpy.ndarray.__ilshift__", "type": "numpy.ndarray.__ilshift__", "text": "\nmethod\n\n"}, {"name": "ndarray.__imod__()", "path": "reference/generated/numpy.ndarray.__imod__", "type": "numpy.ndarray.__imod__", "text": "\nmethod\n\n"}, {"name": "ndarray.__imul__()", "path": "reference/generated/numpy.ndarray.__imul__", "type": "numpy.ndarray.__imul__", "text": "\nmethod\n\n"}, {"name": "ndarray.__int__()", "path": "reference/generated/numpy.ndarray.__int__", "type": "numpy.ndarray.__int__", "text": "\nmethod\n\n"}, {"name": "ndarray.__invert__()", "path": "reference/generated/numpy.ndarray.__invert__", "type": "numpy.ndarray.__invert__", "text": "\nmethod\n\n"}, {"name": "ndarray.__ior__()", "path": "reference/generated/numpy.ndarray.__ior__", "type": "numpy.ndarray.__ior__", "text": "\nmethod\n\n"}, {"name": "ndarray.__ipow__()", "path": "reference/generated/numpy.ndarray.__ipow__", "type": "numpy.ndarray.__ipow__", "text": "\nmethod\n\n"}, {"name": "ndarray.__irshift__()", "path": "reference/generated/numpy.ndarray.__irshift__", "type": "numpy.ndarray.__irshift__", "text": "\nmethod\n\n"}, {"name": "ndarray.__isub__()", "path": "reference/generated/numpy.ndarray.__isub__", "type": "numpy.ndarray.__isub__", "text": "\nmethod\n\n"}, {"name": "ndarray.__itruediv__()", "path": "reference/generated/numpy.ndarray.__itruediv__", "type": "numpy.ndarray.__itruediv__", "text": "\nmethod\n\n"}, {"name": "ndarray.__ixor__()", "path": "reference/generated/numpy.ndarray.__ixor__", "type": "numpy.ndarray.__ixor__", "text": "\nmethod\n\n"}, {"name": "ndarray.__le__()", "path": "reference/generated/numpy.ndarray.__le__", "type": "numpy.ndarray.__le__", "text": "\nmethod\n\n"}, {"name": "ndarray.__len__()", "path": "reference/generated/numpy.ndarray.__len__", "type": "numpy.ndarray.__len__", "text": "\nmethod\n\n"}, {"name": "ndarray.__lshift__()", "path": "reference/generated/numpy.ndarray.__lshift__", "type": "numpy.ndarray.__lshift__", "text": "\nmethod\n\n"}, {"name": "ndarray.__lt__()", "path": "reference/generated/numpy.ndarray.__lt__", "type": "numpy.ndarray.__lt__", "text": "\nmethod\n\n"}, {"name": "ndarray.__matmul__()", "path": "reference/generated/numpy.ndarray.__matmul__", "type": "numpy.ndarray.__matmul__", "text": "\nmethod\n\n"}, {"name": "ndarray.__mod__()", "path": "reference/generated/numpy.ndarray.__mod__", "type": "numpy.ndarray.__mod__", "text": "\nmethod\n\n"}, {"name": "ndarray.__mul__()", "path": "reference/generated/numpy.ndarray.__mul__", "type": "numpy.ndarray.__mul__", "text": "\nmethod\n\n"}, {"name": "ndarray.__ne__()", "path": "reference/generated/numpy.ndarray.__ne__", "type": "numpy.ndarray.__ne__", "text": "\nmethod\n\n"}, {"name": "ndarray.__neg__()", "path": "reference/generated/numpy.ndarray.__neg__", "type": "numpy.ndarray.__neg__", "text": "\nmethod\n\n"}, {"name": "ndarray.__new__()", "path": "reference/generated/numpy.ndarray.__new__", "type": "numpy.ndarray.__new__", "text": "\nmethod\n\n"}, {"name": "ndarray.__or__()", "path": "reference/generated/numpy.ndarray.__or__", "type": "numpy.ndarray.__or__", "text": "\nmethod\n\n"}, {"name": "ndarray.__pos__()", "path": "reference/generated/numpy.ndarray.__pos__", "type": "numpy.ndarray.__pos__", "text": "\nmethod\n\n"}, {"name": "ndarray.__pow__()", "path": "reference/generated/numpy.ndarray.__pow__", "type": "numpy.ndarray.__pow__", "text": "\nmethod\n\n"}, {"name": "ndarray.__reduce__()", "path": "reference/generated/numpy.ndarray.__reduce__", "type": "numpy.ndarray.__reduce__", "text": "\nmethod\n\n"}, {"name": "ndarray.__repr__()", "path": "reference/generated/numpy.ndarray.__repr__", "type": "numpy.ndarray.__repr__", "text": "\nmethod\n\n"}, {"name": "ndarray.__rshift__()", "path": "reference/generated/numpy.ndarray.__rshift__", "type": "numpy.ndarray.__rshift__", "text": "\nmethod\n\n"}, {"name": "ndarray.__setitem__()", "path": "reference/generated/numpy.ndarray.__setitem__", "type": "numpy.ndarray.__setitem__", "text": "\nmethod\n\n"}, {"name": "ndarray.__setstate__()", "path": "reference/generated/numpy.ndarray.__setstate__", "type": "numpy.ndarray.__setstate__", "text": "\nmethod\n\n"}, {"name": "ndarray.__str__()", "path": "reference/generated/numpy.ndarray.__str__", "type": "numpy.ndarray.__str__", "text": "\nmethod\n\n"}, {"name": "ndarray.__sub__()", "path": "reference/generated/numpy.ndarray.__sub__", "type": "numpy.ndarray.__sub__", "text": "\nmethod\n\n"}, {"name": "ndarray.__truediv__()", "path": "reference/generated/numpy.ndarray.__truediv__", "type": "numpy.ndarray.__truediv__", "text": "\nmethod\n\n"}, {"name": "ndarray.__xor__()", "path": "reference/generated/numpy.ndarray.__xor__", "type": "numpy.ndarray.__xor__", "text": "\nmethod\n\n"}, {"name": "ndarray.all()", "path": "reference/generated/numpy.ndarray.all", "type": "numpy.ndarray.all", "text": "\nmethod\n\n"}, {"name": "ndarray.any()", "path": "reference/generated/numpy.ndarray.any", "type": "numpy.ndarray.any", "text": "\nmethod\n\n"}, {"name": "ndarray.argmax()", "path": "reference/generated/numpy.ndarray.argmax", "type": "numpy.ndarray.argmax", "text": "\nmethod\n\n"}, {"name": "ndarray.argmin()", "path": "reference/generated/numpy.ndarray.argmin", "type": "numpy.ndarray.argmin", "text": "\nmethod\n\n"}, {"name": "ndarray.argpartition()", "path": "reference/generated/numpy.ndarray.argpartition", "type": "numpy.ndarray.argpartition", "text": "\nmethod\n\n"}, {"name": "ndarray.argsort()", "path": "reference/generated/numpy.ndarray.argsort", "type": "numpy.ndarray.argsort", "text": "\nmethod\n\n"}, {"name": "ndarray.astype()", "path": "reference/generated/numpy.ndarray.astype", "type": "numpy.ndarray.astype", "text": "\nmethod\n\n"}, {"name": "ndarray.base", "path": "reference/generated/numpy.ndarray.base", "type": "numpy.ndarray.base", "text": "\nattribute\n\n"}, {"name": "ndarray.byteswap()", "path": "reference/generated/numpy.ndarray.byteswap", "type": "numpy.ndarray.byteswap", "text": "\nmethod\n\n"}, {"name": "ndarray.choose()", "path": "reference/generated/numpy.ndarray.choose", "type": "numpy.ndarray.choose", "text": "\nmethod\n\n"}, {"name": "ndarray.clip()", "path": "reference/generated/numpy.ndarray.clip", "type": "numpy.ndarray.clip", "text": "\nmethod\n\n"}, {"name": "ndarray.compress()", "path": "reference/generated/numpy.ndarray.compress", "type": "numpy.ndarray.compress", "text": "\nmethod\n\n"}, {"name": "ndarray.conj()", "path": "reference/generated/numpy.ndarray.conj", "type": "numpy.ndarray.conj", "text": "\nmethod\n\n"}, {"name": "ndarray.conjugate()", "path": "reference/generated/numpy.ndarray.conjugate", "type": "numpy.ndarray.conjugate", "text": "\nmethod\n\n"}, {"name": "ndarray.copy()", "path": "reference/generated/numpy.ndarray.copy", "type": "numpy.ndarray.copy", "text": "\nmethod\n\n"}, {"name": "ndarray.ctypes", "path": "reference/generated/numpy.ndarray.ctypes", "type": "numpy.ndarray.ctypes", "text": "\nattribute\n\n"}, {"name": "ndarray.cumprod()", "path": "reference/generated/numpy.ndarray.cumprod", "type": "numpy.ndarray.cumprod", "text": "\nmethod\n\n"}, {"name": "ndarray.cumsum()", "path": "reference/generated/numpy.ndarray.cumsum", "type": "numpy.ndarray.cumsum", "text": "\nmethod\n\n"}, {"name": "ndarray.data", "path": "reference/generated/numpy.ndarray.data", "type": "numpy.ndarray.data", "text": "\nattribute\n\n"}, {"name": "ndarray.diagonal()", "path": "reference/generated/numpy.ndarray.diagonal", "type": "numpy.ndarray.diagonal", "text": "\nmethod\n\n"}, {"name": "ndarray.dtype", "path": "reference/generated/numpy.ndarray.dtype", "type": "numpy.ndarray.dtype", "text": "\nattribute\n\n"}, {"name": "ndarray.dump()", "path": "reference/generated/numpy.ndarray.dump", "type": "numpy.ndarray.dump", "text": "\nmethod\n\n"}, {"name": "ndarray.dumps()", "path": "reference/generated/numpy.ndarray.dumps", "type": "numpy.ndarray.dumps", "text": "\nmethod\n\n"}, {"name": "ndarray.fill()", "path": "reference/generated/numpy.ndarray.fill", "type": "numpy.ndarray.fill", "text": "\nmethod\n\n"}, {"name": "ndarray.flags", "path": "reference/generated/numpy.ndarray.flags", "type": "numpy.ndarray.flags", "text": "\nattribute\n\n"}, {"name": "ndarray.flat", "path": "reference/generated/numpy.ndarray.flat", "type": "numpy.ndarray.flat", "text": "\nattribute\n\n"}, {"name": "ndarray.flatten()", "path": "reference/generated/numpy.ndarray.flatten", "type": "numpy.ndarray.flatten", "text": "\nmethod\n\n"}, {"name": "ndarray.getfield()", "path": "reference/generated/numpy.ndarray.getfield", "type": "numpy.ndarray.getfield", "text": "\nmethod\n\n"}, {"name": "ndarray.imag", "path": "reference/generated/numpy.ndarray.imag", "type": "numpy.ndarray.imag", "text": "\nattribute\n\n"}, {"name": "ndarray.item()", "path": "reference/generated/numpy.ndarray.item", "type": "numpy.ndarray.item", "text": "\nmethod\n\n"}, {"name": "ndarray.itemset()", "path": "reference/generated/numpy.ndarray.itemset", "type": "numpy.ndarray.itemset", "text": "\nmethod\n\n"}, {"name": "ndarray.itemsize", "path": "reference/generated/numpy.ndarray.itemsize", "type": "numpy.ndarray.itemsize", "text": "\nattribute\n\n"}, {"name": "ndarray.max()", "path": "reference/generated/numpy.ndarray.max", "type": "numpy.ndarray.max", "text": "\nmethod\n\n"}, {"name": "ndarray.mean()", "path": "reference/generated/numpy.ndarray.mean", "type": "numpy.ndarray.mean", "text": "\nmethod\n\n"}, {"name": "ndarray.min()", "path": "reference/generated/numpy.ndarray.min", "type": "numpy.ndarray.min", "text": "\nmethod\n\n"}, {"name": "ndarray.nbytes", "path": "reference/generated/numpy.ndarray.nbytes", "type": "numpy.ndarray.nbytes", "text": "\nattribute\n\n"}, {"name": "ndarray.ndim", "path": "reference/generated/numpy.ndarray.ndim", "type": "numpy.ndarray.ndim", "text": "\nattribute\n\n"}, {"name": "ndarray.ndim", "path": "user/quickstart", "type": "User Guide", "text": "\nYou\u2019ll need to know a bit of Python. For a refresher, see the Python tutorial.\n\n"}, {"name": "ndarray.newbyteorder()", "path": "reference/generated/numpy.ndarray.newbyteorder", "type": "numpy.ndarray.newbyteorder", "text": "\nmethod\n\n"}, {"name": "ndarray.nonzero()", "path": "reference/generated/numpy.ndarray.nonzero", "type": "numpy.ndarray.nonzero", "text": "\nmethod\n\n"}, {"name": "ndarray.partition()", "path": "reference/generated/numpy.ndarray.partition", "type": "numpy.ndarray.partition", "text": "\nmethod\n\n"}, {"name": "ndarray.prod()", "path": "reference/generated/numpy.ndarray.prod", "type": "numpy.ndarray.prod", "text": "\nmethod\n\n"}, {"name": "ndarray.ptp()", "path": "reference/generated/numpy.ndarray.ptp", "type": "numpy.ndarray.ptp", "text": "\nmethod\n\n"}, {"name": "ndarray.put()", "path": "reference/generated/numpy.ndarray.put", "type": "numpy.ndarray.put", "text": "\nmethod\n\n"}, {"name": "ndarray.ravel()", "path": "reference/generated/numpy.ndarray.ravel", "type": "numpy.ndarray.ravel", "text": "\nmethod\n\n"}, {"name": "ndarray.real", "path": "reference/generated/numpy.ndarray.real", "type": "numpy.ndarray.real", "text": "\nattribute\n\n"}, {"name": "ndarray.repeat()", "path": "reference/generated/numpy.ndarray.repeat", "type": "numpy.ndarray.repeat", "text": "\nmethod\n\n"}, {"name": "ndarray.reshape()", "path": "reference/generated/numpy.ndarray.reshape", "type": "numpy.ndarray.reshape", "text": "\nmethod\n\n"}, {"name": "ndarray.resize()", "path": "reference/generated/numpy.ndarray.resize", "type": "numpy.ndarray.resize", "text": "\nmethod\n\n"}, {"name": "ndarray.round()", "path": "reference/generated/numpy.ndarray.round", "type": "numpy.ndarray.round", "text": "\nmethod\n\n"}, {"name": "ndarray.searchsorted()", "path": "reference/generated/numpy.ndarray.searchsorted", "type": "numpy.ndarray.searchsorted", "text": "\nmethod\n\n"}, {"name": "ndarray.setfield()", "path": "reference/generated/numpy.ndarray.setfield", "type": "numpy.ndarray.setfield", "text": "\nmethod\n\n"}, {"name": "ndarray.setflags()", "path": "reference/generated/numpy.ndarray.setflags", "type": "numpy.ndarray.setflags", "text": "\nmethod\n\n"}, {"name": "ndarray.shape", "path": "reference/generated/numpy.ndarray.shape", "type": "numpy.ndarray.shape", "text": "\nattribute\n\n"}, {"name": "ndarray.size", "path": "reference/generated/numpy.ndarray.size", "type": "numpy.ndarray.size", "text": "\nattribute\n\n"}, {"name": "ndarray.sort()", "path": "reference/generated/numpy.ndarray.sort", "type": "numpy.ndarray.sort", "text": "\nmethod\n\n"}, {"name": "ndarray.squeeze()", "path": "reference/generated/numpy.ndarray.squeeze", "type": "numpy.ndarray.squeeze", "text": "\nmethod\n\n"}, {"name": "ndarray.std()", "path": "reference/generated/numpy.ndarray.std", "type": "numpy.ndarray.std", "text": "\nmethod\n\n"}, {"name": "ndarray.strides", "path": "reference/generated/numpy.ndarray.strides", "type": "numpy.ndarray.strides", "text": "\nattribute\n\n"}, {"name": "ndarray.sum()", "path": "reference/generated/numpy.ndarray.sum", "type": "numpy.ndarray.sum", "text": "\nmethod\n\n"}, {"name": "ndarray.swapaxes()", "path": "reference/generated/numpy.ndarray.swapaxes", "type": "numpy.ndarray.swapaxes", "text": "\nmethod\n\n"}, {"name": "ndarray.T", "path": "reference/generated/numpy.ndarray.t", "type": "numpy.ndarray.T", "text": "\nattribute\n\n"}, {"name": "ndarray.take()", "path": "reference/generated/numpy.ndarray.take", "type": "numpy.ndarray.take", "text": "\nmethod\n\n"}, {"name": "ndarray.tobytes()", "path": "reference/generated/numpy.ndarray.tobytes", "type": "numpy.ndarray.tobytes", "text": "\nmethod\n\n"}, {"name": "ndarray.tofile()", "path": "reference/generated/numpy.ndarray.tofile", "type": "numpy.ndarray.tofile", "text": "\nmethod\n\n"}, {"name": "ndarray.tolist()", "path": "reference/generated/numpy.ndarray.tolist", "type": "numpy.ndarray.tolist", "text": "\nmethod\n\n"}, {"name": "ndarray.tostring()", "path": "reference/generated/numpy.ndarray.tostring", "type": "numpy.ndarray.tostring", "text": "\nmethod\n\n"}, {"name": "ndarray.trace()", "path": "reference/generated/numpy.ndarray.trace", "type": "numpy.ndarray.trace", "text": "\nmethod\n\n"}, {"name": "ndarray.transpose()", "path": "reference/generated/numpy.ndarray.transpose", "type": "numpy.ndarray.transpose", "text": "\nmethod\n\n"}, {"name": "ndarray.var()", "path": "reference/generated/numpy.ndarray.var", "type": "numpy.ndarray.var", "text": "\nmethod\n\n"}, {"name": "ndarray.view()", "path": "reference/generated/numpy.ndarray.view", "type": "numpy.ndarray.view", "text": "\nmethod\n\n"}, {"name": "ndindex.ndincr()", "path": "reference/generated/numpy.ndindex.ndincr", "type": "numpy.ndindex.ndincr", "text": "\nmethod\n\n"}, {"name": "nditer.close()", "path": "reference/generated/numpy.nditer.close", "type": "numpy.nditer.close", "text": "\nmethod\n\n"}, {"name": "nditer.copy()", "path": "reference/generated/numpy.nditer.copy", "type": "numpy.nditer.copy", "text": "\nmethod\n\n"}, {"name": "nditer.debug_print()", "path": "reference/generated/numpy.nditer.debug_print", "type": "numpy.nditer.debug_print", "text": "\nmethod\n\n"}, {"name": "nditer.enable_external_loop()", "path": "reference/generated/numpy.nditer.enable_external_loop", "type": "numpy.nditer.enable_external_loop", "text": "\nmethod\n\n"}, {"name": "nditer.index", "path": "reference/generated/numpy.nditer.index", "type": "Indexing routines", "text": "\nattribute\n\n"}, {"name": "nditer.iternext()", "path": "reference/generated/numpy.nditer.iternext", "type": "numpy.nditer.iternext", "text": "\nmethod\n\n"}, {"name": "nditer.itersize", "path": "reference/generated/numpy.nditer.itersize", "type": "Indexing routines", "text": "\nattribute\n\n"}, {"name": "nditer.multi_index", "path": "reference/generated/numpy.nditer.multi_index", "type": "Indexing routines", "text": "\nattribute\n\n"}, {"name": "nditer.operands", "path": "reference/generated/numpy.nditer.operands", "type": "Indexing routines", "text": "\nattribute\n\n"}, {"name": "nditer.remove_axis()", "path": "reference/generated/numpy.nditer.remove_axis", "type": "numpy.nditer.remove_axis", "text": "\nmethod\n\n"}, {"name": "nditer.remove_multi_index()", "path": "reference/generated/numpy.nditer.remove_multi_index", "type": "numpy.nditer.remove_multi_index", "text": "\nmethod\n\n"}, {"name": "nditer.reset()", "path": "reference/generated/numpy.nditer.reset", "type": "numpy.nditer.reset", "text": "\nmethod\n\n"}, {"name": "nditer.value", "path": "reference/generated/numpy.nditer.value", "type": "Indexing routines", "text": "\nattribute\n\n"}, {"name": "ndpointer()", "path": "user/c-info.python-as-glue", "type": "User Guide", "text": "\nMany people like to say that Python is a fantastic glue language. Hopefully,\nthis Chapter will convince you that this is true. The first adopters of Python\nfor science were typically people who used it to glue together large\napplication codes running on super-computers. Not only was it much nicer to\ncode in Python than in a shell script or Perl, in addition, the ability to\neasily extend Python made it relatively easy to create new classes and types\nspecifically adapted to the problems being solved. From the interactions of\nthese early contributors, Numeric emerged as an array-like object that could\nbe used to pass data between these applications.\n\n"}, {"name": "NO_IMPORT_ARRAY", "path": "reference/c-api/array#c.NO_IMPORT_ARRAY", "type": "Array API", "text": "\nUsing these #defines you can use the C-API in multiple files for a single\nextension module. In each file you must define `PY_ARRAY_UNIQUE_SYMBOL` to\nsome name that will hold the C-API (e.g. myextension_ARRAY_API). This must be\ndone before including the numpy/arrayobject.h file. In the module\ninitialization routine you call `import_array`. In addition, in the files that\ndo not have the module initialization sub_routine define `NO_IMPORT_ARRAY`\nprior to including numpy/arrayobject.h.\n\n"}, {"name": "NO_IMPORT_UFUNC", "path": "reference/c-api/ufunc#c.NO_IMPORT_UFUNC", "type": "UFunc API", "text": "\n\n"}, {"name": "NPY_1_PI", "path": "reference/c-api/coremath#c.NPY_1_PI", "type": "NumPy core libraries", "text": "\nReciprocal of pi (\\\\(\\frac{1}{\\pi}\\\\))\n\n"}, {"name": "NPY_2_PI", "path": "reference/c-api/coremath#c.NPY_2_PI", "type": "NumPy core libraries", "text": "\nTwo times the reciprocal of pi (\\\\(\\frac{2}{\\pi}\\\\))\n\n"}, {"name": "NPY_ALLOW_C_API", "path": "reference/c-api/array#c.NPY_ALLOW_C_API", "type": "Array API", "text": "\nPlace before code that needs to call the Python C-API (when it is known that\nthe GIL has already been released).\n\n"}, {"name": "NPY_ARRAY_ALIGNED", "path": "reference/c-api/array#c.NPY_ARRAY_ALIGNED", "type": "Array API", "text": "\nThe data area and all array elements are aligned appropriately.\n\n"}, {"name": "NPY_ARRAY_ALIGNED", "path": "reference/c-api/array#c.PyArray_FromAny.NPY_ARRAY_ALIGNED", "type": "Array API", "text": "\nMake sure the returned array is aligned on proper boundaries for its data\ntype. An aligned array has the data pointer and every strides factor as a\nmultiple of the alignment factor for the data-type- descriptor.\n\n"}, {"name": "NPY_ARRAY_BEHAVED", "path": "reference/c-api/array#c.PyArray_FromAny.NPY_ARRAY_BEHAVED", "type": "Array API", "text": "\n`NPY_ARRAY_ALIGNED` | `NPY_ARRAY_WRITEABLE`\n\n"}, {"name": "NPY_ARRAY_CARRAY", "path": "reference/c-api/array#c.PyArray_FromAny.NPY_ARRAY_CARRAY", "type": "Array API", "text": "\n`NPY_ARRAY_C_CONTIGUOUS` | `NPY_ARRAY_BEHAVED`\n\n"}, {"name": "NPY_ARRAY_CARRAY", "path": "reference/c-api/array#c.NPY_ARRAY_CARRAY", "type": "Array API", "text": "\n`NPY_ARRAY_C_CONTIGUOUS` | `NPY_ARRAY_BEHAVED`\n\n"}, {"name": "NPY_ARRAY_CARRAY_RO", "path": "reference/c-api/array#c.PyArray_FromAny.NPY_ARRAY_CARRAY_RO", "type": "Array API", "text": "\n`NPY_ARRAY_C_CONTIGUOUS` | `NPY_ARRAY_ALIGNED`\n\n"}, {"name": "NPY_ARRAY_CARRAY_RO", "path": "reference/c-api/array#c.NPY_ARRAY_CARRAY_RO", "type": "Array API", "text": "\n`NPY_ARRAY_C_CONTIGUOUS` | `NPY_ARRAY_ALIGNED`\n\n"}, {"name": "NPY_ARRAY_DEFAULT", "path": "reference/c-api/array#c.PyArray_FromAny.NPY_ARRAY_DEFAULT", "type": "Array API", "text": "\n`NPY_ARRAY_CARRAY`\n\n"}, {"name": "NPY_ARRAY_DEFAULT", "path": "reference/c-api/array#c.NPY_ARRAY_DEFAULT", "type": "Array API", "text": "\n`NPY_ARRAY_CARRAY`\n\n"}, {"name": "NPY_ARRAY_ELEMENTSTRIDES", "path": "reference/c-api/array#c.NPY_ARRAY_ELEMENTSTRIDES", "type": "Array API", "text": "\nMake sure the returned array has strides that are multiples of the element\nsize.\n\n"}, {"name": "NPY_ARRAY_ENSUREARRAY", "path": "reference/c-api/array#c.PyArray_FromAny.NPY_ARRAY_ENSUREARRAY", "type": "Array API", "text": "\nMake sure the result is a base-class ndarray. By default, if op is an instance\nof a subclass of ndarray, an instance of that same subclass is returned. If\nthis flag is set, an ndarray object will be returned instead.\n\n"}, {"name": "NPY_ARRAY_ENSUREARRAY", "path": "reference/c-api/array#c.NPY_ARRAY_ENSUREARRAY", "type": "Array API", "text": "\nMake sure the resulting object is an actual ndarray, and not a sub-class.\n\n"}, {"name": "NPY_ARRAY_ENSURECOPY", "path": "reference/c-api/array#c.NPY_ARRAY_ENSURECOPY", "type": "Array API", "text": "\nMake sure the resulting array is a copy of the original.\n\n"}, {"name": "NPY_ARRAY_ENSURECOPY", "path": "reference/c-api/array#c.PyArray_FromAny.NPY_ARRAY_ENSURECOPY", "type": "Array API", "text": "\nMake sure a copy is made of op. If this flag is not present, data is not\ncopied if it can be avoided.\n\n"}, {"name": "NPY_ARRAY_F_CONTIGUOUS", "path": "reference/c-api/array#c.PyArray_FromAny.NPY_ARRAY_F_CONTIGUOUS", "type": "Array API", "text": "\nMake sure the returned array is Fortran-style contiguous.\n\n"}, {"name": "NPY_ARRAY_F_CONTIGUOUS", "path": "reference/c-api/array#c.NPY_ARRAY_F_CONTIGUOUS", "type": "Array API", "text": "\nThe data area is in Fortran-style contiguous order (first index varies the\nfastest).\n\n"}, {"name": "NPY_ARRAY_FARRAY", "path": "reference/c-api/array#c.PyArray_FromAny.NPY_ARRAY_FARRAY", "type": "Array API", "text": "\n`NPY_ARRAY_F_CONTIGUOUS` | `NPY_ARRAY_BEHAVED`\n\n"}, {"name": "NPY_ARRAY_FARRAY", "path": "reference/c-api/array#c.NPY_ARRAY_FARRAY", "type": "Array API", "text": "\n`NPY_ARRAY_F_CONTIGUOUS` | `NPY_ARRAY_BEHAVED`\n\n"}, {"name": "NPY_ARRAY_FARRAY_RO", "path": "reference/c-api/array#c.PyArray_FromAny.NPY_ARRAY_FARRAY_RO", "type": "Array API", "text": "\n`NPY_ARRAY_F_CONTIGUOUS` | `NPY_ARRAY_ALIGNED`\n\n"}, {"name": "NPY_ARRAY_FARRAY_RO", "path": "reference/c-api/array#c.NPY_ARRAY_FARRAY_RO", "type": "Array API", "text": "\n`NPY_ARRAY_F_CONTIGUOUS` | `NPY_ARRAY_ALIGNED`\n\n"}, {"name": "NPY_ARRAY_FORCECAST", "path": "reference/c-api/array#c.PyArray_FromAny.NPY_ARRAY_FORCECAST", "type": "Array API", "text": "\nForce a cast to the output type even if it cannot be done safely. Without this\nflag, a data cast will occur only if it can be done safely, otherwise an error\nis raised.\n\n"}, {"name": "NPY_ARRAY_IN_ARRAY", "path": "reference/c-api/array#c.NPY_ARRAY_IN_ARRAY", "type": "Array API", "text": "\n`NPY_ARRAY_C_CONTIGUOUS` | `NPY_ARRAY_ALIGNED`\n\n"}, {"name": "NPY_ARRAY_INOUT_ARRAY", "path": "reference/c-api/array#c.NPY_ARRAY_INOUT_ARRAY", "type": "Array API", "text": "\n`NPY_ARRAY_C_CONTIGUOUS` | `NPY_ARRAY_WRITEABLE` | `NPY_ARRAY_ALIGNED` |\n`NPY_ARRAY_WRITEBACKIFCOPY` | `NPY_ARRAY_UPDATEIFCOPY`\n\n"}, {"name": "NPY_ARRAY_NOTSWAPPED", "path": "reference/c-api/array#c.NPY_ARRAY_NOTSWAPPED", "type": "Array API", "text": "\nMake sure the returned array has a data-type descriptor that is in machine\nbyte-order, over-riding any specification in the dtype argument. Normally, the\nbyte-order requirement is determined by the dtype argument. If this flag is\nset and the dtype argument does not indicate a machine byte-order descriptor\n(or is NULL and the object is already an array with a data-type descriptor\nthat is not in machine byte- order), then a new data-type descriptor is\ncreated and used with its byte-order field set to native.\n\n"}, {"name": "NPY_ARRAY_OUT_ARRAY", "path": "reference/c-api/array#c.NPY_ARRAY_OUT_ARRAY", "type": "Array API", "text": "\n`NPY_ARRAY_C_CONTIGUOUS` | `NPY_ARRAY_ALIGNED` | `NPY_ARRAY_WRITEABLE`\n\n"}, {"name": "NPY_ARRAY_OWNDATA", "path": "reference/c-api/array#c.NPY_ARRAY_OWNDATA", "type": "Array API", "text": "\nThe data area is owned by this array. Should never be set manually, instead\ncreate a `PyObject` wrapping the data and set the array\u2019s base to that object.\nFor an example, see the test in `test_mem_policy`.\n\n"}, {"name": "NPY_ARRAY_UPDATE_ALL", "path": "reference/c-api/array#c.NPY_ARRAY_UPDATE_ALL", "type": "Array API", "text": "\n`NPY_ARRAY_C_CONTIGUOUS` | `NPY_ARRAY_F_CONTIGUOUS` | `NPY_ARRAY_ALIGNED`\n\n"}, {"name": "NPY_ARRAY_UPDATEIFCOPY", "path": "reference/c-api/array#c.NPY_ARRAY_UPDATEIFCOPY", "type": "Array API", "text": "\nA deprecated version of `NPY_ARRAY_WRITEBACKIFCOPY` which depends upon\n`dealloc` to trigger the writeback. For backwards compatibility,\n`PyArray_ResolveWritebackIfCopy` is called at `dealloc` but relying on that\nbehavior is deprecated and not supported in PyPy.\n\n"}, {"name": "NPY_ARRAY_UPDATEIFCOPY", "path": "reference/c-api/array#c.PyArray_FromAny.NPY_ARRAY_UPDATEIFCOPY", "type": "Array API", "text": "\nDeprecated. Use `NPY_ARRAY_WRITEBACKIFCOPY`, which is similar. This flag\n\u201cautomatically\u201d copies the data back when the returned array is deallocated,\nwhich is not supported in all python implementations.\n\n"}, {"name": "NPY_ARRAY_WRITEABLE", "path": "reference/c-api/array#c.PyArray_FromAny.NPY_ARRAY_WRITEABLE", "type": "Array API", "text": "\nMake sure the returned array can be written to.\n\n"}, {"name": "NPY_ARRAY_WRITEABLE", "path": "reference/c-api/array#c.NPY_ARRAY_WRITEABLE", "type": "Array API", "text": "\nThe data area can be written to.\n\n"}, {"name": "NPY_ARRAY_WRITEBACKIFCOPY", "path": "reference/c-api/array#c.NPY_ARRAY_WRITEBACKIFCOPY", "type": "Array API", "text": "\nThe data area represents a (well-behaved) copy whose information should be\ntransferred back to the original when `PyArray_ResolveWritebackIfCopy` is\ncalled.\n\n"}, {"name": "NPY_ARRAY_WRITEBACKIFCOPY", "path": "reference/c-api/array#c.PyArray_FromAny.NPY_ARRAY_WRITEBACKIFCOPY", "type": "Array API", "text": "\nIf op is already an array, but does not satisfy the requirements, then a copy\nis made (which will satisfy the requirements). If this flag is present and a\ncopy (of an object that is already an array) must be made, then the\ncorresponding `NPY_ARRAY_WRITEBACKIFCOPY` flag is set in the returned copy and\nop is made to be read-only. You must be sure to call\n`PyArray_ResolveWritebackIfCopy` to copy the contents back into op and the op\narray will be made writeable again. If op is not writeable to begin with, or\nif it is not already an array, then an error is raised.\n\n"}, {"name": "NPY_BEGIN_THREADS", "path": "reference/c-api/array#c.NPY_BEGIN_THREADS", "type": "Array API", "text": "\nPlace right before code that does not need the Python interpreter (no Python\nC-API calls). This macro saves the Python state and releases the GIL.\n\n"}, {"name": "NPY_BEGIN_THREADS_DEF", "path": "reference/c-api/array#c.NPY_BEGIN_THREADS_DEF", "type": "Array API", "text": "\nPlace in the variable declaration area. This macro sets up the variable needed\nfor storing the Python state.\n\n"}, {"name": "NPY_BIG", "path": "reference/c-api/array#c.NPY_BIG", "type": "Array API", "text": "\nIf a byteorder of `NPY_IGNORE` is encountered it is left alone. If newendian\nis `NPY_SWAP`, then all byte-orders are swapped. Other valid newendian values\nare `NPY_NATIVE`, `NPY_LITTLE`, and `NPY_BIG` which all cause the returned\ndata-typed descriptor (and all it\u2019s referenced data-type descriptors) to have\nthe corresponding byte- order.\n\n"}, {"name": "NPY_BIG_ENDIAN", "path": "reference/c-api/config#c.NPY_BIG_ENDIAN", "type": "System configuration", "text": "\n\n"}, {"name": "npy_bool contiguous", "path": "reference/c-api/types-and-structures#c.PyArrayIterObject.contiguous", "type": "Python Types and C-Structures", "text": "\nThis flag is true if the underlying array is `NPY_ARRAY_C_CONTIGUOUS`. It is\nused to simplify calculations when possible.\n\n"}, {"name": "npy_bool nonzero()", "path": "reference/c-api/types-and-structures#c.PyArray_ArrFuncs.nonzero", "type": "Python Types and C-Structures", "text": "\nA pointer to a function that returns TRUE if the item of `arr` pointed to by\n`data` is nonzero. This function can deal with misbehaved arrays.\n\n"}, {"name": "npy_bool NpyIter_HasDelayedBufAlloc()", "path": "reference/c-api/iterator#c.NpyIter_HasDelayedBufAlloc", "type": "Array Iterator API", "text": "\nReturns 1 if the flag `NPY_ITER_DELAY_BUFALLOC` was passed to the iterator\nconstructor, and no call to one of the Reset functions has been done yet, 0\notherwise.\n\n"}, {"name": "npy_bool NpyIter_HasExternalLoop()", "path": "reference/c-api/iterator#c.NpyIter_HasExternalLoop", "type": "Array Iterator API", "text": "\nReturns 1 if the caller needs to handle the inner-most 1-dimensional loop, or\n0 if the iterator handles all looping. This is controlled by the constructor\nflag `NPY_ITER_EXTERNAL_LOOP` or `NpyIter_EnableExternalLoop`.\n\n"}, {"name": "npy_bool NpyIter_HasIndex()", "path": "reference/c-api/iterator#c.NpyIter_HasIndex", "type": "Array Iterator API", "text": "\nReturns 1 if the iterator was created with the `NPY_ITER_C_INDEX` or\n`NPY_ITER_F_INDEX` flag, 0 otherwise.\n\n"}, {"name": "npy_bool NpyIter_HasMultiIndex()", "path": "reference/c-api/iterator#c.NpyIter_HasMultiIndex", "type": "Array Iterator API", "text": "\nReturns 1 if the iterator was created with the `NPY_ITER_MULTI_INDEX` flag, 0\notherwise.\n\n"}, {"name": "npy_bool NpyIter_IsBuffered()", "path": "reference/c-api/iterator#c.NpyIter_IsBuffered", "type": "Array Iterator API", "text": "\nReturns 1 if the iterator was created with the `NPY_ITER_BUFFERED` flag, 0\notherwise.\n\n"}, {"name": "npy_bool NpyIter_IsFirstVisit()", "path": "reference/c-api/iterator#c.NpyIter_IsFirstVisit", "type": "Array Iterator API", "text": "\nNew in version 1.7.\n\n"}, {"name": "npy_bool NpyIter_IsGrowInner()", "path": "reference/c-api/iterator#c.NpyIter_IsGrowInner", "type": "Array Iterator API", "text": "\nReturns 1 if the iterator was created with the `NPY_ITER_GROWINNER` flag, 0\notherwise.\n\n"}, {"name": "npy_bool NpyIter_RequiresBuffering()", "path": "reference/c-api/iterator#c.NpyIter_RequiresBuffering", "type": "Array Iterator API", "text": "\nReturns 1 if the iterator requires buffering, which occurs when an operand\nneeds conversion or alignment and so cannot be used directly.\n\n"}, {"name": "npy_bool PyArray_EquivArrTypes()", "path": "reference/c-api/array#c.PyArray_EquivArrTypes", "type": "Array API", "text": "\nReturn `NPY_TRUE` if a1 and a2 are arrays with equivalent types for this\nplatform.\n\n"}, {"name": "npy_bool PyArray_EquivTypenums()", "path": "reference/c-api/array#c.PyArray_EquivTypenums", "type": "Array API", "text": "\nSpecial case of `PyArray_EquivTypes` (\u2026) that does not accept flexible data\ntypes but may be easier to call.\n\n"}, {"name": "npy_bool PyArray_EquivTypes()", "path": "reference/c-api/array#c.PyArray_EquivTypes", "type": "Array API", "text": "\nReturn `NPY_TRUE` if type1 and type2 actually represent equivalent types for\nthis platform (the fortran member of each type is ignored). For example, on\n32-bit platforms, `NPY_LONG` and `NPY_INT` are equivalent. Otherwise return\n`NPY_FALSE`.\n\n"}, {"name": "NPY_BYTE_ORDER", "path": "reference/c-api/config#c.NPY_BYTE_ORDER", "type": "System configuration", "text": "\nNew in version 1.3.0.\n\n"}, {"name": "NPY_CLIP", "path": "reference/c-api/array#c.PyArray_Choose.NPY_CLIP", "type": "Array API", "text": "\nall values are clipped to the region [0, len(op) ).\n\n"}, {"name": "npy_copysign()", "path": "reference/c-api/coremath#c.npy_copysign", "type": "NumPy core libraries", "text": "\nThis is a function equivalent to C99 copysign: return x with the same sign as\ny. Works for any value, including inf and nan. Single and extended precisions\nare available with suffix f and l.\n\n"}, {"name": "NPY_CPU_AMD64", "path": "reference/c-api/config#c.NPY_CPU_AMD64", "type": "System configuration", "text": "\n\n"}, {"name": "NPY_CPU_IA64", "path": "reference/c-api/config#c.NPY_CPU_IA64", "type": "System configuration", "text": "\n\n"}, {"name": "NPY_CPU_LITTLE", "path": "reference/c-api/config#c.PyArray_GetEndianness.NPY_CPU_LITTLE", "type": "System configuration", "text": "\n\n"}, {"name": "NPY_CPU_PARISC", "path": "reference/c-api/config#c.NPY_CPU_PARISC", "type": "System configuration", "text": "\nNew in version 1.3.0.\n\n"}, {"name": "NPY_CPU_PPC", "path": "reference/c-api/config#c.NPY_CPU_PPC", "type": "System configuration", "text": "\n\n"}, {"name": "NPY_CPU_PPC64", "path": "reference/c-api/config#c.NPY_CPU_PPC64", "type": "System configuration", "text": "\n\n"}, {"name": "NPY_CPU_S390", "path": "reference/c-api/config#c.NPY_CPU_S390", "type": "System configuration", "text": "\n\n"}, {"name": "NPY_CPU_SPARC", "path": "reference/c-api/config#c.NPY_CPU_SPARC", "type": "System configuration", "text": "\n\n"}, {"name": "NPY_CPU_SPARC64", "path": "reference/c-api/config#c.NPY_CPU_SPARC64", "type": "System configuration", "text": "\n\n"}, {"name": "NPY_CPU_UNKNOWN_ENDIAN", "path": "reference/c-api/config#c.PyArray_GetEndianness.NPY_CPU_UNKNOWN_ENDIAN", "type": "System configuration", "text": "\n\n"}, {"name": "NPY_DISABLE_C_API", "path": "reference/c-api/array#c.NPY_DISABLE_C_API", "type": "Array API", "text": "\nPlace after code that needs to call the Python C-API (to re-release the GIL).\n\n"}, {"name": "NPY_END_ALLOW_THREADS", "path": "reference/c-api/array#c.NPY_END_ALLOW_THREADS", "type": "Array API", "text": "\nEquivalent to `Py_END_ALLOW_THREADS` except it uses `NPY_ALLOW_THREADS` to\ndetermine if the macro if replaced with white-space or not.\n\n"}, {"name": "NPY_END_THREADS", "path": "reference/c-api/array#c.NPY_END_THREADS", "type": "Array API", "text": "\nPlace right after code that does not need the Python interpreter. This macro\nacquires the GIL and restores the Python state from the saved variable.\n\n"}, {"name": "NPY_EULER", "path": "reference/c-api/coremath#c.NPY_EULER", "type": "NumPy core libraries", "text": "\n\\\\(\\lim_{n\\rightarrow\\infty}({\\sum_{k=1}^n{\\frac{1}{k}}-\\ln n})\\\\)\n\n"}, {"name": "NPY_FAIL", "path": "reference/c-api/array#c.NPY_FAIL", "type": "Array API", "text": "\nThe return value of failed converter functions which are called using the \u201cO&\u201d\nsyntax in `PyArg_ParseTuple`-like functions.\n\n"}, {"name": "NPY_FALSE", "path": "reference/c-api/array#c.NPY_FALSE", "type": "Array API", "text": "\nDefined as 0 for use with Bool.\n\n"}, {"name": "NPY_FEATURE_VERSION", "path": "reference/c-api/array#c.NPY_FEATURE_VERSION", "type": "Array API", "text": "\nThe current version of the C-API.\n\n"}, {"name": "npy_half npy_double_to_half()", "path": "reference/c-api/coremath#c.npy_double_to_half", "type": "NumPy core libraries", "text": "\nConverts a double-precision float to a half-precision float. The value is\nrounded to the nearest representable half, with ties going to the nearest\neven. If the value is too small or too big, the system\u2019s floating point\nunderflow or overflow bit will be set.\n\n"}, {"name": "npy_half npy_float_to_half()", "path": "reference/c-api/coremath#c.npy_float_to_half", "type": "NumPy core libraries", "text": "\nConverts a single-precision float to a half-precision float. The value is\nrounded to the nearest representable half, with ties going to the nearest\neven. If the value is too small or too big, the system\u2019s floating point\nunderflow or overflow bit will be set.\n\n"}, {"name": "npy_half npy_half_copysign()", "path": "reference/c-api/coremath#c.npy_half_copysign", "type": "NumPy core libraries", "text": "\nReturns the value of x with the sign bit copied from y. Works for any value,\nincluding Inf and NaN.\n\n"}, {"name": "npy_half npy_half_nextafter()", "path": "reference/c-api/coremath#c.npy_half_nextafter", "type": "NumPy core libraries", "text": "\nThis is the same for half-precision float as npy_nextafter and npy_nextafterf\ndescribed in the low-level floating point section.\n\n"}, {"name": "npy_half npy_half_spacing()", "path": "reference/c-api/coremath#c.npy_half_spacing", "type": "NumPy core libraries", "text": "\nThis is the same for half-precision float as npy_spacing and npy_spacingf\ndescribed in the low-level floating point section.\n\n"}, {"name": "NPY_HALF_NAN", "path": "reference/c-api/coremath#c.NPY_HALF_NAN", "type": "NumPy core libraries", "text": "\nThis macro is defined to a NaN value, guaranteed to have its sign bit unset.\n\n"}, {"name": "NPY_HALF_NEGONE", "path": "reference/c-api/coremath#c.NPY_HALF_NEGONE", "type": "NumPy core libraries", "text": "\nThis macro is defined to -1.0.\n\n"}, {"name": "NPY_HALF_NINF", "path": "reference/c-api/coremath#c.NPY_HALF_NINF", "type": "NumPy core libraries", "text": "\nThis macro is defined to -inf.\n\n"}, {"name": "NPY_HALF_NZERO", "path": "reference/c-api/coremath#c.NPY_HALF_NZERO", "type": "NumPy core libraries", "text": "\nThis macro is defined to negative zero.\n\n"}, {"name": "NPY_HALF_ONE", "path": "reference/c-api/coremath#c.NPY_HALF_ONE", "type": "NumPy core libraries", "text": "\nThis macro is defined to 1.0.\n\n"}, {"name": "NPY_HALF_PINF", "path": "reference/c-api/coremath#c.NPY_HALF_PINF", "type": "NumPy core libraries", "text": "\nThis macro is defined to +inf.\n\n"}, {"name": "NPY_HALF_PZERO", "path": "reference/c-api/coremath#c.NPY_HALF_PZERO", "type": "NumPy core libraries", "text": "\nThis macro is defined to positive zero.\n\n"}, {"name": "npy_hash_t *hash", "path": "reference/c-api/types-and-structures#c.NPY_USE_SETITEM.hash", "type": "Python Types and C-Structures", "text": "\nCurrently unused. Reserved for future use in caching hash values.\n\n"}, {"name": "NPY_IGNORE", "path": "reference/c-api/array#c.NPY_IGNORE", "type": "Array API", "text": "\nIf a byteorder of `NPY_IGNORE` is encountered it is left alone. If newendian\nis `NPY_SWAP`, then all byte-orders are swapped. Other valid newendian values\nare `NPY_NATIVE`, `NPY_LITTLE`, and `NPY_BIG` which all cause the returned\ndata-typed descriptor (and all it\u2019s referenced data-type descriptors) to have\nthe corresponding byte- order.\n\n"}, {"name": "NPY_INFINITY", "path": "reference/c-api/coremath#c.NPY_INFINITY", "type": "NumPy core libraries", "text": "\nThis macro is defined to a positive inf. The corresponding single and\nextension precision macro are available with the suffix F and L.\n\n"}, {"name": "npy_int32 random_positive_int32()", "path": "reference/random/c-api#c.random_positive_int32", "type": "C API for random", "text": "\n\n"}, {"name": "npy_int64 random_binomial()", "path": "reference/random/c-api#c.random_binomial", "type": "C API for random", "text": "\n\n"}, {"name": "npy_int64 random_geometric()", "path": "reference/random/c-api#c.random_geometric", "type": "C API for random", "text": "\n\n"}, {"name": "npy_int64 random_geometric_inversion()", "path": "reference/random/c-api#c.random_geometric_inversion", "type": "C API for random", "text": "\n\n"}, {"name": "npy_int64 random_geometric_search()", "path": "reference/random/c-api#c.random_geometric_search", "type": "C API for random", "text": "\n\n"}, {"name": "npy_int64 random_hypergeometric()", "path": "reference/random/c-api#c.random_hypergeometric", "type": "C API for random", "text": "\n\n"}, {"name": "npy_int64 random_logseries()", "path": "reference/random/c-api#c.random_logseries", "type": "C API for random", "text": "\n\n"}, {"name": "npy_int64 random_negative_binomial()", "path": "reference/random/c-api#c.random_negative_binomial", "type": "C API for random", "text": "\n\n"}, {"name": "npy_int64 random_poisson()", "path": "reference/random/c-api#c.random_poisson", "type": "C API for random", "text": "\n\n"}, {"name": "npy_int64 random_positive_int()", "path": "reference/random/c-api#c.random_positive_int", "type": "C API for random", "text": "\n\n"}, {"name": "npy_int64 random_positive_int64()", "path": "reference/random/c-api#c.random_positive_int64", "type": "C API for random", "text": "\n\n"}, {"name": "npy_int64 random_zipf()", "path": "reference/random/c-api#c.random_zipf", "type": "C API for random", "text": "\n\n"}, {"name": "npy_intp *backstrides", "path": "reference/c-api/types-and-structures#c.PyArrayIterObject.backstrides", "type": "Python Types and C-Structures", "text": "\nHow many bytes needed to jump from the end of a dimension back to its\nbeginning. Note that `backstrides[k] == strides[k] * dims_m1[k]`, but it is\nstored here as an optimization.\n\n"}, {"name": "npy_intp *coordinates", "path": "reference/c-api/types-and-structures#c.PyArrayIterObject.coordinates", "type": "Python Types and C-Structures", "text": "\nAn \\\\(N\\\\) -dimensional index into the array.\n\n"}, {"name": "npy_intp *core_dim_sizes", "path": "reference/c-api/types-and-structures#c.PyUFuncObject.core_dim_sizes", "type": "Python Types and C-Structures", "text": "\nFor each distinct core dimension, the possible frozen size if\n`UFUNC_CORE_DIM_SIZE_INFERRED` is `0`\n\n"}, {"name": "npy_intp *dimensions", "path": "reference/c-api/types-and-structures#c.PyArrayMultiIterObject.dimensions", "type": "Python Types and C-Structures", "text": "\nThe shape of the broadcasted result (only `nd` slots are used).\n\n"}, {"name": "npy_intp *dims_m1", "path": "reference/c-api/types-and-structures#c.PyArrayIterObject.dims_m1", "type": "Python Types and C-Structures", "text": "\nThe size of the array minus 1 in each dimension.\n\n"}, {"name": "npy_intp *factors", "path": "reference/c-api/types-and-structures#c.PyArrayIterObject.factors", "type": "Python Types and C-Structures", "text": "\nThis array is used in computing an N-d index from a 1-d index. It contains\nneeded products of the dimensions.\n\n"}, {"name": "npy_intp *NpyIter_GetAxisStrideArray()", "path": "reference/c-api/iterator#c.NpyIter_GetAxisStrideArray", "type": "Array Iterator API", "text": "\nGets the array of strides for the specified axis. Requires that the iterator\nbe tracking a multi-index, and that buffering not be enabled.\n\n"}, {"name": "npy_intp *NpyIter_GetIndexPtr()", "path": "reference/c-api/iterator#c.NpyIter_GetIndexPtr", "type": "Array Iterator API", "text": "\nThis gives back a pointer to the index being tracked, or NULL if no index is\nbeing tracked. It is only usable if one of the flags `NPY_ITER_C_INDEX` or\n`NPY_ITER_F_INDEX` were specified during construction.\n\n"}, {"name": "npy_intp *NpyIter_GetInnerLoopSizePtr()", "path": "reference/c-api/iterator#c.NpyIter_GetInnerLoopSizePtr", "type": "Array Iterator API", "text": "\nReturns a pointer to the number of iterations the inner loop should execute.\n\n"}, {"name": "npy_intp *NpyIter_GetInnerStrideArray()", "path": "reference/c-api/iterator#c.NpyIter_GetInnerStrideArray", "type": "Array Iterator API", "text": "\nReturns a pointer to an array of the `nop` strides, one for each iterated\nobject, to be used by the inner loop.\n\n"}, {"name": "npy_intp *PyArray_DIMS()", "path": "reference/c-api/array#c.PyArray_DIMS", "type": "Array API", "text": "\nReturns a pointer to the dimensions/shape of the array. The number of elements\nmatches the number of dimensions of the array. Can return `NULL` for\n0-dimensional arrays.\n\n"}, {"name": "npy_intp *PyArray_SHAPE()", "path": "reference/c-api/array#c.PyArray_SHAPE", "type": "Array API", "text": "\nNew in version 1.7.\n\n"}, {"name": "npy_intp *PyArray_STRIDES()", "path": "reference/c-api/array#c.PyArray_STRIDES", "type": "Array API", "text": "\nReturns a pointer to the strides of the array. The number of elements matches\nthe number of dimensions of the array.\n\n"}, {"name": "npy_intp *PyDimMem_NEW()", "path": "reference/c-api/array#c.PyDimMem_NEW", "type": "Array API", "text": "\n\n"}, {"name": "npy_intp *PyDimMem_RENEW()", "path": "reference/c-api/array#c.PyDimMem_RENEW", "type": "Array API", "text": "\nMacros to allocate, free, and reallocate dimension and strides memory.\n\n"}, {"name": "npy_intp *shape", "path": "reference/c-api/types-and-structures#c.PyArrayInterface.shape", "type": "Python Types and C-Structures", "text": "\nAn array containing the size of the array in each dimension.\n\n"}, {"name": "npy_intp *strides", "path": "reference/c-api/types-and-structures#c.NPY_AO.strides", "type": "Python Types and C-Structures", "text": "\nAn array of integers providing for each dimension the number of bytes that\nmust be skipped to get to the next element in that dimension. Associated with\nmacro `PyArray_STRIDES`.\n\n"}, {"name": "npy_intp *strides", "path": "reference/c-api/types-and-structures#c.PyArrayIterObject.strides", "type": "Python Types and C-Structures", "text": "\nThe strides of the array. How many bytes needed to jump to the next element in\neach dimension.\n\n"}, {"name": "npy_intp *strides", "path": "reference/c-api/types-and-structures#c.PyArrayInterface.strides", "type": "Python Types and C-Structures", "text": "\nAn array containing the number of bytes to jump to get to the next element in\neach dimension.\n\n"}, {"name": "npy_intp dimensions", "path": "reference/c-api/types-and-structures#c.NPY_AO.dimensions", "type": "Python Types and C-Structures", "text": "\nAn array of integers providing the shape in each dimension as long as nd\n\\\\(\\geq\\\\) 1\\. The integer is always large enough to hold a pointer on the\nplatform, so the dimension size is only limited by memory. `PyArray_DIMS` is\nthe macro associated with this data member.\n\n"}, {"name": "npy_intp index", "path": "reference/c-api/types-and-structures#c.PyArrayIterObject.index", "type": "Python Types and C-Structures", "text": "\nThe current 1-d index into the array.\n\n"}, {"name": "npy_intp index", "path": "reference/c-api/types-and-structures#c.PyArrayMultiIterObject.index", "type": "Python Types and C-Structures", "text": "\nThe current (1-d) index into the broadcasted result.\n\n"}, {"name": "npy_intp len", "path": "reference/c-api/types-and-structures#c.PyArray_Chunk.len", "type": "Python Types and C-Structures", "text": "\nThe length of the segment in bytes.\n\n"}, {"name": "npy_intp NpyIter_GetBufferSize()", "path": "reference/c-api/iterator#c.NpyIter_GetBufferSize", "type": "Array Iterator API", "text": "\nIf the iterator is buffered, returns the size of the buffer being used,\notherwise returns 0.\n\n"}, {"name": "npy_intp NpyIter_GetIterIndex()", "path": "reference/c-api/iterator#c.NpyIter_GetIterIndex", "type": "Array Iterator API", "text": "\nGets the `iterindex` of the iterator, which is an index matching the iteration\norder of the iterator.\n\n"}, {"name": "npy_intp NpyIter_GetIterSize()", "path": "reference/c-api/iterator#c.NpyIter_GetIterSize", "type": "Array Iterator API", "text": "\nReturns the number of elements being iterated. This is the product of all the\ndimensions in the shape. When a multi index is being tracked (and\n`NpyIter_RemoveAxis` may be called) the size may be `-1` to indicate an\niterator is too large. Such an iterator is invalid, but may become valid after\n`NpyIter_RemoveAxis` is called. It is not necessary to check for this case.\n\n"}, {"name": "npy_intp PyArray_CountNonzero()", "path": "reference/c-api/array#c.PyArray_CountNonzero", "type": "Array API", "text": "\nNew in version 1.6.\n\n"}, {"name": "npy_intp PyArray_DIM()", "path": "reference/c-api/array#c.PyArray_DIM", "type": "Array API", "text": "\nReturn the shape in the n \\\\(^{\\textrm{th}}\\\\) dimension.\n\n"}, {"name": "npy_intp PyArray_ITEMSIZE()", "path": "reference/c-api/array#c.PyArray_ITEMSIZE", "type": "Array API", "text": "\nReturn the itemsize for the elements of this array.\n\n"}, {"name": "npy_intp PyArray_MultiplyList()", "path": "reference/c-api/array#c.PyArray_MultiplyList", "type": "Array API", "text": "\n\n"}, {"name": "npy_intp PyArray_NBYTES()", "path": "reference/c-api/array#c.PyArray_NBYTES", "type": "Array API", "text": "\nReturns the total number of bytes consumed by the array.\n\n"}, {"name": "npy_intp PyArray_PyIntAsIntp()", "path": "reference/c-api/array#c.PyArray_PyIntAsIntp", "type": "Array API", "text": "\nConvert all kinds of Python objects (including arrays and array scalars) to a\n(platform-pointer-sized) integer. On error, -1 is returned and an exception\nset.\n\n"}, {"name": "npy_intp PyArray_REFCOUNT()", "path": "reference/c-api/array#c.PyArray_REFCOUNT", "type": "Array API", "text": "\nReturns the reference count of any Python object.\n\n"}, {"name": "npy_intp PyArray_Size()", "path": "reference/c-api/array#c.PyArray_Size", "type": "Array API", "text": "\nReturns 0 if obj is not a sub-class of ndarray. Otherwise, returns the total\nnumber of elements in the array. Safer version of `PyArray_SIZE` (obj).\n\n"}, {"name": "npy_intp PyArray_SIZE()", "path": "reference/c-api/array#c.PyArray_SIZE", "type": "Array API", "text": "\nReturns the total size (in number of elements) of the array.\n\n"}, {"name": "npy_intp PyArray_STRIDE()", "path": "reference/c-api/array#c.PyArray_STRIDE", "type": "Array API", "text": "\nReturn the stride in the n \\\\(^{\\textrm{th}}\\\\) dimension.\n\n"}, {"name": "npy_intp size", "path": "reference/c-api/types-and-structures#c.PyArrayIterObject.size", "type": "Python Types and C-Structures", "text": "\nThe total size of the underlying array.\n\n"}, {"name": "npy_intp size", "path": "reference/c-api/types-and-structures#c.PyArrayMultiIterObject.size", "type": "Python Types and C-Structures", "text": "\nThe total broadcasted size.\n\n"}, {"name": "NPY_INTP_FMT", "path": "reference/c-api/dtype#c.NPY_INTP_FMT", "type": "Data Type API", "text": "\n\n"}, {"name": "npy_isfinite()", "path": "reference/c-api/coremath#c.npy_isfinite", "type": "NumPy core libraries", "text": "\nThis is a macro, and is equivalent to C99 isfinite: works for single, double\nand extended precision, and return a non 0 value if x is neither a NaN nor an\ninfinity.\n\n"}, {"name": "npy_isinf()", "path": "reference/c-api/coremath#c.npy_isinf", "type": "NumPy core libraries", "text": "\nThis is a macro, and is equivalent to C99 isinf: works for single, double and\nextended precision, and return a non 0 value if x is infinite (positive and\nnegative).\n\n"}, {"name": "npy_isnan()", "path": "reference/c-api/coremath#c.npy_isnan", "type": "NumPy core libraries", "text": "\nThis is a macro, and is equivalent to C99 isnan: works for single, double and\nextended precision, and return a non 0 value if x is a NaN.\n\n"}, {"name": "NPY_ITEM_IS_POINTER", "path": "reference/c-api/types-and-structures#c.NPY_ITEM_IS_POINTER", "type": "Python Types and C-Structures", "text": "\nIndicates the item is a pointer to some other data-type\n\n"}, {"name": "NPY_ITEM_REFCOUNT", "path": "reference/c-api/types-and-structures#c.NPY_ITEM_REFCOUNT", "type": "Python Types and C-Structures", "text": "\nIndicates that items of this data-type must be reference counted (using\n`Py_INCREF` and `Py_DECREF` ).\n\n"}, {"name": "NPY_ITER_ALIGNED", "path": "reference/c-api/iterator#c.NPY_ITER_ALIGNED", "type": "Array Iterator API", "text": "\n\n"}, {"name": "NPY_ITER_ALLOCATE", "path": "reference/c-api/iterator#c.NPY_ITER_ALLOCATE", "type": "Array Iterator API", "text": "\nThis is for output arrays, and requires that the flag `NPY_ITER_WRITEONLY` or\n`NPY_ITER_READWRITE` be set. If `op[i]` is NULL, creates a new array with the\nfinal broadcast dimensions, and a layout matching the iteration order of the\niterator.\n\n"}, {"name": "NPY_ITER_ARRAYMASK", "path": "reference/c-api/iterator#c.NPY_ITER_ARRAYMASK", "type": "Array Iterator API", "text": "\nNew in version 1.7.\n\n"}, {"name": "NPY_ITER_BUFFERED", "path": "reference/c-api/iterator#c.NPY_ITER_BUFFERED", "type": "Array Iterator API", "text": "\nCauses the iterator to store buffering data, and use buffering to satisfy data\ntype, alignment, and byte-order requirements. To buffer an operand, do not\nspecify the `NPY_ITER_COPY` or `NPY_ITER_UPDATEIFCOPY` flags, because they\nwill override buffering. Buffering is especially useful for Python code using\nthe iterator, allowing for larger chunks of data at once to amortize the\nPython interpreter overhead.\n\n"}, {"name": "NPY_ITER_C_INDEX", "path": "reference/c-api/iterator#c.NPY_ITER_C_INDEX", "type": "Array Iterator API", "text": "\nCauses the iterator to track a raveled flat index matching C order. This\noption cannot be used with `NPY_ITER_F_INDEX`.\n\n"}, {"name": "NPY_ITER_COMMON_DTYPE", "path": "reference/c-api/iterator#c.NPY_ITER_COMMON_DTYPE", "type": "Array Iterator API", "text": "\nCauses the iterator to convert all the operands to a common data type,\ncalculated based on the ufunc type promotion rules. Copying or buffering must\nbe enabled.\n\n"}, {"name": "NPY_ITER_CONTIG", "path": "reference/c-api/iterator#c.NPY_ITER_CONTIG", "type": "Array Iterator API", "text": "\nCauses the iterator to provide data for `op[i]` that is in native byte order,\naligned according to the dtype requirements, contiguous, or any combination.\n\n"}, {"name": "NPY_ITER_COPY", "path": "reference/c-api/iterator#c.NPY_ITER_COPY", "type": "Array Iterator API", "text": "\nAllow a copy of `op[i]` to be made if it does not meet the data type or\nalignment requirements as specified by the constructor flags and parameters.\n\n"}, {"name": "NPY_ITER_COPY_IF_OVERLAP", "path": "reference/c-api/iterator#c.NPY_ITER_COPY_IF_OVERLAP", "type": "Array Iterator API", "text": "\nIf any write operand has overlap with any read operand, eliminate all overlap\nby making temporary copies (enabling UPDATEIFCOPY for write operands, if\nnecessary). A pair of operands has overlap if there is a memory address that\ncontains data common to both arrays.\n\n"}, {"name": "NPY_ITER_DELAY_BUFALLOC", "path": "reference/c-api/iterator#c.NPY_ITER_DELAY_BUFALLOC", "type": "Array Iterator API", "text": "\nWhen buffering is enabled, this delays allocation of the buffers until\n`NpyIter_Reset` or another reset function is called. This flag exists to avoid\nwasteful copying of buffer data when making multiple copies of a buffered\niterator for multi-threaded iteration.\n\n"}, {"name": "NPY_ITER_DONT_NEGATE_STRIDES", "path": "reference/c-api/iterator#c.NPY_ITER_DONT_NEGATE_STRIDES", "type": "Array Iterator API", "text": "\nThis only affects the iterator when `NPY_KEEPORDER` is specified for the order\nparameter. By default with `NPY_KEEPORDER`, the iterator reverses axes which\nhave negative strides, so that memory is traversed in a forward direction.\nThis disables this step. Use this flag if you want to use the underlying\nmemory-ordering of the axes, but don\u2019t want an axis reversed. This is the\nbehavior of `numpy.ravel(a, order='K')`, for instance.\n\n"}, {"name": "NPY_ITER_EXTERNAL_LOOP", "path": "reference/c-api/iterator#c.NPY_ITER_EXTERNAL_LOOP", "type": "Array Iterator API", "text": "\nCauses the iterator to skip iteration of the innermost loop, requiring the\nuser of the iterator to handle it.\n\n"}, {"name": "NPY_ITER_F_INDEX", "path": "reference/c-api/iterator#c.NPY_ITER_F_INDEX", "type": "Array Iterator API", "text": "\nCauses the iterator to track a raveled flat index matching Fortran order. This\noption cannot be used with `NPY_ITER_C_INDEX`.\n\n"}, {"name": "NPY_ITER_GROWINNER", "path": "reference/c-api/iterator#c.NPY_ITER_GROWINNER", "type": "Array Iterator API", "text": "\nWhen buffering is enabled, this allows the size of the inner loop to grow when\nbuffering isn\u2019t necessary. This option is best used if you\u2019re doing a straight\npass through all the data, rather than anything with small cache-friendly\narrays of temporary values for each inner loop.\n\n"}, {"name": "NPY_ITER_MULTI_INDEX", "path": "reference/c-api/iterator#c.NPY_ITER_MULTI_INDEX", "type": "Array Iterator API", "text": "\nCauses the iterator to track a multi-index. This prevents the iterator from\ncoalescing axes to produce bigger inner loops. If the loop is also not\nbuffered and no index is being tracked (`NpyIter_RemoveAxis` can be called),\nthen the iterator size can be `-1` to indicate that the iterator is too large.\nThis can happen due to complex broadcasting and will result in errors being\ncreated when the setting the iterator range, removing the multi index, or\ngetting the next function. However, it is possible to remove axes again and\nuse the iterator normally if the size is small enough after removal.\n\n"}, {"name": "NPY_ITER_NBO", "path": "reference/c-api/iterator#c.NPY_ITER_NBO", "type": "Array Iterator API", "text": "\n\n"}, {"name": "NPY_ITER_NO_BROADCAST", "path": "reference/c-api/iterator#c.NPY_ITER_NO_BROADCAST", "type": "Array Iterator API", "text": "\nEnsures that the input or output matches the iteration dimensions exactly.\n\n"}, {"name": "NPY_ITER_NO_SUBTYPE", "path": "reference/c-api/iterator#c.NPY_ITER_NO_SUBTYPE", "type": "Array Iterator API", "text": "\nFor use with `NPY_ITER_ALLOCATE`, this flag disables allocating an array\nsubtype for the output, forcing it to be a straight ndarray.\n\n"}, {"name": "NPY_ITER_OVERLAP_ASSUME_ELEMENTWISE", "path": "reference/c-api/iterator#c.NPY_ITER_OVERLAP_ASSUME_ELEMENTWISE", "type": "Array Iterator API", "text": "\nIn memory overlap checks, assume that operands with\n`NPY_ITER_OVERLAP_ASSUME_ELEMENTWISE` enabled are accessed only in the\niterator order.\n\n"}, {"name": "NPY_ITER_RANGED", "path": "reference/c-api/iterator#c.NPY_ITER_RANGED", "type": "Array Iterator API", "text": "\nEnables support for iteration of sub-ranges of the full `iterindex` range `[0,\nNpyIter_IterSize(iter))`. Use the function `NpyIter_ResetToIterIndexRange` to\nspecify a range for iteration.\n\n"}, {"name": "NPY_ITER_READONLY", "path": "reference/c-api/iterator#c.NPY_ITER_READONLY", "type": "Array Iterator API", "text": "\n\n"}, {"name": "NPY_ITER_READWRITE", "path": "reference/c-api/iterator#c.NPY_ITER_READWRITE", "type": "Array Iterator API", "text": "\n\n"}, {"name": "NPY_ITER_REDUCE_OK", "path": "reference/c-api/iterator#c.NPY_ITER_REDUCE_OK", "type": "Array Iterator API", "text": "\nPermits writeable operands with a dimension with zero stride and size greater\nthan one. Note that such operands must be read/write.\n\n"}, {"name": "NPY_ITER_REFS_OK", "path": "reference/c-api/iterator#c.NPY_ITER_REFS_OK", "type": "Array Iterator API", "text": "\nIndicates that arrays with reference types (object arrays or structured arrays\ncontaining an object type) may be accepted and used in the iterator. If this\nflag is enabled, the caller must be sure to check whether\nNpyIter_IterationNeedsAPI(iter) is true, in which case it may not release the\nGIL during iteration.\n\n"}, {"name": "NPY_ITER_UPDATEIFCOPY", "path": "reference/c-api/iterator#c.NPY_ITER_UPDATEIFCOPY", "type": "Array Iterator API", "text": "\nTriggers `NPY_ITER_COPY`, and when an array operand is flagged for writing and\nis copied, causes the data in a copy to be copied back to `op[i]` when\n`NpyIter_Deallocate` is called.\n\n"}, {"name": "NPY_ITER_WRITEMASKED", "path": "reference/c-api/iterator#c.NPY_ITER_WRITEMASKED", "type": "Array Iterator API", "text": "\nNew in version 1.7.\n\n"}, {"name": "NPY_ITER_WRITEONLY", "path": "reference/c-api/iterator#c.NPY_ITER_WRITEONLY", "type": "Array Iterator API", "text": "\nIndicate how the user of the iterator will read or write to `op[i]`. Exactly\none of these flags must be specified per operand. Using `NPY_ITER_READWRITE`\nor `NPY_ITER_WRITEONLY` for a user-provided operand may trigger\n`WRITEBACKIFCOPY`` semantics. The data will be written back to the original\narray when `NpyIter_Deallocate` is called.\n\n"}, {"name": "NPY_ITER_ZEROSIZE_OK", "path": "reference/c-api/iterator#c.NPY_ITER_ZEROSIZE_OK", "type": "Array Iterator API", "text": "\nIndicates that arrays with a size of zero should be permitted. Since the\ntypical iteration loop does not naturally work with zero-sized arrays, you\nmust check that the IterSize is larger than zero before entering the iteration\nloop. Currently only the operands are checked, not a forced shape.\n\n"}, {"name": "NPY_LIST_PICKLE", "path": "reference/c-api/types-and-structures#c.NPY_LIST_PICKLE", "type": "Python Types and C-Structures", "text": "\nIndicates arrays of this data-type must be converted to a list before\npickling.\n\n"}, {"name": "NPY_LITTLE", "path": "reference/c-api/array#c.NPY_LITTLE", "type": "Array API", "text": "\nIf a byteorder of `NPY_IGNORE` is encountered it is left alone. If newendian\nis `NPY_SWAP`, then all byte-orders are swapped. Other valid newendian values\nare `NPY_NATIVE`, `NPY_LITTLE`, and `NPY_BIG` which all cause the returned\ndata-typed descriptor (and all it\u2019s referenced data-type descriptors) to have\nthe corresponding byte- order.\n\n"}, {"name": "NPY_LITTLE_ENDIAN", "path": "reference/c-api/config#c.NPY_LITTLE_ENDIAN", "type": "System configuration", "text": "\n\n"}, {"name": "NPY_LOG10E", "path": "reference/c-api/coremath#c.NPY_LOG10E", "type": "NumPy core libraries", "text": "\nLogarithm to base 10 of the Euler constant (\\\\(\\frac{\\ln(e)}{\\ln(10)}\\\\))\n\n"}, {"name": "NPY_LOG2E", "path": "reference/c-api/coremath#c.NPY_LOG2E", "type": "NumPy core libraries", "text": "\nLogarithm to base 2 of the Euler constant (\\\\(\\frac{\\ln(e)}{\\ln(2)}\\\\))\n\n"}, {"name": "NPY_LOGE10", "path": "reference/c-api/coremath#c.NPY_LOGE10", "type": "NumPy core libraries", "text": "\nNatural logarithm of 10 (\\\\(\\ln(10)\\\\))\n\n"}, {"name": "NPY_LOGE2", "path": "reference/c-api/coremath#c.NPY_LOGE2", "type": "NumPy core libraries", "text": "\nNatural logarithm of 2 (\\\\(\\ln(2)\\\\))\n\n"}, {"name": "NPY_LONGDOUBLE_FMT", "path": "reference/c-api/dtype#c.NPY_LONGDOUBLE_FMT", "type": "Data Type API", "text": "\n\n"}, {"name": "NPY_LOOP_END_THREADS", "path": "reference/c-api/ufunc#c.NPY_LOOP_END_THREADS", "type": "UFunc API", "text": "\nUsed in universal function code to re-acquire the Python GIL if it was\nreleased (because loop->obj was not true).\n\n"}, {"name": "NPY_MAX_BUFSIZE", "path": "reference/c-api/array#c.NPY_MAX_BUFSIZE", "type": "Array API", "text": "\nLargest size allowed for the user-settable buffers.\n\n"}, {"name": "NPY_MAXARGS", "path": "reference/c-api/array#c.NPY_MAXARGS", "type": "Array API", "text": "\nThe maximum number of array arguments that can be used in functions.\n\n"}, {"name": "NPY_MAXDIMS", "path": "reference/c-api/array#c.NPY_MAXDIMS", "type": "Array API", "text": "\nThe maximum number of dimensions allowed in arrays.\n\n"}, {"name": "NPY_MIN_BUFSIZE", "path": "reference/c-api/array#c.NPY_MIN_BUFSIZE", "type": "Array API", "text": "\nSmallest size of user-settable internal buffers.\n\n"}, {"name": "NPY_NAN", "path": "reference/c-api/coremath", "type": "NumPy core libraries", "text": "\nNew in version 1.3.0.\n\n"}, {"name": "NPY_NATIVE", "path": "reference/c-api/array#c.NPY_NATIVE", "type": "Array API", "text": "\nIf a byteorder of `NPY_IGNORE` is encountered it is left alone. If newendian\nis `NPY_SWAP`, then all byte-orders are swapped. Other valid newendian values\nare `NPY_NATIVE`, `NPY_LITTLE`, and `NPY_BIG` which all cause the returned\ndata-typed descriptor (and all it\u2019s referenced data-type descriptors) to have\nthe corresponding byte- order.\n\n"}, {"name": "NPY_NEEDS_INIT", "path": "reference/c-api/types-and-structures#c.NPY_NEEDS_INIT", "type": "Python Types and C-Structures", "text": "\nIndicates memory for this data-type must be initialized (set to 0) on\ncreation.\n\n"}, {"name": "NPY_NEEDS_PYAPI", "path": "reference/c-api/types-and-structures#c.NPY_NEEDS_PYAPI", "type": "Python Types and C-Structures", "text": "\nIndicates this data-type requires the Python C-API during access (so don\u2019t\ngive up the GIL if array access is going to be needed).\n\n"}, {"name": "NPY_NEIGHBORHOOD_ITER_CIRCULAR_PADDING", "path": "reference/c-api/array#c.PyArray_NeighborhoodIterNew.NPY_NEIGHBORHOOD_ITER_CIRCULAR_PADDING", "type": "Array API", "text": "\nCircular padding. Outside bounds values will be as if the array was repeated.\nFor example, for the array [1, 2, 3, 4], x[-2] will be 3, x[-2] will be 4,\nx[4] will be 1, x[5] will be 2, etc\u2026\n\n"}, {"name": "NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING", "path": "reference/c-api/array#c.PyArray_NeighborhoodIterNew.NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING", "type": "Array API", "text": "\nConstant padding. Outside bounds values will be the same as the first item in\nfill_value.\n\n"}, {"name": "NPY_NEIGHBORHOOD_ITER_MIRROR_PADDING", "path": "reference/c-api/array#c.PyArray_NeighborhoodIterNew.NPY_NEIGHBORHOOD_ITER_MIRROR_PADDING", "type": "Array API", "text": "\nMirror padding. Outside bounds values will be as if the array items were\nmirrored. For example, for the array [1, 2, 3, 4], x[-2] will be 2, x[-2] will\nbe 1, x[4] will be 4, x[5] will be 1, etc\u2026\n\n"}, {"name": "NPY_NEIGHBORHOOD_ITER_ONE_PADDING", "path": "reference/c-api/array#c.PyArray_NeighborhoodIterNew.NPY_NEIGHBORHOOD_ITER_ONE_PADDING", "type": "Array API", "text": "\nOne padding, Outside bounds values will be 1.\n\n"}, {"name": "NPY_NOTYPE", "path": "reference/c-api/dtype#c.NPY_NOTYPE", "type": "Data Type API", "text": "\nA signal value guaranteed not to be a valid type enumeration number.\n\n"}, {"name": "NPY_NTYPES", "path": "reference/c-api/dtype#c.NPY_NTYPES", "type": "Data Type API", "text": "\nThe total number of built-in NumPy types. The enumeration covers the range\nfrom 0 to NPY_NTYPES-1.\n\n"}, {"name": "NPY_NZERO", "path": "reference/c-api/coremath#c.NPY_NZERO", "type": "NumPy core libraries", "text": "\nThis macro is defined to negative zero (that is with the sign bit set). The\ncorresponding single and extension precision macro are available with the\nsuffix F and L.\n\n"}, {"name": "NPY_OBJECT_DTYPE_FLAGS", "path": "reference/c-api/types-and-structures#c.NPY_USE_SETITEM.NPY_OBJECT_DTYPE_FLAGS", "type": "Python Types and C-Structures", "text": "\nBits set for the object data-type: ( `NPY_LIST_PICKLE` | `NPY_USE_GETITEM` |\n`NPY_ITEM_IS_POINTER` | `NPY_ITEM_REFCOUNT` | `NPY_NEEDS_INIT` |\n`NPY_NEEDS_PYAPI`).\n\n"}, {"name": "NPY_OUT_ARRAY", "path": "reference/c-api/array#c.NPY_OUT_ARRAY", "type": "Array API", "text": "\n`NPY_ARRAY_C_CONTIGUOUS` | `NPY_ARRAY_WRITEABLE` | `NPY_ARRAY_ALIGNED`\n\n"}, {"name": "NPY_PI", "path": "reference/c-api/coremath#c.NPY_PI", "type": "NumPy core libraries", "text": "\nPi (\\\\(\\pi\\\\))\n\n"}, {"name": "NPY_PI_2", "path": "reference/c-api/coremath#c.NPY_PI_2", "type": "NumPy core libraries", "text": "\nPi divided by 2 (\\\\(\\frac{\\pi}{2}\\\\))\n\n"}, {"name": "NPY_PI_4", "path": "reference/c-api/coremath#c.NPY_PI_4", "type": "NumPy core libraries", "text": "\nPi divided by 4 (\\\\(\\frac{\\pi}{4}\\\\))\n\n"}, {"name": "NPY_PZERO", "path": "reference/c-api/coremath#c.NPY_PZERO", "type": "NumPy core libraries", "text": "\nThis macro is defined to positive zero. The corresponding single and extension\nprecision macro are available with the suffix F and L.\n\n"}, {"name": "NPY_SCALAR_PRIORITY", "path": "reference/c-api/array#c.NPY_SCALAR_PRIORITY", "type": "Array API", "text": "\nDefault scalar priority (very small)\n\n"}, {"name": "NPY_SCALARKIND PyArray_ScalarKind()", "path": "reference/c-api/array#c.PyArray_ScalarKind", "type": "Array API", "text": "\nSee the function `PyArray_MinScalarType` for an alternative mechanism\nintroduced in NumPy 1.6.0.\n\n"}, {"name": "NPY_SCALARKIND scalarkind()", "path": "reference/c-api/types-and-structures#c.PyArray_ArrFuncs.scalarkind", "type": "Python Types and C-Structures", "text": "\nA function to determine how scalars of this type should be interpreted. The\nargument is `NULL` or a 0-dimensional array containing the data (if that is\nneeded to determine the kind of scalar). The return value must be of type\n`NPY_SCALARKIND`.\n\n"}, {"name": "NPY_SIGINT_OFF", "path": "reference/c-api/config#c.NPY_SIGINT_OFF", "type": "System configuration", "text": "\n\n"}, {"name": "NPY_SIGINT_ON", "path": "reference/c-api/config#c.NPY_SIGINT_ON", "type": "System configuration", "text": "\n\n"}, {"name": "NPY_SIGJMP_BUF", "path": "reference/c-api/config#c.NPY_SIGJMP_BUF", "type": "System configuration", "text": "\n\n"}, {"name": "NPY_SIGLONGJMP", "path": "reference/c-api/config#c.NPY_SIGLONGJMP", "type": "System configuration", "text": "\n\n"}, {"name": "npy_signbit()", "path": "reference/c-api/coremath#c.npy_signbit", "type": "NumPy core libraries", "text": "\nThis is a macro, and is equivalent to C99 signbit: works for single, double\nand extended precision, and return a non 0 value if x has the signbit set\n(that is the number is negative).\n\n"}, {"name": "NPY_SIGSETJMP", "path": "reference/c-api/config#c.NPY_SIGSETJMP", "type": "System configuration", "text": "\n\n"}, {"name": "NPY_SIZEOF_DOUBLE", "path": "reference/c-api/config#c.NPY_SIZEOF_DOUBLE", "type": "System configuration", "text": "\nsizeof(double)\n\n"}, {"name": "NPY_SIZEOF_FLOAT", "path": "reference/c-api/config#c.NPY_SIZEOF_FLOAT", "type": "System configuration", "text": "\nsizeof(float)\n\n"}, {"name": "NPY_SIZEOF_INT", "path": "reference/c-api/config#c.NPY_SIZEOF_INT", "type": "System configuration", "text": "\nsizeof(int)\n\n"}, {"name": "NPY_SIZEOF_INTP", "path": "reference/c-api/config#c.NPY_SIZEOF_INTP", "type": "System configuration", "text": "\nSize of a pointer on this platform (sizeof(void *))\n\n"}, {"name": "NPY_SIZEOF_LONG", "path": "reference/c-api/config#c.NPY_SIZEOF_LONG", "type": "System configuration", "text": "\nsizeof(long)\n\n"}, {"name": "NPY_SIZEOF_LONG_DOUBLE", "path": "reference/c-api/config#c.NPY_SIZEOF_LONG_DOUBLE", "type": "System configuration", "text": "\n\n"}, {"name": "NPY_SIZEOF_LONGDOUBLE", "path": "reference/c-api/config#c.NPY_SIZEOF_LONGDOUBLE", "type": "System configuration", "text": "\nsizeof(longdouble)\n\n"}, {"name": "NPY_SIZEOF_LONGLONG", "path": "reference/c-api/config#c.NPY_SIZEOF_LONGLONG", "type": "System configuration", "text": "\nsizeof(longlong) where longlong is defined appropriately on the platform.\n\n"}, {"name": "NPY_SIZEOF_PY_INTPTR_T", "path": "reference/c-api/config#c.NPY_SIZEOF_PY_INTPTR_T", "type": "System configuration", "text": "\n\n"}, {"name": "NPY_SIZEOF_PY_LONG_LONG", "path": "reference/c-api/config#c.NPY_SIZEOF_PY_LONG_LONG", "type": "System configuration", "text": "\n\n"}, {"name": "NPY_SIZEOF_SHORT", "path": "reference/c-api/config", "type": "System configuration", "text": "\nWhen NumPy is built, information about system configuration is recorded, and\nis made available for extension modules using NumPy\u2019s C API. These are mostly\ndefined in `numpyconfig.h` (included in `ndarrayobject.h`). The public symbols\nare prefixed by `NPY_*`. NumPy also offers some functions for querying\ninformation about the platform in use.\n\n"}, {"name": "NPY_SUBTYPE_PRIORITY", "path": "reference/c-api/array#c.NPY_SUBTYPE_PRIORITY", "type": "Array API", "text": "\nDefault subtype priority.\n\n"}, {"name": "NPY_SUCCEED", "path": "reference/c-api/array#c.NPY_SUCCEED", "type": "Array API", "text": "\nThe return value of successful converter functions which are called using the\n\u201cO&\u201d syntax in `PyArg_ParseTuple`-like functions.\n\n"}, {"name": "NPY_SWAP", "path": "reference/c-api/array#c.NPY_SWAP", "type": "Array API", "text": "\nIf a byteorder of `NPY_IGNORE` is encountered it is left alone. If newendian\nis `NPY_SWAP`, then all byte-orders are swapped. Other valid newendian values\nare `NPY_NATIVE`, `NPY_LITTLE`, and `NPY_BIG` which all cause the returned\ndata-typed descriptor (and all it\u2019s referenced data-type descriptors) to have\nthe corresponding byte- order.\n\n"}, {"name": "NPY_TRUE", "path": "reference/c-api/array#c.NPY_TRUE", "type": "Array API", "text": "\nDefined as 1 for use with Bool.\n\n"}, {"name": "npy_uint16 npy_doublebits_to_halfbits()", "path": "reference/c-api/coremath#c.npy_doublebits_to_halfbits", "type": "NumPy core libraries", "text": "\nLow-level function which converts a 64-bit double-precision float, stored as a\nuint64, into a 16-bit half-precision float.\n\n"}, {"name": "npy_uint16 npy_floatbits_to_halfbits()", "path": "reference/c-api/coremath#c.npy_floatbits_to_halfbits", "type": "NumPy core libraries", "text": "\nLow-level function which converts a 32-bit single-precision float, stored as a\nuint32, into a 16-bit half-precision float.\n\n"}, {"name": "npy_uint32 *core_dim_flags", "path": "reference/c-api/types-and-structures#c.PyUFuncObject.core_dim_flags", "type": "Python Types and C-Structures", "text": "\nFor each distinct core dimension, a set of `UFUNC_CORE_DIM*` flags\n\n"}, {"name": "npy_uint32 iter_flags", "path": "reference/c-api/types-and-structures#c.PyUFuncObject.iter_flags", "type": "Python Types and C-Structures", "text": "\nOverride the default nditer flags for the ufunc.\n\n"}, {"name": "npy_uint32 npy_halfbits_to_floatbits()", "path": "reference/c-api/coremath#c.npy_halfbits_to_floatbits", "type": "NumPy core libraries", "text": "\nLow-level function which converts a 16-bit half-precision float into a 32-bit\nsingle-precision float, stored as a uint32.\n\n"}, {"name": "npy_uint32 op_flags", "path": "reference/c-api/types-and-structures#c.PyUFuncObject.op_flags", "type": "Python Types and C-Structures", "text": "\nOverride the default operand flags for each ufunc operand.\n\n"}, {"name": "npy_uint64 npy_halfbits_to_doublebits()", "path": "reference/c-api/coremath#c.npy_halfbits_to_doublebits", "type": "NumPy core libraries", "text": "\nLow-level function which converts a 16-bit half-precision float into a 64-bit\ndouble-precision float, stored as a uint64.\n\n"}, {"name": "npy_uint64 random_bounded_uint64()", "path": "reference/random/c-api#c.random_bounded_uint64", "type": "C API for random", "text": "\n\n"}, {"name": "npy_uint64 random_interval()", "path": "reference/random/c-api#c.random_interval", "type": "C API for random", "text": "\n\n"}, {"name": "npy_uint64 random_uint()", "path": "reference/random/c-api#c.random_uint", "type": "C API for random", "text": "\n\n"}, {"name": "NPY_UINTP_FMT", "path": "reference/c-api/dtype#c.NPY_UINTP_FMT", "type": "Data Type API", "text": "\n\n"}, {"name": "NPY_ULONGLONG_FMT", "path": "reference/c-api/dtype#c.NPY_ULONGLONG_FMT", "type": "Data Type API", "text": "\n\n"}, {"name": "NPY_UNLIKELY", "path": "reference/c-api/config#c.NPY_UNLIKELY", "type": "System configuration", "text": "\n\n"}, {"name": "NPY_UNUSED", "path": "reference/c-api/config#c.NPY_UNUSED", "type": "System configuration", "text": "\n\n"}, {"name": "NPY_USE_GETITEM", "path": "reference/c-api/types-and-structures#c.NPY_USE_GETITEM", "type": "Python Types and C-Structures", "text": "\nOn array access use the `f->getitem` function pointer instead of the standard\nconversion to an array scalar. Must use if you don\u2019t define an array scalar to\ngo along with the data-type.\n\n"}, {"name": "NPY_USE_SETITEM", "path": "reference/c-api/types-and-structures#c.NPY_USE_SETITEM", "type": "Python Types and C-Structures", "text": "\nWhen creating a 0-d array from an array scalar use `f->setitem` instead of the\nstandard copy from an array scalar. Must use if you don\u2019t define an array\nscalar to go along with the data-type.\n\n"}, {"name": "NPY_USERDEF", "path": "reference/c-api/dtype#c.NPY_USERDEF", "type": "Data Type API", "text": "\nThe start of type numbers used for Custom Data types.\n\n"}, {"name": "NPY_WRAP", "path": "reference/c-api/array#c.PyArray_Choose.NPY_WRAP", "type": "Array API", "text": "\nwrap values < 0 by adding len(op) and values >=len(op) by subtracting len(op)\nuntil they are in range;\n\n"}, {"name": "NpyAuxData *c_metadata", "path": "reference/c-api/types-and-structures#c.NPY_USE_SETITEM.c_metadata", "type": "Python Types and C-Structures", "text": "\nMetadata specific to the C implementation of the particular dtype. Added for\nNumPy 1.7.0.\n\n"}, {"name": "NpyAuxData *NPY_AUXDATA_CLONE()", "path": "reference/c-api/array#c.NPY_AUXDATA_CLONE", "type": "Array API", "text": "\nA macro which calls the auxdata\u2019s clone function appropriately, returning a\ndeep copy of the auxiliary data.\n\n"}, {"name": "NpyIter *NpyIter_AdvancedNew()", "path": "reference/c-api/iterator#c.NpyIter_AdvancedNew", "type": "Array Iterator API", "text": "\nExtends `NpyIter_MultiNew` with several advanced options providing more\ncontrol over broadcasting and buffering.\n\n"}, {"name": "NpyIter *NpyIter_Copy()", "path": "reference/c-api/iterator#c.NpyIter_Copy", "type": "Array Iterator API", "text": "\nMakes a copy of the given iterator. This function is provided primarily to\nenable multi-threaded iteration of the data.\n\n"}, {"name": "NpyIter *NpyIter_MultiNew()", "path": "reference/c-api/iterator#c.NpyIter_MultiNew", "type": "Array Iterator API", "text": "\nCreates an iterator for broadcasting the `nop` array objects provided in `op`,\nusing regular NumPy broadcasting rules.\n\n"}, {"name": "NpyIter_GetMultiIndexFunc *NpyIter_GetGetMultiIndex()", "path": "reference/c-api/iterator#c.NpyIter_GetGetMultiIndex", "type": "Array Iterator API", "text": "\nReturns a function pointer for getting the current multi-index of the\niterator. Returns NULL if the iterator is not tracking a multi-index. It is\nrecommended that this function pointer be cached in a local variable before\nthe iteration loop.\n\n"}, {"name": "number.__class_getitem__()", "path": "reference/generated/numpy.number.__class_getitem__", "type": "numpy.number.__class_getitem__", "text": "\nmethod\n\n"}, {"name": "NumPy and SWIG", "path": "reference/swig", "type": "NumPy and SWIG", "text": "\n\n"}, {"name": "NumPy benchmarks", "path": "benchmarking", "type": "NumPy benchmarks", "text": "\nBenchmarking NumPy with Airspeed Velocity.\n\n"}, {"name": "NumPy C code explanations", "path": "dev/internals.code-explanations", "type": "Development", "text": "\nFanaticism consists of redoubling your efforts when you have forgotten your\naim. \u2014 George Santayana\n\n"}, {"name": "NumPy C-API", "path": "reference/c-api/index", "type": "NumPy C-API", "text": "\nNumPy provides a C-API to enable users to extend the system and get access to\nthe array object for use in other routines. The best way to truly understand\nthe C-API is to read the source code. If you are unfamiliar with (C) source\ncode, however, this can be a daunting experience at first. Be assured that the\ntask becomes easier with practice, and you may be surprised at how simple the\nC-code can be to understand. Even if you don\u2019t think you can write C-code from\nscratch, it is much easier to understand and modify already-written source\ncode than create it de novo.\n\n"}, {"name": "NumPy for MATLAB users", "path": "user/numpy-for-matlab-users", "type": "User Guide", "text": "\nMATLAB\u00ae and NumPy have a lot in common, but NumPy was created to work with\nPython, not to be a MATLAB clone. This guide will help MATLAB users get\nstarted with NumPy.\n\n"}, {"name": "NumPy fundamentals", "path": "user/basics", "type": "User Guide", "text": "\nThese documents clarify concepts, design decisions, and technical constraints\nin NumPy. This is a great place to understand the fundamental NumPy ideas and\nphilosophy.\n\n"}, {"name": "NumPy governance", "path": "dev/governance/index", "type": "Development", "text": "\n\n"}, {"name": "NumPy How Tos", "path": "user/howtos_index", "type": "User Guide", "text": "\nThese documents are intended as recipes to common tasks using NumPy. For\ndetailed reference documentation of the functions and classes contained in the\npackage, see the API reference.\n\n"}, {"name": "NumPy license", "path": "license", "type": "NumPy license", "text": "\n\n"}, {"name": "NumPy project governance and decision-making", "path": "dev/governance/governance", "type": "Development", "text": "\nThe purpose of this document is to formalize the governance process used by\nthe NumPy project in both ordinary and extraordinary situations, and to\nclarify how decisions are made and how the various elements of our community\ninteract, including the relationship between open source collaborative\ndevelopment and work that may be funded by for-profit or non-profit entities.\n\n"}, {"name": "NumPy user guide", "path": "user/index", "type": "User Guide", "text": "\nThis guide is an overview and explains the important features; details are\nfound in Command Reference.\n\n"}, {"name": "NumPy-specific help functions", "path": "reference/routines.help", "type": "NumPy-specific help functions", "text": "\n`lookfor`(what[, module, import_modules, ...])\n\n"}, {"name": "numpy.absolute()", "path": "reference/generated/numpy.absolute", "type": "numpy.absolute", "text": "\nCalculate the absolute value element-wise.\n\n"}, {"name": "numpy.add()", "path": "reference/generated/numpy.add", "type": "numpy.add", "text": "\nAdd arguments element-wise.\n\n"}, {"name": "numpy.all()", "path": "reference/generated/numpy.all", "type": "numpy.all", "text": "\nTest whether all array elements along a given axis evaluate to True.\n\n"}, {"name": "numpy.allclose()", "path": "reference/generated/numpy.allclose", "type": "numpy.allclose", "text": "\nReturns True if two arrays are element-wise equal within a tolerance.\n\n"}, {"name": "numpy.amax()", "path": "reference/generated/numpy.amax", "type": "numpy.amax", "text": "\nReturn the maximum of an array or maximum along an axis.\n\n"}, {"name": "numpy.amin()", "path": "reference/generated/numpy.amin", "type": "numpy.amin", "text": "\nReturn the minimum of an array or minimum along an axis.\n\n"}, {"name": "numpy.angle()", "path": "reference/generated/numpy.angle", "type": "numpy.angle", "text": "\nReturn the angle of the complex argument.\n\n"}, {"name": "numpy.any()", "path": "reference/generated/numpy.any", "type": "numpy.any", "text": "\nTest whether any array element along a given axis evaluates to True.\n\n"}, {"name": "numpy.append()", "path": "reference/generated/numpy.append", "type": "numpy.append", "text": "\nAppend values to the end of an array.\n\n"}, {"name": "numpy.apply_along_axis()", "path": "reference/generated/numpy.apply_along_axis", "type": "numpy.apply_along_axis", "text": "\nApply a function to 1-D slices along the given axis.\n\n"}, {"name": "numpy.apply_over_axes()", "path": "reference/generated/numpy.apply_over_axes", "type": "numpy.apply_over_axes", "text": "\nApply a function repeatedly over multiple axes.\n\n"}, {"name": "numpy.arange()", "path": "reference/generated/numpy.arange", "type": "numpy.arange", "text": "\nReturn evenly spaced values within a given interval.\n\n"}, {"name": "numpy.arccos()", "path": "reference/generated/numpy.arccos", "type": "numpy.arccos", "text": "\nTrigonometric inverse cosine, element-wise.\n\n"}, {"name": "numpy.arccosh()", "path": "reference/generated/numpy.arccosh", "type": "numpy.arccosh", "text": "\nInverse hyperbolic cosine, element-wise.\n\n"}, {"name": "numpy.arcsin()", "path": "reference/generated/numpy.arcsin", "type": "numpy.arcsin", "text": "\nInverse sine, element-wise.\n\n"}, {"name": "numpy.arcsinh()", "path": "reference/generated/numpy.arcsinh", "type": "numpy.arcsinh", "text": "\nInverse hyperbolic sine element-wise.\n\n"}, {"name": "numpy.arctan()", "path": "reference/generated/numpy.arctan", "type": "numpy.arctan", "text": "\nTrigonometric inverse tangent, element-wise.\n\n"}, {"name": "numpy.arctan2()", "path": "reference/generated/numpy.arctan2", "type": "numpy.arctan2", "text": "\nElement-wise arc tangent of `x1/x2` choosing the quadrant correctly.\n\n"}, {"name": "numpy.arctanh()", "path": "reference/generated/numpy.arctanh", "type": "numpy.arctanh", "text": "\nInverse hyperbolic tangent element-wise.\n\n"}, {"name": "numpy.argmax()", "path": "reference/generated/numpy.argmax", "type": "numpy.argmax", "text": "\nReturns the indices of the maximum values along an axis.\n\n"}, {"name": "numpy.argmin()", "path": "reference/generated/numpy.argmin", "type": "numpy.argmin", "text": "\nReturns the indices of the minimum values along an axis.\n\n"}, {"name": "numpy.argpartition()", "path": "reference/generated/numpy.argpartition", "type": "numpy.argpartition", "text": "\nPerform an indirect partition along the given axis using the algorithm\nspecified by the `kind` keyword. It returns an array of indices of the same\nshape as `a` that index data along the given axis in partitioned order.\n\n"}, {"name": "numpy.argsort()", "path": "reference/generated/numpy.argsort", "type": "numpy.argsort", "text": "\nReturns the indices that would sort an array.\n\n"}, {"name": "numpy.argwhere()", "path": "reference/generated/numpy.argwhere", "type": "numpy.argwhere", "text": "\nFind the indices of array elements that are non-zero, grouped by element.\n\n"}, {"name": "numpy.around()", "path": "reference/generated/numpy.around", "type": "numpy.around", "text": "\nEvenly round to the given number of decimals.\n\n"}, {"name": "numpy.array()", "path": "reference/generated/numpy.array", "type": "numpy.array", "text": "\nCreate an array.\n\n"}, {"name": "numpy.array2string()", "path": "reference/generated/numpy.array2string", "type": "numpy.array2string", "text": "\nReturn a string representation of an array.\n\n"}, {"name": "numpy.array_equal()", "path": "reference/generated/numpy.array_equal", "type": "numpy.array_equal", "text": "\nTrue if two arrays have the same shape and elements, False otherwise.\n\n"}, {"name": "numpy.array_equiv()", "path": "reference/generated/numpy.array_equiv", "type": "numpy.array_equiv", "text": "\nReturns True if input arrays are shape consistent and all elements equal.\n\n"}, {"name": "numpy.array_repr()", "path": "reference/generated/numpy.array_repr", "type": "numpy.array_repr", "text": "\nReturn the string representation of an array.\n\n"}, {"name": "numpy.array_split()", "path": "reference/generated/numpy.array_split", "type": "numpy.array_split", "text": "\nSplit an array into multiple sub-arrays.\n\n"}, {"name": "numpy.array_str()", "path": "reference/generated/numpy.array_str", "type": "numpy.array_str", "text": "\nReturn a string representation of the data in an array.\n\n"}, {"name": "numpy.asanyarray()", "path": "reference/generated/numpy.asanyarray", "type": "numpy.asanyarray", "text": "\nConvert the input to an ndarray, but pass ndarray subclasses through.\n\n"}, {"name": "numpy.asarray()", "path": "reference/generated/numpy.asarray", "type": "numpy.asarray", "text": "\nConvert the input to an array.\n\n"}, {"name": "numpy.asarray_chkfinite()", "path": "reference/generated/numpy.asarray_chkfinite", "type": "numpy.asarray_chkfinite", "text": "\nConvert the input to an array, checking for NaNs or Infs.\n\n"}, {"name": "numpy.ascontiguousarray()", "path": "reference/generated/numpy.ascontiguousarray", "type": "numpy.ascontiguousarray", "text": "\nReturn a contiguous array (ndim >= 1) in memory (C order).\n\n"}, {"name": "numpy.asfarray()", "path": "reference/generated/numpy.asfarray", "type": "numpy.asfarray", "text": "\nReturn an array converted to a float type.\n\n"}, {"name": "numpy.asfortranarray()", "path": "reference/generated/numpy.asfortranarray", "type": "numpy.asfortranarray", "text": "\nReturn an array (ndim >= 1) laid out in Fortran order in memory.\n\n"}, {"name": "numpy.asmatrix()", "path": "reference/generated/numpy.asmatrix", "type": "numpy.asmatrix", "text": "\nInterpret the input as a matrix.\n\n"}, {"name": "numpy.asscalar()", "path": "reference/generated/numpy.asscalar", "type": "numpy.asscalar", "text": "\nConvert an array of size 1 to its scalar equivalent.\n\n"}, {"name": "numpy.atleast_1d()", "path": "reference/generated/numpy.atleast_1d", "type": "numpy.atleast_1d", "text": "\nConvert inputs to arrays with at least one dimension.\n\n"}, {"name": "numpy.atleast_2d()", "path": "reference/generated/numpy.atleast_2d", "type": "numpy.atleast_2d", "text": "\nView inputs as arrays with at least two dimensions.\n\n"}, {"name": "numpy.atleast_3d()", "path": "reference/generated/numpy.atleast_3d", "type": "numpy.atleast_3d", "text": "\nView inputs as arrays with at least three dimensions.\n\n"}, {"name": "numpy.average()", "path": "reference/generated/numpy.average", "type": "numpy.average", "text": "\nCompute the weighted average along the specified axis.\n\n"}, {"name": "numpy.AxisError()", "path": "reference/generated/numpy.axiserror", "type": "numpy.AxisError", "text": "\nAxis supplied was invalid.\n\n"}, {"name": "numpy.bartlett()", "path": "reference/generated/numpy.bartlett", "type": "numpy.bartlett", "text": "\nReturn the Bartlett window.\n\n"}, {"name": "numpy.base_repr()", "path": "reference/generated/numpy.base_repr", "type": "numpy.base_repr", "text": "\nReturn a string representation of a number in the given base system.\n\n"}, {"name": "numpy.binary_repr()", "path": "reference/generated/numpy.binary_repr", "type": "numpy.binary_repr", "text": "\nReturn the binary representation of the input number as a string.\n\n"}, {"name": "numpy.bincount()", "path": "reference/generated/numpy.bincount", "type": "numpy.bincount", "text": "\nCount number of occurrences of each value in array of non-negative ints.\n\n"}, {"name": "numpy.bitwise_and()", "path": "reference/generated/numpy.bitwise_and", "type": "numpy.bitwise_and", "text": "\nCompute the bit-wise AND of two arrays element-wise.\n\n"}, {"name": "numpy.bitwise_or()", "path": "reference/generated/numpy.bitwise_or", "type": "numpy.bitwise_or", "text": "\nCompute the bit-wise OR of two arrays element-wise.\n\n"}, {"name": "numpy.bitwise_xor()", "path": "reference/generated/numpy.bitwise_xor", "type": "numpy.bitwise_xor", "text": "\nCompute the bit-wise XOR of two arrays element-wise.\n\n"}, {"name": "numpy.blackman()", "path": "reference/generated/numpy.blackman", "type": "numpy.blackman", "text": "\nReturn the Blackman window.\n\n"}, {"name": "numpy.block()", "path": "reference/generated/numpy.block", "type": "numpy.block", "text": "\nAssemble an nd-array from nested lists of blocks.\n\n"}, {"name": "numpy.bmat()", "path": "reference/generated/numpy.bmat", "type": "numpy.bmat", "text": "\nBuild a matrix object from a string, nested sequence, or array.\n\n"}, {"name": "numpy.broadcast", "path": "reference/generated/numpy.broadcast", "type": "numpy.broadcast", "text": "\nProduce an object that mimics broadcasting.\n\n"}, {"name": "numpy.broadcast_arrays()", "path": "reference/generated/numpy.broadcast_arrays", "type": "numpy.broadcast_arrays", "text": "\nBroadcast any number of arrays against each other.\n\n"}, {"name": "numpy.broadcast_shapes()", "path": "reference/generated/numpy.broadcast_shapes", "type": "numpy.broadcast_shapes", "text": "\nBroadcast the input shapes into a single shape.\n\n"}, {"name": "numpy.broadcast_to()", "path": "reference/generated/numpy.broadcast_to", "type": "numpy.broadcast_to", "text": "\nBroadcast an array to a new shape.\n\n"}, {"name": "numpy.busday_count()", "path": "reference/generated/numpy.busday_count", "type": "numpy.busday_count", "text": "\nCounts the number of valid days between `begindates` and `enddates`, not\nincluding the day of `enddates`.\n\n"}, {"name": "numpy.busday_offset()", "path": "reference/generated/numpy.busday_offset", "type": "numpy.busday_offset", "text": "\nFirst adjusts the date to fall on a valid day according to the `roll` rule,\nthen applies offsets to the given dates counted in valid days.\n\n"}, {"name": "numpy.busdaycalendar()", "path": "reference/generated/numpy.busdaycalendar", "type": "numpy.busdaycalendar", "text": "\nA business day calendar object that efficiently stores information defining\nvalid days for the busday family of functions.\n\n"}, {"name": "numpy.byte", "path": "reference/arrays.scalars#numpy.byte", "type": "Scalars", "text": "\nSigned integer type, compatible with C `char`.\n\n"}, {"name": "numpy.byte_bounds()", "path": "reference/generated/numpy.byte_bounds", "type": "numpy.byte_bounds", "text": "\nReturns pointers to the end-points of an array.\n\n"}, {"name": "numpy.bytes_", "path": "reference/arrays.scalars#numpy.bytes_", "type": "Scalars", "text": "\nA byte string.\n\n"}, {"name": "numpy.c_", "path": "reference/generated/numpy.c_", "type": "numpy.c_", "text": "\nTranslates slice objects to concatenation along the second axis.\n\n"}, {"name": "numpy.can_cast()", "path": "reference/generated/numpy.can_cast", "type": "numpy.can_cast", "text": "\nReturns True if cast between data types can occur according to the casting\nrule. If from is a scalar or array scalar, also returns True if the scalar\nvalue can be cast without overflow or truncation to an integer.\n\n"}, {"name": "numpy.cbrt()", "path": "reference/generated/numpy.cbrt", "type": "numpy.cbrt", "text": "\nReturn the cube-root of an array, element-wise.\n\n"}, {"name": "numpy.cdouble()", "path": "reference/arrays.scalars#numpy.cdouble", "type": "Scalars", "text": "\nComplex number type composed of two double-precision floating-point numbers,\ncompatible with Python `complex`.\n\n"}, {"name": "numpy.ceil()", "path": "reference/generated/numpy.ceil", "type": "numpy.ceil", "text": "\nReturn the ceiling of the input, element-wise.\n\n"}, {"name": "numpy.cfloat", "path": "reference/arrays.scalars#numpy.cfloat", "type": "Scalars", "text": "\nalias of `numpy.cdouble`\n\n"}, {"name": "numpy.char.chararray()", "path": "reference/generated/numpy.char.chararray", "type": "numpy.char.chararray", "text": "\nProvides a convenient view on arrays of string and unicode values.\n\n"}, {"name": "numpy.chararray()", "path": "reference/generated/numpy.chararray", "type": "numpy.chararray", "text": "\nProvides a convenient view on arrays of string and unicode values.\n\n"}, {"name": "numpy.choose()", "path": "reference/generated/numpy.choose", "type": "numpy.choose", "text": "\nConstruct an array from an index array and a list of arrays to choose from.\n\n"}, {"name": "numpy.clip()", "path": "reference/generated/numpy.clip", "type": "numpy.clip", "text": "\nClip (limit) the values in an array.\n\n"}, {"name": "numpy.clongdouble", "path": "reference/arrays.scalars#numpy.clongdouble", "type": "Scalars", "text": "\nComplex number type composed of two extended-precision floating-point numbers.\n\n"}, {"name": "numpy.clongfloat", "path": "reference/arrays.scalars#numpy.clongfloat", "type": "Scalars", "text": "\nalias of `numpy.clongdouble`\n\n"}, {"name": "numpy.column_stack()", "path": "reference/generated/numpy.column_stack", "type": "numpy.column_stack", "text": "\nStack 1-D arrays as columns into a 2-D array.\n\n"}, {"name": "numpy.common_type()", "path": "reference/generated/numpy.common_type", "type": "numpy.common_type", "text": "\nReturn a scalar type which is common to the input arrays.\n\n"}, {"name": "numpy.complex128", "path": "reference/arrays.scalars#numpy.complex128", "type": "Scalars", "text": "\nalias of `numpy.cdouble`\n\n"}, {"name": "numpy.complex192", "path": "reference/arrays.scalars#numpy.complex192", "type": "Scalars", "text": "\nAlias for `numpy.clongdouble`, named after its size in bits. The existence of\nthese aliases depends on the platform.\n\n"}, {"name": "numpy.complex256", "path": "reference/arrays.scalars#numpy.complex256", "type": "Scalars", "text": "\nAlias for `numpy.clongdouble`, named after its size in bits. The existence of\nthese aliases depends on the platform.\n\n"}, {"name": "numpy.complex64", "path": "reference/arrays.scalars#numpy.complex64", "type": "Scalars", "text": "\nalias of `numpy.csingle`\n\n"}, {"name": "numpy.complex_", "path": "reference/arrays.scalars#numpy.complex_", "type": "Scalars", "text": "\nalias of `numpy.cdouble`\n\n"}, {"name": "numpy.compress()", "path": "reference/generated/numpy.compress", "type": "numpy.compress", "text": "\nReturn selected slices of an array along given axis.\n\n"}, {"name": "numpy.concatenate()", "path": "reference/generated/numpy.concatenate", "type": "numpy.concatenate", "text": "\nJoin a sequence of arrays along an existing axis.\n\n"}, {"name": "numpy.conj()", "path": "reference/generated/numpy.conj", "type": "numpy.conj", "text": "\nReturn the complex conjugate, element-wise.\n\n"}, {"name": "numpy.conjugate()", "path": "reference/generated/numpy.conjugate", "type": "numpy.conjugate", "text": "\nReturn the complex conjugate, element-wise.\n\n"}, {"name": "numpy.convolve()", "path": "reference/generated/numpy.convolve", "type": "numpy.convolve", "text": "\nReturns the discrete, linear convolution of two one-dimensional sequences.\n\n"}, {"name": "numpy.copy()", "path": "reference/generated/numpy.copy", "type": "numpy.copy", "text": "\nReturn an array copy of the given object.\n\n"}, {"name": "numpy.copysign()", "path": "reference/generated/numpy.copysign", "type": "numpy.copysign", "text": "\nChange the sign of x1 to that of x2, element-wise.\n\n"}, {"name": "numpy.copyto()", "path": "reference/generated/numpy.copyto", "type": "numpy.copyto", "text": "\nCopies values from one array to another, broadcasting as necessary.\n\n"}, {"name": "numpy.corrcoef()", "path": "reference/generated/numpy.corrcoef", "type": "numpy.corrcoef", "text": "\nReturn Pearson product-moment correlation coefficients.\n\n"}, {"name": "numpy.correlate()", "path": "reference/generated/numpy.correlate", "type": "numpy.correlate", "text": "\nCross-correlation of two 1-dimensional sequences.\n\n"}, {"name": "numpy.cos()", "path": "reference/generated/numpy.cos", "type": "numpy.cos", "text": "\nCosine element-wise.\n\n"}, {"name": "numpy.cosh()", "path": "reference/generated/numpy.cosh", "type": "numpy.cosh", "text": "\nHyperbolic cosine, element-wise.\n\n"}, {"name": "numpy.count_nonzero()", "path": "reference/generated/numpy.count_nonzero", "type": "numpy.count_nonzero", "text": "\nCounts the number of non-zero values in the array `a`.\n\n"}, {"name": "numpy.cov()", "path": "reference/generated/numpy.cov", "type": "numpy.cov", "text": "\nEstimate a covariance matrix, given data and weights.\n\n"}, {"name": "numpy.cross()", "path": "reference/generated/numpy.cross", "type": "numpy.cross", "text": "\nReturn the cross product of two (arrays of) vectors.\n\n"}, {"name": "numpy.csingle", "path": "reference/arrays.scalars#numpy.csingle", "type": "Scalars", "text": "\nComplex number type composed of two single-precision floating-point numbers.\n\n"}, {"name": "numpy.ctypeslib.as_array()", "path": "reference/routines.ctypeslib", "type": "C-Types Foreign Function Interface ( \n      \n       numpy.ctypeslib\n      \n      )", "text": "\nCreate a numpy array from a ctypes array or POINTER.\n\n"}, {"name": "numpy.ctypeslib.as_ctypes()", "path": "reference/routines.ctypeslib#numpy.ctypeslib.as_ctypes", "type": "C-Types Foreign Function Interface ( \n      \n       numpy.ctypeslib\n      \n      )", "text": "\nCreate and return a ctypes object from a numpy array. Actually anything that\nexposes the __array_interface__ is accepted.\n\n"}, {"name": "numpy.ctypeslib.as_ctypes_type()", "path": "reference/routines.ctypeslib#numpy.ctypeslib.as_ctypes_type", "type": "C-Types Foreign Function Interface ( \n      \n       numpy.ctypeslib\n      \n      )", "text": "\nConvert a dtype into a ctypes type.\n\n"}, {"name": "numpy.ctypeslib.c_intp", "path": "reference/routines.ctypeslib#numpy.ctypeslib.c_intp", "type": "C-Types Foreign Function Interface ( \n      \n       numpy.ctypeslib\n      \n      )", "text": "\nA `ctypes` signed integer type of the same size as `numpy.intp`.\n\n"}, {"name": "numpy.ctypeslib.load_library()", "path": "reference/routines.ctypeslib#numpy.ctypeslib.load_library", "type": "C-Types Foreign Function Interface ( \n      \n       numpy.ctypeslib\n      \n      )", "text": "\nIt is possible to load a library using\n\n"}, {"name": "numpy.ctypeslib.ndpointer()", "path": "reference/routines.ctypeslib#numpy.ctypeslib.ndpointer", "type": "C-Types Foreign Function Interface ( \n      \n       numpy.ctypeslib\n      \n      )", "text": "\nArray-checking restype/argtypes.\n\n"}, {"name": "numpy.cumprod()", "path": "reference/generated/numpy.cumprod", "type": "numpy.cumprod", "text": "\nReturn the cumulative product of elements along a given axis.\n\n"}, {"name": "numpy.cumsum()", "path": "reference/generated/numpy.cumsum", "type": "numpy.cumsum", "text": "\nReturn the cumulative sum of the elements along a given axis.\n\n"}, {"name": "numpy.DataSource()", "path": "reference/generated/numpy.datasource", "type": "numpy.DataSource", "text": "\nA generic data source file (file, http, ftp, \u2026).\n\n"}, {"name": "numpy.datetime64", "path": "reference/arrays.scalars#numpy.datetime64", "type": "Scalars", "text": "\nIf created from a 64-bit integer, it represents an offset from\n`1970-01-01T00:00:00`. If created from string, the string can be in ISO 8601\ndate or datetime format.\n\n"}, {"name": "numpy.datetime_as_string()", "path": "reference/generated/numpy.datetime_as_string", "type": "numpy.datetime_as_string", "text": "\nConvert an array of datetimes into an array of strings.\n\n"}, {"name": "numpy.datetime_data()", "path": "reference/generated/numpy.datetime_data", "type": "numpy.datetime_data", "text": "\nGet information about the step size of a date or time type.\n\n"}, {"name": "numpy.deg2rad()", "path": "reference/generated/numpy.deg2rad", "type": "numpy.deg2rad", "text": "\nConvert angles from degrees to radians.\n\n"}, {"name": "numpy.degrees()", "path": "reference/generated/numpy.degrees", "type": "numpy.degrees", "text": "\nConvert angles from radians to degrees.\n\n"}, {"name": "numpy.delete()", "path": "reference/generated/numpy.delete", "type": "numpy.delete", "text": "\nReturn a new array with sub-arrays along an axis deleted. For a one\ndimensional array, this returns those entries not returned by `arr[obj]`.\n\n"}, {"name": "numpy.deprecate()", "path": "reference/generated/numpy.deprecate", "type": "numpy.deprecate", "text": "\nIssues a DeprecationWarning, adds warning to `old_name`\u2019s docstring, rebinds\n`old_name.__name__` and returns the new function object.\n\n"}, {"name": "numpy.deprecate_with_doc()", "path": "reference/generated/numpy.deprecate_with_doc", "type": "numpy.deprecate_with_doc", "text": "\nDeprecates a function and includes the deprecation in its docstring.\n\n"}, {"name": "numpy.diag()", "path": "reference/generated/numpy.diag", "type": "numpy.diag", "text": "\nExtract a diagonal or construct a diagonal array.\n\n"}, {"name": "numpy.diag_indices()", "path": "reference/generated/numpy.diag_indices", "type": "numpy.diag_indices", "text": "\nReturn the indices to access the main diagonal of an array.\n\n"}, {"name": "numpy.diag_indices_from()", "path": "reference/generated/numpy.diag_indices_from", "type": "numpy.diag_indices_from", "text": "\nReturn the indices to access the main diagonal of an n-dimensional array.\n\n"}, {"name": "numpy.diagflat()", "path": "reference/generated/numpy.diagflat", "type": "numpy.diagflat", "text": "\nCreate a two-dimensional array with the flattened input as a diagonal.\n\n"}, {"name": "numpy.diagonal()", "path": "reference/generated/numpy.diagonal", "type": "numpy.diagonal", "text": "\nReturn specified diagonals.\n\n"}, {"name": "numpy.diff()", "path": "reference/generated/numpy.diff", "type": "numpy.diff", "text": "\nCalculate the n-th discrete difference along the given axis.\n\n"}, {"name": "numpy.digitize()", "path": "reference/generated/numpy.digitize", "type": "numpy.digitize", "text": "\nReturn the indices of the bins to which each value in input array belongs.\n\n"}, {"name": "numpy.disp()", "path": "reference/generated/numpy.disp", "type": "numpy.disp", "text": "\nDisplay a message on a device.\n\n"}, {"name": "numpy.distutils.ccompiler", "path": "reference/generated/numpy.distutils.ccompiler", "type": "numpy.distutils.ccompiler", "text": "\n`CCompiler_compile`(self, sources[, ...])\n\n"}, {"name": "numpy.distutils.ccompiler_opt", "path": "reference/generated/numpy.distutils.ccompiler_opt", "type": "numpy.distutils.ccompiler_opt", "text": "\nProvides the `CCompilerOpt` class, used for handling the CPU/hardware\noptimization, starting from parsing the command arguments, to managing the\nrelation between the CPU baseline and dispatch-able features, also generating\nthe required C headers and ending with compiling the sources with proper\ncompiler\u2019s flags.\n\n"}, {"name": "numpy.distutils.ccompiler_opt.CCompilerOpt()", "path": "reference/generated/numpy.distutils.ccompiler_opt.ccompileropt", "type": "numpy.distutils.ccompiler_opt.CCompilerOpt", "text": "\nA helper class for `CCompiler` aims to provide extra build options to\neffectively control of compiler optimizations that are directly related to CPU\nfeatures.\n\n"}, {"name": "numpy.distutils.core.Extension()", "path": "reference/generated/numpy.distutils.core.extension", "type": "numpy.distutils.core.Extension", "text": "\nExtension name.\n\n"}, {"name": "numpy.distutils.misc_util.all_strings()", "path": "reference/distutils/misc_util", "type": "distutils.misc_util", "text": "\nReturn True if all items in lst are string objects.\n\n"}, {"name": "numpy.distutils.misc_util.allpath()", "path": "reference/distutils/misc_util#numpy.distutils.misc_util.allpath", "type": "distutils.misc_util", "text": "\nConvert a /-separated pathname to one using the OS\u2019s path separator.\n\n"}, {"name": "numpy.distutils.misc_util.appendpath()", "path": "reference/distutils/misc_util#numpy.distutils.misc_util.appendpath", "type": "distutils.misc_util", "text": "\n\n"}, {"name": "numpy.distutils.misc_util.as_list()", "path": "reference/distutils/misc_util#numpy.distutils.misc_util.as_list", "type": "distutils.misc_util", "text": "\n\n"}, {"name": "numpy.distutils.misc_util.blue_text()", "path": "reference/distutils/misc_util#numpy.distutils.misc_util.blue_text", "type": "distutils.misc_util", "text": "\n\n"}, {"name": "numpy.distutils.misc_util.cyan_text()", "path": "reference/distutils/misc_util#numpy.distutils.misc_util.cyan_text", "type": "distutils.misc_util", "text": "\n\n"}, {"name": "numpy.distutils.misc_util.cyg2win32()", "path": "reference/distutils/misc_util#numpy.distutils.misc_util.cyg2win32", "type": "distutils.misc_util", "text": "\nConvert a path from Cygwin-native to Windows-native.\n\n"}, {"name": "numpy.distutils.misc_util.default_config_dict()", "path": "reference/distutils/misc_util#numpy.distutils.misc_util.default_config_dict", "type": "distutils.misc_util", "text": "\nReturn a configuration dictionary for usage in configuration() function\ndefined in file setup_<name>.py.\n\n"}, {"name": "numpy.distutils.misc_util.dict_append()", "path": "reference/distutils/misc_util#numpy.distutils.misc_util.dict_append", "type": "distutils.misc_util", "text": "\n\n"}, {"name": "numpy.distutils.misc_util.dot_join()", "path": "reference/distutils/misc_util#numpy.distutils.misc_util.dot_join", "type": "distutils.misc_util", "text": "\n\n"}, {"name": "numpy.distutils.misc_util.exec_mod_from_location()", "path": "reference/distutils/misc_util#numpy.distutils.misc_util.exec_mod_from_location", "type": "distutils.misc_util", "text": "\nUse importlib machinery to import a module `modname` from the file `modfile`.\nDepending on the `spec.loader`, the module may not be registered in\nsys.modules.\n\n"}, {"name": "numpy.distutils.misc_util.filter_sources()", "path": "reference/distutils/misc_util#numpy.distutils.misc_util.filter_sources", "type": "distutils.misc_util", "text": "\nReturn four lists of filenames containing C, C++, Fortran, and Fortran 90\nmodule sources, respectively.\n\n"}, {"name": "numpy.distutils.misc_util.generate_config_py()", "path": "reference/distutils/misc_util#numpy.distutils.misc_util.generate_config_py", "type": "distutils.misc_util", "text": "\nGenerate config.py file containing system_info information used during\nbuilding the package.\n\n"}, {"name": "numpy.distutils.misc_util.get_build_architecture()", "path": "reference/distutils/misc_util#numpy.distutils.misc_util.get_build_architecture", "type": "distutils.misc_util", "text": "\n\n"}, {"name": "numpy.distutils.misc_util.get_cmd()", "path": "reference/distutils/misc_util#numpy.distutils.misc_util.get_cmd", "type": "distutils.misc_util", "text": "\n\n"}, {"name": "numpy.distutils.misc_util.get_data_files()", "path": "reference/distutils/misc_util#numpy.distutils.misc_util.get_data_files", "type": "distutils.misc_util", "text": "\n\n"}, {"name": "numpy.distutils.misc_util.get_dependencies()", "path": "reference/distutils/misc_util#numpy.distutils.misc_util.get_dependencies", "type": "distutils.misc_util", "text": "\n\n"}, {"name": "numpy.distutils.misc_util.get_ext_source_files()", "path": "reference/distutils/misc_util#numpy.distutils.misc_util.get_ext_source_files", "type": "distutils.misc_util", "text": "\n\n"}, {"name": "numpy.distutils.misc_util.get_frame()", "path": "reference/distutils/misc_util#numpy.distutils.misc_util.get_frame", "type": "distutils.misc_util", "text": "\nReturn frame object from call stack with given level.\n\n"}, {"name": "numpy.distutils.misc_util.get_info()", "path": "reference/distutils/misc_util#numpy.distutils.misc_util.get_info", "type": "distutils.misc_util", "text": "\nReturn an info dict for a given C library.\n\n"}, {"name": "numpy.distutils.misc_util.get_language()", "path": "reference/distutils/misc_util#numpy.distutils.misc_util.get_language", "type": "distutils.misc_util", "text": "\nDetermine language value (c,f77,f90) from sources\n\n"}, {"name": "numpy.distutils.misc_util.get_lib_source_files()", "path": "reference/distutils/misc_util#numpy.distutils.misc_util.get_lib_source_files", "type": "distutils.misc_util", "text": "\n\n"}, {"name": "numpy.distutils.misc_util.get_mathlibs()", "path": "reference/distutils/misc_util#numpy.distutils.misc_util.get_mathlibs", "type": "distutils.misc_util", "text": "\nReturn the MATHLIB line from numpyconfig.h\n\n"}, {"name": "numpy.distutils.misc_util.get_num_build_jobs()", "path": "reference/distutils/misc_util#numpy.distutils.misc_util.get_num_build_jobs", "type": "distutils.misc_util", "text": "\nGet number of parallel build jobs set by the \u2013parallel command line argument\nof setup.py If the command did not receive a setting the environment variable\nNPY_NUM_BUILD_JOBS is checked. If that is unset, return the number of\nprocessors on the system, with a maximum of 8 (to prevent overloading the\nsystem if there a lot of CPUs).\n\n"}, {"name": "numpy.distutils.misc_util.get_numpy_include_dirs()", "path": "reference/distutils/misc_util#numpy.distutils.misc_util.get_numpy_include_dirs", "type": "distutils.misc_util", "text": "\n\n"}, {"name": "numpy.distutils.misc_util.get_pkg_info()", "path": "reference/distutils/misc_util#numpy.distutils.misc_util.get_pkg_info", "type": "distutils.misc_util", "text": "\nReturn library info for the given package.\n\n"}, {"name": "numpy.distutils.misc_util.get_script_files()", "path": "reference/distutils/misc_util#numpy.distutils.misc_util.get_script_files", "type": "distutils.misc_util", "text": "\n\n"}, {"name": "numpy.distutils.misc_util.gpaths()", "path": "reference/distutils/misc_util#numpy.distutils.misc_util.gpaths", "type": "distutils.misc_util", "text": "\nApply glob to paths and prepend local_path if needed.\n\n"}, {"name": "numpy.distutils.misc_util.green_text()", "path": "reference/distutils/misc_util#numpy.distutils.misc_util.green_text", "type": "distutils.misc_util", "text": "\n\n"}, {"name": "numpy.distutils.misc_util.has_cxx_sources()", "path": "reference/distutils/misc_util#numpy.distutils.misc_util.has_cxx_sources", "type": "distutils.misc_util", "text": "\nReturn True if sources contains C++ files\n\n"}, {"name": "numpy.distutils.misc_util.has_f_sources()", "path": "reference/distutils/misc_util#numpy.distutils.misc_util.has_f_sources", "type": "distutils.misc_util", "text": "\nReturn True if sources contains Fortran files\n\n"}, {"name": "numpy.distutils.misc_util.is_local_src_dir()", "path": "reference/distutils/misc_util#numpy.distutils.misc_util.is_local_src_dir", "type": "distutils.misc_util", "text": "\nReturn true if directory is local directory.\n\n"}, {"name": "numpy.distutils.misc_util.is_sequence()", "path": "reference/distutils/misc_util#numpy.distutils.misc_util.is_sequence", "type": "distutils.misc_util", "text": "\n\n"}, {"name": "numpy.distutils.misc_util.is_string()", "path": "reference/distutils/misc_util#numpy.distutils.misc_util.is_string", "type": "distutils.misc_util", "text": "\n\n"}, {"name": "numpy.distutils.misc_util.mingw32()", "path": "reference/distutils/misc_util#numpy.distutils.misc_util.mingw32", "type": "distutils.misc_util", "text": "\nReturn true when using mingw32 environment.\n\n"}, {"name": "numpy.distutils.misc_util.minrelpath()", "path": "reference/distutils/misc_util#numpy.distutils.misc_util.minrelpath", "type": "distutils.misc_util", "text": "\nResolve and \u2018.\u2019 from path.\n\n"}, {"name": "numpy.distutils.misc_util.njoin()", "path": "reference/distutils/misc_util#numpy.distutils.misc_util.njoin", "type": "distutils.misc_util", "text": "\nJoin two or more pathname components + - convert a /-separated pathname to one\nusing the OS\u2019s path separator. - resolve and from path.\n\n"}, {"name": "numpy.distutils.misc_util.red_text()", "path": "reference/distutils/misc_util#numpy.distutils.misc_util.red_text", "type": "distutils.misc_util", "text": "\n\n"}, {"name": "numpy.distutils.misc_util.sanitize_cxx_flags()", "path": "reference/distutils/misc_util#numpy.distutils.misc_util.sanitize_cxx_flags", "type": "distutils.misc_util", "text": "\nSome flags are valid for C but not C++. Prune them.\n\n"}, {"name": "numpy.distutils.misc_util.terminal_has_colors()", "path": "reference/distutils/misc_util#numpy.distutils.misc_util.terminal_has_colors", "type": "distutils.misc_util", "text": "\n\n"}, {"name": "numpy.distutils.misc_util.yellow_text()", "path": "reference/distutils/misc_util#numpy.distutils.misc_util.yellow_text", "type": "distutils.misc_util", "text": "\n\n"}, {"name": "numpy.divide()", "path": "reference/generated/numpy.divide", "type": "numpy.divide", "text": "\nReturns a true division of the inputs, element-wise.\n\n"}, {"name": "numpy.divmod()", "path": "reference/generated/numpy.divmod", "type": "numpy.divmod", "text": "\nReturn element-wise quotient and remainder simultaneously.\n\n"}, {"name": "numpy.dot()", "path": "reference/generated/numpy.dot", "type": "numpy.dot", "text": "\nDot product of two arrays. Specifically,\n\n"}, {"name": "numpy.double()", "path": "reference/arrays.scalars#numpy.double", "type": "Scalars", "text": "\nDouble-precision floating-point number type, compatible with Python `float`\nand C `double`.\n\n"}, {"name": "numpy.dsplit()", "path": "reference/generated/numpy.dsplit", "type": "numpy.dsplit", "text": "\nSplit array into multiple sub-arrays along the 3rd axis (depth).\n\n"}, {"name": "numpy.dstack()", "path": "reference/generated/numpy.dstack", "type": "numpy.dstack", "text": "\nStack arrays in sequence depth wise (along third axis).\n\n"}, {"name": "numpy.dtype()", "path": "reference/generated/numpy.dtype", "type": "numpy.dtype", "text": "\nCreate a data type object.\n\n"}, {"name": "numpy.e", "path": "reference/constants#numpy.e", "type": "Constants", "text": "\nEuler\u2019s constant, base of natural logarithms, Napier\u2019s constant.\n\n"}, {"name": "numpy.ediff1d()", "path": "reference/generated/numpy.ediff1d", "type": "numpy.ediff1d", "text": "\nThe differences between consecutive elements of an array.\n\n"}, {"name": "numpy.einsum()", "path": "reference/generated/numpy.einsum", "type": "numpy.einsum", "text": "\nEvaluates the Einstein summation convention on the operands.\n\n"}, {"name": "numpy.einsum_path()", "path": "reference/generated/numpy.einsum_path", "type": "numpy.einsum_path", "text": "\nEvaluates the lowest cost contraction order for an einsum expression by\nconsidering the creation of intermediate arrays.\n\n"}, {"name": "numpy.empty()", "path": "reference/generated/numpy.empty", "type": "numpy.empty", "text": "\nReturn a new array of given shape and type, without initializing entries.\n\n"}, {"name": "numpy.empty_like()", "path": "reference/generated/numpy.empty_like", "type": "numpy.empty_like", "text": "\nReturn a new array with the same shape and type as a given array.\n\n"}, {"name": "numpy.equal()", "path": "reference/generated/numpy.equal", "type": "numpy.equal", "text": "\nReturn (x1 == x2) element-wise.\n\n"}, {"name": "numpy.errstate()", "path": "reference/generated/numpy.errstate", "type": "numpy.errstate", "text": "\nContext manager for floating-point error handling.\n\n"}, {"name": "numpy.euler_gamma", "path": "reference/constants#numpy.euler_gamma", "type": "Constants", "text": "\n`\u03b3 = 0.5772156649015328606065120900824024310421...`\n\n"}, {"name": "numpy.exp()", "path": "reference/generated/numpy.exp", "type": "numpy.exp", "text": "\nCalculate the exponential of all elements in the input array.\n\n"}, {"name": "numpy.exp2()", "path": "reference/generated/numpy.exp2", "type": "numpy.exp2", "text": "\nCalculate `2**p` for all `p` in the input array.\n\n"}, {"name": "numpy.expand_dims()", "path": "reference/generated/numpy.expand_dims", "type": "numpy.expand_dims", "text": "\nExpand the shape of an array.\n\n"}, {"name": "numpy.expm1()", "path": "reference/generated/numpy.expm1", "type": "numpy.expm1", "text": "\nCalculate `exp(x) - 1` for all elements in the array.\n\n"}, {"name": "numpy.extract()", "path": "reference/generated/numpy.extract", "type": "numpy.extract", "text": "\nReturn the elements of an array that satisfy some condition.\n\n"}, {"name": "numpy.eye()", "path": "reference/generated/numpy.eye", "type": "numpy.eye", "text": "\nReturn a 2-D array with ones on the diagonal and zeros elsewhere.\n\n"}, {"name": "numpy.f2py.get_include()", "path": "f2py/usage#numpy.f2py.get_include", "type": "Using F2PY", "text": "\nReturn the directory that contains the fortranobject.c and .h files.\n\n"}, {"name": "numpy.f2py.run_main()", "path": "f2py/usage#numpy.f2py.run_main", "type": "Using F2PY", "text": "\nEquivalent to running:\n\n"}, {"name": "numpy.fabs()", "path": "reference/generated/numpy.fabs", "type": "numpy.fabs", "text": "\nCompute the absolute values element-wise.\n\n"}, {"name": "numpy.fill_diagonal()", "path": "reference/generated/numpy.fill_diagonal", "type": "numpy.fill_diagonal", "text": "\nFill the main diagonal of the given array of any dimensionality.\n\n"}, {"name": "numpy.find_common_type()", "path": "reference/generated/numpy.find_common_type", "type": "numpy.find_common_type", "text": "\nDetermine common type following standard coercion rules.\n\n"}, {"name": "numpy.finfo()", "path": "reference/generated/numpy.finfo", "type": "numpy.finfo", "text": "\nMachine limits for floating point types.\n\n"}, {"name": "numpy.fix()", "path": "reference/generated/numpy.fix", "type": "numpy.fix", "text": "\nRound to nearest integer towards zero.\n\n"}, {"name": "numpy.flatiter", "path": "reference/generated/numpy.flatiter", "type": "numpy.flatiter", "text": "\nFlat iterator object to iterate over arrays.\n\n"}, {"name": "numpy.flatnonzero()", "path": "reference/generated/numpy.flatnonzero", "type": "numpy.flatnonzero", "text": "\nReturn indices that are non-zero in the flattened version of a.\n\n"}, {"name": "numpy.flexible", "path": "reference/arrays.scalars#numpy.flexible", "type": "Scalars", "text": "\nAbstract base class of all scalar types without predefined length. The actual\nsize of these types depends on the specific `np.dtype` instantiation.\n\n"}, {"name": "numpy.flip()", "path": "reference/generated/numpy.flip", "type": "numpy.flip", "text": "\nReverse the order of elements in an array along the given axis.\n\n"}, {"name": "numpy.fliplr()", "path": "reference/generated/numpy.fliplr", "type": "numpy.fliplr", "text": "\nReverse the order of elements along axis 1 (left/right).\n\n"}, {"name": "numpy.flipud()", "path": "reference/generated/numpy.flipud", "type": "numpy.flipud", "text": "\nReverse the order of elements along axis 0 (up/down).\n\n"}, {"name": "numpy.float128", "path": "reference/arrays.scalars#numpy.float128", "type": "Scalars", "text": "\nAlias for `numpy.longdouble`, named after its size in bits. The existence of\nthese aliases depends on the platform.\n\n"}, {"name": "numpy.float16", "path": "reference/arrays.scalars#numpy.float16", "type": "Scalars", "text": "\nalias of `numpy.half`\n\n"}, {"name": "numpy.float32", "path": "reference/arrays.scalars#numpy.float32", "type": "Scalars", "text": "\nalias of `numpy.single`\n\n"}, {"name": "numpy.float64", "path": "reference/arrays.scalars#numpy.float64", "type": "Scalars", "text": "\nalias of `numpy.double`\n\n"}, {"name": "numpy.float96", "path": "reference/arrays.scalars#numpy.float96", "type": "Scalars", "text": "\nAlias for `numpy.longdouble`, named after its size in bits. The existence of\nthese aliases depends on the platform.\n\n"}, {"name": "numpy.float_power()", "path": "reference/generated/numpy.float_power", "type": "numpy.float_power", "text": "\nFirst array elements raised to powers from second array, element-wise.\n\n"}, {"name": "numpy.floor()", "path": "reference/generated/numpy.floor", "type": "numpy.floor", "text": "\nReturn the floor of the input, element-wise.\n\n"}, {"name": "numpy.floor_divide()", "path": "reference/generated/numpy.floor_divide", "type": "numpy.floor_divide", "text": "\nReturn the largest integer smaller or equal to the division of the inputs. It\nis equivalent to the Python `//` operator and pairs with the Python `%`\n(`remainder`), function so that `a = a % b + b * (a // b)` up to roundoff.\n\n"}, {"name": "numpy.fmax()", "path": "reference/generated/numpy.fmax", "type": "numpy.fmax", "text": "\nElement-wise maximum of array elements.\n\n"}, {"name": "numpy.fmin()", "path": "reference/generated/numpy.fmin", "type": "numpy.fmin", "text": "\nElement-wise minimum of array elements.\n\n"}, {"name": "numpy.fmod()", "path": "reference/generated/numpy.fmod", "type": "numpy.fmod", "text": "\nReturns the element-wise remainder of division.\n\n"}, {"name": "numpy.format_float_positional()", "path": "reference/generated/numpy.format_float_positional", "type": "numpy.format_float_positional", "text": "\nFormat a floating-point scalar as a decimal string in positional notation.\n\n"}, {"name": "numpy.format_float_scientific()", "path": "reference/generated/numpy.format_float_scientific", "type": "numpy.format_float_scientific", "text": "\nFormat a floating-point scalar as a decimal string in scientific notation.\n\n"}, {"name": "numpy.format_parser()", "path": "reference/generated/numpy.format_parser", "type": "numpy.format_parser", "text": "\nClass to convert formats, names, titles description to a dtype.\n\n"}, {"name": "numpy.frexp()", "path": "reference/generated/numpy.frexp", "type": "numpy.frexp", "text": "\nDecompose the elements of x into mantissa and twos exponent.\n\n"}, {"name": "numpy.frombuffer()", "path": "reference/generated/numpy.frombuffer", "type": "numpy.frombuffer", "text": "\nInterpret a buffer as a 1-dimensional array.\n\n"}, {"name": "numpy.fromfile()", "path": "reference/generated/numpy.fromfile", "type": "numpy.fromfile", "text": "\nConstruct an array from data in a text or binary file.\n\n"}, {"name": "numpy.fromfunction()", "path": "reference/generated/numpy.fromfunction", "type": "numpy.fromfunction", "text": "\nConstruct an array by executing a function over each coordinate.\n\n"}, {"name": "numpy.fromiter()", "path": "reference/generated/numpy.fromiter", "type": "numpy.fromiter", "text": "\nCreate a new 1-dimensional array from an iterable object.\n\n"}, {"name": "numpy.frompyfunc()", "path": "reference/generated/numpy.frompyfunc", "type": "numpy.frompyfunc", "text": "\nTakes an arbitrary Python function and returns a NumPy ufunc.\n\n"}, {"name": "numpy.fromregex()", "path": "reference/generated/numpy.fromregex", "type": "numpy.fromregex", "text": "\nConstruct an array from a text file, using regular expression parsing.\n\n"}, {"name": "numpy.fromstring()", "path": "reference/generated/numpy.fromstring", "type": "numpy.fromstring", "text": "\nA new 1-D array initialized from text data in a string.\n\n"}, {"name": "numpy.full()", "path": "reference/generated/numpy.full", "type": "numpy.full", "text": "\nReturn a new array of given shape and type, filled with `fill_value`.\n\n"}, {"name": "numpy.full_like()", "path": "reference/generated/numpy.full_like", "type": "numpy.full_like", "text": "\nReturn a full array with the same shape and type as a given array.\n\n"}, {"name": "numpy.gcd()", "path": "reference/generated/numpy.gcd", "type": "numpy.gcd", "text": "\nReturns the greatest common divisor of `|x1|` and `|x2|`\n\n"}, {"name": "numpy.genfromtxt()", "path": "reference/generated/numpy.genfromtxt", "type": "numpy.genfromtxt", "text": "\nLoad data from a text file, with missing values handled as specified.\n\n"}, {"name": "numpy.geomspace()", "path": "reference/generated/numpy.geomspace", "type": "numpy.geomspace", "text": "\nReturn numbers spaced evenly on a log scale (a geometric progression).\n\n"}, {"name": "numpy.get_include()", "path": "reference/generated/numpy.get_include", "type": "numpy.get_include", "text": "\nReturn the directory that contains the NumPy *.h header files.\n\n"}, {"name": "numpy.get_printoptions()", "path": "reference/generated/numpy.get_printoptions", "type": "numpy.get_printoptions", "text": "\nReturn the current print options.\n\n"}, {"name": "numpy.getbufsize()", "path": "reference/generated/numpy.getbufsize", "type": "numpy.getbufsize", "text": "\nReturn the size of the buffer used in ufuncs.\n\n"}, {"name": "numpy.geterr()", "path": "reference/generated/numpy.geterr", "type": "numpy.geterr", "text": "\nGet the current way of handling floating-point errors.\n\n"}, {"name": "numpy.geterrcall()", "path": "reference/generated/numpy.geterrcall", "type": "numpy.geterrcall", "text": "\nReturn the current callback function used on floating-point errors.\n\n"}, {"name": "numpy.geterrobj()", "path": "reference/generated/numpy.geterrobj", "type": "numpy.geterrobj", "text": "\nReturn the current object that defines floating-point error handling.\n\n"}, {"name": "numpy.gradient()", "path": "reference/generated/numpy.gradient", "type": "numpy.gradient", "text": "\nReturn the gradient of an N-dimensional array.\n\n"}, {"name": "numpy.greater()", "path": "reference/generated/numpy.greater", "type": "numpy.greater", "text": "\nReturn the truth value of (x1 > x2) element-wise.\n\n"}, {"name": "numpy.greater_equal()", "path": "reference/generated/numpy.greater_equal", "type": "numpy.greater_equal", "text": "\nReturn the truth value of (x1 >= x2) element-wise.\n\n"}, {"name": "numpy.half", "path": "reference/arrays.scalars#numpy.half", "type": "Scalars", "text": "\nHalf-precision floating-point number type.\n\n"}, {"name": "numpy.hamming()", "path": "reference/generated/numpy.hamming", "type": "numpy.hamming", "text": "\nReturn the Hamming window.\n\n"}, {"name": "numpy.hanning()", "path": "reference/generated/numpy.hanning", "type": "numpy.hanning", "text": "\nReturn the Hanning window.\n\n"}, {"name": "numpy.heaviside()", "path": "reference/generated/numpy.heaviside", "type": "numpy.heaviside", "text": "\nCompute the Heaviside step function.\n\n"}, {"name": "numpy.histogram()", "path": "reference/generated/numpy.histogram", "type": "numpy.histogram", "text": "\nCompute the histogram of a dataset.\n\n"}, {"name": "numpy.histogram2d()", "path": "reference/generated/numpy.histogram2d", "type": "numpy.histogram2d", "text": "\nCompute the bi-dimensional histogram of two data samples.\n\n"}, {"name": "numpy.histogram_bin_edges()", "path": "reference/generated/numpy.histogram_bin_edges", "type": "numpy.histogram_bin_edges", "text": "\nFunction to calculate only the edges of the bins used by the `histogram`\nfunction.\n\n"}, {"name": "numpy.histogramdd()", "path": "reference/generated/numpy.histogramdd", "type": "numpy.histogramdd", "text": "\nCompute the multidimensional histogram of some data.\n\n"}, {"name": "numpy.hsplit()", "path": "reference/generated/numpy.hsplit", "type": "numpy.hsplit", "text": "\nSplit an array into multiple sub-arrays horizontally (column-wise).\n\n"}, {"name": "numpy.hstack()", "path": "reference/generated/numpy.hstack", "type": "numpy.hstack", "text": "\nStack arrays in sequence horizontally (column wise).\n\n"}, {"name": "numpy.hypot()", "path": "reference/generated/numpy.hypot", "type": "numpy.hypot", "text": "\nGiven the \u201clegs\u201d of a right triangle, return its hypotenuse.\n\n"}, {"name": "numpy.i0()", "path": "reference/generated/numpy.i0", "type": "numpy.i0", "text": "\nModified Bessel function of the first kind, order 0.\n\n"}, {"name": "numpy.identity()", "path": "reference/generated/numpy.identity", "type": "numpy.identity", "text": "\nReturn the identity array.\n\n"}, {"name": "numpy.iinfo()", "path": "reference/generated/numpy.iinfo", "type": "numpy.iinfo", "text": "\nMachine limits for integer types.\n\n"}, {"name": "numpy.imag()", "path": "reference/generated/numpy.imag", "type": "numpy.imag", "text": "\nReturn the imaginary part of the complex argument.\n\n"}, {"name": "numpy.in1d()", "path": "reference/generated/numpy.in1d", "type": "numpy.in1d", "text": "\nTest whether each element of a 1-D array is also present in a second array.\n\n"}, {"name": "numpy.indices()", "path": "reference/generated/numpy.indices", "type": "numpy.indices", "text": "\nReturn an array representing the indices of a grid.\n\n"}, {"name": "numpy.Inf", "path": "reference/constants", "type": "Constants", "text": "\nNumPy includes several constants:\n\n"}, {"name": "numpy.inf", "path": "reference/constants#numpy.inf", "type": "Constants", "text": "\nIEEE 754 floating point representation of (positive) infinity.\n\n"}, {"name": "numpy.Infinity", "path": "reference/constants#numpy.Infinity", "type": "Constants", "text": "\nIEEE 754 floating point representation of (positive) infinity.\n\n"}, {"name": "numpy.info()", "path": "reference/generated/numpy.info", "type": "numpy.info", "text": "\nGet help information for a function, class, or module.\n\n"}, {"name": "numpy.infty", "path": "reference/constants#numpy.infty", "type": "Constants", "text": "\nIEEE 754 floating point representation of (positive) infinity.\n\n"}, {"name": "numpy.inner()", "path": "reference/generated/numpy.inner", "type": "numpy.inner", "text": "\nInner product of two arrays.\n\n"}, {"name": "numpy.insert()", "path": "reference/generated/numpy.insert", "type": "numpy.insert", "text": "\nInsert values along the given axis before the given indices.\n\n"}, {"name": "numpy.int16", "path": "reference/arrays.scalars#numpy.int16", "type": "Scalars", "text": "\nAliases for the signed integer types (one of `numpy.byte`, `numpy.short`,\n`numpy.intc`, `numpy.int_` and `numpy.longlong`) with the specified number of\nbits.\n\n"}, {"name": "numpy.int32", "path": "reference/arrays.scalars#numpy.int32", "type": "Scalars", "text": "\nAliases for the signed integer types (one of `numpy.byte`, `numpy.short`,\n`numpy.intc`, `numpy.int_` and `numpy.longlong`) with the specified number of\nbits.\n\n"}, {"name": "numpy.int64", "path": "reference/arrays.scalars#numpy.int64", "type": "Scalars", "text": "\nAliases for the signed integer types (one of `numpy.byte`, `numpy.short`,\n`numpy.intc`, `numpy.int_` and `numpy.longlong`) with the specified number of\nbits.\n\n"}, {"name": "numpy.int8", "path": "reference/arrays.scalars#numpy.int8", "type": "Scalars", "text": "\nAliases for the signed integer types (one of `numpy.byte`, `numpy.short`,\n`numpy.intc`, `numpy.int_` and `numpy.longlong`) with the specified number of\nbits.\n\n"}, {"name": "numpy.int_", "path": "reference/arrays.scalars#numpy.int_", "type": "Scalars", "text": "\nSigned integer type, compatible with Python `int` and C `long`.\n\n"}, {"name": "numpy.intc", "path": "reference/arrays.scalars#numpy.intc", "type": "Scalars", "text": "\nSigned integer type, compatible with C `int`.\n\n"}, {"name": "numpy.interp()", "path": "reference/generated/numpy.interp", "type": "numpy.interp", "text": "\nOne-dimensional linear interpolation for monotonically increasing sample\npoints.\n\n"}, {"name": "numpy.intersect1d()", "path": "reference/generated/numpy.intersect1d", "type": "numpy.intersect1d", "text": "\nFind the intersection of two arrays.\n\n"}, {"name": "numpy.intp", "path": "reference/arrays.scalars#numpy.intp", "type": "Scalars", "text": "\nAlias for the signed integer type (one of `numpy.byte`, `numpy.short`,\n`numpy.intc`, `numpy.int_` and `np.longlong`) that is the same size as a\npointer.\n\n"}, {"name": "numpy.invert()", "path": "reference/generated/numpy.invert", "type": "numpy.invert", "text": "\nCompute bit-wise inversion, or bit-wise NOT, element-wise.\n\n"}, {"name": "numpy.is_busday()", "path": "reference/generated/numpy.is_busday", "type": "numpy.is_busday", "text": "\nCalculates which of the given dates are valid days, and which are not.\n\n"}, {"name": "numpy.isclose()", "path": "reference/generated/numpy.isclose", "type": "numpy.isclose", "text": "\nReturns a boolean array where two arrays are element-wise equal within a\ntolerance.\n\n"}, {"name": "numpy.iscomplex()", "path": "reference/generated/numpy.iscomplex", "type": "numpy.iscomplex", "text": "\nReturns a bool array, where True if input element is complex.\n\n"}, {"name": "numpy.iscomplexobj()", "path": "reference/generated/numpy.iscomplexobj", "type": "numpy.iscomplexobj", "text": "\nCheck for a complex type or an array of complex numbers.\n\n"}, {"name": "numpy.isfinite()", "path": "reference/generated/numpy.isfinite", "type": "numpy.isfinite", "text": "\nTest element-wise for finiteness (not infinity and not Not a Number).\n\n"}, {"name": "numpy.isfortran()", "path": "reference/generated/numpy.isfortran", "type": "numpy.isfortran", "text": "\nCheck if the array is Fortran contiguous but not C contiguous.\n\n"}, {"name": "numpy.isin()", "path": "reference/generated/numpy.isin", "type": "numpy.isin", "text": "\nCalculates `element in test_elements`, broadcasting over `element` only.\nReturns a boolean array of the same shape as `element` that is True where an\nelement of `element` is in `test_elements` and False otherwise.\n\n"}, {"name": "numpy.isinf()", "path": "reference/generated/numpy.isinf", "type": "numpy.isinf", "text": "\nTest element-wise for positive or negative infinity.\n\n"}, {"name": "numpy.isnan()", "path": "reference/generated/numpy.isnan", "type": "numpy.isnan", "text": "\nTest element-wise for NaN and return result as a boolean array.\n\n"}, {"name": "numpy.isnat()", "path": "reference/generated/numpy.isnat", "type": "numpy.isnat", "text": "\nTest element-wise for NaT (not a time) and return result as a boolean array.\n\n"}, {"name": "numpy.isneginf()", "path": "reference/generated/numpy.isneginf", "type": "numpy.isneginf", "text": "\nTest element-wise for negative infinity, return result as bool array.\n\n"}, {"name": "numpy.isposinf()", "path": "reference/generated/numpy.isposinf", "type": "numpy.isposinf", "text": "\nTest element-wise for positive infinity, return result as bool array.\n\n"}, {"name": "numpy.isreal()", "path": "reference/generated/numpy.isreal", "type": "numpy.isreal", "text": "\nReturns a bool array, where True if input element is real.\n\n"}, {"name": "numpy.isrealobj()", "path": "reference/generated/numpy.isrealobj", "type": "numpy.isrealobj", "text": "\nReturn True if x is a not complex type or an array of complex numbers.\n\n"}, {"name": "numpy.isscalar()", "path": "reference/generated/numpy.isscalar", "type": "numpy.isscalar", "text": "\nReturns True if the type of `element` is a scalar type.\n\n"}, {"name": "numpy.issctype()", "path": "reference/generated/numpy.issctype", "type": "numpy.issctype", "text": "\nDetermines whether the given object represents a scalar data-type.\n\n"}, {"name": "numpy.issubclass_()", "path": "reference/generated/numpy.issubclass_", "type": "numpy.issubclass_", "text": "\nDetermine if a class is a subclass of a second class.\n\n"}, {"name": "numpy.issubdtype()", "path": "reference/generated/numpy.issubdtype", "type": "numpy.issubdtype", "text": "\nReturns True if first argument is a typecode lower/equal in type hierarchy.\n\n"}, {"name": "numpy.issubsctype()", "path": "reference/generated/numpy.issubsctype", "type": "numpy.issubsctype", "text": "\nDetermine if the first argument is a subclass of the second argument.\n\n"}, {"name": "numpy.ix_()", "path": "reference/generated/numpy.ix_", "type": "numpy.ix_", "text": "\nConstruct an open mesh from multiple sequences.\n\n"}, {"name": "numpy.kaiser()", "path": "reference/generated/numpy.kaiser", "type": "numpy.kaiser", "text": "\nReturn the Kaiser window.\n\n"}, {"name": "numpy.kron()", "path": "reference/generated/numpy.kron", "type": "numpy.kron", "text": "\nKronecker product of two arrays.\n\n"}, {"name": "numpy.lcm()", "path": "reference/generated/numpy.lcm", "type": "numpy.lcm", "text": "\nReturns the lowest common multiple of `|x1|` and `|x2|`\n\n"}, {"name": "numpy.ldexp()", "path": "reference/generated/numpy.ldexp", "type": "numpy.ldexp", "text": "\nReturns x1 * 2**x2, element-wise.\n\n"}, {"name": "numpy.left_shift()", "path": "reference/generated/numpy.left_shift", "type": "numpy.left_shift", "text": "\nShift the bits of an integer to the left.\n\n"}, {"name": "numpy.less()", "path": "reference/generated/numpy.less", "type": "numpy.less", "text": "\nReturn the truth value of (x1 < x2) element-wise.\n\n"}, {"name": "numpy.less_equal()", "path": "reference/generated/numpy.less_equal", "type": "numpy.less_equal", "text": "\nReturn the truth value of (x1 <= x2) element-wise.\n\n"}, {"name": "numpy.lexsort()", "path": "reference/generated/numpy.lexsort", "type": "numpy.lexsort", "text": "\nPerform an indirect stable sort using a sequence of keys.\n\n"}, {"name": "numpy.lib.arraysetops", "path": "reference/generated/numpy.lib.arraysetops", "type": "numpy.lib.arraysetops", "text": "\nSet operations for arrays based on sorting.\n\n"}, {"name": "numpy.lib.Arrayterator()", "path": "reference/generated/numpy.lib.arrayterator", "type": "numpy.lib.Arrayterator", "text": "\nBuffered iterator for big arrays.\n\n"}, {"name": "numpy.lib.mixins.NDArrayOperatorsMixin", "path": "reference/generated/numpy.lib.mixins.ndarrayoperatorsmixin", "type": "numpy.lib.mixins.NDArrayOperatorsMixin", "text": "\nMixin defining all operator special methods using __array_ufunc__.\n\n"}, {"name": "numpy.lib.NumpyVersion()", "path": "reference/generated/numpy.lib.numpyversion", "type": "numpy.lib.NumpyVersion", "text": "\nParse and compare numpy version strings.\n\n"}, {"name": "numpy.lib.recfunctions.append_fields()", "path": "user/basics.rec", "type": "User Guide", "text": "\nStructured arrays are ndarrays whose datatype is a composition of simpler\ndatatypes organized as a sequence of named fields. For example,\n\n"}, {"name": "numpy.lib.recfunctions.apply_along_fields()", "path": "user/basics.rec#numpy.lib.recfunctions.apply_along_fields", "type": "User Guide", "text": "\nApply function \u2018func\u2019 as a reduction across fields of a structured array.\n\n"}, {"name": "numpy.lib.recfunctions.assign_fields_by_name()", "path": "user/basics.rec#numpy.lib.recfunctions.assign_fields_by_name", "type": "User Guide", "text": "\nAssigns values from one structured array to another by field name.\n\n"}, {"name": "numpy.lib.recfunctions.drop_fields()", "path": "user/basics.rec#numpy.lib.recfunctions.drop_fields", "type": "User Guide", "text": "\nReturn a new array with fields in `drop_names` dropped.\n\n"}, {"name": "numpy.lib.recfunctions.find_duplicates()", "path": "user/basics.rec#numpy.lib.recfunctions.find_duplicates", "type": "User Guide", "text": "\nFind the duplicates in a structured array along a given key\n\n"}, {"name": "numpy.lib.recfunctions.flatten_descr()", "path": "user/basics.rec#numpy.lib.recfunctions.flatten_descr", "type": "User Guide", "text": "\nFlatten a structured data-type description.\n\n"}, {"name": "numpy.lib.recfunctions.get_fieldstructure()", "path": "user/basics.rec#numpy.lib.recfunctions.get_fieldstructure", "type": "User Guide", "text": "\nReturns a dictionary with fields indexing lists of their parent fields.\n\n"}, {"name": "numpy.lib.recfunctions.get_names()", "path": "user/basics.rec#numpy.lib.recfunctions.get_names", "type": "User Guide", "text": "\nReturns the field names of the input datatype as a tuple.\n\n"}, {"name": "numpy.lib.recfunctions.get_names_flat()", "path": "user/basics.rec#numpy.lib.recfunctions.get_names_flat", "type": "User Guide", "text": "\nReturns the field names of the input datatype as a tuple. Nested structure are\nflattened beforehand.\n\n"}, {"name": "numpy.lib.recfunctions.join_by()", "path": "user/basics.rec#numpy.lib.recfunctions.join_by", "type": "User Guide", "text": "\nJoin arrays `r1` and `r2` on key `key`.\n\n"}, {"name": "numpy.lib.recfunctions.merge_arrays()", "path": "user/basics.rec#numpy.lib.recfunctions.merge_arrays", "type": "User Guide", "text": "\nMerge arrays field by field.\n\n"}, {"name": "numpy.lib.recfunctions.rec_append_fields()", "path": "user/basics.rec#numpy.lib.recfunctions.rec_append_fields", "type": "User Guide", "text": "\nAdd new fields to an existing array.\n\n"}, {"name": "numpy.lib.recfunctions.rec_drop_fields()", "path": "user/basics.rec#numpy.lib.recfunctions.rec_drop_fields", "type": "User Guide", "text": "\nReturns a new numpy.recarray with fields in `drop_names` dropped.\n\n"}, {"name": "numpy.lib.recfunctions.rec_join()", "path": "user/basics.rec#numpy.lib.recfunctions.rec_join", "type": "User Guide", "text": "\nJoin arrays `r1` and `r2` on keys. Alternative to join_by, that always returns\na np.recarray.\n\n"}, {"name": "numpy.lib.recfunctions.recursive_fill_fields()", "path": "user/basics.rec#numpy.lib.recfunctions.recursive_fill_fields", "type": "User Guide", "text": "\nFills fields from output with fields from input, with support for nested\nstructures.\n\n"}, {"name": "numpy.lib.recfunctions.rename_fields()", "path": "user/basics.rec#numpy.lib.recfunctions.rename_fields", "type": "User Guide", "text": "\nRename the fields from a flexible-datatype ndarray or recarray.\n\n"}, {"name": "numpy.lib.recfunctions.repack_fields()", "path": "user/basics.rec#numpy.lib.recfunctions.repack_fields", "type": "User Guide", "text": "\nRe-pack the fields of a structured array or dtype in memory.\n\n"}, {"name": "numpy.lib.recfunctions.require_fields()", "path": "user/basics.rec#numpy.lib.recfunctions.require_fields", "type": "User Guide", "text": "\nCasts a structured array to a new dtype using assignment by field-name.\n\n"}, {"name": "numpy.lib.recfunctions.stack_arrays()", "path": "user/basics.rec#numpy.lib.recfunctions.stack_arrays", "type": "User Guide", "text": "\nSuperposes arrays fields by fields\n\n"}, {"name": "numpy.lib.recfunctions.structured_to_unstructured()", "path": "user/basics.rec#numpy.lib.recfunctions.structured_to_unstructured", "type": "User Guide", "text": "\nConverts an n-D structured array into an (n+1)-D unstructured array.\n\n"}, {"name": "numpy.lib.recfunctions.unstructured_to_structured()", "path": "user/basics.rec#numpy.lib.recfunctions.unstructured_to_structured", "type": "User Guide", "text": "\nConverts an n-D unstructured array into an (n-1)-D structured array.\n\n"}, {"name": "numpy.lib.user_array.container()", "path": "reference/generated/numpy.lib.user_array.container", "type": "numpy.lib.user_array.container", "text": "\nStandard container-class for easy multiple-inheritance.\n\n"}, {"name": "numpy.linspace()", "path": "reference/generated/numpy.linspace", "type": "numpy.linspace", "text": "\nReturn evenly spaced numbers over a specified interval.\n\n"}, {"name": "numpy.load()", "path": "reference/generated/numpy.load", "type": "numpy.load", "text": "\nLoad arrays or pickled objects from `.npy`, `.npz` or pickled files.\n\n"}, {"name": "numpy.loadtxt()", "path": "reference/generated/numpy.loadtxt", "type": "numpy.loadtxt", "text": "\nLoad data from a text file.\n\n"}, {"name": "numpy.log()", "path": "reference/generated/numpy.log", "type": "numpy.log", "text": "\nNatural logarithm, element-wise.\n\n"}, {"name": "numpy.log10()", "path": "reference/generated/numpy.log10", "type": "numpy.log10", "text": "\nReturn the base 10 logarithm of the input array, element-wise.\n\n"}, {"name": "numpy.log1p()", "path": "reference/generated/numpy.log1p", "type": "numpy.log1p", "text": "\nReturn the natural logarithm of one plus the input array, element-wise.\n\n"}, {"name": "numpy.log2()", "path": "reference/generated/numpy.log2", "type": "numpy.log2", "text": "\nBase-2 logarithm of `x`.\n\n"}, {"name": "numpy.logaddexp()", "path": "reference/generated/numpy.logaddexp", "type": "numpy.logaddexp", "text": "\nLogarithm of the sum of exponentiations of the inputs.\n\n"}, {"name": "numpy.logaddexp2()", "path": "reference/generated/numpy.logaddexp2", "type": "numpy.logaddexp2", "text": "\nLogarithm of the sum of exponentiations of the inputs in base-2.\n\n"}, {"name": "numpy.logical_and()", "path": "reference/generated/numpy.logical_and", "type": "numpy.logical_and", "text": "\nCompute the truth value of x1 AND x2 element-wise.\n\n"}, {"name": "numpy.logical_not()", "path": "reference/generated/numpy.logical_not", "type": "numpy.logical_not", "text": "\nCompute the truth value of NOT x element-wise.\n\n"}, {"name": "numpy.logical_or()", "path": "reference/generated/numpy.logical_or", "type": "numpy.logical_or", "text": "\nCompute the truth value of x1 OR x2 element-wise.\n\n"}, {"name": "numpy.logical_xor()", "path": "reference/generated/numpy.logical_xor", "type": "numpy.logical_xor", "text": "\nCompute the truth value of x1 XOR x2, element-wise.\n\n"}, {"name": "numpy.logspace()", "path": "reference/generated/numpy.logspace", "type": "numpy.logspace", "text": "\nReturn numbers spaced evenly on a log scale.\n\n"}, {"name": "numpy.longcomplex", "path": "reference/arrays.scalars#numpy.longcomplex", "type": "Scalars", "text": "\nalias of `numpy.clongdouble`\n\n"}, {"name": "numpy.longdouble", "path": "reference/arrays.scalars#numpy.longdouble", "type": "Scalars", "text": "\nExtended-precision floating-point number type, compatible with C `long double`\nbut not necessarily with IEEE 754 quadruple-precision.\n\n"}, {"name": "numpy.longfloat", "path": "reference/arrays.scalars#numpy.longfloat", "type": "Scalars", "text": "\nalias of `numpy.longdouble`\n\n"}, {"name": "numpy.longlong", "path": "reference/arrays.scalars#numpy.longlong", "type": "Scalars", "text": "\nSigned integer type, compatible with C `long long`.\n\n"}, {"name": "numpy.lookfor()", "path": "reference/generated/numpy.lookfor", "type": "numpy.lookfor", "text": "\nDo a keyword search on docstrings.\n\n"}, {"name": "numpy.ma.masked", "path": "reference/maskedarray.baseclass", "type": "Constants of the \n        \n         numpy.ma\n        \n        module", "text": "\nIn addition to the `MaskedArray` class, the `numpy.ma` module defines several\nconstants.\n\n"}, {"name": "numpy.ma.masked_array", "path": "reference/generated/numpy.ma.masked_array", "type": "numpy.ma.masked_array", "text": "\nalias of `numpy.ma.core.MaskedArray`\n\n"}, {"name": "numpy.ma.masked_print_options", "path": "reference/maskedarray.baseclass#numpy.ma.masked_print_options", "type": "Constants of the \n        \n         numpy.ma\n        \n        module", "text": "\nString used in lieu of missing data when a masked array is printed. By\ndefault, this string is `'--'`.\n\n"}, {"name": "numpy.ma.MaskType", "path": "reference/generated/numpy.ma.masktype", "type": "numpy.ma.MaskType", "text": "\nalias of `numpy.bool_`\n\n"}, {"name": "numpy.ma.nomask", "path": "reference/maskedarray.baseclass#numpy.ma.nomask", "type": "Constants of the \n        \n         numpy.ma\n        \n        module", "text": "\nValue indicating that a masked array has no invalid entry. `nomask` is used\ninternally to speed up computations when the mask is not needed. It is\nrepresented internally as `np.False_`.\n\n"}, {"name": "numpy.MachAr()", "path": "reference/generated/numpy.machar", "type": "numpy.MachAr", "text": "\nDiagnosing machine parameters.\n\n"}, {"name": "numpy.mask_indices()", "path": "reference/generated/numpy.mask_indices", "type": "numpy.mask_indices", "text": "\nReturn the indices to access (n, n) arrays, given a masking function.\n\n"}, {"name": "numpy.mat()", "path": "reference/generated/numpy.mat", "type": "numpy.mat", "text": "\nInterpret the input as a matrix.\n\n"}, {"name": "numpy.matmul()", "path": "reference/generated/numpy.matmul", "type": "numpy.matmul", "text": "\nMatrix product of two arrays.\n\n"}, {"name": "numpy.matrix()", "path": "reference/generated/numpy.matrix", "type": "numpy.matrix", "text": "\nNote\n\n"}, {"name": "numpy.maximum()", "path": "reference/generated/numpy.maximum", "type": "numpy.maximum", "text": "\nElement-wise maximum of array elements.\n\n"}, {"name": "numpy.maximum_sctype()", "path": "reference/generated/numpy.maximum_sctype", "type": "numpy.maximum_sctype", "text": "\nReturn the scalar type of highest precision of the same kind as the input.\n\n"}, {"name": "numpy.may_share_memory()", "path": "reference/generated/numpy.may_share_memory", "type": "numpy.may_share_memory", "text": "\nDetermine if two arrays might share memory\n\n"}, {"name": "numpy.mean()", "path": "reference/generated/numpy.mean", "type": "numpy.mean", "text": "\nCompute the arithmetic mean along the specified axis.\n\n"}, {"name": "numpy.median()", "path": "reference/generated/numpy.median", "type": "numpy.median", "text": "\nCompute the median along the specified axis.\n\n"}, {"name": "numpy.memmap()", "path": "reference/generated/numpy.memmap", "type": "numpy.memmap", "text": "\nCreate a memory-map to an array stored in a binary file on disk.\n\n"}, {"name": "numpy.meshgrid()", "path": "reference/generated/numpy.meshgrid", "type": "numpy.meshgrid", "text": "\nReturn coordinate matrices from coordinate vectors.\n\n"}, {"name": "numpy.mgrid", "path": "reference/generated/numpy.mgrid", "type": "numpy.mgrid", "text": "\n`nd_grid` instance which returns a dense multi-dimensional \u201cmeshgrid\u201d.\n\n"}, {"name": "numpy.min_scalar_type()", "path": "reference/generated/numpy.min_scalar_type", "type": "numpy.min_scalar_type", "text": "\nFor scalar `a`, returns the data type with the smallest size and smallest\nscalar kind which can hold its value. For non-scalar array `a`, returns the\nvector\u2019s dtype unmodified.\n\n"}, {"name": "numpy.minimum()", "path": "reference/generated/numpy.minimum", "type": "numpy.minimum", "text": "\nElement-wise minimum of array elements.\n\n"}, {"name": "numpy.mintypecode()", "path": "reference/generated/numpy.mintypecode", "type": "numpy.mintypecode", "text": "\nReturn the character for the minimum-size type to which given types can be\nsafely cast.\n\n"}, {"name": "numpy.mod()", "path": "reference/generated/numpy.mod", "type": "numpy.mod", "text": "\nReturns the element-wise remainder of division.\n\n"}, {"name": "numpy.modf()", "path": "reference/generated/numpy.modf", "type": "numpy.modf", "text": "\nReturn the fractional and integral parts of an array, element-wise.\n\n"}, {"name": "numpy.moveaxis()", "path": "reference/generated/numpy.moveaxis", "type": "numpy.moveaxis", "text": "\nMove axes of an array to new positions.\n\n"}, {"name": "numpy.msort()", "path": "reference/generated/numpy.msort", "type": "numpy.msort", "text": "\nReturn a copy of an array sorted along the first axis.\n\n"}, {"name": "numpy.multiply()", "path": "reference/generated/numpy.multiply", "type": "numpy.multiply", "text": "\nMultiply arguments element-wise.\n\n"}, {"name": "numpy.NAN", "path": "reference/constants#numpy.NAN", "type": "Constants", "text": "\nIEEE 754 floating point representation of Not a Number (NaN).\n\n"}, {"name": "numpy.NaN", "path": "reference/constants#numpy.NaN", "type": "Constants", "text": "\nIEEE 754 floating point representation of Not a Number (NaN).\n\n"}, {"name": "numpy.nan", "path": "reference/constants#numpy.nan", "type": "Constants", "text": "\nIEEE 754 floating point representation of Not a Number (NaN).\n\n"}, {"name": "numpy.nan_to_num()", "path": "reference/generated/numpy.nan_to_num", "type": "numpy.nan_to_num", "text": "\nReplace NaN with zero and infinity with large finite numbers (default\nbehaviour) or with the numbers defined by the user using the `nan`, `posinf`\nand/or `neginf` keywords.\n\n"}, {"name": "numpy.nanargmax()", "path": "reference/generated/numpy.nanargmax", "type": "numpy.nanargmax", "text": "\nReturn the indices of the maximum values in the specified axis ignoring NaNs.\nFor all-NaN slices `ValueError` is raised. Warning: the results cannot be\ntrusted if a slice contains only NaNs and -Infs.\n\n"}, {"name": "numpy.nanargmin()", "path": "reference/generated/numpy.nanargmin", "type": "numpy.nanargmin", "text": "\nReturn the indices of the minimum values in the specified axis ignoring NaNs.\nFor all-NaN slices `ValueError` is raised. Warning: the results cannot be\ntrusted if a slice contains only NaNs and Infs.\n\n"}, {"name": "numpy.nancumprod()", "path": "reference/generated/numpy.nancumprod", "type": "numpy.nancumprod", "text": "\nReturn the cumulative product of array elements over a given axis treating Not\na Numbers (NaNs) as one. The cumulative product does not change when NaNs are\nencountered and leading NaNs are replaced by ones.\n\n"}, {"name": "numpy.nancumsum()", "path": "reference/generated/numpy.nancumsum", "type": "numpy.nancumsum", "text": "\nReturn the cumulative sum of array elements over a given axis treating Not a\nNumbers (NaNs) as zero. The cumulative sum does not change when NaNs are\nencountered and leading NaNs are replaced by zeros.\n\n"}, {"name": "numpy.nanmax()", "path": "reference/generated/numpy.nanmax", "type": "numpy.nanmax", "text": "\nReturn the maximum of an array or maximum along an axis, ignoring any NaNs.\nWhen all-NaN slices are encountered a `RuntimeWarning` is raised and NaN is\nreturned for that slice.\n\n"}, {"name": "numpy.nanmean()", "path": "reference/generated/numpy.nanmean", "type": "numpy.nanmean", "text": "\nCompute the arithmetic mean along the specified axis, ignoring NaNs.\n\n"}, {"name": "numpy.nanmedian()", "path": "reference/generated/numpy.nanmedian", "type": "numpy.nanmedian", "text": "\nCompute the median along the specified axis, while ignoring NaNs.\n\n"}, {"name": "numpy.nanmin()", "path": "reference/generated/numpy.nanmin", "type": "numpy.nanmin", "text": "\nReturn minimum of an array or minimum along an axis, ignoring any NaNs. When\nall-NaN slices are encountered a `RuntimeWarning` is raised and Nan is\nreturned for that slice.\n\n"}, {"name": "numpy.nanpercentile()", "path": "reference/generated/numpy.nanpercentile", "type": "numpy.nanpercentile", "text": "\nCompute the qth percentile of the data along the specified axis, while\nignoring nan values.\n\n"}, {"name": "numpy.nanprod()", "path": "reference/generated/numpy.nanprod", "type": "numpy.nanprod", "text": "\nReturn the product of array elements over a given axis treating Not a Numbers\n(NaNs) as ones.\n\n"}, {"name": "numpy.nanquantile()", "path": "reference/generated/numpy.nanquantile", "type": "numpy.nanquantile", "text": "\nCompute the qth quantile of the data along the specified axis, while ignoring\nnan values. Returns the qth quantile(s) of the array elements.\n\n"}, {"name": "numpy.nanstd()", "path": "reference/generated/numpy.nanstd", "type": "numpy.nanstd", "text": "\nCompute the standard deviation along the specified axis, while ignoring NaNs.\n\n"}, {"name": "numpy.nansum()", "path": "reference/generated/numpy.nansum", "type": "numpy.nansum", "text": "\nReturn the sum of array elements over a given axis treating Not a Numbers\n(NaNs) as zero.\n\n"}, {"name": "numpy.nanvar()", "path": "reference/generated/numpy.nanvar", "type": "numpy.nanvar", "text": "\nCompute the variance along the specified axis, while ignoring NaNs.\n\n"}, {"name": "numpy.ndarray()", "path": "reference/generated/numpy.ndarray", "type": "numpy.ndarray", "text": "\nAn array object represents a multidimensional, homogeneous array of fixed-size\nitems. An associated data-type object describes the format of each element in\nthe array (its byte-order, how many bytes it occupies in memory, whether it is\nan integer, a floating point number, or something else, etc.)\n\n"}, {"name": "numpy.ndenumerate()", "path": "reference/generated/numpy.ndenumerate", "type": "numpy.ndenumerate", "text": "\nMultidimensional index iterator.\n\n"}, {"name": "numpy.ndindex()", "path": "reference/generated/numpy.ndindex", "type": "numpy.ndindex", "text": "\nAn N-dimensional iterator object to index arrays.\n\n"}, {"name": "numpy.nditer()", "path": "reference/generated/numpy.nditer", "type": "numpy.nditer", "text": "\nEfficient multi-dimensional iterator object to iterate over arrays. To get\nstarted using this object, see the introductory guide to array iteration.\n\n"}, {"name": "numpy.negative()", "path": "reference/generated/numpy.negative", "type": "numpy.negative", "text": "\nNumerical negative, element-wise.\n\n"}, {"name": "numpy.nested_iters()", "path": "reference/generated/numpy.nested_iters", "type": "numpy.nested_iters", "text": "\nCreate nditers for use in nested loops\n\n"}, {"name": "numpy.newaxis", "path": "reference/constants#numpy.newaxis", "type": "Constants", "text": "\nA convenient alias for None, useful for indexing arrays.\n\n"}, {"name": "numpy.nextafter()", "path": "reference/generated/numpy.nextafter", "type": "numpy.nextafter", "text": "\nReturn the next floating-point value after x1 towards x2, element-wise.\n\n"}, {"name": "numpy.NINF", "path": "reference/constants#numpy.NINF", "type": "Constants", "text": "\nIEEE 754 floating point representation of negative infinity.\n\n"}, {"name": "numpy.nonzero()", "path": "reference/generated/numpy.nonzero", "type": "numpy.nonzero", "text": "\nReturn the indices of the elements that are non-zero.\n\n"}, {"name": "numpy.not_equal()", "path": "reference/generated/numpy.not_equal", "type": "numpy.not_equal", "text": "\nReturn (x1 != x2) element-wise.\n\n"}, {"name": "numpy.number", "path": "reference/arrays.scalars#numpy.number", "type": "Scalars", "text": "\nAbstract base class of all numeric scalar types.\n\n"}, {"name": "numpy.NZERO", "path": "reference/constants#numpy.NZERO", "type": "Constants", "text": "\nIEEE 754 floating point representation of negative zero.\n\n"}, {"name": "numpy.obj2sctype()", "path": "reference/generated/numpy.obj2sctype", "type": "numpy.obj2sctype", "text": "\nReturn the scalar dtype or NumPy equivalent of Python type of an object.\n\n"}, {"name": "numpy.object_", "path": "reference/arrays.scalars#numpy.object_", "type": "Scalars", "text": "\nAny Python object.\n\n"}, {"name": "numpy.ogrid", "path": "reference/generated/numpy.ogrid", "type": "numpy.ogrid", "text": "\n`nd_grid` instance which returns an open multi-dimensional \u201cmeshgrid\u201d.\n\n"}, {"name": "numpy.ones()", "path": "reference/generated/numpy.ones", "type": "numpy.ones", "text": "\nReturn a new array of given shape and type, filled with ones.\n\n"}, {"name": "numpy.ones_like()", "path": "reference/generated/numpy.ones_like", "type": "numpy.ones_like", "text": "\nReturn an array of ones with the same shape and type as a given array.\n\n"}, {"name": "numpy.outer()", "path": "reference/generated/numpy.outer", "type": "numpy.outer", "text": "\nCompute the outer product of two vectors.\n\n"}, {"name": "numpy.packbits()", "path": "reference/generated/numpy.packbits", "type": "numpy.packbits", "text": "\nPacks the elements of a binary-valued array into bits in a uint8 array.\n\n"}, {"name": "numpy.pad()", "path": "reference/generated/numpy.pad", "type": "numpy.pad", "text": "\nPad an array.\n\n"}, {"name": "numpy.partition()", "path": "reference/generated/numpy.partition", "type": "numpy.partition", "text": "\nReturn a partitioned copy of an array.\n\n"}, {"name": "numpy.percentile()", "path": "reference/generated/numpy.percentile", "type": "numpy.percentile", "text": "\nCompute the q-th percentile of the data along the specified axis.\n\n"}, {"name": "numpy.pi", "path": "reference/constants#numpy.pi", "type": "Constants", "text": "\n`pi = 3.1415926535897932384626433...`\n\n"}, {"name": "numpy.piecewise()", "path": "reference/generated/numpy.piecewise", "type": "numpy.piecewise", "text": "\nEvaluate a piecewise-defined function.\n\n"}, {"name": "numpy.PINF", "path": "reference/constants#numpy.PINF", "type": "Constants", "text": "\nIEEE 754 floating point representation of (positive) infinity.\n\n"}, {"name": "numpy.place()", "path": "reference/generated/numpy.place", "type": "numpy.place", "text": "\nChange elements of an array based on conditional and input values.\n\n"}, {"name": "numpy.poly()", "path": "reference/generated/numpy.poly", "type": "numpy.poly", "text": "\nFind the coefficients of a polynomial with the given sequence of roots.\n\n"}, {"name": "numpy.poly1d()", "path": "reference/generated/numpy.poly1d", "type": "numpy.poly1d", "text": "\nA one-dimensional polynomial class.\n\n"}, {"name": "numpy.polyadd()", "path": "reference/generated/numpy.polyadd", "type": "numpy.polyadd", "text": "\nFind the sum of two polynomials.\n\n"}, {"name": "numpy.polyder()", "path": "reference/generated/numpy.polyder", "type": "numpy.polyder", "text": "\nReturn the derivative of the specified order of a polynomial.\n\n"}, {"name": "numpy.polydiv()", "path": "reference/generated/numpy.polydiv", "type": "numpy.polydiv", "text": "\nReturns the quotient and remainder of polynomial division.\n\n"}, {"name": "numpy.polyfit()", "path": "reference/generated/numpy.polyfit", "type": "numpy.polyfit", "text": "\nLeast squares polynomial fit.\n\n"}, {"name": "numpy.polyint()", "path": "reference/generated/numpy.polyint", "type": "numpy.polyint", "text": "\nReturn an antiderivative (indefinite integral) of a polynomial.\n\n"}, {"name": "numpy.polymul()", "path": "reference/generated/numpy.polymul", "type": "numpy.polymul", "text": "\nFind the product of two polynomials.\n\n"}, {"name": "numpy.polynomial.chebyshev.Chebyshev()", "path": "reference/generated/numpy.polynomial.chebyshev.chebyshev", "type": "numpy.polynomial.chebyshev.Chebyshev", "text": "\nA Chebyshev series class.\n\n"}, {"name": "numpy.polynomial.hermite.Hermite()", "path": "reference/generated/numpy.polynomial.hermite.hermite", "type": "numpy.polynomial.hermite.Hermite", "text": "\nAn Hermite series class.\n\n"}, {"name": "numpy.polynomial.hermite_e.HermiteE()", "path": "reference/generated/numpy.polynomial.hermite_e.hermitee", "type": "numpy.polynomial.hermite_e.HermiteE", "text": "\nAn HermiteE series class.\n\n"}, {"name": "numpy.polynomial.laguerre.Laguerre()", "path": "reference/generated/numpy.polynomial.laguerre.laguerre", "type": "numpy.polynomial.laguerre.Laguerre", "text": "\nA Laguerre series class.\n\n"}, {"name": "numpy.polynomial.legendre.Legendre()", "path": "reference/generated/numpy.polynomial.legendre.legendre", "type": "numpy.polynomial.legendre.Legendre", "text": "\nA Legendre series class.\n\n"}, {"name": "numpy.polynomial.polynomial.Polynomial()", "path": "reference/generated/numpy.polynomial.polynomial.polynomial", "type": "numpy.polynomial.polynomial.Polynomial", "text": "\nA power series class.\n\n"}, {"name": "numpy.polysub()", "path": "reference/generated/numpy.polysub", "type": "numpy.polysub", "text": "\nDifference (subtraction) of two polynomials.\n\n"}, {"name": "numpy.polyval()", "path": "reference/generated/numpy.polyval", "type": "numpy.polyval", "text": "\nEvaluate a polynomial at specific values.\n\n"}, {"name": "numpy.positive()", "path": "reference/generated/numpy.positive", "type": "numpy.positive", "text": "\nNumerical positive, element-wise.\n\n"}, {"name": "numpy.power()", "path": "reference/generated/numpy.power", "type": "numpy.power", "text": "\nFirst array elements raised to powers from second array, element-wise.\n\n"}, {"name": "numpy.printoptions()", "path": "reference/generated/numpy.printoptions", "type": "numpy.printoptions", "text": "\nContext manager for setting print options.\n\n"}, {"name": "numpy.prod()", "path": "reference/generated/numpy.prod", "type": "numpy.prod", "text": "\nReturn the product of array elements over a given axis.\n\n"}, {"name": "numpy.promote_types()", "path": "reference/generated/numpy.promote_types", "type": "numpy.promote_types", "text": "\nReturns the data type with the smallest size and smallest scalar kind to which\nboth `type1` and `type2` may be safely cast. The returned data type is always\nin native byte order.\n\n"}, {"name": "numpy.ptp()", "path": "reference/generated/numpy.ptp", "type": "numpy.ptp", "text": "\nRange of values (maximum - minimum) along an axis.\n\n"}, {"name": "numpy.put()", "path": "reference/generated/numpy.put", "type": "numpy.put", "text": "\nReplaces specified elements of an array with given values.\n\n"}, {"name": "numpy.put_along_axis()", "path": "reference/generated/numpy.put_along_axis", "type": "numpy.put_along_axis", "text": "\nPut values into the destination array by matching 1d index and data slices.\n\n"}, {"name": "numpy.putmask()", "path": "reference/generated/numpy.putmask", "type": "numpy.putmask", "text": "\nChanges elements of an array based on conditional and input values.\n\n"}, {"name": "numpy.PZERO", "path": "reference/constants#numpy.PZERO", "type": "Constants", "text": "\nIEEE 754 floating point representation of positive zero.\n\n"}, {"name": "numpy.quantile()", "path": "reference/generated/numpy.quantile", "type": "numpy.quantile", "text": "\nCompute the q-th quantile of the data along the specified axis.\n\n"}, {"name": "numpy.r_", "path": "reference/generated/numpy.r_", "type": "numpy.r_", "text": "\nTranslates slice objects to concatenation along the first axis.\n\n"}, {"name": "numpy.rad2deg()", "path": "reference/generated/numpy.rad2deg", "type": "numpy.rad2deg", "text": "\nConvert angles from radians to degrees.\n\n"}, {"name": "numpy.radians()", "path": "reference/generated/numpy.radians", "type": "numpy.radians", "text": "\nConvert angles from degrees to radians.\n\n"}, {"name": "numpy.random.BitGenerator()", "path": "reference/random/bit_generators/generated/numpy.random.bitgenerator", "type": "numpy.random.BitGenerator", "text": "\nBase Class for generic BitGenerators, which provide a stream of random bits\nbased on different algorithms. Must be overridden.\n\n"}, {"name": "numpy.random.default_rng()", "path": "reference/random/generator", "type": "Random Generator", "text": "\nThe `Generator` provides access to a wide range of distributions, and served\nas a replacement for `RandomState`. The main difference between the two is\nthat `Generator` relies on an additional BitGenerator to manage state and\ngenerate the random bits, which are then transformed into random values from\nuseful distributions. The default BitGenerator used by `Generator` is `PCG64`.\nThe BitGenerator can be changed by passing an instantized BitGenerator to\n`Generator`.\n\n"}, {"name": "numpy.random.Generator()", "path": "reference/random/generator#numpy.random.Generator", "type": "Random Generator", "text": "\nContainer for the BitGenerators.\n\n"}, {"name": "numpy.random.MT19937()", "path": "reference/random/bit_generators/mt19937", "type": "MT19937", "text": "\nContainer for the Mersenne Twister pseudo-random number generator.\n\n"}, {"name": "numpy.random.PCG64()", "path": "reference/random/bit_generators/pcg64", "type": "PCG64", "text": "\nBitGenerator for the PCG-64 pseudo-random number generator.\n\n"}, {"name": "numpy.random.PCG64DXSM()", "path": "reference/random/bit_generators/pcg64dxsm", "type": "PCG64DXSM", "text": "\nBitGenerator for the PCG-64 DXSM pseudo-random number generator.\n\n"}, {"name": "numpy.random.Philox()", "path": "reference/random/bit_generators/philox", "type": "Philox", "text": "\nContainer for the Philox (4x64) pseudo-random number generator.\n\n"}, {"name": "numpy.random.RandomState()", "path": "reference/random/legacy", "type": "Legacy Generator (RandomState)", "text": "\nThe `RandomState` provides access to legacy generators. This generator is\nconsidered frozen and will have no further improvements. It is guaranteed to\nproduce the same values as the final point release of NumPy v1.16. These all\ndepend on Box-Muller normals or inverse CDF exponentials or gammas. This class\nshould only be used if it is essential to have randoms that are identical to\nwhat would have been produced by previous versions of NumPy.\n\n"}, {"name": "numpy.random.SeedSequence()", "path": "reference/random/bit_generators/generated/numpy.random.seedsequence", "type": "Random sampling ( \n      \n       numpy.random\n      \n      )", "text": "\nSeedSequence mixes sources of entropy in a reproducible way to set the initial\nstate for independent and very probably non-overlapping BitGenerators.\n\n"}, {"name": "numpy.random.SFC64()", "path": "reference/random/bit_generators/sfc64", "type": "SFC64", "text": "\nBitGenerator for Chris Doty-Humphrey\u2019s Small Fast Chaotic PRNG.\n\n"}, {"name": "numpy.RankWarning", "path": "reference/generated/numpy.rankwarning", "type": "numpy.RankWarning", "text": "\nIssued by `polyfit` when the Vandermonde matrix is rank deficient.\n\n"}, {"name": "numpy.ravel()", "path": "reference/generated/numpy.ravel", "type": "numpy.ravel", "text": "\nReturn a contiguous flattened array.\n\n"}, {"name": "numpy.ravel_multi_index()", "path": "reference/generated/numpy.ravel_multi_index", "type": "numpy.ravel_multi_index", "text": "\nConverts a tuple of index arrays into an array of flat indices, applying\nboundary modes to the multi-index.\n\n"}, {"name": "numpy.real()", "path": "reference/generated/numpy.real", "type": "numpy.real", "text": "\nReturn the real part of the complex argument.\n\n"}, {"name": "numpy.real_if_close()", "path": "reference/generated/numpy.real_if_close", "type": "numpy.real_if_close", "text": "\nIf input is complex with all imaginary parts close to zero, return real parts.\n\n"}, {"name": "numpy.recarray()", "path": "reference/generated/numpy.recarray", "type": "numpy.recarray", "text": "\nConstruct an ndarray that allows field access using attributes.\n\n"}, {"name": "numpy.reciprocal()", "path": "reference/generated/numpy.reciprocal", "type": "numpy.reciprocal", "text": "\nReturn the reciprocal of the argument, element-wise.\n\n"}, {"name": "numpy.record", "path": "reference/generated/numpy.record", "type": "numpy.record", "text": "\nA data-type scalar that allows field access as attribute lookup.\n\n"}, {"name": "numpy.remainder()", "path": "reference/generated/numpy.remainder", "type": "numpy.remainder", "text": "\nReturns the element-wise remainder of division.\n\n"}, {"name": "numpy.repeat()", "path": "reference/generated/numpy.repeat", "type": "numpy.repeat", "text": "\nRepeat elements of an array.\n\n"}, {"name": "numpy.require()", "path": "reference/generated/numpy.require", "type": "numpy.require", "text": "\nReturn an ndarray of the provided type that satisfies requirements.\n\n"}, {"name": "numpy.reshape()", "path": "reference/generated/numpy.reshape", "type": "numpy.reshape", "text": "\nGives a new shape to an array without changing its data.\n\n"}, {"name": "numpy.resize()", "path": "reference/generated/numpy.resize", "type": "numpy.resize", "text": "\nReturn a new array with the specified shape.\n\n"}, {"name": "numpy.result_type()", "path": "reference/generated/numpy.result_type", "type": "numpy.result_type", "text": "\nReturns the type that results from applying the NumPy type promotion rules to\nthe arguments.\n\n"}, {"name": "numpy.right_shift()", "path": "reference/generated/numpy.right_shift", "type": "numpy.right_shift", "text": "\nShift the bits of an integer to the right.\n\n"}, {"name": "numpy.rint()", "path": "reference/generated/numpy.rint", "type": "numpy.rint", "text": "\nRound elements of the array to the nearest integer.\n\n"}, {"name": "numpy.roll()", "path": "reference/generated/numpy.roll", "type": "numpy.roll", "text": "\nRoll array elements along a given axis.\n\n"}, {"name": "numpy.rollaxis()", "path": "reference/generated/numpy.rollaxis", "type": "numpy.rollaxis", "text": "\nRoll the specified axis backwards, until it lies in a given position.\n\n"}, {"name": "numpy.roots()", "path": "reference/generated/numpy.roots", "type": "numpy.roots", "text": "\nReturn the roots of a polynomial with coefficients given in p.\n\n"}, {"name": "numpy.rot90()", "path": "reference/generated/numpy.rot90", "type": "numpy.rot90", "text": "\nRotate an array by 90 degrees in the plane specified by axes.\n\n"}, {"name": "numpy.round_()", "path": "reference/generated/numpy.round_", "type": "numpy.round_", "text": "\nRound an array to the given number of decimals.\n\n"}, {"name": "numpy.row_stack()", "path": "reference/generated/numpy.row_stack", "type": "numpy.row_stack", "text": "\nStack arrays in sequence vertically (row wise).\n\n"}, {"name": "numpy.s_", "path": "reference/generated/numpy.s_", "type": "numpy.s_", "text": "\nA nicer way to build up index tuples for arrays.\n\n"}, {"name": "numpy.save()", "path": "reference/generated/numpy.save", "type": "numpy.save", "text": "\nSave an array to a binary file in NumPy `.npy` format.\n\n"}, {"name": "numpy.savetxt()", "path": "reference/generated/numpy.savetxt", "type": "numpy.savetxt", "text": "\nSave an array to a text file.\n\n"}, {"name": "numpy.savez()", "path": "reference/generated/numpy.savez", "type": "numpy.savez", "text": "\nSave several arrays into a single file in uncompressed `.npz` format.\n\n"}, {"name": "numpy.savez_compressed()", "path": "reference/generated/numpy.savez_compressed", "type": "numpy.savez_compressed", "text": "\nSave several arrays into a single file in compressed `.npz` format.\n\n"}, {"name": "numpy.sctype2char()", "path": "reference/generated/numpy.sctype2char", "type": "numpy.sctype2char", "text": "\nReturn the string representation of a scalar dtype.\n\n"}, {"name": "numpy.searchsorted()", "path": "reference/generated/numpy.searchsorted", "type": "numpy.searchsorted", "text": "\nFind indices where elements should be inserted to maintain order.\n\n"}, {"name": "numpy.select()", "path": "reference/generated/numpy.select", "type": "numpy.select", "text": "\nReturn an array drawn from elements in choicelist, depending on conditions.\n\n"}, {"name": "numpy.set_printoptions()", "path": "reference/generated/numpy.set_printoptions", "type": "numpy.set_printoptions", "text": "\nSet printing options.\n\n"}, {"name": "numpy.set_string_function()", "path": "reference/generated/numpy.set_string_function", "type": "numpy.set_string_function", "text": "\nSet a Python function to be used when pretty printing arrays.\n\n"}, {"name": "numpy.setbufsize()", "path": "reference/generated/numpy.setbufsize", "type": "numpy.setbufsize", "text": "\nSet the size of the buffer used in ufuncs.\n\n"}, {"name": "numpy.setdiff1d()", "path": "reference/generated/numpy.setdiff1d", "type": "numpy.setdiff1d", "text": "\nFind the set difference of two arrays.\n\n"}, {"name": "numpy.seterr()", "path": "reference/generated/numpy.seterr", "type": "numpy.seterr", "text": "\nSet how floating-point errors are handled.\n\n"}, {"name": "numpy.seterrcall()", "path": "reference/generated/numpy.seterrcall", "type": "numpy.seterrcall", "text": "\nSet the floating-point error callback function or log object.\n\n"}, {"name": "numpy.seterrobj()", "path": "reference/generated/numpy.seterrobj", "type": "numpy.seterrobj", "text": "\nSet the object that defines floating-point error handling.\n\n"}, {"name": "numpy.setxor1d()", "path": "reference/generated/numpy.setxor1d", "type": "numpy.setxor1d", "text": "\nFind the set exclusive-or of two arrays.\n\n"}, {"name": "numpy.shape()", "path": "reference/generated/numpy.shape", "type": "numpy.shape", "text": "\nReturn the shape of an array.\n\n"}, {"name": "numpy.shares_memory()", "path": "reference/generated/numpy.shares_memory", "type": "numpy.shares_memory", "text": "\nDetermine if two arrays share memory.\n\n"}, {"name": "numpy.short", "path": "reference/arrays.scalars#numpy.short", "type": "Scalars", "text": "\nSigned integer type, compatible with C `short`.\n\n"}, {"name": "numpy.show_config()", "path": "reference/generated/numpy.show_config", "type": "numpy.show_config", "text": "\nShow libraries in the system on which NumPy was built.\n\n"}, {"name": "numpy.sign()", "path": "reference/generated/numpy.sign", "type": "numpy.sign", "text": "\nReturns an element-wise indication of the sign of a number.\n\n"}, {"name": "numpy.signbit()", "path": "reference/generated/numpy.signbit", "type": "numpy.signbit", "text": "\nReturns element-wise True where signbit is set (less than zero).\n\n"}, {"name": "numpy.sin()", "path": "reference/generated/numpy.sin", "type": "numpy.sin", "text": "\nTrigonometric sine, element-wise.\n\n"}, {"name": "numpy.sinc()", "path": "reference/generated/numpy.sinc", "type": "numpy.sinc", "text": "\nReturn the normalized sinc function.\n\n"}, {"name": "numpy.single", "path": "reference/arrays.scalars#numpy.single", "type": "Scalars", "text": "\nSingle-precision floating-point number type, compatible with C `float`.\n\n"}, {"name": "numpy.singlecomplex", "path": "reference/arrays.scalars#numpy.singlecomplex", "type": "Scalars", "text": "\nalias of `numpy.csingle`\n\n"}, {"name": "numpy.sinh()", "path": "reference/generated/numpy.sinh", "type": "numpy.sinh", "text": "\nHyperbolic sine, element-wise.\n\n"}, {"name": "numpy.sort()", "path": "reference/generated/numpy.sort", "type": "numpy.sort", "text": "\nReturn a sorted copy of an array.\n\n"}, {"name": "numpy.sort_complex()", "path": "reference/generated/numpy.sort_complex", "type": "numpy.sort_complex", "text": "\nSort a complex array using the real part first, then the imaginary part.\n\n"}, {"name": "numpy.source()", "path": "reference/generated/numpy.source", "type": "numpy.source", "text": "\nPrint or write to a file the source code for a NumPy object.\n\n"}, {"name": "numpy.spacing()", "path": "reference/generated/numpy.spacing", "type": "numpy.spacing", "text": "\nReturn the distance between x and the nearest adjacent number.\n\n"}, {"name": "numpy.split()", "path": "reference/generated/numpy.split", "type": "numpy.split", "text": "\nSplit an array into multiple sub-arrays as views into `ary`.\n\n"}, {"name": "numpy.sqrt()", "path": "reference/generated/numpy.sqrt", "type": "numpy.sqrt", "text": "\nReturn the non-negative square-root of an array, element-wise.\n\n"}, {"name": "numpy.square()", "path": "reference/generated/numpy.square", "type": "numpy.square", "text": "\nReturn the element-wise square of the input.\n\n"}, {"name": "numpy.squeeze()", "path": "reference/generated/numpy.squeeze", "type": "numpy.squeeze", "text": "\nRemove axes of length one from `a`.\n\n"}, {"name": "numpy.stack()", "path": "reference/generated/numpy.stack", "type": "numpy.stack", "text": "\nJoin a sequence of arrays along a new axis.\n\n"}, {"name": "numpy.std()", "path": "reference/generated/numpy.std", "type": "numpy.std", "text": "\nCompute the standard deviation along the specified axis.\n\n"}, {"name": "numpy.str_", "path": "reference/arrays.scalars#numpy.str_", "type": "Scalars", "text": "\nA unicode string.\n\n"}, {"name": "numpy.string_", "path": "reference/arrays.scalars#numpy.string_", "type": "Scalars", "text": "\nalias of `numpy.bytes_`\n\n"}, {"name": "numpy.subtract()", "path": "reference/generated/numpy.subtract", "type": "numpy.subtract", "text": "\nSubtract arguments, element-wise.\n\n"}, {"name": "numpy.sum()", "path": "reference/generated/numpy.sum", "type": "numpy.sum", "text": "\nSum of array elements over a given axis.\n\n"}, {"name": "numpy.swapaxes()", "path": "reference/generated/numpy.swapaxes", "type": "numpy.swapaxes", "text": "\nInterchange two axes of an array.\n\n"}, {"name": "numpy.take()", "path": "reference/generated/numpy.take", "type": "numpy.take", "text": "\nTake elements from an array along an axis.\n\n"}, {"name": "numpy.take_along_axis()", "path": "reference/generated/numpy.take_along_axis", "type": "numpy.take_along_axis", "text": "\nTake values from the input array by matching 1d index and data slices.\n\n"}, {"name": "numpy.tan()", "path": "reference/generated/numpy.tan", "type": "numpy.tan", "text": "\nCompute tangent element-wise.\n\n"}, {"name": "numpy.tanh()", "path": "reference/generated/numpy.tanh", "type": "numpy.tanh", "text": "\nCompute hyperbolic tangent element-wise.\n\n"}, {"name": "numpy.tensordot()", "path": "reference/generated/numpy.tensordot", "type": "numpy.tensordot", "text": "\nCompute tensor dot product along specified axes.\n\n"}, {"name": "numpy.testing.extbuild.build_and_import_extension()", "path": "reference/testing", "type": "Testing Guidelines", "text": "\nUntil the 1.15 release, NumPy used the nose testing framework, it now uses the\npytest framework. The older framework is still maintained in order to support\ndownstream projects that use the old numpy framework, but all tests for NumPy\nshould use pytest.\n\n"}, {"name": "numpy.testing.suppress_warnings()", "path": "reference/generated/numpy.testing.suppress_warnings", "type": "numpy.testing.suppress_warnings", "text": "\nContext manager and decorator doing much the same as\n`warnings.catch_warnings`.\n\n"}, {"name": "numpy.testing.Tester", "path": "reference/generated/numpy.testing.tester", "type": "numpy.testing.Tester", "text": "\nalias of `numpy.testing._private.nosetester.NoseTester`\n\n"}, {"name": "numpy.tile()", "path": "reference/generated/numpy.tile", "type": "numpy.tile", "text": "\nConstruct an array by repeating A the number of times given by reps.\n\n"}, {"name": "numpy.timedelta64", "path": "reference/arrays.scalars#numpy.timedelta64", "type": "Scalars", "text": "\nA timedelta stored as a 64-bit integer.\n\n"}, {"name": "numpy.trace()", "path": "reference/generated/numpy.trace", "type": "numpy.trace", "text": "\nReturn the sum along diagonals of the array.\n\n"}, {"name": "numpy.transpose()", "path": "reference/generated/numpy.transpose", "type": "numpy.transpose", "text": "\nReverse or permute the axes of an array; returns the modified array.\n\n"}, {"name": "numpy.trapz()", "path": "reference/generated/numpy.trapz", "type": "numpy.trapz", "text": "\nIntegrate along the given axis using the composite trapezoidal rule.\n\n"}, {"name": "numpy.tri()", "path": "reference/generated/numpy.tri", "type": "numpy.tri", "text": "\nAn array with ones at and below the given diagonal and zeros elsewhere.\n\n"}, {"name": "numpy.tril()", "path": "reference/generated/numpy.tril", "type": "numpy.tril", "text": "\nLower triangle of an array.\n\n"}, {"name": "numpy.tril_indices()", "path": "reference/generated/numpy.tril_indices", "type": "numpy.tril_indices", "text": "\nReturn the indices for the lower-triangle of an (n, m) array.\n\n"}, {"name": "numpy.tril_indices_from()", "path": "reference/generated/numpy.tril_indices_from", "type": "numpy.tril_indices_from", "text": "\nReturn the indices for the lower-triangle of arr.\n\n"}, {"name": "numpy.trim_zeros()", "path": "reference/generated/numpy.trim_zeros", "type": "numpy.trim_zeros", "text": "\nTrim the leading and/or trailing zeros from a 1-D array or sequence.\n\n"}, {"name": "numpy.triu()", "path": "reference/generated/numpy.triu", "type": "numpy.triu", "text": "\nUpper triangle of an array.\n\n"}, {"name": "numpy.triu_indices()", "path": "reference/generated/numpy.triu_indices", "type": "numpy.triu_indices", "text": "\nReturn the indices for the upper-triangle of an (n, m) array.\n\n"}, {"name": "numpy.triu_indices_from()", "path": "reference/generated/numpy.triu_indices_from", "type": "numpy.triu_indices_from", "text": "\nReturn the indices for the upper-triangle of arr.\n\n"}, {"name": "numpy.true_divide()", "path": "reference/generated/numpy.true_divide", "type": "numpy.true_divide", "text": "\nReturns a true division of the inputs, element-wise.\n\n"}, {"name": "numpy.trunc()", "path": "reference/generated/numpy.trunc", "type": "numpy.trunc", "text": "\nReturn the truncated value of the input, element-wise.\n\n"}, {"name": "numpy.typename()", "path": "reference/generated/numpy.typename", "type": "numpy.typename", "text": "\nReturn a description for the given data type code.\n\n"}, {"name": "numpy.typing.ArrayLike", "path": "reference/typing", "type": "Typing ( \n    \n     numpy.typing\n    \n    )", "text": "\nNew in version 1.20.\n\n"}, {"name": "numpy.typing.DTypeLike", "path": "reference/typing#numpy.typing.DTypeLike", "type": "Typing ( \n    \n     numpy.typing\n    \n    )", "text": "\nA `Union` representing objects that can be coerced into a `dtype`.\n\n"}, {"name": "numpy.typing.NDArray", "path": "reference/typing#numpy.typing.NDArray", "type": "Typing ( \n    \n     numpy.typing\n    \n    )", "text": "\nA generic version of `np.ndarray[Any, np.dtype[+ScalarType]]`.\n\n"}, {"name": "numpy.ubyte", "path": "reference/arrays.scalars#numpy.ubyte", "type": "Scalars", "text": "\nUnsigned integer type, compatible with C `unsigned char`.\n\n"}, {"name": "numpy.ufunc", "path": "reference/generated/numpy.ufunc", "type": "numpy.ufunc", "text": "\nFunctions that operate element by element on whole arrays.\n\n"}, {"name": "numpy.uint", "path": "reference/arrays.scalars#numpy.uint", "type": "Scalars", "text": "\nUnsigned integer type, compatible with C `unsigned long`.\n\n"}, {"name": "numpy.uint16", "path": "reference/arrays.scalars#numpy.uint16", "type": "Scalars", "text": "\nAlias for the unsigned integer types (one of `numpy.ubyte`, `numpy.ushort`,\n`numpy.uintc`, `numpy.uint` and `numpy.ulonglong`) with the specified number\nof bits.\n\n"}, {"name": "numpy.uint32", "path": "reference/arrays.scalars#numpy.uint32", "type": "Scalars", "text": "\nAlias for the unsigned integer types (one of `numpy.ubyte`, `numpy.ushort`,\n`numpy.uintc`, `numpy.uint` and `numpy.ulonglong`) with the specified number\nof bits.\n\n"}, {"name": "numpy.uint64", "path": "reference/arrays.scalars#numpy.uint64", "type": "Scalars", "text": "\nAlias for the unsigned integer types (one of `numpy.ubyte`, `numpy.ushort`,\n`numpy.uintc`, `numpy.uint` and `numpy.ulonglong`) with the specified number\nof bits.\n\n"}, {"name": "numpy.uint8", "path": "reference/arrays.scalars#numpy.uint8", "type": "Scalars", "text": "\nAlias for the unsigned integer types (one of `numpy.ubyte`, `numpy.ushort`,\n`numpy.uintc`, `numpy.uint` and `numpy.ulonglong`) with the specified number\nof bits.\n\n"}, {"name": "numpy.uintc", "path": "reference/arrays.scalars#numpy.uintc", "type": "Scalars", "text": "\nUnsigned integer type, compatible with C `unsigned int`.\n\n"}, {"name": "numpy.uintp", "path": "reference/arrays.scalars#numpy.uintp", "type": "Scalars", "text": "\nAlias for the unsigned integer type (one of `numpy.ubyte`, `numpy.ushort`,\n`numpy.uintc`, `numpy.uint` and `np.ulonglong`) that is the same size as a\npointer.\n\n"}, {"name": "numpy.ulonglong", "path": "reference/arrays.scalars#numpy.ulonglong", "type": "Scalars", "text": "\nSigned integer type, compatible with C `unsigned long long`.\n\n"}, {"name": "numpy.unicode_", "path": "reference/arrays.scalars#numpy.unicode_", "type": "Scalars", "text": "\nalias of `numpy.str_`\n\n"}, {"name": "numpy.union1d()", "path": "reference/generated/numpy.union1d", "type": "numpy.union1d", "text": "\nFind the union of two arrays.\n\n"}, {"name": "numpy.unique()", "path": "reference/generated/numpy.unique", "type": "numpy.unique", "text": "\nFind the unique elements of an array.\n\n"}, {"name": "numpy.unpackbits()", "path": "reference/generated/numpy.unpackbits", "type": "numpy.unpackbits", "text": "\nUnpacks elements of a uint8 array into a binary-valued output array.\n\n"}, {"name": "numpy.unravel_index()", "path": "reference/generated/numpy.unravel_index", "type": "numpy.unravel_index", "text": "\nConverts a flat index or array of flat indices into a tuple of coordinate\narrays.\n\n"}, {"name": "numpy.unwrap()", "path": "reference/generated/numpy.unwrap", "type": "numpy.unwrap", "text": "\nUnwrap by taking the complement of large deltas with respect to the period.\n\n"}, {"name": "numpy.ushort", "path": "reference/arrays.scalars#numpy.ushort", "type": "Scalars", "text": "\nUnsigned integer type, compatible with C `unsigned short`.\n\n"}, {"name": "numpy.vander()", "path": "reference/generated/numpy.vander", "type": "numpy.vander", "text": "\nGenerate a Vandermonde matrix.\n\n"}, {"name": "numpy.var()", "path": "reference/generated/numpy.var", "type": "numpy.var", "text": "\nCompute the variance along the specified axis.\n\n"}, {"name": "numpy.vdot()", "path": "reference/generated/numpy.vdot", "type": "numpy.vdot", "text": "\nReturn the dot product of two vectors.\n\n"}, {"name": "numpy.vectorize()", "path": "reference/generated/numpy.vectorize", "type": "numpy.vectorize", "text": "\nGeneralized function class.\n\n"}, {"name": "numpy.void", "path": "reference/arrays.scalars#numpy.void", "type": "Scalars", "text": "\nEither an opaque sequence of bytes, or a structure.\n\n"}, {"name": "numpy.vsplit()", "path": "reference/generated/numpy.vsplit", "type": "numpy.vsplit", "text": "\nSplit an array into multiple sub-arrays vertically (row-wise).\n\n"}, {"name": "numpy.vstack()", "path": "reference/generated/numpy.vstack", "type": "numpy.vstack", "text": "\nStack arrays in sequence vertically (row wise).\n\n"}, {"name": "numpy.where()", "path": "reference/generated/numpy.where", "type": "numpy.where", "text": "\nReturn elements chosen from `x` or `y` depending on `condition`.\n\n"}, {"name": "numpy.who()", "path": "reference/generated/numpy.who", "type": "numpy.who", "text": "\nPrint the NumPy arrays in the given dictionary.\n\n"}, {"name": "numpy.zeros()", "path": "reference/generated/numpy.zeros", "type": "numpy.zeros", "text": "\nReturn a new array of given shape and type, filled with zeros.\n\n"}, {"name": "numpy.zeros_like()", "path": "reference/generated/numpy.zeros_like", "type": "numpy.zeros_like", "text": "\nReturn an array of zeros with the same shape and type as a given array.\n\n"}, {"name": "NumPy: the absolute basics for beginners", "path": "user/absolute_beginners", "type": "User Guide", "text": "\nWelcome to the absolute beginner\u2019s guide to NumPy! If you have comments or\nsuggestions, please don\u2019t hesitate to reach out!\n\n"}, {"name": "Optionally SciPy-accelerated routines (numpy.dual)", "path": "reference/routines.dual", "type": "Optionally SciPy-accelerated routines ( \n      \n       numpy.dual\n      \n      )", "text": "\nDeprecated since version 1.20.\n\n"}, {"name": "Padding Arrays", "path": "reference/routines.padding", "type": "Padding Arrays", "text": "\n`pad`(array, pad_width[, mode])\n\n"}, {"name": "Parameters", "path": "reference/distutils", "type": "Packaging ( \n    \n     numpy.distutils\n    \n    )", "text": "\nNumPy provides enhanced distutils functionality to make it easier to build and\ninstall sub-packages, auto-generate code, and extension modules that use\nFortran-compiled libraries. To use features of NumPy distutils, use the\n`setup` command from `numpy.distutils.core`. A useful `Configuration` class is\nalso provided in `numpy.distutils.misc_util` that can make it easier to\nconstruct keyword arguments to pass to the setup function (by passing the\ndictionary obtained from the todict() method of the class). More information\nis available in the NumPy Distutils - Users Guide.\n\n"}, {"name": "paths()", "path": "reference/distutils#numpy.distutils.misc_util.Configuration.paths", "type": "Packaging ( \n    \n     numpy.distutils\n    \n    )", "text": "\nApply glob to paths and prepend local_path if needed.\n\n"}, {"name": "Performance", "path": "reference/random/performance", "type": "Comparing Performance", "text": "\nThe recommended generator for general use is `PCG64` or its upgraded variant\n`PCG64DXSM` for heavily-parallel use cases. They are statistically high\nquality, full-featured, and fast on most platforms, but somewhat slow when\ncompiled for 32-bit processes. See Upgrading PCG64 with PCG64DXSM for details\non when heavy parallelism would indicate using `PCG64DXSM`.\n\n"}, {"name": "Poly1d", "path": "reference/routines.polynomials.poly1d", "type": "Poly1d", "text": "\n`poly1d`(c_or_r[, r, variable])\n\n"}, {"name": "poly1d.__call__()", "path": "reference/generated/numpy.poly1d.__call__", "type": "numpy.poly1d", "text": "\nmethod\n\n"}, {"name": "poly1d.deriv()", "path": "reference/generated/numpy.poly1d.deriv", "type": "numpy.poly1d", "text": "\nmethod\n\n"}, {"name": "poly1d.integ()", "path": "reference/generated/numpy.poly1d.integ", "type": "numpy.poly1d", "text": "\nmethod\n\n"}, {"name": "polynomial.chebyshev.cheb2poly()", "path": "reference/generated/numpy.polynomial.chebyshev.cheb2poly", "type": "numpy.polynomial.chebyshev.cheb2poly", "text": "\nConvert a Chebyshev series to a polynomial.\n\n"}, {"name": "polynomial.chebyshev.chebadd()", "path": "reference/generated/numpy.polynomial.chebyshev.chebadd", "type": "numpy.polynomial.chebyshev.chebadd", "text": "\nAdd one Chebyshev series to another.\n\n"}, {"name": "polynomial.chebyshev.chebcompanion()", "path": "reference/generated/numpy.polynomial.chebyshev.chebcompanion", "type": "numpy.polynomial.chebyshev.chebcompanion", "text": "\nReturn the scaled companion matrix of c.\n\n"}, {"name": "polynomial.chebyshev.chebder()", "path": "reference/generated/numpy.polynomial.chebyshev.chebder", "type": "numpy.polynomial.chebyshev.chebder", "text": "\nDifferentiate a Chebyshev series.\n\n"}, {"name": "polynomial.chebyshev.chebdiv()", "path": "reference/generated/numpy.polynomial.chebyshev.chebdiv", "type": "numpy.polynomial.chebyshev.chebdiv", "text": "\nDivide one Chebyshev series by another.\n\n"}, {"name": "polynomial.chebyshev.chebdomain", "path": "reference/generated/numpy.polynomial.chebyshev.chebdomain", "type": "numpy.polynomial.chebyshev.chebdomain", "text": "\nAn array object represents a multidimensional, homogeneous array of fixed-size\nitems. An associated data-type object describes the format of each element in\nthe array (its byte-order, how many bytes it occupies in memory, whether it is\nan integer, a floating point number, or something else, etc.)\n\n"}, {"name": "polynomial.chebyshev.chebfit()", "path": "reference/generated/numpy.polynomial.chebyshev.chebfit", "type": "numpy.polynomial.chebyshev.chebfit", "text": "\nLeast squares fit of Chebyshev series to data.\n\n"}, {"name": "polynomial.chebyshev.chebfromroots()", "path": "reference/generated/numpy.polynomial.chebyshev.chebfromroots", "type": "numpy.polynomial.chebyshev.chebfromroots", "text": "\nGenerate a Chebyshev series with given roots.\n\n"}, {"name": "polynomial.chebyshev.chebgauss()", "path": "reference/generated/numpy.polynomial.chebyshev.chebgauss", "type": "numpy.polynomial.chebyshev.chebgauss", "text": "\nGauss-Chebyshev quadrature.\n\n"}, {"name": "polynomial.chebyshev.chebgrid2d()", "path": "reference/generated/numpy.polynomial.chebyshev.chebgrid2d", "type": "numpy.polynomial.chebyshev.chebgrid2d", "text": "\nEvaluate a 2-D Chebyshev series on the Cartesian product of x and y.\n\n"}, {"name": "polynomial.chebyshev.chebgrid3d()", "path": "reference/generated/numpy.polynomial.chebyshev.chebgrid3d", "type": "numpy.polynomial.chebyshev.chebgrid3d", "text": "\nEvaluate a 3-D Chebyshev series on the Cartesian product of x, y, and z.\n\n"}, {"name": "polynomial.chebyshev.chebint()", "path": "reference/generated/numpy.polynomial.chebyshev.chebint", "type": "numpy.polynomial.chebyshev.chebint", "text": "\nIntegrate a Chebyshev series.\n\n"}, {"name": "polynomial.chebyshev.chebinterpolate()", "path": "reference/generated/numpy.polynomial.chebyshev.chebinterpolate", "type": "numpy.polynomial.chebyshev.chebinterpolate", "text": "\nInterpolate a function at the Chebyshev points of the first kind.\n\n"}, {"name": "polynomial.chebyshev.chebline()", "path": "reference/generated/numpy.polynomial.chebyshev.chebline", "type": "numpy.polynomial.chebyshev.chebline", "text": "\nChebyshev series whose graph is a straight line.\n\n"}, {"name": "polynomial.chebyshev.chebmul()", "path": "reference/generated/numpy.polynomial.chebyshev.chebmul", "type": "numpy.polynomial.chebyshev.chebmul", "text": "\nMultiply one Chebyshev series by another.\n\n"}, {"name": "polynomial.chebyshev.chebmulx()", "path": "reference/generated/numpy.polynomial.chebyshev.chebmulx", "type": "numpy.polynomial.chebyshev.chebmulx", "text": "\nMultiply a Chebyshev series by x.\n\n"}, {"name": "polynomial.chebyshev.chebone", "path": "reference/generated/numpy.polynomial.chebyshev.chebone", "type": "numpy.polynomial.chebyshev.chebone", "text": "\nAn array object represents a multidimensional, homogeneous array of fixed-size\nitems. An associated data-type object describes the format of each element in\nthe array (its byte-order, how many bytes it occupies in memory, whether it is\nan integer, a floating point number, or something else, etc.)\n\n"}, {"name": "polynomial.chebyshev.chebpow()", "path": "reference/generated/numpy.polynomial.chebyshev.chebpow", "type": "numpy.polynomial.chebyshev.chebpow", "text": "\nRaise a Chebyshev series to a power.\n\n"}, {"name": "polynomial.chebyshev.chebpts1()", "path": "reference/generated/numpy.polynomial.chebyshev.chebpts1", "type": "numpy.polynomial.chebyshev.chebpts1", "text": "\nChebyshev points of the first kind.\n\n"}, {"name": "polynomial.chebyshev.chebpts2()", "path": "reference/generated/numpy.polynomial.chebyshev.chebpts2", "type": "numpy.polynomial.chebyshev.chebpts2", "text": "\nChebyshev points of the second kind.\n\n"}, {"name": "polynomial.chebyshev.chebroots()", "path": "reference/generated/numpy.polynomial.chebyshev.chebroots", "type": "numpy.polynomial.chebyshev.chebroots", "text": "\nCompute the roots of a Chebyshev series.\n\n"}, {"name": "polynomial.chebyshev.chebsub()", "path": "reference/generated/numpy.polynomial.chebyshev.chebsub", "type": "numpy.polynomial.chebyshev.chebsub", "text": "\nSubtract one Chebyshev series from another.\n\n"}, {"name": "polynomial.chebyshev.chebtrim()", "path": "reference/generated/numpy.polynomial.chebyshev.chebtrim", "type": "numpy.polynomial.chebyshev.chebtrim", "text": "\nRemove \u201csmall\u201d \u201ctrailing\u201d coefficients from a polynomial.\n\n"}, {"name": "polynomial.chebyshev.chebval()", "path": "reference/generated/numpy.polynomial.chebyshev.chebval", "type": "numpy.polynomial.chebyshev.chebval", "text": "\nEvaluate a Chebyshev series at points x.\n\n"}, {"name": "polynomial.chebyshev.chebval2d()", "path": "reference/generated/numpy.polynomial.chebyshev.chebval2d", "type": "numpy.polynomial.chebyshev.chebval2d", "text": "\nEvaluate a 2-D Chebyshev series at points (x, y).\n\n"}, {"name": "polynomial.chebyshev.chebval3d()", "path": "reference/generated/numpy.polynomial.chebyshev.chebval3d", "type": "numpy.polynomial.chebyshev.chebval3d", "text": "\nEvaluate a 3-D Chebyshev series at points (x, y, z).\n\n"}, {"name": "polynomial.chebyshev.chebvander()", "path": "reference/generated/numpy.polynomial.chebyshev.chebvander", "type": "numpy.polynomial.chebyshev.chebvander", "text": "\nPseudo-Vandermonde matrix of given degree.\n\n"}, {"name": "polynomial.chebyshev.chebvander2d()", "path": "reference/generated/numpy.polynomial.chebyshev.chebvander2d", "type": "numpy.polynomial.chebyshev.chebvander2d", "text": "\nPseudo-Vandermonde matrix of given degrees.\n\n"}, {"name": "polynomial.chebyshev.chebvander3d()", "path": "reference/generated/numpy.polynomial.chebyshev.chebvander3d", "type": "numpy.polynomial.chebyshev.chebvander3d", "text": "\nPseudo-Vandermonde matrix of given degrees.\n\n"}, {"name": "polynomial.chebyshev.chebweight()", "path": "reference/generated/numpy.polynomial.chebyshev.chebweight", "type": "numpy.polynomial.chebyshev.chebweight", "text": "\nThe weight function of the Chebyshev polynomials.\n\n"}, {"name": "polynomial.chebyshev.chebx", "path": "reference/generated/numpy.polynomial.chebyshev.chebx", "type": "numpy.polynomial.chebyshev.chebx", "text": "\nAn array object represents a multidimensional, homogeneous array of fixed-size\nitems. An associated data-type object describes the format of each element in\nthe array (its byte-order, how many bytes it occupies in memory, whether it is\nan integer, a floating point number, or something else, etc.)\n\n"}, {"name": "polynomial.chebyshev.Chebyshev.__call__()", "path": "reference/generated/numpy.polynomial.chebyshev.chebyshev.__call__", "type": "numpy.polynomial.chebyshev.Chebyshev", "text": "\nmethod\n\n"}, {"name": "polynomial.chebyshev.Chebyshev.basis()", "path": "reference/generated/numpy.polynomial.chebyshev.chebyshev.basis", "type": "numpy.polynomial.chebyshev.Chebyshev", "text": "\nmethod\n\n"}, {"name": "polynomial.chebyshev.Chebyshev.cast()", "path": "reference/generated/numpy.polynomial.chebyshev.chebyshev.cast", "type": "numpy.polynomial.chebyshev.Chebyshev", "text": "\nmethod\n\n"}, {"name": "polynomial.chebyshev.Chebyshev.convert()", "path": "reference/generated/numpy.polynomial.chebyshev.chebyshev.convert", "type": "numpy.polynomial.chebyshev.Chebyshev", "text": "\nmethod\n\n"}, {"name": "polynomial.chebyshev.Chebyshev.copy()", "path": "reference/generated/numpy.polynomial.chebyshev.chebyshev.copy", "type": "numpy.polynomial.chebyshev.Chebyshev", "text": "\nmethod\n\n"}, {"name": "polynomial.chebyshev.Chebyshev.cutdeg()", "path": "reference/generated/numpy.polynomial.chebyshev.chebyshev.cutdeg", "type": "numpy.polynomial.chebyshev.Chebyshev", "text": "\nmethod\n\n"}, {"name": "polynomial.chebyshev.Chebyshev.degree()", "path": "reference/generated/numpy.polynomial.chebyshev.chebyshev.degree", "type": "numpy.polynomial.chebyshev.Chebyshev", "text": "\nmethod\n\n"}, {"name": "polynomial.chebyshev.Chebyshev.deriv()", "path": "reference/generated/numpy.polynomial.chebyshev.chebyshev.deriv", "type": "numpy.polynomial.chebyshev.Chebyshev", "text": "\nmethod\n\n"}, {"name": "polynomial.chebyshev.Chebyshev.domain", "path": "reference/generated/numpy.polynomial.chebyshev.chebyshev.domain", "type": "Polynomials", "text": "\nattribute\n\n"}, {"name": "polynomial.chebyshev.Chebyshev.fit()", "path": "reference/generated/numpy.polynomial.chebyshev.chebyshev.fit", "type": "numpy.polynomial.chebyshev.Chebyshev", "text": "\nmethod\n\n"}, {"name": "polynomial.chebyshev.Chebyshev.fromroots()", "path": "reference/generated/numpy.polynomial.chebyshev.chebyshev.fromroots", "type": "numpy.polynomial.chebyshev.Chebyshev", "text": "\nmethod\n\n"}, {"name": "polynomial.chebyshev.Chebyshev.has_samecoef()", "path": "reference/generated/numpy.polynomial.chebyshev.chebyshev.has_samecoef", "type": "numpy.polynomial.chebyshev.Chebyshev", "text": "\nmethod\n\n"}, {"name": "polynomial.chebyshev.Chebyshev.has_samedomain()", "path": "reference/generated/numpy.polynomial.chebyshev.chebyshev.has_samedomain", "type": "numpy.polynomial.chebyshev.Chebyshev", "text": "\nmethod\n\n"}, {"name": "polynomial.chebyshev.Chebyshev.has_sametype()", "path": "reference/generated/numpy.polynomial.chebyshev.chebyshev.has_sametype", "type": "numpy.polynomial.chebyshev.Chebyshev", "text": "\nmethod\n\n"}, {"name": "polynomial.chebyshev.Chebyshev.has_samewindow()", "path": "reference/generated/numpy.polynomial.chebyshev.chebyshev.has_samewindow", "type": "numpy.polynomial.chebyshev.Chebyshev", "text": "\nmethod\n\n"}, {"name": "polynomial.chebyshev.Chebyshev.identity()", "path": "reference/generated/numpy.polynomial.chebyshev.chebyshev.identity", "type": "numpy.polynomial.chebyshev.Chebyshev", "text": "\nmethod\n\n"}, {"name": "polynomial.chebyshev.Chebyshev.integ()", "path": "reference/generated/numpy.polynomial.chebyshev.chebyshev.integ", "type": "numpy.polynomial.chebyshev.Chebyshev", "text": "\nmethod\n\n"}, {"name": "polynomial.chebyshev.Chebyshev.interpolate()", "path": "reference/generated/numpy.polynomial.chebyshev.chebyshev.interpolate", "type": "numpy.polynomial.chebyshev.Chebyshev", "text": "\nmethod\n\n"}, {"name": "polynomial.chebyshev.Chebyshev.linspace()", "path": "reference/generated/numpy.polynomial.chebyshev.chebyshev.linspace", "type": "numpy.polynomial.chebyshev.Chebyshev", "text": "\nmethod\n\n"}, {"name": "polynomial.chebyshev.Chebyshev.mapparms()", "path": "reference/generated/numpy.polynomial.chebyshev.chebyshev.mapparms", "type": "numpy.polynomial.chebyshev.Chebyshev", "text": "\nmethod\n\n"}, {"name": "polynomial.chebyshev.Chebyshev.roots()", "path": "reference/generated/numpy.polynomial.chebyshev.chebyshev.roots", "type": "numpy.polynomial.chebyshev.Chebyshev", "text": "\nmethod\n\n"}, {"name": "polynomial.chebyshev.Chebyshev.trim()", "path": "reference/generated/numpy.polynomial.chebyshev.chebyshev.trim", "type": "numpy.polynomial.chebyshev.Chebyshev", "text": "\nmethod\n\n"}, {"name": "polynomial.chebyshev.Chebyshev.truncate()", "path": "reference/generated/numpy.polynomial.chebyshev.chebyshev.truncate", "type": "numpy.polynomial.chebyshev.Chebyshev", "text": "\nmethod\n\n"}, {"name": "polynomial.chebyshev.chebzero", "path": "reference/generated/numpy.polynomial.chebyshev.chebzero", "type": "numpy.polynomial.chebyshev.chebzero", "text": "\nAn array object represents a multidimensional, homogeneous array of fixed-size\nitems. An associated data-type object describes the format of each element in\nthe array (its byte-order, how many bytes it occupies in memory, whether it is\nan integer, a floating point number, or something else, etc.)\n\n"}, {"name": "polynomial.chebyshev.poly2cheb()", "path": "reference/generated/numpy.polynomial.chebyshev.poly2cheb", "type": "numpy.polynomial.chebyshev.poly2cheb", "text": "\nConvert a polynomial to a Chebyshev series.\n\n"}, {"name": "polynomial.hermite.herm2poly()", "path": "reference/generated/numpy.polynomial.hermite.herm2poly", "type": "numpy.polynomial.hermite.herm2poly", "text": "\nConvert a Hermite series to a polynomial.\n\n"}, {"name": "polynomial.hermite.hermadd()", "path": "reference/generated/numpy.polynomial.hermite.hermadd", "type": "numpy.polynomial.hermite.hermadd", "text": "\nAdd one Hermite series to another.\n\n"}, {"name": "polynomial.hermite.hermcompanion()", "path": "reference/generated/numpy.polynomial.hermite.hermcompanion", "type": "numpy.polynomial.hermite.hermcompanion", "text": "\nReturn the scaled companion matrix of c.\n\n"}, {"name": "polynomial.hermite.hermder()", "path": "reference/generated/numpy.polynomial.hermite.hermder", "type": "numpy.polynomial.hermite.hermder", "text": "\nDifferentiate a Hermite series.\n\n"}, {"name": "polynomial.hermite.hermdiv()", "path": "reference/generated/numpy.polynomial.hermite.hermdiv", "type": "numpy.polynomial.hermite.hermdiv", "text": "\nDivide one Hermite series by another.\n\n"}, {"name": "polynomial.hermite.hermdomain", "path": "reference/generated/numpy.polynomial.hermite.hermdomain", "type": "numpy.polynomial.hermite.hermdomain", "text": "\nAn array object represents a multidimensional, homogeneous array of fixed-size\nitems. An associated data-type object describes the format of each element in\nthe array (its byte-order, how many bytes it occupies in memory, whether it is\nan integer, a floating point number, or something else, etc.)\n\n"}, {"name": "polynomial.hermite.hermfit()", "path": "reference/generated/numpy.polynomial.hermite.hermfit", "type": "numpy.polynomial.hermite.hermfit", "text": "\nLeast squares fit of Hermite series to data.\n\n"}, {"name": "polynomial.hermite.hermfromroots()", "path": "reference/generated/numpy.polynomial.hermite.hermfromroots", "type": "numpy.polynomial.hermite.hermfromroots", "text": "\nGenerate a Hermite series with given roots.\n\n"}, {"name": "polynomial.hermite.hermgauss()", "path": "reference/generated/numpy.polynomial.hermite.hermgauss", "type": "numpy.polynomial.hermite.hermgauss", "text": "\nGauss-Hermite quadrature.\n\n"}, {"name": "polynomial.hermite.hermgrid2d()", "path": "reference/generated/numpy.polynomial.hermite.hermgrid2d", "type": "numpy.polynomial.hermite.hermgrid2d", "text": "\nEvaluate a 2-D Hermite series on the Cartesian product of x and y.\n\n"}, {"name": "polynomial.hermite.hermgrid3d()", "path": "reference/generated/numpy.polynomial.hermite.hermgrid3d", "type": "numpy.polynomial.hermite.hermgrid3d", "text": "\nEvaluate a 3-D Hermite series on the Cartesian product of x, y, and z.\n\n"}, {"name": "polynomial.hermite.hermint()", "path": "reference/generated/numpy.polynomial.hermite.hermint", "type": "numpy.polynomial.hermite.hermint", "text": "\nIntegrate a Hermite series.\n\n"}, {"name": "polynomial.hermite.Hermite.__call__()", "path": "reference/generated/numpy.polynomial.hermite.hermite.__call__", "type": "numpy.polynomial.hermite.Hermite", "text": "\nmethod\n\n"}, {"name": "polynomial.hermite.Hermite.basis()", "path": "reference/generated/numpy.polynomial.hermite.hermite.basis", "type": "numpy.polynomial.hermite.Hermite", "text": "\nmethod\n\n"}, {"name": "polynomial.hermite.Hermite.cast()", "path": "reference/generated/numpy.polynomial.hermite.hermite.cast", "type": "numpy.polynomial.hermite.Hermite", "text": "\nmethod\n\n"}, {"name": "polynomial.hermite.Hermite.convert()", "path": "reference/generated/numpy.polynomial.hermite.hermite.convert", "type": "numpy.polynomial.hermite.Hermite", "text": "\nmethod\n\n"}, {"name": "polynomial.hermite.Hermite.copy()", "path": "reference/generated/numpy.polynomial.hermite.hermite.copy", "type": "numpy.polynomial.hermite.Hermite", "text": "\nmethod\n\n"}, {"name": "polynomial.hermite.Hermite.cutdeg()", "path": "reference/generated/numpy.polynomial.hermite.hermite.cutdeg", "type": "numpy.polynomial.hermite.Hermite", "text": "\nmethod\n\n"}, {"name": "polynomial.hermite.Hermite.degree()", "path": "reference/generated/numpy.polynomial.hermite.hermite.degree", "type": "numpy.polynomial.hermite.Hermite", "text": "\nmethod\n\n"}, {"name": "polynomial.hermite.Hermite.deriv()", "path": "reference/generated/numpy.polynomial.hermite.hermite.deriv", "type": "numpy.polynomial.hermite.Hermite", "text": "\nmethod\n\n"}, {"name": "polynomial.hermite.Hermite.domain", "path": "reference/generated/numpy.polynomial.hermite.hermite.domain", "type": "Polynomials", "text": "\nattribute\n\n"}, {"name": "polynomial.hermite.Hermite.fit()", "path": "reference/generated/numpy.polynomial.hermite.hermite.fit", "type": "numpy.polynomial.hermite.Hermite", "text": "\nmethod\n\n"}, {"name": "polynomial.hermite.Hermite.fromroots()", "path": "reference/generated/numpy.polynomial.hermite.hermite.fromroots", "type": "numpy.polynomial.hermite.Hermite", "text": "\nmethod\n\n"}, {"name": "polynomial.hermite.Hermite.has_samecoef()", "path": "reference/generated/numpy.polynomial.hermite.hermite.has_samecoef", "type": "numpy.polynomial.hermite.Hermite", "text": "\nmethod\n\n"}, {"name": "polynomial.hermite.Hermite.has_samedomain()", "path": "reference/generated/numpy.polynomial.hermite.hermite.has_samedomain", "type": "numpy.polynomial.hermite.Hermite", "text": "\nmethod\n\n"}, {"name": "polynomial.hermite.Hermite.has_sametype()", "path": "reference/generated/numpy.polynomial.hermite.hermite.has_sametype", "type": "numpy.polynomial.hermite.Hermite", "text": "\nmethod\n\n"}, {"name": "polynomial.hermite.Hermite.has_samewindow()", "path": "reference/generated/numpy.polynomial.hermite.hermite.has_samewindow", "type": "numpy.polynomial.hermite.Hermite", "text": "\nmethod\n\n"}, {"name": "polynomial.hermite.Hermite.identity()", "path": "reference/generated/numpy.polynomial.hermite.hermite.identity", "type": "numpy.polynomial.hermite.Hermite", "text": "\nmethod\n\n"}, {"name": "polynomial.hermite.Hermite.integ()", "path": "reference/generated/numpy.polynomial.hermite.hermite.integ", "type": "numpy.polynomial.hermite.Hermite", "text": "\nmethod\n\n"}, {"name": "polynomial.hermite.Hermite.linspace()", "path": "reference/generated/numpy.polynomial.hermite.hermite.linspace", "type": "numpy.polynomial.hermite.Hermite", "text": "\nmethod\n\n"}, {"name": "polynomial.hermite.Hermite.mapparms()", "path": "reference/generated/numpy.polynomial.hermite.hermite.mapparms", "type": "numpy.polynomial.hermite.Hermite", "text": "\nmethod\n\n"}, {"name": "polynomial.hermite.Hermite.roots()", "path": "reference/generated/numpy.polynomial.hermite.hermite.roots", "type": "numpy.polynomial.hermite.Hermite", "text": "\nmethod\n\n"}, {"name": "polynomial.hermite.Hermite.trim()", "path": "reference/generated/numpy.polynomial.hermite.hermite.trim", "type": "numpy.polynomial.hermite.Hermite", "text": "\nmethod\n\n"}, {"name": "polynomial.hermite.Hermite.truncate()", "path": "reference/generated/numpy.polynomial.hermite.hermite.truncate", "type": "numpy.polynomial.hermite.Hermite", "text": "\nmethod\n\n"}, {"name": "polynomial.hermite.hermline()", "path": "reference/generated/numpy.polynomial.hermite.hermline", "type": "numpy.polynomial.hermite.hermline", "text": "\nHermite series whose graph is a straight line.\n\n"}, {"name": "polynomial.hermite.hermmul()", "path": "reference/generated/numpy.polynomial.hermite.hermmul", "type": "numpy.polynomial.hermite.hermmul", "text": "\nMultiply one Hermite series by another.\n\n"}, {"name": "polynomial.hermite.hermmulx()", "path": "reference/generated/numpy.polynomial.hermite.hermmulx", "type": "numpy.polynomial.hermite.hermmulx", "text": "\nMultiply a Hermite series by x.\n\n"}, {"name": "polynomial.hermite.hermone", "path": "reference/generated/numpy.polynomial.hermite.hermone", "type": "numpy.polynomial.hermite.hermone", "text": "\nAn array object represents a multidimensional, homogeneous array of fixed-size\nitems. An associated data-type object describes the format of each element in\nthe array (its byte-order, how many bytes it occupies in memory, whether it is\nan integer, a floating point number, or something else, etc.)\n\n"}, {"name": "polynomial.hermite.hermpow()", "path": "reference/generated/numpy.polynomial.hermite.hermpow", "type": "numpy.polynomial.hermite.hermpow", "text": "\nRaise a Hermite series to a power.\n\n"}, {"name": "polynomial.hermite.hermroots()", "path": "reference/generated/numpy.polynomial.hermite.hermroots", "type": "numpy.polynomial.hermite.hermroots", "text": "\nCompute the roots of a Hermite series.\n\n"}, {"name": "polynomial.hermite.hermsub()", "path": "reference/generated/numpy.polynomial.hermite.hermsub", "type": "numpy.polynomial.hermite.hermsub", "text": "\nSubtract one Hermite series from another.\n\n"}, {"name": "polynomial.hermite.hermtrim()", "path": "reference/generated/numpy.polynomial.hermite.hermtrim", "type": "numpy.polynomial.hermite.hermtrim", "text": "\nRemove \u201csmall\u201d \u201ctrailing\u201d coefficients from a polynomial.\n\n"}, {"name": "polynomial.hermite.hermval()", "path": "reference/generated/numpy.polynomial.hermite.hermval", "type": "numpy.polynomial.hermite.hermval", "text": "\nEvaluate an Hermite series at points x.\n\n"}, {"name": "polynomial.hermite.hermval2d()", "path": "reference/generated/numpy.polynomial.hermite.hermval2d", "type": "numpy.polynomial.hermite.hermval2d", "text": "\nEvaluate a 2-D Hermite series at points (x, y).\n\n"}, {"name": "polynomial.hermite.hermval3d()", "path": "reference/generated/numpy.polynomial.hermite.hermval3d", "type": "numpy.polynomial.hermite.hermval3d", "text": "\nEvaluate a 3-D Hermite series at points (x, y, z).\n\n"}, {"name": "polynomial.hermite.hermvander()", "path": "reference/generated/numpy.polynomial.hermite.hermvander", "type": "numpy.polynomial.hermite.hermvander", "text": "\nPseudo-Vandermonde matrix of given degree.\n\n"}, {"name": "polynomial.hermite.hermvander2d()", "path": "reference/generated/numpy.polynomial.hermite.hermvander2d", "type": "numpy.polynomial.hermite.hermvander2d", "text": "\nPseudo-Vandermonde matrix of given degrees.\n\n"}, {"name": "polynomial.hermite.hermvander3d()", "path": "reference/generated/numpy.polynomial.hermite.hermvander3d", "type": "numpy.polynomial.hermite.hermvander3d", "text": "\nPseudo-Vandermonde matrix of given degrees.\n\n"}, {"name": "polynomial.hermite.hermweight()", "path": "reference/generated/numpy.polynomial.hermite.hermweight", "type": "numpy.polynomial.hermite.hermweight", "text": "\nWeight function of the Hermite polynomials.\n\n"}, {"name": "polynomial.hermite.hermx", "path": "reference/generated/numpy.polynomial.hermite.hermx", "type": "numpy.polynomial.hermite.hermx", "text": "\nAn array object represents a multidimensional, homogeneous array of fixed-size\nitems. An associated data-type object describes the format of each element in\nthe array (its byte-order, how many bytes it occupies in memory, whether it is\nan integer, a floating point number, or something else, etc.)\n\n"}, {"name": "polynomial.hermite.hermzero", "path": "reference/generated/numpy.polynomial.hermite.hermzero", "type": "numpy.polynomial.hermite.hermzero", "text": "\nAn array object represents a multidimensional, homogeneous array of fixed-size\nitems. An associated data-type object describes the format of each element in\nthe array (its byte-order, how many bytes it occupies in memory, whether it is\nan integer, a floating point number, or something else, etc.)\n\n"}, {"name": "polynomial.hermite.poly2herm()", "path": "reference/generated/numpy.polynomial.hermite.poly2herm", "type": "numpy.polynomial.hermite.poly2herm", "text": "\nConvert a polynomial to a Hermite series.\n\n"}, {"name": "polynomial.hermite_e.herme2poly()", "path": "reference/generated/numpy.polynomial.hermite_e.herme2poly", "type": "numpy.polynomial.hermite_e.herme2poly", "text": "\nConvert a Hermite series to a polynomial.\n\n"}, {"name": "polynomial.hermite_e.hermeadd()", "path": "reference/generated/numpy.polynomial.hermite_e.hermeadd", "type": "numpy.polynomial.hermite_e.hermeadd", "text": "\nAdd one Hermite series to another.\n\n"}, {"name": "polynomial.hermite_e.hermecompanion()", "path": "reference/generated/numpy.polynomial.hermite_e.hermecompanion", "type": "numpy.polynomial.hermite_e.hermecompanion", "text": "\nReturn the scaled companion matrix of c.\n\n"}, {"name": "polynomial.hermite_e.hermeder()", "path": "reference/generated/numpy.polynomial.hermite_e.hermeder", "type": "numpy.polynomial.hermite_e.hermeder", "text": "\nDifferentiate a Hermite_e series.\n\n"}, {"name": "polynomial.hermite_e.hermediv()", "path": "reference/generated/numpy.polynomial.hermite_e.hermediv", "type": "numpy.polynomial.hermite_e.hermediv", "text": "\nDivide one Hermite series by another.\n\n"}, {"name": "polynomial.hermite_e.hermedomain", "path": "reference/generated/numpy.polynomial.hermite_e.hermedomain", "type": "numpy.polynomial.hermite_e.hermedomain", "text": "\nAn array object represents a multidimensional, homogeneous array of fixed-size\nitems. An associated data-type object describes the format of each element in\nthe array (its byte-order, how many bytes it occupies in memory, whether it is\nan integer, a floating point number, or something else, etc.)\n\n"}, {"name": "polynomial.hermite_e.hermefit()", "path": "reference/generated/numpy.polynomial.hermite_e.hermefit", "type": "numpy.polynomial.hermite_e.hermefit", "text": "\nLeast squares fit of Hermite series to data.\n\n"}, {"name": "polynomial.hermite_e.hermefromroots()", "path": "reference/generated/numpy.polynomial.hermite_e.hermefromroots", "type": "numpy.polynomial.hermite_e.hermefromroots", "text": "\nGenerate a HermiteE series with given roots.\n\n"}, {"name": "polynomial.hermite_e.hermegauss()", "path": "reference/generated/numpy.polynomial.hermite_e.hermegauss", "type": "numpy.polynomial.hermite_e.hermegauss", "text": "\nGauss-HermiteE quadrature.\n\n"}, {"name": "polynomial.hermite_e.hermegrid2d()", "path": "reference/generated/numpy.polynomial.hermite_e.hermegrid2d", "type": "numpy.polynomial.hermite_e.hermegrid2d", "text": "\nEvaluate a 2-D HermiteE series on the Cartesian product of x and y.\n\n"}, {"name": "polynomial.hermite_e.hermegrid3d()", "path": "reference/generated/numpy.polynomial.hermite_e.hermegrid3d", "type": "numpy.polynomial.hermite_e.hermegrid3d", "text": "\nEvaluate a 3-D HermiteE series on the Cartesian product of x, y, and z.\n\n"}, {"name": "polynomial.hermite_e.hermeint()", "path": "reference/generated/numpy.polynomial.hermite_e.hermeint", "type": "numpy.polynomial.hermite_e.hermeint", "text": "\nIntegrate a Hermite_e series.\n\n"}, {"name": "polynomial.hermite_e.hermeline()", "path": "reference/generated/numpy.polynomial.hermite_e.hermeline", "type": "numpy.polynomial.hermite_e.hermeline", "text": "\nHermite series whose graph is a straight line.\n\n"}, {"name": "polynomial.hermite_e.hermemul()", "path": "reference/generated/numpy.polynomial.hermite_e.hermemul", "type": "numpy.polynomial.hermite_e.hermemul", "text": "\nMultiply one Hermite series by another.\n\n"}, {"name": "polynomial.hermite_e.hermemulx()", "path": "reference/generated/numpy.polynomial.hermite_e.hermemulx", "type": "numpy.polynomial.hermite_e.hermemulx", "text": "\nMultiply a Hermite series by x.\n\n"}, {"name": "polynomial.hermite_e.hermeone", "path": "reference/generated/numpy.polynomial.hermite_e.hermeone", "type": "numpy.polynomial.hermite_e.hermeone", "text": "\nAn array object represents a multidimensional, homogeneous array of fixed-size\nitems. An associated data-type object describes the format of each element in\nthe array (its byte-order, how many bytes it occupies in memory, whether it is\nan integer, a floating point number, or something else, etc.)\n\n"}, {"name": "polynomial.hermite_e.hermepow()", "path": "reference/generated/numpy.polynomial.hermite_e.hermepow", "type": "numpy.polynomial.hermite_e.hermepow", "text": "\nRaise a Hermite series to a power.\n\n"}, {"name": "polynomial.hermite_e.hermeroots()", "path": "reference/generated/numpy.polynomial.hermite_e.hermeroots", "type": "numpy.polynomial.hermite_e.hermeroots", "text": "\nCompute the roots of a HermiteE series.\n\n"}, {"name": "polynomial.hermite_e.hermesub()", "path": "reference/generated/numpy.polynomial.hermite_e.hermesub", "type": "numpy.polynomial.hermite_e.hermesub", "text": "\nSubtract one Hermite series from another.\n\n"}, {"name": "polynomial.hermite_e.hermetrim()", "path": "reference/generated/numpy.polynomial.hermite_e.hermetrim", "type": "numpy.polynomial.hermite_e.hermetrim", "text": "\nRemove \u201csmall\u201d \u201ctrailing\u201d coefficients from a polynomial.\n\n"}, {"name": "polynomial.hermite_e.hermeval()", "path": "reference/generated/numpy.polynomial.hermite_e.hermeval", "type": "numpy.polynomial.hermite_e.hermeval", "text": "\nEvaluate an HermiteE series at points x.\n\n"}, {"name": "polynomial.hermite_e.hermeval2d()", "path": "reference/generated/numpy.polynomial.hermite_e.hermeval2d", "type": "numpy.polynomial.hermite_e.hermeval2d", "text": "\nEvaluate a 2-D HermiteE series at points (x, y).\n\n"}, {"name": "polynomial.hermite_e.hermeval3d()", "path": "reference/generated/numpy.polynomial.hermite_e.hermeval3d", "type": "numpy.polynomial.hermite_e.hermeval3d", "text": "\nEvaluate a 3-D Hermite_e series at points (x, y, z).\n\n"}, {"name": "polynomial.hermite_e.hermevander()", "path": "reference/generated/numpy.polynomial.hermite_e.hermevander", "type": "numpy.polynomial.hermite_e.hermevander", "text": "\nPseudo-Vandermonde matrix of given degree.\n\n"}, {"name": "polynomial.hermite_e.hermevander2d()", "path": "reference/generated/numpy.polynomial.hermite_e.hermevander2d", "type": "numpy.polynomial.hermite_e.hermevander2d", "text": "\nPseudo-Vandermonde matrix of given degrees.\n\n"}, {"name": "polynomial.hermite_e.hermevander3d()", "path": "reference/generated/numpy.polynomial.hermite_e.hermevander3d", "type": "numpy.polynomial.hermite_e.hermevander3d", "text": "\nPseudo-Vandermonde matrix of given degrees.\n\n"}, {"name": "polynomial.hermite_e.hermeweight()", "path": "reference/generated/numpy.polynomial.hermite_e.hermeweight", "type": "numpy.polynomial.hermite_e.hermeweight", "text": "\nWeight function of the Hermite_e polynomials.\n\n"}, {"name": "polynomial.hermite_e.hermex", "path": "reference/generated/numpy.polynomial.hermite_e.hermex", "type": "numpy.polynomial.hermite_e.hermex", "text": "\nAn array object represents a multidimensional, homogeneous array of fixed-size\nitems. An associated data-type object describes the format of each element in\nthe array (its byte-order, how many bytes it occupies in memory, whether it is\nan integer, a floating point number, or something else, etc.)\n\n"}, {"name": "polynomial.hermite_e.hermezero", "path": "reference/generated/numpy.polynomial.hermite_e.hermezero", "type": "numpy.polynomial.hermite_e.hermezero", "text": "\nAn array object represents a multidimensional, homogeneous array of fixed-size\nitems. An associated data-type object describes the format of each element in\nthe array (its byte-order, how many bytes it occupies in memory, whether it is\nan integer, a floating point number, or something else, etc.)\n\n"}, {"name": "polynomial.hermite_e.HermiteE.__call__()", "path": "reference/generated/numpy.polynomial.hermite_e.hermitee.__call__", "type": "numpy.polynomial.hermite_e.HermiteE", "text": "\nmethod\n\n"}, {"name": "polynomial.hermite_e.HermiteE.basis()", "path": "reference/generated/numpy.polynomial.hermite_e.hermitee.basis", "type": "numpy.polynomial.hermite_e.HermiteE", "text": "\nmethod\n\n"}, {"name": "polynomial.hermite_e.HermiteE.cast()", "path": "reference/generated/numpy.polynomial.hermite_e.hermitee.cast", "type": "numpy.polynomial.hermite_e.HermiteE", "text": "\nmethod\n\n"}, {"name": "polynomial.hermite_e.HermiteE.convert()", "path": "reference/generated/numpy.polynomial.hermite_e.hermitee.convert", "type": "numpy.polynomial.hermite_e.HermiteE", "text": "\nmethod\n\n"}, {"name": "polynomial.hermite_e.HermiteE.copy()", "path": "reference/generated/numpy.polynomial.hermite_e.hermitee.copy", "type": "numpy.polynomial.hermite_e.HermiteE", "text": "\nmethod\n\n"}, {"name": "polynomial.hermite_e.HermiteE.cutdeg()", "path": "reference/generated/numpy.polynomial.hermite_e.hermitee.cutdeg", "type": "numpy.polynomial.hermite_e.HermiteE", "text": "\nmethod\n\n"}, {"name": "polynomial.hermite_e.HermiteE.degree()", "path": "reference/generated/numpy.polynomial.hermite_e.hermitee.degree", "type": "numpy.polynomial.hermite_e.HermiteE", "text": "\nmethod\n\n"}, {"name": "polynomial.hermite_e.HermiteE.deriv()", "path": "reference/generated/numpy.polynomial.hermite_e.hermitee.deriv", "type": "numpy.polynomial.hermite_e.HermiteE", "text": "\nmethod\n\n"}, {"name": "polynomial.hermite_e.HermiteE.domain", "path": "reference/generated/numpy.polynomial.hermite_e.hermitee.domain", "type": "Polynomials", "text": "\nattribute\n\n"}, {"name": "polynomial.hermite_e.HermiteE.fit()", "path": "reference/generated/numpy.polynomial.hermite_e.hermitee.fit", "type": "numpy.polynomial.hermite_e.HermiteE", "text": "\nmethod\n\n"}, {"name": "polynomial.hermite_e.HermiteE.fromroots()", "path": "reference/generated/numpy.polynomial.hermite_e.hermitee.fromroots", "type": "numpy.polynomial.hermite_e.HermiteE", "text": "\nmethod\n\n"}, {"name": "polynomial.hermite_e.HermiteE.has_samecoef()", "path": "reference/generated/numpy.polynomial.hermite_e.hermitee.has_samecoef", "type": "numpy.polynomial.hermite_e.HermiteE", "text": "\nmethod\n\n"}, {"name": "polynomial.hermite_e.HermiteE.has_samedomain()", "path": "reference/generated/numpy.polynomial.hermite_e.hermitee.has_samedomain", "type": "numpy.polynomial.hermite_e.HermiteE", "text": "\nmethod\n\n"}, {"name": "polynomial.hermite_e.HermiteE.has_sametype()", "path": "reference/generated/numpy.polynomial.hermite_e.hermitee.has_sametype", "type": "numpy.polynomial.hermite_e.HermiteE", "text": "\nmethod\n\n"}, {"name": "polynomial.hermite_e.HermiteE.has_samewindow()", "path": "reference/generated/numpy.polynomial.hermite_e.hermitee.has_samewindow", "type": "numpy.polynomial.hermite_e.HermiteE", "text": "\nmethod\n\n"}, {"name": "polynomial.hermite_e.HermiteE.identity()", "path": "reference/generated/numpy.polynomial.hermite_e.hermitee.identity", "type": "numpy.polynomial.hermite_e.HermiteE", "text": "\nmethod\n\n"}, {"name": "polynomial.hermite_e.HermiteE.integ()", "path": "reference/generated/numpy.polynomial.hermite_e.hermitee.integ", "type": "numpy.polynomial.hermite_e.HermiteE", "text": "\nmethod\n\n"}, {"name": "polynomial.hermite_e.HermiteE.linspace()", "path": "reference/generated/numpy.polynomial.hermite_e.hermitee.linspace", "type": "numpy.polynomial.hermite_e.HermiteE", "text": "\nmethod\n\n"}, {"name": "polynomial.hermite_e.HermiteE.mapparms()", "path": "reference/generated/numpy.polynomial.hermite_e.hermitee.mapparms", "type": "numpy.polynomial.hermite_e.HermiteE", "text": "\nmethod\n\n"}, {"name": "polynomial.hermite_e.HermiteE.roots()", "path": "reference/generated/numpy.polynomial.hermite_e.hermitee.roots", "type": "numpy.polynomial.hermite_e.HermiteE", "text": "\nmethod\n\n"}, {"name": "polynomial.hermite_e.HermiteE.trim()", "path": "reference/generated/numpy.polynomial.hermite_e.hermitee.trim", "type": "numpy.polynomial.hermite_e.HermiteE", "text": "\nmethod\n\n"}, {"name": "polynomial.hermite_e.HermiteE.truncate()", "path": "reference/generated/numpy.polynomial.hermite_e.hermitee.truncate", "type": "numpy.polynomial.hermite_e.HermiteE", "text": "\nmethod\n\n"}, {"name": "polynomial.hermite_e.poly2herme()", "path": "reference/generated/numpy.polynomial.hermite_e.poly2herme", "type": "numpy.polynomial.hermite_e.poly2herme", "text": "\nConvert a polynomial to a Hermite series.\n\n"}, {"name": "polynomial.laguerre.lag2poly()", "path": "reference/generated/numpy.polynomial.laguerre.lag2poly", "type": "numpy.polynomial.laguerre.lag2poly", "text": "\nConvert a Laguerre series to a polynomial.\n\n"}, {"name": "polynomial.laguerre.lagadd()", "path": "reference/generated/numpy.polynomial.laguerre.lagadd", "type": "numpy.polynomial.laguerre.lagadd", "text": "\nAdd one Laguerre series to another.\n\n"}, {"name": "polynomial.laguerre.lagcompanion()", "path": "reference/generated/numpy.polynomial.laguerre.lagcompanion", "type": "numpy.polynomial.laguerre.lagcompanion", "text": "\nReturn the companion matrix of c.\n\n"}, {"name": "polynomial.laguerre.lagder()", "path": "reference/generated/numpy.polynomial.laguerre.lagder", "type": "numpy.polynomial.laguerre.lagder", "text": "\nDifferentiate a Laguerre series.\n\n"}, {"name": "polynomial.laguerre.lagdiv()", "path": "reference/generated/numpy.polynomial.laguerre.lagdiv", "type": "numpy.polynomial.laguerre.lagdiv", "text": "\nDivide one Laguerre series by another.\n\n"}, {"name": "polynomial.laguerre.lagdomain", "path": "reference/generated/numpy.polynomial.laguerre.lagdomain", "type": "numpy.polynomial.laguerre.lagdomain", "text": "\nAn array object represents a multidimensional, homogeneous array of fixed-size\nitems. An associated data-type object describes the format of each element in\nthe array (its byte-order, how many bytes it occupies in memory, whether it is\nan integer, a floating point number, or something else, etc.)\n\n"}, {"name": "polynomial.laguerre.lagfit()", "path": "reference/generated/numpy.polynomial.laguerre.lagfit", "type": "numpy.polynomial.laguerre.lagfit", "text": "\nLeast squares fit of Laguerre series to data.\n\n"}, {"name": "polynomial.laguerre.lagfromroots()", "path": "reference/generated/numpy.polynomial.laguerre.lagfromroots", "type": "numpy.polynomial.laguerre.lagfromroots", "text": "\nGenerate a Laguerre series with given roots.\n\n"}, {"name": "polynomial.laguerre.laggauss()", "path": "reference/generated/numpy.polynomial.laguerre.laggauss", "type": "numpy.polynomial.laguerre.laggauss", "text": "\nGauss-Laguerre quadrature.\n\n"}, {"name": "polynomial.laguerre.laggrid2d()", "path": "reference/generated/numpy.polynomial.laguerre.laggrid2d", "type": "numpy.polynomial.laguerre.laggrid2d", "text": "\nEvaluate a 2-D Laguerre series on the Cartesian product of x and y.\n\n"}, {"name": "polynomial.laguerre.laggrid3d()", "path": "reference/generated/numpy.polynomial.laguerre.laggrid3d", "type": "numpy.polynomial.laguerre.laggrid3d", "text": "\nEvaluate a 3-D Laguerre series on the Cartesian product of x, y, and z.\n\n"}, {"name": "polynomial.laguerre.lagint()", "path": "reference/generated/numpy.polynomial.laguerre.lagint", "type": "numpy.polynomial.laguerre.lagint", "text": "\nIntegrate a Laguerre series.\n\n"}, {"name": "polynomial.laguerre.lagline()", "path": "reference/generated/numpy.polynomial.laguerre.lagline", "type": "numpy.polynomial.laguerre.lagline", "text": "\nLaguerre series whose graph is a straight line.\n\n"}, {"name": "polynomial.laguerre.lagmul()", "path": "reference/generated/numpy.polynomial.laguerre.lagmul", "type": "numpy.polynomial.laguerre.lagmul", "text": "\nMultiply one Laguerre series by another.\n\n"}, {"name": "polynomial.laguerre.lagmulx()", "path": "reference/generated/numpy.polynomial.laguerre.lagmulx", "type": "numpy.polynomial.laguerre.lagmulx", "text": "\nMultiply a Laguerre series by x.\n\n"}, {"name": "polynomial.laguerre.lagone", "path": "reference/generated/numpy.polynomial.laguerre.lagone", "type": "numpy.polynomial.laguerre.lagone", "text": "\nAn array object represents a multidimensional, homogeneous array of fixed-size\nitems. An associated data-type object describes the format of each element in\nthe array (its byte-order, how many bytes it occupies in memory, whether it is\nan integer, a floating point number, or something else, etc.)\n\n"}, {"name": "polynomial.laguerre.lagpow()", "path": "reference/generated/numpy.polynomial.laguerre.lagpow", "type": "numpy.polynomial.laguerre.lagpow", "text": "\nRaise a Laguerre series to a power.\n\n"}, {"name": "polynomial.laguerre.lagroots()", "path": "reference/generated/numpy.polynomial.laguerre.lagroots", "type": "numpy.polynomial.laguerre.lagroots", "text": "\nCompute the roots of a Laguerre series.\n\n"}, {"name": "polynomial.laguerre.lagsub()", "path": "reference/generated/numpy.polynomial.laguerre.lagsub", "type": "numpy.polynomial.laguerre.lagsub", "text": "\nSubtract one Laguerre series from another.\n\n"}, {"name": "polynomial.laguerre.lagtrim()", "path": "reference/generated/numpy.polynomial.laguerre.lagtrim", "type": "numpy.polynomial.laguerre.lagtrim", "text": "\nRemove \u201csmall\u201d \u201ctrailing\u201d coefficients from a polynomial.\n\n"}, {"name": "polynomial.laguerre.Laguerre.__call__()", "path": "reference/generated/numpy.polynomial.laguerre.laguerre.__call__", "type": "numpy.polynomial.laguerre.Laguerre", "text": "\nmethod\n\n"}, {"name": "polynomial.laguerre.Laguerre.basis()", "path": "reference/generated/numpy.polynomial.laguerre.laguerre.basis", "type": "numpy.polynomial.laguerre.Laguerre", "text": "\nmethod\n\n"}, {"name": "polynomial.laguerre.Laguerre.cast()", "path": "reference/generated/numpy.polynomial.laguerre.laguerre.cast", "type": "numpy.polynomial.laguerre.Laguerre", "text": "\nmethod\n\n"}, {"name": "polynomial.laguerre.Laguerre.convert()", "path": "reference/generated/numpy.polynomial.laguerre.laguerre.convert", "type": "numpy.polynomial.laguerre.Laguerre", "text": "\nmethod\n\n"}, {"name": "polynomial.laguerre.Laguerre.copy()", "path": "reference/generated/numpy.polynomial.laguerre.laguerre.copy", "type": "numpy.polynomial.laguerre.Laguerre", "text": "\nmethod\n\n"}, {"name": "polynomial.laguerre.Laguerre.cutdeg()", "path": "reference/generated/numpy.polynomial.laguerre.laguerre.cutdeg", "type": "numpy.polynomial.laguerre.Laguerre", "text": "\nmethod\n\n"}, {"name": "polynomial.laguerre.Laguerre.degree()", "path": "reference/generated/numpy.polynomial.laguerre.laguerre.degree", "type": "numpy.polynomial.laguerre.Laguerre", "text": "\nmethod\n\n"}, {"name": "polynomial.laguerre.Laguerre.deriv()", "path": "reference/generated/numpy.polynomial.laguerre.laguerre.deriv", "type": "numpy.polynomial.laguerre.Laguerre", "text": "\nmethod\n\n"}, {"name": "polynomial.laguerre.Laguerre.domain", "path": "reference/generated/numpy.polynomial.laguerre.laguerre.domain", "type": "Polynomials", "text": "\nattribute\n\n"}, {"name": "polynomial.laguerre.Laguerre.fit()", "path": "reference/generated/numpy.polynomial.laguerre.laguerre.fit", "type": "numpy.polynomial.laguerre.Laguerre", "text": "\nmethod\n\n"}, {"name": "polynomial.laguerre.Laguerre.fromroots()", "path": "reference/generated/numpy.polynomial.laguerre.laguerre.fromroots", "type": "numpy.polynomial.laguerre.Laguerre", "text": "\nmethod\n\n"}, {"name": "polynomial.laguerre.Laguerre.has_samecoef()", "path": "reference/generated/numpy.polynomial.laguerre.laguerre.has_samecoef", "type": "numpy.polynomial.laguerre.Laguerre", "text": "\nmethod\n\n"}, {"name": "polynomial.laguerre.Laguerre.has_samedomain()", "path": "reference/generated/numpy.polynomial.laguerre.laguerre.has_samedomain", "type": "numpy.polynomial.laguerre.Laguerre", "text": "\nmethod\n\n"}, {"name": "polynomial.laguerre.Laguerre.has_sametype()", "path": "reference/generated/numpy.polynomial.laguerre.laguerre.has_sametype", "type": "numpy.polynomial.laguerre.Laguerre", "text": "\nmethod\n\n"}, {"name": "polynomial.laguerre.Laguerre.has_samewindow()", "path": "reference/generated/numpy.polynomial.laguerre.laguerre.has_samewindow", "type": "numpy.polynomial.laguerre.Laguerre", "text": "\nmethod\n\n"}, {"name": "polynomial.laguerre.Laguerre.identity()", "path": "reference/generated/numpy.polynomial.laguerre.laguerre.identity", "type": "numpy.polynomial.laguerre.Laguerre", "text": "\nmethod\n\n"}, {"name": "polynomial.laguerre.Laguerre.integ()", "path": "reference/generated/numpy.polynomial.laguerre.laguerre.integ", "type": "numpy.polynomial.laguerre.Laguerre", "text": "\nmethod\n\n"}, {"name": "polynomial.laguerre.Laguerre.linspace()", "path": "reference/generated/numpy.polynomial.laguerre.laguerre.linspace", "type": "numpy.polynomial.laguerre.Laguerre", "text": "\nmethod\n\n"}, {"name": "polynomial.laguerre.Laguerre.mapparms()", "path": "reference/generated/numpy.polynomial.laguerre.laguerre.mapparms", "type": "numpy.polynomial.laguerre.Laguerre", "text": "\nmethod\n\n"}, {"name": "polynomial.laguerre.Laguerre.roots()", "path": "reference/generated/numpy.polynomial.laguerre.laguerre.roots", "type": "numpy.polynomial.laguerre.Laguerre", "text": "\nmethod\n\n"}, {"name": "polynomial.laguerre.Laguerre.trim()", "path": "reference/generated/numpy.polynomial.laguerre.laguerre.trim", "type": "numpy.polynomial.laguerre.Laguerre", "text": "\nmethod\n\n"}, {"name": "polynomial.laguerre.Laguerre.truncate()", "path": "reference/generated/numpy.polynomial.laguerre.laguerre.truncate", "type": "numpy.polynomial.laguerre.Laguerre", "text": "\nmethod\n\n"}, {"name": "polynomial.laguerre.lagval()", "path": "reference/generated/numpy.polynomial.laguerre.lagval", "type": "numpy.polynomial.laguerre.lagval", "text": "\nEvaluate a Laguerre series at points x.\n\n"}, {"name": "polynomial.laguerre.lagval2d()", "path": "reference/generated/numpy.polynomial.laguerre.lagval2d", "type": "numpy.polynomial.laguerre.lagval2d", "text": "\nEvaluate a 2-D Laguerre series at points (x, y).\n\n"}, {"name": "polynomial.laguerre.lagval3d()", "path": "reference/generated/numpy.polynomial.laguerre.lagval3d", "type": "numpy.polynomial.laguerre.lagval3d", "text": "\nEvaluate a 3-D Laguerre series at points (x, y, z).\n\n"}, {"name": "polynomial.laguerre.lagvander()", "path": "reference/generated/numpy.polynomial.laguerre.lagvander", "type": "numpy.polynomial.laguerre.lagvander", "text": "\nPseudo-Vandermonde matrix of given degree.\n\n"}, {"name": "polynomial.laguerre.lagvander2d()", "path": "reference/generated/numpy.polynomial.laguerre.lagvander2d", "type": "numpy.polynomial.laguerre.lagvander2d", "text": "\nPseudo-Vandermonde matrix of given degrees.\n\n"}, {"name": "polynomial.laguerre.lagvander3d()", "path": "reference/generated/numpy.polynomial.laguerre.lagvander3d", "type": "numpy.polynomial.laguerre.lagvander3d", "text": "\nPseudo-Vandermonde matrix of given degrees.\n\n"}, {"name": "polynomial.laguerre.lagweight()", "path": "reference/generated/numpy.polynomial.laguerre.lagweight", "type": "numpy.polynomial.laguerre.lagweight", "text": "\nWeight function of the Laguerre polynomials.\n\n"}, {"name": "polynomial.laguerre.lagx", "path": "reference/generated/numpy.polynomial.laguerre.lagx", "type": "numpy.polynomial.laguerre.lagx", "text": "\nAn array object represents a multidimensional, homogeneous array of fixed-size\nitems. An associated data-type object describes the format of each element in\nthe array (its byte-order, how many bytes it occupies in memory, whether it is\nan integer, a floating point number, or something else, etc.)\n\n"}, {"name": "polynomial.laguerre.lagzero", "path": "reference/generated/numpy.polynomial.laguerre.lagzero", "type": "numpy.polynomial.laguerre.lagzero", "text": "\nAn array object represents a multidimensional, homogeneous array of fixed-size\nitems. An associated data-type object describes the format of each element in\nthe array (its byte-order, how many bytes it occupies in memory, whether it is\nan integer, a floating point number, or something else, etc.)\n\n"}, {"name": "polynomial.laguerre.poly2lag()", "path": "reference/generated/numpy.polynomial.laguerre.poly2lag", "type": "numpy.polynomial.laguerre.poly2lag", "text": "\nConvert a polynomial to a Laguerre series.\n\n"}, {"name": "polynomial.legendre.leg2poly()", "path": "reference/generated/numpy.polynomial.legendre.leg2poly", "type": "numpy.polynomial.legendre.leg2poly", "text": "\nConvert a Legendre series to a polynomial.\n\n"}, {"name": "polynomial.legendre.legadd()", "path": "reference/generated/numpy.polynomial.legendre.legadd", "type": "numpy.polynomial.legendre.legadd", "text": "\nAdd one Legendre series to another.\n\n"}, {"name": "polynomial.legendre.legcompanion()", "path": "reference/generated/numpy.polynomial.legendre.legcompanion", "type": "numpy.polynomial.legendre.legcompanion", "text": "\nReturn the scaled companion matrix of c.\n\n"}, {"name": "polynomial.legendre.legder()", "path": "reference/generated/numpy.polynomial.legendre.legder", "type": "numpy.polynomial.legendre.legder", "text": "\nDifferentiate a Legendre series.\n\n"}, {"name": "polynomial.legendre.legdiv()", "path": "reference/generated/numpy.polynomial.legendre.legdiv", "type": "numpy.polynomial.legendre.legdiv", "text": "\nDivide one Legendre series by another.\n\n"}, {"name": "polynomial.legendre.legdomain", "path": "reference/generated/numpy.polynomial.legendre.legdomain", "type": "numpy.polynomial.legendre.legdomain", "text": "\nAn array object represents a multidimensional, homogeneous array of fixed-size\nitems. An associated data-type object describes the format of each element in\nthe array (its byte-order, how many bytes it occupies in memory, whether it is\nan integer, a floating point number, or something else, etc.)\n\n"}, {"name": "polynomial.legendre.Legendre.__call__()", "path": "reference/generated/numpy.polynomial.legendre.legendre.__call__", "type": "numpy.polynomial.legendre.Legendre", "text": "\nmethod\n\n"}, {"name": "polynomial.legendre.Legendre.basis()", "path": "reference/generated/numpy.polynomial.legendre.legendre.basis", "type": "numpy.polynomial.legendre.Legendre", "text": "\nmethod\n\n"}, {"name": "polynomial.legendre.Legendre.cast()", "path": "reference/generated/numpy.polynomial.legendre.legendre.cast", "type": "numpy.polynomial.legendre.Legendre", "text": "\nmethod\n\n"}, {"name": "polynomial.legendre.Legendre.convert()", "path": "reference/generated/numpy.polynomial.legendre.legendre.convert", "type": "numpy.polynomial.legendre.Legendre", "text": "\nmethod\n\n"}, {"name": "polynomial.legendre.Legendre.copy()", "path": "reference/generated/numpy.polynomial.legendre.legendre.copy", "type": "numpy.polynomial.legendre.Legendre", "text": "\nmethod\n\n"}, {"name": "polynomial.legendre.Legendre.cutdeg()", "path": "reference/generated/numpy.polynomial.legendre.legendre.cutdeg", "type": "numpy.polynomial.legendre.Legendre", "text": "\nmethod\n\n"}, {"name": "polynomial.legendre.Legendre.degree()", "path": "reference/generated/numpy.polynomial.legendre.legendre.degree", "type": "numpy.polynomial.legendre.Legendre", "text": "\nmethod\n\n"}, {"name": "polynomial.legendre.Legendre.deriv()", "path": "reference/generated/numpy.polynomial.legendre.legendre.deriv", "type": "numpy.polynomial.legendre.Legendre", "text": "\nmethod\n\n"}, {"name": "polynomial.legendre.Legendre.domain", "path": "reference/generated/numpy.polynomial.legendre.legendre.domain", "type": "Polynomials", "text": "\nattribute\n\n"}, {"name": "polynomial.legendre.Legendre.fit()", "path": "reference/generated/numpy.polynomial.legendre.legendre.fit", "type": "numpy.polynomial.legendre.Legendre", "text": "\nmethod\n\n"}, {"name": "polynomial.legendre.Legendre.fromroots()", "path": "reference/generated/numpy.polynomial.legendre.legendre.fromroots", "type": "numpy.polynomial.legendre.Legendre", "text": "\nmethod\n\n"}, {"name": "polynomial.legendre.Legendre.has_samecoef()", "path": "reference/generated/numpy.polynomial.legendre.legendre.has_samecoef", "type": "numpy.polynomial.legendre.Legendre", "text": "\nmethod\n\n"}, {"name": "polynomial.legendre.Legendre.has_samedomain()", "path": "reference/generated/numpy.polynomial.legendre.legendre.has_samedomain", "type": "numpy.polynomial.legendre.Legendre", "text": "\nmethod\n\n"}, {"name": "polynomial.legendre.Legendre.has_sametype()", "path": "reference/generated/numpy.polynomial.legendre.legendre.has_sametype", "type": "numpy.polynomial.legendre.Legendre", "text": "\nmethod\n\n"}, {"name": "polynomial.legendre.Legendre.has_samewindow()", "path": "reference/generated/numpy.polynomial.legendre.legendre.has_samewindow", "type": "numpy.polynomial.legendre.Legendre", "text": "\nmethod\n\n"}, {"name": "polynomial.legendre.Legendre.identity()", "path": "reference/generated/numpy.polynomial.legendre.legendre.identity", "type": "numpy.polynomial.legendre.Legendre", "text": "\nmethod\n\n"}, {"name": "polynomial.legendre.Legendre.integ()", "path": "reference/generated/numpy.polynomial.legendre.legendre.integ", "type": "numpy.polynomial.legendre.Legendre", "text": "\nmethod\n\n"}, {"name": "polynomial.legendre.Legendre.linspace()", "path": "reference/generated/numpy.polynomial.legendre.legendre.linspace", "type": "numpy.polynomial.legendre.Legendre", "text": "\nmethod\n\n"}, {"name": "polynomial.legendre.Legendre.mapparms()", "path": "reference/generated/numpy.polynomial.legendre.legendre.mapparms", "type": "numpy.polynomial.legendre.Legendre", "text": "\nmethod\n\n"}, {"name": "polynomial.legendre.Legendre.roots()", "path": "reference/generated/numpy.polynomial.legendre.legendre.roots", "type": "numpy.polynomial.legendre.Legendre", "text": "\nmethod\n\n"}, {"name": "polynomial.legendre.Legendre.trim()", "path": "reference/generated/numpy.polynomial.legendre.legendre.trim", "type": "numpy.polynomial.legendre.Legendre", "text": "\nmethod\n\n"}, {"name": "polynomial.legendre.Legendre.truncate()", "path": "reference/generated/numpy.polynomial.legendre.legendre.truncate", "type": "numpy.polynomial.legendre.Legendre", "text": "\nmethod\n\n"}, {"name": "polynomial.legendre.legfit()", "path": "reference/generated/numpy.polynomial.legendre.legfit", "type": "numpy.polynomial.legendre.legfit", "text": "\nLeast squares fit of Legendre series to data.\n\n"}, {"name": "polynomial.legendre.legfromroots()", "path": "reference/generated/numpy.polynomial.legendre.legfromroots", "type": "numpy.polynomial.legendre.legfromroots", "text": "\nGenerate a Legendre series with given roots.\n\n"}, {"name": "polynomial.legendre.leggauss()", "path": "reference/generated/numpy.polynomial.legendre.leggauss", "type": "numpy.polynomial.legendre.leggauss", "text": "\nGauss-Legendre quadrature.\n\n"}, {"name": "polynomial.legendre.leggrid2d()", "path": "reference/generated/numpy.polynomial.legendre.leggrid2d", "type": "numpy.polynomial.legendre.leggrid2d", "text": "\nEvaluate a 2-D Legendre series on the Cartesian product of x and y.\n\n"}, {"name": "polynomial.legendre.leggrid3d()", "path": "reference/generated/numpy.polynomial.legendre.leggrid3d", "type": "numpy.polynomial.legendre.leggrid3d", "text": "\nEvaluate a 3-D Legendre series on the Cartesian product of x, y, and z.\n\n"}, {"name": "polynomial.legendre.legint()", "path": "reference/generated/numpy.polynomial.legendre.legint", "type": "numpy.polynomial.legendre.legint", "text": "\nIntegrate a Legendre series.\n\n"}, {"name": "polynomial.legendre.legline()", "path": "reference/generated/numpy.polynomial.legendre.legline", "type": "numpy.polynomial.legendre.legline", "text": "\nLegendre series whose graph is a straight line.\n\n"}, {"name": "polynomial.legendre.legmul()", "path": "reference/generated/numpy.polynomial.legendre.legmul", "type": "numpy.polynomial.legendre.legmul", "text": "\nMultiply one Legendre series by another.\n\n"}, {"name": "polynomial.legendre.legmulx()", "path": "reference/generated/numpy.polynomial.legendre.legmulx", "type": "numpy.polynomial.legendre.legmulx", "text": "\nMultiply a Legendre series by x.\n\n"}, {"name": "polynomial.legendre.legone", "path": "reference/generated/numpy.polynomial.legendre.legone", "type": "numpy.polynomial.legendre.legone", "text": "\nAn array object represents a multidimensional, homogeneous array of fixed-size\nitems. An associated data-type object describes the format of each element in\nthe array (its byte-order, how many bytes it occupies in memory, whether it is\nan integer, a floating point number, or something else, etc.)\n\n"}, {"name": "polynomial.legendre.legpow()", "path": "reference/generated/numpy.polynomial.legendre.legpow", "type": "numpy.polynomial.legendre.legpow", "text": "\nRaise a Legendre series to a power.\n\n"}, {"name": "polynomial.legendre.legroots()", "path": "reference/generated/numpy.polynomial.legendre.legroots", "type": "numpy.polynomial.legendre.legroots", "text": "\nCompute the roots of a Legendre series.\n\n"}, {"name": "polynomial.legendre.legsub()", "path": "reference/generated/numpy.polynomial.legendre.legsub", "type": "numpy.polynomial.legendre.legsub", "text": "\nSubtract one Legendre series from another.\n\n"}, {"name": "polynomial.legendre.legtrim()", "path": "reference/generated/numpy.polynomial.legendre.legtrim", "type": "numpy.polynomial.legendre.legtrim", "text": "\nRemove \u201csmall\u201d \u201ctrailing\u201d coefficients from a polynomial.\n\n"}, {"name": "polynomial.legendre.legval()", "path": "reference/generated/numpy.polynomial.legendre.legval", "type": "numpy.polynomial.legendre.legval", "text": "\nEvaluate a Legendre series at points x.\n\n"}, {"name": "polynomial.legendre.legval2d()", "path": "reference/generated/numpy.polynomial.legendre.legval2d", "type": "numpy.polynomial.legendre.legval2d", "text": "\nEvaluate a 2-D Legendre series at points (x, y).\n\n"}, {"name": "polynomial.legendre.legval3d()", "path": "reference/generated/numpy.polynomial.legendre.legval3d", "type": "numpy.polynomial.legendre.legval3d", "text": "\nEvaluate a 3-D Legendre series at points (x, y, z).\n\n"}, {"name": "polynomial.legendre.legvander()", "path": "reference/generated/numpy.polynomial.legendre.legvander", "type": "numpy.polynomial.legendre.legvander", "text": "\nPseudo-Vandermonde matrix of given degree.\n\n"}, {"name": "polynomial.legendre.legvander2d()", "path": "reference/generated/numpy.polynomial.legendre.legvander2d", "type": "numpy.polynomial.legendre.legvander2d", "text": "\nPseudo-Vandermonde matrix of given degrees.\n\n"}, {"name": "polynomial.legendre.legvander3d()", "path": "reference/generated/numpy.polynomial.legendre.legvander3d", "type": "numpy.polynomial.legendre.legvander3d", "text": "\nPseudo-Vandermonde matrix of given degrees.\n\n"}, {"name": "polynomial.legendre.legweight()", "path": "reference/generated/numpy.polynomial.legendre.legweight", "type": "numpy.polynomial.legendre.legweight", "text": "\nWeight function of the Legendre polynomials.\n\n"}, {"name": "polynomial.legendre.legx", "path": "reference/generated/numpy.polynomial.legendre.legx", "type": "numpy.polynomial.legendre.legx", "text": "\nAn array object represents a multidimensional, homogeneous array of fixed-size\nitems. An associated data-type object describes the format of each element in\nthe array (its byte-order, how many bytes it occupies in memory, whether it is\nan integer, a floating point number, or something else, etc.)\n\n"}, {"name": "polynomial.legendre.legzero", "path": "reference/generated/numpy.polynomial.legendre.legzero", "type": "numpy.polynomial.legendre.legzero", "text": "\nAn array object represents a multidimensional, homogeneous array of fixed-size\nitems. An associated data-type object describes the format of each element in\nthe array (its byte-order, how many bytes it occupies in memory, whether it is\nan integer, a floating point number, or something else, etc.)\n\n"}, {"name": "polynomial.legendre.poly2leg()", "path": "reference/generated/numpy.polynomial.legendre.poly2leg", "type": "numpy.polynomial.legendre.poly2leg", "text": "\nConvert a polynomial to a Legendre series.\n\n"}, {"name": "polynomial.polynomial.polyadd()", "path": "reference/generated/numpy.polynomial.polynomial.polyadd", "type": "numpy.polynomial.polynomial.polyadd", "text": "\nAdd one polynomial to another.\n\n"}, {"name": "polynomial.polynomial.polycompanion()", "path": "reference/generated/numpy.polynomial.polynomial.polycompanion", "type": "numpy.polynomial.polynomial.polycompanion", "text": "\nReturn the companion matrix of c.\n\n"}, {"name": "polynomial.polynomial.polyder()", "path": "reference/generated/numpy.polynomial.polynomial.polyder", "type": "numpy.polynomial.polynomial.polyder", "text": "\nDifferentiate a polynomial.\n\n"}, {"name": "polynomial.polynomial.polydiv()", "path": "reference/generated/numpy.polynomial.polynomial.polydiv", "type": "numpy.polynomial.polynomial.polydiv", "text": "\nDivide one polynomial by another.\n\n"}, {"name": "polynomial.polynomial.polydomain", "path": "reference/generated/numpy.polynomial.polynomial.polydomain", "type": "numpy.polynomial.polynomial.polydomain", "text": "\nAn array object represents a multidimensional, homogeneous array of fixed-size\nitems. An associated data-type object describes the format of each element in\nthe array (its byte-order, how many bytes it occupies in memory, whether it is\nan integer, a floating point number, or something else, etc.)\n\n"}, {"name": "polynomial.polynomial.polyfit()", "path": "reference/generated/numpy.polynomial.polynomial.polyfit", "type": "numpy.polynomial.polynomial.polyfit", "text": "\nLeast-squares fit of a polynomial to data.\n\n"}, {"name": "polynomial.polynomial.polyfromroots()", "path": "reference/generated/numpy.polynomial.polynomial.polyfromroots", "type": "numpy.polynomial.polynomial.polyfromroots", "text": "\nGenerate a monic polynomial with given roots.\n\n"}, {"name": "polynomial.polynomial.polygrid2d()", "path": "reference/generated/numpy.polynomial.polynomial.polygrid2d", "type": "numpy.polynomial.polynomial.polygrid2d", "text": "\nEvaluate a 2-D polynomial on the Cartesian product of x and y.\n\n"}, {"name": "polynomial.polynomial.polygrid3d()", "path": "reference/generated/numpy.polynomial.polynomial.polygrid3d", "type": "numpy.polynomial.polynomial.polygrid3d", "text": "\nEvaluate a 3-D polynomial on the Cartesian product of x, y and z.\n\n"}, {"name": "polynomial.polynomial.polyint()", "path": "reference/generated/numpy.polynomial.polynomial.polyint", "type": "numpy.polynomial.polynomial.polyint", "text": "\nIntegrate a polynomial.\n\n"}, {"name": "polynomial.polynomial.polyline()", "path": "reference/generated/numpy.polynomial.polynomial.polyline", "type": "numpy.polynomial.polynomial.polyline", "text": "\nReturns an array representing a linear polynomial.\n\n"}, {"name": "polynomial.polynomial.polymul()", "path": "reference/generated/numpy.polynomial.polynomial.polymul", "type": "numpy.polynomial.polynomial.polymul", "text": "\nMultiply one polynomial by another.\n\n"}, {"name": "polynomial.polynomial.polymulx()", "path": "reference/generated/numpy.polynomial.polynomial.polymulx", "type": "numpy.polynomial.polynomial.polymulx", "text": "\nMultiply a polynomial by x.\n\n"}, {"name": "polynomial.polynomial.Polynomial.__call__()", "path": "reference/generated/numpy.polynomial.polynomial.polynomial.__call__", "type": "numpy.polynomial.polynomial.Polynomial", "text": "\nmethod\n\n"}, {"name": "polynomial.polynomial.Polynomial.basis()", "path": "reference/generated/numpy.polynomial.polynomial.polynomial.basis", "type": "numpy.polynomial.polynomial.Polynomial", "text": "\nmethod\n\n"}, {"name": "polynomial.polynomial.Polynomial.cast()", "path": "reference/generated/numpy.polynomial.polynomial.polynomial.cast", "type": "numpy.polynomial.polynomial.Polynomial", "text": "\nmethod\n\n"}, {"name": "polynomial.polynomial.Polynomial.convert()", "path": "reference/generated/numpy.polynomial.polynomial.polynomial.convert", "type": "numpy.polynomial.polynomial.Polynomial", "text": "\nmethod\n\n"}, {"name": "polynomial.polynomial.Polynomial.copy()", "path": "reference/generated/numpy.polynomial.polynomial.polynomial.copy", "type": "numpy.polynomial.polynomial.Polynomial", "text": "\nmethod\n\n"}, {"name": "polynomial.polynomial.Polynomial.cutdeg()", "path": "reference/generated/numpy.polynomial.polynomial.polynomial.cutdeg", "type": "numpy.polynomial.polynomial.Polynomial", "text": "\nmethod\n\n"}, {"name": "polynomial.polynomial.Polynomial.degree()", "path": "reference/generated/numpy.polynomial.polynomial.polynomial.degree", "type": "numpy.polynomial.polynomial.Polynomial", "text": "\nmethod\n\n"}, {"name": "polynomial.polynomial.Polynomial.deriv()", "path": "reference/generated/numpy.polynomial.polynomial.polynomial.deriv", "type": "numpy.polynomial.polynomial.Polynomial", "text": "\nmethod\n\n"}, {"name": "polynomial.polynomial.Polynomial.domain", "path": "reference/generated/numpy.polynomial.polynomial.polynomial.domain", "type": "Polynomials", "text": "\nattribute\n\n"}, {"name": "polynomial.polynomial.Polynomial.fit()", "path": "reference/generated/numpy.polynomial.polynomial.polynomial.fit", "type": "numpy.polynomial.polynomial.Polynomial", "text": "\nmethod\n\n"}, {"name": "polynomial.polynomial.Polynomial.fromroots()", "path": "reference/generated/numpy.polynomial.polynomial.polynomial.fromroots", "type": "numpy.polynomial.polynomial.Polynomial", "text": "\nmethod\n\n"}, {"name": "polynomial.polynomial.Polynomial.has_samecoef()", "path": "reference/generated/numpy.polynomial.polynomial.polynomial.has_samecoef", "type": "numpy.polynomial.polynomial.Polynomial", "text": "\nmethod\n\n"}, {"name": "polynomial.polynomial.Polynomial.has_samedomain()", "path": "reference/generated/numpy.polynomial.polynomial.polynomial.has_samedomain", "type": "numpy.polynomial.polynomial.Polynomial", "text": "\nmethod\n\n"}, {"name": "polynomial.polynomial.Polynomial.has_sametype()", "path": "reference/generated/numpy.polynomial.polynomial.polynomial.has_sametype", "type": "numpy.polynomial.polynomial.Polynomial", "text": "\nmethod\n\n"}, {"name": "polynomial.polynomial.Polynomial.has_samewindow()", "path": "reference/generated/numpy.polynomial.polynomial.polynomial.has_samewindow", "type": "numpy.polynomial.polynomial.Polynomial", "text": "\nmethod\n\n"}, {"name": "polynomial.polynomial.Polynomial.identity()", "path": "reference/generated/numpy.polynomial.polynomial.polynomial.identity", "type": "numpy.polynomial.polynomial.Polynomial", "text": "\nmethod\n\n"}, {"name": "polynomial.polynomial.Polynomial.integ()", "path": "reference/generated/numpy.polynomial.polynomial.polynomial.integ", "type": "numpy.polynomial.polynomial.Polynomial", "text": "\nmethod\n\n"}, {"name": "polynomial.polynomial.Polynomial.linspace()", "path": "reference/generated/numpy.polynomial.polynomial.polynomial.linspace", "type": "numpy.polynomial.polynomial.Polynomial", "text": "\nmethod\n\n"}, {"name": "polynomial.polynomial.Polynomial.mapparms()", "path": "reference/generated/numpy.polynomial.polynomial.polynomial.mapparms", "type": "numpy.polynomial.polynomial.Polynomial", "text": "\nmethod\n\n"}, {"name": "polynomial.polynomial.Polynomial.roots()", "path": "reference/generated/numpy.polynomial.polynomial.polynomial.roots", "type": "numpy.polynomial.polynomial.Polynomial", "text": "\nmethod\n\n"}, {"name": "polynomial.polynomial.Polynomial.trim()", "path": "reference/generated/numpy.polynomial.polynomial.polynomial.trim", "type": "numpy.polynomial.polynomial.Polynomial", "text": "\nmethod\n\n"}, {"name": "polynomial.polynomial.Polynomial.truncate()", "path": "reference/generated/numpy.polynomial.polynomial.polynomial.truncate", "type": "numpy.polynomial.polynomial.Polynomial", "text": "\nmethod\n\n"}, {"name": "polynomial.polynomial.polyone", "path": "reference/generated/numpy.polynomial.polynomial.polyone", "type": "numpy.polynomial.polynomial.polyone", "text": "\nAn array object represents a multidimensional, homogeneous array of fixed-size\nitems. An associated data-type object describes the format of each element in\nthe array (its byte-order, how many bytes it occupies in memory, whether it is\nan integer, a floating point number, or something else, etc.)\n\n"}, {"name": "polynomial.polynomial.polypow()", "path": "reference/generated/numpy.polynomial.polynomial.polypow", "type": "numpy.polynomial.polynomial.polypow", "text": "\nRaise a polynomial to a power.\n\n"}, {"name": "polynomial.polynomial.polyroots()", "path": "reference/generated/numpy.polynomial.polynomial.polyroots", "type": "numpy.polynomial.polynomial.polyroots", "text": "\nCompute the roots of a polynomial.\n\n"}, {"name": "polynomial.polynomial.polysub()", "path": "reference/generated/numpy.polynomial.polynomial.polysub", "type": "numpy.polynomial.polynomial.polysub", "text": "\nSubtract one polynomial from another.\n\n"}, {"name": "polynomial.polynomial.polytrim()", "path": "reference/generated/numpy.polynomial.polynomial.polytrim", "type": "numpy.polynomial.polynomial.polytrim", "text": "\nRemove \u201csmall\u201d \u201ctrailing\u201d coefficients from a polynomial.\n\n"}, {"name": "polynomial.polynomial.polyval()", "path": "reference/generated/numpy.polynomial.polynomial.polyval", "type": "numpy.polynomial.polynomial.polyval", "text": "\nEvaluate a polynomial at points x.\n\n"}, {"name": "polynomial.polynomial.polyval2d()", "path": "reference/generated/numpy.polynomial.polynomial.polyval2d", "type": "numpy.polynomial.polynomial.polyval2d", "text": "\nEvaluate a 2-D polynomial at points (x, y).\n\n"}, {"name": "polynomial.polynomial.polyval3d()", "path": "reference/generated/numpy.polynomial.polynomial.polyval3d", "type": "numpy.polynomial.polynomial.polyval3d", "text": "\nEvaluate a 3-D polynomial at points (x, y, z).\n\n"}, {"name": "polynomial.polynomial.polyvalfromroots()", "path": "reference/generated/numpy.polynomial.polynomial.polyvalfromroots", "type": "numpy.polynomial.polynomial.polyvalfromroots", "text": "\nEvaluate a polynomial specified by its roots at points x.\n\n"}, {"name": "polynomial.polynomial.polyvander()", "path": "reference/generated/numpy.polynomial.polynomial.polyvander", "type": "numpy.polynomial.polynomial.polyvander", "text": "\nVandermonde matrix of given degree.\n\n"}, {"name": "polynomial.polynomial.polyvander2d()", "path": "reference/generated/numpy.polynomial.polynomial.polyvander2d", "type": "numpy.polynomial.polynomial.polyvander2d", "text": "\nPseudo-Vandermonde matrix of given degrees.\n\n"}, {"name": "polynomial.polynomial.polyvander3d()", "path": "reference/generated/numpy.polynomial.polynomial.polyvander3d", "type": "numpy.polynomial.polynomial.polyvander3d", "text": "\nPseudo-Vandermonde matrix of given degrees.\n\n"}, {"name": "polynomial.polynomial.polyx", "path": "reference/generated/numpy.polynomial.polynomial.polyx", "type": "numpy.polynomial.polynomial.polyx", "text": "\nAn array object represents a multidimensional, homogeneous array of fixed-size\nitems. An associated data-type object describes the format of each element in\nthe array (its byte-order, how many bytes it occupies in memory, whether it is\nan integer, a floating point number, or something else, etc.)\n\n"}, {"name": "polynomial.polynomial.polyzero", "path": "reference/generated/numpy.polynomial.polynomial.polyzero", "type": "numpy.polynomial.polynomial.polyzero", "text": "\nAn array object represents a multidimensional, homogeneous array of fixed-size\nitems. An associated data-type object describes the format of each element in\nthe array (its byte-order, how many bytes it occupies in memory, whether it is\nan integer, a floating point number, or something else, etc.)\n\n"}, {"name": "polynomial.polyutils.as_series()", "path": "reference/generated/numpy.polynomial.polyutils.as_series", "type": "numpy.polynomial.polyutils.as_series", "text": "\nReturn argument as a list of 1-d arrays.\n\n"}, {"name": "polynomial.polyutils.getdomain()", "path": "reference/generated/numpy.polynomial.polyutils.getdomain", "type": "numpy.polynomial.polyutils.getdomain", "text": "\nReturn a domain suitable for given abscissae.\n\n"}, {"name": "polynomial.polyutils.mapdomain()", "path": "reference/generated/numpy.polynomial.polyutils.mapdomain", "type": "numpy.polynomial.polyutils.mapdomain", "text": "\nApply linear map to input points.\n\n"}, {"name": "polynomial.polyutils.mapparms()", "path": "reference/generated/numpy.polynomial.polyutils.mapparms", "type": "numpy.polynomial.polyutils.mapparms", "text": "\nLinear map parameters between domains.\n\n"}, {"name": "polynomial.polyutils.RankWarning", "path": "reference/generated/numpy.polynomial.polyutils.rankwarning", "type": "numpy.polynomial.polyutils.RankWarning", "text": "\nIssued by chebfit when the design matrix is rank deficient.\n\n"}, {"name": "polynomial.polyutils.trimcoef()", "path": "reference/generated/numpy.polynomial.polyutils.trimcoef", "type": "numpy.polynomial.polyutils.trimcoef", "text": "\nRemove \u201csmall\u201d \u201ctrailing\u201d coefficients from a polynomial.\n\n"}, {"name": "polynomial.polyutils.trimseq()", "path": "reference/generated/numpy.polynomial.polyutils.trimseq", "type": "numpy.polynomial.polyutils.trimseq", "text": "\nRemove small Poly series coefficients.\n\n"}, {"name": "polynomial.set_default_printstyle()", "path": "reference/generated/numpy.polynomial.set_default_printstyle", "type": "Polynomials", "text": "\nSet the default format for the string representation of polynomials.\n\n"}, {"name": "Polyutils", "path": "reference/routines.polynomials.polyutils", "type": "Polyutils", "text": "\nUtility classes and functions for the polynomial modules.\n\n"}, {"name": "Power Series (numpy.polynomial.polynomial)", "path": "reference/routines.polynomials.polynomial", "type": "Power Series ( \n        \n         numpy.polynomial.polynomial\n        \n        )", "text": "\nThis module provides a number of objects (mostly functions) useful for dealing\nwith polynomials, including a `Polynomial` class that encapsulates the usual\narithmetic operations. (General information on how this module represents and\nworks with polynomial objects is in the docstring for its \u201cparent\u201d sub-\npackage, `numpy.polynomial`).\n\n"}, {"name": "property finfo.machar", "path": "reference/generated/numpy.finfo.machar", "type": "NumPy.finfo.machar", "text": "\nproperty\n\n"}, {"name": "property finfo.smallest_normal", "path": "reference/generated/numpy.finfo.smallest_normal", "type": "NumPy.finfo.smallest_normal", "text": "\nproperty\n\n"}, {"name": "property finfo.tiny", "path": "reference/generated/numpy.finfo.tiny", "type": "NumPy.finfo.tiny", "text": "\nproperty\n\n"}, {"name": "property iinfo.max", "path": "reference/generated/numpy.iinfo.max", "type": "Data type routines", "text": "\nproperty\n\n"}, {"name": "property iinfo.min", "path": "reference/generated/numpy.iinfo.min", "type": "Data type routines", "text": "\nproperty\n\n"}, {"name": "property lib.Arrayterator.flat", "path": "reference/generated/numpy.lib.arrayterator.flat", "type": "Indexing routines", "text": "\nproperty\n\n"}, {"name": "property lib.Arrayterator.shape", "path": "reference/generated/numpy.lib.arrayterator.shape", "type": "Indexing routines", "text": "\nproperty\n\n"}, {"name": "property ma.masked_array.mask", "path": "reference/generated/numpy.ma.masked_array.mask", "type": "numpy.ma.masked_array.mask", "text": "\nproperty\n\n"}, {"name": "property ma.MaskedArray.dtype", "path": "reference/generated/numpy.ma.maskedarray.dtype", "type": "Masked arrays", "text": "\nproperty\n\n"}, {"name": "property ma.MaskedArray.flat", "path": "reference/generated/numpy.ma.maskedarray.flat", "type": "Masked arrays", "text": "\nproperty\n\n"}, {"name": "property ma.MaskedArray.imag", "path": "reference/generated/numpy.ma.maskedarray.imag", "type": "Masked arrays", "text": "\nproperty\n\n"}, {"name": "property ma.MaskedArray.real", "path": "reference/generated/numpy.ma.maskedarray.real", "type": "Masked arrays", "text": "\nproperty\n\n"}, {"name": "property ma.MaskedArray.shape", "path": "reference/generated/numpy.ma.maskedarray.shape", "type": "Masked arrays", "text": "\nproperty\n\n"}, {"name": "property ma.MaskedArray.T", "path": "reference/generated/numpy.ma.maskedarray.t", "type": "Masked arrays", "text": "\nproperty\n\n"}, {"name": "property matrix.A", "path": "reference/generated/numpy.matrix.a", "type": "numpy.matrix.A", "text": "\nproperty\n\n"}, {"name": "property matrix.A1", "path": "reference/generated/numpy.matrix.a1", "type": "Standard array subclasses", "text": "\nproperty\n\n"}, {"name": "property matrix.H", "path": "reference/generated/numpy.matrix.h", "type": "numpy.matrix.H", "text": "\nproperty\n\n"}, {"name": "property matrix.I", "path": "reference/generated/numpy.matrix.i", "type": "numpy.matrix.I", "text": "\nproperty\n\n"}, {"name": "property matrix.T", "path": "reference/generated/numpy.matrix.t", "type": "numpy.matrix.T", "text": "\nproperty\n\n"}, {"name": "property poly1d.c", "path": "reference/generated/numpy.poly1d.c", "type": "Polynomials", "text": "\nproperty\n\n"}, {"name": "property poly1d.coef", "path": "reference/generated/numpy.poly1d.coef", "type": "Polynomials", "text": "\nproperty\n\n"}, {"name": "property poly1d.coefficients", "path": "reference/generated/numpy.poly1d.coefficients", "type": "Polynomials", "text": "\nproperty\n\n"}, {"name": "property poly1d.coeffs", "path": "reference/generated/numpy.poly1d.coeffs", "type": "Polynomials", "text": "\nproperty\n\n"}, {"name": "property poly1d.o", "path": "reference/generated/numpy.poly1d.o", "type": "Polynomials", "text": "\nproperty\n\n"}, {"name": "property poly1d.order", "path": "reference/generated/numpy.poly1d.order", "type": "Polynomials", "text": "\nproperty\n\n"}, {"name": "property poly1d.r", "path": "reference/generated/numpy.poly1d.r", "type": "Polynomials", "text": "\nproperty\n\n"}, {"name": "property poly1d.variable", "path": "reference/generated/numpy.poly1d.variable", "type": "Polynomials", "text": "\nproperty\n\n"}, {"name": "PY_ARRAY_UNIQUE_SYMBOL", "path": "reference/c-api/array#c.PY_ARRAY_UNIQUE_SYMBOL", "type": "Array API", "text": "\n\n"}, {"name": "PyArray_ArrayDescr *subarray", "path": "reference/c-api/types-and-structures#c.NPY_USE_SETITEM.subarray", "type": "Python Types and C-Structures", "text": "\nIf this is non- `NULL`, then this data-type descriptor is a C-style contiguous\narray of another data-type descriptor. In other-words, each element that this\ndescriptor describes is actually an array of some other base descriptor. This\nis most useful as the data-type descriptor for a field in another data-type\ndescriptor. The fields member should be `NULL` if this is non- `NULL` (the\nfields member of the base descriptor can be non- `NULL` however).\n\n"}, {"name": "PyArray_ArrFuncs *f", "path": "reference/c-api/types-and-structures#c.NPY_USE_SETITEM.f", "type": "Python Types and C-Structures", "text": "\nA pointer to a structure containing functions that the type needs to implement\ninternal features. These functions are not the same thing as the universal\nfunctions (ufuncs) described later. Their signatures can vary arbitrarily.\n\n"}, {"name": "PyArray_CEQ()", "path": "reference/c-api/array#c.PyArray_CEQ", "type": "Array API", "text": "\n\n"}, {"name": "PyArray_CGE()", "path": "reference/c-api/array#c.PyArray_CGE", "type": "Array API", "text": "\n\n"}, {"name": "PyArray_CGT()", "path": "reference/c-api/array#c.PyArray_CGT", "type": "Array API", "text": "\n\n"}, {"name": "PyArray_CLE()", "path": "reference/c-api/array#c.PyArray_CLE", "type": "Array API", "text": "\n\n"}, {"name": "PyArray_CLT()", "path": "reference/c-api/array#c.PyArray_CLT", "type": "Array API", "text": "\n\n"}, {"name": "PyArray_CNE()", "path": "reference/c-api/array#c.PyArray_CNE", "type": "Array API", "text": "\nImplements the complex comparisons between two complex numbers (structures\nwith a real and imag member) using NumPy\u2019s definition of the ordering which is\nlexicographic: comparing the real parts first and then the complex parts if\nthe real parts are equal.\n\n"}, {"name": "PyArray_Descr **NpyIter_GetDescrArray()", "path": "reference/c-api/iterator#c.NpyIter_GetDescrArray", "type": "Array Iterator API", "text": "\nThis gives back a pointer to the `nop` data type Descrs for the objects being\niterated. The result points into `iter`, so the caller does not gain any\nreferences to the Descrs.\n\n"}, {"name": "PyArray_Descr *descr", "path": "reference/c-api/types-and-structures#c.NPY_AO.descr", "type": "Python Types and C-Structures", "text": "\nA pointer to a data-type descriptor object (see below). The data-type\ndescriptor object is an instance of a new built-in type which allows a generic\ndescription of memory. There is a descriptor structure for each data type\nsupported. This descriptor structure contains useful information about the\ntype as well as a pointer to a table of function pointers to implement\nspecific functionality. As the name suggests, it is associated with the macro\n`PyArray_DESCR`.\n\n"}, {"name": "PyArray_Descr *PyArray_DESCR()", "path": "reference/c-api/array#c.PyArray_DESCR", "type": "Array API", "text": "\nReturns a borrowed reference to the dtype property of the array.\n\n"}, {"name": "PyArray_Descr *PyArray_DescrFromObject()", "path": "reference/c-api/array#c.PyArray_DescrFromObject", "type": "Array API", "text": "\nDetermine an appropriate data-type object from the object op (which should be\na \u201cnested\u201d sequence object) and the minimum data-type descriptor mintype\n(which can be `NULL` ). Similar in behavior to array(op).dtype. Don\u2019t confuse\nthis function with `PyArray_DescrConverter`. This function essentially looks\nat all the objects in the (nested) sequence and determines the data-type from\nthe elements it finds.\n\n"}, {"name": "PyArray_Descr *PyArray_DescrFromScalar()", "path": "reference/c-api/array#c.PyArray_DescrFromScalar", "type": "Array API", "text": "\nReturn a data-type object from an array-scalar object. No checking is done to\nbe sure that scalar is an array scalar. If no suitable data-type can be\ndetermined, then a data-type of `NPY_OBJECT` is returned by default.\n\n"}, {"name": "PyArray_Descr *PyArray_DescrFromType()", "path": "reference/c-api/array#c.PyArray_DescrFromType", "type": "Array API", "text": "\nReturns a data-type object corresponding to typenum. The typenum can be one of\nthe enumerated types, a character code for one of the enumerated types, or a\nuser-defined type. If you want to use a flexible size array, then you need to\n`flexible typenum` and set the results `elsize` parameter to the desired size.\nThe typenum is one of the `NPY_TYPES`.\n\n"}, {"name": "PyArray_Descr *PyArray_DescrNew()", "path": "reference/c-api/array#c.PyArray_DescrNew", "type": "Array API", "text": "\nReturn a new data-type object copied from obj (the fields reference is just\nupdated so that the new object points to the same fields dictionary if any).\n\n"}, {"name": "PyArray_Descr *PyArray_DescrNewByteorder()", "path": "reference/c-api/array#c.PyArray_DescrNewByteorder", "type": "Array API", "text": "\nCreate a new data-type object with the byteorder set according to newendian.\nAll referenced data-type objects (in subdescr and fields members of the data-\ntype object) are also changed (recursively).\n\n"}, {"name": "PyArray_Descr *PyArray_DescrNewFromType()", "path": "reference/c-api/array#c.PyArray_DescrNewFromType", "type": "Array API", "text": "\nCreate a new data-type object from the built-in (or user-registered) data-type\nindicated by typenum. All builtin types should not have any of their fields\nchanged. This creates a new copy of the `PyArray_Descr` structure so that you\ncan fill it in as appropriate. This function is especially needed for flexible\ndata-types which need to have a new elsize member in order to be meaningful in\narray construction.\n\n"}, {"name": "PyArray_Descr *PyArray_DTYPE()", "path": "reference/c-api/array#c.PyArray_DTYPE", "type": "Array API", "text": "\nNew in version 1.7.\n\n"}, {"name": "PyArray_Descr *PyArray_MinScalarType()", "path": "reference/c-api/array#c.PyArray_MinScalarType", "type": "Array API", "text": "\nNew in version 1.6.\n\n"}, {"name": "PyArray_Descr *PyArray_PromoteTypes()", "path": "reference/c-api/array#c.PyArray_PromoteTypes", "type": "Array API", "text": "\nNew in version 1.6.\n\n"}, {"name": "PyArray_Descr *PyArray_ResultType()", "path": "reference/c-api/array#c.PyArray_ResultType", "type": "Array API", "text": "\nNew in version 1.6.\n\n"}, {"name": "PyArray_IsScalar()", "path": "reference/c-api/array#c.PyArray_IsScalar", "type": "Array API", "text": "\nEvaluates true if op is an instance of `Py{cls}ArrType_Type`.\n\n"}, {"name": "PyArray_MAX()", "path": "reference/c-api/array#c.PyArray_MAX", "type": "Array API", "text": "\nReturns the maximum of a and b. If (a) or (b) are expressions they are\nevaluated twice.\n\n"}, {"name": "PyArray_MIN()", "path": "reference/c-api/array#c.PyArray_MIN", "type": "Array API", "text": "\nReturns the minimum of a and b. If (a) or (b) are expressions they are\nevaluated twice.\n\n"}, {"name": "PyArray_VectorUnaryFunc *PyArray_GetCastFunc()", "path": "reference/c-api/array#c.PyArray_GetCastFunc", "type": "Array API", "text": "\nReturn the low-level casting function to cast from the given descriptor to the\nbuiltin type number. If no casting function exists return `NULL` and set an\nerror. Using this function instead of direct access to from ->f->cast will\nallow support of any user-defined casting functions added to a descriptors\ncasting dictionary.\n\n"}, {"name": "PyArrayIterObject **iters", "path": "reference/c-api/types-and-structures#c.PyArrayMultiIterObject.iters", "type": "Python Types and C-Structures", "text": "\nAn array of iterator objects that holds the iterators for the arrays to be\nbroadcast together. On return, the iterators are adjusted for broadcasting.\n\n"}, {"name": "PyArrayObject **PyArray_ConvertToCommonType()", "path": "reference/c-api/array#c.PyArray_ConvertToCommonType", "type": "Array API", "text": "\nThe functionality this provides is largely superseded by iterator `NpyIter`\nintroduced in 1.6, with flag `NPY_ITER_COMMON_DTYPE` or with the same dtype\nparameter for all operands.\n\n"}, {"name": "PyArrayObject *ao", "path": "reference/c-api/types-and-structures#c.PyArrayIterObject.ao", "type": "Python Types and C-Structures", "text": "\nA pointer to the underlying ndarray this iterator was created to represent.\n\n"}, {"name": "PyArrayObject *PyArray_GETCONTIGUOUS()", "path": "reference/c-api/array#c.PyArray_GETCONTIGUOUS", "type": "Array API", "text": "\nIf `op` is already (C-style) contiguous and well-behaved then just return a\nreference, otherwise return a (contiguous and well-behaved) copy of the array.\nThe parameter op must be a (sub-class of an) ndarray and no checking for that\nis done.\n\n"}, {"name": "PyDataMem_EventHookFunc *PyDataMem_SetEventHook()", "path": "reference/c-api/data_memory#c.PyDataMem_SetEventHook", "type": "Memory management in NumPy", "text": "\nSets the allocation event hook for numpy array data.\n\n"}, {"name": "PyObject **NpyIter_GetOperandArray()", "path": "reference/c-api/iterator#c.NpyIter_GetOperandArray", "type": "Array Iterator API", "text": "\nThis gives back a pointer to the `nop` operand PyObjects that are being\niterated. The result points into `iter`, so the caller does not gain any\nreferences to the PyObjects.\n\n"}, {"name": "PyObject *base", "path": "reference/c-api/types-and-structures#c.NPY_AO.base", "type": "Python Types and C-Structures", "text": "\nPointed to by `PyArray_BASE`, this member is used to hold a pointer to another\nPython object that is related to this array. There are two use cases:\n\n"}, {"name": "PyObject *castdict", "path": "reference/c-api/types-and-structures#c.PyArray_ArrFuncs.castdict", "type": "Python Types and C-Structures", "text": "\nEither `NULL` or a dictionary containing low-level casting functions for user-\ndefined data-types. Each function is wrapped in a PyCapsule* and keyed by the\ndata-type number.\n\n"}, {"name": "PyObject *descr", "path": "reference/c-api/types-and-structures#c.PyArrayInterface.descr", "type": "Python Types and C-Structures", "text": "\nA Python object describing the data-type in more detail (same as the descr key\nin `__array_interface__`). This can be `NULL` if typekind and itemsize provide\nenough information. This field is also ignored unless `NPY_ARR_HAS_DESCR` flag\nis on in flags.\n\n"}, {"name": "PyObject *fields", "path": "reference/c-api/types-and-structures#c.NPY_USE_SETITEM.fields", "type": "Python Types and C-Structures", "text": "\nIf this is non-NULL, then this data-type-descriptor has fields described by a\nPython dictionary whose keys are names (and also titles if given) and whose\nvalues are tuples that describe the fields. Recall that a data-type-descriptor\nalways describes a fixed-length set of bytes. A field is a named sub-region of\nthat total, fixed-length collection. A field is described by a tuple composed\nof another data- type-descriptor and a byte offset. Optionally, the tuple may\ncontain a title which is normally a Python string. These tuples are placed in\nthis dictionary keyed by name (and also title if given).\n\n"}, {"name": "PyObject *getitem()", "path": "reference/c-api/types-and-structures#c.PyArray_ArrFuncs.getitem", "type": "Python Types and C-Structures", "text": "\nA pointer to a function that returns a standard Python object from a single\nelement of the array object arr pointed to by data. This function must be able\nto deal with \u201cmisbehaved \u201c(misaligned and/or swapped) arrays correctly.\n\n"}, {"name": "PyObject *metadata", "path": "reference/c-api/types-and-structures#c.NPY_USE_SETITEM.metadata", "type": "Python Types and C-Structures", "text": "\nMetadata about this dtype.\n\n"}, {"name": "PyObject *names", "path": "reference/c-api/types-and-structures#c.NPY_USE_SETITEM.names", "type": "Python Types and C-Structures", "text": "\nAn ordered tuple of field names. It is NULL if no field is defined.\n\n"}, {"name": "PyObject *NpyIter_GetIterView()", "path": "reference/c-api/iterator#c.NpyIter_GetIterView", "type": "Array Iterator API", "text": "\nThis gives back a reference to a new ndarray view, which is a view into the\ni-th object in the array `NpyIter_GetOperandArray`, whose dimensions and\nstrides match the internal optimized iteration pattern. A C-order iteration of\nthis view is equivalent to the iterator\u2019s iteration order.\n\n"}, {"name": "PyObject *obj", "path": "reference/c-api/types-and-structures#c.PyUFuncObject.obj", "type": "Python Types and C-Structures", "text": "\nFor ufuncs dynamically created from python functions, this member holds a\nreference to the underlying Python function.\n\n"}, {"name": "PyObject *PyArray_All()", "path": "reference/c-api/array#c.PyArray_All", "type": "Array API", "text": "\nEquivalent to `ndarray.all` (self, axis). Return an array with True elements\nfor every 1-d sub-array of `self` defined by `axis` in which all the elements\nare True.\n\n"}, {"name": "PyObject *PyArray_Any()", "path": "reference/c-api/array#c.PyArray_Any", "type": "Array API", "text": "\nEquivalent to `ndarray.any` (self, axis). Return an array with True elements\nfor every 1-d sub-array of self defined by axis in which any of the elements\nare True.\n\n"}, {"name": "PyObject *PyArray_Arange()", "path": "reference/c-api/array#c.PyArray_Arange", "type": "Array API", "text": "\nConstruct a new 1-dimensional array of data-type, typenum, that ranges from\nstart to stop (exclusive) in increments of step . Equivalent to arange (start,\nstop, step, dtype).\n\n"}, {"name": "PyObject *PyArray_ArangeObj()", "path": "reference/c-api/array#c.PyArray_ArangeObj", "type": "Array API", "text": "\nConstruct a new 1-dimensional array of data-type determined by `descr`, that\nranges from `start` to `stop` (exclusive) in increments of `step`. Equivalent\nto arange( `start`, `stop`, `step`, `typenum` ).\n\n"}, {"name": "PyObject *PyArray_ArgMin()", "path": "reference/c-api/array#c.PyArray_ArgMin", "type": "Array API", "text": "\nEquivalent to `ndarray.argmin` (self, axis). Return the index of the smallest\nelement of self along axis.\n\n"}, {"name": "PyObject *PyArray_ArgPartition()", "path": "reference/c-api/array#c.PyArray_ArgPartition", "type": "Array API", "text": "\nEquivalent to `ndarray.argpartition` (self, ktharray, axis, kind). Return an\narray of indices such that selection of these indices along the given `axis`\nwould return a partitioned version of self.\n\n"}, {"name": "PyObject *PyArray_ArgSort()", "path": "reference/c-api/array#c.PyArray_ArgSort", "type": "Array API", "text": "\nEquivalent to `ndarray.argsort` (self, axis). Return an array of indices such\nthat selection of these indices along the given `axis` would return a sorted\nversion of self. If self ->descr is a data-type with fields defined, then\nself->descr->names is used to determine the sort order. A comparison where the\nfirst field is equal will use the second field and so on. To alter the sort\norder of a structured array, create a new data-type with a different order of\nnames and construct a view of the array with that new data-type.\n\n"}, {"name": "PyObject *PyArray_BASE()", "path": "reference/c-api/array#c.PyArray_BASE", "type": "Array API", "text": "\nThis returns the base object of the array. In most cases, this means the\nobject which owns the memory the array is pointing at.\n\n"}, {"name": "PyObject *PyArray_BroadcastToShape()", "path": "reference/c-api/array#c.PyArray_BroadcastToShape", "type": "Array API", "text": "\nReturn an array iterator that is broadcast to iterate as an array of the shape\nprovided by dimensions and nd.\n\n"}, {"name": "PyObject *PyArray_Byteswap()", "path": "reference/c-api/array#c.PyArray_Byteswap", "type": "Array API", "text": "\nEquivalent to `ndarray.byteswap` (self, inplace). Return an array whose data\narea is byteswapped. If inplace is non-zero, then do the byteswap inplace and\nreturn a reference to self. Otherwise, create a byteswapped copy and leave\nself unchanged.\n\n"}, {"name": "PyObject *PyArray_CastToType()", "path": "reference/c-api/array#c.PyArray_CastToType", "type": "Array API", "text": "\nReturn a new array of the type specified, casting the elements of arr as\nappropriate. The fortran argument specifies the ordering of the output array.\n\n"}, {"name": "PyObject *PyArray_CheckAxis()", "path": "reference/c-api/array#c.PyArray_CheckAxis", "type": "Array API", "text": "\nEncapsulate the functionality of functions and methods that take the axis=\nkeyword and work properly with None as the axis argument. The input array is\n`obj`, while `*axis` is a converted integer (so that >=MAXDIMS is the None\nvalue), and `requirements` gives the needed properties of `obj`. The output is\na converted version of the input so that requirements are met and if needed a\nflattening has occurred. On output negative values of `*axis` are converted\nand the new value is checked to ensure consistency with the shape of `obj`.\n\n"}, {"name": "PyObject *PyArray_CheckFromAny()", "path": "reference/c-api/array#c.PyArray_CheckFromAny", "type": "Array API", "text": "\nNearly identical to `PyArray_FromAny` (\u2026) except requirements can contain\n`NPY_ARRAY_NOTSWAPPED` (over-riding the specification in dtype) and\n`NPY_ARRAY_ELEMENTSTRIDES` which indicates that the array should be aligned in\nthe sense that the strides are multiples of the element size.\n\n"}, {"name": "PyObject *PyArray_Choose()", "path": "reference/c-api/array#c.PyArray_Choose", "type": "Array API", "text": "\nEquivalent to `ndarray.choose` (self, op, ret, clipmode). Create a new array\nby selecting elements from the sequence of arrays in op based on the integer\nvalues in self. The arrays must all be broadcastable to the same shape and the\nentries in self should be between 0 and len(op). The output is placed in ret\nunless it is `NULL` in which case a new output is created. The clipmode\nargument determines behavior for when entries in self are not between 0 and\nlen(op).\n\n"}, {"name": "PyObject *PyArray_Clip()", "path": "reference/c-api/array#c.PyArray_Clip", "type": "Array API", "text": "\nEquivalent to `ndarray.clip` (self, min, max). Clip an array, self, so that\nvalues larger than max are fixed to max and values less than min are fixed to\nmin.\n\n"}, {"name": "PyObject *PyArray_Compress()", "path": "reference/c-api/array#c.PyArray_Compress", "type": "Array API", "text": "\nEquivalent to `ndarray.compress` (self, condition, axis ). Return the elements\nalong axis corresponding to elements of condition that are true.\n\n"}, {"name": "PyObject *PyArray_Concatenate()", "path": "reference/c-api/array#c.PyArray_Concatenate", "type": "Array API", "text": "\nJoin the sequence of objects in obj together along axis into a single array.\nIf the dimensions or types are not compatible an error is raised.\n\n"}, {"name": "PyObject *PyArray_Conjugate()", "path": "reference/c-api/array#c.PyArray_Conjugate", "type": "Array API", "text": "\nEquivalent to `ndarray.conjugate` (self). Return the complex conjugate of\nself. If self is not of complex data type, then return self with a reference.\n\n"}, {"name": "PyObject *PyArray_ContiguousFromAny()", "path": "reference/c-api/array#c.PyArray_ContiguousFromAny", "type": "Array API", "text": "\nThis function returns a (C-style) contiguous and behaved function array from\nany nested sequence or array interface exporting object, op, of (non-flexible)\ntype given by the enumerated typenum, of minimum depth min_depth, and of\nmaximum depth max_depth. Equivalent to a call to `PyArray_FromAny` with\nrequirements set to `NPY_ARRAY_DEFAULT` and the type_num member of the type\nargument set to typenum.\n\n"}, {"name": "PyObject *PyArray_ContiguousFromObject()", "path": "reference/c-api/array#c.PyArray_ContiguousFromObject", "type": "Array API", "text": "\nThis function returns a well-behaved C-style contiguous array from any nested\nsequence or array-interface exporting object. The minimum number of dimensions\nthe array can have is given by `min_depth` while the maximum is `max_depth`.\nThis is equivalent to call `PyArray_FromAny` with requirements\n`NPY_ARRAY_DEFAULT` and `NPY_ARRAY_ENSUREARRAY`.\n\n"}, {"name": "PyObject *PyArray_CopyAndTranspose()", "path": "reference/c-api/array#c.PyArray_CopyAndTranspose", "type": "Array API", "text": "\nA specialized copy and transpose function that works only for 2-d arrays. The\nreturned array is a transposed copy of op.\n\n"}, {"name": "PyObject *PyArray_Correlate()", "path": "reference/c-api/array#c.PyArray_Correlate", "type": "Array API", "text": "\nCompute the 1-d correlation of the 1-d arrays op1 and op2 . The correlation is\ncomputed at each output point by multiplying op1 by a shifted version of op2\nand summing the result. As a result of the shift, needed values outside of the\ndefined range of op1 and op2 are interpreted as zero. The mode determines how\nmany shifts to return: 0 - return only shifts that did not need to assume\nzero- values; 1 - return an object that is the same size as op1, 2 - return\nall possible shifts (any overlap at all is accepted).\n\n"}, {"name": "PyObject *PyArray_Correlate2()", "path": "reference/c-api/array#c.PyArray_Correlate2", "type": "Array API", "text": "\nUpdated version of PyArray_Correlate, which uses the usual definition of\ncorrelation for 1d arrays. The correlation is computed at each output point by\nmultiplying op1 by a shifted version of op2 and summing the result. As a\nresult of the shift, needed values outside of the defined range of op1 and op2\nare interpreted as zero. The mode determines how many shifts to return: 0 -\nreturn only shifts that did not need to assume zero- values; 1 - return an\nobject that is the same size as op1, 2 - return all possible shifts (any\noverlap at all is accepted).\n\n"}, {"name": "PyObject *PyArray_CumProd()", "path": "reference/c-api/array#c.PyArray_CumProd", "type": "Array API", "text": "\nEquivalent to `ndarray.cumprod` (self, axis, rtype). Return 1-d cumulative\nproducts of elements in `self` along `axis`. Perform the product after\nconverting data to data type `rtype`.\n\n"}, {"name": "PyObject *PyArray_CumSum()", "path": "reference/c-api/array#c.PyArray_CumSum", "type": "Array API", "text": "\nEquivalent to `ndarray.cumsum` (self, axis, rtype). Return cumulative 1-d sums\nof elements in self along axis. Perform the sum after converting data to data\ntype rtype.\n\n"}, {"name": "PyObject *PyArray_Diagonal()", "path": "reference/c-api/array#c.PyArray_Diagonal", "type": "Array API", "text": "\nEquivalent to `ndarray.diagonal` (self, offset, axis1, axis2 ). Return the\noffset diagonals of the 2-d arrays defined by axis1 and axis2.\n\n"}, {"name": "PyObject *PyArray_Dumps()", "path": "reference/c-api/array#c.PyArray_Dumps", "type": "Array API", "text": "\nPickle the object in self to a Python string and return it. Use the Pickle\nprotocol provided (or the highest available if protocol is negative).\n\n"}, {"name": "PyObject *PyArray_EinsteinSum()", "path": "reference/c-api/array#c.PyArray_EinsteinSum", "type": "Array API", "text": "\nNew in version 1.6.\n\n"}, {"name": "PyObject *PyArray_EMPTY()", "path": "reference/c-api/array#c.PyArray_EMPTY", "type": "Array API", "text": "\nMacro form of `PyArray_Empty` which takes a type-number, typenum, instead of a\ndata-type object.\n\n"}, {"name": "PyObject *PyArray_Empty()", "path": "reference/c-api/array#c.PyArray_Empty", "type": "Array API", "text": "\nConstruct a new nd -dimensional array with shape given by dims and data type\ngiven by dtype. If fortran is non-zero, then a Fortran-order array is created,\notherwise a C-order array is created. The array is uninitialized unless the\ndata type corresponds to `NPY_OBJECT` in which case the array is filled with\n`Py_None`.\n\n"}, {"name": "PyObject *PyArray_EnsureArray()", "path": "reference/c-api/array#c.PyArray_EnsureArray", "type": "Array API", "text": "\nThis function steals a reference to `op` and makes sure that `op` is a base-\nclass ndarray. It special cases array scalars, but otherwise calls\n`PyArray_FromAny` ( `op`, NULL, 0, 0, `NPY_ARRAY_ENSUREARRAY`, NULL).\n\n"}, {"name": "PyObject *PyArray_FieldNames()", "path": "reference/c-api/array#c.PyArray_FieldNames", "type": "Array API", "text": "\nTake the fields dictionary, dict, such as the one attached to a data-type\nobject and construct an ordered-list of field names such as is stored in the\nnames field of the `PyArray_Descr` object.\n\n"}, {"name": "PyObject *PyArray_Flatten()", "path": "reference/c-api/array#c.PyArray_Flatten", "type": "Array API", "text": "\nEquivalent to `ndarray.flatten` (self, order). Return a 1-d copy of the array.\nIf order is `NPY_FORTRANORDER` the elements are scanned out in Fortran order\n(first-dimension varies the fastest). If order is `NPY_CORDER`, the elements\nof `self` are scanned in C-order (last dimension varies the fastest). If order\n`NPY_ANYORDER`, then the result of `PyArray_ISFORTRAN` (self) is used to\ndetermine which order to flatten.\n\n"}, {"name": "PyObject *PyArray_FROM_O()", "path": "reference/c-api/array#c.PyArray_FROM_O", "type": "Array API", "text": "\nConvert `obj` to an ndarray. The argument can be any nested sequence or object\nthat exports the array interface. This is a macro form of `PyArray_FromAny`\nusing `NULL`, 0, 0, 0 for the other arguments. Your code must be able to\nhandle any data-type descriptor and any combination of data-flags to use this\nmacro.\n\n"}, {"name": "PyObject *PyArray_FROM_OF()", "path": "reference/c-api/array#c.PyArray_FROM_OF", "type": "Array API", "text": "\nSimilar to `PyArray_FROM_O` except it can take an argument of requirements\nindicating properties the resulting array must have. Available requirements\nthat can be enforced are `NPY_ARRAY_C_CONTIGUOUS`, `NPY_ARRAY_F_CONTIGUOUS`,\n`NPY_ARRAY_ALIGNED`, `NPY_ARRAY_WRITEABLE`, `NPY_ARRAY_NOTSWAPPED`,\n`NPY_ARRAY_ENSURECOPY`, `NPY_ARRAY_WRITEBACKIFCOPY`, `NPY_ARRAY_UPDATEIFCOPY`,\n`NPY_ARRAY_FORCECAST`, and `NPY_ARRAY_ENSUREARRAY`. Standard combinations of\nflags can also be used:\n\n"}, {"name": "PyObject *PyArray_FROM_OT()", "path": "reference/c-api/array#c.PyArray_FROM_OT", "type": "Array API", "text": "\nSimilar to `PyArray_FROM_O` except it can take an argument of typenum\nspecifying the type-number the returned array.\n\n"}, {"name": "PyObject *PyArray_FROM_OTF()", "path": "reference/c-api/array#c.PyArray_FROM_OTF", "type": "Array API", "text": "\nCombination of `PyArray_FROM_OF` and `PyArray_FROM_OT` allowing both a typenum\nand a flags argument to be provided.\n\n"}, {"name": "PyObject *PyArray_FROMANY()", "path": "reference/c-api/array#c.PyArray_FROMANY", "type": "Array API", "text": "\nSimilar to `PyArray_FromAny` except the data-type is specified using a\ntypenumber. `PyArray_DescrFromType` (typenum) is passed directly to\n`PyArray_FromAny`. This macro also adds `NPY_ARRAY_DEFAULT` to requirements if\n`NPY_ARRAY_ENSURECOPY` is passed in as requirements.\n\n"}, {"name": "PyObject *PyArray_FromArray()", "path": "reference/c-api/array#c.PyArray_FromArray", "type": "Array API", "text": "\nSpecial case of `PyArray_FromAny` for when op is already an array but it needs\nto be of a specific newtype (including byte-order) or has certain\nrequirements.\n\n"}, {"name": "PyObject *PyArray_FromArrayAttr()", "path": "reference/c-api/array#c.PyArray_FromArrayAttr", "type": "Array API", "text": "\nReturn an ndarray object from a Python object that exposes the `__array__`\nmethod. The `__array__` method can take 0, or 1 argument `([dtype])`.\n`context` is unused.\n\n"}, {"name": "PyObject *PyArray_FromBuffer()", "path": "reference/c-api/array#c.PyArray_FromBuffer", "type": "Array API", "text": "\nConstruct a one-dimensional ndarray of a single type from an object, `buf`,\nthat exports the (single-segment) buffer protocol (or has an attribute\n__buffer__ that returns an object that exports the buffer protocol). A\nwriteable buffer will be tried first followed by a read- only buffer. The\n`NPY_ARRAY_WRITEABLE` flag of the returned array will reflect which one was\nsuccessful. The data is assumed to start at `offset` bytes from the start of\nthe memory location for the object. The type of the data in the buffer will be\ninterpreted depending on the data- type descriptor, `dtype.` If `count` is\nnegative then it will be determined from the size of the buffer and the\nrequested itemsize, otherwise, `count` represents how many elements should be\nconverted from the buffer.\n\n"}, {"name": "PyObject *PyArray_FromFile()", "path": "reference/c-api/array#c.PyArray_FromFile", "type": "Array API", "text": "\nConstruct a one-dimensional ndarray of a single type from a binary or text\nfile. The open file pointer is `fp`, the data-type of the array to be created\nis given by `dtype`. This must match the data in the file. If `num` is -1,\nthen read until the end of the file and return an appropriately sized array,\notherwise, `num` is the number of items to read. If `sep` is NULL (or \u201c\u201d),\nthen read from the file in binary mode, otherwise read from the file in text\nmode with `sep` providing the item separator. Some array types cannot be read\nin text mode in which case an error is raised.\n\n"}, {"name": "PyObject *PyArray_FromInterface()", "path": "reference/c-api/array#c.PyArray_FromInterface", "type": "Array API", "text": "\nReturns an ndarray object from a Python object that exposes the\n`__array_interface__` attribute following the array interface protocol. If the\nobject does not contain this attribute then a borrowed reference to\n`Py_NotImplemented` is returned.\n\n"}, {"name": "PyObject *PyArray_FromObject()", "path": "reference/c-api/array#c.PyArray_FromObject", "type": "Array API", "text": "\nReturn an aligned and in native-byteorder array from any nested sequence or\narray-interface exporting object, op, of a type given by the enumerated\ntypenum. The minimum number of dimensions the array can have is given by\nmin_depth while the maximum is max_depth. This is equivalent to a call to\n`PyArray_FromAny` with requirements set to BEHAVED.\n\n"}, {"name": "PyObject *PyArray_FromScalar()", "path": "reference/c-api/array#c.PyArray_FromScalar", "type": "Array API", "text": "\nReturn a 0-dimensional array of type determined by outcode from scalar which\nshould be an array-scalar object. If outcode is NULL, then the type is\ndetermined from scalar.\n\n"}, {"name": "PyObject *PyArray_FromString()", "path": "reference/c-api/array#c.PyArray_FromString", "type": "Array API", "text": "\nConstruct a one-dimensional ndarray of a single type from a binary or (ASCII)\ntext `string` of length `slen`. The data-type of the array to-be-created is\ngiven by `dtype`. If num is -1, then copy the entire string and return an\nappropriately sized array, otherwise, `num` is the number of items to copy\nfrom the string. If `sep` is NULL (or \u201c\u201d), then interpret the string as bytes\nof binary data, otherwise convert the sub-strings separated by `sep` to items\nof data-type `dtype`. Some data-types may not be readable in text mode and an\nerror will be raised if that occurs. All errors return NULL.\n\n"}, {"name": "PyObject *PyArray_FromStructInterface()", "path": "reference/c-api/array#c.PyArray_FromStructInterface", "type": "Array API", "text": "\nReturns an ndarray object from a Python object that exposes the\n`__array_struct__` attribute and follows the array interface protocol. If the\nobject does not contain this attribute then a borrowed reference to\n`Py_NotImplemented` is returned.\n\n"}, {"name": "PyObject *PyArray_GETITEM()", "path": "reference/c-api/array#c.PyArray_GETITEM", "type": "Array API", "text": "\nGet a Python object of a builtin type from the ndarray, arr, at the location\npointed to by itemptr. Return `NULL` on failure.\n\n"}, {"name": "PyObject *PyArray_GetNumericOps()", "path": "reference/c-api/array#c.PyArray_GetNumericOps", "type": "Array API", "text": "\nReturn a Python dictionary containing the callable Python objects stored in\nthe internal arithmetic operation table. The keys of this dictionary are given\nin the explanation for `PyArray_SetNumericOps`.\n\n"}, {"name": "PyObject *PyArray_InnerProduct()", "path": "reference/c-api/array#c.PyArray_InnerProduct", "type": "Array API", "text": "\nCompute a product-sum over the last dimensions of obj1 and obj2. Neither array\nis conjugated.\n\n"}, {"name": "PyObject *PyArray_IterAllButAxis()", "path": "reference/c-api/array#c.PyArray_IterAllButAxis", "type": "Array API", "text": "\nReturn an array iterator that will iterate over all axes but the one provided\nin *axis. The returned iterator cannot be used with `PyArray_ITER_GOTO1D`.\nThis iterator could be used to write something similar to what ufuncs do\nwherein the loop over the largest axis is done by a separate sub-routine. If\n*axis is negative then *axis will be set to the axis having the smallest\nstride and that axis will be used.\n\n"}, {"name": "PyObject *PyArray_LexSort()", "path": "reference/c-api/array#c.PyArray_LexSort", "type": "Array API", "text": "\nGiven a sequence of arrays (sort_keys) of the same shape, return an array of\nindices (similar to `PyArray_ArgSort` (\u2026)) that would sort the arrays\nlexicographically. A lexicographic sort specifies that when two keys are found\nto be equal, the order is based on comparison of subsequent keys. A merge sort\n(which leaves equal entries unmoved) is required to be defined for the types.\nThe sort is accomplished by sorting the indices first using the first sort_key\nand then using the second sort_key and so forth. This is equivalent to the\nlexsort(sort_keys, axis) Python command. Because of the way the merge-sort\nworks, be sure to understand the order the sort_keys must be in (reversed from\nthe order you would use when comparing two elements).\n\n"}, {"name": "PyObject *PyArray_MapIterArrayCopyIfOverlap()", "path": "reference/c-api/array#c.PyArray_MapIterArrayCopyIfOverlap", "type": "Array API", "text": "\nSimilar to `PyArray_MapIterArray` but with an additional `copy_if_overlap`\nargument. If `copy_if_overlap != 0`, checks if `a` has memory overlap with any\nof the arrays in `index` and with `extra_op`, and make copies as appropriate\nto avoid problems if the input is modified during the iteration. `iter->array`\nmay contain a copied array (UPDATEIFCOPY/WRITEBACKIFCOPY set).\n\n"}, {"name": "PyObject *PyArray_MatrixProduct()", "path": "reference/c-api/array#c.PyArray_MatrixProduct", "type": "Array API", "text": "\nCompute a product-sum over the last dimension of obj1 and the second-to-last\ndimension of obj2. For 2-d arrays this is a matrix-product. Neither array is\nconjugated.\n\n"}, {"name": "PyObject *PyArray_MatrixProduct2()", "path": "reference/c-api/array#c.PyArray_MatrixProduct2", "type": "Array API", "text": "\nNew in version 1.6.\n\n"}, {"name": "PyObject *PyArray_Max()", "path": "reference/c-api/array#c.PyArray_Max", "type": "Array API", "text": "\nEquivalent to `ndarray.max` (self, axis). Returns the largest element of self\nalong the given axis. When the result is a single element, returns a numpy\nscalar instead of an ndarray.\n\n"}, {"name": "PyObject *PyArray_Mean()", "path": "reference/c-api/array#c.PyArray_Mean", "type": "Array API", "text": "\nEquivalent to `ndarray.mean` (self, axis, rtype). Returns the mean of the\nelements along the given axis, using the enumerated type rtype as the data\ntype to sum in. Default sum behavior is obtained using `NPY_NOTYPE` for rtype.\n\n"}, {"name": "PyObject *PyArray_Min()", "path": "reference/c-api/array#c.PyArray_Min", "type": "Array API", "text": "\nEquivalent to `ndarray.min` (self, axis). Return the smallest element of self\nalong the given axis. When the result is a single element, returns a numpy\nscalar instead of an ndarray.\n\n"}, {"name": "PyObject *PyArray_New()", "path": "reference/c-api/array#c.PyArray_New", "type": "Array API", "text": "\nThis is similar to `PyArray_NewFromDescr` (\u2026) except you specify the data-type\ndescriptor with type_num and itemsize, where type_num corresponds to a builtin\n(or user-defined) type. If the type always has the same number of bytes, then\nitemsize is ignored. Otherwise, itemsize specifies the particular size of this\narray.\n\n"}, {"name": "PyObject *PyArray_NewCopy()", "path": "reference/c-api/array#c.PyArray_NewCopy", "type": "Array API", "text": "\nEquivalent to `ndarray.copy` (self, fortran). Make a copy of the old array.\nThe returned array is always aligned and writeable with data interpreted the\nsame as the old array. If order is `NPY_CORDER`, then a C-style contiguous\narray is returned. If order is `NPY_FORTRANORDER`, then a Fortran-style\ncontiguous array is returned. If order is `NPY_ANYORDER`, then the array\nreturned is Fortran-style contiguous only if the old one is; otherwise, it is\nC-style contiguous.\n\n"}, {"name": "PyObject *PyArray_NewLikeArray()", "path": "reference/c-api/array#c.PyArray_NewLikeArray", "type": "Array API", "text": "\nNew in version 1.6.\n\n"}, {"name": "PyObject *PyArray_Nonzero()", "path": "reference/c-api/array#c.PyArray_Nonzero", "type": "Array API", "text": "\nEquivalent to `ndarray.nonzero` (self). Returns a tuple of index arrays that\nselect elements of self that are nonzero. If (nd= `PyArray_NDIM` ( `self`\n))==1, then a single index array is returned. The index arrays have data type\n`NPY_INTP`. If a tuple is returned (nd \\\\(\\neq\\\\) 1), then its length is nd.\n\n"}, {"name": "PyObject *PyArray_Prod()", "path": "reference/c-api/array#c.PyArray_Prod", "type": "Array API", "text": "\nEquivalent to `ndarray.prod` (self, axis, rtype). Return 1-d products of\nelements in self along axis. Perform the product after converting data to data\ntype rtype.\n\n"}, {"name": "PyObject *PyArray_Ptp()", "path": "reference/c-api/array#c.PyArray_Ptp", "type": "Array API", "text": "\nEquivalent to `ndarray.ptp` (self, axis). Return the difference between the\nlargest element of self along axis and the smallest element of self along\naxis. When the result is a single element, returns a numpy scalar instead of\nan ndarray.\n\n"}, {"name": "PyObject *PyArray_PutMask()", "path": "reference/c-api/array#c.PyArray_PutMask", "type": "Array API", "text": "\nPlace the values in self wherever corresponding positions (using a flattened\ncontext) in mask are true. The mask and self arrays must have the same total\nnumber of elements. If values is too small, it will be repeated as necessary.\n\n"}, {"name": "PyObject *PyArray_PutTo()", "path": "reference/c-api/array#c.PyArray_PutTo", "type": "Array API", "text": "\nEquivalent to self.put(values, indices, clipmode ). Put values into self at\nthe corresponding (flattened) indices. If values is too small it will be\nrepeated as necessary.\n\n"}, {"name": "PyObject *PyArray_Ravel()", "path": "reference/c-api/array#c.PyArray_Ravel", "type": "Array API", "text": "\nEquivalent to self.ravel(order). Same basic functionality as `PyArray_Flatten`\n(self, order) except if order is 0 and self is C-style contiguous, the shape\nis altered but no copy is performed.\n\n"}, {"name": "PyObject *PyArray_Repeat()", "path": "reference/c-api/array#c.PyArray_Repeat", "type": "Array API", "text": "\nEquivalent to `ndarray.repeat` (self, op, axis). Copy the elements of self, op\ntimes along the given axis. Either op is a scalar integer or a sequence of\nlength self ->dimensions[ axis ] indicating how many times to repeat each item\nalong the axis.\n\n"}, {"name": "PyObject *PyArray_Reshape()", "path": "reference/c-api/array#c.PyArray_Reshape", "type": "Array API", "text": "\nEquivalent to `ndarray.reshape` (self, shape) where shape is a sequence.\nConverts shape to a `PyArray_Dims` structure and calls `PyArray_Newshape`\ninternally. For back-ward compatibility \u2013 Not recommended\n\n"}, {"name": "PyObject *PyArray_Resize()", "path": "reference/c-api/array#c.PyArray_Resize", "type": "Array API", "text": "\nEquivalent to `ndarray.resize` (self, newshape, refcheck `=` refcheck, order=\nfortran ). This function only works on single-segment arrays. It changes the\nshape of self inplace and will reallocate the memory for self if newshape has\na different total number of elements then the old shape. If reallocation is\nnecessary, then self must own its data, have self \\- `>base==NULL`, have self\n\\- `>weakrefs==NULL`, and (unless refcheck is 0) not be referenced by any\nother array. The fortran argument can be `NPY_ANYORDER`, `NPY_CORDER`, or\n`NPY_FORTRANORDER`. It currently has no effect. Eventually it could be used to\ndetermine how the resize operation should view the data when constructing a\ndifferently-dimensioned array. Returns None on success and NULL on error.\n\n"}, {"name": "PyObject *PyArray_Round()", "path": "reference/c-api/array#c.PyArray_Round", "type": "Array API", "text": "\nEquivalent to `ndarray.round` (self, decimals, out). Returns the array with\nelements rounded to the nearest decimal place. The decimal place is defined as\nthe \\\\(10^{-\\textrm{decimals}}\\\\) digit so that negative decimals cause\nrounding to the nearest 10\u2019s, 100\u2019s, etc. If out is `NULL`, then the output\narray is created, otherwise the output is placed in out which must be the\ncorrect size and type.\n\n"}, {"name": "PyObject *PyArray_Scalar()", "path": "reference/c-api/array#c.PyArray_Scalar", "type": "Array API", "text": "\nReturn an array scalar object of the given dtype by copying from memory\npointed to by data. base is expected to be the array object that is the owner\nof the data. base is required if `dtype` is a `void` scalar, or if the\n`NPY_USE_GETITEM` flag is set and it is known that the `getitem` method uses\nthe `arr` argument without checking if it is `NULL`. Otherwise `base` may be\n`NULL`.\n\n"}, {"name": "PyObject *PyArray_SearchSorted()", "path": "reference/c-api/array#c.PyArray_SearchSorted", "type": "Array API", "text": "\nEquivalent to `ndarray.searchsorted` (self, values, side, perm). Assuming self\nis a 1-d array in ascending order, then the output is an array of indices the\nsame shape as values such that, if the elements in values were inserted before\nthe indices, the order of self would be preserved. No checking is done on\nwhether or not self is in ascending order.\n\n"}, {"name": "PyObject *PyArray_SimpleNew()", "path": "reference/c-api/array#c.PyArray_SimpleNew", "type": "Array API", "text": "\nCreate a new uninitialized array of type, typenum, whose size in each of nd\ndimensions is given by the integer array, dims.The memory for the array is\nuninitialized (unless typenum is `NPY_OBJECT` in which case each element in\nthe array is set to NULL). The typenum argument allows specification of any of\nthe builtin data-types such as `NPY_FLOAT` or `NPY_LONG`. The memory for the\narray can be set to zero if desired using `PyArray_FILLWBYTE` (return_object,\n0).This function cannot be used to create a flexible-type array (no itemsize\ngiven).\n\n"}, {"name": "PyObject *PyArray_SimpleNewFromData()", "path": "reference/c-api/array#c.PyArray_SimpleNewFromData", "type": "Array API", "text": "\nCreate an array wrapper around data pointed to by the given pointer. The array\nflags will have a default that the data area is well-behaved and C-style\ncontiguous. The shape of the array is given by the dims c-array of length nd.\nThe data-type of the array is indicated by typenum. If data comes from another\nreference-counted Python object, the reference count on this object should be\nincreased after the pointer is passed in, and the base member of the returned\nndarray should point to the Python object that owns the data. This will ensure\nthat the provided memory is not freed while the returned array is in\nexistence.\n\n"}, {"name": "PyObject *PyArray_SimpleNewFromDescr()", "path": "reference/c-api/array#c.PyArray_SimpleNewFromDescr", "type": "Array API", "text": "\nThis function steals a reference to descr.\n\n"}, {"name": "PyObject *PyArray_Sort()", "path": "reference/c-api/array#c.PyArray_Sort", "type": "Array API", "text": "\nEquivalent to `ndarray.sort` (self, axis, kind). Return an array with the\nitems of self sorted along axis. The array is sorted using the algorithm\ndenoted by kind, which is an integer/enum pointing to the type of sorting\nalgorithms used.\n\n"}, {"name": "PyObject *PyArray_Squeeze()", "path": "reference/c-api/array#c.PyArray_Squeeze", "type": "Array API", "text": "\nEquivalent to `ndarray.squeeze` (self). Return a new view of self with all of\nthe dimensions of length 1 removed from the shape.\n\n"}, {"name": "PyObject *PyArray_Std()", "path": "reference/c-api/array#c.PyArray_Std", "type": "Array API", "text": "\nEquivalent to `ndarray.std` (self, axis, rtype). Return the standard deviation\nusing data along axis converted to data type rtype.\n\n"}, {"name": "PyObject *PyArray_Sum()", "path": "reference/c-api/array#c.PyArray_Sum", "type": "Array API", "text": "\nEquivalent to `ndarray.sum` (self, axis, rtype). Return 1-d vector sums of\nelements in self along axis. Perform the sum after converting data to data\ntype rtype.\n\n"}, {"name": "PyObject *PyArray_SwapAxes()", "path": "reference/c-api/array#c.PyArray_SwapAxes", "type": "Array API", "text": "\nEquivalent to `ndarray.swapaxes` (self, a1, a2). The returned array is a new\nview of the data in self with the given axes, a1 and a2, swapped.\n\n"}, {"name": "PyObject *PyArray_ToFile()", "path": "reference/c-api/array#c.PyArray_ToFile", "type": "Array API", "text": "\nWrite the contents of self to the file pointer fp in C-style contiguous\nfashion. Write the data as binary bytes if sep is the string \u201c\u201dor `NULL`.\nOtherwise, write the contents of self as text using the sep string as the item\nseparator. Each item will be printed to the file. If the format string is not\n`NULL` or \u201c\u201d, then it is a Python print statement format string showing how\nthe items are to be written.\n\n"}, {"name": "PyObject *PyArray_ToList()", "path": "reference/c-api/array#c.PyArray_ToList", "type": "Array API", "text": "\nEquivalent to `ndarray.tolist` (self). Return a nested Python list from self.\n\n"}, {"name": "PyObject *PyArray_ToScalar()", "path": "reference/c-api/array#c.PyArray_ToScalar", "type": "Array API", "text": "\nReturn an array scalar object of the type and itemsize indicated by the array\nobject arr copied from the memory pointed to by data and swapping if the data\nin arr is not in machine byte-order.\n\n"}, {"name": "PyObject *PyArray_ToString()", "path": "reference/c-api/array#c.PyArray_ToString", "type": "Array API", "text": "\nEquivalent to `ndarray.tobytes` (self, order). Return the bytes of this array\nin a Python string.\n\n"}, {"name": "PyObject *PyArray_Trace()", "path": "reference/c-api/array#c.PyArray_Trace", "type": "Array API", "text": "\nEquivalent to `ndarray.trace` (self, offset, axis1, axis2, rtype). Return the\nsum (using rtype as the data type of summation) over the offset diagonal\nelements of the 2-d arrays defined by axis1 and axis2 variables. A positive\noffset chooses diagonals above the main diagonal. A negative offset selects\ndiagonals below the main diagonal.\n\n"}, {"name": "PyObject *PyArray_Transpose()", "path": "reference/c-api/array#c.PyArray_Transpose", "type": "Array API", "text": "\nEquivalent to `ndarray.transpose` (self, permute). Permute the axes of the\nndarray object self according to the data structure permute and return the\nresult. If permute is `NULL`, then the resulting array has its axes reversed.\nFor example if self has shape \\\\(10\\times20\\times30\\\\), and permute `.ptr` is\n(0,2,1) the shape of the result is \\\\(10\\times30\\times20.\\\\) If permute is\n`NULL`, the shape of the result is \\\\(30\\times20\\times10.\\\\)\n\n"}, {"name": "PyObject *PyArray_TypeObjectFromType()", "path": "reference/c-api/array#c.PyArray_TypeObjectFromType", "type": "Array API", "text": "\nReturns a scalar type-object from a type-number, type . Equivalent to\n`PyArray_DescrFromType` (type)->typeobj except for reference counting and\nerror-checking. Returns a new reference to the typeobject on success or `NULL`\non failure.\n\n"}, {"name": "PyObject *PyArray_View()", "path": "reference/c-api/array#c.PyArray_View", "type": "Array API", "text": "\nEquivalent to `ndarray.view` (self, dtype). Return a new view of the array\nself as possibly a different data-type, dtype, and different array subclass\nptype.\n\n"}, {"name": "PyObject *PyArray_Where()", "path": "reference/c-api/array#c.PyArray_Where", "type": "Array API", "text": "\nIf both `x` and `y` are `NULL`, then return `PyArray_Nonzero` (condition).\nOtherwise, both x and y must be given and the object returned is shaped like\ncondition and has elements of x and y where condition is respectively True or\nFalse.\n\n"}, {"name": "PyObject *PyArray_Zeros()", "path": "reference/c-api/array#c.PyArray_Zeros", "type": "Array API", "text": "\nConstruct a new nd -dimensional array with shape given by dims and data type\ngiven by dtype. If fortran is non-zero, then a Fortran-order array is created,\notherwise a C-order array is created. Fill the memory with zeros (or the 0\nobject if dtype corresponds to `NPY_OBJECT` ).\n\n"}, {"name": "PyObject *PyArray_ZEROS()", "path": "reference/c-api/array#c.PyArray_ZEROS", "type": "Array API", "text": "\nMacro form of `PyArray_Zeros` which takes a type-number instead of a data-type\nobject.\n\n"}, {"name": "PyObject *PyDataMem_GetHandler()", "path": "reference/c-api/data_memory#c.PyDataMem_GetHandler", "type": "Memory management in NumPy", "text": "\nReturn the current policy that will be used to allocate data for the next\n`PyArrayObject`. On failure, return `NULL`.\n\n"}, {"name": "PyObject *PyDataMem_SetHandler()", "path": "reference/c-api/data_memory#c.PyDataMem_SetHandler", "type": "Memory management in NumPy", "text": "\nSet a new allocation policy. If the input value is `NULL`, will reset the\npolicy to the default. Return the previous policy, or return `NULL` if an\nerror has occurred. We wrap the user-provided functions so they will still\ncall the python and numpy memory management callback hooks.\n\n"}, {"name": "PyObject *PyUFunc_FromFuncAndDataAndSignature()", "path": "reference/c-api/ufunc#c.PyUFunc_FromFuncAndDataAndSignature", "type": "UFunc API", "text": "\nThis function is very similar to PyUFunc_FromFuncAndData above, but has an\nextra signature argument, to define a generalized universal functions.\nSimilarly to how ufuncs are built around an element-by-element operation,\ngufuncs are around subarray-by-subarray operations, the signature defining the\nsubarrays to operate on.\n\n"}, {"name": "PyObject *PyUFunc_FromFuncAndDataAndSignatureAndIdentity()", "path": "reference/c-api/ufunc#c.PyUFunc_FromFuncAndDataAndSignatureAndIdentity", "type": "UFunc API", "text": "\nThis function is very similar to `PyUFunc_FromFuncAndDataAndSignature` above,\nbut has an extra identity_value argument, to define an arbitrary identity for\nthe ufunc when `identity` is passed as `PyUFunc_IdentityValue`.\n\n"}, {"name": "PyObject *shape", "path": "reference/c-api/types-and-structures#c.NPY_USE_SETITEM.subarray.PyArray_ArrayDescr.shape", "type": "Python Types and C-Structures", "text": "\nThe shape (always C-style contiguous) of the sub-array as a Python tuple.\n\n"}, {"name": "PyObject *userloops", "path": "reference/c-api/types-and-structures#c.PyUFuncObject.userloops", "type": "Python Types and C-Structures", "text": "\nA dictionary of user-defined 1-d vector loops (stored as CObject ptrs) for\nuser-defined types. A loop may be registered by the user for any user-defined\ntype. It is retrieved by type number. User defined type numbers are always\nlarger than `NPY_USERDEF`.\n\n"}, {"name": "PyObject *weakreflist", "path": "reference/c-api/types-and-structures#c.NPY_AO.weakreflist", "type": "Python Types and C-Structures", "text": "\nThis member allows array objects to have weak references (using the weakref\nmodule).\n\n"}, {"name": "PyTypeObject PyArray_Type", "path": "reference/c-api/types-and-structures", "type": "Python Types and C-Structures", "text": "\nSeveral new types are defined in the C-code. Most of these are accessible from\nPython, but a few are not exposed due to their limited use. Every new Python\ntype has an associated PyObject* with an internal structure that includes a\npointer to a \u201cmethod table\u201d that defines how the new object behaves in Python.\nWhen you receive a Python object into C code, you always get a pointer to a\n`PyObject` structure. Because a `PyObject` structure is very generic and\ndefines only `PyObject_HEAD`, by itself it is not very interesting. However,\ndifferent objects contain more details after the `PyObject_HEAD` (but you have\nto cast to the correct type to access them \u2014 or use accessor functions or\nmacros).\n\n"}, {"name": "PyTypeObject PyArrayMapIter_Type", "path": "reference/c-api/types-and-structures#c.PyArrayMapIter_Type", "type": "Python Types and C-Structures", "text": "\nAdvanced indexing is handled with this Python type. It is simply a loose\nwrapper around the C-structure containing the variables needed for advanced\narray indexing. The associated C-structure, `PyArrayMapIterObject`, is useful\nif you are trying to understand the advanced-index mapping code. It is defined\nin the `arrayobject.h` header. This type is not exposed to Python and could be\nreplaced with a C-structure. As a Python type it takes advantage of reference-\ncounted memory management.\n\n"}, {"name": "PyUFunc_IdentityValue", "path": "reference/c-api/ufunc#c.PyUFunc_IdentityValue", "type": "UFunc API", "text": "\n\n"}, {"name": "PyUFunc_LegacyInnerLoopSelectionFunc *legacy_inner_loop_selector", "path": "reference/c-api/types-and-structures#c.PyUFuncObject.legacy_inner_loop_selector", "type": "Python Types and C-Structures", "text": "\nDeprecated since version 1.22: Some fallback support for this slot exists, but\nwill be removed eventually. A universal function that relied on this will have\nto be ported eventually. See ref:`NEP 41` and ref:`NEP 43`\n\n"}, {"name": "PyUFunc_MinusOne", "path": "reference/c-api/ufunc#c.PyUFunc_MinusOne", "type": "UFunc API", "text": "\n\n"}, {"name": "PyUFunc_None", "path": "reference/c-api/ufunc#c.PyUFunc_None", "type": "UFunc API", "text": "\n\n"}, {"name": "PyUFunc_ReorderableNone", "path": "reference/c-api/ufunc#c.PyUFunc_ReorderableNone", "type": "UFunc API", "text": "\n\n"}, {"name": "PyUFunc_TypeResolutionFunc *type_resolver", "path": "reference/c-api/types-and-structures#c.PyUFuncObject.type_resolver", "type": "Python Types and C-Structures", "text": "\nA function which resolves the types and fills an array with the dtypes for the\ninputs and outputs\n\n"}, {"name": "PyUFunc_Zero", "path": "reference/c-api/ufunc#c.PyUFunc_Zero", "type": "UFunc API", "text": "\n\n"}, {"name": "Random sampling (numpy.random)", "path": "reference/random/index", "type": "Random sampling ( \n      \n       numpy.random\n      \n      )", "text": "\nNumpy\u2019s random number routines produce pseudo random numbers using\ncombinations of a `BitGenerator` to create sequences and a `Generator` to use\nthose sequences to sample from different statistical distributions:\n\n"}, {"name": "random.beta()", "path": "reference/random/generated/numpy.random.beta", "type": "numpy.random.beta", "text": "\nDraw samples from a Beta distribution.\n\n"}, {"name": "random.binomial()", "path": "reference/random/generated/numpy.random.binomial", "type": "numpy.random.binomial", "text": "\nDraw samples from a binomial distribution.\n\n"}, {"name": "random.BitGenerator.cffi", "path": "reference/random/bit_generators/generated/numpy.random.bitgenerator.cffi", "type": "Random sampling", "text": "\nattribute\n\n"}, {"name": "random.BitGenerator.random_raw()", "path": "reference/random/bit_generators/generated/numpy.random.bitgenerator.random_raw", "type": "numpy.random.BitGenerator", "text": "\nmethod\n\n"}, {"name": "random.bytes()", "path": "reference/random/generated/numpy.random.bytes", "type": "numpy.random.bytes", "text": "\nReturn random bytes.\n\n"}, {"name": "random.chisquare()", "path": "reference/random/generated/numpy.random.chisquare", "type": "numpy.random.chisquare", "text": "\nDraw samples from a chi-square distribution.\n\n"}, {"name": "random.choice()", "path": "reference/random/generated/numpy.random.choice", "type": "numpy.random.choice", "text": "\nGenerates a random sample from a given 1-D array\n\n"}, {"name": "random.dirichlet()", "path": "reference/random/generated/numpy.random.dirichlet", "type": "numpy.random.dirichlet", "text": "\nDraw samples from the Dirichlet distribution.\n\n"}, {"name": "random.exponential()", "path": "reference/random/generated/numpy.random.exponential", "type": "numpy.random.exponential", "text": "\nDraw samples from an exponential distribution.\n\n"}, {"name": "random.f()", "path": "reference/random/generated/numpy.random.f", "type": "numpy.random.f", "text": "\nDraw samples from an F distribution.\n\n"}, {"name": "random.gamma()", "path": "reference/random/generated/numpy.random.gamma", "type": "numpy.random.gamma", "text": "\nDraw samples from a Gamma distribution.\n\n"}, {"name": "random.Generator.beta()", "path": "reference/random/generated/numpy.random.generator.beta", "type": "numpy.random.Generator.beta", "text": "\nmethod\n\n"}, {"name": "random.Generator.binomial()", "path": "reference/random/generated/numpy.random.generator.binomial", "type": "numpy.random.Generator.binomial", "text": "\nmethod\n\n"}, {"name": "random.Generator.bit_generator", "path": "reference/random/generated/numpy.random.generator.bit_generator", "type": "numpy.random.Generator.bit_generator", "text": "\nattribute\n\n"}, {"name": "random.Generator.bytes()", "path": "reference/random/generated/numpy.random.generator.bytes", "type": "numpy.random.Generator.bytes", "text": "\nmethod\n\n"}, {"name": "random.Generator.chisquare()", "path": "reference/random/generated/numpy.random.generator.chisquare", "type": "numpy.random.Generator.chisquare", "text": "\nmethod\n\n"}, {"name": "random.Generator.choice()", "path": "reference/random/generated/numpy.random.generator.choice", "type": "numpy.random.Generator.choice", "text": "\nmethod\n\n"}, {"name": "random.Generator.dirichlet()", "path": "reference/random/generated/numpy.random.generator.dirichlet", "type": "numpy.random.Generator.dirichlet", "text": "\nmethod\n\n"}, {"name": "random.Generator.exponential()", "path": "reference/random/generated/numpy.random.generator.exponential", "type": "numpy.random.Generator.exponential", "text": "\nmethod\n\n"}, {"name": "random.Generator.f()", "path": "reference/random/generated/numpy.random.generator.f", "type": "numpy.random.Generator.f", "text": "\nmethod\n\n"}, {"name": "random.Generator.gamma()", "path": "reference/random/generated/numpy.random.generator.gamma", "type": "numpy.random.Generator.gamma", "text": "\nmethod\n\n"}, {"name": "random.Generator.geometric()", "path": "reference/random/generated/numpy.random.generator.geometric", "type": "numpy.random.Generator.geometric", "text": "\nmethod\n\n"}, {"name": "random.Generator.gumbel()", "path": "reference/random/generated/numpy.random.generator.gumbel", "type": "numpy.random.Generator.gumbel", "text": "\nmethod\n\n"}, {"name": "random.Generator.hypergeometric()", "path": "reference/random/generated/numpy.random.generator.hypergeometric", "type": "numpy.random.Generator.hypergeometric", "text": "\nmethod\n\n"}, {"name": "random.Generator.integers()", "path": "reference/random/generated/numpy.random.generator.integers", "type": "numpy.random.Generator.integers", "text": "\nmethod\n\n"}, {"name": "random.Generator.laplace()", "path": "reference/random/generated/numpy.random.generator.laplace", "type": "numpy.random.Generator.laplace", "text": "\nmethod\n\n"}, {"name": "random.Generator.logistic()", "path": "reference/random/generated/numpy.random.generator.logistic", "type": "numpy.random.Generator.logistic", "text": "\nmethod\n\n"}, {"name": "random.Generator.lognormal()", "path": "reference/random/generated/numpy.random.generator.lognormal", "type": "numpy.random.Generator.lognormal", "text": "\nmethod\n\n"}, {"name": "random.Generator.logseries()", "path": "reference/random/generated/numpy.random.generator.logseries", "type": "numpy.random.Generator.logseries", "text": "\nmethod\n\n"}, {"name": "random.Generator.multinomial()", "path": "reference/random/generated/numpy.random.generator.multinomial", "type": "numpy.random.Generator.multinomial", "text": "\nmethod\n\n"}, {"name": "random.Generator.multivariate_hypergeometric()", "path": "reference/random/generated/numpy.random.generator.multivariate_hypergeometric", "type": "numpy.random.Generator.multivariate_hypergeometric", "text": "\nmethod\n\n"}, {"name": "random.Generator.multivariate_normal()", "path": "reference/random/generated/numpy.random.generator.multivariate_normal", "type": "numpy.random.Generator.multivariate_normal", "text": "\nmethod\n\n"}, {"name": "random.Generator.negative_binomial()", "path": "reference/random/generated/numpy.random.generator.negative_binomial", "type": "numpy.random.Generator.negative_binomial", "text": "\nmethod\n\n"}, {"name": "random.Generator.noncentral_chisquare()", "path": "reference/random/generated/numpy.random.generator.noncentral_chisquare", "type": "numpy.random.Generator.noncentral_chisquare", "text": "\nmethod\n\n"}, {"name": "random.Generator.noncentral_f()", "path": "reference/random/generated/numpy.random.generator.noncentral_f", "type": "numpy.random.Generator.noncentral_f", "text": "\nmethod\n\n"}, {"name": "random.Generator.normal()", "path": "reference/random/generated/numpy.random.generator.normal", "type": "numpy.random.Generator.normal", "text": "\nmethod\n\n"}, {"name": "random.Generator.pareto()", "path": "reference/random/generated/numpy.random.generator.pareto", "type": "numpy.random.Generator.pareto", "text": "\nmethod\n\n"}, {"name": "random.Generator.permutation()", "path": "reference/random/generated/numpy.random.generator.permutation", "type": "numpy.random.Generator.permutation", "text": "\nmethod\n\n"}, {"name": "random.Generator.permuted()", "path": "reference/random/generated/numpy.random.generator.permuted", "type": "numpy.random.Generator.permuted", "text": "\nmethod\n\n"}, {"name": "random.Generator.poisson()", "path": "reference/random/generated/numpy.random.generator.poisson", "type": "numpy.random.Generator.poisson", "text": "\nmethod\n\n"}, {"name": "random.Generator.power()", "path": "reference/random/generated/numpy.random.generator.power", "type": "numpy.random.Generator.power", "text": "\nmethod\n\n"}, {"name": "random.Generator.random()", "path": "reference/random/generated/numpy.random.generator.random", "type": "numpy.random.Generator.random", "text": "\nmethod\n\n"}, {"name": "random.Generator.rayleigh()", "path": "reference/random/generated/numpy.random.generator.rayleigh", "type": "numpy.random.Generator.rayleigh", "text": "\nmethod\n\n"}, {"name": "random.Generator.shuffle()", "path": "reference/random/generated/numpy.random.generator.shuffle", "type": "numpy.random.Generator.shuffle", "text": "\nmethod\n\n"}, {"name": "random.Generator.standard_cauchy()", "path": "reference/random/generated/numpy.random.generator.standard_cauchy", "type": "numpy.random.Generator.standard_cauchy", "text": "\nmethod\n\n"}, {"name": "random.Generator.standard_exponential()", "path": "reference/random/generated/numpy.random.generator.standard_exponential", "type": "numpy.random.Generator.standard_exponential", "text": "\nmethod\n\n"}, {"name": "random.Generator.standard_gamma()", "path": "reference/random/generated/numpy.random.generator.standard_gamma", "type": "numpy.random.Generator.standard_gamma", "text": "\nmethod\n\n"}, {"name": "random.Generator.standard_normal()", "path": "reference/random/generated/numpy.random.generator.standard_normal", "type": "numpy.random.Generator.standard_normal", "text": "\nmethod\n\n"}, {"name": "random.Generator.standard_t()", "path": "reference/random/generated/numpy.random.generator.standard_t", "type": "numpy.random.Generator.standard_t", "text": "\nmethod\n\n"}, {"name": "random.Generator.triangular()", "path": "reference/random/generated/numpy.random.generator.triangular", "type": "numpy.random.Generator.triangular", "text": "\nmethod\n\n"}, {"name": "random.Generator.uniform()", "path": "reference/random/generated/numpy.random.generator.uniform", "type": "numpy.random.Generator.uniform", "text": "\nmethod\n\n"}, {"name": "random.Generator.vonmises()", "path": "reference/random/generated/numpy.random.generator.vonmises", "type": "numpy.random.Generator.vonmises", "text": "\nmethod\n\n"}, {"name": "random.Generator.wald()", "path": "reference/random/generated/numpy.random.generator.wald", "type": "numpy.random.Generator.wald", "text": "\nmethod\n\n"}, {"name": "random.Generator.weibull()", "path": "reference/random/generated/numpy.random.generator.weibull", "type": "numpy.random.Generator.weibull", "text": "\nmethod\n\n"}, {"name": "random.Generator.zipf()", "path": "reference/random/generated/numpy.random.generator.zipf", "type": "numpy.random.Generator.zipf", "text": "\nmethod\n\n"}, {"name": "random.geometric()", "path": "reference/random/generated/numpy.random.geometric", "type": "numpy.random.geometric", "text": "\nDraw samples from the geometric distribution.\n\n"}, {"name": "random.get_state()", "path": "reference/random/generated/numpy.random.get_state", "type": "numpy.random.get_state", "text": "\nReturn a tuple representing the internal state of the generator.\n\n"}, {"name": "random.gumbel()", "path": "reference/random/generated/numpy.random.gumbel", "type": "numpy.random.gumbel", "text": "\nDraw samples from a Gumbel distribution.\n\n"}, {"name": "random.hypergeometric()", "path": "reference/random/generated/numpy.random.hypergeometric", "type": "numpy.random.hypergeometric", "text": "\nDraw samples from a Hypergeometric distribution.\n\n"}, {"name": "random.laplace()", "path": "reference/random/generated/numpy.random.laplace", "type": "numpy.random.laplace", "text": "\nDraw samples from the Laplace or double exponential distribution with\nspecified location (or mean) and scale (decay).\n\n"}, {"name": "random.logistic()", "path": "reference/random/generated/numpy.random.logistic", "type": "numpy.random.logistic", "text": "\nDraw samples from a logistic distribution.\n\n"}, {"name": "random.lognormal()", "path": "reference/random/generated/numpy.random.lognormal", "type": "numpy.random.lognormal", "text": "\nDraw samples from a log-normal distribution.\n\n"}, {"name": "random.logseries()", "path": "reference/random/generated/numpy.random.logseries", "type": "numpy.random.logseries", "text": "\nDraw samples from a logarithmic series distribution.\n\n"}, {"name": "random.MT19937.cffi", "path": "reference/random/bit_generators/generated/numpy.random.mt19937.cffi", "type": "MT19937", "text": "\nattribute\n\n"}, {"name": "random.MT19937.ctypes", "path": "reference/random/bit_generators/generated/numpy.random.mt19937.ctypes", "type": "MT19937", "text": "\nattribute\n\n"}, {"name": "random.MT19937.jumped()", "path": "reference/random/bit_generators/generated/numpy.random.mt19937.jumped", "type": "MT19937", "text": "\nmethod\n\n"}, {"name": "random.MT19937.state", "path": "reference/random/bit_generators/generated/numpy.random.mt19937.state", "type": "MT19937", "text": "\nattribute\n\n"}, {"name": "random.multinomial()", "path": "reference/random/generated/numpy.random.multinomial", "type": "numpy.random.multinomial", "text": "\nDraw samples from a multinomial distribution.\n\n"}, {"name": "random.multivariate_normal()", "path": "reference/random/generated/numpy.random.multivariate_normal", "type": "numpy.random.multivariate_normal", "text": "\nDraw random samples from a multivariate normal distribution.\n\n"}, {"name": "random.negative_binomial()", "path": "reference/random/generated/numpy.random.negative_binomial", "type": "numpy.random.negative_binomial", "text": "\nDraw samples from a negative binomial distribution.\n\n"}, {"name": "random.noncentral_chisquare()", "path": "reference/random/generated/numpy.random.noncentral_chisquare", "type": "numpy.random.noncentral_chisquare", "text": "\nDraw samples from a noncentral chi-square distribution.\n\n"}, {"name": "random.noncentral_f()", "path": "reference/random/generated/numpy.random.noncentral_f", "type": "numpy.random.noncentral_f", "text": "\nDraw samples from the noncentral F distribution.\n\n"}, {"name": "random.normal()", "path": "reference/random/generated/numpy.random.normal", "type": "numpy.random.normal", "text": "\nDraw random samples from a normal (Gaussian) distribution.\n\n"}, {"name": "random.pareto()", "path": "reference/random/generated/numpy.random.pareto", "type": "numpy.random.pareto", "text": "\nDraw samples from a Pareto II or Lomax distribution with specified shape.\n\n"}, {"name": "random.PCG64.advance()", "path": "reference/random/bit_generators/generated/numpy.random.pcg64.advance", "type": "PCG64", "text": "\nmethod\n\n"}, {"name": "random.PCG64.cffi", "path": "reference/random/bit_generators/generated/numpy.random.pcg64.cffi", "type": "PCG64", "text": "\nattribute\n\n"}, {"name": "random.PCG64.ctypes", "path": "reference/random/bit_generators/generated/numpy.random.pcg64.ctypes", "type": "PCG64", "text": "\nattribute\n\n"}, {"name": "random.PCG64.jumped()", "path": "reference/random/bit_generators/generated/numpy.random.pcg64.jumped", "type": "PCG64", "text": "\nmethod\n\n"}, {"name": "random.PCG64.state", "path": "reference/random/bit_generators/generated/numpy.random.pcg64.state", "type": "PCG64", "text": "\nattribute\n\n"}, {"name": "random.PCG64DXSM.advance()", "path": "reference/random/bit_generators/generated/numpy.random.pcg64dxsm.advance", "type": "PCG64DXSM", "text": "\nmethod\n\n"}, {"name": "random.PCG64DXSM.cffi", "path": "reference/random/bit_generators/generated/numpy.random.pcg64dxsm.cffi", "type": "PCG64DXSM", "text": "\nattribute\n\n"}, {"name": "random.PCG64DXSM.ctypes", "path": "reference/random/bit_generators/generated/numpy.random.pcg64dxsm.ctypes", "type": "PCG64DXSM", "text": "\nattribute\n\n"}, {"name": "random.PCG64DXSM.jumped()", "path": "reference/random/bit_generators/generated/numpy.random.pcg64dxsm.jumped", "type": "PCG64DXSM", "text": "\nmethod\n\n"}, {"name": "random.PCG64DXSM.state", "path": "reference/random/bit_generators/generated/numpy.random.pcg64dxsm.state", "type": "PCG64DXSM", "text": "\nattribute\n\n"}, {"name": "random.permutation()", "path": "reference/random/generated/numpy.random.permutation", "type": "numpy.random.permutation", "text": "\nRandomly permute a sequence, or return a permuted range.\n\n"}, {"name": "random.Philox.advance()", "path": "reference/random/bit_generators/generated/numpy.random.philox.advance", "type": "Philox", "text": "\nmethod\n\n"}, {"name": "random.Philox.cffi", "path": "reference/random/bit_generators/generated/numpy.random.philox.cffi", "type": "Philox", "text": "\nattribute\n\n"}, {"name": "random.Philox.ctypes", "path": "reference/random/bit_generators/generated/numpy.random.philox.ctypes", "type": "Philox", "text": "\nattribute\n\n"}, {"name": "random.Philox.jumped()", "path": "reference/random/bit_generators/generated/numpy.random.philox.jumped", "type": "Philox", "text": "\nmethod\n\n"}, {"name": "random.Philox.state", "path": "reference/random/bit_generators/generated/numpy.random.philox.state", "type": "Philox", "text": "\nattribute\n\n"}, {"name": "random.poisson()", "path": "reference/random/generated/numpy.random.poisson", "type": "numpy.random.poisson", "text": "\nDraw samples from a Poisson distribution.\n\n"}, {"name": "random.power()", "path": "reference/random/generated/numpy.random.power", "type": "numpy.random.power", "text": "\nDraws samples in [0, 1] from a power distribution with positive exponent a -\n1.\n\n"}, {"name": "random.rand()", "path": "reference/random/generated/numpy.random.rand", "type": "numpy.random.rand", "text": "\nRandom values in a given shape.\n\n"}, {"name": "random.randint()", "path": "reference/random/generated/numpy.random.randint", "type": "numpy.random.randint", "text": "\nReturn random integers from `low` (inclusive) to `high` (exclusive).\n\n"}, {"name": "random.randn()", "path": "reference/random/generated/numpy.random.randn", "type": "numpy.random.randn", "text": "\nReturn a sample (or samples) from the \u201cstandard normal\u201d distribution.\n\n"}, {"name": "random.random()", "path": "reference/random/generated/numpy.random.random", "type": "numpy.random.random", "text": "\nReturn random floats in the half-open interval [0.0, 1.0). Alias for\n`random_sample` to ease forward-porting to the new random API.\n\n"}, {"name": "random.random_integers()", "path": "reference/random/generated/numpy.random.random_integers", "type": "numpy.random.random_integers", "text": "\nRandom integers of type `np.int_` between `low` and `high`, inclusive.\n\n"}, {"name": "random.random_sample()", "path": "reference/random/generated/numpy.random.random_sample", "type": "numpy.random.random_sample", "text": "\nReturn random floats in the half-open interval [0.0, 1.0).\n\n"}, {"name": "random.RandomState.beta()", "path": "reference/random/generated/numpy.random.randomstate.beta", "type": "numpy.random.RandomState.beta", "text": "\nmethod\n\n"}, {"name": "random.RandomState.binomial()", "path": "reference/random/generated/numpy.random.randomstate.binomial", "type": "numpy.random.RandomState.binomial", "text": "\nmethod\n\n"}, {"name": "random.RandomState.bytes()", "path": "reference/random/generated/numpy.random.randomstate.bytes", "type": "numpy.random.RandomState.bytes", "text": "\nmethod\n\n"}, {"name": "random.RandomState.chisquare()", "path": "reference/random/generated/numpy.random.randomstate.chisquare", "type": "numpy.random.RandomState.chisquare", "text": "\nmethod\n\n"}, {"name": "random.RandomState.choice()", "path": "reference/random/generated/numpy.random.randomstate.choice", "type": "numpy.random.RandomState.choice", "text": "\nmethod\n\n"}, {"name": "random.RandomState.dirichlet()", "path": "reference/random/generated/numpy.random.randomstate.dirichlet", "type": "numpy.random.RandomState.dirichlet", "text": "\nmethod\n\n"}, {"name": "random.RandomState.exponential()", "path": "reference/random/generated/numpy.random.randomstate.exponential", "type": "numpy.random.RandomState.exponential", "text": "\nmethod\n\n"}, {"name": "random.RandomState.f()", "path": "reference/random/generated/numpy.random.randomstate.f", "type": "numpy.random.RandomState.f", "text": "\nmethod\n\n"}, {"name": "random.RandomState.gamma()", "path": "reference/random/generated/numpy.random.randomstate.gamma", "type": "numpy.random.RandomState.gamma", "text": "\nmethod\n\n"}, {"name": "random.RandomState.geometric()", "path": "reference/random/generated/numpy.random.randomstate.geometric", "type": "numpy.random.RandomState.geometric", "text": "\nmethod\n\n"}, {"name": "random.RandomState.get_state()", "path": "reference/random/generated/numpy.random.randomstate.get_state", "type": "numpy.random.RandomState.get_state", "text": "\nmethod\n\n"}, {"name": "random.RandomState.gumbel()", "path": "reference/random/generated/numpy.random.randomstate.gumbel", "type": "numpy.random.RandomState.gumbel", "text": "\nmethod\n\n"}, {"name": "random.RandomState.hypergeometric()", "path": "reference/random/generated/numpy.random.randomstate.hypergeometric", "type": "numpy.random.RandomState.hypergeometric", "text": "\nmethod\n\n"}, {"name": "random.RandomState.laplace()", "path": "reference/random/generated/numpy.random.randomstate.laplace", "type": "numpy.random.RandomState.laplace", "text": "\nmethod\n\n"}, {"name": "random.RandomState.logistic()", "path": "reference/random/generated/numpy.random.randomstate.logistic", "type": "numpy.random.RandomState.logistic", "text": "\nmethod\n\n"}, {"name": "random.RandomState.lognormal()", "path": "reference/random/generated/numpy.random.randomstate.lognormal", "type": "numpy.random.RandomState.lognormal", "text": "\nmethod\n\n"}, {"name": "random.RandomState.logseries()", "path": "reference/random/generated/numpy.random.randomstate.logseries", "type": "numpy.random.RandomState.logseries", "text": "\nmethod\n\n"}, {"name": "random.RandomState.multinomial()", "path": "reference/random/generated/numpy.random.randomstate.multinomial", "type": "numpy.random.RandomState.multinomial", "text": "\nmethod\n\n"}, {"name": "random.RandomState.multivariate_normal()", "path": "reference/random/generated/numpy.random.randomstate.multivariate_normal", "type": "numpy.random.RandomState.multivariate_normal", "text": "\nmethod\n\n"}, {"name": "random.RandomState.negative_binomial()", "path": "reference/random/generated/numpy.random.randomstate.negative_binomial", "type": "numpy.random.RandomState.negative_binomial", "text": "\nmethod\n\n"}, {"name": "random.RandomState.noncentral_chisquare()", "path": "reference/random/generated/numpy.random.randomstate.noncentral_chisquare", "type": "numpy.random.RandomState.noncentral_chisquare", "text": "\nmethod\n\n"}, {"name": "random.RandomState.noncentral_f()", "path": "reference/random/generated/numpy.random.randomstate.noncentral_f", "type": "numpy.random.RandomState.noncentral_f", "text": "\nmethod\n\n"}, {"name": "random.RandomState.normal()", "path": "reference/random/generated/numpy.random.randomstate.normal", "type": "numpy.random.RandomState.normal", "text": "\nmethod\n\n"}, {"name": "random.RandomState.pareto()", "path": "reference/random/generated/numpy.random.randomstate.pareto", "type": "numpy.random.RandomState.pareto", "text": "\nmethod\n\n"}, {"name": "random.RandomState.permutation()", "path": "reference/random/generated/numpy.random.randomstate.permutation", "type": "numpy.random.RandomState.permutation", "text": "\nmethod\n\n"}, {"name": "random.RandomState.poisson()", "path": "reference/random/generated/numpy.random.randomstate.poisson", "type": "numpy.random.RandomState.poisson", "text": "\nmethod\n\n"}, {"name": "random.RandomState.power()", "path": "reference/random/generated/numpy.random.randomstate.power", "type": "numpy.random.RandomState.power", "text": "\nmethod\n\n"}, {"name": "random.RandomState.rand()", "path": "reference/random/generated/numpy.random.randomstate.rand", "type": "numpy.random.RandomState.rand", "text": "\nmethod\n\n"}, {"name": "random.RandomState.randint()", "path": "reference/random/generated/numpy.random.randomstate.randint", "type": "numpy.random.RandomState.randint", "text": "\nmethod\n\n"}, {"name": "random.RandomState.randn()", "path": "reference/random/generated/numpy.random.randomstate.randn", "type": "numpy.random.RandomState.randn", "text": "\nmethod\n\n"}, {"name": "random.RandomState.random_integers()", "path": "reference/random/generated/numpy.random.randomstate.random_integers", "type": "numpy.random.RandomState.random_integers", "text": "\nmethod\n\n"}, {"name": "random.RandomState.random_sample()", "path": "reference/random/generated/numpy.random.randomstate.random_sample", "type": "numpy.random.RandomState.random_sample", "text": "\nmethod\n\n"}, {"name": "random.RandomState.rayleigh()", "path": "reference/random/generated/numpy.random.randomstate.rayleigh", "type": "numpy.random.RandomState.rayleigh", "text": "\nmethod\n\n"}, {"name": "random.RandomState.seed()", "path": "reference/random/generated/numpy.random.randomstate.seed", "type": "numpy.random.RandomState.seed", "text": "\nmethod\n\n"}, {"name": "random.RandomState.set_state()", "path": "reference/random/generated/numpy.random.randomstate.set_state", "type": "numpy.random.RandomState.set_state", "text": "\nmethod\n\n"}, {"name": "random.RandomState.shuffle()", "path": "reference/random/generated/numpy.random.randomstate.shuffle", "type": "numpy.random.RandomState.shuffle", "text": "\nmethod\n\n"}, {"name": "random.RandomState.standard_cauchy()", "path": "reference/random/generated/numpy.random.randomstate.standard_cauchy", "type": "numpy.random.RandomState.standard_cauchy", "text": "\nmethod\n\n"}, {"name": "random.RandomState.standard_exponential()", "path": "reference/random/generated/numpy.random.randomstate.standard_exponential", "type": "numpy.random.RandomState.standard_exponential", "text": "\nmethod\n\n"}, {"name": "random.RandomState.standard_gamma()", "path": "reference/random/generated/numpy.random.randomstate.standard_gamma", "type": "numpy.random.RandomState.standard_gamma", "text": "\nmethod\n\n"}, {"name": "random.RandomState.standard_normal()", "path": "reference/random/generated/numpy.random.randomstate.standard_normal", "type": "numpy.random.RandomState.standard_normal", "text": "\nmethod\n\n"}, {"name": "random.RandomState.standard_t()", "path": "reference/random/generated/numpy.random.randomstate.standard_t", "type": "numpy.random.RandomState.standard_t", "text": "\nmethod\n\n"}, {"name": "random.RandomState.triangular()", "path": "reference/random/generated/numpy.random.randomstate.triangular", "type": "numpy.random.RandomState.triangular", "text": "\nmethod\n\n"}, {"name": "random.RandomState.uniform()", "path": "reference/random/generated/numpy.random.randomstate.uniform", "type": "numpy.random.RandomState.uniform", "text": "\nmethod\n\n"}, {"name": "random.RandomState.vonmises()", "path": "reference/random/generated/numpy.random.randomstate.vonmises", "type": "numpy.random.RandomState.vonmises", "text": "\nmethod\n\n"}, {"name": "random.RandomState.wald()", "path": "reference/random/generated/numpy.random.randomstate.wald", "type": "numpy.random.RandomState.wald", "text": "\nmethod\n\n"}, {"name": "random.RandomState.weibull()", "path": "reference/random/generated/numpy.random.randomstate.weibull", "type": "numpy.random.RandomState.weibull", "text": "\nmethod\n\n"}, {"name": "random.RandomState.zipf()", "path": "reference/random/generated/numpy.random.randomstate.zipf", "type": "numpy.random.RandomState.zipf", "text": "\nmethod\n\n"}, {"name": "random.ranf()", "path": "reference/random/generated/numpy.random.ranf", "type": "numpy.random.ranf", "text": "\nThis is an alias of `random_sample`. See `random_sample` for the complete\ndocumentation.\n\n"}, {"name": "random.rayleigh()", "path": "reference/random/generated/numpy.random.rayleigh", "type": "numpy.random.rayleigh", "text": "\nDraw samples from a Rayleigh distribution.\n\n"}, {"name": "random.sample()", "path": "reference/random/generated/numpy.random.sample", "type": "numpy.random.sample", "text": "\nThis is an alias of `random_sample`. See `random_sample` for the complete\ndocumentation.\n\n"}, {"name": "random.seed()", "path": "reference/random/generated/numpy.random.seed", "type": "numpy.random.seed", "text": "\nReseed a legacy MT19937 BitGenerator\n\n"}, {"name": "random.SeedSequence.entropy", "path": "reference/random/bit_generators/generated/numpy.random.seedsequence.entropy", "type": "Random sampling", "text": "\nattribute\n\n"}, {"name": "random.SeedSequence.generate_state()", "path": "reference/random/bit_generators/generated/numpy.random.seedsequence.generate_state", "type": "Random sampling ( \n      \n       numpy.random\n      \n      )", "text": "\nmethod\n\n"}, {"name": "random.SeedSequence.spawn()", "path": "reference/random/bit_generators/generated/numpy.random.seedsequence.spawn", "type": "Random sampling ( \n      \n       numpy.random\n      \n      )", "text": "\nmethod\n\n"}, {"name": "random.SeedSequence.spawn_key", "path": "reference/random/bit_generators/generated/numpy.random.seedsequence.spawn_key", "type": "Random sampling", "text": "\nattribute\n\n"}, {"name": "random.set_state()", "path": "reference/random/generated/numpy.random.set_state", "type": "numpy.random.set_state", "text": "\nSet the internal state of the generator from a tuple.\n\n"}, {"name": "random.SFC64.cffi", "path": "reference/random/bit_generators/generated/numpy.random.sfc64.cffi", "type": "SFC64", "text": "\nattribute\n\n"}, {"name": "random.SFC64.ctypes", "path": "reference/random/bit_generators/generated/numpy.random.sfc64.ctypes", "type": "SFC64", "text": "\nattribute\n\n"}, {"name": "random.SFC64.state", "path": "reference/random/bit_generators/generated/numpy.random.sfc64.state", "type": "SFC64", "text": "\nattribute\n\n"}, {"name": "random.shuffle()", "path": "reference/random/generated/numpy.random.shuffle", "type": "numpy.random.shuffle", "text": "\nModify a sequence in-place by shuffling its contents.\n\n"}, {"name": "random.standard_cauchy()", "path": "reference/random/generated/numpy.random.standard_cauchy", "type": "numpy.random.standard_cauchy", "text": "\nDraw samples from a standard Cauchy distribution with mode = 0.\n\n"}, {"name": "random.standard_exponential()", "path": "reference/random/generated/numpy.random.standard_exponential", "type": "numpy.random.standard_exponential", "text": "\nDraw samples from the standard exponential distribution.\n\n"}, {"name": "random.standard_gamma()", "path": "reference/random/generated/numpy.random.standard_gamma", "type": "numpy.random.standard_gamma", "text": "\nDraw samples from a standard Gamma distribution.\n\n"}, {"name": "random.standard_normal()", "path": "reference/random/generated/numpy.random.standard_normal", "type": "numpy.random.standard_normal", "text": "\nDraw samples from a standard Normal distribution (mean=0, stdev=1).\n\n"}, {"name": "random.standard_t()", "path": "reference/random/generated/numpy.random.standard_t", "type": "numpy.random.standard_t", "text": "\nDraw samples from a standard Student\u2019s t distribution with `df` degrees of\nfreedom.\n\n"}, {"name": "random.triangular()", "path": "reference/random/generated/numpy.random.triangular", "type": "numpy.random.triangular", "text": "\nDraw samples from the triangular distribution over the interval `[left,\nright]`.\n\n"}, {"name": "random.uniform()", "path": "reference/random/generated/numpy.random.uniform", "type": "numpy.random.uniform", "text": "\nDraw samples from a uniform distribution.\n\n"}, {"name": "random.vonmises()", "path": "reference/random/generated/numpy.random.vonmises", "type": "numpy.random.vonmises", "text": "\nDraw samples from a von Mises distribution.\n\n"}, {"name": "random.wald()", "path": "reference/random/generated/numpy.random.wald", "type": "numpy.random.wald", "text": "\nDraw samples from a Wald, or inverse Gaussian, distribution.\n\n"}, {"name": "random.weibull()", "path": "reference/random/generated/numpy.random.weibull", "type": "numpy.random.weibull", "text": "\nDraw samples from a Weibull distribution.\n\n"}, {"name": "random.zipf()", "path": "reference/random/generated/numpy.random.zipf", "type": "numpy.random.zipf", "text": "\nDraw samples from a Zipf distribution.\n\n"}, {"name": "Reading and writing files", "path": "user/how-to-io", "type": "User Guide", "text": "\nThis page tackles common applications; for the full collection of I/O\nroutines, see Input and output.\n\n"}, {"name": "recarray.all()", "path": "reference/generated/numpy.recarray.all", "type": "numpy.recarray.all", "text": "\nmethod\n\n"}, {"name": "recarray.any()", "path": "reference/generated/numpy.recarray.any", "type": "numpy.recarray.any", "text": "\nmethod\n\n"}, {"name": "recarray.argmax()", "path": "reference/generated/numpy.recarray.argmax", "type": "numpy.recarray.argmax", "text": "\nmethod\n\n"}, {"name": "recarray.argmin()", "path": "reference/generated/numpy.recarray.argmin", "type": "numpy.recarray.argmin", "text": "\nmethod\n\n"}, {"name": "recarray.argpartition()", "path": "reference/generated/numpy.recarray.argpartition", "type": "numpy.recarray.argpartition", "text": "\nmethod\n\n"}, {"name": "recarray.argsort()", "path": "reference/generated/numpy.recarray.argsort", "type": "numpy.recarray.argsort", "text": "\nmethod\n\n"}, {"name": "recarray.astype()", "path": "reference/generated/numpy.recarray.astype", "type": "numpy.recarray.astype", "text": "\nmethod\n\n"}, {"name": "recarray.base", "path": "reference/generated/numpy.recarray.base", "type": "Standard array subclasses", "text": "\nattribute\n\n"}, {"name": "recarray.byteswap()", "path": "reference/generated/numpy.recarray.byteswap", "type": "numpy.recarray.byteswap", "text": "\nmethod\n\n"}, {"name": "recarray.choose()", "path": "reference/generated/numpy.recarray.choose", "type": "numpy.recarray.choose", "text": "\nmethod\n\n"}, {"name": "recarray.clip()", "path": "reference/generated/numpy.recarray.clip", "type": "numpy.recarray.clip", "text": "\nmethod\n\n"}, {"name": "recarray.compress()", "path": "reference/generated/numpy.recarray.compress", "type": "numpy.recarray.compress", "text": "\nmethod\n\n"}, {"name": "recarray.conj()", "path": "reference/generated/numpy.recarray.conj", "type": "numpy.recarray.conj", "text": "\nmethod\n\n"}, {"name": "recarray.conjugate()", "path": "reference/generated/numpy.recarray.conjugate", "type": "numpy.recarray.conjugate", "text": "\nmethod\n\n"}, {"name": "recarray.copy()", "path": "reference/generated/numpy.recarray.copy", "type": "numpy.recarray.copy", "text": "\nmethod\n\n"}, {"name": "recarray.ctypes", "path": "reference/generated/numpy.recarray.ctypes", "type": "Standard array subclasses", "text": "\nattribute\n\n"}, {"name": "recarray.cumprod()", "path": "reference/generated/numpy.recarray.cumprod", "type": "numpy.recarray.cumprod", "text": "\nmethod\n\n"}, {"name": "recarray.cumsum()", "path": "reference/generated/numpy.recarray.cumsum", "type": "numpy.recarray.cumsum", "text": "\nmethod\n\n"}, {"name": "recarray.data", "path": "reference/generated/numpy.recarray.data", "type": "Standard array subclasses", "text": "\nattribute\n\n"}, {"name": "recarray.diagonal()", "path": "reference/generated/numpy.recarray.diagonal", "type": "numpy.recarray.diagonal", "text": "\nmethod\n\n"}, {"name": "recarray.dump()", "path": "reference/generated/numpy.recarray.dump", "type": "numpy.recarray.dump", "text": "\nmethod\n\n"}, {"name": "recarray.dumps()", "path": "reference/generated/numpy.recarray.dumps", "type": "numpy.recarray.dumps", "text": "\nmethod\n\n"}, {"name": "recarray.fill()", "path": "reference/generated/numpy.recarray.fill", "type": "numpy.recarray.fill", "text": "\nmethod\n\n"}, {"name": "recarray.flags", "path": "reference/generated/numpy.recarray.flags", "type": "Standard array subclasses", "text": "\nattribute\n\n"}, {"name": "recarray.flat", "path": "reference/generated/numpy.recarray.flat", "type": "Standard array subclasses", "text": "\nattribute\n\n"}, {"name": "recarray.flatten()", "path": "reference/generated/numpy.recarray.flatten", "type": "numpy.recarray.flatten", "text": "\nmethod\n\n"}, {"name": "recarray.getfield()", "path": "reference/generated/numpy.recarray.getfield", "type": "numpy.recarray.getfield", "text": "\nmethod\n\n"}, {"name": "recarray.item()", "path": "reference/generated/numpy.recarray.item", "type": "numpy.recarray.item", "text": "\nmethod\n\n"}, {"name": "recarray.itemset()", "path": "reference/generated/numpy.recarray.itemset", "type": "numpy.recarray.itemset", "text": "\nmethod\n\n"}, {"name": "recarray.itemsize", "path": "reference/generated/numpy.recarray.itemsize", "type": "Standard array subclasses", "text": "\nattribute\n\n"}, {"name": "recarray.max()", "path": "reference/generated/numpy.recarray.max", "type": "numpy.recarray.max", "text": "\nmethod\n\n"}, {"name": "recarray.mean()", "path": "reference/generated/numpy.recarray.mean", "type": "numpy.recarray.mean", "text": "\nmethod\n\n"}, {"name": "recarray.min()", "path": "reference/generated/numpy.recarray.min", "type": "numpy.recarray.min", "text": "\nmethod\n\n"}, {"name": "recarray.nbytes", "path": "reference/generated/numpy.recarray.nbytes", "type": "Standard array subclasses", "text": "\nattribute\n\n"}, {"name": "recarray.ndim", "path": "reference/generated/numpy.recarray.ndim", "type": "Standard array subclasses", "text": "\nattribute\n\n"}, {"name": "recarray.newbyteorder()", "path": "reference/generated/numpy.recarray.newbyteorder", "type": "numpy.recarray.newbyteorder", "text": "\nmethod\n\n"}, {"name": "recarray.nonzero()", "path": "reference/generated/numpy.recarray.nonzero", "type": "numpy.recarray.nonzero", "text": "\nmethod\n\n"}, {"name": "recarray.partition()", "path": "reference/generated/numpy.recarray.partition", "type": "numpy.recarray.partition", "text": "\nmethod\n\n"}, {"name": "recarray.prod()", "path": "reference/generated/numpy.recarray.prod", "type": "numpy.recarray.prod", "text": "\nmethod\n\n"}, {"name": "recarray.ptp()", "path": "reference/generated/numpy.recarray.ptp", "type": "numpy.recarray.ptp", "text": "\nmethod\n\n"}, {"name": "recarray.put()", "path": "reference/generated/numpy.recarray.put", "type": "numpy.recarray.put", "text": "\nmethod\n\n"}, {"name": "recarray.ravel()", "path": "reference/generated/numpy.recarray.ravel", "type": "numpy.recarray.ravel", "text": "\nmethod\n\n"}, {"name": "recarray.repeat()", "path": "reference/generated/numpy.recarray.repeat", "type": "numpy.recarray.repeat", "text": "\nmethod\n\n"}, {"name": "recarray.reshape()", "path": "reference/generated/numpy.recarray.reshape", "type": "numpy.recarray.reshape", "text": "\nmethod\n\n"}, {"name": "recarray.resize()", "path": "reference/generated/numpy.recarray.resize", "type": "numpy.recarray.resize", "text": "\nmethod\n\n"}, {"name": "recarray.round()", "path": "reference/generated/numpy.recarray.round", "type": "numpy.recarray.round", "text": "\nmethod\n\n"}, {"name": "recarray.searchsorted()", "path": "reference/generated/numpy.recarray.searchsorted", "type": "numpy.recarray.searchsorted", "text": "\nmethod\n\n"}, {"name": "recarray.setfield()", "path": "reference/generated/numpy.recarray.setfield", "type": "numpy.recarray.setfield", "text": "\nmethod\n\n"}, {"name": "recarray.setflags()", "path": "reference/generated/numpy.recarray.setflags", "type": "numpy.recarray.setflags", "text": "\nmethod\n\n"}, {"name": "recarray.size", "path": "reference/generated/numpy.recarray.size", "type": "Standard array subclasses", "text": "\nattribute\n\n"}, {"name": "recarray.sort()", "path": "reference/generated/numpy.recarray.sort", "type": "numpy.recarray.sort", "text": "\nmethod\n\n"}, {"name": "recarray.squeeze()", "path": "reference/generated/numpy.recarray.squeeze", "type": "numpy.recarray.squeeze", "text": "\nmethod\n\n"}, {"name": "recarray.std()", "path": "reference/generated/numpy.recarray.std", "type": "numpy.recarray.std", "text": "\nmethod\n\n"}, {"name": "recarray.strides", "path": "reference/generated/numpy.recarray.strides", "type": "Standard array subclasses", "text": "\nattribute\n\n"}, {"name": "recarray.sum()", "path": "reference/generated/numpy.recarray.sum", "type": "numpy.recarray.sum", "text": "\nmethod\n\n"}, {"name": "recarray.swapaxes()", "path": "reference/generated/numpy.recarray.swapaxes", "type": "numpy.recarray.swapaxes", "text": "\nmethod\n\n"}, {"name": "recarray.T", "path": "reference/generated/numpy.recarray.t", "type": "Standard array subclasses", "text": "\nattribute\n\n"}, {"name": "recarray.take()", "path": "reference/generated/numpy.recarray.take", "type": "numpy.recarray.take", "text": "\nmethod\n\n"}, {"name": "recarray.tobytes()", "path": "reference/generated/numpy.recarray.tobytes", "type": "numpy.recarray.tobytes", "text": "\nmethod\n\n"}, {"name": "recarray.tofile()", "path": "reference/generated/numpy.recarray.tofile", "type": "numpy.recarray.tofile", "text": "\nmethod\n\n"}, {"name": "recarray.tolist()", "path": "reference/generated/numpy.recarray.tolist", "type": "numpy.recarray.tolist", "text": "\nmethod\n\n"}, {"name": "recarray.tostring()", "path": "reference/generated/numpy.recarray.tostring", "type": "numpy.recarray.tostring", "text": "\nmethod\n\n"}, {"name": "recarray.trace()", "path": "reference/generated/numpy.recarray.trace", "type": "numpy.recarray.trace", "text": "\nmethod\n\n"}, {"name": "recarray.transpose()", "path": "reference/generated/numpy.recarray.transpose", "type": "numpy.recarray.transpose", "text": "\nmethod\n\n"}, {"name": "recarray.var()", "path": "reference/generated/numpy.recarray.var", "type": "numpy.recarray.var", "text": "\nmethod\n\n"}, {"name": "recarray.view()", "path": "reference/generated/numpy.recarray.view", "type": "numpy.recarray.view", "text": "\nmethod\n\n"}, {"name": "record.all()", "path": "reference/generated/numpy.record.all", "type": "numpy.record.all", "text": "\nmethod\n\n"}, {"name": "record.any()", "path": "reference/generated/numpy.record.any", "type": "numpy.record.any", "text": "\nmethod\n\n"}, {"name": "record.argmax()", "path": "reference/generated/numpy.record.argmax", "type": "numpy.record.argmax", "text": "\nmethod\n\n"}, {"name": "record.argmin()", "path": "reference/generated/numpy.record.argmin", "type": "numpy.record.argmin", "text": "\nmethod\n\n"}, {"name": "record.argsort()", "path": "reference/generated/numpy.record.argsort", "type": "numpy.record.argsort", "text": "\nmethod\n\n"}, {"name": "record.astype()", "path": "reference/generated/numpy.record.astype", "type": "numpy.record.astype", "text": "\nmethod\n\n"}, {"name": "record.base", "path": "reference/generated/numpy.record.base", "type": "Standard array subclasses", "text": "\nattribute\n\n"}, {"name": "record.byteswap()", "path": "reference/generated/numpy.record.byteswap", "type": "numpy.record.byteswap", "text": "\nmethod\n\n"}, {"name": "record.choose()", "path": "reference/generated/numpy.record.choose", "type": "numpy.record.choose", "text": "\nmethod\n\n"}, {"name": "record.clip()", "path": "reference/generated/numpy.record.clip", "type": "numpy.record.clip", "text": "\nmethod\n\n"}, {"name": "record.compress()", "path": "reference/generated/numpy.record.compress", "type": "numpy.record.compress", "text": "\nmethod\n\n"}, {"name": "record.conjugate()", "path": "reference/generated/numpy.record.conjugate", "type": "numpy.record.conjugate", "text": "\nmethod\n\n"}, {"name": "record.copy()", "path": "reference/generated/numpy.record.copy", "type": "numpy.record.copy", "text": "\nmethod\n\n"}, {"name": "record.cumprod()", "path": "reference/generated/numpy.record.cumprod", "type": "numpy.record.cumprod", "text": "\nmethod\n\n"}, {"name": "record.cumsum()", "path": "reference/generated/numpy.record.cumsum", "type": "numpy.record.cumsum", "text": "\nmethod\n\n"}, {"name": "record.data", "path": "reference/generated/numpy.record.data", "type": "Standard array subclasses", "text": "\nattribute\n\n"}, {"name": "record.diagonal()", "path": "reference/generated/numpy.record.diagonal", "type": "numpy.record.diagonal", "text": "\nmethod\n\n"}, {"name": "record.dump()", "path": "reference/generated/numpy.record.dump", "type": "numpy.record.dump", "text": "\nmethod\n\n"}, {"name": "record.dumps()", "path": "reference/generated/numpy.record.dumps", "type": "numpy.record.dumps", "text": "\nmethod\n\n"}, {"name": "record.fill()", "path": "reference/generated/numpy.record.fill", "type": "numpy.record.fill", "text": "\nmethod\n\n"}, {"name": "record.flags", "path": "reference/generated/numpy.record.flags", "type": "Standard array subclasses", "text": "\nattribute\n\n"}, {"name": "record.flat", "path": "reference/generated/numpy.record.flat", "type": "Standard array subclasses", "text": "\nattribute\n\n"}, {"name": "record.flatten()", "path": "reference/generated/numpy.record.flatten", "type": "numpy.record.flatten", "text": "\nmethod\n\n"}, {"name": "record.getfield()", "path": "reference/generated/numpy.record.getfield", "type": "numpy.record.getfield", "text": "\nmethod\n\n"}, {"name": "record.item()", "path": "reference/generated/numpy.record.item", "type": "numpy.record.item", "text": "\nmethod\n\n"}, {"name": "record.itemset()", "path": "reference/generated/numpy.record.itemset", "type": "numpy.record.itemset", "text": "\nmethod\n\n"}, {"name": "record.itemsize", "path": "reference/generated/numpy.record.itemsize", "type": "Standard array subclasses", "text": "\nattribute\n\n"}, {"name": "record.max()", "path": "reference/generated/numpy.record.max", "type": "numpy.record.max", "text": "\nmethod\n\n"}, {"name": "record.mean()", "path": "reference/generated/numpy.record.mean", "type": "numpy.record.mean", "text": "\nmethod\n\n"}, {"name": "record.min()", "path": "reference/generated/numpy.record.min", "type": "numpy.record.min", "text": "\nmethod\n\n"}, {"name": "record.nbytes", "path": "reference/generated/numpy.record.nbytes", "type": "Standard array subclasses", "text": "\nattribute\n\n"}, {"name": "record.ndim", "path": "reference/generated/numpy.record.ndim", "type": "Standard array subclasses", "text": "\nattribute\n\n"}, {"name": "record.newbyteorder()", "path": "reference/generated/numpy.record.newbyteorder", "type": "numpy.record.newbyteorder", "text": "\nmethod\n\n"}, {"name": "record.nonzero()", "path": "reference/generated/numpy.record.nonzero", "type": "numpy.record.nonzero", "text": "\nmethod\n\n"}, {"name": "record.pprint()", "path": "reference/generated/numpy.record.pprint", "type": "numpy.record.pprint", "text": "\nmethod\n\n"}, {"name": "record.prod()", "path": "reference/generated/numpy.record.prod", "type": "numpy.record.prod", "text": "\nmethod\n\n"}, {"name": "record.ptp()", "path": "reference/generated/numpy.record.ptp", "type": "numpy.record.ptp", "text": "\nmethod\n\n"}, {"name": "record.put()", "path": "reference/generated/numpy.record.put", "type": "numpy.record.put", "text": "\nmethod\n\n"}, {"name": "record.ravel()", "path": "reference/generated/numpy.record.ravel", "type": "numpy.record.ravel", "text": "\nmethod\n\n"}, {"name": "record.repeat()", "path": "reference/generated/numpy.record.repeat", "type": "numpy.record.repeat", "text": "\nmethod\n\n"}, {"name": "record.reshape()", "path": "reference/generated/numpy.record.reshape", "type": "numpy.record.reshape", "text": "\nmethod\n\n"}, {"name": "record.resize()", "path": "reference/generated/numpy.record.resize", "type": "numpy.record.resize", "text": "\nmethod\n\n"}, {"name": "record.round()", "path": "reference/generated/numpy.record.round", "type": "numpy.record.round", "text": "\nmethod\n\n"}, {"name": "record.searchsorted()", "path": "reference/generated/numpy.record.searchsorted", "type": "numpy.record.searchsorted", "text": "\nmethod\n\n"}, {"name": "record.setfield()", "path": "reference/generated/numpy.record.setfield", "type": "numpy.record.setfield", "text": "\nmethod\n\n"}, {"name": "record.setflags()", "path": "reference/generated/numpy.record.setflags", "type": "numpy.record.setflags", "text": "\nmethod\n\n"}, {"name": "record.size", "path": "reference/generated/numpy.record.size", "type": "Standard array subclasses", "text": "\nattribute\n\n"}, {"name": "record.sort()", "path": "reference/generated/numpy.record.sort", "type": "numpy.record.sort", "text": "\nmethod\n\n"}, {"name": "record.squeeze()", "path": "reference/generated/numpy.record.squeeze", "type": "numpy.record.squeeze", "text": "\nmethod\n\n"}, {"name": "record.std()", "path": "reference/generated/numpy.record.std", "type": "numpy.record.std", "text": "\nmethod\n\n"}, {"name": "record.strides", "path": "reference/generated/numpy.record.strides", "type": "Standard array subclasses", "text": "\nattribute\n\n"}, {"name": "record.sum()", "path": "reference/generated/numpy.record.sum", "type": "numpy.record.sum", "text": "\nmethod\n\n"}, {"name": "record.swapaxes()", "path": "reference/generated/numpy.record.swapaxes", "type": "numpy.record.swapaxes", "text": "\nmethod\n\n"}, {"name": "record.T", "path": "reference/generated/numpy.record.t", "type": "Standard array subclasses", "text": "\nattribute\n\n"}, {"name": "record.take()", "path": "reference/generated/numpy.record.take", "type": "numpy.record.take", "text": "\nmethod\n\n"}, {"name": "record.tofile()", "path": "reference/generated/numpy.record.tofile", "type": "numpy.record.tofile", "text": "\nmethod\n\n"}, {"name": "record.tolist()", "path": "reference/generated/numpy.record.tolist", "type": "numpy.record.tolist", "text": "\nmethod\n\n"}, {"name": "record.tostring()", "path": "reference/generated/numpy.record.tostring", "type": "numpy.record.tostring", "text": "\nmethod\n\n"}, {"name": "record.trace()", "path": "reference/generated/numpy.record.trace", "type": "numpy.record.trace", "text": "\nmethod\n\n"}, {"name": "record.transpose()", "path": "reference/generated/numpy.record.transpose", "type": "numpy.record.transpose", "text": "\nmethod\n\n"}, {"name": "record.var()", "path": "reference/generated/numpy.record.var", "type": "numpy.record.var", "text": "\nmethod\n\n"}, {"name": "record.view()", "path": "reference/generated/numpy.record.view", "type": "numpy.record.view", "text": "\nmethod\n\n"}, {"name": "Release", "path": "reference/index", "type": "API reference", "text": "\n1.22\n\n"}, {"name": "Release notes", "path": "release", "type": "Release notes", "text": "\n\n"}, {"name": "Releasing a version", "path": "dev/releasing", "type": "Development", "text": "\nThis file gives an overview of what is necessary to build binary releases for\nNumPy.\n\n"}, {"name": "Reporting bugs", "path": "bugs", "type": "Reporting bugs", "text": "\nFile bug reports or feature requests, and make contributions (e.g. code\npatches), by opening a \u201cnew issue\u201d on GitHub:\n\n"}, {"name": "Routines", "path": "reference/routines", "type": "Routines", "text": "\nIn this chapter routine docstrings are presented, grouped by functionality.\nMany docstrings contain example code, which demonstrates basic usage of the\nroutine. The examples assume that NumPy is imported with:\n\n"}, {"name": "self.typeStr", "path": "reference/swig.testing", "type": "Testing the numpy.i Typemaps", "text": "\nWriting tests for the `numpy.i` SWIG interface file is a combinatorial\nheadache. At present, 12 different data types are supported, each with 74\ndifferent argument signatures, for a total of 888 typemaps supported \u201cout of\nthe box\u201d. Each of these typemaps, in turn, might require several unit tests in\norder to verify expected behavior for both proper and improper inputs.\nCurrently, this results in more than 1,000 individual unit tests executed when\n`make test` is run in the `numpy/tools/swig` subdirectory.\n\n"}, {"name": "Set routines", "path": "reference/routines.set", "type": "Set routines", "text": "\n`lib.arraysetops`\n\n"}, {"name": "Setting up and using your development environment", "path": "dev/development_environment", "type": "Development", "text": "\nSince NumPy contains parts written in C and Cython that need to be compiled\nbefore use, make sure you have the necessary compilers and Python development\nheaders installed - see Building from source. Building NumPy as of version\n`1.17` requires a C99 compliant compiler.\n\n"}, {"name": "Setting up git for NumPy development", "path": "dev/gitwash/development_setup", "type": "Development", "text": "\nTo contribute code or documentation, you first need\n\n"}, {"name": "setup.py", "path": "reference/random/examples/cython/setup.py", "type": "Cython", "text": "\n\n"}, {"name": "Some cases where uint and true alignment are different ()", "path": "dev/alignment", "type": "Development", "text": "\nThere are three use-cases related to memory alignment in NumPy (as of 1.14):\n\n"}, {"name": "Sorting, searching, and counting", "path": "reference/routines.sort", "type": "Sorting, searching, and counting", "text": "\n`sort`(a[, axis, kind, order])\n\n"}, {"name": "static distutils.ccompiler_opt.CCompilerOpt.dist_error()", "path": "reference/generated/numpy.distutils.ccompiler_opt.ccompileropt.dist_error", "type": "numpy.distutils.ccompiler_opt.CCompilerOpt.dist_error", "text": "\nmethod\n\n"}, {"name": "static distutils.ccompiler_opt.CCompilerOpt.dist_fatal()", "path": "reference/generated/numpy.distutils.ccompiler_opt.ccompileropt.dist_fatal", "type": "numpy.distutils.ccompiler_opt.CCompilerOpt.dist_fatal", "text": "\nmethod\n\n"}, {"name": "static distutils.ccompiler_opt.CCompilerOpt.dist_load_module()", "path": "reference/generated/numpy.distutils.ccompiler_opt.ccompileropt.dist_load_module", "type": "numpy.distutils.ccompiler_opt.CCompilerOpt.dist_load_module", "text": "\nmethod\n\n"}, {"name": "static distutils.ccompiler_opt.CCompilerOpt.dist_log()", "path": "reference/generated/numpy.distutils.ccompiler_opt.ccompileropt.dist_log", "type": "numpy.distutils.ccompiler_opt.CCompilerOpt.dist_log", "text": "\nmethod\n\n"}, {"name": "static distutils.ccompiler_opt.CCompilerOpt.me()", "path": "reference/generated/numpy.distutils.ccompiler_opt.ccompileropt.me", "type": "numpy.distutils.ccompiler_opt.CCompilerOpt.me", "text": "\nmethod\n\n"}, {"name": "static ma.MaskedArray.__new__()", "path": "reference/generated/numpy.ma.maskedarray.__new__", "type": "Masked arrays", "text": "\nmethod\n\n"}, {"name": "Statistics", "path": "reference/routines.statistics", "type": "Statistics", "text": "\n`ptp`(a[, axis, out, keepdims])\n\n"}, {"name": "String operations", "path": "reference/routines.char", "type": "String operations", "text": "\nThe `numpy.char` module provides a set of vectorized string operations for\narrays of type `numpy.str_` or `numpy.bytes_`. All of them are based on the\nstring methods in the Python standard library.\n\n"}, {"name": "Subclassing ndarray", "path": "user/basics.subclassing", "type": "User Guide", "text": "\nSubclassing ndarray is relatively simple, but it has some complications\ncompared to other Python objects. On this page we explain the machinery that\nallows you to subclass ndarray, and the implications for implementing a\nsubclass.\n\n"}, {"name": "template<typename Tp, std::size_t N>class DoxyLimbo", "path": "dev/howto-docs#_CPPv4I0_NSt6size_tEE9DoxyLimbo", "type": "Development", "text": "\nTemplate to represent limbo numbers.\n\n"}, {"name": "Test Support (numpy.testing)", "path": "reference/routines.testing", "type": "Test Support ( \n      \n       numpy.testing\n      \n      )", "text": "\nCommon test support for all numpy test scripts.\n\n"}, {"name": "testing.assert_allclose()", "path": "reference/generated/numpy.testing.assert_allclose", "type": "numpy.testing.assert_allclose", "text": "\nRaises an AssertionError if two objects are not equal up to desired tolerance.\n\n"}, {"name": "testing.assert_almost_equal()", "path": "reference/generated/numpy.testing.assert_almost_equal", "type": "numpy.testing.assert_almost_equal", "text": "\nRaises an AssertionError if two items are not equal up to desired precision.\n\n"}, {"name": "testing.assert_approx_equal()", "path": "reference/generated/numpy.testing.assert_approx_equal", "type": "numpy.testing.assert_approx_equal", "text": "\nRaises an AssertionError if two items are not equal up to significant digits.\n\n"}, {"name": "testing.assert_array_almost_equal()", "path": "reference/generated/numpy.testing.assert_array_almost_equal", "type": "numpy.testing.assert_array_almost_equal", "text": "\nRaises an AssertionError if two objects are not equal up to desired precision.\n\n"}, {"name": "testing.assert_array_almost_equal_nulp()", "path": "reference/generated/numpy.testing.assert_array_almost_equal_nulp", "type": "numpy.testing.assert_array_almost_equal_nulp", "text": "\nCompare two arrays relatively to their spacing.\n\n"}, {"name": "testing.assert_array_equal()", "path": "reference/generated/numpy.testing.assert_array_equal", "type": "numpy.testing.assert_array_equal", "text": "\nRaises an AssertionError if two array_like objects are not equal.\n\n"}, {"name": "testing.assert_array_less()", "path": "reference/generated/numpy.testing.assert_array_less", "type": "numpy.testing.assert_array_less", "text": "\nRaises an AssertionError if two array_like objects are not ordered by less\nthan.\n\n"}, {"name": "testing.assert_array_max_ulp()", "path": "reference/generated/numpy.testing.assert_array_max_ulp", "type": "numpy.testing.assert_array_max_ulp", "text": "\nCheck that all items of arrays differ in at most N Units in the Last Place.\n\n"}, {"name": "testing.assert_equal()", "path": "reference/generated/numpy.testing.assert_equal", "type": "numpy.testing.assert_equal", "text": "\nRaises an AssertionError if two objects are not equal.\n\n"}, {"name": "testing.assert_raises()", "path": "reference/generated/numpy.testing.assert_raises", "type": "numpy.testing.assert_raises", "text": "\nFail unless an exception of class exception_class is thrown by callable when\ninvoked with arguments args and keyword arguments kwargs. If a different type\nof exception is thrown, it will not be caught, and the test case will be\ndeemed to have suffered an error, exactly as for an unexpected exception.\n\n"}, {"name": "testing.assert_raises_regex()", "path": "reference/generated/numpy.testing.assert_raises_regex", "type": "numpy.testing.assert_raises_regex", "text": "\nFail unless an exception of class exception_class and with message that\nmatches expected_regexp is thrown by callable when invoked with arguments args\nand keyword arguments kwargs.\n\n"}, {"name": "testing.assert_string_equal()", "path": "reference/generated/numpy.testing.assert_string_equal", "type": "numpy.testing.assert_string_equal", "text": "\nTest if two strings are equal.\n\n"}, {"name": "testing.assert_warns()", "path": "reference/generated/numpy.testing.assert_warns", "type": "numpy.testing.assert_warns", "text": "\nFail unless the given callable throws the specified warning.\n\n"}, {"name": "testing.dec.deprecated()", "path": "reference/generated/numpy.testing.dec.deprecated", "type": "numpy.testing.dec.deprecated", "text": "\nDeprecated since version 1.21: This decorator is retained for compatibility\nwith the nose testing framework, which is being phased out. Please use the\nnose2 or pytest frameworks instead.\n\n"}, {"name": "testing.dec.knownfailureif()", "path": "reference/generated/numpy.testing.dec.knownfailureif", "type": "numpy.testing.dec.knownfailureif", "text": "\nDeprecated since version 1.21: This decorator is retained for compatibility\nwith the nose testing framework, which is being phased out. Please use the\nnose2 or pytest frameworks instead.\n\n"}, {"name": "testing.dec.setastest()", "path": "reference/generated/numpy.testing.dec.setastest", "type": "numpy.testing.dec.setastest", "text": "\nDeprecated since version 1.21: This decorator is retained for compatibility\nwith the nose testing framework, which is being phased out. Please use the\nnose2 or pytest frameworks instead.\n\n"}, {"name": "testing.dec.skipif()", "path": "reference/generated/numpy.testing.dec.skipif", "type": "numpy.testing.dec.skipif", "text": "\nDeprecated since version 1.21: This decorator is retained for compatibility\nwith the nose testing framework, which is being phased out. Please use the\nnose2 or pytest frameworks instead.\n\n"}, {"name": "testing.dec.slow()", "path": "reference/generated/numpy.testing.dec.slow", "type": "numpy.testing.dec.slow", "text": "\nDeprecated since version 1.21: This decorator is retained for compatibility\nwith the nose testing framework, which is being phased out. Please use the\nnose2 or pytest frameworks instead.\n\n"}, {"name": "testing.decorate_methods()", "path": "reference/generated/numpy.testing.decorate_methods", "type": "numpy.testing.decorate_methods", "text": "\nApply a decorator to all methods in a class matching a regular expression.\n\n"}, {"name": "testing.run_module_suite()", "path": "reference/generated/numpy.testing.run_module_suite", "type": "numpy.testing.run_module_suite", "text": "\nRun a test module.\n\n"}, {"name": "testing.rundocs()", "path": "reference/generated/numpy.testing.rundocs", "type": "numpy.testing.rundocs", "text": "\nRun doctests found in the given file.\n\n"}, {"name": "testing.suppress_warnings.__call__()", "path": "reference/generated/numpy.testing.suppress_warnings.__call__", "type": "numpy.testing.suppress_warnings.__call__", "text": "\nmethod\n\n"}, {"name": "testing.suppress_warnings.filter()", "path": "reference/generated/numpy.testing.suppress_warnings.filter", "type": "numpy.testing.suppress_warnings.filter", "text": "\nmethod\n\n"}, {"name": "testing.suppress_warnings.record()", "path": "reference/generated/numpy.testing.suppress_warnings.record", "type": "numpy.testing.suppress_warnings.record", "text": "\nmethod\n\n"}, {"name": "The N-dimensional array (ndarray)", "path": "reference/arrays.ndarray", "type": "The N-dimensional array ( \n      \n       ndarray\n      \n      )", "text": "\nAn `ndarray` is a (usually fixed-size) multidimensional container of items of\nthe same type and size. The number of dimensions and items in an array is\ndefined by its `shape`, which is a `tuple` of N non-negative integers that\nspecify the sizes of each dimension. The type of items in the array is\nspecified by a separate data-type object (dtype), one of which is associated\nwith each ndarray.\n\n"}, {"name": "The numpy.ma module", "path": "reference/maskedarray.generic", "type": "The \n        \n         numpy.ma\n        \n        module", "text": "\nMasked arrays are arrays that may have missing or invalid entries. The\n`numpy.ma` module provides a nearly work-alike replacement for numpy that\nsupports data arrays with masks.\n\n"}, {"name": "Three ways to wrap - getting started", "path": "f2py/f2py.getting-started", "type": "Three ways to wrap - getting started", "text": "\nWrapping Fortran or C functions to Python using F2PY consists of the following\nsteps:\n\n"}, {"name": "Two and three dots in difference specs", "path": "dev/gitwash/dot2_dot3", "type": "Development", "text": "\nThanks to Yarik Halchenko for this explanation.\n\n"}, {"name": "type binomial_t", "path": "reference/random/c-api#c.binomial_t", "type": "C API for random", "text": "\n\n"}, {"name": "type bitgen_t", "path": "reference/random/c-api", "type": "C API for random", "text": "\nNew in version 1.19.0.\n\n"}, {"name": "type NPY_AO", "path": "reference/c-api/types-and-structures#c.NPY_AO", "type": "Python Types and C-Structures", "text": "\nThe `PyArrayObject` C-structure contains all of the required information for\nan array. All instances of an ndarray (and its subclasses) will have this\nstructure. For future compatibility, these structure members should normally\nbe accessed using the provided macros. If you need a shorter name, then you\ncan make use of `NPY_AO` (deprecated) which is defined to be equivalent to\n`PyArrayObject`. Direct access to the struct fields are deprecated. Use the\n`PyArray_*(arr)` form instead. As of NumPy 1.20, the size of this struct is\nnot considered part of the NumPy ABI (see note at the end of the member list).\n\n"}, {"name": "type npy_cdouble", "path": "reference/c-api/dtype#c.npy_cdouble", "type": "Data Type API", "text": "\n64-bit complex double\n\n"}, {"name": "type npy_cfloat", "path": "reference/c-api/dtype#c.npy_cfloat", "type": "Data Type API", "text": "\n32-bit complex float\n\n"}, {"name": "type npy_clongdouble", "path": "reference/c-api/dtype#c.npy_clongdouble", "type": "Data Type API", "text": "\nlong complex double\n\n"}, {"name": "type npy_double", "path": "reference/c-api/dtype#c.npy_double", "type": "Data Type API", "text": "\n64-bit double\n\n"}, {"name": "type npy_float", "path": "reference/c-api/dtype#c.npy_float", "type": "Data Type API", "text": "\n32-bit float\n\n"}, {"name": "type npy_hash_t", "path": "reference/c-api/types-and-structures#c.NPY_USE_SETITEM.npy_hash_t", "type": "Python Types and C-Structures", "text": "\n\n"}, {"name": "type npy_int", "path": "reference/c-api/dtype#c.npy_int", "type": "Data Type API", "text": "\nint\n\n"}, {"name": "type npy_int16", "path": "reference/c-api/dtype#c.npy_int16", "type": "Data Type API", "text": "\n16-bit integer\n\n"}, {"name": "type npy_int32", "path": "reference/c-api/dtype#c.npy_int32", "type": "Data Type API", "text": "\n32-bit integer\n\n"}, {"name": "type npy_int64", "path": "reference/c-api/dtype#c.npy_int64", "type": "Data Type API", "text": "\n64-bit integer\n\n"}, {"name": "type npy_intp", "path": "reference/c-api/dtype#c.npy_intp", "type": "Data Type API", "text": "\nPy_intptr_t (an integer that is the size of a pointer on the platform).\n\n"}, {"name": "type npy_long", "path": "reference/c-api/dtype#c.npy_long", "type": "Data Type API", "text": "\nlong int\n\n"}, {"name": "type npy_longdouble", "path": "reference/c-api/dtype#c.npy_longdouble", "type": "Data Type API", "text": "\nlong double\n\n"}, {"name": "type npy_longlong", "path": "reference/c-api/dtype#c.npy_longlong", "type": "Data Type API", "text": "\nlong long int\n\n"}, {"name": "type npy_short", "path": "reference/c-api/dtype#c.npy_short", "type": "Data Type API", "text": "\nshort\n\n"}, {"name": "type npy_ubyte", "path": "reference/c-api/dtype#c.npy_ubyte", "type": "Data Type API", "text": "\nunsigned char\n\n"}, {"name": "type npy_uint", "path": "reference/c-api/dtype#c.npy_uint", "type": "Data Type API", "text": "\nunsigned int\n\n"}, {"name": "type npy_uint16", "path": "reference/c-api/dtype#c.npy_uint16", "type": "Data Type API", "text": "\n16-bit unsigned integer\n\n"}, {"name": "type npy_uint32", "path": "reference/c-api/dtype#c.npy_uint32", "type": "Data Type API", "text": "\n32-bit unsigned integer\n\n"}, {"name": "type npy_uint64", "path": "reference/c-api/dtype#c.npy_uint64", "type": "Data Type API", "text": "\n64-bit unsigned integer\n\n"}, {"name": "type npy_uintp", "path": "reference/c-api/dtype#c.npy_uintp", "type": "Data Type API", "text": "\nunsigned Py_intptr_t (an integer that is the size of a pointer on the\nplatform).\n\n"}, {"name": "type npy_ulong", "path": "reference/c-api/dtype#c.npy_ulong", "type": "Data Type API", "text": "\nunsigned long int\n\n"}, {"name": "type npy_ulonglong", "path": "reference/c-api/dtype#c.npy_ulonglong", "type": "Data Type API", "text": "\nunsigned long long int\n\n"}, {"name": "type npy_ushort", "path": "reference/c-api/dtype#c.npy_ushort", "type": "Data Type API", "text": "\nunsigned short\n\n"}, {"name": "type NpyAuxData_CloneFunc", "path": "reference/c-api/array#c.NpyAuxData_CloneFunc", "type": "Array API", "text": "\nThe function pointer type for NpyAuxData clone functions. These functions\nshould never set the Python exception on error, because they may be called\nfrom a multi-threaded context.\n\n"}, {"name": "type NpyAuxData_FreeFunc", "path": "reference/c-api/array#c.NpyAuxData_FreeFunc", "type": "Array API", "text": "\nThe function pointer type for NpyAuxData free functions.\n\n"}, {"name": "type NpyIter", "path": "reference/c-api/iterator", "type": "Array Iterator API", "text": "\nNew in version 1.6.\n\n"}, {"name": "type NpyIter_GetMultiIndexFunc", "path": "reference/c-api/iterator#c.NpyIter_GetMultiIndexFunc", "type": "Array Iterator API", "text": "\nThis is a function pointer for getting the current iterator multi-index,\nreturned by `NpyIter_GetGetMultiIndex`.\n\n"}, {"name": "type NpyIter_IterNextFunc", "path": "reference/c-api/iterator#c.NpyIter_IterNextFunc", "type": "Array Iterator API", "text": "\nThis is a function pointer for the iteration loop, returned by\n`NpyIter_GetIterNext`.\n\n"}, {"name": "type NpyIter_Type", "path": "reference/c-api/iterator#c.NpyIter_Type", "type": "Array Iterator API", "text": "\nThis is the type which exposes the iterator to Python. Currently, no API is\nexposed which provides access to the values of a Python-created iterator. If\nan iterator is created in Python, it must be used in Python and vice versa.\nSuch an API will likely be created in a future version.\n\n"}, {"name": "type PyArray_ArrFuncs", "path": "reference/c-api/types-and-structures#c.PyArray_ArrFuncs", "type": "Python Types and C-Structures", "text": "\nFunctions implementing internal features. Not all of these function pointers\nmust be defined for a given type. The required members are `nonzero`,\n`copyswap`, `copyswapn`, `setitem`, `getitem`, and `cast`. These are assumed\nto be non- `NULL` and `NULL` entries will cause a program crash. The other\nfunctions may be `NULL` which will just mean reduced functionality for that\ndata-type. (Also, the nonzero function will be filled in with a default\nfunction if it is `NULL` when you register a user-defined data-type).\n\n"}, {"name": "type PyArray_Descr", "path": "reference/c-api/types-and-structures#c.PyArray_Descr", "type": "Python Types and C-Structures", "text": "\nThe `PyArray_Descr` structure lies at the heart of the `PyArrayDescr_Type`.\nWhile it is described here for completeness, it should be considered internal\nto NumPy and manipulated via `PyArrayDescr_*` or `PyDataType*` functions and\nmacros. The size of this structure is subject to change across versions of\nNumPy. To ensure compatibility:\n\n"}, {"name": "type PyArrayFlagsObject", "path": "reference/c-api/types-and-structures#c.PyArrayFlagsObject", "type": "Python Types and C-Structures", "text": "\n\n"}, {"name": "type PyArrayIterObject", "path": "reference/c-api/types-and-structures#c.PyArrayIterObject", "type": "Python Types and C-Structures", "text": "\nThe C-structure corresponding to an object of `PyArrayIter_Type` is the\n`PyArrayIterObject`. The `PyArrayIterObject` is used to keep track of a\npointer into an N-dimensional array. It contains associated information used\nto quickly march through the array. The pointer can be adjusted in three basic\nways: 1) advance to the \u201cnext\u201d position in the array in a C-style contiguous\nfashion, 2) advance to an arbitrary N-dimensional coordinate in the array, and\n3) advance to an arbitrary one-dimensional index into the array. The members\nof the `PyArrayIterObject` structure are used in these calculations. Iterator\nobjects keep their own dimension and strides information about an array. This\ncan be adjusted as needed for \u201cbroadcasting,\u201d or to loop over only specific\ndimensions.\n\n"}, {"name": "type PyArrayMultiIterObject", "path": "reference/c-api/types-and-structures#c.PyArrayMultiIterObject", "type": "Python Types and C-Structures", "text": "\nThe number of arrays that need to be broadcast to the same shape.\n\n"}, {"name": "type PyArrayNeighborhoodIterObject", "path": "reference/c-api/types-and-structures#c.PyArrayNeighborhoodIterObject", "type": "Python Types and C-Structures", "text": "\nThe C-structure corresponding to an object of `PyArrayNeighborhoodIter_Type`\nis the `PyArrayNeighborhoodIterObject`.\n\n"}, {"name": "type PyArrayObject", "path": "reference/c-api/types-and-structures#c.PyArrayObject", "type": "Python Types and C-Structures", "text": "\nThe `PyArrayObject` C-structure contains all of the required information for\nan array. All instances of an ndarray (and its subclasses) will have this\nstructure. For future compatibility, these structure members should normally\nbe accessed using the provided macros. If you need a shorter name, then you\ncan make use of `NPY_AO` (deprecated) which is defined to be equivalent to\n`PyArrayObject`. Direct access to the struct fields are deprecated. Use the\n`PyArray_*(arr)` form instead. As of NumPy 1.20, the size of this struct is\nnot considered part of the NumPy ABI (see note at the end of the member list).\n\n"}, {"name": "type PyDataMem_Handler", "path": "reference/c-api/data_memory", "type": "Memory management in NumPy", "text": "\nThe `numpy.ndarray` is a python class. It requires additional memory\nallocations to hold `numpy.ndarray.strides`, `numpy.ndarray.shape` and\n`numpy.ndarray.data` attributes. These attributes are specially allocated\nafter creating the python object in `__new__`. The `strides` and `shape` are\nstored in a piece of memory allocated internally.\n\n"}, {"name": "type PyUFunc_Loop1d", "path": "reference/c-api/types-and-structures#c.PyUFunc_Loop1d", "type": "Python Types and C-Structures", "text": "\nA simple linked-list of C-structures containing the information needed to\ndefine a 1-d loop for a ufunc for every defined signature of a user-defined\ndata-type.\n\n"}, {"name": "type PyUFuncObject", "path": "reference/c-api/types-and-structures#c.PyUFuncObject", "type": "Python Types and C-Structures", "text": "\nThe core of the ufunc is the `PyUFuncObject` which contains all the\ninformation needed to call the underlying C-code loops that perform the actual\nwork. While it is described here for completeness, it should be considered\ninternal to NumPy and manipulated via `PyUFunc_*` functions. The size of this\nstructure is subject to change across versions of NumPy. To ensure\ncompatibility:\n\n"}, {"name": "type PyUFuncReduceObject", "path": "reference/c-api/types-and-structures#c.PyUFuncReduceObject", "type": "Python Types and C-Structures", "text": "\nA loose wrapper for the C-structure that contains the information needed for\nreduce-like methods of ufuncs. This is useful if you are trying to understand\nthe reduce, accumulate, and reduce-at code. The `PyUFuncReduceObject` is the\nassociated C-structure. It is defined in the `ufuncobject.h` header.\n\n"}, {"name": "ufunc.__call__()", "path": "reference/generated/numpy.ufunc.__call__", "type": "numpy.ufunc.__call__", "text": "\nmethod\n\n"}, {"name": "ufunc.accumulate()", "path": "reference/generated/numpy.ufunc.accumulate", "type": "numpy.ufunc.accumulate", "text": "\nmethod\n\n"}, {"name": "ufunc.at()", "path": "reference/generated/numpy.ufunc.at", "type": "numpy.ufunc.at", "text": "\nmethod\n\n"}, {"name": "ufunc.identity", "path": "reference/generated/numpy.ufunc.identity", "type": "numpy.ufunc.identity", "text": "\nattribute\n\n"}, {"name": "ufunc.nargs", "path": "reference/generated/numpy.ufunc.nargs", "type": "numpy.ufunc.nargs", "text": "\nattribute\n\n"}, {"name": "ufunc.nin", "path": "reference/generated/numpy.ufunc.nin", "type": "numpy.ufunc.nin", "text": "\nattribute\n\n"}, {"name": "ufunc.nout", "path": "reference/generated/numpy.ufunc.nout", "type": "numpy.ufunc.nout", "text": "\nattribute\n\n"}, {"name": "ufunc.ntypes", "path": "reference/generated/numpy.ufunc.ntypes", "type": "numpy.ufunc.ntypes", "text": "\nattribute\n\n"}, {"name": "ufunc.outer()", "path": "reference/generated/numpy.ufunc.outer", "type": "numpy.ufunc.outer", "text": "\nmethod\n\n"}, {"name": "ufunc.reduce()", "path": "reference/generated/numpy.ufunc.reduce", "type": "numpy.ufunc.reduce", "text": "\nmethod\n\n"}, {"name": "ufunc.reduceat()", "path": "reference/generated/numpy.ufunc.reduceat", "type": "numpy.ufunc.reduceat", "text": "\nmethod\n\n"}, {"name": "ufunc.signature", "path": "reference/generated/numpy.ufunc.signature", "type": "numpy.ufunc.signature", "text": "\nattribute\n\n"}, {"name": "ufunc.types", "path": "reference/generated/numpy.ufunc.types", "type": "numpy.ufunc.types", "text": "\nattribute\n\n"}, {"name": "UFUNC_CORE_DIM_CAN_IGNORE", "path": "reference/c-api/types-and-structures#c.UFUNC_CORE_DIM_CAN_IGNORE", "type": "Python Types and C-Structures", "text": "\nif the dim name ends in `?`\n\n"}, {"name": "UFUNC_CORE_DIM_SIZE_INFERRED", "path": "reference/c-api/types-and-structures#c.UFUNC_CORE_DIM_SIZE_INFERRED", "type": "Python Types and C-Structures", "text": "\nif the dim size will be determined from the operands and not from a frozen\nsignature\n\n"}, {"name": "UFUNC_ERR_CALL", "path": "reference/c-api/ufunc#c.UFUNC_ERR_CALL", "type": "UFunc API", "text": "\n\n"}, {"name": "UFUNC_ERR_RAISE", "path": "reference/c-api/ufunc#c.UFUNC_ERR_RAISE", "type": "UFunc API", "text": "\n\n"}, {"name": "UFUNC_ERR_WARN", "path": "reference/c-api/ufunc#c.UFUNC_ERR_WARN", "type": "UFunc API", "text": "\n\n"}, {"name": "UFUNC_ERR_{HANDLER}", "path": "reference/c-api/ufunc", "type": "UFunc API", "text": "\nUsed in universal function code to only release the Python GIL if loop->obj is\nnot true (i.e. this is not an OBJECT array loop). Requires use of\n`NPY_BEGIN_THREADS_DEF` in variable declaration area.\n\n"}, {"name": "UFUNC_FPE_DIVIDEBYZERO", "path": "reference/c-api/ufunc#c.UFUNC_FPE_DIVIDEBYZERO", "type": "UFunc API", "text": "\n\n"}, {"name": "UFUNC_FPE_INVALID", "path": "reference/c-api/ufunc#c.UFUNC_FPE_INVALID", "type": "UFunc API", "text": "\n\n"}, {"name": "UFUNC_FPE_OVERFLOW", "path": "reference/c-api/ufunc#c.UFUNC_FPE_OVERFLOW", "type": "UFunc API", "text": "\n\n"}, {"name": "UFUNC_FPE_UNDERFLOW", "path": "reference/c-api/ufunc#c.UFUNC_FPE_UNDERFLOW", "type": "UFunc API", "text": "\n\n"}, {"name": "UFUNC_MASK_INVALID", "path": "reference/c-api/ufunc#c.UFUNC_MASK_INVALID", "type": "UFunc API", "text": "\n\n"}, {"name": "UFUNC_MASK_OVERFLOW", "path": "reference/c-api/ufunc#c.UFUNC_MASK_OVERFLOW", "type": "UFunc API", "text": "\n\n"}, {"name": "UFUNC_MASK_UNDERFLOW", "path": "reference/c-api/ufunc#c.UFUNC_MASK_UNDERFLOW", "type": "UFunc API", "text": "\n\n"}, {"name": "UFUNC_SHIFT_DIVIDEBYZERO", "path": "reference/c-api/ufunc#c.UFUNC_SHIFT_DIVIDEBYZERO", "type": "UFunc API", "text": "\n\n"}, {"name": "UFUNC_SHIFT_INVALID", "path": "reference/c-api/ufunc#c.UFUNC_SHIFT_INVALID", "type": "UFunc API", "text": "\n\n"}, {"name": "UFUNC_SHIFT_OVERFLOW", "path": "reference/c-api/ufunc#c.UFUNC_SHIFT_OVERFLOW", "type": "UFunc API", "text": "\n\n"}, {"name": "UFUNC_SHIFT_UNDERFLOW", "path": "reference/c-api/ufunc#c.UFUNC_SHIFT_UNDERFLOW", "type": "UFunc API", "text": "\n\n"}, {"name": "Under-the-hood Documentation for developers", "path": "dev/underthehood", "type": "Development", "text": "\nThese documents are intended as a low-level look into NumPy; focused towards\ndevelopers.\n\n"}, {"name": "Universal functions (ufunc)", "path": "reference/ufuncs", "type": "Universal functions ( \n    \n     ufunc\n    \n    )", "text": "\nSee also\n\n"}, {"name": "Universal functions (ufunc) basics", "path": "user/basics.ufuncs", "type": "User Guide", "text": "\nSee also\n\n"}, {"name": "unsigned int PyArray_GetNDArrayCFeatureVersion()", "path": "reference/c-api/array#c.PyArray_GetNDArrayCFeatureVersion", "type": "Array API", "text": "\nNew in version 1.4.0.\n\n"}, {"name": "unsigned int PyArray_GetNDArrayCVersion()", "path": "reference/c-api/array#c.PyArray_GetNDArrayCVersion", "type": "Array API", "text": "\nThis just returns the value `NPY_VERSION`. `NPY_VERSION` changes whenever a\nbackward incompatible change at the ABI level. Because it is in the C-API,\nhowever, comparing the output of this function from the value defined in the\ncurrent header gives a way to test if the C-API has changed thus requiring a\nre-compilation of extension modules that use the C-API. This is automatically\nchecked in the function `import_array`.\n\n"}, {"name": "Upgrading PCG64 with PCG64DXSM", "path": "reference/random/upgrading-pcg64", "type": "Upgrading PCG64 with PCG64DXSM", "text": "\nUses of the `PCG64` `BitGenerator` in a massively-parallel context have been\nshown to have statistical weaknesses that were not apparent at the first\nrelease in numpy 1.17. Most users will never observe this weakness and are\nsafe to continue to use `PCG64`. We have introduced a new `PCG64DXSM`\n`BitGenerator` that will eventually become the new default `BitGenerator`\nimplementation used by `default_rng` in future releases. `PCG64DXSM` solves\nthe statistical weakness while preserving the performance and the features of\n`PCG64`.\n\n"}, {"name": "Using F2PY bindings in Python", "path": "f2py/python-usage", "type": "Using F2PY bindings in Python", "text": "\nAll wrappers for Fortran/C routines, common blocks, or for Fortran 90 module\ndata generated by F2PY are exposed to Python as `fortran` type objects.\nRoutine wrappers are callable `fortran` type objects while wrappers to Fortran\ndata have attributes referring to data objects.\n\n"}, {"name": "Using Gitpod for NumPy development", "path": "dev/development_gitpod", "type": "Development", "text": "\nThis section of the documentation will guide you through:\n\n"}, {"name": "Using NumPy C-API", "path": "user/c-info", "type": "User Guide", "text": "\n\n"}, {"name": "Using the Convenience Classes", "path": "reference/routines.polynomials.classes", "type": "Using the Convenience Classes", "text": "\nThe convenience classes provided by the polynomial package are:\n\n"}, {"name": "Using via cmake", "path": "f2py/buildtools/cmake", "type": "Using via \n        \n         cmake", "text": "\nIn terms of complexity, `cmake` falls between `make` and `meson`. The learning\ncurve is steeper since CMake syntax is not pythonic and is closer to `make`\nwith environment variables.\n\n"}, {"name": "Using via meson", "path": "f2py/buildtools/meson", "type": "Using via \n        \n         meson", "text": "\nThe key advantage gained by leveraging `meson` over the techniques described\nin Using via numpy.distutils is that this feeds into existing systems and\nlarger projects with ease. `meson` has a rather pythonic syntax which makes it\nmore comfortable and amenable to extension for `python` users.\n\n"}, {"name": "Using via scikit-build", "path": "f2py/buildtools/skbuild", "type": "Using via \n        \n         scikit-build", "text": "\n`scikit-build` provides two separate concepts geared towards the users of\nPython extension modules.\n\n"}, {"name": "vectorize.__call__()", "path": "reference/generated/numpy.vectorize.__call__", "type": "numpy.vectorize.__call__", "text": "\nmethod\n\n"}, {"name": "version", "path": "reference/arrays.interface", "type": "The Array Interface", "text": "\nNote\n\n"}, {"name": "void **data", "path": "reference/c-api/types-and-structures#c.PyUFuncObject.data", "type": "Python Types and C-Structures", "text": "\nExtra data to be passed to the 1-d vector loops or `NULL` if no extra-data is\nneeded. This C-array must be the same size ( i.e. ntypes) as the functions\narray. `NULL` is used if extra_data is not needed. Several C-API calls for\nUFuncs are just 1-d vector loops that make use of this extra data to receive a\npointer to the actual function to call.\n\n"}, {"name": "void *data", "path": "reference/c-api/types-and-structures#c.PyArrayInterface.data", "type": "Python Types and C-Structures", "text": "\nA pointer to the first element of the array.\n\n"}, {"name": "void *ptr", "path": "reference/c-api/types-and-structures#c.PyUFuncObject.ptr", "type": "Python Types and C-Structures", "text": "\nAny dynamically allocated memory. Currently, this is used for dynamic ufuncs\ncreated from a python function to store room for the types, data, and name\nmembers.\n\n"}, {"name": "void *ptr", "path": "reference/c-api/types-and-structures#c.PyArray_Chunk.ptr", "type": "Python Types and C-Structures", "text": "\nA pointer to the start of the single-segment chunk of memory.\n\n"}, {"name": "void *PyArray_DATA()", "path": "reference/c-api/array#c.PyArray_DATA", "type": "Array API", "text": "\n\n"}, {"name": "void *PyArray_GETPTR1()", "path": "reference/c-api/array#c.PyArray_GETPTR1", "type": "Array API", "text": "\n\n"}, {"name": "void *PyArray_GETPTR2()", "path": "reference/c-api/array#c.PyArray_GETPTR2", "type": "Array API", "text": "\n\n"}, {"name": "void *PyArray_GETPTR3()", "path": "reference/c-api/array#c.PyArray_GETPTR3", "type": "Array API", "text": "\n\n"}, {"name": "void *PyArray_GETPTR4()", "path": "reference/c-api/array#c.PyArray_GETPTR4", "type": "Array API", "text": "\nQuick, inline access to the element at the given coordinates in the ndarray,\nobj, which must have respectively 1, 2, 3, or 4 dimensions (this is not\nchecked). The corresponding i, j, k, and l coordinates can be any integer but\nwill be interpreted as `npy_intp`. You may want to typecast the returned\npointer to the data type of the ndarray.\n\n"}, {"name": "void *PyArray_ITER_DATA()", "path": "reference/c-api/array#c.PyArray_ITER_DATA", "type": "Array API", "text": "\nA pointer to the current element of the array.\n\n"}, {"name": "void *PyArray_malloc()", "path": "reference/c-api/array#c.PyArray_malloc", "type": "Array API", "text": "\n\n"}, {"name": "void *PyArray_MultiIter_DATA()", "path": "reference/c-api/array#c.PyArray_MultiIter_DATA", "type": "Array API", "text": "\nReturn the data-pointer of the i \\\\(^{\\textrm{th}}\\\\) iterator in a multi-\niterator object.\n\n"}, {"name": "void *PyArray_realloc()", "path": "reference/c-api/array#c.PyArray_realloc", "type": "Array API", "text": "\nThese macros use different memory allocators, depending on the constant\n`NPY_USE_PYMEM`. The system malloc is used when `NPY_USE_PYMEM` is 0, if\n`NPY_USE_PYMEM` is 1, then the Python memory allocator is used.\n\n"}, {"name": "void *reserved2", "path": "reference/c-api/types-and-structures#c.PyUFuncObject.reserved2", "type": "Python Types and C-Structures", "text": "\nFor a possible future loop selector with a different signature.\n\n"}, {"name": "void castfunc()", "path": "user/c-info.beyond-basics", "type": "User Guide", "text": "\nOne common algorithmic requirement is to be able to walk over all elements in\na multidimensional array. The array iterator object makes this easy to do in a\ngeneric way that works for arrays of any dimension. Naturally, if you know the\nnumber of dimensions you will be using, then you can always write nested for\nloops to accomplish the iteration. If, however, you want to write code that\nworks with any number of dimensions, then you can make use of the array\niterator. An array iterator object is returned when accessing the .flat\nattribute of an array.\n\n"}, {"name": "void copyswap()", "path": "reference/c-api/types-and-structures#c.PyArray_ArrFuncs.copyswap", "type": "Python Types and C-Structures", "text": "\nThese members are both pointers to functions to copy data from src to dest and\nswap if indicated. The value of arr is only used for flexible ( `NPY_STRING`,\n`NPY_UNICODE`, and `NPY_VOID` ) arrays (and is obtained from\n`arr->descr->elsize` ). The second function copies a single value, while the\nfirst loops over n values with the provided strides. These functions can deal\nwith misbehaved src data. If src is NULL then no copy is performed. If swap is\n0, then no byteswapping occurs. It is assumed that dest and src do not\noverlap. If they overlap, then use `memmove` (\u2026) first followed by\n`copyswap(n)` with NULL valued `src`.\n\n"}, {"name": "void copyswapn()", "path": "reference/c-api/types-and-structures#c.PyArray_ArrFuncs.copyswapn", "type": "Python Types and C-Structures", "text": "\n\n"}, {"name": "void dotfunc()", "path": "reference/c-api/types-and-structures#c.PyArray_ArrFuncs.dotfunc", "type": "Python Types and C-Structures", "text": "\nA pointer to a function that multiplies two `n` -length sequences together,\nadds them, and places the result in element pointed to by `op` of `arr`. The\nstart of the two sequences are pointed to by `ip1` and `ip2`. To get to the\nnext element in each sequence requires a jump of `is1` and `is2` bytes,\nrespectively. This function requires behaved (though not necessarily\ncontiguous) memory.\n\n"}, {"name": "void fastclip()", "path": "reference/c-api/types-and-structures#c.PyArray_ArrFuncs.fastclip", "type": "Python Types and C-Structures", "text": "\nDeprecated since version 1.17: The use of this function will give a\ndeprecation warning when `np.clip`. Instead of this function, the datatype\nmust instead use `PyUFunc_RegisterLoopForDescr` to attach a custom loop to\n`np.core.umath.clip`, `np.minimum`, and `np.maximum`.\n\n"}, {"name": "void fastputmask()", "path": "reference/c-api/types-and-structures#c.PyArray_ArrFuncs.fastputmask", "type": "Python Types and C-Structures", "text": "\nDeprecated since version 1.19: Setting this function is deprecated and should\nalways be `NULL`, if set, it will be ignored.\n\n"}, {"name": "void fasttake()", "path": "reference/c-api/types-and-structures#c.PyArray_ArrFuncs.fasttake", "type": "Python Types and C-Structures", "text": "\nDeprecated since version 1.19: Setting this function is deprecated and should\nalways be `NULL`, if set, it will be ignored.\n\n"}, {"name": "void fill()", "path": "reference/c-api/types-and-structures#c.PyArray_ArrFuncs.fill", "type": "Python Types and C-Structures", "text": "\nA pointer to a function that fills a contiguous array of given length with\ndata. The first two elements of the array must already be filled- in. From\nthese two values, a delta will be computed and the values from item 3 to the\nend will be computed by repeatedly adding this computed delta. The data buffer\nmust be well-behaved.\n\n"}, {"name": "void fillwithscalar()", "path": "reference/c-api/types-and-structures#c.PyArray_ArrFuncs.fillwithscalar", "type": "Python Types and C-Structures", "text": "\nA pointer to a function that fills a contiguous `buffer` of the given `length`\nwith a single scalar `value` whose address is given. The final argument is the\narray which is needed to get the itemsize for variable-length arrays.\n\n"}, {"name": "void functions()", "path": "reference/c-api/types-and-structures#c.PyUFuncObject.functions", "type": "Python Types and C-Structures", "text": "\nAn array of function pointers \u2014 one for each data type supported by the ufunc.\nThis is the vector loop that is called to implement the underlying function\ndims [0] times. The first argument, args, is an array of nargs pointers to\nbehaved memory. Pointers to the data for the input arguments are first,\nfollowed by the pointers to the data for the output arguments. How many bytes\nmust be skipped to get to the next element in the sequence is specified by the\ncorresponding entry in the steps array. The last argument allows the loop to\nreceive extra information. This is commonly used so that a single, generic\nvector loop can be used for multiple functions. In this case, the actual\nscalar function to call is passed in as extradata. The size of this function\npointer array is ntypes.\n\n"}, {"name": "void import_ufunc()", "path": "reference/c-api/ufunc#c.import_ufunc", "type": "UFunc API", "text": "\nThese are the constants and functions for accessing the ufunc C-API from\nextension modules in precisely the same way as the array C-API can be\naccessed. The `import_ufunc` () function must always be called (in the\ninitialization subroutine of the extension module). If your extension module\nis in one file then that is all that is required. The other two constants are\nuseful if your extension module makes use of multiple files. In that case,\ndefine `PY_UFUNC_UNIQUE_SYMBOL` to something unique to your code and then in\nsource files that do not contain the module initialization function but still\nneed access to the UFUNC API, define `PY_UFUNC_UNIQUE_SYMBOL` to the same name\nused previously and also define `NO_IMPORT_UFUNC`.\n\n"}, {"name": "void NPY_AUXDATA_FREE()", "path": "reference/c-api/array#c.NPY_AUXDATA_FREE", "type": "Array API", "text": "\nA macro which calls the auxdata\u2019s free function appropriately, does nothing if\nauxdata is NULL.\n\n"}, {"name": "void NPY_BEGIN_THREADS_DESCR()", "path": "reference/c-api/array#c.NPY_BEGIN_THREADS_DESCR", "type": "Array API", "text": "\nUseful to release the GIL only if dtype does not contain arbitrary Python\nobjects which may need the Python interpreter during execution of the loop.\n\n"}, {"name": "void NPY_BEGIN_THREADS_THRESHOLDED()", "path": "reference/c-api/array#c.NPY_BEGIN_THREADS_THRESHOLDED", "type": "Array API", "text": "\nUseful to release the GIL only if loop_size exceeds a minimum threshold,\ncurrently set to 500. Should be matched with a `NPY_END_THREADS` to regain the\nGIL.\n\n"}, {"name": "void NPY_END_THREADS_DESCR()", "path": "reference/c-api/array#c.NPY_END_THREADS_DESCR", "type": "Array API", "text": "\nUseful to regain the GIL in situations where it was released using the BEGIN\nform of this macro.\n\n"}, {"name": "void npy_set_floatstatus_divbyzero()", "path": "reference/c-api/coremath#c.npy_set_floatstatus_divbyzero", "type": "NumPy core libraries", "text": "\nSet the divide by zero floating point exception\n\n"}, {"name": "void npy_set_floatstatus_invalid()", "path": "reference/c-api/coremath#c.npy_set_floatstatus_invalid", "type": "NumPy core libraries", "text": "\nSet the invalid floating point exception\n\n"}, {"name": "void npy_set_floatstatus_overflow()", "path": "reference/c-api/coremath#c.npy_set_floatstatus_overflow", "type": "NumPy core libraries", "text": "\nSet the overflow floating point exception\n\n"}, {"name": "void npy_set_floatstatus_underflow()", "path": "reference/c-api/coremath#c.npy_set_floatstatus_underflow", "type": "NumPy core libraries", "text": "\nSet the underflow floating point exception\n\n"}, {"name": "void NpyIter_GetInnerFixedStrideArray()", "path": "reference/c-api/iterator#c.NpyIter_GetInnerFixedStrideArray", "type": "Array Iterator API", "text": "\nGets an array of strides which are fixed, or will not change during the entire\niteration. For strides that may change, the value NPY_MAX_INTP is placed in\nthe stride.\n\n"}, {"name": "void NpyIter_GetIterIndexRange()", "path": "reference/c-api/iterator#c.NpyIter_GetIterIndexRange", "type": "Array Iterator API", "text": "\nGets the `iterindex` sub-range that is being iterated. If `NPY_ITER_RANGED`\nwas not specified, this always returns the range `[0,\nNpyIter_IterSize(iter))`.\n\n"}, {"name": "void NpyIter_GetReadFlags()", "path": "reference/c-api/iterator#c.NpyIter_GetReadFlags", "type": "Array Iterator API", "text": "\nFills `nop` flags. Sets `outreadflags[i]` to 1 if `op[i]` can be read from,\nand to 0 if not.\n\n"}, {"name": "void NpyIter_GetWriteFlags()", "path": "reference/c-api/iterator#c.NpyIter_GetWriteFlags", "type": "Array Iterator API", "text": "\nFills `nop` flags. Sets `outwriteflags[i]` to 1 if `op[i]` can be written to,\nand to 0 if not.\n\n"}, {"name": "void PyArray_ArrayType()", "path": "reference/c-api/array#c.PyArray_ArrayType", "type": "Array API", "text": "\nThis function is superseded by `PyArray_ResultType`.\n\n"}, {"name": "void PyArray_CastScalarToCtype()", "path": "reference/c-api/array#c.PyArray_CastScalarToCtype", "type": "Array API", "text": "\nReturn the data (cast to the data type indicated by outcode) from the array-\nscalar, scalar, into the memory pointed to by ctypeptr (which must be large\nenough to handle the incoming memory).\n\n"}, {"name": "void PyArray_CLEARFLAGS()", "path": "reference/c-api/array#c.PyArray_CLEARFLAGS", "type": "Array API", "text": "\nNew in version 1.7.\n\n"}, {"name": "void PyArray_DiscardWritebackIfCopy()", "path": "reference/c-api/array#c.PyArray_DiscardWritebackIfCopy", "type": "Array API", "text": "\nIf `obj.flags` has `NPY_ARRAY_WRITEBACKIFCOPY` or (deprecated)\n`NPY_ARRAY_UPDATEIFCOPY`, this function clears the flags, `DECREF` s\n`obj->base` and makes it writeable, and sets `obj->base` to NULL. In contrast\nto `PyArray_DiscardWritebackIfCopy` it makes no attempt to copy the data from\n`obj->base` This undoes `PyArray_SetWritebackIfCopyBase`. Usually this is\ncalled after an error when you are finished with `obj`, just before\n`Py_DECREF(obj)`. It may be called multiple times, or with `NULL` input.\n\n"}, {"name": "void PyArray_ENABLEFLAGS()", "path": "reference/c-api/array#c.PyArray_ENABLEFLAGS", "type": "Array API", "text": "\nNew in version 1.7.\n\n"}, {"name": "void PyArray_FillObjectArray()", "path": "reference/c-api/array#c.PyArray_FillObjectArray", "type": "Array API", "text": "\nFill a newly created array with a single value obj at all locations in the\nstructure with object data-types. No checking is performed but arr must be of\ndata-type `NPY_OBJECT` and be single-segment and uninitialized (no previous\nobjects in position). Use `PyArray_XDECREF` (arr) if you need to decrement all\nthe items in the object array prior to calling this function.\n\n"}, {"name": "void PyArray_FILLWBYTE()", "path": "reference/c-api/array#c.PyArray_FILLWBYTE", "type": "Array API", "text": "\nFill the array pointed to by obj \u2014which must be a (subclass of) ndarray\u2014with\nthe contents of val (evaluated as a byte). This macro calls memset, so obj\nmust be contiguous.\n\n"}, {"name": "void PyArray_free()", "path": "reference/c-api/array#c.PyArray_free", "type": "Array API", "text": "\n\n"}, {"name": "void PyArray_Item_INCREF()", "path": "reference/c-api/array#c.PyArray_Item_INCREF", "type": "Array API", "text": "\nA function to INCREF all the objects at the location ptr according to the\ndata-type dtype. If ptr is the start of a structured type with an object at\nany offset, then this will (recursively) increment the reference count of all\nobject-like items in the structured type.\n\n"}, {"name": "void PyArray_Item_XDECREF()", "path": "reference/c-api/array#c.PyArray_Item_XDECREF", "type": "Array API", "text": "\nA function to XDECREF all the object-like items at the location ptr as\nrecorded in the data-type, dtype. This works recursively so that if `dtype`\nitself has fields with data-types that contain object-like items, all the\nobject-like fields will be XDECREF `'d`.\n\n"}, {"name": "void PyArray_ITER_GOTO()", "path": "reference/c-api/array#c.PyArray_ITER_GOTO", "type": "Array API", "text": "\nSet the iterator index, dataptr, and coordinates members to the location in\nthe array indicated by the N-dimensional c-array, destination, which must have\nsize at least iterator ->nd_m1+1.\n\n"}, {"name": "void PyArray_ITER_GOTO1D()", "path": "reference/c-api/array#c.PyArray_ITER_GOTO1D", "type": "Array API", "text": "\nSet the iterator index and dataptr to the location in the array indicated by\nthe integer index which points to an element in the C-styled flattened array.\n\n"}, {"name": "void PyArray_ITER_NEXT()", "path": "reference/c-api/array#c.PyArray_ITER_NEXT", "type": "Array API", "text": "\nIncremement the index and the dataptr members of the iterator to point to the\nnext element of the array. If the array is not (C-style) contiguous, also\nincrement the N-dimensional coordinates array.\n\n"}, {"name": "void PyArray_ITER_RESET()", "path": "reference/c-api/array#c.PyArray_ITER_RESET", "type": "Array API", "text": "\nReset an iterator to the beginning of the array.\n\n"}, {"name": "void PyArray_MapIterNext()", "path": "reference/c-api/array#c.PyArray_MapIterNext", "type": "Array API", "text": "\nThis function needs to update the state of the map iterator and point\n`mit->dataptr` to the memory-location of the next object.\n\n"}, {"name": "void PyArray_MapIterSwapAxes()", "path": "reference/c-api/array#c.PyArray_MapIterSwapAxes", "type": "Array API", "text": "\nSwap the axes to or from their inserted form. `MapIter` always puts the\nadvanced (array) indices first in the iteration. But if they are consecutive,\nit will insert/transpose them back before returning. This is stored as\n`mit->consec != 0` (the place where they are inserted). For assignments, the\nopposite happens: the values to be assigned are transposed (`getmap=1` instead\nof `getmap=0`). `getmap=0` and `getmap=1` undo the other operation.\n\n"}, {"name": "void PyArray_MultiIter_GOTO()", "path": "reference/c-api/array#c.PyArray_MultiIter_GOTO", "type": "Array API", "text": "\nAdvance each iterator in a multi-iterator object, multi, to the given \\\\(N\\\\)\n-dimensional destination where \\\\(N\\\\) is the number of dimensions in the\nbroadcasted array.\n\n"}, {"name": "void PyArray_MultiIter_GOTO1D()", "path": "reference/c-api/array#c.PyArray_MultiIter_GOTO1D", "type": "Array API", "text": "\nAdvance each iterator in a multi-iterator object, multi, to the corresponding\nlocation of the index into the flattened broadcasted array.\n\n"}, {"name": "void PyArray_MultiIter_NEXT()", "path": "reference/c-api/array#c.PyArray_MultiIter_NEXT", "type": "Array API", "text": "\nAdvance each iterator in a multi-iterator object, multi, to its next\n(broadcasted) element.\n\n"}, {"name": "void PyArray_MultiIter_NEXTi()", "path": "reference/c-api/array#c.PyArray_MultiIter_NEXTi", "type": "Array API", "text": "\nAdvance the pointer of only the i \\\\(^{\\textrm{th}}\\\\) iterator.\n\n"}, {"name": "void PyArray_MultiIter_RESET()", "path": "reference/c-api/array#c.PyArray_MultiIter_RESET", "type": "Array API", "text": "\nReset all the iterators to the beginning in a multi-iterator object, multi.\n\n"}, {"name": "void PyArray_ScalarAsCtype()", "path": "reference/c-api/array#c.PyArray_ScalarAsCtype", "type": "Array API", "text": "\nReturn in ctypeptr a pointer to the actual value in an array scalar. There is\nno error checking so scalar must be an array-scalar object, and ctypeptr must\nhave enough space to hold the correct type. For flexible-sized types, a\npointer to the data is copied into the memory of ctypeptr, for all other\ntypes, the actual data is copied into the address pointed to by ctypeptr.\n\n"}, {"name": "void PyArray_SetStringFunction()", "path": "reference/c-api/array#c.PyArray_SetStringFunction", "type": "Array API", "text": "\nThis function allows you to alter the tp_str and tp_repr methods of the array\nobject to any Python function. Thus you can alter what happens for all arrays\nwhen str(arr) or repr(arr) is called from Python. The function to be called is\npassed in as op. If repr is non-zero, then this function will be called in\nresponse to repr(arr), otherwise the function will be called in response to\nstr(arr). No check on whether or not op is callable is performed. The callable\npassed in to op should expect an array argument and should return a string to\nbe printed.\n\n"}, {"name": "void PyArray_UpdateFlags()", "path": "reference/c-api/array#c.PyArray_UpdateFlags", "type": "Array API", "text": "\nThe `NPY_ARRAY_C_CONTIGUOUS`, `NPY_ARRAY_ALIGNED`, and\n`NPY_ARRAY_F_CONTIGUOUS` array flags can be \u201ccalculated\u201d from the array object\nitself. This routine updates one or more of these flags of arr as specified in\nflagmask by performing the required calculation.\n\n"}, {"name": "void PyArray_XDECREF_ERR()", "path": "reference/c-api/array#c.PyArray_XDECREF_ERR", "type": "Array API", "text": "\nDeprecated in 1.14, use `PyArray_DiscardWritebackIfCopy` followed by\n`Py_XDECREF`\n\n"}, {"name": "void PyDataMem_EventHookFunc()", "path": "reference/c-api/data_memory#c.PyDataMem_EventHookFunc", "type": "Memory management in NumPy", "text": "\nThis function will be called during data memory manipulation\n\n"}, {"name": "void PyDataMem_FREE()", "path": "reference/c-api/array#c.PyDataMem_FREE", "type": "Array API", "text": "\n\n"}, {"name": "void PyDimMem_FREE()", "path": "reference/c-api/array#c.PyDimMem_FREE", "type": "Array API", "text": "\n\n"}, {"name": "void PyUFunc_clearfperr()", "path": "reference/c-api/ufunc#c.PyUFunc_clearfperr", "type": "UFunc API", "text": "\nClear the IEEE error flags.\n\n"}, {"name": "void PyUFunc_d_d()", "path": "reference/c-api/ufunc#c.PyUFunc_d_d", "type": "UFunc API", "text": "\n\n"}, {"name": "void PyUFunc_D_D()", "path": "reference/c-api/ufunc#c.PyUFunc_D_D", "type": "UFunc API", "text": "\n\n"}, {"name": "void PyUFunc_DD_D()", "path": "reference/c-api/ufunc#c.PyUFunc_DD_D", "type": "UFunc API", "text": "\n\n"}, {"name": "void PyUFunc_dd_d()", "path": "reference/c-api/ufunc#c.PyUFunc_dd_d", "type": "UFunc API", "text": "\n\n"}, {"name": "void PyUFunc_e_e()", "path": "reference/c-api/ufunc#c.PyUFunc_e_e", "type": "UFunc API", "text": "\n\n"}, {"name": "void PyUFunc_e_e_As_d_d()", "path": "reference/c-api/ufunc#c.PyUFunc_e_e_As_d_d", "type": "UFunc API", "text": "\nType specific, core 1-d functions for ufuncs where each calculation is\nobtained by calling a function taking one input argument and returning one\noutput. This function is passed in `func`. The letters correspond to\ndtypechar\u2019s of the supported data types ( `e` \\- half, `f` \\- float, `d` \\-\ndouble, `g` \\- long double, `F` \\- cfloat, `D` \\- cdouble, `G` \\-\nclongdouble). The argument func must support the same signature. The _As_X_X\nvariants assume ndarray\u2019s of one data type but cast the values to use an\nunderlying function that takes a different data type. Thus,\n`PyUFunc_f_f_As_d_d` uses ndarrays of data type `NPY_FLOAT` but calls out to a\nC-function that takes double and returns double.\n\n"}, {"name": "void PyUFunc_e_e_As_f_f()", "path": "reference/c-api/ufunc#c.PyUFunc_e_e_As_f_f", "type": "UFunc API", "text": "\n\n"}, {"name": "void PyUFunc_ee_e()", "path": "reference/c-api/ufunc#c.PyUFunc_ee_e", "type": "UFunc API", "text": "\n\n"}, {"name": "void PyUFunc_ee_e_As_dd_d()", "path": "reference/c-api/ufunc#c.PyUFunc_ee_e_As_dd_d", "type": "UFunc API", "text": "\nType specific, core 1-d functions for ufuncs where each calculation is\nobtained by calling a function taking two input arguments and returning one\noutput. The underlying function to call is passed in as func. The letters\ncorrespond to dtypechar\u2019s of the specific data type supported by the general-\npurpose function. The argument `func` must support the corresponding\nsignature. The `_As_XX_X` variants assume ndarrays of one data type but cast\nthe values at each iteration of the loop to use the underlying function that\ntakes a different data type.\n\n"}, {"name": "void PyUFunc_ee_e_As_ff_f()", "path": "reference/c-api/ufunc#c.PyUFunc_ee_e_As_ff_f", "type": "UFunc API", "text": "\n\n"}, {"name": "void PyUFunc_F_F()", "path": "reference/c-api/ufunc#c.PyUFunc_F_F", "type": "UFunc API", "text": "\n\n"}, {"name": "void PyUFunc_f_f()", "path": "reference/c-api/ufunc#c.PyUFunc_f_f", "type": "UFunc API", "text": "\n\n"}, {"name": "void PyUFunc_F_F_As_D_D()", "path": "reference/c-api/ufunc#c.PyUFunc_F_F_As_D_D", "type": "UFunc API", "text": "\n\n"}, {"name": "void PyUFunc_ff_f()", "path": "reference/c-api/ufunc#c.PyUFunc_ff_f", "type": "UFunc API", "text": "\n\n"}, {"name": "void PyUFunc_FF_F()", "path": "reference/c-api/ufunc#c.PyUFunc_FF_F", "type": "UFunc API", "text": "\n\n"}, {"name": "void PyUFunc_ff_f_As_dd_d()", "path": "reference/c-api/ufunc#c.PyUFunc_ff_f_As_dd_d", "type": "UFunc API", "text": "\n\n"}, {"name": "void PyUFunc_FF_F_As_DD_D()", "path": "reference/c-api/ufunc#c.PyUFunc_FF_F_As_DD_D", "type": "UFunc API", "text": "\n\n"}, {"name": "void PyUFunc_g_g()", "path": "reference/c-api/ufunc#c.PyUFunc_g_g", "type": "UFunc API", "text": "\n\n"}, {"name": "void PyUFunc_G_G()", "path": "reference/c-api/ufunc#c.PyUFunc_G_G", "type": "UFunc API", "text": "\n\n"}, {"name": "void PyUFunc_GetPyValues()", "path": "reference/c-api/ufunc#c.PyUFunc_GetPyValues", "type": "UFunc API", "text": "\nGet the Python values used for ufunc processing from the thread-local storage\narea unless the defaults have been set in which case the name lookup is\nbypassed. The name is placed as a string in the first element of *errobj. The\nsecond element is the looked-up function to call on error callback. The value\nof the looked-up buffer-size to use is passed into bufsize, and the value of\nthe error mask is placed into errmask.\n\n"}, {"name": "void PyUFunc_gg_g()", "path": "reference/c-api/ufunc#c.PyUFunc_gg_g", "type": "UFunc API", "text": "\n\n"}, {"name": "void PyUFunc_GG_G()", "path": "reference/c-api/ufunc#c.PyUFunc_GG_G", "type": "UFunc API", "text": "\n\n"}, {"name": "void PyUFunc_O_O()", "path": "reference/c-api/ufunc#c.PyUFunc_O_O", "type": "UFunc API", "text": "\n\n"}, {"name": "void PyUFunc_O_O_method()", "path": "reference/c-api/ufunc#c.PyUFunc_O_O_method", "type": "UFunc API", "text": "\nThis general purpose 1-d core function assumes that func is a string\nrepresenting a method of the input object. For each iteration of the loop, the\nPython object is extracted from the array and its func method is called\nreturning the result to the output array.\n\n"}, {"name": "void PyUFunc_On_Om()", "path": "reference/c-api/ufunc#c.PyUFunc_On_Om", "type": "UFunc API", "text": "\nThis is the 1-d core function used by the dynamic ufuncs created by\numath.frompyfunc(function, nin, nout). In this case func is a pointer to a\n`PyUFunc_PyFuncData` structure which has definition\n\n"}, {"name": "void PyUFunc_OO_O()", "path": "reference/c-api/ufunc#c.PyUFunc_OO_O", "type": "UFunc API", "text": "\nOne-input, one-output, and two-input, one-output core 1-d functions for the\n`NPY_OBJECT` data type. These functions handle reference count issues and\nreturn early on error. The actual function to call is func and it must accept\ncalls with the signature `(PyObject*) (PyObject*)` for `PyUFunc_O_O` or\n`(PyObject*)(PyObject *, PyObject *)` for `PyUFunc_OO_O`.\n\n"}, {"name": "void PyUFunc_OO_O_method()", "path": "reference/c-api/ufunc#c.PyUFunc_OO_O_method", "type": "UFunc API", "text": "\nThis general purpose 1-d core function assumes that func is a string\nrepresenting a method of the input object that takes one argument. The first\nargument in args is the method whose function is called, the second argument\nin args is the argument passed to the function. The output of the function is\nstored in the third entry of args.\n\n"}, {"name": "void random_multinomial()", "path": "reference/random/c-api#c.random_multinomial", "type": "C API for random", "text": "\n\n"}, {"name": "void random_multivariate_hypergeometric_marginals()", "path": "reference/random/c-api#c.random_multivariate_hypergeometric_marginals", "type": "C API for random", "text": "\n\n"}, {"name": "void random_standard_exponential_fill()", "path": "reference/random/c-api#c.random_standard_exponential_fill", "type": "C API for random", "text": "\n\n"}, {"name": "void random_standard_exponential_fill_f()", "path": "reference/random/c-api#c.random_standard_exponential_fill_f", "type": "C API for random", "text": "\n\n"}, {"name": "void random_standard_exponential_inv_fill()", "path": "reference/random/c-api#c.random_standard_exponential_inv_fill", "type": "C API for random", "text": "\n\n"}, {"name": "void random_standard_exponential_inv_fill_f()", "path": "reference/random/c-api#c.random_standard_exponential_inv_fill_f", "type": "C API for random", "text": "\n\n"}, {"name": "void random_standard_normal_fill()", "path": "reference/random/c-api#c.random_standard_normal_fill", "type": "C API for random", "text": "\n\n"}, {"name": "void random_standard_normal_fill_f()", "path": "reference/random/c-api#c.random_standard_normal_fill_f", "type": "C API for random", "text": "\n\n"}, {"name": "void random_standard_uniform_fill()", "path": "reference/random/c-api#c.random_standard_uniform_fill", "type": "C API for random", "text": "\n\n"}, {"name": "void random_standard_uniform_fill_f()", "path": "reference/random/c-api#c.random_standard_uniform_fill_f", "type": "C API for random", "text": "\n\n"}, {"name": "What is NumPy?", "path": "user/whatisnumpy", "type": "User Guide", "text": "\nNumPy is the fundamental package for scientific computing in Python. It is a\nPython library that provides a multidimensional array object, various derived\nobjects (such as masked arrays and matrices), and an assortment of routines\nfor fast operations on arrays, including mathematical, logical, shape\nmanipulation, sorting, selecting, I/O, discrete Fourier transforms, basic\nlinear algebra, basic statistical operations, random simulation and much more.\n\n"}, {"name": "What\u2019s New or Different", "path": "reference/random/new-or-different", "type": "What\u2019s New or Different", "text": "\nWarning\n\n"}, {"name": "Window functions", "path": "reference/routines.window", "type": "Window functions", "text": "\n`bartlett`(M)\n\n"}, {"name": "WITH_THREADS", "path": "reference/c-api/array#c.WITH_THREADS", "type": "Array API", "text": "\n\n"}, {"name": "Writing custom array containers", "path": "user/basics.dispatch", "type": "User Guide", "text": "\nNumpy\u2019s dispatch mechanism, introduced in numpy version v1.16 is the\nrecommended approach for writing custom N-dimensional array containers that\nare compatible with the numpy API and provide custom implementations of numpy\nfunctionality. Applications include dask arrays, an N-dimensional array\ndistributed across multiple nodes, and cupy arrays, an N-dimensional array on\na GPU.\n\n"}, {"name": "Writing your own ufunc", "path": "user/c-info.ufunc-tutorial", "type": "User Guide", "text": "\nBefore reading this, it may help to familiarize yourself with the basics of C\nextensions for Python by reading/skimming the tutorials in Section 1 of\nExtending and Embedding the Python Interpreter and in How to extend NumPy\n\n"}, {"name": "\u201cdescr\u201ddtype.descr", "path": "reference/generated/numpy.lib.format", "type": "numpy.lib.format", "text": "\nBinary serialization\n\n"}]