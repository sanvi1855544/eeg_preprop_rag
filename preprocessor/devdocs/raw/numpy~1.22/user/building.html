<h1 id="id1">Building from source</h1> <p>There are two options for building NumPy- building with Gitpod or locally from source. Your choice depends on your operating system and familiarity with the command line.</p> <section id="gitpod"> <h2>Gitpod</h2> <p>Gitpod is an open-source platform that automatically creates the correct development environment right in your browser, reducing the need to install local development environments and deal with incompatible dependencies.</p> <p>If you are a Windows user, unfamiliar with using the command line or building NumPy for the first time, it is often faster to build with Gitpod. Here are the in-depth instructions for building NumPy with <a class="reference external" href="https://numpy.org/devdocs/dev/development_gitpod.html">building NumPy with Gitpod</a>.</p> </section> <section id="building-locally"> <h2>Building locally</h2> <p>Building locally on your machine gives you more granular control. If you are a MacOS or Linux user familiar with using the command line, you can continue with building NumPy locally by following the instructions below.</p> </section> <section id="prerequisites"> <h2>Prerequisites</h2> <p>Building NumPy requires the following software installed:</p> <ol class="arabic"> <li>
<p>Python 3.6.x or newer</p> <p>Please note that the Python development headers also need to be installed, e.g., on Debian/Ubuntu one needs to install both <code>python3</code> and <code>python3-dev</code>. On Windows and macOS this is normally not an issue.</p> </li> <li>
<p>Compilers</p> <p>Much of NumPy is written in C. You will need a C compiler that complies with the C99 standard.</p> <p>While a FORTRAN 77 compiler is not necessary for building NumPy, it is needed to run the <code>numpy.f2py</code> tests. These tests are skipped if the compiler is not auto-detected.</p> <p>Note that NumPy is developed mainly using GNU compilers and tested on MSVC and Clang compilers. Compilers from other vendors such as Intel, Absoft, Sun, NAG, Compaq, Vast, Portland, Lahey, HP, IBM are only supported in the form of community feedback, and may not work out of the box. GCC 4.x (and later) compilers are recommended. On ARM64 (aarch64) GCC 8.x (and later) are recommended.</p> </li> <li>
<p>Linear Algebra libraries</p> <p>NumPy does not require any external linear algebra libraries to be installed. However, if these are available, NumPy’s setup script can detect them and use them for building. A number of different LAPACK library setups can be used, including optimized LAPACK libraries such as OpenBLAS or MKL. The choice and location of these libraries as well as include paths and other such build options can be specified in a <code>site.cfg</code> file located in the NumPy root repository or a <code>.numpy-site.cfg</code> file in your home directory. See the <code>site.cfg.example</code> example file included in the NumPy repository or sdist for documentation, and below for specifying search priority from environmental variables.</p> </li> <li>
<p>Cython</p> <p>For building NumPy, you’ll need a recent version of Cython.</p> </li> </ol> </section> <section id="basic-installation"> <h2>Basic Installation</h2> <p>To install NumPy, run:</p> <pre data-language="python">pip install .
</pre> <p>To perform an in-place build that can be run from the source folder run:</p> <pre data-language="python">python setup.py build_ext --inplace
</pre> <p><em>Note: for build instructions to do development work on NumPy itself, see</em> <a class="reference internal" href="../dev/development_environment#development-environment"><span class="std std-ref">Setting up and using your development environment</span></a>.</p> </section> <section id="testing"> <h2>Testing</h2> <p>Make sure to test your builds. To ensure everything stays in shape, see if all tests pass:</p> <pre data-language="python">$ python runtests.py -v -m full
</pre> <p>For detailed info on testing, see <a class="reference internal" href="../dev/development_environment#testing-builds"><span class="std std-ref">Testing builds</span></a>.</p> <section id="parallel-builds"> <h3 id="id2">Parallel builds</h3> <p>It’s possible to do a parallel build with:</p> <pre data-language="python">python setup.py build -j 4 install --prefix $HOME/.local
</pre> <p>This will compile numpy on 4 CPUs and install it into the specified prefix. to perform a parallel in-place build, run:</p> <pre data-language="python">python setup.py build_ext --inplace -j 4
</pre> <p>The number of build jobs can also be specified via the environment variable <code>NPY_NUM_BUILD_JOBS</code>.</p> </section> <section id="choosing-the-fortran-compiler"> <h3>Choosing the fortran compiler</h3> <p>Compilers are auto-detected; building with a particular compiler can be done with <code>--fcompiler</code>. E.g. to select gfortran:</p> <pre data-language="python">python setup.py build --fcompiler=gnu95
</pre> <p>For more information see:</p> <pre data-language="python">python setup.py build --help-fcompiler
</pre> </section> <section id="how-to-check-the-abi-of-blas-lapack-libraries"> <h3>How to check the ABI of BLAS/LAPACK libraries</h3> <p>One relatively simple and reliable way to check for the compiler used to build a library is to use ldd on the library. If libg2c.so is a dependency, this means that g77 has been used (note: g77 is no longer supported for building NumPy). If libgfortran.so is a dependency, gfortran has been used. If both are dependencies, this means both have been used, which is almost always a very bad idea.</p> </section> </section> <section id="accelerated-blas-lapack-libraries"> <h2 id="id3">Accelerated BLAS/LAPACK libraries</h2> <p>NumPy searches for optimized linear algebra libraries such as BLAS and LAPACK. There are specific orders for searching these libraries, as described below and in the <code>site.cfg.example</code> file.</p> <section id="blas"> <h3>BLAS</h3> <p>Note that both BLAS and CBLAS interfaces are needed for a properly optimized build of NumPy.</p> <p>The default order for the libraries are:</p> <ol class="arabic simple"> <li>MKL</li> <li>BLIS</li> <li>OpenBLAS</li> <li>ATLAS</li> <li>BLAS (NetLIB)</li> </ol> <p>The detection of BLAS libraries may be bypassed by defining the environment variable <code>NPY_BLAS_LIBS</code> , which should contain the exact linker flags you want to use (interface is assumed to be Fortran 77). Also define <code>NPY_CBLAS_LIBS</code> (even empty if CBLAS is contained in your BLAS library) to trigger use of CBLAS and avoid slow fallback code for matrix calculations.</p> <p>If you wish to build against OpenBLAS but you also have BLIS available one may predefine the order of searching via the environment variable <code>NPY_BLAS_ORDER</code> which is a comma-separated list of the above names which is used to determine what to search for, for instance:</p> <pre data-language="python">NPY_BLAS_ORDER=ATLAS,blis,openblas,MKL python setup.py build
</pre> <p>will prefer to use ATLAS, then BLIS, then OpenBLAS and as a last resort MKL. If neither of these exists the build will fail (names are compared lower case).</p> <p>Alternatively one may use <code>!</code> or <code>^</code> to negate all items:</p> <pre data-language="python">NPY_BLAS_ORDER='^blas,atlas' python setup.py build
</pre> <p>will allow using anything <strong>but</strong> NetLIB BLAS and ATLAS libraries, the order of the above list is retained.</p> <p>One cannot mix negation and positives, nor have multiple negations, such cases will raise an error.</p> </section> <section id="lapack"> <h3>LAPACK</h3> <p>The default order for the libraries are:</p> <ol class="arabic simple"> <li>MKL</li> <li>OpenBLAS</li> <li>libFLAME</li> <li>ATLAS</li> <li>LAPACK (NetLIB)</li> </ol> <p>The detection of LAPACK libraries may be bypassed by defining the environment variable <code>NPY_LAPACK_LIBS</code>, which should contain the exact linker flags you want to use (language is assumed to be Fortran 77).</p> <p>If you wish to build against OpenBLAS but you also have MKL available one may predefine the order of searching via the environment variable <code>NPY_LAPACK_ORDER</code> which is a comma-separated list of the above names, for instance:</p> <pre data-language="python">NPY_LAPACK_ORDER=ATLAS,openblas,MKL python setup.py build
</pre> <p>will prefer to use ATLAS, then OpenBLAS and as a last resort MKL. If neither of these exists the build will fail (names are compared lower case).</p> <p>Alternatively one may use <code>!</code> or <code>^</code> to negate all items:</p> <pre data-language="python">NPY_LAPACK_ORDER='^lapack' python setup.py build
</pre> <p>will allow using anything <strong>but</strong> the NetLIB LAPACK library, the order of the above list is retained.</p> <p>One cannot mix negation and positives, nor have multiple negations, such cases will raise an error.</p> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 1.20: </span>The native libraries on macOS, provided by Accelerate, are not fit for use in NumPy since they have bugs that cause wrong output under easily reproducible conditions. If the vendor fixes those bugs, the library could be reinstated, but until then users compiling for themselves should use another linear algebra library or use the built-in (but slower) default, see the next section.</p> </div> </section> <section id="disabling-atlas-and-other-accelerated-libraries"> <h3>Disabling ATLAS and other accelerated libraries</h3> <p>Usage of ATLAS and other accelerated libraries in NumPy can be disabled via:</p> <pre data-language="python">NPY_BLAS_ORDER= NPY_LAPACK_ORDER= python setup.py build
</pre> <p>or:</p> <pre data-language="python">BLAS=None LAPACK=None ATLAS=None python setup.py build
</pre> </section> <section id="bit-blas-and-lapack"> <h3>64-bit BLAS and LAPACK</h3> <p>You can tell Numpy to use 64-bit BLAS/LAPACK libraries by setting the environment variable:</p> <pre data-language="python">NPY_USE_BLAS_ILP64=1
</pre> <p>when building Numpy. The following 64-bit BLAS/LAPACK libraries are supported:</p> <ol class="arabic simple"> <li>OpenBLAS ILP64 with <code>64_</code> symbol suffix (<code>openblas64_</code>)</li> <li>OpenBLAS ILP64 without symbol suffix (<code>openblas_ilp64</code>)</li> </ol> <p>The order in which they are preferred is determined by <code>NPY_BLAS_ILP64_ORDER</code> and <code>NPY_LAPACK_ILP64_ORDER</code> environment variables. The default value is <code>openblas64_,openblas_ilp64</code>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Using non-symbol-suffixed 64-bit BLAS/LAPACK in a program that also uses 32-bit BLAS/LAPACK can cause crashes under certain conditions (e.g. with embedded Python interpreters on Linux).</p> <p>The 64-bit OpenBLAS with <code>64_</code> symbol suffix is obtained by compiling OpenBLAS with settings:</p> <pre data-language="python">make INTERFACE64=1 SYMBOLSUFFIX=64_
</pre> <p>The symbol suffix avoids the symbol name clashes between 32-bit and 64-bit BLAS/LAPACK libraries.</p> </div> </section> </section> <section id="supplying-additional-compiler-flags"> <h2>Supplying additional compiler flags</h2> <p>Additional compiler flags can be supplied by setting the <code>OPT</code>, <code>FOPT</code> (for Fortran), and <code>CC</code> environment variables. When providing options that should improve the performance of the code ensure that you also set <code>-DNDEBUG</code> so that debugging code is not executed.</p> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2021 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/1.22/user/building.html" class="_attribution-link">https://numpy.org/doc/1.22/user/building.html</a>
  </p>
</div>
