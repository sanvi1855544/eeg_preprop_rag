<h1>numpy.arange</h1> <dl class="py function"> <dt class="sig sig-object py" id="numpy.arange"> <span class="sig-prename descclassname">numpy.</span><span class="sig-name descname">arange</span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param">start</em>, <span class="optional">]</span><em class="sig-param">stop</em>, <span class="optional">[</span><em class="sig-param">step</em>, <span class="optional">]</span><em class="sig-param">dtype=None</em>, <em class="sig-param">*</em>, <em class="sig-param">like=None</em><span class="sig-paren">)</span>
</dt> <dd>
<p>Return evenly spaced values within a given interval.</p> <p>Values are generated within the half-open interval <code>[start, stop)</code> (in other words, the interval including <code>start</code> but excluding <code>stop</code>). For integer arguments the function is equivalent to the Python built-in <code>range</code> function, but returns an ndarray rather than a list.</p> <p>When using a non-integer step, such as 0.1, it is often better to use <a class="reference internal" href="numpy.linspace#numpy.linspace" title="numpy.linspace"><code>numpy.linspace</code></a>. See the warnings section below for more information.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<strong>start</strong><span class="classifier">integer or real, optional</span>
</dt>
<dd>
<p>Start of interval. The interval includes this value. The default start value is 0.</p> </dd> <dt>
<strong>stop</strong><span class="classifier">integer or real</span>
</dt>
<dd>
<p>End of interval. The interval does not include this value, except in some cases where <code>step</code> is not an integer and floating point round-off affects the length of <code>out</code>.</p> </dd> <dt>
<strong>step</strong><span class="classifier">integer or real, optional</span>
</dt>
<dd>
<p>Spacing between values. For any output <code>out</code>, this is the distance between two adjacent values, <code>out[i+1] - out[i]</code>. The default step size is 1. If <code>step</code> is specified as a position argument, <code>start</code> must also be given.</p> </dd> <dt>
<strong>dtype</strong><span class="classifier">dtype</span>
</dt>
<dd>
<p>The type of the output array. If <a class="reference internal" href="numpy.dtype#numpy.dtype" title="numpy.dtype"><code>dtype</code></a> is not given, infer the data type from the other input arguments.</p> </dd> <dt>
<strong>like</strong><span class="classifier">array_like</span>
</dt>
<dd>
<p>Reference object to allow the creation of arrays which are not NumPy arrays. If an array-like passed in as <code>like</code> supports the <code>__array_function__</code> protocol, the result will be defined by it. In this case, it ensures the creation of an array object compatible with that passed in via this argument.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.20.0.</span></p> </div> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl> <dt>
<strong>arange</strong><span class="classifier">ndarray</span>
</dt>
<dd>
<p>Array of evenly spaced values.</p> <p>For floating point arguments, the length of the result is <code>ceil((stop - start)/step)</code>. Because of floating point overflow, this rule may result in the last element of <code>out</code> being greater than <code>stop</code>.</p> </dd> </dl> </dd> </dl> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>The length of the output might not be numerically stable.</p> <p>Another stability issue is due to the internal implementation of <a class="reference internal" href="#numpy.arange" title="numpy.arange"><code>numpy.arange</code></a>. The actual step value used to populate the array is <code>dtype(start + step) - dtype(start)</code> and not <code>step</code>. Precision loss can occur here, due to casting or due to using floating points when <code>start</code> is much larger than <code>step</code>. This can lead to unexpected behaviour. For example:</p> <pre data-language="python">&gt;&gt;&gt; np.arange(0, 5, 0.5, dtype=int)
array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0])
&gt;&gt;&gt; np.arange(-3, 3, 0.5, dtype=int)
array([-3, -2, -1,  0,  1,  2,  3,  4,  5,  6,  7,  8])
</pre> <p>In such cases, the use of <a class="reference internal" href="numpy.linspace#numpy.linspace" title="numpy.linspace"><code>numpy.linspace</code></a> should be preferred.</p> </div> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="numpy.linspace#numpy.linspace" title="numpy.linspace"><code>numpy.linspace</code></a></dt>
<dd>
<p>Evenly spaced numbers with careful handling of endpoints.</p> </dd> <dt><a class="reference internal" href="numpy.ogrid#numpy.ogrid" title="numpy.ogrid"><code>numpy.ogrid</code></a></dt>
<dd>
<p>Arrays of evenly spaced numbers in N-dimensions.</p> </dd> <dt><a class="reference internal" href="numpy.mgrid#numpy.mgrid" title="numpy.mgrid"><code>numpy.mgrid</code></a></dt>
<dd>
<p>Grid-shaped arrays of evenly spaced numbers in N-dimensions.</p> </dd> </dl> </div> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; np.arange(3)
array([0, 1, 2])
&gt;&gt;&gt; np.arange(3.0)
array([ 0.,  1.,  2.])
&gt;&gt;&gt; np.arange(3,7)
array([3, 4, 5, 6])
&gt;&gt;&gt; np.arange(3,7,2)
array([3, 5])
</pre> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2021 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/1.22/reference/generated/numpy.arange.html" class="_attribution-link">https://numpy.org/doc/1.22/reference/generated/numpy.arange.html</a>
  </p>
</div>
