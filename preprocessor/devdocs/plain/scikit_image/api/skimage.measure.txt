# Module: measure

`skimage.measure.approximate_polygon`(coords, …) | Approximate a polygonal chain with the specified tolerance.  
---|---  
`skimage.measure.block_reduce`(image, block_size) | Downsample image by applying function `func` to local blocks.  
`skimage.measure.euler_number`(image[, …]) | Calculate the Euler characteristic in binary image.  
`skimage.measure.find_contours`(image[, …]) | Find iso-valued contours in a 2D array for a given level value.  
`skimage.measure.grid_points_in_poly`(shape, verts) | Test whether points on a specified grid are inside a polygon.  
`skimage.measure.inertia_tensor`(image[, mu]) | Compute the inertia tensor of the input image.  
`skimage.measure.inertia_tensor_eigvals`(image) | Compute the eigenvalues of the inertia tensor of the image.  
`skimage.measure.label`(input[, background, …]) | Label connected regions of an integer array.  
`skimage.measure.marching_cubes`(volume[, …]) | Marching cubes algorithm to find surfaces in 3d volumetric data.  
`skimage.measure.marching_cubes_classic`(volume) | Classic marching cubes algorithm to find surfaces in 3d volumetric data.  
`skimage.measure.marching_cubes_lewiner`(volume) | Lewiner marching cubes algorithm to find surfaces in 3d volumetric data.  
`skimage.measure.mesh_surface_area`(verts, faces) | Compute surface area, given vertices & triangular faces  
`skimage.measure.moments`(image[, order]) | Calculate all raw image moments up to a certain order.  
`skimage.measure.moments_central`(image[, …]) | Calculate all central image moments up to a certain order.  
`skimage.measure.moments_coords`(coords[, order]) | Calculate all raw image moments up to a certain order.  
`skimage.measure.moments_coords_central`(coords) | Calculate all central image moments up to a certain order.  
`skimage.measure.moments_hu`(nu) | Calculate Hu’s set of image moments (2D-only).  
`skimage.measure.moments_normalized`(mu[, order]) | Calculate all normalized central image moments up to a certain order.  
`skimage.measure.perimeter`(image[, neighbourhood]) | Calculate total perimeter of all objects in binary image.  
`skimage.measure.perimeter_crofton`(image[, …]) | Calculate total Crofton perimeter of all objects in binary image.  
`skimage.measure.points_in_poly`(points, verts) | Test whether points lie inside a polygon.  
`skimage.measure.profile_line`(image, src, dst) | Return the intensity profile of an image measured along a scan line.  
`skimage.measure.ransac`(data, model_class, …) | Fit a model to data with the RANSAC (random sample consensus) algorithm.  
`skimage.measure.regionprops`(label_image[, …]) | Measure properties of labeled image regions.  
`skimage.measure.regionprops_table`(label_image) | Compute image properties and return them as a pandas-compatible table.  
`skimage.measure.shannon_entropy`(image[, base]) | Calculate the Shannon entropy of an image.  
`skimage.measure.subdivide_polygon`(coords[, …]) | Subdivision of polygonal curves using B-Splines.  
`skimage.measure.CircleModel`() | Total least squares estimator for 2D circles.  
`skimage.measure.EllipseModel`() | Total least squares estimator for 2D ellipses.  
`skimage.measure.LineModelND`() | Total least squares estimator for N-dimensional lines.  
## approximate_polygon

`skimage.measure.approximate_polygon(coords, tolerance)` [source]

    
Approximate a polygonal chain with the specified tolerance.

It is based on the Douglas-Peucker algorithm.

Note that the approximated polygon is always within the convex hull of the
original polygon.

Parameters

    
`coords(N, 2) array`

    
Coordinate array.

`tolerancefloat`

    
Maximum distance from original points of polygon to approximated polygonal
chain. If tolerance is 0, the original coordinate array is returned.

Returns

    
`coords(M, 2) array`

    
Approximated polygonal chain where M <= N.

#### References

`1`

    
https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm

## block_reduce

`skimage.measure.block_reduce(image, block_size, func=<function sum>, cval=0,
func_kwargs=None)` [source]

    
Downsample image by applying function `func` to local blocks.

This function is useful for max and mean pooling, for example.

Parameters

    
`imagendarray`

    
N-dimensional input image.

`block_sizearray_like`

    
Array containing down-sampling integer factor along each axis.

`funccallable`

    
Function object which is used to calculate the return value for each local
block. This function must implement an `axis` parameter. Primary functions are
`numpy.sum`, `numpy.min`, `numpy.max`, `numpy.mean` and `numpy.median`. See
also `func_kwargs`.

`cvalfloat`

    
Constant padding value if image is not perfectly divisible by the block size.

`func_kwargsdict`

    
Keyword arguments passed to `func`. Notably useful for passing dtype argument
to `np.mean`. Takes dictionary of inputs, e.g.: `func_kwargs={'dtype':
np.float16})`.

Returns

    
`imagendarray`

    
Down-sampled image with same number of dimensions as input image.

#### Examples

    
    >>> from skimage.measure import block_reduce
    >>> image = np.arange(3*3*4).reshape(3, 3, 4)
    >>> image 
    array([[[ 0,  1,  2,  3],
            [ 4,  5,  6,  7],
            [ 8,  9, 10, 11]],
           [[12, 13, 14, 15],
            [16, 17, 18, 19],
            [20, 21, 22, 23]],
           [[24, 25, 26, 27],
            [28, 29, 30, 31],
            [32, 33, 34, 35]]])
    >>> block_reduce(image, block_size=(3, 3, 1), func=np.mean)
    array([[[16., 17., 18., 19.]]])
    >>> image_max1 = block_reduce(image, block_size=(1, 3, 4), func=np.max)
    >>> image_max1 
    array([[[11]],
           [[23]],
           [[35]]])
    >>> image_max2 = block_reduce(image, block_size=(3, 1, 4), func=np.max)
    >>> image_max2 
    array([[[27],
            [31],
            [35]]])
    
## euler_number

`skimage.measure.euler_number(image, connectivity=None)` [source]

    
Calculate the Euler characteristic in binary image.

For 2D objects, the Euler number is the number of objects minus the number of
holes. For 3D objects, the Euler number is obtained as the number of objects
plus the number of holes, minus the number of tunnels, or loops.

Parameters

    
image: (N, M) ndarray or (N, M, D) ndarray.

    
2D or 3D images. If image is not binary, all values strictly greater than zero
are considered as the object.

`connectivityint, optional`

    
Maximum number of orthogonal hops to consider a pixel/voxel as a neighbor.
Accepted values are ranging from 1 to input.ndim. If `None`, a full
connectivity of `input.ndim` is used. 4 or 8 neighborhoods are defined for 2D
images (connectivity 1 and 2, respectively). 6 or 26 neighborhoods are defined
for 3D images, (connectivity 1 and 3, respectively). Connectivity 2 is not
defined.

Returns

    
`euler_numberint`

    
Euler characteristic of the set of all objects in the image.

#### Notes

The Euler characteristic is an integer number that describes the topology of
the set of all objects in the input image. If object is 4-connected, then
background is 8-connected, and conversely.

The computation of the Euler characteristic is based on an integral geometry
formula in discretized space. In practice, a neighbourhood configuration is
constructed, and a LUT is applied for each configuration. The coefficients
used are the ones of Ohser et al.

It can be useful to compute the Euler characteristic for several
connectivities. A large relative difference between results for different
connectivities suggests that the image resolution (with respect to the size of
objects and holes) is too low.

#### References

`1`

    
S. Rivollier. Analyse d’image geometrique et morphometrique par diagrammes de
forme et voisinages adaptatifs generaux. PhD thesis, 2010. Ecole Nationale
Superieure des Mines de Saint-Etienne. https://tel.archives-
ouvertes.fr/tel-00560838

`2`

    
Ohser J., Nagel W., Schladitz K. (2002) The Euler Number of Discretized Sets -
On the Choice of Adjacency in Homogeneous Lattices. In: Mecke K., Stoyan D.
(eds) Morphology of Condensed Matter. Lecture Notes in Physics, vol 600.
Springer, Berlin, Heidelberg.

#### Examples

    
    >>> import numpy as np
    >>> SAMPLE = np.zeros((100,100,100));
    >>> SAMPLE[40:60, 40:60, 40:60]=1
    >>> euler_number(SAMPLE) 
    1...
    >>> SAMPLE[45:55,45:55,45:55] = 0;
    >>> euler_number(SAMPLE) 
    2...
    >>> SAMPLE = np.array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0],
    ...                    [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
    ...                    [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0],
    ...                    [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0],
    ...                    [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
    ...                    [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
    ...                    [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
    ...                    [1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0],
    ...                    [0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1],
    ...                    [0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1]])
    >>> euler_number(SAMPLE)  # doctest:
    0
    >>> euler_number(SAMPLE, connectivity=1)  # doctest:
    2
    
### Examples using `skimage.measure.euler_number`

![Euler
number](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARgAAADECAMAAABz285eAAAAjVBMVEX///9zc3MPDw/y8vL6+vqgoKAiIiIAAABXV1dhYWHo6Og/Pz/l5eUyMjKCgoJubm5paWn+/v4XFxe0tLTr6+vOzs7CwsKbm5tkZGSQkJD39/fv7+/Z2dkrKyt4eHjf39+tra27u7t9fX0LCwuoqKiJiYnT09M8PDyWlpbHx8dGRkZfX19QUFBcXFwFBQXZsS0IAAAHJklEQVR42u2dh3ajOBhGRSQyCWaEZHqJKCMIuOT9H2+FE2PPhPXJ7npnXL57cmyqFF1+VCwXQgAAAAAAAAAAAAAAAACAI2g4hHJcqLK/O8R3j1aktqflMiBORmTBdmvuEIxPdeAMzv4AnxCm2ccaO8qh6MyDU+1zCD4W8vpixNRbu2KMMOblJDDPGSW7ByYlYywnWUaaYdyWE8lyRoptQfKP49Zr0oQk+l6OCWV9KoxBp2FxmoxbspyETS5lSEhg1Oe0a3LzuMs18izjrLNMSmOuqiS7Jcoa92LEqK4oUpIWitqqyS2vJtJrkjLunDTcKtWKoElEHTRKl0+tQ+zX2hZW3nimYM2ma8OMi9IxUWTKrgZz8WOTaGsufCmEX6wUpzzrFc9sr9evdmW1OzNN51ombFaqYb1QtCm1Um6vYqKrC4oYv+OEdyrcVGtfmBCXW1frNHR5ZLFN3te8drzU0psoMVe1aGjCem1FY/Eqzjsd8ZKGY1KhZwrdG2GFyAlJKyqiRFqRGp6qJy0y2SnStrvoIlaZe5IUa6kiwVq/HTZa2JYdED+9GDHmChsxVqeip2gILFM9MMF83YdlE6VEMNvnQ+bxdgjDZqwcmkAQ227GAqqSr4akXfTvFYo3Vi1aE9cr36NGRBZp6qZeD0PnmWwUyfx1cRQxivDaI33Vjnk7uU6yXcBdhpin3g5EuylUwNvUtdxRTObrSCi1FyM8XXipfhejJFdJqcayN2WxDN0iGVxznbONiM3JBZfrdWxKHyZWXyxaL7CoavugVbG71lUqyt6cOnjmlt2JKXgjXF6mPC3i1MvarrMvQ0zWhZ0MCoc5knUFc8YmxJE0J0UZZKbVkTnNXVPOIBxXjbWAsM5sH48z1WaZjU+ZKSsrutDcSjINzEI+tlIdYU5HcyGzrpSyK4lbBKHDdrVMWbynFbAxtYBJk7cb0jyVvn+j7T9jP69Xv0YAO30yu4IySvf0f3ncMZHUNEv074+n8tdz6PVe/J7n+2KHLelqZvPh/f5L23GPHZZq37xm1ljzlvtThymRvB0bGmZ9CPH1lHpxrV7chWa+L8val6RadnVfN92WjZ21OK7a0QVz+rFCJp1dsucqIiGluibMr4qVndd615+l/jMbK/TKJ1nly8qWfpVlVZVF/bWKCTZ1z9u42kSS+B6ve3crUjnGiiqp6YZ0RkrIx5o00Ymzsr2Bd9xWft/63abWVv0+MqCWESM3tjX0baP9yk7TNOY1HRvsK8WjXhBYu8FRZbc8Du3O290RlkuF3EkZRjF+b/ojgtR9Gm1ayzb9POaRwkrfR0CBZWKMJdLXXuaqSj8r0ymyYup4VytG5I1f812zou3yJbZTd0vHIWOqayPEVeausejYK3GTYlW0VRuKsMxNqFBR5iWP6dh+F89jpzFhlW6iqvU1r0o3KERdNtdb+VJXKWcYR7xRTXhFW6smqSlszsfBnmzc0lubylTaXiU5b1lbdKopXMXzyvR4uZOaPknWbFtJWM+GyFVNMEQBV1Gk2ty+1Q6LqXN/blek8/zL2Dg61STX2d28tuMOeH3rRoiebwV13hFD/O1WWJ5XjH0zYh4hBmIgBmIgBmIgBmLOz/dwT/1j2qjDzzzemZjF4aW/g5i513Vf7laMexDTzcw9QAzEQAzEQAzEQMwf6+AdxLydEnMn/ZhVvOcwTZTZ08Z8mtsXyZ6HuxDz1Qno8t7GSl+dgD6qdyDmuMaFGEQMIgYRg4hBxEDMpYp5+v7ByzeI+XlcZMZN738Qc64BI8RADMRADMRADMRADMRADMRADMRADMRADMRAzNcRp3N+vAsxL8ln9Omcm/1xT283LOa/fII8uOVZAvEf/gUXYu5wJhIRg4hBxCBiEDFXJqZ8g5hZnNfv/5TlXYj5F3CIgRiIgRiIgRiIgRiIgRiIgRiIgRiIgRiIgRiIgZgzkNywmMdojz9998TLzLYj1LT78BVl/HXP3O8hBavXT2yyyxZz+C6TbPl5G50TM/ezPtuTt5c7M1WyvBox+V7M22FbMCdm7qeg1iffMzM3uXaFYr5BzB+MmDdEDCIGEXNnEXNomv+FmO3NRcwL3eM+Pnxw9H2z07Yj5voxYtrrTQkeSu4sp92HiHHoZ06Xsp1S+fH/i3lb7nnsnA+C6TjpzDB3qfNpbzoluJlL5uVzxkec/iEhOqVi/86x0o/gLEmnU4Kvc7tPf5ZAfzET/3eKeTi3mMU/F1NBDMRADMRADMRADMScSUy+WXzG/6KYh5lzF6ffKP8yc4Z1iWJmP58Xf1HMmVhcpJiHPy9mBTEQAzEQAzEQAzGTmJkf6c6+Ond9oP8dYurfKeZNWJ8Qcx9cXFmnWJxbzONMJpsLf3/MBQAxEAMxEAMxEAMx9yYmvhkxy/OKiZ5uBe+8YgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHDMXwXCfT4Bqt2kAAAAAElFTkSuQmCC)

Euler number

## find_contours

`skimage.measure.find_contours(image, level=None, fully_connected='low',
positive_orientation='low', *, mask=None)` [source]

    
Find iso-valued contours in a 2D array for a given level value.

Uses the “marching squares” method to compute a the iso-valued contours of the
input 2D array for a particular level value. Array values are linearly
interpolated to provide better precision for the output contours.

Parameters

    
`image2D ndarray of double`

    
Input image in which to find contours.

`levelfloat, optional`

    
Value along which to find contours in the array. By default, the level is set
to (max(image) + min(image)) / 2

Changed in version 0.18: This parameter is now optional.

`fully_connectedstr, {‘low’, ‘high’}`

    
Indicates whether array elements below the given level value are to be
considered fully-connected (and hence elements above the value will only be
face connected), or vice-versa. (See notes below for details.)

`positive_orientationstr, {‘low’, ‘high’}`

    
Indicates whether the output contours will produce positively-oriented
polygons around islands of low- or high-valued elements. If ‘low’ then
contours will wind counter- clockwise around elements below the iso-value.
Alternately, this means that low-valued elements are always on the left of the
contour. (See below for details.)

`mask2D ndarray of bool, or None`

    
A boolean mask, True where we want to draw contours. Note that NaN values are
always excluded from the considered region (`mask` is set to `False` wherever
`array` is `NaN`).

Returns

    
`contourslist of (n,2)-ndarrays`

    
Each contour is an ndarray of shape `(n, 2)`, consisting of n `(row, column)`
coordinates along the contour.

See also

`skimage.measure.marching_cubes`

#### Notes

The marching squares algorithm is a special case of the marching cubes
algorithm [1]. A simple explanation is available here:

http://users.polytech.unice.fr/~lingrand/MarchingCubes/algo.html

There is a single ambiguous case in the marching squares algorithm: when a
given `2 x 2`-element square has two high-valued and two low-valued elements,
each pair diagonally adjacent. (Where high- and low-valued is with respect to
the contour value sought.) In this case, either the high-valued elements can
be ‘connected together’ via a thin isthmus that separates the low-valued
elements, or vice-versa. When elements are connected together across a
diagonal, they are considered ‘fully connected’ (also known as ‘face+vertex-
connected’ or ‘8-connected’). Only high-valued or low-valued elements can be
fully-connected, the other set will be considered as ‘face-connected’ or
‘4-connected’. By default, low-valued elements are considered fully-connected;
this can be altered with the ‘fully_connected’ parameter.

Output contours are not guaranteed to be closed: contours which intersect the
array edge or a masked-off region (either where mask is False or where array
is NaN) will be left open. All other contours will be closed. (The closed-ness
of a contours can be tested by checking whether the beginning point is the
same as the end point.)

Contours are oriented. By default, array values lower than the contour value
are to the left of the contour and values greater than the contour value are
to the right. This means that contours will wind counter-clockwise (i.e. in
‘positive orientation’) around islands of low-valued pixels. This behavior can
be altered with the ‘positive_orientation’ parameter.

The order of the contours in the output list is determined by the position of
the smallest `x,y` (in lexicographical order) coordinate in the contour. This
is a side-effect of how the input array is traversed, but can be relied upon.

Warning

Array coordinates/values are assumed to refer to the center of the array
element. Take a simple example input: `[0, 1]`. The interpolated position of
0.5 in this array is midway between the 0-element (at `x=0`) and the 1-element
(at `x=1`), and thus would fall at `x=0.5`.

This means that to find reasonable contours, it is best to find contours
midway between the expected “light” and “dark” values. In particular, given a
binarized array, do not choose to find contours at the low or high value of
the array. This will often yield degenerate contours, especially around
structures that are a single array element wide. Instead choose a middle
value, as above.

#### References

`1`

    
Lorensen, William and Harvey E. Cline. Marching Cubes: A High Resolution 3D
Surface Construction Algorithm. Computer Graphics (SIGGRAPH 87 Proceedings)
21(4) July 1987, p. 163-170). DOI:10.1145/37401.37422

#### Examples

    
    >>> a = np.zeros((3, 3))
    >>> a[0, 0] = 1
    >>> a
    array([[1., 0., 0.],
           [0., 0., 0.],
           [0., 0., 0.]])
    >>> find_contours(a, 0.5)
    [array([[0. , 0.5],
           [0.5, 0. ]])]
    
### Examples using `skimage.measure.find_contours`

![Contour
finding](data:image/png;base64,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)

Contour finding

![Measure region
properties](data:image/png;base64,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)

Measure region properties

## grid_points_in_poly

`skimage.measure.grid_points_in_poly(shape, verts)` [source]

    
Test whether points on a specified grid are inside a polygon.

For each `(r, c)` coordinate on a grid, i.e. `(0, 0)`, `(0, 1)` etc., test
whether that point lies inside a polygon.

Parameters

    
`shapetuple (M, N)`

    
Shape of the grid.

`verts(V, 2) array`

    
Specify the V vertices of the polygon, sorted either clockwise or anti-
clockwise. The first point may (but does not need to be) duplicated.

Returns

    
`mask(M, N) ndarray of bool`

    
True where the grid falls inside the polygon.

See also

`points_in_poly`

## inertia_tensor

`skimage.measure.inertia_tensor(image, mu=None)` [source]

    
Compute the inertia tensor of the input image.

Parameters

    
`imagearray`

    
The input image.

`muarray, optional`

    
The pre-computed central moments of `image`. The inertia tensor computation
requires the central moments of the image. If an application requires both the
central moments and the inertia tensor (for example,
`skimage.measure.regionprops`), then it is more efficient to pre-compute them
and pass them to the inertia tensor call.

Returns

    
`Tarray, shape (image.ndim, image.ndim)`

    
The inertia tensor of the input image. \\(T_{i, j}\\) contains the covariance
of image intensity along axes \\(i\\) and \\(j\\).

#### References

`1`

    
https://en.wikipedia.org/wiki/Moment_of_inertia#Inertia_tensor

`2`

    
Bernd Jähne. Spatio-Temporal Image Processing: Theory and Scientific
Applications. (Chapter 8: Tensor Methods) Springer, 1993.

## inertia_tensor_eigvals

`skimage.measure.inertia_tensor_eigvals(image, mu=None, T=None)` [source]

    
Compute the eigenvalues of the inertia tensor of the image.

The inertia tensor measures covariance of the image intensity along the image
axes. (See `inertia_tensor`.) The relative magnitude of the eigenvalues of the
tensor is thus a measure of the elongation of a (bright) object in the image.

Parameters

    
`imagearray`

    
The input image.

`muarray, optional`

    
The pre-computed central moments of `image`.

`Tarray, shape (image.ndim, image.ndim)`

    
The pre-computed inertia tensor. If `T` is given, `mu` and `image` are
ignored.

Returns

    
`eigvalslist of float, length image.ndim`

    
The eigenvalues of the inertia tensor of `image`, in descending order.

#### Notes

Computing the eigenvalues requires the inertia tensor of the input image. This
is much faster if the central moments (`mu`) are provided, or, alternatively,
one can provide the inertia tensor (`T`) directly.

## label

`skimage.measure.label(input, background=None, return_num=False,
connectivity=None)` [source]

    
Label connected regions of an integer array.

Two pixels are connected when they are neighbors and have the same value. In
2D, they can be neighbors either in a 1- or 2-connected sense. The value
refers to the maximum number of orthogonal hops to consider a pixel/voxel a
neighbor:

    
    1-connectivity     2-connectivity     diagonal connection close-up
    
         [ ]           [ ]  [ ]  [ ]             [ ]
          |               \  |  /                 |  <- hop 2
    [ ]--[x]--[ ]      [ ]--[x]--[ ]        [x]--[ ]
          |               /  |  \             hop 1
         [ ]           [ ]  [ ]  [ ]
    
Parameters

    
`inputndarray of dtype int`

    
Image to label.

`backgroundint, optional`

    
Consider all pixels with this value as background pixels, and label them as 0.
By default, 0-valued pixels are considered as background pixels.

`return_numbool, optional`

    
Whether to return the number of assigned labels.

`connectivityint, optional`

    
Maximum number of orthogonal hops to consider a pixel/voxel as a neighbor.
Accepted values are ranging from 1 to input.ndim. If `None`, a full
connectivity of `input.ndim` is used.

Returns

    
`labelsndarray of dtype int`

    
Labeled array, where all connected regions are assigned the same integer
value.

`numint, optional`

    
Number of labels, which equals the maximum label index and is only returned if
return_num is `True`.

See also

`regionprops`

`regionprops_table`

#### References

`1`

    
Christophe Fiorio and Jens Gustedt, “Two linear time Union-Find strategies for
image processing”, Theoretical Computer Science 154 (1996), pp. 165-181.

`2`

    
Kensheng Wu, Ekow Otoo and Arie Shoshani, “Optimizing connected component
labeling algorithms”, Paper LBNL-56864, 2005, Lawrence Berkeley National
Laboratory (University of California),
http://repositories.cdlib.org/lbnl/LBNL-56864

#### Examples

    
    >>> import numpy as np
    >>> x = np.eye(3).astype(int)
    >>> print(x)
    [[1 0 0]
     [0 1 0]
     [0 0 1]]
    >>> print(label(x, connectivity=1))
    [[1 0 0]
     [0 2 0]
     [0 0 3]]
    >>> print(label(x, connectivity=2))
    [[1 0 0]
     [0 1 0]
     [0 0 1]]
    >>> print(label(x, background=-1))
    [[1 2 2]
     [2 1 2]
     [2 2 1]]
    >>> x = np.array([[1, 0, 0],
    ...               [1, 1, 5],
    ...               [0, 0, 0]])
    >>> print(label(x))
    [[1 0 0]
     [1 1 2]
     [0 0 0]]
    
### Examples using `skimage.measure.label`

![Measure region
properties](data:image/png;base64,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)

Measure region properties

![Euler
number](data:image/png;base64,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)

Euler number

![Segment human cells \(in
mitosis\)](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARgAAADECAMAAABz285eAAADAFBMVEX////p6emYmJjz8/OysrL//v/4+Peenp79/v7R0dH//v+Wlpb8/Pz7+vx5a6J/cKVyY514aaH59/t7bKPx7/Xe2uiBc6f08veHe6zk4Ozr6fF0ZZ7i3uuMf6/c2Oa1rcz29fnm5O7y8fbt6/K3sM3KxdqDdah9bqR1Zp/Mx9z19Pjf3Ol2Z6DGwNeJfa2dk7v3+Prp5vCRhbPTz+Gbkbra1eW6ss/v7fTV0OL9/P7RzN/IwtnPyd2+ttGZjriFeKru7POPgrH49vrCu9Wflb2zqsrl4u3n5e+Li4ulm8DEvtZxYpyPj4+nncKXjLf6+fjAudOTiLSTkpP6+fv19fS8tdCvpsejmb+Hh4erosVsXpnY0+Sbm5utpMaVirapoMOxqMlpW5f7+/qCgoS3t7f09PjOzs7Dw8NvYJu/v7/b29tkWZZzc3O7u7urq6w9S4dMZpZhVJM8RYRHUIyXl5eoqKh2cqSgoJ81UIjh4eHn5+fW0eM8UYpbTo5NVpChl749ZJE5XY1gYJhCVo3GxsaMgrB/f39tap/T09NWdZ6xsbFdW5Xt7e1RbppSXZPJycqioqJAXI+EnLhJW5FGR4hqamrV1dVYVZFZfaCFhrCurq+lpaUgeIgyRYIvSoPX19dqZJssZol6enoibYerrMlTUo/e3t5FYpNucqKDeqnk5ORkb59Jb5gyW4vr6+ukqMWLj7WVk7lfeaK1t9Bse6agtMlYZphOTItgaJuAgK01b48bhIRzgKlhYWJ3kbKttM2+zdttiqv29vYhjoiYpcFVQ4mhoMJ8h64tVId7eKhfgKQrgY9XV21GTWXw8PBMU2kanYRlhqhRUVFBapSWnL3CxdjGxNmJiI4weY+Ol7nT1+RtaXpjXnOvw9NPQIG8vtR7mbGPpsBBeZRKiJtXZnQ4PYA4PWN3c4BDM37J1OGQiaXHzNw8q3Vepax8fIY7OzvV4Ol9c6ZmWovOy9/d5u1ncXxxsLZJt5pam4RTuWQxppJQl6R8ykZx5qRh/+mY87JqtCfxAAAgAElEQVR42uxafVDa5x3/IihQQKAoEPFdQVTQ+C74gviCqPgGaIjiC0IwOvCui4ZBmqRtLDXWBS4drpHbXGlGbvTmumZZb7d512W3P9Lduc5bmnR3zXrt7dbbcpdb9k966x97eFFjYnq1Yfpzx+fOH88Lv+f7/D58X3+PADHEEEMMMcQQQwwxxBBDDDHEEMMBxIpkW9e+EryuJXz9BdbwB/PBl51OwkZ7kvzYNNWnRVetNdI1W+ZgbQKU5K8vYJZ8IHnBr5pX5vBxFK3ZpnIo112TOgLJBC6/Kc4F3V7KEtWSMKEju+55JaCdnsZbVgNgujevU6oXEtwUpD0Oik1rUpK7vXEmQtzYWhzxOsC43jqhnF0ZD3jxJgCyf4JIdCnteD1lQaPXz4NJtXgQFMaDLhS9Vx3nI6iWdDjPuGXcAtMTHuICaO/NWmadZI/L40J8gNpmoxDVCUD2OJxqm9umpPgAVMrFbvK8J7DuWp83WnVEYxyA0+hYNK36nUvrJjUA0WRxG33zxoRxJWVeSVidtSytarFPzGSQGEsAbyFaF3SmmTULeN0+0E847cg7eMA9Y1xSg9PqC34Lt+CbmkK3OEE3t6y2GONQx64z+p2U9UUL+FaWvKsqCjI6pUuiU6/bdT6VZxzAbdUFCFMrTrPT6FSSqT7bKjHuOvaJGfMhG3DrVG4iweGctdgtM55F39L6hM+PPMv6lIdsWfZMefyrZhLYdErvlBcgsDpnNJNVUzor8h5kq8fkMa3PWcDimJmh6K3oPt2sdtW0HtCvm+8tBDXG6J/yOnwzOpXFimgxW6zjB8HJJBC8kxLCPHUycN08tkTGuc1gn5nAmVEswXumZsEFc247jJtIMEaYl/jRc5MmrOSFhTmS1TuJTNE7KxmfH19zgSvB7x+bn3EAzOHAPDWhDbgSrCikTQbIeLv/ujlhyUSWmIgWMLtdBzxS453RXnFBZZn4f8hhSFFfUZuA0UclTxODmFa7KRT9LZXaFuoSUYwh7oAdB7851Lf0NiTplopIUQdXv2XUIwluN1F/yy3Zey6uL4xB0GGERC9ZcQgrfff5vP7F+5d+HMCFYK/z4/73WP7QjsNl/OPOtYV+wQoO13Z/gGfHOXrEKw7eH8f2nheLzaF3zpKd6qAWE+bC+Wwbvb5RQr9yIj3U1aQx5Xu0ndG80t/zs+UZqMlOh9I+6GWzOqHk7917T4xRPaHG65S4uEUYc9jID7mPiucMtSPyUwCDbA0r54krNDZGbzc0ZisY8kRyGmo3y1PqK6VsoAkPwb5kNnOeuG6dck1PBvyUZe7hmaQy4dEWtgRaRVJRNoC0qC3l8dulQtFQ1DxAFSPzFJOWFFqv8LVPf5QpTkzu6WgFyt4To/UqrRSjddaoDMo2ba/o0geqexAxkMtrQb9mYt0IMzvEhUyQtfEVDrOsRDYUrd1Qu5g8aYSjB19+8dkzklE6F9nzPhBDcuCgG2VdjlCgJGwQwwnZR3wTm10RUnH0JxH0pHZUBXk5/tbzXQBZaV0cAIVQAnwBHCvMjMp2JIMRm32m8IsvH1yDrOqfvHSUtB/EbMcGMXUdTOm2CY0GIFXAbAq2hy+8/jYihlt0J08Dki5ZMUOaLqKzDkV3K7RrF/+dI/vWt7/zfkcyZohRMBRljCRQSKnASacGlYSdV4i0SxOabf7BuYFCoBrufH4aqQm1J0MB3CZahix6uUZ8fPizNOPjn77wnqwMM8QcEnGqhAVlPHpvCt1QSgPNK+/8snjLQxbXJ6OPfMPp8g0uivLf+wUzatEp85NPOKEGt+/YR2e4RRrMEBN/VNjRAmc7QVCaJj59CkpOvPhqy+P+4PBms5rxr9PR8sC1udV3794MNZPz8uhH+goAOz4GUpDHSGV0Cfkd/LNHkCM5LS/4yhsVNYooWdLV1869fPfutUiUygqLxQ4xQW6KDccroMnA4AfNJzSU0yJ+UuFI6xUNRmULl65895UHd/+5fRBLxNAEZ/7MRnqTnbQ5dEhYz6rc6JQVFYdmOA0h4xtu6+FGZQuDr36ff/Nq/GY/K+j9MUUM/fzHabUREspzg5nMcAb0oTh987c/r4UGRvtZLhqUikRtyIgkidLy5ujsoaDh7Qs3NiqQ7N5EVlomtkyp892TgrCFFzIy5Cg0QPnZLBYfJJ998OsXC6sFAImpQBLkF+QFUx5xR9dTpniazWT6xJ+uXI60h5s1UNSOLWIyK0ezw632YQBZDXI0cibSDv6F331wW8FJrExmNABJ1ldY3h8N0bkMdnIk6b185tyHkdHeEU6DQIwtYraQKmwAeci5oADdzuu5eQFF0xK2SBwkzVA/kBqcqqhseBrJ2YysPtmmM9vMonO4iczyTOwRE4nR/TyZgBMZog+COPx2hhq61pTmh4qI7514qtS34Xh6ef2OjD2LtXCNAoSAxU0Nh4b2YxuD9WlDHTsEZvoPr/DCTCkq03dVUNeEPHx8Lqt+51RJQsMaMYMGcU4l/VE1OJx7JHmnKCuKlJ18EXeAswuRPYn0cuoTHfLRol4Wc7hxGlPE9Lch95K326MAuvjQQNIuvj/aDALxVpfP4m4pXNZbb7wxkpLS1azHFDG5LxdUJOZ+9Q05ta2PjGQYBvi7EZnDKxbmbxlWYr6YsamR6c+/+eZwg0LeiS1iMkuFeXUoBa1j1z/JNjJ4XMajNJSV7U6mon/j1Y+mIgV6OzWlGVsF5a+uFifmddKmMRaVcoL5Lp8pre8KG1RKuWCoETh/vRyxlSxeClQz46MknFpEZ+Rmp/HY25WwgArYzGN6myCTF071hj8/W9pZdv7T2xfDU6foAH1p0RKuOV7BYSggaQdXjElihuQp/TJamJjnTrWkXfzDf25/FHkUuUAuTI2a9BpGkSF5xxlMEvNsOa8ocmyS08sSJP/l9fd/tlEW0WrF2VEU38Df/uK4CtVPg0VpVVgtCTarw6pmRZCNvTpI7hmQS1IYdV2dmCNG0dy+rc9patzL3bAvMyuksuCrDqwRIziS99Cb3NatvC0nt3Y7Y2UV0d9M48ALZ8o4wvIO6f4Q40jAL5NgeWEHYugVSYzDQKrpRAGUNGQ4jmqkkMokJXbljT5cfovYIn64qokiaKK/nWyE1P6K/XG+gdVxlYpgVeqC/4i8dUSbOor208OQpUkgl3WWngm1775zYwRaOm6UoHEBqTNUYUtqaoJkyJulhhEo+c35SzudulG/qf21tm8klvtwqI8nTrvjSDqd1maGNbdn41A/u+PkwH/ZufKgJtMz/o5bbNzNSUhCyMmVm8QASfgSsgkQwYAwQBpOAyiIrLRyVRflWmBYr4HKMcUTseiIg+6q64GLZbWssq67WxysXbXr2tp1Op3pTO0x/bf5vhx8SbAbakpCpvknyZfv/OV5nvf3/J7nfVus8MREwUUjQGICzvF6IltNujTSYSV6OkY4zMIwZTxqopX7CRvaSDRw4djc2KwnLAUEhgH7OrfIvr7zyfK3gex6/5c/zt+9fsOu/BMAemOHw2LSh8+1O3TvGH45WQSiz+6JAymPzvUZYUuxabJiPIQVWD9CmWqr4VyY+tfM555JIlWsux32GncYOnm+80usH2JM1Zod76/ZVrlxMxJj5HQmLItgCq7VOhmKRiZH/AaAxJHPhsULh6rDQYbAuVvsxzNjdzxOr+vBZTaoXocQ45tav/AHMLZHtnGT/U8HB0tsZRC6M2MRZYfn2QlpxNnxv6PVNZJxoZ5iTR8fnTJ5nJt1OwIYZV7dRoiwULhYqCnMzfd30+KRp+1NNe4KozGeEiNxDDiuGWOkUft9p1zHoAFLnnfSDLmCtLhk4f/sulrOlLsTW1liuoHl3Kil9ixJugRGCY8s92pPWaJe6pQc6ExMgOdKIKoM3+GUY9m19Z0NS2uFiVR7KXVGxZNkDsusEOB7FjTgVYGZK6Ff9NrO/jYnzYXiDOwQH6aRENCmFOphcsdIB6QWZ2rih67NpQIDSnvCc51G3jLU2jB+9Y7vskqhJNYghU9v5Bn4DsRN419iAxYYxMRFhW4NmsK6Q8NnBurEPruBUmKmkQUDA2UWOwMTc/CfmwMUGFo8kWMdjzi6PcWueZ6u7fZQ90SYL66NERo5JtCSJ/MgPeK6PwYSMFAsP83xObFDUWI1bI3u09FQF77PunvZ2JDpi0uHdBA4gsXPZLr4RSABw27DNzi6MaRKM8kE48ASuGSEURJR1BVZoS8uTSGKtAwXYTOpQhyQw3V61u2nDsZCwdciNQ5Rscb1b347T1Ge5RMtRk7ES9PRG5hEmSQmIHnMFjLVGWpDX0FFUo3Ut30UeiPdeGMagRsnwQYkwcNxbe+K8JSw5b8XUQ4JHxfQzFdMjDOWLeddqCg2BhOVGtgpgZIaVpiyjDehZhAYZtdNgQkMLacmT7U81+dapJy1+ASQTrT5LlPKUwcuMM7Gqv/5C1Mmvc6IZJhAhA0YFUkbS+IGMDDL9cLxr3T20RJ1HUSb/BWnA3oJ7f/AANCjfVwrxynXOQRDSRmpAqx8YLDJGu5rJtcMcgc6TZUrE8DKBwZbphvdGepblmd/rVrRwESNTu9rXiINjk5keaq8NHf1hV65eiUDgxm/9U3r0lRPHK9cQ3RWBvQaZPjjbCK4VsbZNU82r+gYEztYf2FpUlsUkQuEBIcgeHjksnUIir7W+xHDntbbHDNH+cMVPiqpY5YYfEM6+JaCEntcgg4dm7cSSdHoSG8Jot7RpFkWGLQ8rR+6Njdvz9+7v/LErqKj8H9d5bvh2kvTSc5OdDRtQjfqkflb9Pg9ubb8+vSlUVi6Ki353fK7Emb3u+s37Fqff2LDNrC6ev1eX523hV9GW+oxYWHyTPRSCZzJgQKkhqn6rR+C71cbKzeCoqJfHawGP9pa6TNgWBdGY0RL1fbVNSwiSsRLkCjCbRTYD5XI1T85+tb6t7ZX5Vd+5VNX4k008/FU85IKK9E1ChDDQh3CIRtN/iJ42DXVmA9+hsVU7/ZtShC76aLh+ickoVf6iyEPUcHpWTiAq7E7EzfwZYf/UkEA+tpJgdobMhNuyOXDNWuoQ5CiYyE2YspjoGfpBFkSGZUr9GbuClNijdVU5KMiTrPWnldHSmOCFhhIEenNbltIQjaf47qNkwNyOMEKDGWiv92rykoSmYBqs1EbOVFATyVTo4IUmIirA3/t53hnWgseBxn4BWV8FeCqRUEafEFS983pyYilHsUUWIdraRrKgHhUZlAAgxFmJyEfUmcHL+i/Z2danPu8U70gVhVHXChJqhhCMyH0p0EAjHqovcGIuAaElBZM6w6felXHuELC4ie6ccBSgkCnAIoE+2Y2HwCqYmMQAKMY+myaiOq5Ux+/1R0HG1Ky577xSoAje8xVthKZT06O2RcxEEmECoZ+VRAA82ZuVxcZVdGNnuxttYaMtKG6Ux5zBBNjHj+rXyQ+Q59PzR2ym0wCn6QJghjDvXjVQlOtRW+S38m1ulJ293sHPOYUMLN6783Me7Z0vnn/3swliCsKolHJ3D/QuuhcwIjRxpeeyXZm09dzJ/lmjxj0m0PntPTJvszgAUbTXT9u12HSE1CCTKQhRWsnbI8Hni0MVrw/zExnl3hmVGlnPh7vv98XETw8JsFsL3Mr27sETt6LI5RbqLbA8/je1NisUG0zkrB9c3Pf4BiebOfDk1P9f+q/Gh18BC+0prf3BskRhEUMdnqJDSbx81vzUye/sxXSSo/NnZTpstEuV6GFo65qtn9TTpvTklYFDzAQfmR6C95ZZUoj8zn2EAN9OzP39TVbmSV14JYwcR0qxERLZPw8RIrhJQC8Tc3DmQtWdl3Jljkm2Yck9oF2at6i2uazqbFGmSM7cqN3atbNfXeRWR6ycJ29W6njZbf/G6BPvJb7hIByEo9gD636tGT4qU3mO7DdsC3OtkbKh99q0A+q0VkgYCpFYrOKtO/8AxL8K1cZBzFlcBO64MaZX/sbmP1/fo0OTGXWS4pADrJdJidhLrbW98kBpaGvRLP4YcLTj4aTabwSW9NWy2hdg4Py0SQFVDMA2lrBE3/PJTjyopbiRZ4Ys5PlmR6mCz4duVvIE+a4AIPrmo7qLwDJjfOjyPNmuLE8iE3o7W1O45SFkpjJadYBHqdAeBBdSwcRkn/MwidTmfwefLePnD7wn9ZzpqTBBv+we1+dJ5E3Wm7OD+pzww0O+sJ+WQyBkOudt0Z6QKi0XQaf1zw06VL2T03ZdLuveWJLfCagEnWEEseP9IamBjHG0DbMDozhev+Lps6h9FeTlCwWyUotzK3Tx5UeP3JyrjR3odSlVPJgo/Wx6Icvxlh5ClaufWB9O3u+Gd0AGiYtj2FZCvQg3pJJktCZxY6pcKVD7zWtA5BYFSg85mnj/JDllQq2TgPVWIOQKP5AnmdbHpdVktWC+h59YL4RtcZObGv9eCooqGtGr5pnbLAwECPJkPIoSnJSoWPNFVzZNSKqccLvrnTkBbmpQpL0qthCzSYkIqTDJbkxJdiUA2z6AloZCSaI9d1dnDjOsS239X6THkClQvQAIy83oFbRMfN6rPFFlCm0Ol1IOlcPm0u0oYwNVEXLz2OwW98xra7aBta8A9/w9r9RJKlS97WUnHIBU7rI9JDQG+c7H7pte3i1fjY0NUmkHj5OtfcypD6acHE/vYwcv9jcOBo1hcxBbAYvKQAhKRPNXUm1fphevHrrwf07jhZVF62qsn6r2ksnKUlubpJA4C8sO/bRHfdUuPTM87EHdneRliHBEpp4/pdO2K04O3+/UHMLAeKFxBvSZWcgy5aG2MMIpBYjbC8jCyj5kQAk47H0LCyGcLl1tKPZL/OV3t1aBA5uqPogH7zxg1/8HCoOdxuw5Qy1to0LuGyYqcf+m7prjWkju8JX6aLS1Hg82Pg1Nn7hV2zsYAx+2xhjXPBi2YsAAQJM1VRIVmsDEkLlFUCUuohoIUiBKkFECU1WgALhGRolRAoNIZWqKGS12SqbpFWqjVZbVdrV/umfzp2xDc6a7M94+YXt8ZXnzHl93zn33InIgSi5G7oosr5N0m0q7GqtF8bxjGeX9yMQGYplfCwhDJZsasoXf/QUpMUlC+KK40Ad0Jlk6uVYLQ2ipgCzL9RmAxJ6y4geX13j5DVOvYcE75c//Zjy4a9/8cGJ33wMqv98IgUkUCKMFr6JQ/+ijQEFc6+3tS054t4eH3adhP+56179l09Uqw3LC58CBicDCC2HLrSxdXpvM8HtibS+YlxDgoFSAZyxyUOB+/XeWI3Gmm3VbIw3UICxXUOgi6JbD+zvYbPoT35/4me/+/BXlN/+/LhuB7EOczKApsYWwh2M6Ubn6r2tqqQLvlnavvwMVpwtzAJle1zfTh5Ezr810GBgbL7i7SRJqTA3aaBgMJe6Y2mKtoKZ8GwwzM4UIlo+gag0E5PjabqLFmZs/BaeGioKgya+O1eR7GmvfPfdZRiYsur6ensfxnSi5tqbVxtHxOCpr1KJU/QSWWQ6go7x8/3XZ/v460M5EqCs4wKbDrxpg95Oeu1uNI130UoCVCKomKpo8qrkZt6sB5c/O0tYDG/4+c7EixhrOXxzfDWeMOefoqDnyrB3j2E8yfWr6Pq++X4iKgbt3w6ziYzq6dqDtKYd4g9N/L3cLrf9K7afgEv90Xv98UK+eTXuXiwKPjNHvX6a0Raj6sTSuMExSF4q8cdpmVvaGyE+YSvkscszMn4MRJWkmYl8k/yWlA/IXrls2vhzedCVyJyzOMRdNxcDvn9EAHLVpCmJEbaXlIyE7nMMJC+Wd2mWRKEUEZ4Y8FSmHwu1yS/jVNKSTd6DBYnWOd5M+51zu+GOeBZYPdN7AO9LqijDPCWo04unQwarGNhGgBbJb3FygF8GyuEYYLMyYZ2mGndCJYW6C5samCWkRYmWa/OkRpAOBzT+KiqfXvFW6UwagNmceOPe4/Pe+SezcR0QTfwzQrhiY60KthHhDroElWHcHqqlfWiz/5wPGGQyPL0FxWp2jCoH2YwjZuu+tD/dAVvqP0oDwZQMhUOpJMP1Kq0NuNfI5DXmpEKZHN8nkW9fhs2h8HxjwivvrVXjEOqIF6mzU7rqM9yyvrOLi3t4NKcUwlSZrQQys/BghgEaFSEBKPUpSPRQNTu9CFezpMOG9E9nlzpSTbeRYEYX7fg5MAZ0ZT480TEAGgeMCS5X6OKCLB3Ghk7UBN+hUO/s1OP5bgZ1+ULHhofMBABwMWtp3BuRyPWBvnMTIVZFc66CEK4E6Zyvx7XT/e80CNcFaxfswlSfSZn8lDVGEjuJFF/d2aXHmzQzK4b4sZyFi4p0OCYS0eX4t02KyCsEml0lUm/m4rG/D4/grAFnszYH3F5nRF6fPTvo5dIlQCsgVy4gVpGkRYJnInxf+bvGCuUWJzL7Aj5zgOizrECczoTNGPrPbsZmLmYzF8bwu6yqy1fgiiNtU+tJ0RGa0gsL2nmXevtxG12O7kQ7pq/NmUsVKqsXd0oWqkYlcRMPI33aQPyYuu5YijO/ge2IK1VNa7GuDPpiij8vwSKwinqfwLFwBL/L0elxzOOSwagN91QXHYrc3j0xmg2K+hcjtxhANBpes4XHWCBDQGOaIXgt8jeEulBcROZ/pIHGVCL8cgDk5kzvcRQna+7m4824g+V+MVDefvtWkruWXmjY3OtWmioQByw68PiyctzVIDSC37NgXiuo9utgN5no1kMY5q3D21du43qqYt1fGoTZshDqUw+NZW6nrXcJQIni/ZvSH4QNuUF2Bsij1qPCYy5SUcWvxuJllswyhbpjsFuX4J8sHsAe7NVfn8m20e//FTWALMRlaygCFCmpKezCQgfQs13eQw9funjxfxGpYIDD2X50cT/O91Ba2qhSeVcrB9jsabBfycSs9EOIYtUf62RYcj3beVgF4TYuDw7GcXR5aBQzNs9swVhSd2tpsssFxPTJHcvhEUOafL/TRHs62RrrsDKP+MH0xUdRnS6otj25eDF6CMTOZIICOCpFSv1PGpiSion80Dg3RlNSJRFkX70bf5238SaXWsRUwOKauT261GEFWY6ZN8WHgjHS1DmgtnUIz4KF5gIg6t8Lr9zYn/48GDDwBavb4ytHLDhXWwYjgUn/t7Tb+md6cfDu2qSJNDhuGQkjK9lZBQpJhYzo31CG5n24YYjYcuYRxl8I6SdD9Smb0Uf1FuX3Tr8cXzAxBHY26mQAjw/BlI262hJCLjS3jmQ4Pko3rEQ52P7sZoodwxni2OzIcgdaj0cvStf1231cVo+wWtewG7QiTShBfxrIqA7bN0vfHjbJvhTuM1gduee7X44/BHZdCwEKytVZ5gZqjR6BplpvBy6ynpJ27aw528+/jnyfXTI8PDdKxiHn8v0Q/nQ5Q/s7DpsMlQmz2zq6XA5gTz4k0KjB1IcmUl5XzwGB2cHXAknbqQLXzAokCIEDBi2bE9Tu1gGghirHozOxHsDS6orSg3ZguQWnQbUF/k7u4r8u30jBunU8jtXNPum+NIJrzKlQ991nu0zAt3lao2P+gDN5o5JJvRKN1S55EpA9OttLY5TqpzZRbz2QrvmrV30CxNEHIWoBisjy1UYBk3BapYW4fPT6q6G02F5MYQdGmk3NMmozrs6Fy4IU3csFW8NbvJw8HDnx2FrcPboqLYrOxVGMo26StHa15mYLYvUWTw/pgtyb3aPQbQgDKC2X27k4TcVjktVcjefCC0+GF67sLbi/HGJCR1tiFIJ8hO8BUm0t2WjmML559vd0oDY9KDBRGzGKSXf8kZiMHlZ5/xYaI+sqqPN5Be3Xve20L41A1XI4FCdPIVOTIrLYCIMUjGQp6ZKhiWgoVmgodJ9fnBr8+tFG89Z60qhSKyZwOgncIEXFtrTgfHPkAOgsGoEw6HvXpfnh/S5ScjzUE90CUme+mV5mSiawXpwpoh2tQuXhiSDfZVW0xaoF/vBEd6ft3l+uLJvbx2IHrIgI75WnBww1rm44zGjyytMCRJ5m2oM0j4RJhefykmxBSp6BPtdKUnWWAPh8jmiIIu9MGHez5dQzACDkK4EchnMhWxfEchJTwcDD6M7+Rin3/lUWMAqI6FcaQOh1FDi2QIBoTaXNqEMFhO+/P+ZP8ERZQ60Wz10oXBhgjSEs75jmB6EthpcaEVCy29nvj5PgVLWWlGZmgN/kk0MhZNmZVmJLCUXgO1qta7o2+fhcHKnnj9gygXRu5zlx3pKy2ZIJCuliP7r6NOO9h+s/fsBMLnGw1yZbLT/wpf8zd60xbZ1n+JMWS16Hb9jYxld8N3BsB2Njjo2xMbapzbBwXSAmJSZts7Ky4YRsiI4UAxFCFCVpCBtQOVkZYZCFiIaQG6CQCHJpmLpEWbo0apaFaNKaLlK0TauWXzvfsU1sIAH1D+bnOfZ3fF7e6/PeUoqKOvu6u3si/g6DNne/2hq5kyUMOHANaqgWpyCJ1bxb/YV6QJq4sH8symBCipvKId2+Nz/fsYz7SKiCXbMzM3ObADsQtzSAQz/6w5tvvQsZY8sJduLiVJd2oMe/3hk+aZ7xSPOJCJsIkLn6q/S4ZsgULGwiepiKFXPDHZbB85hpyts/2hrhIblMzGUJhp7fmpkD1qg1A6aDS/PffTewCTPDib/53RfvHHrj45+//j54+1dvPalMTOlnhDrU1rUWLqy8JsArwlkBXXZg54ciXe3yDSON4kABqQAHPDPy7DG8wuUZGMPc2tOjN/dHHinj1uUBVtfwzKyB9WlfFwdkOfwM2+75f/7v1s3NGKb+9usfvAG2bXuz4T3wg4afrS5ntfHUiGYlGSRqmmeNCXAZFp1fDqpqULIK5EvxL+VwZXeXK0FI7K4ahEHA8Uoet5+KqSXe5yMf5hGzNEVOwIEyZTDJnAResP1YHqFzb/PnpNnwfHjg/mYo39/++v13tvyi4ZfbPgBxSX1bpgqN8gVfKNEGVnzJcUcP+WEAAAqESURBVCLHj6zuHRaQgZGOuSDcv9LYiJqpoWhIpqJn410xLcWj7gIK3sL0QAmq6VBn4kqH078vKCs/GuyKCE/WxO3FBZI2GMwllB5u28vKHjtnZ21Kwu2nH//w9w1f+D76SQSoilwUkS2IFBD9iJYBKAvfOFaOz8/tuAxqdKs5RsGnYgYtW1kpVlqAx6Nnmw2KpvOUmHXOUgRCFkw6Zr419d/pjIz51wdPHQt4m0+1RhT2wszzW7cBqryq8+UONmEshcJ/zuZXbf6LaYdmpLYQOLk+nrJEowF5welm1Uqwwdt4nF27Rqxgxr3XkB1UXDVZCoDGAcQqVcqyMyQJ2a1govuKWNp/SUzHUXfU39VUbTm9N1of+2hm/vF9oLLk4DBGThSu2GzCvPZJQ7YL9u3lk1lp1FQek+MmiwlT4aGHq3Im5h3Cly8NEsvJtCp+odKL5OBYDYUSn6nKmJiwMsjqADPWdeEPgNRoWhuIz9zFnq+psipUICWgVAZSkoEweC+BAobVASrVBOvkDAoBmLvRHi3LFGRucDZXqh7yXXotpEt+qT89tzSikFD4mgvD4Sk01VG4jEMUUwSyurhCRYPUza7DPM2WPWcZO51JQZhPSoUaCr6P1wp/KIuNYCGv/+99EakJBXcfiW3o5mx4yRSeNaFDHBANUBRaCTg+NDyFw1Zbi2tMUMhIfoo8rlJUrNAigizACBTWX5RrfcnBMU9c/uVhSDxvrS0bo5J83xW8kJPQddP64EjEgffvHdvoYLc8hcmt1kI6qkrvi1xagJb8G38GqlWX0ZdD8RReDOMzyoFQA2zyzk9ryqLgclKIEhZfn4ZbbxjKAB/PipR/2M/H+cO9f3LyQsTCDB6YPCja2JloOd+bh3/fPvgfsD0yDwVnFLKZpeFH6UviU+XRoMlKK/NWARHzMj4yQ+IkJkt9TFbHjWOY7Bio2yuoOARg5UUdvPzBE1FofPuBZ5PX1j/PkID0FihrA1xobARqBVxyIlDX/YOsjPBMphzdETNzVpeOATLI0lKMsYwjPXxxkmC+aNepY/Cli6lqGBr71gQeZnsnP1vvNB6bRk6oMs91+WFqJgsxp6lxpNPjAu5In5KMuUv3ostAtDDny7VAGgYax3vcWT9OCsLoOxrtuAIWucUAraXI19ImqiMn19u1ml1nFqtWLBInSAhwQZwIhPCSWK29mAZztSgjxY6Ql8Pv3KX5+QdR4tY3n6dQv04GzBcdGz98McreOnF+/6VB9loflfjWO6zIDFf4JhRfFSA0CxZjldfRFLgnyCn0wHAhm4LwcxgvArK/3Xo+8yAmjRXa4Hhy7D65tu/GWJZTQiLRZDo7bw9exfF9/iyqDHNdAlulKIy2AB8zNIaSGFk5KuwTncIMoTzucw+XHh/HOM3Hw23SxI325Nh9ghY3SW8v3RlkkSXFWmD0ru44sUlDG5iubkSU7ERxQ+WY2ogHrAgOpZcrAwFPuj1hO3RJKFAC0M4+F7AaUf3e9qTIEgDCwvR0+OnTIUEtl7p9zY+5aVXsDTh4vlWpumyat5IWd9VWnW1QmEGGh1bFC3heQEFVzbsP6nNGDjel06srgLkpKXQMsI3/9+lQ+9AkA4isLzE39G9GpN/rATZpYfT1cSCUoFMilVA9oyS5K4+KeUYZeuxGaseAePR0ruVbtu7cBdi7kxzmmjC7uHRcX8B4iTcC/8o6Li1jCRvz8lZekNa7oHigOdFjjF1nL9uFQEKha1OAD9nd23yNRaMLT1zfKUuKWOk9p0MABL134y8K65grOUcycp0mecU5zsSbAraiMpE06bSpo/EgO/Gr4XvdynwQGrwM8WJjfWMXB7QI0bzIcsbNx2Oe0DXIimLWHC6jKtaHI6qKopQFzFeZqoJ6akTDZuLgRHp1uUDtQYFt4quYftEr7sdWuhZQ5DzAWFpcPCXF3N3uOwhU2IyY72QgpJlKNp8w7z6Ri3QrFmimU3nLCJ766OFeJ2HdY/wXm3C6ZVIrYNeg14HpDqUBnBmO9AhiTqPJRfVGiUSWVTCBrXsmPM4CHPqVUx04AMGTRW5nFPV3cZNgeNehAKUzsS5cQjTTo2M5MCNyZzE8/ei19Y4pD+6HW7pIFCNwYUTxlgOiqNQKvpwOX4dU1dNk3III/pIZMNJaTBbouoyegcPVdR0wYvLtCO47ictv1cG2Axc1yaB8E3UBKbRTLiHFlG9W/+S9xfAlAmH7qzEHTn0jNFoiOgDMFgAKtaBmj5AAnKPDA6mAx8q3gFxm1O6X0QKKPTCgkuDCJ7I7oE42B88+G8WjS+bDS+37+/6YRI1cxRoo65lKcQVzOUdLdB0MD7ems9SNe169RJXnhrTkIGKHnARaqHqAFwicGQoPoAvtJ3lsrdpDABxtyCsE2grS6oFDoebe2604mxYrSxvvtP0peQhTQK9EMG5Pq/YIkbhfJViYEwDH0baRDczGAEQvV469NCx/F9Ax94QzO9WS0xYe+nNGhXkrAHZNURHZQlnLh3aOtTZF43JOWv+BR39Jng63HScfjUB5cdq1q6oTixv71Os5vnjWI8UKma2cVlzixrcFYsrJ2bb4eCqipApN7sL0zLXdITQOAi7r6f86Wao2DeYjvc3qBB1cEPdTjeXrbVwyNnGXB4kSVVo6M1YiS7jWHite89QaKRBxePkpIs01+NQ0QVJUbaIyaea5w6OTPdbcF4qER6XzZd6NDLpOd2Nvymm9MYXEVXvG81fml1H9nkajyoDt+u7P9OD/7Z3Ni9NAFMDHBKfNZi8Lgofdg3+Al1VYqAcPXhxhIJKdw6ABZVNSUtqwsM12U0QUQymLbCv4AS1aWZYgBQt78OBBhVxtGtxLD+2x9tibd9va6i7OVhCkFeZ3mTDvzRvmzUtmSB6Z1bu/Uhev35l0c+31zpPt0ao9c8fsFgA4fLS5tfnx/vuVg3t7hwfjmb66dvvW8trSzT9aWH3xdPkCuLzz4OE2U378dw5nBx668vbzy0uf9l69mVSeu3hjaRxs57e+vPs63B+vzDwBOq1ravitHwRBO6I1umGv15CFIZ1Wu9PBekc4FYxGRT8Iw5amB92wrR2TIjzWamdOtNL6YTfo9BrdcT+CoHey/XFTudFtBTpGWuvDrFelmCiK0CeKoviDCwgVBYojfJFAB/m+eCpmhYzKH00UqBzXJSVXnBg6CRloerIC4c8aKJKJ0qBWIWmbiLMOmOmI7jSpM/UQDCn394afA87/R931o64HHJd5s1cTBBhVkEuw9mFRyd3IJdZjrsPeBUqLSQMQ8zHbcI2YTWDMb9A4z6rxDC3QTJk1NtPKFDGVaCTCkG4UIxrS7F1BZ449cVSkqilkKcvlKSGnZlUX0+rceqZSwKKlWj5lSl074iWwAHTWx7naPh6exwNLBkOYzGDVzCEEaJ21SmoZChBKuuV59UtMNjRDLsuSypx1BK20bSGPMnKCF5vFFEpiuYC934ULBj7KVxIR6uQJIxThmVTeoaW0bc6rY7x9NYnsdRvVWFIdpZuqBuOU9SyAWbUap14NWewk83i9hJsGZQ09amHJoC5RZ/6iag5Z4C7gcDgcDofD4XA4nH/Bd9ZGnZKsc79tAAAAAElFTkSuQmCC)

Segment human cells (in mitosis)

## marching_cubes

`skimage.measure.marching_cubes(volume, level=None, *, spacing=(1.0, 1.0,
1.0), gradient_direction='descent', step_size=1, allow_degenerate=True,
method='lewiner', mask=None)` [source]

    
Marching cubes algorithm to find surfaces in 3d volumetric data.

In contrast with Lorensen et al. approach [2], Lewiner et al. algorithm is
faster, resolves ambiguities, and guarantees topologically correct results.
Therefore, this algorithm generally a better choice.

Parameters

    
`volume(M, N, P) array`

    
Input data volume to find isosurfaces. Will internally be converted to float32
if necessary.

`levelfloat, optional`

    
Contour value to search for isosurfaces in `volume`. If not given or None, the
average of the min and max of vol is used.

`spacinglength-3 tuple of floats, optional`

    
Voxel spacing in spatial dimensions corresponding to numpy array indexing
dimensions (M, N, P) as in `volume`.

`gradient_directionstring, optional`

    
Controls if the mesh was generated from an isosurface with gradient descent
toward objects of interest (the default), or the opposite, considering the
left-hand rule. The two options are: * descent : Object was greater than
exterior * ascent : Exterior was greater than object

`step_sizeint, optional`

    
Step size in voxels. Default 1. Larger steps yield faster but coarser results.
The result will always be topologically correct though.

`allow_degeneratebool, optional`

    
Whether to allow degenerate (i.e. zero-area) triangles in the end-result.
Default True. If False, degenerate triangles are removed, at the cost of
making the algorithm slower.

method: str, optional

    
One of ‘lewiner’, ‘lorensen’ or ‘_lorensen’. Specify witch of Lewiner et al.
or Lorensen et al. method will be used. The ‘_lorensen’ flag correspond to an
old implementation that will be deprecated in version 0.19.

`mask(M, N, P) array, optional`

    
Boolean array. The marching cube algorithm will be computed only on True
elements. This will save computational time when interfaces are located within
certain region of the volume M, N, P-e.g. the top half of the cube-and also
allow to compute finite surfaces-i.e. open surfaces that do not end at the
border of the cube.

Returns

    
`verts(V, 3) array`

    
Spatial coordinates for V unique mesh vertices. Coordinate order matches input
`volume` (M, N, P). If `allow_degenerate` is set to True, then the presence of
degenerate triangles in the mesh can make this array have duplicate vertices.

`faces(F, 3) array`

    
Define triangular faces via referencing vertex indices from `verts`. This
algorithm specifically outputs triangles, so each face has exactly three
indices.

`normals(V, 3) array`

    
The normal direction at each vertex, as calculated from the data.

`values(V, ) array`

    
Gives a measure for the maximum value of the data in the local region near
each vertex. This can be used by visualization tools to apply a colormap to
the mesh.

See also

`skimage.measure.mesh_surface_area`

`skimage.measure.find_contours`

#### Notes

The algorithm [1] is an improved version of Chernyaev’s Marching Cubes 33
algorithm. It is an efficient algorithm that relies on heavy use of lookup
tables to handle the many different cases, keeping the algorithm relatively
easy. This implementation is written in Cython, ported from Lewiner’s C++
implementation.

To quantify the area of an isosurface generated by this algorithm, pass verts
and faces to `skimage.measure.mesh_surface_area`.

Regarding visualization of algorithm output, to contour a volume named
`myvolume` about the level 0.0, using the `mayavi` package:

    
    >>>
    >> from mayavi import mlab
    >> verts, faces, _, _ = marching_cubes(myvolume, 0.0)
    >> mlab.triangular_mesh([vert[0] for vert in verts],
                            [vert[1] for vert in verts],
                            [vert[2] for vert in verts],
                            faces)
    >> mlab.show()
    
Similarly using the `visvis` package:

    
    >>>
    >> import visvis as vv
    >> verts, faces, normals, values = marching_cubes(myvolume, 0.0)
    >> vv.mesh(np.fliplr(verts), faces, normals, values)
    >> vv.use().Run()
    
To reduce the number of triangles in the mesh for better performance, see this
example using the `mayavi` package.

#### References

`1`

    
Thomas Lewiner, Helio Lopes, Antonio Wilson Vieira and Geovan Tavares.
Efficient implementation of Marching Cubes’ cases with topological guarantees.
Journal of Graphics Tools 8(2) pp. 1-15 (december 2003).
DOI:10.1080/10867651.2003.10487582

`2`

    
Lorensen, William and Harvey E. Cline. Marching Cubes: A High Resolution 3D
Surface Construction Algorithm. Computer Graphics (SIGGRAPH 87 Proceedings)
21(4) July 1987, p. 163-170). DOI:10.1145/37401.37422

## marching_cubes_classic

`skimage.measure.marching_cubes_classic(volume, level=None, spacing=(1.0, 1.0,
1.0), gradient_direction='descent')` [source]

    
Classic marching cubes algorithm to find surfaces in 3d volumetric data.

Note that the `marching_cubes()` algorithm is recommended over this algorithm,
because it’s faster and produces better results.

Parameters

    
`volume(M, N, P) array of doubles`

    
Input data volume to find isosurfaces. Will be cast to `np.float64`.

`levelfloat`

    
Contour value to search for isosurfaces in `volume`. If not given or None, the
average of the min and max of vol is used.

`spacinglength-3 tuple of floats`

    
Voxel spacing in spatial dimensions corresponding to numpy array indexing
dimensions (M, N, P) as in `volume`.

`gradient_directionstring`

    
Controls if the mesh was generated from an isosurface with gradient descent
toward objects of interest (the default), or the opposite. The two options
are: * descent : Object was greater than exterior * ascent : Exterior was
greater than object

Returns

    
`verts(V, 3) array`

    
Spatial coordinates for V unique mesh vertices. Coordinate order matches input
`volume` (M, N, P). If `allow_degenerate` is set to True, then the presence of
degenerate triangles in the mesh can make this array have duplicate vertices.

`faces(F, 3) array`

    
Define triangular faces via referencing vertex indices from `verts`. This
algorithm specifically outputs triangles, so each face has exactly three
indices.

See also

`skimage.measure.marching_cubes`

`skimage.measure.mesh_surface_area`

#### Notes

The marching cubes algorithm is implemented as described in [1]. A simple
explanation is available here:

    
    http://users.polytech.unice.fr/~lingrand/MarchingCubes/algo.html
    
There are several known ambiguous cases in the marching cubes algorithm. Using
point labeling as in [1], Figure 4, as shown:

    
        v8 ------ v7
       / |       / |        y
      /  |      /  |        ^  z
    v4 ------ v3   |        | /
     |  v5 ----|- v6        |/          (note: NOT right handed!)
     |  /      |  /          ----> x
     | /       | /
    v1 ------ v2
    
Most notably, if v4, v8, v2, and v6 are all >= `level` (or any generalization
of this case) two parallel planes are generated by this algorithm, separating
v4 and v8 from v2 and v6. An equally valid interpretation would be a single
connected thin surface enclosing all four points. This is the best known
ambiguity, though there are others.

This algorithm does not attempt to resolve such ambiguities; it is a naive
implementation of marching cubes as in [1], but may be a good beginning for
work with more recent techniques (Dual Marching Cubes, Extended Marching
Cubes, Cubic Marching Squares, etc.).

Because of interactions between neighboring cubes, the isosurface(s) generated
by this algorithm are NOT guaranteed to be closed, particularly for
complicated contours. Furthermore, this algorithm does not guarantee a single
contour will be returned. Indeed, ALL isosurfaces which cross `level` will be
found, regardless of connectivity.

The output is a triangular mesh consisting of a set of unique vertices and
connecting triangles. The order of these vertices and triangles in the output
list is determined by the position of the smallest `x,y,z` (in lexicographical
order) coordinate in the contour. This is a side-effect of how the input array
is traversed, but can be relied upon.

The generated mesh guarantees coherent orientation as of version 0.12.

To quantify the area of an isosurface generated by this algorithm, pass
outputs directly into `skimage.measure.mesh_surface_area`.

#### References

`1(1,2,3)`

    
Lorensen, William and Harvey E. Cline. Marching Cubes: A High Resolution 3D
Surface Construction Algorithm. Computer Graphics (SIGGRAPH 87 Proceedings)
21(4) July 1987, p. 163-170). DOI:10.1145/37401.37422

## marching_cubes_lewiner

`skimage.measure.marching_cubes_lewiner(volume, level=None, spacing=(1.0, 1.0,
1.0), gradient_direction='descent', step_size=1, allow_degenerate=True,
use_classic=False, mask=None)` [source]

    
Lewiner marching cubes algorithm to find surfaces in 3d volumetric data.

In contrast to `marching_cubes_classic()`, this algorithm is faster, resolves
ambiguities, and guarantees topologically correct results. Therefore, this
algorithm generally a better choice, unless there is a specific need for the
classic algorithm.

Parameters

    
`volume(M, N, P) array`

    
Input data volume to find isosurfaces. Will internally be converted to float32
if necessary.

`levelfloat`

    
Contour value to search for isosurfaces in `volume`. If not given or None, the
average of the min and max of vol is used.

`spacinglength-3 tuple of floats`

    
Voxel spacing in spatial dimensions corresponding to numpy array indexing
dimensions (M, N, P) as in `volume`.

`gradient_directionstring`

    
Controls if the mesh was generated from an isosurface with gradient descent
toward objects of interest (the default), or the opposite, considering the
left-hand rule. The two options are: * descent : Object was greater than
exterior * ascent : Exterior was greater than object

`step_sizeint`

    
Step size in voxels. Default 1. Larger steps yield faster but coarser results.
The result will always be topologically correct though.

`allow_degeneratebool`

    
Whether to allow degenerate (i.e. zero-area) triangles in the end-result.
Default True. If False, degenerate triangles are removed, at the cost of
making the algorithm slower.

`use_classicbool`

    
If given and True, the classic marching cubes by Lorensen (1987) is used. This
option is included for reference purposes. Note that this algorithm has
ambiguities and is not guaranteed to produce a topologically correct result.
The results with using this option are not generally the same as the
`marching_cubes_classic()` function.

`mask(M, N, P) array`

    
Boolean array. The marching cube algorithm will be computed only on True
elements. This will save computational time when interfaces are located within
certain region of the volume M, N, P-e.g. the top half of the cube-and also
allow to compute finite surfaces-i.e. open surfaces that do not end at the
border of the cube.

Returns

    
`verts(V, 3) array`

    
Spatial coordinates for V unique mesh vertices. Coordinate order matches input
`volume` (M, N, P). If `allow_degenerate` is set to True, then the presence of
degenerate triangles in the mesh can make this array have duplicate vertices.

`faces(F, 3) array`

    
Define triangular faces via referencing vertex indices from `verts`. This
algorithm specifically outputs triangles, so each face has exactly three
indices.

`normals(V, 3) array`

    
The normal direction at each vertex, as calculated from the data.

`values(V, ) array`

    
Gives a measure for the maximum value of the data in the local region near
each vertex. This can be used by visualization tools to apply a colormap to
the mesh.

See also

`skimage.measure.marching_cubes`

`skimage.measure.mesh_surface_area`

#### Notes

The algorithm [1] is an improved version of Chernyaev’s Marching Cubes 33
algorithm. It is an efficient algorithm that relies on heavy use of lookup
tables to handle the many different cases, keeping the algorithm relatively
easy. This implementation is written in Cython, ported from Lewiner’s C++
implementation.

To quantify the area of an isosurface generated by this algorithm, pass verts
and faces to `skimage.measure.mesh_surface_area`.

Regarding visualization of algorithm output, to contour a volume named
`myvolume` about the level 0.0, using the `mayavi` package:

    
    >>> from mayavi import mlab 
    >>> verts, faces, normals, values = marching_cubes_lewiner(myvolume, 0.0) 
    >>> mlab.triangular_mesh([vert[0] for vert in verts],
    ...                      [vert[1] for vert in verts],
    ...                      [vert[2] for vert in verts],
    ...                      faces) 
    >>> mlab.show() 
    
Similarly using the `visvis` package:

    
    >>> import visvis as vv 
    >>> verts, faces, normals, values = marching_cubes_lewiner(myvolume, 0.0) 
    >>> vv.mesh(np.fliplr(verts), faces, normals, values) 
    >>> vv.use().Run() 
    
#### References

`1`

    
Thomas Lewiner, Helio Lopes, Antonio Wilson Vieira and Geovan Tavares.
Efficient implementation of Marching Cubes’ cases with topological guarantees.
Journal of Graphics Tools 8(2) pp. 1-15 (december 2003).
DOI:10.1080/10867651.2003.10487582

## mesh_surface_area

`skimage.measure.mesh_surface_area(verts, faces)` [source]

    
Compute surface area, given vertices & triangular faces

Parameters

    
`verts(V, 3) array of floats`

    
Array containing (x, y, z) coordinates for V unique mesh vertices.

`faces(F, 3) array of ints`

    
List of length-3 lists of integers, referencing vertex coordinates as provided
in `verts`

Returns

    
`areafloat`

    
Surface area of mesh. Units now [coordinate units] ** 2.

See also

`skimage.measure.marching_cubes`

`skimage.measure.marching_cubes_classic`

#### Notes

The arguments expected by this function are the first two outputs from
`skimage.measure.marching_cubes`. For unit correct output, ensure correct
`spacing` was passed to `skimage.measure.marching_cubes`.

This algorithm works properly only if the `faces` provided are all triangles.

## moments

`skimage.measure.moments(image, order=3)` [source]

    
Calculate all raw image moments up to a certain order.

The following properties can be calculated from raw image moments:

    
  * Area as: `M[0, 0]`.
  * Centroid as: {`M[1, 0] / M[0, 0]`, `M[0, 1] / M[0, 0]`}.

Note that raw moments are neither translation, scale nor rotation invariant.

Parameters

    
`imagenD double or uint8 array`

    
Rasterized shape as image.

`orderint, optional`

    
Maximum order of moments. Default is 3.

Returns

    
`m(order + 1, order + 1) array`

    
Raw image moments.

#### References

`1`

    
Wilhelm Burger, Mark Burge. Principles of Digital Image Processing: Core
Algorithms. Springer-Verlag, London, 2009.

`2`

    
B. Jähne. Digital Image Processing. Springer-Verlag, Berlin-Heidelberg, 6.
edition, 2005.

`3`

    
T. H. Reiss. Recognizing Planar Objects Using Invariant Image Features, from
Lecture notes in computer science, p. 676. Springer, Berlin, 1993.

`4`

    
https://en.wikipedia.org/wiki/Image_moment

#### Examples

    
    >>> image = np.zeros((20, 20), dtype=np.double)
    >>> image[13:17, 13:17] = 1
    >>> M = moments(image)
    >>> centroid = (M[1, 0] / M[0, 0], M[0, 1] / M[0, 0])
    >>> centroid
    (14.5, 14.5)
    
## moments_central

`skimage.measure.moments_central(image, center=None, order=3, **kwargs)`
[source]

    
Calculate all central image moments up to a certain order.

The center coordinates (cr, cc) can be calculated from the raw moments as:
{`M[1, 0] / M[0, 0]`, `M[0, 1] / M[0, 0]`}.

Note that central moments are translation invariant but not scale and rotation
invariant.

Parameters

    
`imagenD double or uint8 array`

    
Rasterized shape as image.

`centertuple of float, optional`

    
Coordinates of the image centroid. This will be computed if it is not
provided.

`orderint, optional`

    
The maximum order of moments computed.

Returns

    
`mu(order + 1, order + 1) array`

    
Central image moments.

#### References

`1`

    
Wilhelm Burger, Mark Burge. Principles of Digital Image Processing: Core
Algorithms. Springer-Verlag, London, 2009.

`2`

    
B. Jähne. Digital Image Processing. Springer-Verlag, Berlin-Heidelberg, 6.
edition, 2005.

`3`

    
T. H. Reiss. Recognizing Planar Objects Using Invariant Image Features, from
Lecture notes in computer science, p. 676. Springer, Berlin, 1993.

`4`

    
https://en.wikipedia.org/wiki/Image_moment

#### Examples

    
    >>> image = np.zeros((20, 20), dtype=np.double)
    >>> image[13:17, 13:17] = 1
    >>> M = moments(image)
    >>> centroid = (M[1, 0] / M[0, 0], M[0, 1] / M[0, 0])
    >>> moments_central(image, centroid)
    array([[16.,  0., 20.,  0.],
           [ 0.,  0.,  0.,  0.],
           [20.,  0., 25.,  0.],
           [ 0.,  0.,  0.,  0.]])
    
## moments_coords

`skimage.measure.moments_coords(coords, order=3)` [source]

    
Calculate all raw image moments up to a certain order.

The following properties can be calculated from raw image moments:

    
  * Area as: `M[0, 0]`.
  * Centroid as: {`M[1, 0] / M[0, 0]`, `M[0, 1] / M[0, 0]`}.

Note that raw moments are neither translation, scale nor rotation invariant.

Parameters

    
`coords(N, D) double or uint8 array`

    
Array of N points that describe an image of D dimensionality in Cartesian
space.

`orderint, optional`

    
Maximum order of moments. Default is 3.

Returns

    
`M(order + 1, order + 1, …) array`

    
Raw image moments. (D dimensions)

#### References

`1`

    
Johannes Kilian. Simple Image Analysis By Moments. Durham University, version
0.2, Durham, 2001.

#### Examples

    
    >>> coords = np.array([[row, col]
    ...                    for row in range(13, 17)
    ...                    for col in range(14, 18)], dtype=np.double)
    >>> M = moments_coords(coords)
    >>> centroid = (M[1, 0] / M[0, 0], M[0, 1] / M[0, 0])
    >>> centroid
    (14.5, 15.5)
    
## moments_coords_central

`skimage.measure.moments_coords_central(coords, center=None, order=3)`
[source]

    
Calculate all central image moments up to a certain order.

The following properties can be calculated from raw image moments:

    
  * Area as: `M[0, 0]`.
  * Centroid as: {`M[1, 0] / M[0, 0]`, `M[0, 1] / M[0, 0]`}.

Note that raw moments are neither translation, scale nor rotation invariant.

Parameters

    
`coords(N, D) double or uint8 array`

    
Array of N points that describe an image of D dimensionality in Cartesian
space. A tuple of coordinates as returned by `np.nonzero` is also accepted as
input.

`centertuple of float, optional`

    
Coordinates of the image centroid. This will be computed if it is not
provided.

`orderint, optional`

    
Maximum order of moments. Default is 3.

Returns

    
`Mc(order + 1, order + 1, …) array`

    
Central image moments. (D dimensions)

#### References

`1`

    
Johannes Kilian. Simple Image Analysis By Moments. Durham University, version
0.2, Durham, 2001.

#### Examples

    
    >>> coords = np.array([[row, col]
    ...                    for row in range(13, 17)
    ...                    for col in range(14, 18)])
    >>> moments_coords_central(coords)
    array([[16.,  0., 20.,  0.],
           [ 0.,  0.,  0.,  0.],
           [20.,  0., 25.,  0.],
           [ 0.,  0.,  0.,  0.]])
    
As seen above, for symmetric objects, odd-order moments (columns 1 and 3, rows
1 and 3) are zero when centered on the centroid, or center of mass, of the
object (the default). If we break the symmetry by adding a new point, this no
longer holds:

    
    >>> coords2 = np.concatenate((coords, [[17, 17]]), axis=0)
    >>> np.round(moments_coords_central(coords2),
    ...          decimals=2)  
    array([[17.  ,  0.  , 22.12, -2.49],
           [ 0.  ,  3.53,  1.73,  7.4 ],
           [25.88,  6.02, 36.63,  8.83],
           [ 4.15, 19.17, 14.8 , 39.6 ]])
    
Image moments and central image moments are equivalent (by definition) when
the center is (0, 0):

    
    >>> np.allclose(moments_coords(coords),
    ...             moments_coords_central(coords, (0, 0)))
    True
    
## moments_hu

`skimage.measure.moments_hu(nu)` [source]

    
Calculate Hu’s set of image moments (2D-only).

Note that this set of moments is proofed to be translation, scale and rotation
invariant.

Parameters

    
`nu(M, M) array`

    
Normalized central image moments, where M must be >= 4.

Returns

    
`nu(7,) array`

    
Hu’s set of image moments.

#### References

`1`

    
M. K. Hu, “Visual Pattern Recognition by Moment Invariants”, IRE Trans. Info.
Theory, vol. IT-8, pp. 179-187, 1962

`2`

    
Wilhelm Burger, Mark Burge. Principles of Digital Image Processing: Core
Algorithms. Springer-Verlag, London, 2009.

`3`

    
B. Jähne. Digital Image Processing. Springer-Verlag, Berlin-Heidelberg, 6.
edition, 2005.

`4`

    
T. H. Reiss. Recognizing Planar Objects Using Invariant Image Features, from
Lecture notes in computer science, p. 676. Springer, Berlin, 1993.

`5`

    
https://en.wikipedia.org/wiki/Image_moment

#### Examples

    
    >>> image = np.zeros((20, 20), dtype=np.double)
    >>> image[13:17, 13:17] = 0.5
    >>> image[10:12, 10:12] = 1
    >>> mu = moments_central(image)
    >>> nu = moments_normalized(mu)
    >>> moments_hu(nu)
    array([7.45370370e-01, 3.51165981e-01, 1.04049179e-01, 4.06442107e-02,
           2.64312299e-03, 2.40854582e-02, 4.33680869e-19])
    
## moments_normalized

`skimage.measure.moments_normalized(mu, order=3)` [source]

    
Calculate all normalized central image moments up to a certain order.

Note that normalized central moments are translation and scale invariant but
not rotation invariant.

Parameters

    
`mu(M,[ …,] M) array`

    
Central image moments, where M must be greater than or equal to `order`.

`orderint, optional`

    
Maximum order of moments. Default is 3.

Returns

    
`nu(order + 1,[ …,] order + 1) array`

    
Normalized central image moments.

#### References

`1`

    
Wilhelm Burger, Mark Burge. Principles of Digital Image Processing: Core
Algorithms. Springer-Verlag, London, 2009.

`2`

    
B. Jähne. Digital Image Processing. Springer-Verlag, Berlin-Heidelberg, 6.
edition, 2005.

`3`

    
T. H. Reiss. Recognizing Planar Objects Using Invariant Image Features, from
Lecture notes in computer science, p. 676. Springer, Berlin, 1993.

`4`

    
https://en.wikipedia.org/wiki/Image_moment

#### Examples

    
    >>> image = np.zeros((20, 20), dtype=np.double)
    >>> image[13:17, 13:17] = 1
    >>> m = moments(image)
    >>> centroid = (m[0, 1] / m[0, 0], m[1, 0] / m[0, 0])
    >>> mu = moments_central(image, centroid)
    >>> moments_normalized(mu)
    array([[       nan,        nan, 0.078125  , 0.        ],
           [       nan, 0.        , 0.        , 0.        ],
           [0.078125  , 0.        , 0.00610352, 0.        ],
           [0.        , 0.        , 0.        , 0.        ]])
    
## perimeter

`skimage.measure.perimeter(image, neighbourhood=4)` [source]

    
Calculate total perimeter of all objects in binary image.

Parameters

    
`image(N, M) ndarray`

    
2D binary image.

`neighbourhood4 or 8, optional`

    
Neighborhood connectivity for border pixel determination. It is used to
compute the contour. A higher neighbourhood widens the border on which the
perimeter is computed.

Returns

    
`perimeterfloat`

    
Total perimeter of all objects in binary image.

#### References

`1`

    
K. Benkrid, D. Crookes. Design and FPGA Implementation of a Perimeter
Estimator. The Queen’s University of Belfast.
http://www.cs.qub.ac.uk/~d.crookes/webpubs/papers/perimeter.doc

#### Examples

    
    >>> from skimage import data, util
    >>> from skimage.measure import label
    >>> # coins image (binary)
    >>> img_coins = data.coins() > 110
    >>> # total perimeter of all objects in the image
    >>> perimeter(img_coins, neighbourhood=4)  
    7796.867...
    >>> perimeter(img_coins, neighbourhood=8)  
    8806.268...
    
### Examples using `skimage.measure.perimeter`

![Different
perimeters](data:image/png;base64,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)

Different perimeters

## perimeter_crofton

`skimage.measure.perimeter_crofton(image, directions=4)` [source]

    
Calculate total Crofton perimeter of all objects in binary image.

Parameters

    
`image(N, M) ndarray`

    
2D image. If image is not binary, all values strictly greater than zero are
considered as the object.

`directions2 or 4, optional`

    
Number of directions used to approximate the Crofton perimeter. By default, 4
is used: it should be more accurate than 2. Computation time is the same in
both cases.

Returns

    
`perimeterfloat`

    
Total perimeter of all objects in binary image.

#### Notes

This measure is based on Crofton formula [1], which is a measure from integral
geometry. It is defined for general curve length evaluation via a double
integral along all directions. In a discrete space, 2 or 4 directions give a
quite good approximation, 4 being more accurate than 2 for more complex
shapes.

Similar to `perimeter()`, this function returns an approximation of the
perimeter in continuous space.

#### References

`1`

    
https://en.wikipedia.org/wiki/Crofton_formula

`2`

    
S. Rivollier. Analyse d’image geometrique et morphometrique par diagrammes de
forme et voisinages adaptatifs generaux. PhD thesis, 2010. Ecole Nationale
Superieure des Mines de Saint-Etienne. https://tel.archives-
ouvertes.fr/tel-00560838

#### Examples

    
    >>> from skimage import data, util
    >>> from skimage.measure import label
    >>> # coins image (binary)
    >>> img_coins = data.coins() > 110
    >>> # total perimeter of all objects in the image
    >>> perimeter_crofton(img_coins, directions=2)  
    8144.578...
    >>> perimeter_crofton(img_coins, directions=4)  
    7837.077...
    
### Examples using `skimage.measure.perimeter_crofton`

![Different
perimeters](data:image/png;base64,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)

Different perimeters

## points_in_poly

`skimage.measure.points_in_poly(points, verts)` [source]

    
Test whether points lie inside a polygon.

Parameters

    
`points(N, 2) array`

    
Input points, `(x, y)`.

`verts(M, 2) array`

    
Vertices of the polygon, sorted either clockwise or anti-clockwise. The first
point may (but does not need to be) duplicated.

Returns

    
`mask(N,) array of bool`

    
True if corresponding point is inside the polygon.

See also

`grid_points_in_poly`

## profile_line

`skimage.measure.profile_line(image, src, dst, linewidth=1, order=None,
mode=None, cval=0.0, *, reduce_func=<function mean>)` [source]

    
Return the intensity profile of an image measured along a scan line.

Parameters

    
`imagendarray, shape (M, N[, C])`

    
The image, either grayscale (2D array) or multichannel (3D array, where the
final axis contains the channel information).

`srcarray_like, shape (2, )`

    
The coordinates of the start point of the scan line.

`dstarray_like, shape (2, )`

    
The coordinates of the end point of the scan line. The destination point is
included in the profile, in contrast to standard numpy indexing.

`linewidthint, optional`

    
Width of the scan, perpendicular to the line

`orderint in {0, 1, 2, 3, 4, 5}, optional`

    
The order of the spline interpolation, default is 0 if image.dtype is bool and
1 otherwise. The order has to be in the range 0-5. See
`skimage.transform.warp` for detail.

`mode{‘constant’, ‘nearest’, ‘reflect’, ‘mirror’, ‘wrap’}, optional`

    
How to compute any values falling outside of the image.

`cvalfloat, optional`

    
If `mode` is ‘constant’, what constant value to use outside the image.

`reduce_funccallable, optional`

    
Function used to calculate the aggregation of pixel values perpendicular to
the profile_line direction when `linewidth` > 1\. If set to None the unreduced
array will be returned.

Returns

    
`return_valuearray`

    
The intensity profile along the scan line. The length of the profile is the
ceil of the computed length of the scan line.

#### Examples

    
    >>> x = np.array([[1, 1, 1, 2, 2, 2]])
    >>> img = np.vstack([np.zeros_like(x), x, x, x, np.zeros_like(x)])
    >>> img
    array([[0, 0, 0, 0, 0, 0],
           [1, 1, 1, 2, 2, 2],
           [1, 1, 1, 2, 2, 2],
           [1, 1, 1, 2, 2, 2],
           [0, 0, 0, 0, 0, 0]])
    >>> profile_line(img, (2, 1), (2, 4))
    array([1., 1., 2., 2.])
    >>> profile_line(img, (1, 0), (1, 6), cval=4)
    array([1., 1., 1., 2., 2., 2., 4.])
    
The destination point is included in the profile, in contrast to standard
numpy indexing. For example:

    
    >>> profile_line(img, (1, 0), (1, 6))  # The final point is out of bounds
    array([1., 1., 1., 2., 2., 2., 0.])
    >>> profile_line(img, (1, 0), (1, 5))  # This accesses the full first row
    array([1., 1., 1., 2., 2., 2.])
    
For different reduce_func inputs:

    
    >>> profile_line(img, (1, 0), (1, 3), linewidth=3, reduce_func=np.mean)
    array([0.66666667, 0.66666667, 0.66666667, 1.33333333])
    >>> profile_line(img, (1, 0), (1, 3), linewidth=3, reduce_func=np.max)
    array([1, 1, 1, 2])
    >>> profile_line(img, (1, 0), (1, 3), linewidth=3, reduce_func=np.sum)
    array([2, 2, 2, 4])
    
The unreduced array will be returned when `reduce_func` is None or when
`reduce_func` acts on each pixel value individually.

    
    >>> profile_line(img, (1, 2), (4, 2), linewidth=3, order=0,
    ...     reduce_func=None)
    array([[1, 1, 2],
           [1, 1, 2],
           [1, 1, 2],
           [0, 0, 0]])
    >>> profile_line(img, (1, 0), (1, 3), linewidth=3, reduce_func=np.sqrt)
    array([[1.        , 1.        , 0.        ],
           [1.        , 1.        , 0.        ],
           [1.        , 1.        , 0.        ],
           [1.41421356, 1.41421356, 0.        ]])
    
## ransac

`skimage.measure.ransac(data, model_class, min_samples, residual_threshold,
is_data_valid=None, is_model_valid=None, max_trials=100, stop_sample_num=inf,
stop_residuals_sum=0, stop_probability=1, random_state=None,
initial_inliers=None)` [source]

    
Fit a model to data with the RANSAC (random sample consensus) algorithm.

RANSAC is an iterative algorithm for the robust estimation of parameters from
a subset of inliers from the complete data set. Each iteration performs the
following tasks:

  1. Select `min_samples` random samples from the original data and check whether the set of data is valid (see `is_data_valid`).
  2. Estimate a model to the random subset (`model_cls.estimate(*data[random_subset]`) and check whether the estimated model is valid (see `is_model_valid`).
  3. Classify all data as inliers or outliers by calculating the residuals to the estimated model (`model_cls.residuals(*data)`) - all data samples with residuals smaller than the `residual_threshold` are considered as inliers.
  4. Save estimated model as best model if number of inlier samples is maximal. In case the current estimated model has the same number of inliers, it is only considered as the best model if it has less sum of residuals.

These steps are performed either a maximum number of times or until one of the
special stop criteria are met. The final model is estimated using all inlier
samples of the previously determined best model.

Parameters

    
`data[list, tuple of] (N, …) array`

    
Data set to which the model is fitted, where N is the number of data points
and the remaining dimension are depending on model requirements. If the model
class requires multiple input data arrays (e.g. source and destination
coordinates of `skimage.transform.AffineTransform`), they can be optionally
passed as tuple or list. Note, that in this case the functions
`estimate(*data)`, `residuals(*data)`, `is_model_valid(model, *random_data)`
and `is_data_valid(*random_data)` must all take each data array as separate
arguments.

`model_classobject`

    
Object with the following object methods:

  * `success = estimate(*data)`
  * `residuals(*data)`

where `success` indicates whether the model estimation succeeded (`True` or
`None` for success, `False` for failure).

`min_samplesint in range (0, N)`

    
The minimum number of data points to fit a model to.

`residual_thresholdfloat larger than 0`

    
Maximum distance for a data point to be classified as an inlier.

`is_data_validfunction, optional`

    
This function is called with the randomly selected data before the model is
fitted to it: `is_data_valid(*random_data)`.

`is_model_validfunction, optional`

    
This function is called with the estimated model and the randomly selected
data: `is_model_valid(model, *random_data)`, .

`max_trialsint, optional`

    
Maximum number of iterations for random sample selection.

`stop_sample_numint, optional`

    
Stop iteration if at least this number of inliers are found.

`stop_residuals_sumfloat, optional`

    
Stop iteration if sum of residuals is less than or equal to this threshold.

`stop_probabilityfloat in range [0, 1], optional`

    
RANSAC iteration stops if at least one outlier-free set of the training data
is sampled with `probability >= stop_probability`, depending on the current
best model’s inlier ratio and the number of trials. This requires to generate
at least N samples (trials):

N >= log(1 - probability) / log(1 - e**m)

where the probability (confidence) is typically set to a high value such as
0.99, e is the current fraction of inliers w.r.t. the total number of samples,
and m is the min_samples value.

`random_stateint, RandomState instance or None, optional`

    
If int, random_state is the seed used by the random number generator; If
RandomState instance, random_state is the random number generator; If None,
the random number generator is the RandomState instance used by `np.random`.

`initial_inliersarray-like of bool, shape (N,), optional`

    
Initial samples selection for model estimation

Returns

    
`modelobject`

    
Best model with largest consensus set.

`inliers(N, ) array`

    
Boolean mask of inliers classified as `True`.

#### References

`1`

    
“RANSAC”, Wikipedia, https://en.wikipedia.org/wiki/RANSAC

#### Examples

Generate ellipse data without tilt and add noise:

    
    >>> t = np.linspace(0, 2 * np.pi, 50)
    >>> xc, yc = 20, 30
    >>> a, b = 5, 10
    >>> x = xc + a * np.cos(t)
    >>> y = yc + b * np.sin(t)
    >>> data = np.column_stack([x, y])
    >>> np.random.seed(seed=1234)
    >>> data += np.random.normal(size=data.shape)
    
Add some faulty data:

    
    >>> data[0] = (100, 100)
    >>> data[1] = (110, 120)
    >>> data[2] = (120, 130)
    >>> data[3] = (140, 130)
    
Estimate ellipse model using all available data:

    
    >>> model = EllipseModel()
    >>> model.estimate(data)
    True
    >>> np.round(model.params)  
    array([ 72.,  75.,  77.,  14.,   1.])
    
Estimate ellipse model using RANSAC:

    
    >>> ransac_model, inliers = ransac(data, EllipseModel, 20, 3, max_trials=50)
    >>> abs(np.round(ransac_model.params))
    array([20., 30.,  5., 10.,  0.])
    >>> inliers 
    array([False, False, False, False,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True], dtype=bool)
    >>> sum(inliers) > 40
    True
    
RANSAC can be used to robustly estimate a geometric transformation. In this
section, we also show how to use a proportion of the total samples, rather
than an absolute number.

    
    >>> from skimage.transform import SimilarityTransform
    >>> np.random.seed(0)
    >>> src = 100 * np.random.rand(50, 2)
    >>> model0 = SimilarityTransform(scale=0.5, rotation=1, translation=(10, 20))
    >>> dst = model0(src)
    >>> dst[0] = (10000, 10000)
    >>> dst[1] = (-100, 100)
    >>> dst[2] = (50, 50)
    >>> ratio = 0.5  # use half of the samples
    >>> min_samples = int(ratio * len(src))
    >>> model, inliers = ransac((src, dst), SimilarityTransform, min_samples, 10,
    ...                         initial_inliers=np.ones(len(src), dtype=bool))
    >>> inliers
    array([False, False, False,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True,  True,  True,  True,  True,
            True,  True,  True,  True,  True])
    
## regionprops

`skimage.measure.regionprops(label_image, intensity_image=None, cache=True,
coordinates=None, *, extra_properties=None)` [source]

    
Measure properties of labeled image regions.

Parameters

    
`label_image(M, N[, P]) ndarray`

    
Labeled input image. Labels with value 0 are ignored.

Changed in version 0.14.1: Previously, `label_image` was processed by
`numpy.squeeze` and so any number of singleton dimensions was allowed. This
resulted in inconsistent handling of images with singleton dimensions. To
recover the old behaviour, use `regionprops(np.squeeze(label_image), ...)`.

`intensity_image(M, N[, P][, C]) ndarray, optional`

    
Intensity (i.e., input) image with same size as labeled image, plus optionally
an extra dimension for multichannel data. Default is None.

Changed in version 0.18.0: The ability to provide an extra dimension for
channels was added.

`cachebool, optional`

    
Determine whether to cache calculated properties. The computation is much
faster for cached properties, whereas the memory consumption increases.

`coordinatesDEPRECATED`

    
This argument is deprecated and will be removed in a future version of scikit-
image.

See Coordinate conventions for more details.

Deprecated since version 0.16.0: Use “rc” coordinates everywhere. It may be
sufficient to call `numpy.transpose` on your label image to get the same
values as 0.15 and earlier. However, for some properties, the transformation
will be less trivial. For example, the new orientation is \\(\frac{\pi}{2}\\)
plus the old orientation.

`extra_propertiesIterable of callables`

    
Add extra property computation functions that are not included with skimage.
The name of the property is derived from the function name, the dtype is
inferred by calling the function on a small sample. If the name of an extra
property clashes with the name of an existing property the extra property wil
not be visible and a UserWarning is issued. A property computation function
must take a region mask as its first argument. If the property requires an
intensity image, it must accept the intensity image as the second argument.

Returns

    
`propertieslist of RegionProperties`

    
Each item describes one labeled region, and can be accessed using the
attributes listed below.

See also

`label`

#### Notes

The following properties can be accessed as attributes or keys:

`areaint`

    
Number of pixels of the region.

`bboxtuple`

    
Bounding box `(min_row, min_col, max_row, max_col)`. Pixels belonging to the
bounding box are in the half-open interval `[min_row; max_row)` and `[min_col;
max_col)`.

`bbox_areaint`

    
Number of pixels of bounding box.

`centroidarray`

    
Centroid coordinate tuple `(row, col)`.

`convex_areaint`

    
Number of pixels of convex hull image, which is the smallest convex polygon
that encloses the region.

`convex_image(H, J) ndarray`

    
Binary convex hull image which has the same size as bounding box.

`coords(N, 2) ndarray`

    
Coordinate list `(row, col)` of the region.

`eccentricityfloat`

    
Eccentricity of the ellipse that has the same second-moments as the region.
The eccentricity is the ratio of the focal distance (distance between focal
points) over the major axis length. The value is in the interval [0, 1). When
it is 0, the ellipse becomes a circle.

`equivalent_diameterfloat`

    
The diameter of a circle with the same area as the region.

`euler_numberint`

    
Euler characteristic of the set of non-zero pixels. Computed as number of
connected components subtracted by number of holes (input.ndim connectivity).
In 3D, number of connected components plus number of holes subtracted by
number of tunnels.

`extentfloat`

    
Ratio of pixels in the region to pixels in the total bounding box. Computed as
`area / (rows * cols)`

`feret_diameter_maxfloat`

    
Maximum Feret’s diameter computed as the longest distance between points
around a region’s convex hull contour as determined by `find_contours`. [5]

`filled_areaint`

    
Number of pixels of the region will all the holes filled in. Describes the
area of the filled_image.

`filled_image(H, J) ndarray`

    
Binary region image with filled holes which has the same size as bounding box.

`image(H, J) ndarray`

    
Sliced binary region image which has the same size as bounding box.

`inertia_tensorndarray`

    
Inertia tensor of the region for the rotation around its mass.

`inertia_tensor_eigvalstuple`

    
The eigenvalues of the inertia tensor in decreasing order.

`intensity_imagendarray`

    
Image inside region bounding box.

`labelint`

    
The label in the labeled input image.

`local_centroidarray`

    
Centroid coordinate tuple `(row, col)`, relative to region bounding box.

`major_axis_lengthfloat`

    
The length of the major axis of the ellipse that has the same normalized
second central moments as the region.

`max_intensityfloat`

    
Value with the greatest intensity in the region.

`mean_intensityfloat`

    
Value with the mean intensity in the region.

`min_intensityfloat`

    
Value with the least intensity in the region.

`minor_axis_lengthfloat`

    
The length of the minor axis of the ellipse that has the same normalized
second central moments as the region.

`moments(3, 3) ndarray`

    
Spatial moments up to 3rd order:

    
    m_ij = sum{ array(row, col) * row^i * col^j }
    
where the sum is over the `row`, `col` coordinates of the region.

`moments_central(3, 3) ndarray`

    
Central moments (translation invariant) up to 3rd order:

    
    mu_ij = sum{ array(row, col) * (row - row_c)^i * (col - col_c)^j }
    
where the sum is over the `row`, `col` coordinates of the region, and `row_c`
and `col_c` are the coordinates of the region’s centroid.

`moments_hutuple`

    
Hu moments (translation, scale and rotation invariant).

`moments_normalized(3, 3) ndarray`

    
Normalized moments (translation and scale invariant) up to 3rd order:

    
    nu_ij = mu_ij / m_00^[(i+j)/2 + 1]
    
where `m_00` is the zeroth spatial moment.

`orientationfloat`

    
Angle between the 0th axis (rows) and the major axis of the ellipse that has
the same second moments as the region, ranging from `-pi/2` to `pi/2` counter-
clockwise.

`perimeterfloat`

    
Perimeter of object which approximates the contour as a line through the
centers of border pixels using a 4-connectivity.

`perimeter_croftonfloat`

    
Perimeter of object approximated by the Crofton formula in 4 directions.

`slicetuple of slices`

    
A slice to extract the object from the source image.

`solidityfloat`

    
Ratio of pixels in the region to pixels of the convex hull image.

`weighted_centroidarray`

    
Centroid coordinate tuple `(row, col)` weighted with intensity image.

`weighted_local_centroidarray`

    
Centroid coordinate tuple `(row, col)`, relative to region bounding box,
weighted with intensity image.

`weighted_moments(3, 3) ndarray`

    
Spatial moments of intensity image up to 3rd order:

    
    wm_ij = sum{ array(row, col) * row^i * col^j }
    
where the sum is over the `row`, `col` coordinates of the region.

`weighted_moments_central(3, 3) ndarray`

    
Central moments (translation invariant) of intensity image up to 3rd order:

    
    wmu_ij = sum{ array(row, col) * (row - row_c)^i * (col - col_c)^j }
    
where the sum is over the `row`, `col` coordinates of the region, and `row_c`
and `col_c` are the coordinates of the region’s weighted centroid.

`weighted_moments_hutuple`

    
Hu moments (translation, scale and rotation invariant) of intensity image.

`weighted_moments_normalized(3, 3) ndarray`

    
Normalized moments (translation and scale invariant) of intensity image up to
3rd order:

    
    wnu_ij = wmu_ij / wm_00^[(i+j)/2 + 1]
    
where `wm_00` is the zeroth spatial moment (intensity-weighted area).

Each region also supports iteration, so that you can do:

    
    for prop in region:
        print(prop, region[prop])
    
#### References

`1`

    
Wilhelm Burger, Mark Burge. Principles of Digital Image Processing: Core
Algorithms. Springer-Verlag, London, 2009.

`2`

    
B. Jähne. Digital Image Processing. Springer-Verlag, Berlin-Heidelberg, 6.
edition, 2005.

`3`

    
T. H. Reiss. Recognizing Planar Objects Using Invariant Image Features, from
Lecture notes in computer science, p. 676. Springer, Berlin, 1993.

`4`

    
https://en.wikipedia.org/wiki/Image_moment

`5`

    
W. Pabst, E. Gregorová. Characterization of particles and particle systems,
pp. 27-28. ICT Prague, 2007.
https://old.vscht.cz/sil/keramika/Characterization_of_particles/CPPS%20_English%20version_.pdf

#### Examples

    
    >>> from skimage import data, util
    >>> from skimage.measure import label, regionprops
    >>> img = util.img_as_ubyte(data.coins()) > 110
    >>> label_img = label(img, connectivity=img.ndim)
    >>> props = regionprops(label_img)
    >>> # centroid of first labeled object
    >>> props[0].centroid
    (22.72987986048314, 81.91228523446583)
    >>> # centroid of first labeled object
    >>> props[0]['centroid']
    (22.72987986048314, 81.91228523446583)
    
Add custom measurements by passing functions as `extra_properties`

    
    >>> from skimage import data, util
    >>> from skimage.measure import label, regionprops
    >>> import numpy as np
    >>> img = util.img_as_ubyte(data.coins()) > 110
    >>> label_img = label(img, connectivity=img.ndim)
    >>> def pixelcount(regionmask):
    ...     return np.sum(regionmask)
    >>> props = regionprops(label_img, extra_properties=(pixelcount,))
    >>> props[0].pixelcount
    7741
    >>> props[1]['pixelcount']
    42
    
### Examples using `skimage.measure.regionprops`

![Measure region
properties](data:image/png;base64,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)

Measure region properties

## regionprops_table

`skimage.measure.regionprops_table(label_image, intensity_image=None,
properties=('label', 'bbox'), *, cache=True, separator='-',
extra_properties=None)` [source]

    
Compute image properties and return them as a pandas-compatible table.

The table is a dictionary mapping column names to value arrays. See Notes
section below for details.

New in version 0.16.

Parameters

    
`label_image(N, M[, P]) ndarray`

    
Labeled input image. Labels with value 0 are ignored.

`intensity_image(M, N[, P][, C]) ndarray, optional`

    
Intensity (i.e., input) image with same size as labeled image, plus optionally
an extra dimension for multichannel data. Default is None.

Changed in version 0.18.0: The ability to provide an extra dimension for
channels was added.

`propertiestuple or list of str, optional`

    
Properties that will be included in the resulting dictionary For a list of
available properties, please see `regionprops()`. Users should remember to add
“label” to keep track of region identities.

`cachebool, optional`

    
Determine whether to cache calculated properties. The computation is much
faster for cached properties, whereas the memory consumption increases.

`separatorstr, optional`

    
For non-scalar properties not listed in OBJECT_COLUMNS, each element will
appear in its own column, with the index of that element separated from the
property name by this separator. For example, the inertia tensor of a 2D
region will appear in four columns: `inertia_tensor-0-0`,
`inertia_tensor-0-1`, `inertia_tensor-1-0`, and `inertia_tensor-1-1` (where
the separator is `-`).

Object columns are those that cannot be split in this way because the number
of columns would change depending on the object. For example, `image` and
`coords`.

`extra_propertiesIterable of callables`

    
Add extra property computation functions that are not included with skimage.
The name of the property is derived from the function name, the dtype is
inferred by calling the function on a small sample. If the name of an extra
property clashes with the name of an existing property the extra property wil
not be visible and a UserWarning is issued. A property computation function
must take a region mask as its first argument. If the property requires an
intensity image, it must accept the intensity image as the second argument.

Returns

    
`out_dictdict`

    
Dictionary mapping property names to an array of values of that property, one
value per region. This dictionary can be used as input to pandas `DataFrame`
to map property names to columns in the frame and regions to rows. If the
image has no regions, the arrays will have length 0, but the correct type.

#### Notes

Each column contains either a scalar property, an object property, or an
element in a multidimensional array.

Properties with scalar values for each region, such as “eccentricity”, will
appear as a float or int array with that property name as key.

Multidimensional properties of fixed size for a given image dimension, such as
“centroid” (every centroid will have three elements in a 3D image, no matter
the region size), will be split into that many columns, with the name
{property_name}{separator}{element_num} (for 1D properties),
{property_name}{separator}{elem_num0}{separator}{elem_num1} (for 2D
properties), and so on.

For multidimensional properties that don’t have a fixed size, such as “image”
(the image of a region varies in size depending on the region size), an object
array will be used, with the corresponding property name as the key.

#### Examples

    
    >>> from skimage import data, util, measure
    >>> image = data.coins()
    >>> label_image = measure.label(image > 110, connectivity=image.ndim)
    >>> props = measure.regionprops_table(label_image, image,
    ...                           properties=['label', 'inertia_tensor',
    ...                                       'inertia_tensor_eigvals'])
    >>> props  
    {'label': array([ 1,  2, ...]), ...
     'inertia_tensor-0-0': array([  4.012...e+03,   8.51..., ...]), ...
     ...,
     'inertia_tensor_eigvals-1': array([  2.67...e+02,   2.83..., ...])}
    
The resulting dictionary can be directly passed to pandas, if installed, to
obtain a clean DataFrame:

    
    >>> import pandas as pd  
    >>> data = pd.DataFrame(props)  
    >>> data.head()  
       label  inertia_tensor-0-0  ...  inertia_tensor_eigvals-1
    0      1         4012.909888  ...                267.065503
    1      2            8.514739  ...                  2.834806
    2      3            0.666667  ...                  0.000000
    3      4            0.000000  ...                  0.000000
    4      5            0.222222  ...                  0.111111
    
[5 rows x 7 columns]

If we want to measure a feature that does not come as a built-in property, we
can define custom functions and pass them as `extra_properties`. For example,
we can create a custom function that measures the intensity quartiles in a
region:

    
    >>> from skimage import data, util, measure
    >>> import numpy as np
    >>> def quartiles(regionmask, intensity):
    ...     return np.percentile(intensity[regionmask], q=(25, 50, 75))
    >>>
    >>> image = data.coins()
    >>> label_image = measure.label(image > 110, connectivity=image.ndim)
    >>> props = measure.regionprops_table(label_image, intensity_image=image,
    ...                                   properties=('label',),
    ...                                   extra_properties=(quartiles,))
    >>> import pandas as pd 
    >>> pd.DataFrame(props).head() 
           label  quartiles-0  quartiles-1  quartiles-2
    0      1       117.00        123.0        130.0
    1      2       111.25        112.0        114.0
    2      3       111.00        111.0        111.0
    3      4       111.00        111.5        112.5
    4      5       112.50        113.0        114.0
    
### Examples using `skimage.measure.regionprops_table`

![Measure region
properties](data:image/png;base64,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)

Measure region properties

## shannon_entropy

`skimage.measure.shannon_entropy(image, base=2)` [source]

    
Calculate the Shannon entropy of an image.

The Shannon entropy is defined as S = -sum(pk * log(pk)), where pk are
frequency/probability of pixels of value k.

Parameters

    
`image(N, M) ndarray`

    
Grayscale input image.

`basefloat, optional`

    
The logarithmic base to use.

Returns

    
`entropyfloat`

#### Notes

The returned value is measured in bits or shannon (Sh) for base=2, natural
unit (nat) for base=np.e and hartley (Hart) for base=10.

#### References

`1`

    
https://en.wikipedia.org/wiki/Entropy_(information_theory)

`2`

    
https://en.wiktionary.org/wiki/Shannon_entropy

#### Examples

    
    >>> from skimage import data
    >>> from skimage.measure import shannon_entropy
    >>> shannon_entropy(data.camera())
    7.231695011055706
    
## subdivide_polygon

`skimage.measure.subdivide_polygon(coords, degree=2, preserve_ends=False)`
[source]

    
Subdivision of polygonal curves using B-Splines.

Note that the resulting curve is always within the convex hull of the original
polygon. Circular polygons stay closed after subdivision.

Parameters

    
`coords(N, 2) array`

    
Coordinate array.

`degree{1, 2, 3, 4, 5, 6, 7}, optional`

    
Degree of B-Spline. Default is 2.

`preserve_endsbool, optional`

    
Preserve first and last coordinate of non-circular polygon. Default is False.

Returns

    
`coords(M, 2) array`

    
Subdivided coordinate array.

#### References

`1`

    
http://mrl.nyu.edu/publications/subdiv-course2000/coursenotes00.pdf

## CircleModel

`class skimage.measure.CircleModel` [source]

    
Bases: `skimage.measure.fit.BaseModel`

Total least squares estimator for 2D circles.

The functional model of the circle is:

    
    r**2 = (x - xc)**2 + (y - yc)**2
    
This estimator minimizes the squared distances from all points to the circle:

    
    min{ sum((r - sqrt((x_i - xc)**2 + (y_i - yc)**2))**2) }
    
A minimum number of 3 points is required to solve for the parameters.

#### Examples

    
    >>> t = np.linspace(0, 2 * np.pi, 25)
    >>> xy = CircleModel().predict_xy(t, params=(2, 3, 4))
    >>> model = CircleModel()
    >>> model.estimate(xy)
    True
    >>> tuple(np.round(model.params, 5))
    (2.0, 3.0, 4.0)
    >>> res = model.residuals(xy)
    >>> np.abs(np.round(res, 9))
    array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
           0., 0., 0., 0., 0., 0., 0., 0.])
    
Attributes

    
`paramstuple`

    
Circle model parameters in the following order `xc`, `yc`, `r`.

`__init__()` [source]

    
Initialize self. See help(type(self)) for accurate signature.

`estimate(data)` [source]

    
Estimate circle model from data using total least squares.

Parameters

    
`data(N, 2) array`

    
N points with `(x, y)` coordinates, respectively.

Returns

    
`successbool`

    
True, if model estimation succeeds.

`predict_xy(t, params=None)` [source]

    
Predict x- and y-coordinates using the estimated model.

Parameters

    
`tarray`

    
Angles in circle in radians. Angles start to count from positive x-axis to
positive y-axis in a right-handed system.

`params(3, ) array, optional`

    
Optional custom parameter set.

Returns

    
`xy(…, 2) array`

    
Predicted x- and y-coordinates.

`residuals(data)` [source]

    
Determine residuals of data to model.

For each point the shortest distance to the circle is returned.

Parameters

    
`data(N, 2) array`

    
N points with `(x, y)` coordinates, respectively.

Returns

    
`residuals(N, ) array`

    
Residual for each data point.

## EllipseModel

`class skimage.measure.EllipseModel` [source]

    
Bases: `skimage.measure.fit.BaseModel`

Total least squares estimator for 2D ellipses.

The functional model of the ellipse is:

    
    xt = xc + a*cos(theta)*cos(t) - b*sin(theta)*sin(t)
    yt = yc + a*sin(theta)*cos(t) + b*cos(theta)*sin(t)
    d = sqrt((x - xt)**2 + (y - yt)**2)
    
where `(xt, yt)` is the closest point on the ellipse to `(x, y)`. Thus d is
the shortest distance from the point to the ellipse.

The estimator is based on a least squares minimization. The optimal solution
is computed directly, no iterations are required. This leads to a simple,
stable and robust fitting method.

The `params` attribute contains the parameters in the following order:

    
    xc, yc, a, b, theta
    
#### Examples

    
    >>> xy = EllipseModel().predict_xy(np.linspace(0, 2 * np.pi, 25),
    ...                                params=(10, 15, 4, 8, np.deg2rad(30)))
    >>> ellipse = EllipseModel()
    >>> ellipse.estimate(xy)
    True
    >>> np.round(ellipse.params, 2)
    array([10.  , 15.  ,  4.  ,  8.  ,  0.52])
    >>> np.round(abs(ellipse.residuals(xy)), 5)
    array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
           0., 0., 0., 0., 0., 0., 0., 0.])
    
Attributes

    
`paramstuple`

    
Ellipse model parameters in the following order `xc`, `yc`, `a`, `b`, `theta`.

`__init__()` [source]

    
Initialize self. See help(type(self)) for accurate signature.

`estimate(data)` [source]

    
Estimate circle model from data using total least squares.

Parameters

    
`data(N, 2) array`

    
N points with `(x, y)` coordinates, respectively.

Returns

    
`successbool`

    
True, if model estimation succeeds.

#### References

`1`

    
Halir, R.; Flusser, J. “Numerically stable direct least squares fitting of
ellipses”. In Proc. 6th International Conference in Central Europe on Computer
Graphics and Visualization. WSCG (Vol. 98, pp. 125-132).

`predict_xy(t, params=None)` [source]

    
Predict x- and y-coordinates using the estimated model.

Parameters

    
`tarray`

    
Angles in circle in radians. Angles start to count from positive x-axis to
positive y-axis in a right-handed system.

`params(5, ) array, optional`

    
Optional custom parameter set.

Returns

    
`xy(…, 2) array`

    
Predicted x- and y-coordinates.

`residuals(data)` [source]

    
Determine residuals of data to model.

For each point the shortest distance to the ellipse is returned.

Parameters

    
`data(N, 2) array`

    
N points with `(x, y)` coordinates, respectively.

Returns

    
`residuals(N, ) array`

    
Residual for each data point.

## LineModelND

`class skimage.measure.LineModelND` [source]

    
Bases: `skimage.measure.fit.BaseModel`

Total least squares estimator for N-dimensional lines.

In contrast to ordinary least squares line estimation, this estimator
minimizes the orthogonal distances of points to the estimated line.

Lines are defined by a point (origin) and a unit vector (direction) according
to the following vector equation:

    
    X = origin + lambda * direction
    
#### Examples

    
    >>> x = np.linspace(1, 2, 25)
    >>> y = 1.5 * x + 3
    >>> lm = LineModelND()
    >>> lm.estimate(np.stack([x, y], axis=-1))
    True
    >>> tuple(np.round(lm.params, 5))
    (array([1.5 , 5.25]), array([0.5547 , 0.83205]))
    >>> res = lm.residuals(np.stack([x, y], axis=-1))
    >>> np.abs(np.round(res, 9))
    array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,
           0., 0., 0., 0., 0., 0., 0., 0.])
    >>> np.round(lm.predict_y(x[:5]), 3)
    array([4.5  , 4.562, 4.625, 4.688, 4.75 ])
    >>> np.round(lm.predict_x(y[:5]), 3)
    array([1.   , 1.042, 1.083, 1.125, 1.167])
    
Attributes

    
`paramstuple`

    
Line model parameters in the following order `origin`, `direction`.

`__init__()` [source]

    
Initialize self. See help(type(self)) for accurate signature.

`estimate(data)` [source]

    
Estimate line model from data.

This minimizes the sum of shortest (orthogonal) distances from the given data
points to the estimated line.

Parameters

    
`data(N, dim) array`

    
N points in a space of dimensionality dim >= 2.

Returns

    
`successbool`

    
True, if model estimation succeeds.

`predict(x, axis=0, params=None)` [source]

    
Predict intersection of the estimated line model with a hyperplane orthogonal
to a given axis.

Parameters

    
`x(n, 1) array`

    
Coordinates along an axis.

`axisint`

    
Axis orthogonal to the hyperplane intersecting the line.

`params(2, ) array, optional`

    
Optional custom parameter set in the form (`origin`, `direction`).

Returns

    
`data(n, m) array`

    
Predicted coordinates.

Raises

    
ValueError

    
If the line is parallel to the given axis.

`predict_x(y, params=None)` [source]

    
Predict x-coordinates for 2D lines using the estimated model.

Alias for:

    
    predict(y, axis=1)[:, 0]
    
Parameters

    
`yarray`

    
y-coordinates.

`params(2, ) array, optional`

    
Optional custom parameter set in the form (`origin`, `direction`).

Returns

    
`xarray`

    
Predicted x-coordinates.

`predict_y(x, params=None)` [source]

    
Predict y-coordinates for 2D lines using the estimated model.

Alias for:

    
    predict(x, axis=0)[:, 1]
    
Parameters

    
`xarray`

    
x-coordinates.

`params(2, ) array, optional`

    
Optional custom parameter set in the form (`origin`, `direction`).

Returns

    
`yarray`

    
Predicted y-coordinates.

`residuals(data, params=None)` [source]

    
Determine residuals of data to model.

For each point, the shortest (orthogonal) distance to the line is returned. It
is obtained by projecting the data onto the line.

Parameters

    
`data(N, dim) array`

    
N points in a space of dimension dim.

`params(2, ) array, optional`

    
Optional custom parameter set in the form (`origin`, `direction`).

Returns

    
`residuals(N, ) array`

    
Residual for each data point.

© 2019 the scikit-image team  
Licensed under the BSD 3-clause License.  
https://scikit-image.org/docs/0.18.x/api/skimage.measure.html

  *[ISP]: Internet Service Provider
  *[LIFO]: last-in, first-out
  *[FIFO]: first-in, first-out

