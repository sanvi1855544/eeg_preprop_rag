# Module: draw

`skimage.draw.bezier_curve`(r0, c0, r1, c1, …) | Generate Bezier curve coordinates.  
---|---  
`skimage.draw.circle`(r, c, radius[, shape]) | Generate coordinates of pixels within circle.  
`skimage.draw.circle_perimeter`(r, c, radius) | Generate circle perimeter coordinates.  
`skimage.draw.circle_perimeter_aa`(r, c, radius) | Generate anti-aliased circle perimeter coordinates.  
`skimage.draw.disk`(center, radius, *[, shape]) | Generate coordinates of pixels within circle.  
`skimage.draw.ellipse`(r, c, r_radius, c_radius) | Generate coordinates of pixels within ellipse.  
`skimage.draw.ellipse_perimeter`(r, c, …[, …]) | Generate ellipse perimeter coordinates.  
`skimage.draw.ellipsoid`(a, b, c[, spacing, …]) | Generates ellipsoid with semimajor axes aligned with grid dimensions on grid with specified `spacing`.  
`skimage.draw.ellipsoid_stats`(a, b, c) | Calculates analytical surface area and volume for ellipsoid with semimajor axes aligned with grid dimensions of specified `spacing`.  
`skimage.draw.line`(r0, c0, r1, c1) | Generate line pixel coordinates.  
`skimage.draw.line_aa`(r0, c0, r1, c1) | Generate anti-aliased line pixel coordinates.  
`skimage.draw.line_nd`(start, stop, *[, …]) | Draw a single-pixel thick line in n dimensions.  
`skimage.draw.polygon`(r, c[, shape]) | Generate coordinates of pixels within polygon.  
`skimage.draw.polygon2mask`(image_shape, polygon) | Compute a mask from polygon.  
`skimage.draw.polygon_perimeter`(r, c[, …]) | Generate polygon perimeter coordinates.  
`skimage.draw.random_shapes`(image_shape, …) | Generate an image with random shapes, labeled with bounding boxes.  
`skimage.draw.rectangle`(start[, end, extent, …]) | Generate coordinates of pixels within a rectangle.  
`skimage.draw.rectangle_perimeter`(start[, …]) | Generate coordinates of pixels that are exactly around a rectangle.  
`skimage.draw.set_color`(image, coords, color) | Set pixel color in the image at the given coordinates.  
## bezier_curve

`skimage.draw.bezier_curve(r0, c0, r1, c1, r2, c2, weight, shape=None)`
[source]

    
Generate Bezier curve coordinates.

Parameters

    
`r0, c0int`

    
Coordinates of the first control point.

`r1, c1int`

    
Coordinates of the middle control point.

`r2, c2int`

    
Coordinates of the last control point.

`weightdouble`

    
Middle control point weight, it describes the line tension.

`shapetuple, optional`

    
Image shape which is used to determine the maximum extent of output pixel
coordinates. This is useful for curves that exceed the image size. If None,
the full extent of the curve is used.

Returns

    
`rr, cc(N,) ndarray of int`

    
Indices of pixels that belong to the Bezier curve. May be used to directly
index into an array, e.g. `img[rr, cc] = 1`.

#### Notes

The algorithm is the rational quadratic algorithm presented in reference [1].

#### References

`1`

    
A Rasterizing Algorithm for Drawing Curves, A. Zingl, 2012
http://members.chello.at/easyfilter/Bresenham.pdf

#### Examples

    
    >>> import numpy as np
    >>> from skimage.draw import bezier_curve
    >>> img = np.zeros((10, 10), dtype=np.uint8)
    >>> rr, cc = bezier_curve(1, 5, 5, -2, 8, 8, 2)
    >>> img[rr, cc] = 1
    >>> img
    array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
           [0, 0, 0, 1, 1, 0, 0, 0, 0, 0],
           [0, 0, 1, 0, 0, 0, 0, 0, 0, 0],
           [0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 1, 1, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 1, 1, 1, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 1, 1, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
    
## circle

`skimage.draw.circle(r, c, radius, shape=None)` [source]

    
Generate coordinates of pixels within circle.

Parameters

    
`r, cdouble`

    
Center coordinate of disk.

`radiusdouble`

    
Radius of disk.

`shapetuple, optional`

    
Image shape which is used to determine the maximum extent of output pixel
coordinates. This is useful for disks that exceed the image size. If None, the
full extent of the disk is used. Must be at least length 2. Only the first two
values are used to determine the extent of the input image.

Returns

    
`rr, ccndarray of int`

    
Pixel coordinates of disk. May be used to directly index into an array, e.g.
`img[rr, cc] = 1`.

Warns

    
Deprecated:

    
New in version 0.17: This function is deprecated and will be removed in
scikit-image 0.19. Please use the function named `disk` instead.

## circle_perimeter

`skimage.draw.circle_perimeter(r, c, radius, method='bresenham', shape=None)`
[source]

    
Generate circle perimeter coordinates.

Parameters

    
`r, cint`

    
Centre coordinate of circle.

`radiusint`

    
Radius of circle.

`method{‘bresenham’, ‘andres’}, optional`

    
bresenham : Bresenham method (default) andres : Andres method

`shapetuple, optional`

    
Image shape which is used to determine the maximum extent of output pixel
coordinates. This is useful for circles that exceed the image size. If None,
the full extent of the circle is used. Must be at least length 2. Only the
first two values are used to determine the extent of the input image.

Returns

    
`rr, cc(N,) ndarray of int`

    
Bresenham and Andres’ method: Indices of pixels that belong to the circle
perimeter. May be used to directly index into an array, e.g. `img[rr, cc] =
1`.

#### Notes

Andres method presents the advantage that concentric circles create a disc
whereas Bresenham can make holes. There is also less distortions when Andres
circles are rotated. Bresenham method is also known as midpoint circle
algorithm. Anti-aliased circle generator is available with
`circle_perimeter_aa`.

#### References

`1`

    
J.E. Bresenham, “Algorithm for computer control of a digital plotter”, IBM
Systems journal, 4 (1965) 25-30.

`2`

    
E. Andres, “Discrete circles, rings and spheres”, Computers & Graphics, 18
(1994) 695-706.

#### Examples

    
    >>> from skimage.draw import circle_perimeter
    >>> img = np.zeros((10, 10), dtype=np.uint8)
    >>> rr, cc = circle_perimeter(4, 4, 3)
    >>> img[rr, cc] = 1
    >>> img
    array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 1, 1, 1, 0, 0, 0, 0],
           [0, 0, 1, 0, 0, 0, 1, 0, 0, 0],
           [0, 1, 0, 0, 0, 0, 0, 1, 0, 0],
           [0, 1, 0, 0, 0, 0, 0, 1, 0, 0],
           [0, 1, 0, 0, 0, 0, 0, 1, 0, 0],
           [0, 0, 1, 0, 0, 0, 1, 0, 0, 0],
           [0, 0, 0, 1, 1, 1, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
    
## circle_perimeter_aa

`skimage.draw.circle_perimeter_aa(r, c, radius, shape=None)` [source]

    
Generate anti-aliased circle perimeter coordinates.

Parameters

    
`r, cint`

    
Centre coordinate of circle.

`radiusint`

    
Radius of circle.

`shapetuple, optional`

    
Image shape which is used to determine the maximum extent of output pixel
coordinates. This is useful for circles that exceed the image size. If None,
the full extent of the circle is used. Must be at least length 2. Only the
first two values are used to determine the extent of the input image.

Returns

    
`rr, cc, val(N,) ndarray (int, int, float)`

    
Indices of pixels (`rr`, `cc`) and intensity values (`val`). `img[rr, cc] =
val`.

#### Notes

Wu’s method draws anti-aliased circle. This implementation doesn’t use lookup
table optimization.

Use the function `draw.set_color` to apply `circle_perimeter_aa` results to
color images.

#### References

`1`

    
X. Wu, “An efficient antialiasing technique”, In ACM SIGGRAPH Computer
Graphics, 25 (1991) 143-152.

#### Examples

    
    >>> from skimage.draw import circle_perimeter_aa
    >>> img = np.zeros((10, 10), dtype=np.uint8)
    >>> rr, cc, val = circle_perimeter_aa(4, 4, 3)
    >>> img[rr, cc] = val * 255
    >>> img
    array([[  0,   0,   0,   0,   0,   0,   0,   0,   0,   0],
           [  0,   0,  60, 211, 255, 211,  60,   0,   0,   0],
           [  0,  60, 194,  43,   0,  43, 194,  60,   0,   0],
           [  0, 211,  43,   0,   0,   0,  43, 211,   0,   0],
           [  0, 255,   0,   0,   0,   0,   0, 255,   0,   0],
           [  0, 211,  43,   0,   0,   0,  43, 211,   0,   0],
           [  0,  60, 194,  43,   0,  43, 194,  60,   0,   0],
           [  0,   0,  60, 211, 255, 211,  60,   0,   0,   0],
           [  0,   0,   0,   0,   0,   0,   0,   0,   0,   0],
           [  0,   0,   0,   0,   0,   0,   0,   0,   0,   0]], dtype=uint8)
    
    
    >>> from skimage import data, draw
    >>> image = data.chelsea()
    >>> rr, cc, val = draw.circle_perimeter_aa(r=100, c=100, radius=75)
    >>> draw.set_color(image, (rr, cc), [1, 0, 0], alpha=val)
    
## disk

`skimage.draw.disk(center, radius, *, shape=None)` [source]

    
Generate coordinates of pixels within circle.

Parameters

    
`centertuple`

    
Center coordinate of disk.

`radiusdouble`

    
Radius of disk.

`shapetuple, optional`

    
Image shape which is used to determine the maximum extent of output pixel
coordinates. This is useful for disks that exceed the image size. If None, the
full extent of the disk is used. Must be at least length 2. Only the first two
values are used to determine the extent of the input image.

Returns

    
`rr, ccndarray of int`

    
Pixel coordinates of disk. May be used to directly index into an array, e.g.
`img[rr, cc] = 1`.

#### Examples

    
    >>> from skimage.draw import disk
    >>> img = np.zeros((10, 10), dtype=np.uint8)
    >>> rr, cc = disk((4, 4), 5)
    >>> img[rr, cc] = 1
    >>> img
    array([[0, 0, 1, 1, 1, 1, 1, 0, 0, 0],
           [0, 1, 1, 1, 1, 1, 1, 1, 0, 0],
           [1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
           [1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
           [1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
           [1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
           [1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
           [0, 1, 1, 1, 1, 1, 1, 1, 0, 0],
           [0, 0, 1, 1, 1, 1, 1, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
    
## ellipse

`skimage.draw.ellipse(r, c, r_radius, c_radius, shape=None, rotation=0.0)`
[source]

    
Generate coordinates of pixels within ellipse.

Parameters

    
`r, cdouble`

    
Centre coordinate of ellipse.

`r_radius, c_radiusdouble`

    
Minor and major semi-axes. `(r/r_radius)**2 + (c/c_radius)**2 = 1`.

`shapetuple, optional`

    
Image shape which is used to determine the maximum extent of output pixel
coordinates. This is useful for ellipses which exceed the image size. By
default the full extent of the ellipse are used. Must be at least length 2.
Only the first two values are used to determine the extent.

`rotationfloat, optional (default 0.)`

    
Set the ellipse rotation (rotation) in range (-PI, PI) in contra clock wise
direction, so PI/2 degree means swap ellipse axis

Returns

    
`rr, ccndarray of int`

    
Pixel coordinates of ellipse. May be used to directly index into an array,
e.g. `img[rr, cc] = 1`.

#### Notes

The ellipse equation:

    
    ((x * cos(alpha) + y * sin(alpha)) / x_radius) ** 2 +
    ((x * sin(alpha) - y * cos(alpha)) / y_radius) ** 2 = 1
    
Note that the positions of `ellipse` without specified `shape` can have also,
negative values, as this is correct on the plane. On the other hand using
these ellipse positions for an image afterwards may lead to appearing on the
other side of image, because `image[-1, -1] = image[end-1, end-1]`

    
    >>> rr, cc = ellipse(1, 2, 3, 6)
    >>> img = np.zeros((6, 12), dtype=np.uint8)
    >>> img[rr, cc] = 1
    >>> img
    array([[1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1],
           [1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1],
           [1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1],
           [1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1]], dtype=uint8)
    
#### Examples

    
    >>> from skimage.draw import ellipse
    >>> img = np.zeros((10, 12), dtype=np.uint8)
    >>> rr, cc = ellipse(5, 6, 3, 5, rotation=np.deg2rad(30))
    >>> img[rr, cc] = 1
    >>> img
    array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0],
           [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0],
           [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0],
           [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
           [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0],
           [0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0],
           [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
    
### Examples using `skimage.draw.ellipse`

![Masked Normalized Cross-
Correlation](data:image/png;base64,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)

Masked Normalized Cross-Correlation

![Measure region
properties](data:image/png;base64,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)

Measure region properties

## ellipse_perimeter

`skimage.draw.ellipse_perimeter(r, c, r_radius, c_radius, orientation=0,
shape=None)` [source]

    
Generate ellipse perimeter coordinates.

Parameters

    
`r, cint`

    
Centre coordinate of ellipse.

`r_radius, c_radiusint`

    
Minor and major semi-axes. `(r/r_radius)**2 + (c/c_radius)**2 = 1`.

`orientationdouble, optional`

    
Major axis orientation in clockwise direction as radians.

`shapetuple, optional`

    
Image shape which is used to determine the maximum extent of output pixel
coordinates. This is useful for ellipses that exceed the image size. If None,
the full extent of the ellipse is used. Must be at least length 2. Only the
first two values are used to determine the extent of the input image.

Returns

    
`rr, cc(N,) ndarray of int`

    
Indices of pixels that belong to the ellipse perimeter. May be used to
directly index into an array, e.g. `img[rr, cc] = 1`.

#### References

`1`

    
A Rasterizing Algorithm for Drawing Curves, A. Zingl, 2012
http://members.chello.at/easyfilter/Bresenham.pdf

#### Examples

    
    >>> from skimage.draw import ellipse_perimeter
    >>> img = np.zeros((10, 10), dtype=np.uint8)
    >>> rr, cc = ellipse_perimeter(5, 5, 3, 4)
    >>> img[rr, cc] = 1
    >>> img
    array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 1, 1, 1, 1, 1, 0, 0],
           [0, 0, 1, 0, 0, 0, 0, 0, 1, 0],
           [0, 1, 0, 0, 0, 0, 0, 0, 0, 1],
           [0, 1, 0, 0, 0, 0, 0, 0, 0, 1],
           [0, 1, 0, 0, 0, 0, 0, 0, 0, 1],
           [0, 0, 1, 0, 0, 0, 0, 0, 1, 0],
           [0, 0, 0, 1, 1, 1, 1, 1, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
    
Note that the positions of `ellipse` without specified `shape` can have also,
negative values, as this is correct on the plane. On the other hand using
these ellipse positions for an image afterwards may lead to appearing on the
other side of image, because `image[-1, -1] = image[end-1, end-1]`

    
    >>> rr, cc = ellipse_perimeter(2, 3, 4, 5)
    >>> img = np.zeros((9, 12), dtype=np.uint8)
    >>> img[rr, cc] = 1
    >>> img
    array([[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
           [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0],
           [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
           [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
           [0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
           [0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
           [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]], dtype=uint8)
    
## ellipsoid

`skimage.draw.ellipsoid(a, b, c, spacing=(1.0, 1.0, 1.0), levelset=False)`
[source]

    
Generates ellipsoid with semimajor axes aligned with grid dimensions on grid
with specified `spacing`.

Parameters

    
`afloat`

    
Length of semimajor axis aligned with x-axis.

`bfloat`

    
Length of semimajor axis aligned with y-axis.

`cfloat`

    
Length of semimajor axis aligned with z-axis.

`spacingtuple of floats, length 3`

    
Spacing in (x, y, z) spatial dimensions.

`levelsetbool`

    
If True, returns the level set for this ellipsoid (signed level set about
zero, with positive denoting interior) as np.float64. False returns a
binarized version of said level set.

Returns

    
`ellip(N, M, P) array`

    
Ellipsoid centered in a correctly sized array for given `spacing`. Boolean
dtype unless `levelset=True`, in which case a float array is returned with the
level set above 0.0 representing the ellipsoid.

## ellipsoid_stats

`skimage.draw.ellipsoid_stats(a, b, c)` [source]

    
Calculates analytical surface area and volume for ellipsoid with semimajor
axes aligned with grid dimensions of specified `spacing`.

Parameters

    
`afloat`

    
Length of semimajor axis aligned with x-axis.

`bfloat`

    
Length of semimajor axis aligned with y-axis.

`cfloat`

    
Length of semimajor axis aligned with z-axis.

Returns

    
`volfloat`

    
Calculated volume of ellipsoid.

`surffloat`

    
Calculated surface area of ellipsoid.

## line

`skimage.draw.line(r0, c0, r1, c1)` [source]

    
Generate line pixel coordinates.

Parameters

    
`r0, c0int`

    
Starting position (row, column).

`r1, c1int`

    
End position (row, column).

Returns

    
`rr, cc(N,) ndarray of int`

    
Indices of pixels that belong to the line. May be used to directly index into
an array, e.g. `img[rr, cc] = 1`.

#### Notes

Anti-aliased line generator is available with `line_aa`.

#### Examples

    
    >>> from skimage.draw import line
    >>> img = np.zeros((10, 10), dtype=np.uint8)
    >>> rr, cc = line(1, 1, 8, 8)
    >>> img[rr, cc] = 1
    >>> img
    array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 1, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 1, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
    
## line_aa

`skimage.draw.line_aa(r0, c0, r1, c1)` [source]

    
Generate anti-aliased line pixel coordinates.

Parameters

    
`r0, c0int`

    
Starting position (row, column).

`r1, c1int`

    
End position (row, column).

Returns

    
`rr, cc, val(N,) ndarray (int, int, float)`

    
Indices of pixels (`rr`, `cc`) and intensity values (`val`). `img[rr, cc] =
val`.

#### References

`1`

    
A Rasterizing Algorithm for Drawing Curves, A. Zingl, 2012
http://members.chello.at/easyfilter/Bresenham.pdf

#### Examples

    
    >>> from skimage.draw import line_aa
    >>> img = np.zeros((10, 10), dtype=np.uint8)
    >>> rr, cc, val = line_aa(1, 1, 8, 8)
    >>> img[rr, cc] = val * 255
    >>> img
    array([[  0,   0,   0,   0,   0,   0,   0,   0,   0,   0],
           [  0, 255,  74,   0,   0,   0,   0,   0,   0,   0],
           [  0,  74, 255,  74,   0,   0,   0,   0,   0,   0],
           [  0,   0,  74, 255,  74,   0,   0,   0,   0,   0],
           [  0,   0,   0,  74, 255,  74,   0,   0,   0,   0],
           [  0,   0,   0,   0,  74, 255,  74,   0,   0,   0],
           [  0,   0,   0,   0,   0,  74, 255,  74,   0,   0],
           [  0,   0,   0,   0,   0,   0,  74, 255,  74,   0],
           [  0,   0,   0,   0,   0,   0,   0,  74, 255,   0],
           [  0,   0,   0,   0,   0,   0,   0,   0,   0,   0]], dtype=uint8)
    
## line_nd

`skimage.draw.line_nd(start, stop, *, endpoint=False, integer=True)` [source]

    
Draw a single-pixel thick line in n dimensions.

The line produced will be ndim-connected. That is, two subsequent pixels in
the line will be either direct or diagonal neighbours in n dimensions.

Parameters

    
`startarray-like, shape (N,)`

    
The start coordinates of the line.

`stoparray-like, shape (N,)`

    
The end coordinates of the line.

`endpointbool, optional`

    
Whether to include the endpoint in the returned line. Defaults to False, which
allows for easy drawing of multi-point paths.

`integerbool, optional`

    
Whether to round the coordinates to integer. If True (default), the returned
coordinates can be used to directly index into an array. `False` could be used
for e.g. vector drawing.

Returns

    
`coordstuple of arrays`

    
The coordinates of points on the line.

#### Examples

    
    >>> lin = line_nd((1, 1), (5, 2.5), endpoint=False)
    >>> lin
    (array([1, 2, 3, 4]), array([1, 1, 2, 2]))
    >>> im = np.zeros((6, 5), dtype=int)
    >>> im[lin] = 1
    >>> im
    array([[0, 0, 0, 0, 0],
           [0, 1, 0, 0, 0],
           [0, 1, 0, 0, 0],
           [0, 0, 1, 0, 0],
           [0, 0, 1, 0, 0],
           [0, 0, 0, 0, 0]])
    >>> line_nd([2, 1, 1], [5, 5, 2.5], endpoint=True)
    (array([2, 3, 4, 4, 5]), array([1, 2, 3, 4, 5]), array([1, 1, 2, 2, 2]))
    
## polygon

`skimage.draw.polygon(r, c, shape=None)` [source]

    
Generate coordinates of pixels within polygon.

Parameters

    
`r(N,) ndarray`

    
Row coordinates of vertices of polygon.

`c(N,) ndarray`

    
Column coordinates of vertices of polygon.

`shapetuple, optional`

    
Image shape which is used to determine the maximum extent of output pixel
coordinates. This is useful for polygons that exceed the image size. If None,
the full extent of the polygon is used. Must be at least length 2. Only the
first two values are used to determine the extent of the input image.

Returns

    
`rr, ccndarray of int`

    
Pixel coordinates of polygon. May be used to directly index into an array,
e.g. `img[rr, cc] = 1`.

#### Examples

    
    >>> from skimage.draw import polygon
    >>> img = np.zeros((10, 10), dtype=np.uint8)
    >>> r = np.array([1, 2, 8])
    >>> c = np.array([1, 7, 4])
    >>> rr, cc = polygon(r, c)
    >>> img[rr, cc] = 1
    >>> img
    array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],
           [0, 0, 1, 1, 1, 1, 1, 0, 0, 0],
           [0, 0, 0, 1, 1, 1, 1, 0, 0, 0],
           [0, 0, 0, 1, 1, 1, 0, 0, 0, 0],
           [0, 0, 0, 0, 1, 1, 0, 0, 0, 0],
           [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
    
## polygon2mask

`skimage.draw.polygon2mask(image_shape, polygon)` [source]

    
Compute a mask from polygon.

Parameters

    
`image_shapetuple of size 2.`

    
The shape of the mask.

`polygonarray_like.`

    
The polygon coordinates of shape (N, 2) where N is the number of points.

Returns

    
`mask2-D ndarray of type ‘bool’.`

    
The mask that corresponds to the input polygon.

#### Notes

This function does not do any border checking, so that all the vertices need
to be within the given shape.

#### Examples

    
    >>> image_shape = (128, 128)
    >>> polygon = np.array([[60, 100], [100, 40], [40, 40]])
    >>> mask = polygon2mask(image_shape, polygon)
    >>> mask.shape
    (128, 128)
    
## polygon_perimeter

`skimage.draw.polygon_perimeter(r, c, shape=None, clip=False)` [source]

    
Generate polygon perimeter coordinates.

Parameters

    
`r(N,) ndarray`

    
Row coordinates of vertices of polygon.

`c(N,) ndarray`

    
Column coordinates of vertices of polygon.

`shapetuple, optional`

    
Image shape which is used to determine maximum extents of output pixel
coordinates. This is useful for polygons that exceed the image size. If None,
the full extents of the polygon is used. Must be at least length 2. Only the
first two values are used to determine the extent of the input image.

`clipbool, optional`

    
Whether to clip the polygon to the provided shape. If this is set to True, the
drawn figure will always be a closed polygon with all edges visible.

Returns

    
`rr, ccndarray of int`

    
Pixel coordinates of polygon. May be used to directly index into an array,
e.g. `img[rr, cc] = 1`.

#### Examples

    
    >>> from skimage.draw import polygon_perimeter
    >>> img = np.zeros((10, 10), dtype=np.uint8)
    >>> rr, cc = polygon_perimeter([5, -1, 5, 10],
    ...                            [-1, 5, 11, 5],
    ...                            shape=img.shape, clip=True)
    >>> img[rr, cc] = 1
    >>> img
    array([[0, 0, 0, 0, 1, 1, 1, 0, 0, 0],
           [0, 0, 0, 1, 0, 0, 0, 1, 0, 0],
           [0, 0, 1, 0, 0, 0, 0, 0, 1, 0],
           [0, 1, 0, 0, 0, 0, 0, 0, 0, 1],
           [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
           [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
           [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
           [0, 1, 1, 0, 0, 0, 0, 0, 0, 1],
           [0, 0, 0, 1, 0, 0, 0, 1, 1, 0],
           [0, 0, 0, 0, 1, 1, 1, 0, 0, 0]], dtype=uint8)
    
## random_shapes

`skimage.draw.random_shapes(image_shape, max_shapes, min_shapes=1, min_size=2,
max_size=None, multichannel=True, num_channels=3, shape=None,
intensity_range=None, allow_overlap=False, num_trials=100, random_seed=None)`
[source]

    
Generate an image with random shapes, labeled with bounding boxes.

The image is populated with random shapes with random sizes, random locations,
and random colors, with or without overlap.

Shapes have random (row, col) starting coordinates and random sizes bounded by
`min_size` and `max_size`. It can occur that a randomly generated shape will
not fit the image at all. In that case, the algorithm will try again with new
starting coordinates a certain number of times. However, it also means that
some shapes may be skipped altogether. In that case, this function will
generate fewer shapes than requested.

Parameters

    
`image_shapetuple`

    
The number of rows and columns of the image to generate.

`max_shapesint`

    
The maximum number of shapes to (attempt to) fit into the shape.

`min_shapesint, optional`

    
The minimum number of shapes to (attempt to) fit into the shape.

`min_sizeint, optional`

    
The minimum dimension of each shape to fit into the image.

`max_sizeint, optional`

    
The maximum dimension of each shape to fit into the image.

`multichannelbool, optional`

    
If True, the generated image has `num_channels` color channels, otherwise
generates grayscale image.

`num_channelsint, optional`

    
Number of channels in the generated image. If 1, generate monochrome images,
else color images with multiple channels. Ignored if `multichannel` is set to
False.

`shape{rectangle, circle, triangle, ellipse, None} str, optional`

    
The name of the shape to generate or `None` to pick random ones.

`intensity_range{tuple of tuples of uint8, tuple of uint8}, optional`

    
The range of values to sample pixel values from. For grayscale images the
format is (min, max). For multichannel - ((min, max),) if the ranges are equal
across the channels, and ((min_0, max_0), … (min_N, max_N)) if they differ. As
the function supports generation of uint8 arrays only, the maximum range is
(0, 255). If None, set to (0, 254) for each channel reserving color of
intensity = 255 for background.

`allow_overlapbool, optional`

    
If `True`, allow shapes to overlap.

`num_trialsint, optional`

    
How often to attempt to fit a shape into the image before skipping it.

`random_seedint, optional`

    
Seed to initialize the random number generator. If `None`, a random seed from
the operating system is used.

Returns

    
`imageuint8 array`

    
An image with the fitted shapes.

`labelslist`

    
A list of labels, one per shape in the image. Each label is a (category, ((r0,
r1), (c0, c1))) tuple specifying the category and bounding box coordinates of
the shape.

#### Examples

    
    >>> import skimage.draw
    >>> image, labels = skimage.draw.random_shapes((32, 32), max_shapes=3)
    >>> image 
    array([
       [[255, 255, 255],
        [255, 255, 255],
        [255, 255, 255],
        ...,
        [255, 255, 255],
        [255, 255, 255],
        [255, 255, 255]]], dtype=uint8)
    >>> labels 
    [('circle', ((22, 18), (25, 21))),
     ('triangle', ((5, 6), (13, 13)))]
    
## rectangle

`skimage.draw.rectangle(start, end=None, extent=None, shape=None)` [source]

    
Generate coordinates of pixels within a rectangle.

Parameters

    
`starttuple`

    
Origin point of the rectangle, e.g., `([plane,] row, column)`.

`endtuple`

    
End point of the rectangle `([plane,] row, column)`. For a 2D matrix, the
slice defined by the rectangle is `[start:(end+1)]`. Either `end` or `extent`
must be specified.

`extenttuple`

    
The extent (size) of the drawn rectangle. E.g., `([num_planes,] num_rows,
num_cols)`. Either `end` or `extent` must be specified. A negative extent is
valid, and will result in a rectangle going along the opposite direction. If
extent is negative, the `start` point is not included.

`shapetuple, optional`

    
Image shape used to determine the maximum bounds of the output coordinates.
This is useful for clipping rectangles that exceed the image size. By default,
no clipping is done.

Returns

    
`coordsarray of int, shape (Ndim, Npoints)`

    
The coordinates of all pixels in the rectangle.

#### Notes

This function can be applied to N-dimensional images, by passing `start` and
`end` or `extent` as tuples of length N.

#### Examples

    
    >>> import numpy as np
    >>> from skimage.draw import rectangle
    >>> img = np.zeros((5, 5), dtype=np.uint8)
    >>> start = (1, 1)
    >>> extent = (3, 3)
    >>> rr, cc = rectangle(start, extent=extent, shape=img.shape)
    >>> img[rr, cc] = 1
    >>> img
    array([[0, 0, 0, 0, 0],
           [0, 1, 1, 1, 0],
           [0, 1, 1, 1, 0],
           [0, 1, 1, 1, 0],
           [0, 0, 0, 0, 0]], dtype=uint8)
    
    
    >>> img = np.zeros((5, 5), dtype=np.uint8)
    >>> start = (0, 1)
    >>> end = (3, 3)
    >>> rr, cc = rectangle(start, end=end, shape=img.shape)
    >>> img[rr, cc] = 1
    >>> img
    array([[0, 1, 1, 1, 0],
           [0, 1, 1, 1, 0],
           [0, 1, 1, 1, 0],
           [0, 1, 1, 1, 0],
           [0, 0, 0, 0, 0]], dtype=uint8)
    
    
    >>> import numpy as np
    >>> from skimage.draw import rectangle
    >>> img = np.zeros((6, 6), dtype=np.uint8)
    >>> start = (3, 3)
    >>>
    >>> rr, cc = rectangle(start, extent=(2, 2))
    >>> img[rr, cc] = 1
    >>> rr, cc = rectangle(start, extent=(-2, 2))
    >>> img[rr, cc] = 2
    >>> rr, cc = rectangle(start, extent=(-2, -2))
    >>> img[rr, cc] = 3
    >>> rr, cc = rectangle(start, extent=(2, -2))
    >>> img[rr, cc] = 4
    >>> print(img)
    [[0 0 0 0 0 0]
     [0 3 3 2 2 0]
     [0 3 3 2 2 0]
     [0 4 4 1 1 0]
     [0 4 4 1 1 0]
     [0 0 0 0 0 0]]
    
## rectangle_perimeter

`skimage.draw.rectangle_perimeter(start, end=None, extent=None, shape=None,
clip=False)` [source]

    
Generate coordinates of pixels that are exactly around a rectangle.

Parameters

    
`starttuple`

    
Origin point of the inner rectangle, e.g., `(row, column)`.

`endtuple`

    
End point of the inner rectangle `(row, column)`. For a 2D matrix, the slice
defined by inner the rectangle is `[start:(end+1)]`. Either `end` or `extent`
must be specified.

`extenttuple`

    
The extent (size) of the inner rectangle. E.g., `(num_rows, num_cols)`. Either
`end` or `extent` must be specified. Negative extents are permitted. See
`rectangle` to better understand how they behave.

`shapetuple, optional`

    
Image shape used to determine the maximum bounds of the output coordinates.
This is useful for clipping perimeters that exceed the image size. By default,
no clipping is done. Must be at least length 2. Only the first two values are
used to determine the extent of the input image.

`clipbool, optional`

    
Whether to clip the perimeter to the provided shape. If this is set to True,
the drawn figure will always be a closed polygon with all edges visible.

Returns

    
`coordsarray of int, shape (2, Npoints)`

    
The coordinates of all pixels in the rectangle.

#### Examples

    
    >>> import numpy as np
    >>> from skimage.draw import rectangle_perimeter
    >>> img = np.zeros((5, 6), dtype=np.uint8)
    >>> start = (2, 3)
    >>> end = (3, 4)
    >>> rr, cc = rectangle_perimeter(start, end=end, shape=img.shape)
    >>> img[rr, cc] = 1
    >>> img
    array([[0, 0, 0, 0, 0, 0],
           [0, 0, 1, 1, 1, 1],
           [0, 0, 1, 0, 0, 1],
           [0, 0, 1, 0, 0, 1],
           [0, 0, 1, 1, 1, 1]], dtype=uint8)
    
    
    >>> img = np.zeros((5, 5), dtype=np.uint8)
    >>> r, c = rectangle_perimeter(start, (10, 10), shape=img.shape, clip=True)
    >>> img[r, c] = 1
    >>> img
    array([[0, 0, 0, 0, 0],
           [0, 0, 1, 1, 1],
           [0, 0, 1, 0, 1],
           [0, 0, 1, 0, 1],
           [0, 0, 1, 1, 1]], dtype=uint8)
    
## set_color

`skimage.draw.set_color(image, coords, color, alpha=1)` [source]

    
Set pixel color in the image at the given coordinates.

Note that this function modifies the color of the image in-place. Coordinates
that exceed the shape of the image will be ignored.

Parameters

    
`image(M, N, D) ndarray`

    
Image

`coordstuple of ((P,) ndarray, (P,) ndarray)`

    
Row and column coordinates of pixels to be colored.

`color(D,) ndarray`

    
Color to be assigned to coordinates in the image.

`alphascalar or (N,) ndarray`

    
Alpha values used to blend color with image. 0 is transparent, 1 is opaque.

#### Examples

    
    >>> from skimage.draw import line, set_color
    >>> img = np.zeros((10, 10), dtype=np.uint8)
    >>> rr, cc = line(1, 1, 20, 20)
    >>> set_color(img, (rr, cc), 1)
    >>> img
    array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 1, 0, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 1, 0, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
           [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]], dtype=uint8)
    
© 2019 the scikit-image team  
Licensed under the BSD 3-clause License.  
https://scikit-image.org/docs/0.18.x/api/skimage.draw.html

  *[ISP]: Internet Service Provider
  *[LIFO]: last-in, first-out
  *[FIFO]: first-in, first-out

