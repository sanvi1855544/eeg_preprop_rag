# Module: util

`skimage.util.apply_parallel`(function, array) | Map a function in parallel across an array.  
---|---  
`skimage.util.compare_images`(image1, image2) | Return an image showing the differences between two images.  
`skimage.util.crop`(ar, crop_width[, copy, order]) | Crop array `ar` by `crop_width` along each dimension.  
`skimage.util.dtype_limits`(image[, clip_negative]) | Return intensity limits, i.e.  
`skimage.util.img_as_bool`(image[, force_copy]) | Convert an image to boolean format.  
`skimage.util.img_as_float`(image[, force_copy]) | Convert an image to floating point format.  
`skimage.util.img_as_float32`(image[, force_copy]) | Convert an image to single-precision (32-bit) floating point format.  
`skimage.util.img_as_float64`(image[, force_copy]) | Convert an image to double-precision (64-bit) floating point format.  
`skimage.util.img_as_int`(image[, force_copy]) | Convert an image to 16-bit signed integer format.  
`skimage.util.img_as_ubyte`(image[, force_copy]) | Convert an image to 8-bit unsigned integer format.  
`skimage.util.img_as_uint`(image[, force_copy]) | Convert an image to 16-bit unsigned integer format.  
`skimage.util.invert`(image[, signed_float]) | Invert an image.  
`skimage.util.map_array`(input_arr, …[, out]) | Map values from input array from input_vals to output_vals.  
`skimage.util.montage`(arr_in[, fill, …]) | Create a montage of several single- or multichannel images.  
`skimage.util.pad`(array, pad_width[, mode]) | Pad an array.  
`skimage.util.random_noise`(image[, mode, …]) | Function to add random noise of various types to a floating-point image.  
`skimage.util.regular_grid`(ar_shape, n_points) | Find `n_points` regularly spaced along `ar_shape`.  
`skimage.util.regular_seeds`(ar_shape, n_points) | Return an image with ~`n_points` regularly-spaced nonzero pixels.  
`skimage.util.unique_rows`(ar) | Remove repeated rows from a 2D array.  
`skimage.util.view_as_blocks`(arr_in, block_shape) | Block view of the input n-dimensional array (using re-striding).  
`skimage.util.view_as_windows`(arr_in, …[, step]) | Rolling window view of the input n-dimensional array.  
## apply_parallel

`skimage.util.apply_parallel(function, array, chunks=None, depth=0, mode=None,
extra_arguments=(), extra_keywords={}, *, dtype=None, multichannel=False,
compute=None)` [source]

    
Map a function in parallel across an array.

Split an array into possibly overlapping chunks of a given depth and boundary
type, call the given function in parallel on the chunks, combine the chunks
and return the resulting array.

Parameters

    
`functionfunction`

    
Function to be mapped which takes an array as an argument.

`arraynumpy array or dask array`

    
Array which the function will be applied to.

`chunksint, tuple, or tuple of tuples, optional`

    
A single integer is interpreted as the length of one side of a square chunk
that should be tiled across the array. One tuple of length `array.ndim`
represents the shape of a chunk, and it is tiled across the array. A list of
tuples of length `ndim`, where each sub-tuple is a sequence of chunk sizes
along the corresponding dimension. If None, the array is broken up into chunks
based on the number of available cpus. More information about chunks is in the
documentation here.

`depthint, optional`

    
Integer equal to the depth of the added boundary cells. Defaults to zero.

`mode{‘reflect’, ‘symmetric’, ‘periodic’, ‘wrap’, ‘nearest’, ‘edge’},
optional`

    
type of external boundary padding.

`extra_argumentstuple, optional`

    
Tuple of arguments to be passed to the function.

`extra_keywordsdictionary, optional`

    
Dictionary of keyword arguments to be passed to the function.

`dtypedata-type or None, optional`

    
The data-type of the `function` output. If None, Dask will attempt to infer
this by calling the function on data of shape `(1,) * ndim`. For functions
expecting RGB or multichannel data this may be problematic. In such cases, the
user should manually specify this dtype argument instead.

New in version 0.18: `dtype` was added in 0.18.

`multichannelbool, optional`

    
If `chunks` is None and `multichannel` is True, this function will keep only a
single chunk along the channels axis. When `depth` is specified as a scalar
value, that depth will be applied only to the non-channels axes (a depth of 0
will be used along the channels axis). If the user manually specified both
`chunks` and a `depth` tuple, then this argument will have no effect.

New in version 0.18: `multichannel` was added in 0.18.

`computebool, optional`

    
If `True`, compute eagerly returning a NumPy Array. If `False`, compute lazily
returning a Dask Array. If `None` (default), compute based on array type
provided (eagerly for NumPy Arrays and lazily for Dask Arrays).

Returns

    
`outndarray or dask Array`

    
Returns the result of the applying the operation. Type is dependent on the
`compute` argument.

#### Notes

Numpy edge modes ‘symmetric’, ‘wrap’, and ‘edge’ are converted to the
equivalent `dask` boundary modes ‘reflect’, ‘periodic’ and ‘nearest’,
respectively. Setting `compute=False` can be useful for chaining later
operations. For example region selection to preview a result or storing large
data to disk instead of loading in memory.

## compare_images

`skimage.util.compare_images(image1, image2, method='diff', *, n_tiles=(8,
8))` [source]

    
Return an image showing the differences between two images.

New in version 0.16.

Parameters

    
`image1, image22-D array`

    
Images to process, must be of the same shape.

`methodstring, optional`

    
Method used for the comparison. Valid values are {‘diff’, ‘blend’,
‘checkerboard’}. Details are provided in the note section.

`n_tilestuple, optional`

    
Used only for the `checkerboard` method. Specifies the number of tiles (row,
column) to divide the image.

Returns

    
`comparison2-D array`

    
Image showing the differences.

#### Notes

`'diff'` computes the absolute difference between the two images. `'blend'`
computes the mean value. `'checkerboard'` makes tiles of dimension `n_tiles`
that display alternatively the first and the second image.

## crop

`skimage.util.crop(ar, crop_width, copy=False, order='K')` [source]

    
Crop array `ar` by `crop_width` along each dimension.

Parameters

    
`ararray-like of rank N`

    
Input array.

`crop_width{sequence, int}`

    
Number of values to remove from the edges of each axis. `((before_1,
after_1),` … `(before_N, after_N))` specifies unique crop widths at the start
and end of each axis. `((before, after),) or (before, after)` specifies a
fixed start and end crop for every axis. `(n,)` or `n` for integer `n` is a
shortcut for before = after = `n` for all axes.

`copybool, optional`

    
If `True`, ensure the returned array is a contiguous copy. Normally, a crop
operation will return a discontiguous view of the underlying input array.

`order{‘C’, ‘F’, ‘A’, ‘K’}, optional`

    
If `copy==True`, control the memory layout of the copy. See `np.copy`.

Returns

    
`croppedarray`

    
The cropped array. If `copy=False` (default), this is a sliced view of the
input array.

## dtype_limits

`skimage.util.dtype_limits(image, clip_negative=False)` [source]

    
Return intensity limits, i.e. (min, max) tuple, of the image’s dtype.

Parameters

    
`imagendarray`

    
Input image.

`clip_negativebool, optional`

    
If True, clip the negative range (i.e. return 0 for min intensity) even if the
image dtype allows negative values.

Returns

    
`imin, imaxtuple`

    
Lower and upper intensity limits.

## img_as_bool

`skimage.util.img_as_bool(image, force_copy=False)` [source]

    
Convert an image to boolean format.

Parameters

    
`imagendarray`

    
Input image.

`force_copybool, optional`

    
Force a copy of the data, irrespective of its current dtype.

Returns

    
`outndarray of bool (bool_)`

    
Output image.

#### Notes

The upper half of the input dtype’s positive range is True, and the lower half
is False. All negative values (if present) are False.

## img_as_float

`skimage.util.img_as_float(image, force_copy=False)` [source]

    
Convert an image to floating point format.

This function is similar to `img_as_float64`, but will not convert lower-
precision floating point arrays to `float64`.

Parameters

    
`imagendarray`

    
Input image.

`force_copybool, optional`

    
Force a copy of the data, irrespective of its current dtype.

Returns

    
`outndarray of float`

    
Output image.

#### Notes

The range of a floating point image is [0.0, 1.0] or [-1.0, 1.0] when
converting from unsigned or signed datatypes, respectively. If the input image
has a float type, intensity values are not modified and can be outside the
ranges [0.0, 1.0] or [-1.0, 1.0].

## img_as_float32

`skimage.util.img_as_float32(image, force_copy=False)` [source]

    
Convert an image to single-precision (32-bit) floating point format.

Parameters

    
`imagendarray`

    
Input image.

`force_copybool, optional`

    
Force a copy of the data, irrespective of its current dtype.

Returns

    
`outndarray of float32`

    
Output image.

#### Notes

The range of a floating point image is [0.0, 1.0] or [-1.0, 1.0] when
converting from unsigned or signed datatypes, respectively. If the input image
has a float type, intensity values are not modified and can be outside the
ranges [0.0, 1.0] or [-1.0, 1.0].

## img_as_float64

`skimage.util.img_as_float64(image, force_copy=False)` [source]

    
Convert an image to double-precision (64-bit) floating point format.

Parameters

    
`imagendarray`

    
Input image.

`force_copybool, optional`

    
Force a copy of the data, irrespective of its current dtype.

Returns

    
`outndarray of float64`

    
Output image.

#### Notes

The range of a floating point image is [0.0, 1.0] or [-1.0, 1.0] when
converting from unsigned or signed datatypes, respectively. If the input image
has a float type, intensity values are not modified and can be outside the
ranges [0.0, 1.0] or [-1.0, 1.0].

## img_as_int

`skimage.util.img_as_int(image, force_copy=False)` [source]

    
Convert an image to 16-bit signed integer format.

Parameters

    
`imagendarray`

    
Input image.

`force_copybool, optional`

    
Force a copy of the data, irrespective of its current dtype.

Returns

    
`outndarray of int16`

    
Output image.

#### Notes

The values are scaled between -32768 and 32767. If the input data-type is
positive-only (e.g., uint8), then the output image will still only have
positive values.

## img_as_ubyte

`skimage.util.img_as_ubyte(image, force_copy=False)` [source]

    
Convert an image to 8-bit unsigned integer format.

Parameters

    
`imagendarray`

    
Input image.

`force_copybool, optional`

    
Force a copy of the data, irrespective of its current dtype.

Returns

    
`outndarray of ubyte (uint8)`

    
Output image.

#### Notes

Negative input values will be clipped. Positive values are scaled between 0
and 255.

## img_as_uint

`skimage.util.img_as_uint(image, force_copy=False)` [source]

    
Convert an image to 16-bit unsigned integer format.

Parameters

    
`imagendarray`

    
Input image.

`force_copybool, optional`

    
Force a copy of the data, irrespective of its current dtype.

Returns

    
`outndarray of uint16`

    
Output image.

#### Notes

Negative input values will be clipped. Positive values are scaled between 0
and 65535.

## invert

`skimage.util.invert(image, signed_float=False)` [source]

    
Invert an image.

Invert the intensity range of the input image, so that the dtype maximum is
now the dtype minimum, and vice-versa. This operation is slightly different
depending on the input dtype:

  * unsigned integers: subtract the image from the dtype maximum
  * signed integers: subtract the image from -1 (see Notes)
  * floats: subtract the image from 1 (if signed_float is False, so we assume the image is unsigned), or from 0 (if signed_float is True).

See the examples for clarification.

Parameters

    
`imagendarray`

    
Input image.

`signed_floatbool, optional`

    
If True and the image is of type float, the range is assumed to be [-1, 1]. If
False and the image is of type float, the range is assumed to be [0, 1].

Returns

    
`invertedndarray`

    
Inverted image.

#### Notes

Ideally, for signed integers we would simply multiply by -1. However, signed
integer ranges are asymmetric. For example, for np.int8, the range of possible
values is [-128, 127], so that -128 * -1 equals -128! By subtracting from -1,
we correctly map the maximum dtype value to the minimum.

#### Examples

    
    >>> img = np.array([[100,  0, 200],
    ...                 [  0, 50,   0],
    ...                 [ 30,  0, 255]], np.uint8)
    >>> invert(img)
    array([[155, 255,  55],
           [255, 205, 255],
           [225, 255,   0]], dtype=uint8)
    >>> img2 = np.array([[ -2, 0, -128],
    ...                  [127, 0,    5]], np.int8)
    >>> invert(img2)
    array([[   1,   -1,  127],
           [-128,   -1,   -6]], dtype=int8)
    >>> img3 = np.array([[ 0., 1., 0.5, 0.75]])
    >>> invert(img3)
    array([[1.  , 0.  , 0.5 , 0.25]])
    >>> img4 = np.array([[ 0., 1., -1., -0.25]])
    >>> invert(img4, signed_float=True)
    array([[-0.  , -1.  ,  1.  ,  0.25]])
    
### Examples using `skimage.util.invert`

![Use rolling-ball algorithm for estimating background
intensity](data:image/png;base64,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)

Use rolling-ball algorithm for estimating background intensity

## map_array

`skimage.util.map_array(input_arr, input_vals, output_vals, out=None)`
[source]

    
Map values from input array from input_vals to output_vals.

Parameters

    
`input_arrarray of int, shape (M[, N][, P][, …])`

    
The input label image.

`input_valsarray of int, shape (N,)`

    
The values to map from.

`output_valsarray, shape (N,)`

    
The values to map to.

out: array, same shape as `input_arr`

    
The output array. Will be created if not provided. It should have the same
dtype as `output_vals`.

Returns

    
`outarray, same shape as input_arr`

    
The array of mapped values.

## montage

`skimage.util.montage(arr_in, fill='mean', rescale_intensity=False,
grid_shape=None, padding_width=0, multichannel=False)` [source]

    
Create a montage of several single- or multichannel images.

Create a rectangular montage from an input array representing an ensemble of
equally shaped single- (gray) or multichannel (color) images.

For example, `montage(arr_in)` called with the following `arr_in`

1 | 2 | 3  
---|---|---  
will return

1 | 2  
---|---  
3 | 
  * 
  
where the ‘*’ patch will be determined by the `fill` parameter.

Parameters

    
`arr_in(K, M, N[, C]) ndarray`

    
An array representing an ensemble of `K` images of equal shape.

`fillfloat or array-like of floats or ‘mean’, optional`

    
Value to fill the padding areas and/or the extra tiles in the output array.
Has to be `float` for single channel collections. For multichannel collections
has to be an array-like of shape of number of channels. If `mean`, uses the
mean value over all images.

`rescale_intensitybool, optional`

    
Whether to rescale the intensity of each image to [0, 1].

`grid_shapetuple, optional`

    
The desired grid shape for the montage `(ntiles_row, ntiles_column)`. The
default aspect ratio is square.

`padding_widthint, optional`

    
The size of the spacing between the tiles and between the tiles and the
borders. If non-zero, makes the boundaries of individual images easier to
perceive.

`multichannelboolean, optional`

    
If True, the last `arr_in` dimension is threated as a color channel, otherwise
as spatial.

Returns

    
`arr_out(K*(M+p)+p, K*(N+p)+p[, C]) ndarray`

    
Output array with input images glued together (including padding `p`).

#### Examples

    
    >>> import numpy as np
    >>> from skimage.util import montage
    >>> arr_in = np.arange(3 * 2 * 2).reshape(3, 2, 2)
    >>> arr_in  
    array([[[ 0,  1],
            [ 2,  3]],
           [[ 4,  5],
            [ 6,  7]],
           [[ 8,  9],
            [10, 11]]])
    >>> arr_out = montage(arr_in)
    >>> arr_out.shape
    (4, 4)
    >>> arr_out
    array([[ 0,  1,  4,  5],
           [ 2,  3,  6,  7],
           [ 8,  9,  5,  5],
           [10, 11,  5,  5]])
    >>> arr_in.mean()
    5.5
    >>> arr_out_nonsquare = montage(arr_in, grid_shape=(1, 3))
    >>> arr_out_nonsquare
    array([[ 0,  1,  4,  5,  8,  9],
           [ 2,  3,  6,  7, 10, 11]])
    >>> arr_out_nonsquare.shape
    (2, 6)
    
## pad

`skimage.util.pad(array, pad_width, mode='constant', **kwargs)` [source]

    
Pad an array.

Parameters

    
`arrayarray_like of rank N`

    
The array to pad.

`pad_width{sequence, array_like, int}`

    
Number of values padded to the edges of each axis. ((before_1, after_1), …
(before_N, after_N)) unique pad widths for each axis. ((before, after),)
yields same before and after pad for each axis. (pad,) or int is a shortcut
for before = after = pad width for all axes.

`modestr or function, optional`

    
One of the following string values or a user supplied function.

‘constant’ (default)

    
Pads with a constant value.

‘edge’

    
Pads with the edge values of array.

‘linear_ramp’

    
Pads with the linear ramp between end_value and the array edge value.

‘maximum’

    
Pads with the maximum value of all or part of the vector along each axis.

‘mean’

    
Pads with the mean value of all or part of the vector along each axis.

‘median’

    
Pads with the median value of all or part of the vector along each axis.

‘minimum’

    
Pads with the minimum value of all or part of the vector along each axis.

‘reflect’

    
Pads with the reflection of the vector mirrored on the first and last values
of the vector along each axis.

‘symmetric’

    
Pads with the reflection of the vector mirrored along the edge of the array.

‘wrap’

    
Pads with the wrap of the vector along the axis. The first values are used to
pad the end and the end values are used to pad the beginning.

‘empty’

    
Pads with undefined values.

New in version 1.17.

<function>

    
Padding function, see Notes.

`stat_lengthsequence or int, optional`

    
Used in ‘maximum’, ‘mean’, ‘median’, and ‘minimum’. Number of values at edge
of each axis used to calculate the statistic value.

((before_1, after_1), … (before_N, after_N)) unique statistic lengths for each
axis.

((before, after),) yields same before and after statistic lengths for each
axis.

(stat_length,) or int is a shortcut for before = after = statistic length for
all axes.

Default is `None`, to use the entire axis.

`constant_valuessequence or scalar, optional`

    
Used in ‘constant’. The values to set the padded values for each axis.

`((before_1, after_1), ... (before_N, after_N))` unique pad constants for each
axis.

`((before, after),)` yields same before and after constants for each axis.

`(constant,)` or `constant` is a shortcut for `before = after = constant` for
all axes.

Default is 0.

`end_valuessequence or scalar, optional`

    
Used in ‘linear_ramp’. The values used for the ending value of the linear_ramp
and that will form the edge of the padded array.

`((before_1, after_1), ... (before_N, after_N))` unique end values for each
axis.

`((before, after),)` yields same before and after end values for each axis.

`(constant,)` or `constant` is a shortcut for `before = after = constant` for
all axes.

Default is 0.

`reflect_type{‘even’, ‘odd’}, optional`

    
Used in ‘reflect’, and ‘symmetric’. The ‘even’ style is the default with an
unaltered reflection around the edge value. For the ‘odd’ style, the extended
part of the array is created by subtracting the reflected values from two
times the edge value.

Returns

    
`padndarray`

    
Padded array of rank equal to `array` with shape increased according to
`pad_width`.

#### Notes

New in version 1.7.0.

For an array with rank greater than 1, some of the padding of later axes is
calculated from padding of previous axes. This is easiest to think about with
a rank 2 array where the corners of the padded array are calculated by using
padded values from the first axis.

The padding function, if used, should modify a rank 1 array in-place. It has
the following signature:

    
    padding_func(vector, iaxis_pad_width, iaxis, kwargs)
    
where

`vectorndarray`

    
A rank 1 array already padded with zeros. Padded values are
vector[:iaxis_pad_width[0]] and vector[-iaxis_pad_width[1]:].

`iaxis_pad_widthtuple`

    
A 2-tuple of ints, iaxis_pad_width[0] represents the number of values padded
at the beginning of vector where iaxis_pad_width[1] represents the number of
values padded at the end of vector.

`iaxisint`

    
The axis currently being calculated.

`kwargsdict`

    
Any keyword arguments the function requires.

#### Examples

    
    >>> a = [1, 2, 3, 4, 5]
    >>> np.pad(a, (2, 3), 'constant', constant_values=(4, 6))
    array([4, 4, 1, ..., 6, 6, 6])
    
    
    >>> np.pad(a, (2, 3), 'edge')
    array([1, 1, 1, ..., 5, 5, 5])
    
    
    >>> np.pad(a, (2, 3), 'linear_ramp', end_values=(5, -4))
    array([ 5,  3,  1,  2,  3,  4,  5,  2, -1, -4])
    
    
    >>> np.pad(a, (2,), 'maximum')
    array([5, 5, 1, 2, 3, 4, 5, 5, 5])
    
    
    >>> np.pad(a, (2,), 'mean')
    array([3, 3, 1, 2, 3, 4, 5, 3, 3])
    
    
    >>> np.pad(a, (2,), 'median')
    array([3, 3, 1, 2, 3, 4, 5, 3, 3])
    
    
    >>> a = [[1, 2], [3, 4]]
    >>> np.pad(a, ((3, 2), (2, 3)), 'minimum')
    array([[1, 1, 1, 2, 1, 1, 1],
           [1, 1, 1, 2, 1, 1, 1],
           [1, 1, 1, 2, 1, 1, 1],
           [1, 1, 1, 2, 1, 1, 1],
           [3, 3, 3, 4, 3, 3, 3],
           [1, 1, 1, 2, 1, 1, 1],
           [1, 1, 1, 2, 1, 1, 1]])
    
    
    >>> a = [1, 2, 3, 4, 5]
    >>> np.pad(a, (2, 3), 'reflect')
    array([3, 2, 1, 2, 3, 4, 5, 4, 3, 2])
    
    
    >>> np.pad(a, (2, 3), 'reflect', reflect_type='odd')
    array([-1,  0,  1,  2,  3,  4,  5,  6,  7,  8])
    
    
    >>> np.pad(a, (2, 3), 'symmetric')
    array([2, 1, 1, 2, 3, 4, 5, 5, 4, 3])
    
    
    >>> np.pad(a, (2, 3), 'symmetric', reflect_type='odd')
    array([0, 1, 1, 2, 3, 4, 5, 5, 6, 7])
    
    
    >>> np.pad(a, (2, 3), 'wrap')
    array([4, 5, 1, 2, 3, 4, 5, 1, 2, 3])
    
    
    >>> def pad_with(vector, pad_width, iaxis, kwargs):
    ...     pad_value = kwargs.get('padder', 10)
    ...     vector[:pad_width[0]] = pad_value
    ...     vector[-pad_width[1]:] = pad_value
    >>> a = np.arange(6)
    >>> a = a.reshape((2, 3))
    >>> np.pad(a, 2, pad_with)
    array([[10, 10, 10, 10, 10, 10, 10],
           [10, 10, 10, 10, 10, 10, 10],
           [10, 10,  0,  1,  2, 10, 10],
           [10, 10,  3,  4,  5, 10, 10],
           [10, 10, 10, 10, 10, 10, 10],
           [10, 10, 10, 10, 10, 10, 10]])
    >>> np.pad(a, 2, pad_with, padder=100)
    array([[100, 100, 100, 100, 100, 100, 100],
           [100, 100, 100, 100, 100, 100, 100],
           [100, 100,   0,   1,   2, 100, 100],
           [100, 100,   3,   4,   5, 100, 100],
           [100, 100, 100, 100, 100, 100, 100],
           [100, 100, 100, 100, 100, 100, 100]])
    
## random_noise

`skimage.util.random_noise(image, mode='gaussian', seed=None, clip=True,
**kwargs)` [source]

    
Function to add random noise of various types to a floating-point image.

Parameters

    
`imagendarray`

    
Input image data. Will be converted to float.

`modestr, optional`

    
One of the following strings, selecting the type of noise to add:

  * ‘gaussian’ Gaussian-distributed additive noise.
  * ‘localvar’ Gaussian-distributed additive noise, with specified
    
local variance at each point of `image`.

  * ‘poisson’ Poisson-distributed noise generated from the data.
  * ‘salt’ Replaces random pixels with 1.
  * ‘pepper’ Replaces random pixels with 0 (for unsigned images) or
    
-1 (for signed images).
  * `‘s&p’ Replaces random pixels with either 1 or low_val, where`
    
`low_val` is 0 for unsigned images or -1 for signed images.

  * ‘speckle’ Multiplicative noise using out = image + n*image, where
    
n is Gaussian noise with specified mean & variance.

`seedint, optional`

    
If provided, this will set the random seed before generating noise, for valid
pseudo-random comparisons.

`clipbool, optional`

    
If True (default), the output will be clipped after noise applied for modes
`‘speckle’`, `‘poisson’`, and `‘gaussian’`. This is needed to maintain the
proper image data range. If False, clipping is not applied, and the output may
extend beyond the range [-1, 1].

`meanfloat, optional`

    
Mean of random distribution. Used in ‘gaussian’ and ‘speckle’. Default : 0.

`varfloat, optional`

    
Variance of random distribution. Used in ‘gaussian’ and ‘speckle’. Note:
variance = (standard deviation) ** 2. Default : 0.01

`local_varsndarray, optional`

    
Array of positive floats, same shape as `image`, defining the local variance
at every image point. Used in ‘localvar’.

`amountfloat, optional`

    
Proportion of image pixels to replace with noise on range [0, 1]. Used in
‘salt’, ‘pepper’, and ‘salt & pepper’. Default : 0.05

`salt_vs_pepperfloat, optional`

    
Proportion of salt vs. pepper noise for ‘s&p’ on range [0, 1]. Higher values
represent more salt. Default : 0.5 (equal amounts)

Returns

    
`outndarray`

    
Output floating-point image data on range [0, 1] or [-1, 1] if the input
`image` was unsigned or signed, respectively.

#### Notes

Speckle, Poisson, Localvar, and Gaussian noise may generate noise outside the
valid image range. The default is to clip (not alias) these values, but they
may be preserved by setting `clip=False`. Note that in this case the output
may contain values outside the ranges [0, 1] or [-1, 1]. Use this option with
care.

Because of the prevalence of exclusively positive floating-point images in
intermediate calculations, it is not possible to intuit if an input is signed
based on dtype alone. Instead, negative values are explicitly searched for.
Only if found does this function assume signed input. Unexpected results only
occur in rare, poorly exposes cases (e.g. if all values are above 50 percent
gray in a signed `image`). In this event, manually scaling the input to the
positive domain will solve the problem.

The Poisson distribution is only defined for positive integers. To apply this
noise type, the number of unique values in the image is found and the next
round power of two is used to scale up the floating-point result, after which
it is scaled back down to the floating-point image range.

To generate Poisson noise against a signed image, the signed image is
temporarily converted to an unsigned image in the floating point domain,
Poisson noise is generated, then it is returned to the original range.

## regular_grid

`skimage.util.regular_grid(ar_shape, n_points)` [source]

    
Find `n_points` regularly spaced along `ar_shape`.

The returned points (as slices) should be as close to cubically-spaced as
possible. Essentially, the points are spaced by the Nth root of the input
array size, where N is the number of dimensions. However, if an array
dimension cannot fit a full step size, it is “discarded”, and the computation
is done for only the remaining dimensions.

Parameters

    
`ar_shapearray-like of ints`

    
The shape of the space embedding the grid. `len(ar_shape)` is the number of
dimensions.

`n_pointsint`

    
The (approximate) number of points to embed in the space.

Returns

    
`slicestuple of slice objects`

    
A slice along each dimension of `ar_shape`, such that the intersection of all
the slices give the coordinates of regularly spaced points.

Changed in version 0.14.1: In scikit-image 0.14.1 and 0.15, the return type
was changed from a list to a tuple to ensure compatibility with Numpy 1.15 and
higher. If your code requires the returned result to be a list, you may
convert the output of this function to a list with:

    
    >>> result = list(regular_grid(ar_shape=(3, 20, 40), n_points=8))
    
#### Examples

    
    >>> ar = np.zeros((20, 40))
    >>> g = regular_grid(ar.shape, 8)
    >>> g
    (slice(5, None, 10), slice(5, None, 10))
    >>> ar[g] = 1
    >>> ar.sum()
    8.0
    >>> ar = np.zeros((20, 40))
    >>> g = regular_grid(ar.shape, 32)
    >>> g
    (slice(2, None, 5), slice(2, None, 5))
    >>> ar[g] = 1
    >>> ar.sum()
    32.0
    >>> ar = np.zeros((3, 20, 40))
    >>> g = regular_grid(ar.shape, 8)
    >>> g
    (slice(1, None, 3), slice(5, None, 10), slice(5, None, 10))
    >>> ar[g] = 1
    >>> ar.sum()
    8.0
    
## regular_seeds

`skimage.util.regular_seeds(ar_shape, n_points, dtype=<class 'int'>)` [source]

    
Return an image with ~`n_points` regularly-spaced nonzero pixels.

Parameters

    
`ar_shapetuple of int`

    
The shape of the desired output image.

`n_pointsint`

    
The desired number of nonzero points.

`dtypenumpy data type, optional`

    
The desired data type of the output.

Returns

    
`seed_imgarray of int or bool`

    
The desired image.

#### Examples

    
    >>> regular_seeds((5, 5), 4)
    array([[0, 0, 0, 0, 0],
           [0, 1, 0, 2, 0],
           [0, 0, 0, 0, 0],
           [0, 3, 0, 4, 0],
           [0, 0, 0, 0, 0]])
    
## unique_rows

`skimage.util.unique_rows(ar)` [source]

    
Remove repeated rows from a 2D array.

In particular, if given an array of coordinates of shape (Npoints, Ndim), it
will remove repeated points.

Parameters

    
`ar2-D ndarray`

    
The input array.

Returns

    
`ar_out2-D ndarray`

    
A copy of the input array with repeated rows removed.

Raises

    
`ValueErrorif ar is not two-dimensional.`

#### Notes

The function will generate a copy of `ar` if it is not C-contiguous, which
will negatively affect performance for large input arrays.

#### Examples

    
    >>> ar = np.array([[1, 0, 1],
    ...                [0, 1, 0],
    ...                [1, 0, 1]], np.uint8)
    >>> unique_rows(ar)
    array([[0, 1, 0],
           [1, 0, 1]], dtype=uint8)
    
## view_as_blocks

`skimage.util.view_as_blocks(arr_in, block_shape)` [source]

    
Block view of the input n-dimensional array (using re-striding).

Blocks are non-overlapping views of the input array.

Parameters

    
`arr_inndarray`

    
N-d input array.

`block_shapetuple`

    
The shape of the block. Each dimension must divide evenly into the
corresponding dimensions of `arr_in`.

Returns

    
`arr_outndarray`

    
Block view of the input array.

#### Examples

    
    >>> import numpy as np
    >>> from skimage.util.shape import view_as_blocks
    >>> A = np.arange(4*4).reshape(4,4)
    >>> A
    array([[ 0,  1,  2,  3],
           [ 4,  5,  6,  7],
           [ 8,  9, 10, 11],
           [12, 13, 14, 15]])
    >>> B = view_as_blocks(A, block_shape=(2, 2))
    >>> B[0, 0]
    array([[0, 1],
           [4, 5]])
    >>> B[0, 1]
    array([[2, 3],
           [6, 7]])
    >>> B[1, 0, 1, 1]
    13
    
    
    >>> A = np.arange(4*4*6).reshape(4,4,6)
    >>> A  
    array([[[ 0,  1,  2,  3,  4,  5],
            [ 6,  7,  8,  9, 10, 11],
            [12, 13, 14, 15, 16, 17],
            [18, 19, 20, 21, 22, 23]],
           [[24, 25, 26, 27, 28, 29],
            [30, 31, 32, 33, 34, 35],
            [36, 37, 38, 39, 40, 41],
            [42, 43, 44, 45, 46, 47]],
           [[48, 49, 50, 51, 52, 53],
            [54, 55, 56, 57, 58, 59],
            [60, 61, 62, 63, 64, 65],
            [66, 67, 68, 69, 70, 71]],
           [[72, 73, 74, 75, 76, 77],
            [78, 79, 80, 81, 82, 83],
            [84, 85, 86, 87, 88, 89],
            [90, 91, 92, 93, 94, 95]]])
    >>> B = view_as_blocks(A, block_shape=(1, 2, 2))
    >>> B.shape
    (4, 2, 3, 1, 2, 2)
    >>> B[2:, 0, 2]  
    array([[[[52, 53],
             [58, 59]]],
           [[[76, 77],
             [82, 83]]]])
    
## view_as_windows

`skimage.util.view_as_windows(arr_in, window_shape, step=1)` [source]

    
Rolling window view of the input n-dimensional array.

Windows are overlapping views of the input array, with adjacent windows
shifted by a single row or column (or an index of a higher dimension).

Parameters

    
`arr_inndarray`

    
N-d input array.

`window_shapeinteger or tuple of length arr_in.ndim`

    
Defines the shape of the elementary n-dimensional orthotope (better know as
hyperrectangle [1]) of the rolling window view. If an integer is given, the
shape will be a hypercube of sidelength given by its value.

`stepinteger or tuple of length arr_in.ndim`

    
Indicates step size at which extraction shall be performed. If integer is
given, then the step is uniform in all dimensions.

Returns

    
`arr_outndarray`

    
(rolling) window view of the input array.

#### Notes

One should be very careful with rolling views when it comes to memory usage.
Indeed, although a ‘view’ has the same memory footprint as its base array, the
actual array that emerges when this ‘view’ is used in a computation is
generally a (much) larger array than the original, especially for
2-dimensional arrays and above.

For example, let us consider a 3 dimensional array of size (100, 100, 100) of
`float64`. This array takes about 8*100**3 Bytes for storage which is just 8
MB. If one decides to build a rolling view on this array with a window of (3,
3, 3) the hypothetical size of the rolling view (if one was to reshape the
view for example) would be 8*(100-3+1)**3*3**3 which is about 203 MB! The
scaling becomes even worse as the dimension of the input array becomes larger.

#### References

`1`

    
https://en.wikipedia.org/wiki/Hyperrectangle

#### Examples

    
    >>> import numpy as np
    >>> from skimage.util.shape import view_as_windows
    >>> A = np.arange(4*4).reshape(4,4)
    >>> A
    array([[ 0,  1,  2,  3],
           [ 4,  5,  6,  7],
           [ 8,  9, 10, 11],
           [12, 13, 14, 15]])
    >>> window_shape = (2, 2)
    >>> B = view_as_windows(A, window_shape)
    >>> B[0, 0]
    array([[0, 1],
           [4, 5]])
    >>> B[0, 1]
    array([[1, 2],
           [5, 6]])
    
    
    >>> A = np.arange(10)
    >>> A
    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
    >>> window_shape = (3,)
    >>> B = view_as_windows(A, window_shape)
    >>> B.shape
    (8, 3)
    >>> B
    array([[0, 1, 2],
           [1, 2, 3],
           [2, 3, 4],
           [3, 4, 5],
           [4, 5, 6],
           [5, 6, 7],
           [6, 7, 8],
           [7, 8, 9]])
    
    
    >>> A = np.arange(5*4).reshape(5, 4)
    >>> A
    array([[ 0,  1,  2,  3],
           [ 4,  5,  6,  7],
           [ 8,  9, 10, 11],
           [12, 13, 14, 15],
           [16, 17, 18, 19]])
    >>> window_shape = (4, 3)
    >>> B = view_as_windows(A, window_shape)
    >>> B.shape
    (2, 2, 4, 3)
    >>> B  
    array([[[[ 0,  1,  2],
             [ 4,  5,  6],
             [ 8,  9, 10],
             [12, 13, 14]],
            [[ 1,  2,  3],
             [ 5,  6,  7],
             [ 9, 10, 11],
             [13, 14, 15]]],
           [[[ 4,  5,  6],
             [ 8,  9, 10],
             [12, 13, 14],
             [16, 17, 18]],
            [[ 5,  6,  7],
             [ 9, 10, 11],
             [13, 14, 15],
             [17, 18, 19]]]])
    
© 2019 the scikit-image team  
Licensed under the BSD 3-clause License.  
https://scikit-image.org/docs/0.18.x/api/skimage.util.html

  *[ISP]: Internet Service Provider
  *[LIFO]: last-in, first-out
  *[FIFO]: first-in, first-out

