# Module: filters

`skimage.filters.apply_hysteresis_threshold`(…) | Apply hysteresis thresholding to `image`.  
---|---  
`skimage.filters.correlate_sparse`(image, kernel) | Compute valid cross-correlation of `padded_array` and `kernel`.  
`skimage.filters.difference_of_gaussians`(…) | Find features between `low_sigma` and `high_sigma` in size.  
`skimage.filters.farid`(image, *[, mask]) | Find the edge magnitude using the Farid transform.  
`skimage.filters.farid_h`(image, *[, mask]) | Find the horizontal edges of an image using the Farid transform.  
`skimage.filters.farid_v`(image, *[, mask]) | Find the vertical edges of an image using the Farid transform.  
`skimage.filters.frangi`(image[, sigmas, …]) | Filter an image with the Frangi vesselness filter.  
`skimage.filters.gabor`(image, frequency[, …]) | Return real and imaginary responses to Gabor filter.  
`skimage.filters.gabor_kernel`(frequency[, …]) | Return complex 2D Gabor filter kernel.  
`skimage.filters.gaussian`(image[, sigma, …]) | Multi-dimensional Gaussian filter.  
`skimage.filters.hessian`(image[, sigmas, …]) | Filter an image with the Hybrid Hessian filter.  
`skimage.filters.inverse`(data[, …]) | Apply the filter in reverse to the given data.  
`skimage.filters.laplace`(image[, ksize, mask]) | Find the edges of an image using the Laplace operator.  
`skimage.filters.median`(image[, selem, out, …]) | Return local median of an image.  
`skimage.filters.meijering`(image[, sigmas, …]) | Filter an image with the Meijering neuriteness filter.  
`skimage.filters.prewitt`(image[, mask, axis, …]) | Find the edge magnitude using the Prewitt transform.  
`skimage.filters.prewitt_h`(image[, mask]) | Find the horizontal edges of an image using the Prewitt transform.  
`skimage.filters.prewitt_v`(image[, mask]) | Find the vertical edges of an image using the Prewitt transform.  
`skimage.filters.rank_order`(image) | Return an image of the same shape where each pixel is the index of the pixel value in the ascending order of the unique values of `image`, aka the rank-order value.  
`skimage.filters.roberts`(image[, mask]) | Find the edge magnitude using Roberts’ cross operator.  
`skimage.filters.roberts_neg_diag`(image[, mask]) | Find the cross edges of an image using the Roberts’ Cross operator.  
`skimage.filters.roberts_pos_diag`(image[, mask]) | Find the cross edges of an image using Roberts’ cross operator.  
`skimage.filters.sato`(image[, sigmas, …]) | Filter an image with the Sato tubeness filter.  
`skimage.filters.scharr`(image[, mask, axis, …]) | Find the edge magnitude using the Scharr transform.  
`skimage.filters.scharr_h`(image[, mask]) | Find the horizontal edges of an image using the Scharr transform.  
`skimage.filters.scharr_v`(image[, mask]) | Find the vertical edges of an image using the Scharr transform.  
`skimage.filters.sobel`(image[, mask, axis, …]) | Find edges in an image using the Sobel filter.  
`skimage.filters.sobel_h`(image[, mask]) | Find the horizontal edges of an image using the Sobel transform.  
`skimage.filters.sobel_v`(image[, mask]) | Find the vertical edges of an image using the Sobel transform.  
`skimage.filters.threshold_isodata`([image, …]) | Return threshold value(s) based on ISODATA method.  
`skimage.filters.threshold_li`(image, *[, …]) | Compute threshold value by Li’s iterative Minimum Cross Entropy method.  
`skimage.filters.threshold_local`(image, …) | Compute a threshold mask image based on local pixel neighborhood.  
`skimage.filters.threshold_mean`(image) | Return threshold value based on the mean of grayscale values.  
`skimage.filters.threshold_minimum`([image, …]) | Return threshold value based on minimum method.  
`skimage.filters.threshold_multiotsu`(image[, …]) | Generate `classes`-1 threshold values to divide gray levels in `image`.  
`skimage.filters.threshold_niblack`(image[, …]) | Applies Niblack local threshold to an array.  
`skimage.filters.threshold_otsu`([image, …]) | Return threshold value based on Otsu’s method.  
`skimage.filters.threshold_sauvola`(image[, …]) | Applies Sauvola local threshold to an array.  
`skimage.filters.threshold_triangle`(image[, …]) | Return threshold value based on the triangle algorithm.  
`skimage.filters.threshold_yen`([image, …]) | Return threshold value based on Yen’s method.  
`skimage.filters.try_all_threshold`(image[, …]) | Returns a figure comparing the outputs of different thresholding methods.  
`skimage.filters.unsharp_mask`(image[, …]) | Unsharp masking filter.  
`skimage.filters.wiener`(data[, …]) | Minimum Mean Square Error (Wiener) inverse filter.  
`skimage.filters.window`(window_type, shape[, …]) | Return an n-dimensional window of a given size and dimensionality.  
`skimage.filters.LPIFilter2D`(…) | Linear Position-Invariant Filter (2-dimensional)  
`skimage.filters.rank` |   
## apply_hysteresis_threshold

`skimage.filters.apply_hysteresis_threshold(image, low, high)` [source]

    
Apply hysteresis thresholding to `image`.

This algorithm finds regions where `image` is greater than `high` OR `image`
is greater than `low` and that region is connected to a region greater than
`high`.

Parameters

    
`imagearray, shape (M,[ N, …, P])`

    
Grayscale input image.

`lowfloat, or array of same shape as image`

    
Lower threshold.

`highfloat, or array of same shape as image`

    
Higher threshold.

Returns

    
`thresholdedarray of bool, same shape as image`

    
Array in which `True` indicates the locations where `image` was above the
hysteresis threshold.

#### References

`1`

    
J. Canny. A computational approach to edge detection. IEEE Transactions on
Pattern Analysis and Machine Intelligence. 1986; vol. 8, pp.679-698.
DOI:10.1109/TPAMI.1986.4767851

#### Examples

    
    >>> image = np.array([1, 2, 3, 2, 1, 2, 1, 3, 2])
    >>> apply_hysteresis_threshold(image, 1.5, 2.5).astype(int)
    array([0, 1, 1, 1, 0, 0, 0, 1, 1])
    
## correlate_sparse

`skimage.filters.correlate_sparse(image, kernel, mode='reflect')` [source]

    
Compute valid cross-correlation of `padded_array` and `kernel`.

This function is fast when `kernel` is large with many zeros.

See `scipy.ndimage.correlate` for a description of cross-correlation.

Parameters

    
`imagendarray, dtype float, shape (M, N,[ …,] P)`

    
The input array. If mode is ‘valid’, this array should already be padded, as a
margin of the same shape as kernel will be stripped off.

`kernelndarray, dtype float shape (Q, R,[ …,] S)`

    
The kernel to be correlated. Must have the same number of dimensions as
`padded_array`. For high performance, it should be sparse (few nonzero
entries).

`modestring, optional`

    
See `scipy.ndimage.correlate` for valid modes. Additionally, mode ‘valid’ is
accepted, in which case no padding is applied and the result is the result for
the smaller image for which the kernel is entirely inside the original data.

Returns

    
`resultarray of float, shape (M, N,[ …,] P)`

    
The result of cross-correlating `image` with `kernel`. If mode ‘valid’ is
used, the resulting shape is (M-Q+1, N-R+1,[ …,] P-S+1).

## difference_of_gaussians

`skimage.filters.difference_of_gaussians(image, low_sigma, high_sigma=None, *,
mode='nearest', cval=0, multichannel=False, truncate=4.0)` [source]

    
Find features between `low_sigma` and `high_sigma` in size.

This function uses the Difference of Gaussians method for applying band-pass
filters to multi-dimensional arrays. The input array is blurred with two
Gaussian kernels of differing sigmas to produce two intermediate, filtered
images. The more-blurred image is then subtracted from the less-blurred image.
The final output image will therefore have had high-frequency components
attenuated by the smaller-sigma Gaussian, and low frequency components will
have been removed due to their presence in the more-blurred intermediate.

Parameters

    
`imagendarray`

    
Input array to filter.

`low_sigmascalar or sequence of scalars`

    
Standard deviation(s) for the Gaussian kernel with the smaller sigmas across
all axes. The standard deviations are given for each axis as a sequence, or as
a single number, in which case the single number is used as the standard
deviation value for all axes.

`high_sigmascalar or sequence of scalars, optional (default is None)`

    
Standard deviation(s) for the Gaussian kernel with the larger sigmas across
all axes. The standard deviations are given for each axis as a sequence, or as
a single number, in which case the single number is used as the standard
deviation value for all axes. If None is given (default), sigmas for all axes
are calculated as 1.6 * low_sigma.

`mode{‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’}, optional`

    
The `mode` parameter determines how the array borders are handled, where
`cval` is the value when mode is equal to ‘constant’. Default is ‘nearest’.

`cvalscalar, optional`

    
Value to fill past edges of input if `mode` is ‘constant’. Default is 0.0

`multichannelbool, optional (default: False)`

    
Whether the last axis of the image is to be interpreted as multiple channels.
If True, each channel is filtered separately (channels are not mixed
together).

`truncatefloat, optional (default is 4.0)`

    
Truncate the filter at this many standard deviations.

Returns

    
`filtered_imagendarray`

    
the filtered array.

See also

`skimage.feature.blog_dog`

#### Notes

This function will subtract an array filtered with a Gaussian kernel with
sigmas given by `high_sigma` from an array filtered with a Gaussian kernel
with sigmas provided by `low_sigma`. The values for `high_sigma` must always
be greater than or equal to the corresponding values in `low_sigma`, or a
`ValueError` will be raised.

When `high_sigma` is none, the values for `high_sigma` will be calculated as
1.6x the corresponding values in `low_sigma`. This ratio was originally
proposed by Marr and Hildreth (1980) [1] and is commonly used when
approximating the inverted Laplacian of Gaussian, which is used in edge and
blob detection.

Input image is converted according to the conventions of `img_as_float`.

Except for sigma values, all parameters are used for both filters.

#### References

`1`

    
Marr, D. and Hildreth, E. Theory of Edge Detection. Proc. R. Soc. Lond. Series
B 207, 187-217 (1980). https://doi.org/10.1098/rspb.1980.0020

#### Examples

Apply a simple Difference of Gaussians filter to a color image:

    
    >>> from skimage.data import astronaut
    >>> from skimage.filters import difference_of_gaussians
    >>> filtered_image = difference_of_gaussians(astronaut(), 2, 10,
    ...                                          multichannel=True)
    
Apply a Laplacian of Gaussian filter as approximated by the Difference of
Gaussians filter:

    
    >>> filtered_image = difference_of_gaussians(astronaut(), 2,
    ...                                          multichannel=True)
    
Apply a Difference of Gaussians filter to a grayscale image using different
sigma values for each axis:

    
    >>> from skimage.data import camera
    >>> filtered_image = difference_of_gaussians(camera(), (2,5), (3,20))
    
## farid

`skimage.filters.farid(image, *, mask=None)` [source]

    
Find the edge magnitude using the Farid transform.

Parameters

    
`image2-D array`

    
Image to process.

`mask2-D array, optional`

    
An optional mask to limit the application to a certain area. Note that pixels
surrounding masked regions are also masked to prevent masked regions from
affecting the result.

Returns

    
`output2-D array`

    
The Farid edge map.

See also

`sobel, prewitt, canny`

#### Notes

Take the square root of the sum of the squares of the horizontal and vertical
derivatives to get a magnitude that is somewhat insensitive to direction.
Similar to the Scharr operator, this operator is designed with a rotation
invariance constraint.

#### References

`1`

    
Farid, H. and Simoncelli, E. P., “Differentiation of discrete multidimensional
signals”, IEEE Transactions on Image Processing 13(4): 496-508, 2004.
DOI:10.1109/TIP.2004.823819

`2`

    
Wikipedia, “Farid and Simoncelli Derivatives.” Available at:
<https://en.wikipedia.org/wiki/Image_derivatives#Farid_and_Simoncelli_Derivatives>

#### Examples

    
    >>> from skimage import data
    >>> camera = data.camera()
    >>> from skimage import filters
    >>> edges = filters.farid(camera)
    
## farid_h

`skimage.filters.farid_h(image, *, mask=None)` [source]

    
Find the horizontal edges of an image using the Farid transform.

Parameters

    
`image2-D array`

    
Image to process.

`mask2-D array, optional`

    
An optional mask to limit the application to a certain area. Note that pixels
surrounding masked regions are also masked to prevent masked regions from
affecting the result.

Returns

    
`output2-D array`

    
The Farid edge map.

#### Notes

The kernel was constructed using the 5-tap weights from [1].

#### References

`1`

    
Farid, H. and Simoncelli, E. P., “Differentiation of discrete multidimensional
signals”, IEEE Transactions on Image Processing 13(4): 496-508, 2004.
DOI:10.1109/TIP.2004.823819

`2`

    
Farid, H. and Simoncelli, E. P. “Optimally rotation-equivariant directional
derivative kernels”, In: 7th International Conference on Computer Analysis of
Images and Patterns, Kiel, Germany. Sep, 1997.

## farid_v

`skimage.filters.farid_v(image, *, mask=None)` [source]

    
Find the vertical edges of an image using the Farid transform.

Parameters

    
`image2-D array`

    
Image to process.

`mask2-D array, optional`

    
An optional mask to limit the application to a certain area. Note that pixels
surrounding masked regions are also masked to prevent masked regions from
affecting the result.

Returns

    
`output2-D array`

    
The Farid edge map.

#### Notes

The kernel was constructed using the 5-tap weights from [1].

#### References

`1`

    
Farid, H. and Simoncelli, E. P., “Differentiation of discrete multidimensional
signals”, IEEE Transactions on Image Processing 13(4): 496-508, 2004.
DOI:10.1109/TIP.2004.823819

## frangi

`skimage.filters.frangi(image, sigmas=range(1, 10, 2), scale_range=None,
scale_step=None, alpha=0.5, beta=0.5, gamma=15, black_ridges=True,
mode='reflect', cval=0)` [source]

    
Filter an image with the Frangi vesselness filter.

This filter can be used to detect continuous ridges, e.g. vessels, wrinkles,
rivers. It can be used to calculate the fraction of the whole image containing
such objects.

Defined only for 2-D and 3-D images. Calculates the eigenvectors of the
Hessian to compute the similarity of an image region to vessels, according to
the method described in [1].

Parameters

    
`image(N, M[, P]) ndarray`

    
Array with input image data.

`sigmasiterable of floats, optional`

    
Sigmas used as scales of filter, i.e., np.arange(scale_range[0],
scale_range[1], scale_step)

`scale_range2-tuple of floats, optional`

    
The range of sigmas used.

`scale_stepfloat, optional`

    
Step size between sigmas.

`alphafloat, optional`

    
Frangi correction constant that adjusts the filter’s sensitivity to deviation
from a plate-like structure.

`betafloat, optional`

    
Frangi correction constant that adjusts the filter’s sensitivity to deviation
from a blob-like structure.

`gammafloat, optional`

    
Frangi correction constant that adjusts the filter’s sensitivity to areas of
high variance/texture/structure.

`black_ridgesboolean, optional`

    
When True (the default), the filter detects black ridges; when False, it
detects white ridges.

`mode{‘constant’, ‘reflect’, ‘wrap’, ‘nearest’, ‘mirror’}, optional`

    
How to handle values outside the image borders.

`cvalfloat, optional`

    
Used in conjunction with mode ‘constant’, the value outside the image
boundaries.

Returns

    
`out(N, M[, P]) ndarray`

    
Filtered image (maximum of pixels across all scales).

See also

`meijering`

`sato`

`hessian`

#### Notes

Written by Marc Schrijver, November 2001 Re-Written by D. J. Kroon, University
of Twente, May 2009, [2] Adoption of 3D version from D. G. Ellis, Januar
20017, [3]

#### References

`1`

    
Frangi, A. F., Niessen, W. J., Vincken, K. L., & Viergever, M. A. (1998,).
Multiscale vessel enhancement filtering. In International Conference on
Medical Image Computing and Computer-Assisted Intervention (pp. 130-137).
Springer Berlin Heidelberg. DOI:10.1007/BFb0056195

`2`

    
Kroon, D. J.: Hessian based Frangi vesselness filter.

`3`

    
Ellis, D. G.: https://github.com/ellisdg/frangi3d/tree/master/frangi

## gabor

`skimage.filters.gabor(image, frequency, theta=0, bandwidth=1, sigma_x=None,
sigma_y=None, n_stds=3, offset=0, mode='reflect', cval=0)` [source]

    
Return real and imaginary responses to Gabor filter.

The real and imaginary parts of the Gabor filter kernel are applied to the
image and the response is returned as a pair of arrays.

Gabor filter is a linear filter with a Gaussian kernel which is modulated by a
sinusoidal plane wave. Frequency and orientation representations of the Gabor
filter are similar to those of the human visual system. Gabor filter banks are
commonly used in computer vision and image processing. They are especially
suitable for edge detection and texture classification.

Parameters

    
`image2-D array`

    
Input image.

`frequencyfloat`

    
Spatial frequency of the harmonic function. Specified in pixels.

`thetafloat, optional`

    
Orientation in radians. If 0, the harmonic is in the x-direction.

`bandwidthfloat, optional`

    
The bandwidth captured by the filter. For fixed bandwidth, `sigma_x` and
`sigma_y` will decrease with increasing frequency. This value is ignored if
`sigma_x` and `sigma_y` are set by the user.

`sigma_x, sigma_yfloat, optional`

    
Standard deviation in x- and y-directions. These directions apply to the
kernel before rotation. If `theta = pi/2`, then the kernel is rotated 90
degrees so that `sigma_x` controls the vertical direction.

`n_stdsscalar, optional`

    
The linear size of the kernel is n_stds (3 by default) standard deviations.

`offsetfloat, optional`

    
Phase offset of harmonic function in radians.

`mode{‘constant’, ‘nearest’, ‘reflect’, ‘mirror’, ‘wrap’}, optional`

    
Mode used to convolve image with a kernel, passed to `ndi.convolve`

`cvalscalar, optional`

    
Value to fill past edges of input if `mode` of convolution is ‘constant’. The
parameter is passed to `ndi.convolve`.

Returns

    
`real, imagarrays`

    
Filtered images using the real and imaginary parts of the Gabor filter kernel.
Images are of the same dimensions as the input one.

#### References

`1`

    
https://en.wikipedia.org/wiki/Gabor_filter

`2`

    
https://web.archive.org/web/20180127125930/http://mplab.ucsd.edu/tutorials/gabor.pdf

#### Examples

    
    >>> from skimage.filters import gabor
    >>> from skimage import data, io
    >>> from matplotlib import pyplot as plt  
    
    
    >>> image = data.coins()
    >>> # detecting edges in a coin image
    >>> filt_real, filt_imag = gabor(image, frequency=0.6)
    >>> plt.figure()            
    >>> io.imshow(filt_real)    
    >>> io.show()               
    
    
    >>> # less sensitivity to finer details with the lower frequency kernel
    >>> filt_real, filt_imag = gabor(image, frequency=0.1)
    >>> plt.figure()            
    >>> io.imshow(filt_real)    
    >>> io.show()               
    
## gabor_kernel

`skimage.filters.gabor_kernel(frequency, theta=0, bandwidth=1, sigma_x=None,
sigma_y=None, n_stds=3, offset=0)` [source]

    
Return complex 2D Gabor filter kernel.

Gabor kernel is a Gaussian kernel modulated by a complex harmonic function.
Harmonic function consists of an imaginary sine function and a real cosine
function. Spatial frequency is inversely proportional to the wavelength of the
harmonic and to the standard deviation of a Gaussian kernel. The bandwidth is
also inversely proportional to the standard deviation.

Parameters

    
`frequencyfloat`

    
Spatial frequency of the harmonic function. Specified in pixels.

`thetafloat, optional`

    
Orientation in radians. If 0, the harmonic is in the x-direction.

`bandwidthfloat, optional`

    
The bandwidth captured by the filter. For fixed bandwidth, `sigma_x` and
`sigma_y` will decrease with increasing frequency. This value is ignored if
`sigma_x` and `sigma_y` are set by the user.

`sigma_x, sigma_yfloat, optional`

    
Standard deviation in x- and y-directions. These directions apply to the
kernel before rotation. If `theta = pi/2`, then the kernel is rotated 90
degrees so that `sigma_x` controls the vertical direction.

`n_stdsscalar, optional`

    
The linear size of the kernel is n_stds (3 by default) standard deviations

`offsetfloat, optional`

    
Phase offset of harmonic function in radians.

Returns

    
`gcomplex array`

    
Complex filter kernel.

#### References

`1`

    
https://en.wikipedia.org/wiki/Gabor_filter

`2`

    
https://web.archive.org/web/20180127125930/http://mplab.ucsd.edu/tutorials/gabor.pdf

#### Examples

    
    >>> from skimage.filters import gabor_kernel
    >>> from skimage import io
    >>> from matplotlib import pyplot as plt  
    
    
    >>> gk = gabor_kernel(frequency=0.2)
    >>> plt.figure()        
    >>> io.imshow(gk.real)  
    >>> io.show()           
    
    
    >>> # more ripples (equivalent to increasing the size of the
    >>> # Gaussian spread)
    >>> gk = gabor_kernel(frequency=0.2, bandwidth=0.1)
    >>> plt.figure()        
    >>> io.imshow(gk.real)  
    >>> io.show()           
    
## gaussian

`skimage.filters.gaussian(image, sigma=1, output=None, mode='nearest', cval=0,
multichannel=None, preserve_range=False, truncate=4.0)` [source]

    
Multi-dimensional Gaussian filter.

Parameters

    
`imagearray-like`

    
Input image (grayscale or color) to filter.

`sigmascalar or sequence of scalars, optional`

    
Standard deviation for Gaussian kernel. The standard deviations of the
Gaussian filter are given for each axis as a sequence, or as a single number,
in which case it is equal for all axes.

`outputarray, optional`

    
The `output` parameter passes an array in which to store the filter output.

`mode{‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’}, optional`

    
The `mode` parameter determines how the array borders are handled, where
`cval` is the value when mode is equal to ‘constant’. Default is ‘nearest’.

`cvalscalar, optional`

    
Value to fill past edges of input if `mode` is ‘constant’. Default is 0.0

`multichannelbool, optional (default: None)`

    
Whether the last axis of the image is to be interpreted as multiple channels.
If True, each channel is filtered separately (channels are not mixed
together). Only 3 channels are supported. If `None`, the function will attempt
to guess this, and raise a warning if ambiguous, when the array has shape (M,
N, 3).

`preserve_rangebool, optional`

    
Whether to keep the original range of values. Otherwise, the input image is
converted according to the conventions of `img_as_float`. Also see
https://scikit-image.org/docs/dev/user_guide/data_types.html

`truncatefloat, optional`

    
Truncate the filter at this many standard deviations.

Returns

    
`filtered_imagendarray`

    
the filtered array

#### Notes

This function is a wrapper around `scipy.ndi.gaussian_filter()`.

Integer arrays are converted to float.

The `output` should be floating point data type since gaussian converts to
float provided `image`. If `output` is not provided, another array will be
allocated and returned as the result.

The multi-dimensional filter is implemented as a sequence of one-dimensional
convolution filters. The intermediate arrays are stored in the same data type
as the output. Therefore, for output types with a limited precision, the
results may be imprecise because intermediate results may be stored with
insufficient precision.

#### Examples

    
    >>> a = np.zeros((3, 3))
    >>> a[1, 1] = 1
    >>> a
    array([[0., 0., 0.],
           [0., 1., 0.],
           [0., 0., 0.]])
    >>> gaussian(a, sigma=0.4)  # mild smoothing
    array([[0.00163116, 0.03712502, 0.00163116],
           [0.03712502, 0.84496158, 0.03712502],
           [0.00163116, 0.03712502, 0.00163116]])
    >>> gaussian(a, sigma=1)  # more smoothing
    array([[0.05855018, 0.09653293, 0.05855018],
           [0.09653293, 0.15915589, 0.09653293],
           [0.05855018, 0.09653293, 0.05855018]])
    >>> # Several modes are possible for handling boundaries
    >>> gaussian(a, sigma=1, mode='reflect')
    array([[0.08767308, 0.12075024, 0.08767308],
           [0.12075024, 0.16630671, 0.12075024],
           [0.08767308, 0.12075024, 0.08767308]])
    >>> # For RGB images, each is filtered separately
    >>> from skimage.data import astronaut
    >>> image = astronaut()
    >>> filtered_img = gaussian(image, sigma=1, multichannel=True)
    
## hessian

`skimage.filters.hessian(image, sigmas=range(1, 10, 2), scale_range=None,
scale_step=None, alpha=0.5, beta=0.5, gamma=15, black_ridges=True, mode=None,
cval=0)` [source]

    
Filter an image with the Hybrid Hessian filter.

This filter can be used to detect continuous edges, e.g. vessels, wrinkles,
rivers. It can be used to calculate the fraction of the whole image containing
such objects.

Defined only for 2-D and 3-D images. Almost equal to Frangi filter, but uses
alternative method of smoothing. Refer to [1] to find the differences between
Frangi and Hessian filters.

Parameters

    
`image(N, M[, P]) ndarray`

    
Array with input image data.

`sigmasiterable of floats, optional`

    
Sigmas used as scales of filter, i.e., np.arange(scale_range[0],
scale_range[1], scale_step)

`scale_range2-tuple of floats, optional`

    
The range of sigmas used.

`scale_stepfloat, optional`

    
Step size between sigmas.

`betafloat, optional`

    
Frangi correction constant that adjusts the filter’s sensitivity to deviation
from a blob-like structure.

`gammafloat, optional`

    
Frangi correction constant that adjusts the filter’s sensitivity to areas of
high variance/texture/structure.

`black_ridgesboolean, optional`

    
When True (the default), the filter detects black ridges; when False, it
detects white ridges.

`mode{‘constant’, ‘reflect’, ‘wrap’, ‘nearest’, ‘mirror’}, optional`

    
How to handle values outside the image borders.

`cvalfloat, optional`

    
Used in conjunction with mode ‘constant’, the value outside the image
boundaries.

Returns

    
`out(N, M[, P]) ndarray`

    
Filtered image (maximum of pixels across all scales).

See also

`meijering`

`sato`

`frangi`

#### Notes

Written by Marc Schrijver (November 2001) Re-Written by D. J. Kroon University
of Twente (May 2009) [2]

#### References

`1`

    
Ng, C. C., Yap, M. H., Costen, N., & Li, B. (2014,). Automatic wrinkle
detection using hybrid Hessian filter. In Asian Conference on Computer Vision
(pp. 609-622). Springer International Publishing.
DOI:10.1007/978-3-319-16811-1_40

`2`

    
Kroon, D. J.: Hessian based Frangi vesselness filter.

## inverse

`skimage.filters.inverse(data, impulse_response=None, filter_params={},
max_gain=2, predefined_filter=None)` [source]

    
Apply the filter in reverse to the given data.

Parameters

    
`data(M,N) ndarray`

    
Input data.

`impulse_responsecallable f(r, c, **filter_params)`

    
Impulse response of the filter. See LPIFilter2D.__init__.

`filter_paramsdict`

    
Additional keyword parameters to the impulse_response function.

`max_gainfloat`

    
Limit the filter gain. Often, the filter contains zeros, which would cause the
inverse filter to have infinite gain. High gain causes amplification of
artefacts, so a conservative limit is recommended.

Other Parameters

    
`predefined_filterLPIFilter2D`

    
If you need to apply the same filter multiple times over different images,
construct the LPIFilter2D and specify it here.

## laplace

`skimage.filters.laplace(image, ksize=3, mask=None)` [source]

    
Find the edges of an image using the Laplace operator.

Parameters

    
`imagendarray`

    
Image to process.

`ksizeint, optional`

    
Define the size of the discrete Laplacian operator such that it will have a
size of (ksize,) * image.ndim.

`maskndarray, optional`

    
An optional mask to limit the application to a certain area. Note that pixels
surrounding masked regions are also masked to prevent masked regions from
affecting the result.

Returns

    
`outputndarray`

    
The Laplace edge map.

#### Notes

The Laplacian operator is generated using the function
skimage.restoration.uft.laplacian().

## median

`skimage.filters.median(image, selem=None, out=None, mode='nearest', cval=0.0,
behavior='ndimage')` [source]

    
Return local median of an image.

Parameters

    
`imagearray-like`

    
Input image.

`selemndarray, optional`

    
If `behavior=='rank'`, `selem` is a 2-D array of 1’s and 0’s. If
`behavior=='ndimage'`, `selem` is a N-D array of 1’s and 0’s with the same
number of dimension than `image`. If None, `selem` will be a N-D array with 3
elements for each dimension (e.g., vector, square, cube, etc.)

`outndarray, (same dtype as image), optional`

    
If None, a new array is allocated.

`mode{‘reflect’, ‘constant’, ‘nearest’, ‘mirror’,’‘wrap’}, optional`

    
The mode parameter determines how the array borders are handled, where `cval`
is the value when mode is equal to ‘constant’. Default is ‘nearest’.

New in version 0.15: `mode` is used when `behavior='ndimage'`.

`cvalscalar, optional`

    
Value to fill past edges of input if mode is ‘constant’. Default is 0.0

New in version 0.15: `cval` was added in 0.15 is used when
`behavior='ndimage'`.

`behavior{‘ndimage’, ‘rank’}, optional`

    
Either to use the old behavior (i.e., < 0.15) or the new behavior. The old
behavior will call the `skimage.filters.rank.median()`. The new behavior will
call the `scipy.ndimage.median_filter()`. Default is ‘ndimage’.

New in version 0.15: `behavior` is introduced in 0.15

Changed in version 0.16: Default `behavior` has been changed from ‘rank’ to
‘ndimage’

Returns

    
`out2-D array (same dtype as input image)`

    
Output image.

See also

`skimage.filters.rank.median`

    
Rank-based implementation of the median filtering offering more flexibility
with additional parameters but dedicated for unsigned integer images.

#### Examples

    
    >>> from skimage import data
    >>> from skimage.morphology import disk
    >>> from skimage.filters import median
    >>> img = data.camera()
    >>> med = median(img, disk(5))
    
## meijering

`skimage.filters.meijering(image, sigmas=range(1, 10, 2), alpha=None,
black_ridges=True, mode='reflect', cval=0)` [source]

    
Filter an image with the Meijering neuriteness filter.

This filter can be used to detect continuous ridges, e.g. neurites, wrinkles,
rivers. It can be used to calculate the fraction of the whole image containing
such objects.

Calculates the eigenvectors of the Hessian to compute the similarity of an
image region to neurites, according to the method described in [1].

Parameters

    
`image(N, M[, …, P]) ndarray`

    
Array with input image data.

`sigmasiterable of floats, optional`

    
Sigmas used as scales of filter

`alphafloat, optional`

    
Frangi correction constant that adjusts the filter’s sensitivity to deviation
from a plate-like structure.

`black_ridgesboolean, optional`

    
When True (the default), the filter detects black ridges; when False, it
detects white ridges.

`mode{‘constant’, ‘reflect’, ‘wrap’, ‘nearest’, ‘mirror’}, optional`

    
How to handle values outside the image borders.

`cvalfloat, optional`

    
Used in conjunction with mode ‘constant’, the value outside the image
boundaries.

Returns

    
`out(N, M[, …, P]) ndarray`

    
Filtered image (maximum of pixels across all scales).

See also

`sato`

`frangi`

`hessian`

#### References

`1`

    
Meijering, E., Jacob, M., Sarria, J. C., Steiner, P., Hirling, H., Unser, M.
(2004). Design and validation of a tool for neurite tracing and analysis in
fluorescence microscopy images. Cytometry Part A, 58(2), 167-176.
DOI:10.1002/cyto.a.20022

## prewitt

`skimage.filters.prewitt(image, mask=None, *, axis=None, mode='reflect',
cval=0.0)` [source]

    
Find the edge magnitude using the Prewitt transform.

Parameters

    
`imagearray`

    
The input image.

`maskarray of bool, optional`

    
Clip the output image to this mask. (Values where mask=0 will be set to 0.)

`axisint or sequence of int, optional`

    
Compute the edge filter along this axis. If not provided, the edge magnitude
is computed. This is defined as:

    
    prw_mag = np.sqrt(sum([prewitt(image, axis=i)**2
                           for i in range(image.ndim)]) / image.ndim)
    
The magnitude is also computed if axis is a sequence.

`modestr or sequence of str, optional`

    
The boundary mode for the convolution. See `scipy.ndimage.convolve` for a
description of the modes. This can be either a single boundary mode or one
boundary mode per axis.

`cvalfloat, optional`

    
When `mode` is `'constant'`, this is the constant used in values outside the
boundary of the image data.

Returns

    
`outputarray of float`

    
The Prewitt edge map.

See also

`sobel,` `scharr`

#### Notes

The edge magnitude depends slightly on edge directions, since the
approximation of the gradient operator by the Prewitt operator is not
completely rotation invariant. For a better rotation invariance, the Scharr
operator should be used. The Sobel operator has a better rotation invariance
than the Prewitt operator, but a worse rotation invariance than the Scharr
operator.

#### Examples

    
    >>> from skimage import data
    >>> from skimage import filters
    >>> camera = data.camera()
    >>> edges = filters.prewitt(camera)
    
## prewitt_h

`skimage.filters.prewitt_h(image, mask=None)` [source]

    
Find the horizontal edges of an image using the Prewitt transform.

Parameters

    
`image2-D array`

    
Image to process.

`mask2-D array, optional`

    
An optional mask to limit the application to a certain area. Note that pixels
surrounding masked regions are also masked to prevent masked regions from
affecting the result.

Returns

    
`output2-D array`

    
The Prewitt edge map.

#### Notes

We use the following kernel:

    
     1/3   1/3   1/3
      0     0     0
    -1/3  -1/3  -1/3
    
## prewitt_v

`skimage.filters.prewitt_v(image, mask=None)` [source]

    
Find the vertical edges of an image using the Prewitt transform.

Parameters

    
`image2-D array`

    
Image to process.

`mask2-D array, optional`

    
An optional mask to limit the application to a certain area. Note that pixels
surrounding masked regions are also masked to prevent masked regions from
affecting the result.

Returns

    
`output2-D array`

    
The Prewitt edge map.

#### Notes

We use the following kernel:

    
    1/3   0  -1/3
    1/3   0  -1/3
    1/3   0  -1/3
    
## rank_order

`skimage.filters.rank_order(image)` [source]

    
Return an image of the same shape where each pixel is the index of the pixel
value in the ascending order of the unique values of `image`, aka the rank-
order value.

Parameters

    
`imagendarray`

Returns

    
`labelsndarray of type np.uint32, of shape image.shape`

    
New array where each pixel has the rank-order value of the corresponding pixel
in `image`. Pixel values are between 0 and n - 1, where n is the number of
distinct unique values in `image`.

`original_values1-D ndarray`

    
Unique original values of `image`

#### Examples

    
    >>> a = np.array([[1, 4, 5], [4, 4, 1], [5, 1, 1]])
    >>> a
    array([[1, 4, 5],
           [4, 4, 1],
           [5, 1, 1]])
    >>> rank_order(a)
    (array([[0, 1, 2],
           [1, 1, 0],
           [2, 0, 0]], dtype=uint32), array([1, 4, 5]))
    >>> b = np.array([-1., 2.5, 3.1, 2.5])
    >>> rank_order(b)
    (array([0, 1, 2, 1], dtype=uint32), array([-1. ,  2.5,  3.1]))
    
## roberts

`skimage.filters.roberts(image, mask=None)` [source]

    
Find the edge magnitude using Roberts’ cross operator.

Parameters

    
`image2-D array`

    
Image to process.

`mask2-D array, optional`

    
An optional mask to limit the application to a certain area. Note that pixels
surrounding masked regions are also masked to prevent masked regions from
affecting the result.

Returns

    
`output2-D array`

    
The Roberts’ Cross edge map.

See also

`sobel, scharr, prewitt, feature.canny`

#### Examples

    
    >>> from skimage import data
    >>> camera = data.camera()
    >>> from skimage import filters
    >>> edges = filters.roberts(camera)
    
## roberts_neg_diag

`skimage.filters.roberts_neg_diag(image, mask=None)` [source]

    
Find the cross edges of an image using the Roberts’ Cross operator.

The kernel is applied to the input image to produce separate measurements of
the gradient component one orientation.

Parameters

    
`image2-D array`

    
Image to process.

`mask2-D array, optional`

    
An optional mask to limit the application to a certain area. Note that pixels
surrounding masked regions are also masked to prevent masked regions from
affecting the result.

Returns

    
`output2-D array`

    
The Robert’s edge map.

#### Notes

We use the following kernel:

    
     0   1
    -1   0
    
## roberts_pos_diag

`skimage.filters.roberts_pos_diag(image, mask=None)` [source]

    
Find the cross edges of an image using Roberts’ cross operator.

The kernel is applied to the input image to produce separate measurements of
the gradient component one orientation.

Parameters

    
`image2-D array`

    
Image to process.

`mask2-D array, optional`

    
An optional mask to limit the application to a certain area. Note that pixels
surrounding masked regions are also masked to prevent masked regions from
affecting the result.

Returns

    
`output2-D array`

    
The Robert’s edge map.

#### Notes

We use the following kernel:

    
    1   0
    0  -1
    
## sato

`skimage.filters.sato(image, sigmas=range(1, 10, 2), black_ridges=True,
mode=None, cval=0)` [source]

    
Filter an image with the Sato tubeness filter.

This filter can be used to detect continuous ridges, e.g. tubes, wrinkles,
rivers. It can be used to calculate the fraction of the whole image containing
such objects.

Defined only for 2-D and 3-D images. Calculates the eigenvectors of the
Hessian to compute the similarity of an image region to tubes, according to
the method described in [1].

Parameters

    
`image(N, M[, P]) ndarray`

    
Array with input image data.

`sigmasiterable of floats, optional`

    
Sigmas used as scales of filter.

`black_ridgesboolean, optional`

    
When True (the default), the filter detects black ridges; when False, it
detects white ridges.

`mode{‘constant’, ‘reflect’, ‘wrap’, ‘nearest’, ‘mirror’}, optional`

    
How to handle values outside the image borders.

`cvalfloat, optional`

    
Used in conjunction with mode ‘constant’, the value outside the image
boundaries.

Returns

    
`out(N, M[, P]) ndarray`

    
Filtered image (maximum of pixels across all scales).

See also

`meijering`

`frangi`

`hessian`

#### References

`1`

    
Sato, Y., Nakajima, S., Shiraga, N., Atsumi, H., Yoshida, S., Koller, T., …,
Kikinis, R. (1998). Three-dimensional multi-scale line filter for segmentation
and visualization of curvilinear structures in medical images. Medical image
analysis, 2(2), 143-168. DOI:10.1016/S1361-8415(98)80009-1

## scharr

`skimage.filters.scharr(image, mask=None, *, axis=None, mode='reflect',
cval=0.0)` [source]

    
Find the edge magnitude using the Scharr transform.

Parameters

    
`imagearray`

    
The input image.

`maskarray of bool, optional`

    
Clip the output image to this mask. (Values where mask=0 will be set to 0.)

`axisint or sequence of int, optional`

    
Compute the edge filter along this axis. If not provided, the edge magnitude
is computed. This is defined as:

    
    sch_mag = np.sqrt(sum([scharr(image, axis=i)**2
                           for i in range(image.ndim)]) / image.ndim)
    
The magnitude is also computed if axis is a sequence.

`modestr or sequence of str, optional`

    
The boundary mode for the convolution. See `scipy.ndimage.convolve` for a
description of the modes. This can be either a single boundary mode or one
boundary mode per axis.

`cvalfloat, optional`

    
When `mode` is `'constant'`, this is the constant used in values outside the
boundary of the image data.

Returns

    
`outputarray of float`

    
The Scharr edge map.

See also

`sobel, prewitt, canny`

#### Notes

The Scharr operator has a better rotation invariance than other edge filters
such as the Sobel or the Prewitt operators.

#### References

`1`

    
D. Kroon, 2009, Short Paper University Twente, Numerical Optimization of
Kernel Based Image Derivatives.

`2`

    
https://en.wikipedia.org/wiki/Sobel_operator#Alternative_operators

#### Examples

    
    >>> from skimage import data
    >>> from skimage import filters
    >>> camera = data.camera()
    >>> edges = filters.scharr(camera)
    
## scharr_h

`skimage.filters.scharr_h(image, mask=None)` [source]

    
Find the horizontal edges of an image using the Scharr transform.

Parameters

    
`image2-D array`

    
Image to process.

`mask2-D array, optional`

    
An optional mask to limit the application to a certain area. Note that pixels
surrounding masked regions are also masked to prevent masked regions from
affecting the result.

Returns

    
`output2-D array`

    
The Scharr edge map.

#### Notes

We use the following kernel:

    
     3   10   3
     0    0   0
    -3  -10  -3
    
#### References

`1`

    
D. Kroon, 2009, Short Paper University Twente, Numerical Optimization of
Kernel Based Image Derivatives.

## scharr_v

`skimage.filters.scharr_v(image, mask=None)` [source]

    
Find the vertical edges of an image using the Scharr transform.

Parameters

    
`image2-D array`

    
Image to process

`mask2-D array, optional`

    
An optional mask to limit the application to a certain area. Note that pixels
surrounding masked regions are also masked to prevent masked regions from
affecting the result.

Returns

    
`output2-D array`

    
The Scharr edge map.

#### Notes

We use the following kernel:

    
     3   0   -3
    10   0  -10
     3   0   -3
    
#### References

`1`

    
D. Kroon, 2009, Short Paper University Twente, Numerical Optimization of
Kernel Based Image Derivatives.

## sobel

`skimage.filters.sobel(image, mask=None, *, axis=None, mode='reflect',
cval=0.0)` [source]

    
Find edges in an image using the Sobel filter.

Parameters

    
`imagearray`

    
The input image.

`maskarray of bool, optional`

    
Clip the output image to this mask. (Values where mask=0 will be set to 0.)

`axisint or sequence of int, optional`

    
Compute the edge filter along this axis. If not provided, the edge magnitude
is computed. This is defined as:

    
    sobel_mag = np.sqrt(sum([sobel(image, axis=i)**2
                             for i in range(image.ndim)]) / image.ndim)
    
The magnitude is also computed if axis is a sequence.

`modestr or sequence of str, optional`

    
The boundary mode for the convolution. See `scipy.ndimage.convolve` for a
description of the modes. This can be either a single boundary mode or one
boundary mode per axis.

`cvalfloat, optional`

    
When `mode` is `'constant'`, this is the constant used in values outside the
boundary of the image data.

Returns

    
`outputarray of float`

    
The Sobel edge map.

See also

`scharr, prewitt, canny`

#### References

`1`

    
D. Kroon, 2009, Short Paper University Twente, Numerical Optimization of
Kernel Based Image Derivatives.

`2`

    
https://en.wikipedia.org/wiki/Sobel_operator

#### Examples

    
    >>> from skimage import data
    >>> from skimage import filters
    >>> camera = data.camera()
    >>> edges = filters.sobel(camera)
    
### Examples using `skimage.filters.sobel`

![Flood
Fill](data:image/png;base64,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)

Flood Fill

## sobel_h

`skimage.filters.sobel_h(image, mask=None)` [source]

    
Find the horizontal edges of an image using the Sobel transform.

Parameters

    
`image2-D array`

    
Image to process.

`mask2-D array, optional`

    
An optional mask to limit the application to a certain area. Note that pixels
surrounding masked regions are also masked to prevent masked regions from
affecting the result.

Returns

    
`output2-D array`

    
The Sobel edge map.

#### Notes

We use the following kernel:

    
     1   2   1
     0   0   0
    -1  -2  -1
    
## sobel_v

`skimage.filters.sobel_v(image, mask=None)` [source]

    
Find the vertical edges of an image using the Sobel transform.

Parameters

    
`image2-D array`

    
Image to process.

`mask2-D array, optional`

    
An optional mask to limit the application to a certain area. Note that pixels
surrounding masked regions are also masked to prevent masked regions from
affecting the result.

Returns

    
`output2-D array`

    
The Sobel edge map.

#### Notes

We use the following kernel:

    
    1   0  -1
    2   0  -2
    1   0  -1
    
## threshold_isodata

`skimage.filters.threshold_isodata(image=None, nbins=256, return_all=False, *,
hist=None)` [source]

    
Return threshold value(s) based on ISODATA method.

Histogram-based threshold, known as Ridler-Calvard method or inter-means.
Threshold values returned satisfy the following equality:

    
    threshold = (image[image <= threshold].mean() +
                 image[image > threshold].mean()) / 2.0
    
That is, returned thresholds are intensities that separate the image into two
groups of pixels, where the threshold intensity is midway between the mean
intensities of these groups.

For integer images, the above equality holds to within one; for floating-
point images, the equality holds to within the histogram bin-width.

Either image or hist must be provided. In case hist is given, the actual
histogram of the image is ignored.

Parameters

    
`image(N, M) ndarray, optional`

    
Input image.

`nbinsint, optional`

    
Number of bins used to calculate histogram. This value is ignored for integer
arrays.

`return_allbool, optional`

    
If False (default), return only the lowest threshold that satisfies the above
equality. If True, return all valid thresholds.

`histarray, or 2-tuple of arrays, optional`

    
Histogram to determine the threshold from and a corresponding array of bin
center intensities. Alternatively, only the histogram can be passed.

Returns

    
`thresholdfloat or int or array`

    
Threshold value(s).

#### References

`1`

    
Ridler, TW & Calvard, S (1978), “Picture thresholding using an iterative
selection method” IEEE Transactions on Systems, Man and Cybernetics 8:
630-632, DOI:10.1109/TSMC.1978.4310039

`2`

    
Sezgin M. and Sankur B. (2004) “Survey over Image Thresholding Techniques and
Quantitative Performance Evaluation” Journal of Electronic Imaging, 13(1):
146-165,
http://www.busim.ee.boun.edu.tr/~sankur/SankurFolder/Threshold_survey.pdf
DOI:10.1117/1.1631315

`3`

    
ImageJ AutoThresholder code, http://fiji.sc/wiki/index.php/Auto_Threshold

#### Examples

    
    >>> from skimage.data import coins
    >>> image = coins()
    >>> thresh = threshold_isodata(image)
    >>> binary = image > thresh
    
## threshold_li

`skimage.filters.threshold_li(image, *, tolerance=None, initial_guess=None,
iter_callback=None)` [source]

    
Compute threshold value by Li’s iterative Minimum Cross Entropy method.

Parameters

    
`imagendarray`

    
Input image.

`tolerancefloat, optional`

    
Finish the computation when the change in the threshold in an iteration is
less than this value. By default, this is half the smallest difference between
intensity values in `image`.

`initial_guessfloat or Callable[[array[float]], float], optional`

    
Li’s iterative method uses gradient descent to find the optimal threshold. If
the image intensity histogram contains more than two modes (peaks), the
gradient descent could get stuck in a local optimum. An initial guess for the
iteration can help the algorithm find the globally-optimal threshold. A float
value defines a specific start point, while a callable should take in an array
of image intensities and return a float value. Example valid callables include
`numpy.mean` (default), `lambda arr: numpy.quantile(arr, 0.95)`, or even
`skimage.filters.threshold_otsu()`.

`iter_callbackCallable[[float], Any], optional`

    
A function that will be called on the threshold at every iteration of the
algorithm.

Returns

    
`thresholdfloat`

    
Upper threshold value. All pixels with an intensity higher than this value are
assumed to be foreground.

#### References

`1`

    
Li C.H. and Lee C.K. (1993) “Minimum Cross Entropy Thresholding” Pattern
Recognition, 26(4): 617-625 DOI:10.1016/0031-3203(93)90115-D

`2`

    
Li C.H. and Tam P.K.S. (1998) “An Iterative Algorithm for Minimum Cross
Entropy Thresholding” Pattern Recognition Letters, 18(8): 771-776
DOI:10.1016/S0167-8655(98)00057-9

`3`

    
Sezgin M. and Sankur B. (2004) “Survey over Image Thresholding Techniques and
Quantitative Performance Evaluation” Journal of Electronic Imaging, 13(1):
146-165 DOI:10.1117/1.1631315

`4`

    
ImageJ AutoThresholder code, http://fiji.sc/wiki/index.php/Auto_Threshold

#### Examples

    
    >>> from skimage.data import camera
    >>> image = camera()
    >>> thresh = threshold_li(image)
    >>> binary = image > thresh
    
## threshold_local

`skimage.filters.threshold_local(image, block_size, method='gaussian',
offset=0, mode='reflect', param=None, cval=0)` [source]

    
Compute a threshold mask image based on local pixel neighborhood.

Also known as adaptive or dynamic thresholding. The threshold value is the
weighted mean for the local neighborhood of a pixel subtracted by a constant.
Alternatively the threshold can be determined dynamically by a given function,
using the ‘generic’ method.

Parameters

    
`image(N, M) ndarray`

    
Input image.

`block_sizeint`

    
Odd size of pixel neighborhood which is used to calculate the threshold value
(e.g. 3, 5, 7, …, 21, …).

`method{‘generic’, ‘gaussian’, ‘mean’, ‘median’}, optional`

    
Method used to determine adaptive threshold for local neighbourhood in
weighted mean image.

  * ‘generic’: use custom function (see `param` parameter)
  * ‘gaussian’: apply gaussian filter (see `param` parameter for custom sigma value)
  * ‘mean’: apply arithmetic mean filter
  * ‘median’: apply median rank filter

By default the ‘gaussian’ method is used.

`offsetfloat, optional`

    
Constant subtracted from weighted mean of neighborhood to calculate the local
threshold value. Default offset is 0.

`mode{‘reflect’, ‘constant’, ‘nearest’, ‘mirror’, ‘wrap’}, optional`

    
The mode parameter determines how the array borders are handled, where cval is
the value when mode is equal to ‘constant’. Default is ‘reflect’.

`param{int, function}, optional`

    
Either specify sigma for ‘gaussian’ method or function object for ‘generic’
method. This functions takes the flat array of local neighbourhood as a single
argument and returns the calculated threshold for the centre pixel.

`cvalfloat, optional`

    
Value to fill past edges of input if mode is ‘constant’.

Returns

    
`threshold(N, M) ndarray`

    
Threshold image. All pixels in the input image higher than the corresponding
pixel in the threshold image are considered foreground.

#### References

`1`

    
https://docs.opencv.org/modules/imgproc/doc/miscellaneous_transformations.html?highlight=threshold#adaptivethreshold

#### Examples

    
    >>> from skimage.data import camera
    >>> image = camera()[:50, :50]
    >>> binary_image1 = image > threshold_local(image, 15, 'mean')
    >>> func = lambda arr: arr.mean()
    >>> binary_image2 = image > threshold_local(image, 15, 'generic',
    ...                                         param=func)
    
## threshold_mean

`skimage.filters.threshold_mean(image)` [source]

    
Return threshold value based on the mean of grayscale values.

Parameters

    
`image(N, M[, …, P]) ndarray`

    
Grayscale input image.

Returns

    
`thresholdfloat`

    
Upper threshold value. All pixels with an intensity higher than this value are
assumed to be foreground.

#### References

`1`

    
C. A. Glasbey, “An analysis of histogram-based thresholding algorithms,”
CVGIP: Graphical Models and Image Processing, vol. 55, pp. 532-537, 1993.
DOI:10.1006/cgip.1993.1040

#### Examples

    
    >>> from skimage.data import camera
    >>> image = camera()
    >>> thresh = threshold_mean(image)
    >>> binary = image > thresh
    
## threshold_minimum

`skimage.filters.threshold_minimum(image=None, nbins=256, max_iter=10000, *,
hist=None)` [source]

    
Return threshold value based on minimum method.

The histogram of the input `image` is computed if not provided and smoothed
until there are only two maxima. Then the minimum in between is the threshold
value.

Either image or hist must be provided. In case hist is given, the actual
histogram of the image is ignored.

Parameters

    
`image(M, N) ndarray, optional`

    
Input image.

`nbinsint, optional`

    
Number of bins used to calculate histogram. This value is ignored for integer
arrays.

`max_iterint, optional`

    
Maximum number of iterations to smooth the histogram.

`histarray, or 2-tuple of arrays, optional`

    
Histogram to determine the threshold from and a corresponding array of bin
center intensities. Alternatively, only the histogram can be passed.

Returns

    
`thresholdfloat`

    
Upper threshold value. All pixels with an intensity higher than this value are
assumed to be foreground.

Raises

    
RuntimeError

    
If unable to find two local maxima in the histogram or if the smoothing takes
more than 1e4 iterations.

#### References

`1`

    
C. A. Glasbey, “An analysis of histogram-based thresholding algorithms,”
CVGIP: Graphical Models and Image Processing, vol. 55, pp. 532-537, 1993.

`2`

    
Prewitt, JMS & Mendelsohn, ML (1966), “The analysis of cell images”, Annals of
the New York Academy of Sciences 128: 1035-1053
DOI:10.1111/j.1749-6632.1965.tb11715.x

#### Examples

    
    >>> from skimage.data import camera
    >>> image = camera()
    >>> thresh = threshold_minimum(image)
    >>> binary = image > thresh
    
## threshold_multiotsu

`skimage.filters.threshold_multiotsu(image, classes=3, nbins=256)` [source]

    
Generate `classes`-1 threshold values to divide gray levels in `image`.

The threshold values are chosen to maximize the total sum of pairwise
variances between the thresholded graylevel classes. See Notes and [1] for
more details.

Parameters

    
`image(N, M) ndarray`

    
Grayscale input image.

`classesint, optional`

    
Number of classes to be thresholded, i.e. the number of resulting regions.

`nbinsint, optional`

    
Number of bins used to calculate the histogram. This value is ignored for
integer arrays.

Returns

    
`thresharray`

    
Array containing the threshold values for the desired classes.

Raises

    
ValueError

    
If `image` contains less grayscale value then the desired number of classes.

#### Notes

This implementation relies on a Cython function whose complexity is
\\(O\left(\frac{Ch^{C-1}}{(C-1)!}\right)\\), where \\(h\\) is the number of
histogram bins and \\(C\\) is the number of classes desired.

The input image must be grayscale.

#### References

`1`

    
Liao, P-S., Chen, T-S. and Chung, P-C., “A fast algorithm for multilevel
thresholding”, Journal of Information Science and Engineering 17 (5): 713-727,
2001. Available at: <https://ftp.iis.sinica.edu.tw/JISE/2001/200109_01.pdf>
DOI:10.6688/JISE.2001.17.5.1

`2`

    
Tosa, Y., “Multi-Otsu Threshold”, a java plugin for ImageJ. Available at:
<http://imagej.net/plugins/download/Multi_OtsuThreshold.java>

#### Examples

    
    >>> from skimage.color import label2rgb
    >>> from skimage import data
    >>> image = data.camera()
    >>> thresholds = threshold_multiotsu(image)
    >>> regions = np.digitize(image, bins=thresholds)
    >>> regions_colorized = label2rgb(regions)
    
### Examples using `skimage.filters.threshold_multiotsu`

![Multi-Otsu
Thresholding](data:image/png;base64,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)

Multi-Otsu Thresholding

![Segment human cells \(in
mitosis\)](data:image/png;base64,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)

Segment human cells (in mitosis)

## threshold_niblack

`skimage.filters.threshold_niblack(image, window_size=15, k=0.2)` [source]

    
Applies Niblack local threshold to an array.

A threshold T is calculated for every pixel in the image using the following
formula:

    
    T = m(x,y) - k * s(x,y)
    
where m(x,y) and s(x,y) are the mean and standard deviation of pixel (x,y)
neighborhood defined by a rectangular window with size w times w centered
around the pixel. k is a configurable parameter that weights the effect of
standard deviation.

Parameters

    
`imagendarray`

    
Input image.

`window_sizeint, or iterable of int, optional`

    
Window size specified as a single odd integer (3, 5, 7, …), or an iterable of
length `image.ndim` containing only odd integers (e.g. `(1, 5, 5)`).

`kfloat, optional`

    
Value of parameter k in threshold formula.

Returns

    
`threshold(N, M) ndarray`

    
Threshold mask. All pixels with an intensity higher than this value are
assumed to be foreground.

#### Notes

This algorithm is originally designed for text recognition.

The Bradley threshold is a particular case of the Niblack one, being
equivalent to

    
    >>> from skimage import data
    >>> image = data.page()
    >>> q = 1
    >>> threshold_image = threshold_niblack(image, k=0) * q
    
for some value `q`. By default, Bradley and Roth use `q=1`.

#### References

`1`

    
W. Niblack, An introduction to Digital Image Processing, Prentice-Hall, 1986.

`2`

    
D. Bradley and G. Roth, “Adaptive thresholding using Integral Image”, Journal
of Graphics Tools 12(2), pp. 13-21, 2007. DOI:10.1080/2151237X.2007.10129236

#### Examples

    
    >>> from skimage import data
    >>> image = data.page()
    >>> threshold_image = threshold_niblack(image, window_size=7, k=0.1)
    
## threshold_otsu

`skimage.filters.threshold_otsu(image=None, nbins=256, *, hist=None)` [source]

    
Return threshold value based on Otsu’s method.

Either image or hist must be provided. If hist is provided, the actual
histogram of the image is ignored.

Parameters

    
`image(N, M) ndarray, optional`

    
Grayscale input image.

`nbinsint, optional`

    
Number of bins used to calculate histogram. This value is ignored for integer
arrays.

`histarray, or 2-tuple of arrays, optional`

    
Histogram from which to determine the threshold, and optionally a
corresponding array of bin center intensities. An alternative use of this
function is to pass it only hist.

Returns

    
`thresholdfloat`

    
Upper threshold value. All pixels with an intensity higher than this value are
assumed to be foreground.

#### Notes

The input image must be grayscale.

#### References

`1`

    
Wikipedia, https://en.wikipedia.org/wiki/Otsu’s_Method

#### Examples

    
    >>> from skimage.data import camera
    >>> image = camera()
    >>> thresh = threshold_otsu(image)
    >>> binary = image <= thresh
    
### Examples using `skimage.filters.threshold_otsu`

![Measure region
properties](data:image/png;base64,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)

Measure region properties

![Rank
filters](data:image/png;base64,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)

Rank filters

## threshold_sauvola

`skimage.filters.threshold_sauvola(image, window_size=15, k=0.2, r=None)`
[source]

    
Applies Sauvola local threshold to an array. Sauvola is a modification of
Niblack technique.

In the original method a threshold T is calculated for every pixel in the
image using the following formula:

    
    T = m(x,y) * (1 + k * ((s(x,y) / R) - 1))
    
where m(x,y) and s(x,y) are the mean and standard deviation of pixel (x,y)
neighborhood defined by a rectangular window with size w times w centered
around the pixel. k is a configurable parameter that weights the effect of
standard deviation. R is the maximum standard deviation of a greyscale image.

Parameters

    
`imagendarray`

    
Input image.

`window_sizeint, or iterable of int, optional`

    
Window size specified as a single odd integer (3, 5, 7, …), or an iterable of
length `image.ndim` containing only odd integers (e.g. `(1, 5, 5)`).

`kfloat, optional`

    
Value of the positive parameter k.

`rfloat, optional`

    
Value of R, the dynamic range of standard deviation. If None, set to the half
of the image dtype range.

Returns

    
`threshold(N, M) ndarray`

    
Threshold mask. All pixels with an intensity higher than this value are
assumed to be foreground.

#### Notes

This algorithm is originally designed for text recognition.

#### References

`1`

    
J. Sauvola and M. Pietikainen, “Adaptive document image binarization,” Pattern
Recognition 33(2), pp. 225-236, 2000. DOI:10.1016/S0031-3203(99)00055-2

#### Examples

    
    >>> from skimage import data
    >>> image = data.page()
    >>> t_sauvola = threshold_sauvola(image, window_size=15, k=0.2)
    >>> binary_image = image > t_sauvola
    
## threshold_triangle

`skimage.filters.threshold_triangle(image, nbins=256)` [source]

    
Return threshold value based on the triangle algorithm.

Parameters

    
`image(N, M[, …, P]) ndarray`

    
Grayscale input image.

`nbinsint, optional`

    
Number of bins used to calculate histogram. This value is ignored for integer
arrays.

Returns

    
`thresholdfloat`

    
Upper threshold value. All pixels with an intensity higher than this value are
assumed to be foreground.

#### References

`1`

    
Zack, G. W., Rogers, W. E. and Latt, S. A., 1977, Automatic Measurement of
Sister Chromatid Exchange Frequency, Journal of Histochemistry and
Cytochemistry 25 (7), pp. 741-753 DOI:10.1177/25.7.70454

`2`

    
ImageJ AutoThresholder code, http://fiji.sc/wiki/index.php/Auto_Threshold

#### Examples

    
    >>> from skimage.data import camera
    >>> image = camera()
    >>> thresh = threshold_triangle(image)
    >>> binary = image > thresh
    
## threshold_yen

`skimage.filters.threshold_yen(image=None, nbins=256, *, hist=None)` [source]

    
Return threshold value based on Yen’s method. Either image or hist must be
provided. In case hist is given, the actual histogram of the image is ignored.

Parameters

    
`image(N, M) ndarray, optional`

    
Input image.

`nbinsint, optional`

    
Number of bins used to calculate histogram. This value is ignored for integer
arrays.

`histarray, or 2-tuple of arrays, optional`

    
Histogram from which to determine the threshold, and optionally a
corresponding array of bin center intensities. An alternative use of this
function is to pass it only hist.

Returns

    
`thresholdfloat`

    
Upper threshold value. All pixels with an intensity higher than this value are
assumed to be foreground.

#### References

`1`

    
Yen J.C., Chang F.J., and Chang S. (1995) “A New Criterion for Automatic
Multilevel Thresholding” IEEE Trans. on Image Processing, 4(3): 370-378.
DOI:10.1109/83.366472

`2`

    
Sezgin M. and Sankur B. (2004) “Survey over Image Thresholding Techniques and
Quantitative Performance Evaluation” Journal of Electronic Imaging, 13(1):
146-165, DOI:10.1117/1.1631315
http://www.busim.ee.boun.edu.tr/~sankur/SankurFolder/Threshold_survey.pdf

`3`

    
ImageJ AutoThresholder code, http://fiji.sc/wiki/index.php/Auto_Threshold

#### Examples

    
    >>> from skimage.data import camera
    >>> image = camera()
    >>> thresh = threshold_yen(image)
    >>> binary = image <= thresh
    
## try_all_threshold

`skimage.filters.try_all_threshold(image, figsize=(8, 5), verbose=True)`
[source]

    
Returns a figure comparing the outputs of different thresholding methods.

Parameters

    
`image(N, M) ndarray`

    
Input image.

`figsizetuple, optional`

    
Figure size (in inches).

`verbosebool, optional`

    
Print function name for each method.

Returns

    
`fig, axtuple`

    
Matplotlib figure and axes.

#### Notes

The following algorithms are used:

  * isodata
  * li
  * mean
  * minimum
  * otsu
  * triangle
  * yen

#### Examples

    
    >>> from skimage.data import text
    >>> fig, ax = try_all_threshold(text(), figsize=(10, 6), verbose=False)
    
## unsharp_mask

`skimage.filters.unsharp_mask(image, radius=1.0, amount=1.0,
multichannel=False, preserve_range=False)` [source]

    
Unsharp masking filter.

The sharp details are identified as the difference between the original image
and its blurred version. These details are then scaled, and added back to the
original image.

Parameters

    
`image[P, …, ]M[, N][, C] ndarray`

    
Input image.

`radiusscalar or sequence of scalars, optional`

    
If a scalar is given, then its value is used for all dimensions. If sequence
is given, then there must be exactly one radius for each dimension except the
last dimension for multichannel images. Note that 0 radius means no blurring,
and negative values are not allowed.

`amountscalar, optional`

    
The details will be amplified with this factor. The factor could be 0 or
negative. Typically, it is a small positive number, e.g. 1.0.

`multichannelbool, optional`

    
If True, the last `image` dimension is considered as a color channel,
otherwise as spatial. Color channels are processed individually.

`preserve_rangebool, optional`

    
Whether to keep the original range of values. Otherwise, the input image is
converted according to the conventions of `img_as_float`. Also see
https://scikit-image.org/docs/dev/user_guide/data_types.html

Returns

    
`output[P, …, ]M[, N][, C] ndarray of float`

    
Image with unsharp mask applied.

#### Notes

Unsharp masking is an image sharpening technique. It is a linear image
operation, and numerically stable, unlike deconvolution which is an ill-posed
problem. Because of this stability, it is often preferred over deconvolution.

The main idea is as follows: sharp details are identified as the difference
between the original image and its blurred version. These details are added
back to the original image after a scaling step:

enhanced image = original + amount * (original - blurred)

When applying this filter to several color layers independently, color
bleeding may occur. More visually pleasing result can be achieved by
processing only the brightness/lightness/intensity channel in a suitable color
space such as HSV, HSL, YUV, or YCbCr.

Unsharp masking is described in most introductory digital image processing
books. This implementation is based on [1].

#### References

`1`

    
Maria Petrou, Costas Petrou “Image Processing: The Fundamentals”, (2010), ed
ii., page 357, ISBN 13: 9781119994398 DOI:10.1002/9781119994398

`2`

    
Wikipedia. Unsharp masking https://en.wikipedia.org/wiki/Unsharp_masking

#### Examples

    
    >>> array = np.ones(shape=(5,5), dtype=np.uint8)*100
    >>> array[2,2] = 120
    >>> array
    array([[100, 100, 100, 100, 100],
           [100, 100, 100, 100, 100],
           [100, 100, 120, 100, 100],
           [100, 100, 100, 100, 100],
           [100, 100, 100, 100, 100]], dtype=uint8)
    >>> np.around(unsharp_mask(array, radius=0.5, amount=2),2)
    array([[0.39, 0.39, 0.39, 0.39, 0.39],
           [0.39, 0.39, 0.38, 0.39, 0.39],
           [0.39, 0.38, 0.53, 0.38, 0.39],
           [0.39, 0.39, 0.38, 0.39, 0.39],
           [0.39, 0.39, 0.39, 0.39, 0.39]])
    
    
    >>> array = np.ones(shape=(5,5), dtype=np.int8)*100
    >>> array[2,2] = 127
    >>> np.around(unsharp_mask(array, radius=0.5, amount=2),2)
    array([[0.79, 0.79, 0.79, 0.79, 0.79],
           [0.79, 0.78, 0.75, 0.78, 0.79],
           [0.79, 0.75, 1.  , 0.75, 0.79],
           [0.79, 0.78, 0.75, 0.78, 0.79],
           [0.79, 0.79, 0.79, 0.79, 0.79]])
    
    
    >>> np.around(unsharp_mask(array, radius=0.5, amount=2, preserve_range=True), 2)
    array([[100.  , 100.  ,  99.99, 100.  , 100.  ],
           [100.  ,  99.39,  95.48,  99.39, 100.  ],
           [ 99.99,  95.48, 147.59,  95.48,  99.99],
           [100.  ,  99.39,  95.48,  99.39, 100.  ],
           [100.  , 100.  ,  99.99, 100.  , 100.  ]])
    
## wiener

`skimage.filters.wiener(data, impulse_response=None, filter_params={}, K=0.25,
predefined_filter=None)` [source]

    
Minimum Mean Square Error (Wiener) inverse filter.

Parameters

    
`data(M,N) ndarray`

    
Input data.

`Kfloat or (M,N) ndarray`

    
Ratio between power spectrum of noise and undegraded image.

`impulse_responsecallable f(r, c, **filter_params)`

    
Impulse response of the filter. See LPIFilter2D.__init__.

`filter_paramsdict`

    
Additional keyword parameters to the impulse_response function.

Other Parameters

    
`predefined_filterLPIFilter2D`

    
If you need to apply the same filter multiple times over different images,
construct the LPIFilter2D and specify it here.

## window

`skimage.filters.window(window_type, shape, warp_kwargs=None)` [source]

    
Return an n-dimensional window of a given size and dimensionality.

Parameters

    
`window_typestring, float, or tuple`

    
The type of window to be created. Any window type supported by
`scipy.signal.get_window` is allowed here. See notes below for a current list,
or the SciPy documentation for the version of SciPy on your machine.

`shapetuple of int or int`

    
The shape of the window along each axis. If an integer is provided, a 1D
window is generated.

`warp_kwargsdict`

    
Keyword arguments passed to `skimage.transform.warp` (e.g.,
`warp_kwargs={'order':3}` to change interpolation method).

Returns

    
`nd_windowndarray`

    
A window of the specified `shape`. `dtype` is `np.double`.

#### Notes

This function is based on `scipy.signal.get_window` and thus can access all of
the window types available to that function (e.g., `"hann"`, `"boxcar"`). Note
that certain window types require parameters that have to be supplied with the
window name as a tuple (e.g., `("tukey", 0.8)`). If only a float is supplied,
it is interpreted as the beta parameter of the Kaiser window.

See
https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.windows.get_window.html
for more details.

Note that this function generates a double precision array of the specified
`shape` and can thus generate very large arrays that consume a large amount of
available memory.

The approach taken here to create nD windows is to first calculate the
Euclidean distance from the center of the intended nD window to each position
in the array. That distance is used to sample, with interpolation, from a 1D
window returned from `scipy.signal.get_window`. The method of interpolation
can be changed with the `order` keyword argument passed to
`skimage.transform.warp`.

Some coordinates in the output window will be outside of the original signal;
these will be filled in with zeros.

Window types: - boxcar - triang - blackman - hamming - hann - bartlett -
flattop - parzen - bohman - blackmanharris - nuttall - barthann - kaiser
(needs beta) - gaussian (needs standard deviation) - general_gaussian (needs
power, width) - slepian (needs width) - dpss (needs normalized half-bandwidth)
- chebwin (needs attenuation) - exponential (needs decay scale) - tukey (needs
taper fraction)

#### References

`1`

    
Two-dimensional window design, Wikipedia,
https://en.wikipedia.org/wiki/Two_dimensional_window_design

#### Examples

Return a Hann window with shape (512, 512):

    
    >>> from skimage.filters import window
    >>> w = window('hann', (512, 512))
    
Return a Kaiser window with beta parameter of 16 and shape (256, 256, 35):

    
    >>> w = window(16, (256, 256, 35))
    
Return a Tukey window with an alpha parameter of 0.8 and shape (100, 300):

    
    >>> w = window(('tukey', 0.8), (100, 300))
    
## LPIFilter2D

`class skimage.filters.LPIFilter2D(impulse_response, **filter_params)`
[source]

    
Bases: `object`

Linear Position-Invariant Filter (2-dimensional)

`__init__(impulse_response, **filter_params)` [source]

    
Parameters

    
`impulse_responsecallable f(r, c, **filter_params)`

    
Function that yields the impulse response. `r` and `c` are 1-dimensional
vectors that represent row and column positions, in other words coordinates
are (r[0],c[0]),(r[0],c[1]) etc. `**filter_params` are passed through.

In other words, `impulse_response` would be called like this:

    
    >>> def impulse_response(r, c, **filter_params):
    ...     pass
    >>>
    >>> r = [0,0,0,1,1,1,2,2,2]
    >>> c = [0,1,2,0,1,2,0,1,2]
    >>> filter_params = {'kw1': 1, 'kw2': 2, 'kw3': 3}
    >>> impulse_response(r, c, **filter_params)
    
#### Examples

Gaussian filter: Use a 1-D gaussian in each direction without normalization
coefficients.

    
    >>> def filt_func(r, c, sigma = 1):
    ...     return np.exp(-np.hypot(r, c)/sigma)
    >>> filter = LPIFilter2D(filt_func)
    
© 2019 the scikit-image team  
Licensed under the BSD 3-clause License.  
https://scikit-image.org/docs/0.18.x/api/skimage.filters.html

  *[ISP]: Internet Service Provider
  *[LIFO]: last-in, first-out
  *[FIFO]: first-in, first-out

