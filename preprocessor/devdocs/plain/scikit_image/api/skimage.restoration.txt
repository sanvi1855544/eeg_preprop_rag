# Module: restoration

Image restoration module.

`skimage.restoration.ball_kernel`(radius, ndim) | Create a ball kernel for restoration.rolling_ball.  
---|---  
`skimage.restoration.calibrate_denoiser`(…) | Calibrate a denoising function and return optimal J-invariant version.  
`skimage.restoration.cycle_spin`(x, func, …) | Cycle spinning (repeatedly apply func to shifted versions of x).  
`skimage.restoration.denoise_bilateral`(image) | Denoise image using bilateral filter.  
`skimage.restoration.denoise_nl_means`(image) | Perform non-local means denoising on 2-D or 3-D grayscale images, and 2-D RGB images.  
`skimage.restoration.denoise_tv_bregman`(…) | Perform total-variation denoising using split-Bregman optimization.  
`skimage.restoration.denoise_tv_chambolle`(image) | Perform total-variation denoising on n-dimensional images.  
`skimage.restoration.denoise_wavelet`(image[, …]) | Perform wavelet denoising on an image.  
`skimage.restoration.ellipsoid_kernel`(shape, …) | Create an ellipoid kernel for restoration.rolling_ball.  
`skimage.restoration.estimate_sigma`(image[, …]) | Robust wavelet-based estimator of the (Gaussian) noise standard deviation.  
`skimage.restoration.inpaint_biharmonic`(…) | Inpaint masked points in image with biharmonic equations.  
`skimage.restoration.richardson_lucy`(image, psf) | Richardson-Lucy deconvolution.  
`skimage.restoration.rolling_ball`(image, *[, …]) | Estimate background intensity by rolling/translating a kernel.  
`skimage.restoration.unsupervised_wiener`(…) | Unsupervised Wiener-Hunt deconvolution.  
`skimage.restoration.unwrap_phase`(image[, …]) | Recover the original from a wrapped phase image.  
`skimage.restoration.wiener`(image, psf, balance) | Wiener-Hunt deconvolution  
## ball_kernel

`skimage.restoration.ball_kernel(radius, ndim)` [source]

    
Create a ball kernel for restoration.rolling_ball.

Parameters

    
`radiusint`

    
Radius of the ball.

`ndimint`

    
Number of dimensions of the ball. `ndim` should match the dimensionality of
the image the kernel will be applied to.

Returns

    
`kernelndarray`

    
The kernel containing the surface intensity of the top half of the ellipsoid.

See also

`rolling_ball`

## calibrate_denoiser

`skimage.restoration.calibrate_denoiser(image, denoise_function,
denoise_parameters, *, stride=4, approximate_loss=True, extra_output=False)`
[source]

    
Calibrate a denoising function and return optimal J-invariant version.

The returned function is partially evaluated with optimal parameter values set
for denoising the input image.

Parameters

    
`imagendarray`

    
Input data to be denoised (converted using `img_as_float`).

`denoise_functionfunction`

    
Denoising function to be calibrated.

`denoise_parametersdict of list`

    
Ranges of parameters for `denoise_function` to be calibrated over.

`strideint, optional`

    
Stride used in masking procedure that converts `denoise_function` to
J-invariance.

`approximate_lossbool, optional`

    
Whether to approximate the self-supervised loss used to evaluate the denoiser
by only computing it on one masked version of the image. If False, the runtime
will be a factor of `stride**image.ndim` longer.

`extra_outputbool, optional`

    
If True, return parameters and losses in addition to the calibrated denoising
function

Returns

    
`best_denoise_functionfunction`

    
The optimal J-invariant version of `denoise_function`.

`If extra_output is True, the following tuple is also returned:`

`(parameters_tested, losses)tuple (list of dict, list of int)`

    
List of parameters tested for `denoise_function`, as a dictionary of kwargs
Self-supervised loss for each set of parameters in `parameters_tested`.

#### Notes

The calibration procedure uses a self-supervised mean-square-error loss to
evaluate the performance of J-invariant versions of `denoise_function`. The
minimizer of the self-supervised loss is also the minimizer of the ground-
truth loss (i.e., the true MSE error) [1]. The returned function can be used
on the original noisy image, or other images with similar characteristics.

`Increasing the stride increases the performance of best_denoise_function`

    
at the expense of increasing its runtime. It has no effect on the runtime of
the calibration.

#### References

`1`

    
J. Batson & L. Royer. Noise2Self: Blind Denoising by Self-Supervision,
International Conference on Machine Learning, p. 524-533 (2019).

#### Examples

    
    >>> from skimage import color, data
    >>> from skimage.restoration import denoise_wavelet
    >>> import numpy as np
    >>> img = color.rgb2gray(data.astronaut()[:50, :50])
    >>> noisy = img + 0.5 * img.std() * np.random.randn(*img.shape)
    >>> parameters = {'sigma': np.arange(0.1, 0.4, 0.02)}
    >>> denoising_function = calibrate_denoiser(noisy, denoise_wavelet,
    ...                                         denoise_parameters=parameters)
    >>> denoised_img = denoising_function(img)
    
## cycle_spin

`skimage.restoration.cycle_spin(x, func, max_shifts, shift_steps=1,
num_workers=None, multichannel=False, func_kw={})` [source]

    
Cycle spinning (repeatedly apply func to shifted versions of x).

Parameters

    
`xarray-like`

    
Data for input to `func`.

`funcfunction`

    
A function to apply to circularly shifted versions of `x`. Should take `x` as
its first argument. Any additional arguments can be supplied via `func_kw`.

`max_shiftsint or tuple`

    
If an integer, shifts in `range(0, max_shifts+1)` will be used along each axis
of `x`. If a tuple, `range(0, max_shifts[i]+1)` will be along axis i.

`shift_stepsint or tuple, optional`

    
The step size for the shifts applied along axis, i, are:: `range((0,
max_shifts[i]+1, shift_steps[i]))`. If an integer is provided, the same step
size is used for all axes.

`num_workersint or None, optional`

    
The number of parallel threads to use during cycle spinning. If set to `None`,
the full set of available cores are used.

`multichannelbool, optional`

    
Whether to treat the final axis as channels (no cycle shifts are performed
over the channels axis).

`func_kwdict, optional`

    
Additional keyword arguments to supply to `func`.

Returns

    
`avg_ynp.ndarray`

    
The output of `func(x, **func_kw)` averaged over all combinations of the
specified axis shifts.

#### Notes

Cycle spinning was proposed as a way to approach shift-invariance via
performing several circular shifts of a shift-variant transform [1].

For a n-level discrete wavelet transforms, one may wish to perform all shifts
up to `max_shifts = 2**n - 1`. In practice, much of the benefit can often be
realized with only a small number of shifts per axis.

For transforms such as the blockwise discrete cosine transform, one may wish
to evaluate shifts up to the block size used by the transform.

#### References

`1`

    
R.R. Coifman and D.L. Donoho. “Translation-Invariant De-Noising”. Wavelets and
Statistics, Lecture Notes in Statistics, vol.103. Springer, New York, 1995,
pp.125-150. DOI:10.1007/978-1-4612-2544-7_9

#### Examples

    
    >>> import skimage.data
    >>> from skimage import img_as_float
    >>> from skimage.restoration import denoise_wavelet, cycle_spin
    >>> img = img_as_float(skimage.data.camera())
    >>> sigma = 0.1
    >>> img = img + sigma * np.random.standard_normal(img.shape)
    >>> denoised = cycle_spin(img, func=denoise_wavelet,
    ...                       max_shifts=3)
    
## denoise_bilateral

`skimage.restoration.denoise_bilateral(image, win_size=None, sigma_color=None,
sigma_spatial=1, bins=10000, mode='constant', cval=0, multichannel=False)`
[source]

    
Denoise image using bilateral filter.

Parameters

    
`imagendarray, shape (M, N[, 3])`

    
Input image, 2D grayscale or RGB.

`win_sizeint`

    
Window size for filtering. If win_size is not specified, it is calculated as
`max(5, 2 * ceil(3 * sigma_spatial) + 1)`.

`sigma_colorfloat`

    
Standard deviation for grayvalue/color distance (radiometric similarity). A
larger value results in averaging of pixels with larger radiometric
differences. Note, that the image will be converted using the `img_as_float`
function and thus the standard deviation is in respect to the range `[0, 1]`.
If the value is `None` the standard deviation of the `image` will be used.

`sigma_spatialfloat`

    
Standard deviation for range distance. A larger value results in averaging of
pixels with larger spatial differences.

`binsint`

    
Number of discrete values for Gaussian weights of color filtering. A larger
value results in improved accuracy.

`mode{‘constant’, ‘edge’, ‘symmetric’, ‘reflect’, ‘wrap’}`

    
How to handle values outside the image borders. See `numpy.pad` for detail.

`cvalstring`

    
Used in conjunction with mode ‘constant’, the value outside the image
boundaries.

`multichannelbool`

    
Whether the last axis of the image is to be interpreted as multiple channels
or another spatial dimension.

Returns

    
`denoisedndarray`

    
Denoised image.

#### Notes

This is an edge-preserving, denoising filter. It averages pixels based on
their spatial closeness and radiometric similarity [1].

Spatial closeness is measured by the Gaussian function of the Euclidean
distance between two pixels and a certain standard deviation
(`sigma_spatial`).

Radiometric similarity is measured by the Gaussian function of the Euclidean
distance between two color values and a certain standard deviation
(`sigma_color`).

#### References

`1`

    
C. Tomasi and R. Manduchi. “Bilateral Filtering for Gray and Color Images.”
IEEE International Conference on Computer Vision (1998) 839-846.
DOI:10.1109/ICCV.1998.710815

#### Examples

    
    >>> from skimage import data, img_as_float
    >>> astro = img_as_float(data.astronaut())
    >>> astro = astro[220:300, 220:320]
    >>> noisy = astro + 0.6 * astro.std() * np.random.random(astro.shape)
    >>> noisy = np.clip(noisy, 0, 1)
    >>> denoised = denoise_bilateral(noisy, sigma_color=0.05, sigma_spatial=15,
    ...                              multichannel=True)
    
### Examples using `skimage.restoration.denoise_bilateral`

![Rank
filters](data:image/png;base64,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)

Rank filters

## denoise_nl_means

`skimage.restoration.denoise_nl_means(image, patch_size=7, patch_distance=11,
h=0.1, multichannel=False, fast_mode=True, sigma=0.0, *, preserve_range=None)`
[source]

    
Perform non-local means denoising on 2-D or 3-D grayscale images, and 2-D RGB
images.

Parameters

    
`image2D or 3D ndarray`

    
Input image to be denoised, which can be 2D or 3D, and grayscale or RGB (for
2D images only, see `multichannel` parameter).

`patch_sizeint, optional`

    
Size of patches used for denoising.

`patch_distanceint, optional`

    
Maximal distance in pixels where to search patches used for denoising.

`hfloat, optional`

    
Cut-off distance (in gray levels). The higher h, the more permissive one is in
accepting patches. A higher h results in a smoother image, at the expense of
blurring features. For a Gaussian noise of standard deviation sigma, a rule of
thumb is to choose the value of h to be sigma of slightly less.

`multichannelbool, optional`

    
Whether the last axis of the image is to be interpreted as multiple channels
or another spatial dimension.

`fast_modebool, optional`

    
If True (default value), a fast version of the non-local means algorithm is
used. If False, the original version of non-local means is used. See the Notes
section for more details about the algorithms.

`sigmafloat, optional`

    
The standard deviation of the (Gaussian) noise. If provided, a more robust
computation of patch weights is computed that takes the expected noise
variance into account (see Notes below).

`preserve_rangebool, optional`

    
Whether to keep the original range of values. Otherwise, the input image is
converted according to the conventions of `img_as_float`. Also see
https://scikit-image.org/docs/dev/user_guide/data_types.html

Returns

    
`resultndarray`

    
Denoised image, of same shape as `image`.

#### Notes

The non-local means algorithm is well suited for denoising images with
specific textures. The principle of the algorithm is to average the value of a
given pixel with values of other pixels in a limited neighbourhood, provided
that the patches centered on the other pixels are similar enough to the patch
centered on the pixel of interest.

In the original version of the algorithm [1], corresponding to `fast=False`,
the computational complexity is:

    
    image.size * patch_size ** image.ndim * patch_distance ** image.ndim
    
Hence, changing the size of patches or their maximal distance has a strong
effect on computing times, especially for 3-D images.

However, the default behavior corresponds to `fast_mode=True`, for which
another version of non-local means [2] is used, corresponding to a complexity
of:

    
    image.size * patch_distance ** image.ndim
    
The computing time depends only weakly on the patch size, thanks to the
computation of the integral of patches distances for a given shift, that
reduces the number of operations [1]. Therefore, this algorithm executes
faster than the classic algorithm (`fast_mode=False`), at the expense of using
twice as much memory. This implementation has been proven to be more efficient
compared to other alternatives, see e.g. [3].

Compared to the classic algorithm, all pixels of a patch contribute to the
distance to another patch with the same weight, no matter their distance to
the center of the patch. This coarser computation of the distance can result
in a slightly poorer denoising performance. Moreover, for small images (images
with a linear size that is only a few times the patch size), the classic
algorithm can be faster due to boundary effects.

The image is padded using the `reflect` mode of `skimage.util.pad` before
denoising.

If the noise standard deviation, `sigma`, is provided a more robust
computation of patch weights is used. Subtracting the known noise variance
from the computed patch distances improves the estimates of patch similarity,
giving a moderate improvement to denoising performance [4]. It was also
mentioned as an option for the fast variant of the algorithm in [3].

When `sigma` is provided, a smaller `h` should typically be used to avoid
oversmoothing. The optimal value for `h` depends on the image content and
noise level, but a reasonable starting point is `h = 0.8 * sigma` when
`fast_mode` is `True`, or `h = 0.6 * sigma` when `fast_mode` is `False`.

#### References

`1(1,2)`

    
A. Buades, B. Coll, & J-M. Morel. A non-local algorithm for image denoising.
In CVPR 2005, Vol. 2, pp. 60-65, IEEE. DOI:10.1109/CVPR.2005.38

`2`

    
J. Darbon, A. Cunha, T.F. Chan, S. Osher, and G.J. Jensen, Fast nonlocal
filtering applied to electron cryomicroscopy, in 5th IEEE International
Symposium on Biomedical Imaging: From Nano to Macro, 2008, pp. 1331-1334.
DOI:10.1109/ISBI.2008.4541250

`3(1,2)`

    
Jacques Froment. Parameter-Free Fast Pixelwise Non-Local Means Denoising.
Image Processing On Line, 2014, vol. 4, pp. 300-326. DOI:10.5201/ipol.2014.120

`4`

    
A. Buades, B. Coll, & J-M. Morel. Non-Local Means Denoising. Image Processing
On Line, 2011, vol. 1, pp. 208-212. DOI:10.5201/ipol.2011.bcm_nlm

#### Examples

    
    >>> a = np.zeros((40, 40))
    >>> a[10:-10, 10:-10] = 1.
    >>> a += 0.3 * np.random.randn(*a.shape)
    >>> denoised_a = denoise_nl_means(a, 7, 5, 0.1)
    
## denoise_tv_bregman

`skimage.restoration.denoise_tv_bregman(image, weight, max_iter=100,
eps=0.001, isotropic=True, *, multichannel=False)` [source]

    
Perform total-variation denoising using split-Bregman optimization.

Total-variation denoising (also know as total-variation regularization) tries
to find an image with less total-variation under the constraint of being
similar to the input image, which is controlled by the regularization
parameter ([1], [2], [3], [4]).

Parameters

    
`imagendarray`

    
Input data to be denoised (converted using img_as_float`).

`weightfloat`

    
Denoising weight. The smaller the `weight`, the more denoising (at the expense
of less similarity to the `input`). The regularization parameter `lambda` is
chosen as `2 * weight`.

`epsfloat, optional`

    
Relative difference of the value of the cost function that determines the stop
criterion. The algorithm stops when:

    
    SUM((u(n) - u(n-1))**2) < eps
    
`max_iterint, optional`

    
Maximal number of iterations used for the optimization.

`isotropicboolean, optional`

    
Switch between isotropic and anisotropic TV denoising.

`multichannelbool, optional`

    
Apply total-variation denoising separately for each channel. This option
should be true for color images, otherwise the denoising is also applied in
the channels dimension.

Returns

    
`undarray`

    
Denoised image.

#### References

`1`

    
https://en.wikipedia.org/wiki/Total_variation_denoising

`2`

    
Tom Goldstein and Stanley Osher, “The Split Bregman Method For L1 Regularized
Problems”, ftp://ftp.math.ucla.edu/pub/camreport/cam08-29.pdf

`3`

    
Pascal Getreuer, “Rudin–Osher–Fatemi Total Variation Denoising using Split
Bregman” in Image Processing On Line on 2012–05–19,
https://www.ipol.im/pub/art/2012/g-tvd/article_lr.pdf

`4`

    
https://web.math.ucsb.edu/~cgarcia/UGProjects/BregmanAlgorithms_JacquelineBush.pdf

## denoise_tv_chambolle

`skimage.restoration.denoise_tv_chambolle(image, weight=0.1, eps=0.0002,
n_iter_max=200, multichannel=False)` [source]

    
Perform total-variation denoising on n-dimensional images.

Parameters

    
`imagendarray of ints, uints or floats`

    
Input data to be denoised. `image` can be of any numeric type, but it is cast
into an ndarray of floats for the computation of the denoised image.

`weightfloat, optional`

    
Denoising weight. The greater `weight`, the more denoising (at the expense of
fidelity to `input`).

`epsfloat, optional`

    
Relative difference of the value of the cost function that determines the stop
criterion. The algorithm stops when:

(E_(n-1) - E_n) < eps * E_0

`n_iter_maxint, optional`

    
Maximal number of iterations used for the optimization.

`multichannelbool, optional`

    
Apply total-variation denoising separately for each channel. This option
should be true for color images, otherwise the denoising is also applied in
the channels dimension.

Returns

    
`outndarray`

    
Denoised image.

#### Notes

Make sure to set the multichannel parameter appropriately for color images.

The principle of total variation denoising is explained in
https://en.wikipedia.org/wiki/Total_variation_denoising

The principle of total variation denoising is to minimize the total variation
of the image, which can be roughly described as the integral of the norm of
the image gradient. Total variation denoising tends to produce “cartoon-like”
images, that is, piecewise-constant images.

This code is an implementation of the algorithm of Rudin, Fatemi and Osher
that was proposed by Chambolle in [1].

#### References

`1`

    
A. Chambolle, An algorithm for total variation minimization and applications,
Journal of Mathematical Imaging and Vision, Springer, 2004, 20, 89-97.

#### Examples

2D example on astronaut image:

    
    >>> from skimage import color, data
    >>> img = color.rgb2gray(data.astronaut())[:50, :50]
    >>> img += 0.5 * img.std() * np.random.randn(*img.shape)
    >>> denoised_img = denoise_tv_chambolle(img, weight=60)
    
3D example on synthetic data:

    
    >>> x, y, z = np.ogrid[0:20, 0:20, 0:20]
    >>> mask = (x - 22)**2 + (y - 20)**2 + (z - 17)**2 < 8**2
    >>> mask = mask.astype(float)
    >>> mask += 0.2*np.random.randn(*mask.shape)
    >>> res = denoise_tv_chambolle(mask, weight=100)
    
## denoise_wavelet

`skimage.restoration.denoise_wavelet(image, sigma=None, wavelet='db1',
mode='soft', wavelet_levels=None, multichannel=False, convert2ycbcr=False,
method='BayesShrink', rescale_sigma=True)` [source]

    
Perform wavelet denoising on an image.

Parameters

    
`imagendarray ([M[, N[, …P]][, C]) of ints, uints or floats`

    
Input data to be denoised. `image` can be of any numeric type, but it is cast
into an ndarray of floats for the computation of the denoised image.

`sigmafloat or list, optional`

    
The noise standard deviation used when computing the wavelet detail
coefficient threshold(s). When None (default), the noise standard deviation is
estimated via the method in [2].

`waveletstring, optional`

    
The type of wavelet to perform and can be any of the options `pywt.wavelist`
outputs. The default is `‘db1’`. For example, `wavelet` can be any of `{'db2',
'haar', 'sym9'}` and many more.

`mode{‘soft’, ‘hard’}, optional`

    
An optional argument to choose the type of denoising performed. It noted that
choosing soft thresholding given additive noise finds the best approximation
of the original image.

`wavelet_levelsint or None, optional`

    
The number of wavelet decomposition levels to use. The default is three less
than the maximum number of possible decomposition levels.

`multichannelbool, optional`

    
Apply wavelet denoising separately for each channel (where channels correspond
to the final axis of the array).

`convert2ycbcrbool, optional`

    
If True and multichannel True, do the wavelet denoising in the YCbCr
colorspace instead of the RGB color space. This typically results in better
performance for RGB images.

`method{‘BayesShrink’, ‘VisuShrink’}, optional`

    
Thresholding method to be used. The currently supported methods are
“BayesShrink” [1] and “VisuShrink” [2]. Defaults to “BayesShrink”.

`rescale_sigmabool, optional`

    
If False, no rescaling of the user-provided `sigma` will be performed. The
default of `True` rescales sigma appropriately if the image is rescaled
internally.

New in version 0.16: `rescale_sigma` was introduced in 0.16

Returns

    
`outndarray`

    
Denoised image.

#### Notes

The wavelet domain is a sparse representation of the image, and can be thought
of similarly to the frequency domain of the Fourier transform. Sparse
representations have most values zero or near-zero and truly random noise is
(usually) represented by many small values in the wavelet domain. Setting all
values below some threshold to 0 reduces the noise in the image, but larger
thresholds also decrease the detail present in the image.

If the input is 3D, this function performs wavelet denoising on each color
plane separately.

Changed in version 0.16: For floating point inputs, the original input range
is maintained and there is no clipping applied to the output. Other input
types will be converted to a floating point value in the range [-1, 1] or [0,
1] depending on the input image range. Unless `rescale_sigma = False`, any
internal rescaling applied to the `image` will also be applied to `sigma` to
maintain the same relative amplitude.

Many wavelet coefficient thresholding approaches have been proposed. By
default, `denoise_wavelet` applies BayesShrink, which is an adaptive
thresholding method that computes separate thresholds for each wavelet sub-
band as described in [1].

If `method == "VisuShrink"`, a single “universal threshold” is applied to all
wavelet detail coefficients as described in [2]. This threshold is designed to
remove all Gaussian noise at a given `sigma` with high probability, but tends
to produce images that appear overly smooth.

Although any of the wavelets from `PyWavelets` can be selected, the
thresholding methods assume an orthogonal wavelet transform and may not choose
the threshold appropriately for biorthogonal wavelets. Orthogonal wavelets are
desirable because white noise in the input remains white noise in the
subbands. Biorthogonal wavelets lead to colored noise in the subbands.
Additionally, the orthogonal wavelets in PyWavelets are orthonormal so that
noise variance in the subbands remains identical to the noise variance of the
input. Example orthogonal wavelets are the Daubechies (e.g. ‘db2’) or symmlet
(e.g. ‘sym2’) families.

#### References

`1(1,2)`

    
Chang, S. Grace, Bin Yu, and Martin Vetterli. “Adaptive wavelet thresholding
for image denoising and compression.” Image Processing, IEEE Transactions on
9.9 (2000): 1532-1546. DOI:10.1109/83.862633

`2(1,2,3)`

    
D. L. Donoho and I. M. Johnstone. “Ideal spatial adaptation by wavelet
shrinkage.” Biometrika 81.3 (1994): 425-455. DOI:10.1093/biomet/81.3.425

#### Examples

    
    >>> from skimage import color, data
    >>> img = img_as_float(data.astronaut())
    >>> img = color.rgb2gray(img)
    >>> img += 0.1 * np.random.randn(*img.shape)
    >>> img = np.clip(img, 0, 1)
    >>> denoised_img = denoise_wavelet(img, sigma=0.1, rescale_sigma=True)
    
## ellipsoid_kernel

`skimage.restoration.ellipsoid_kernel(shape, intensity)` [source]

    
Create an ellipoid kernel for restoration.rolling_ball.

Parameters

    
`shapearraylike`

    
Length of the principal axis of the ellipsoid (excluding the intensity axis).
The kernel needs to have the same dimensionality as the image it will be
applied to.

`intensityint`

    
Length of the intensity axis of the ellipsoid.

Returns

    
`kernelndarray`

    
The kernel containing the surface intensity of the top half of the ellipsoid.

See also

`rolling_ball`

### Examples using `skimage.restoration.ellipsoid_kernel`

![Use rolling-ball algorithm for estimating background
intensity](data:image/png;base64,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)

Use rolling-ball algorithm for estimating background intensity

## estimate_sigma

`skimage.restoration.estimate_sigma(image, average_sigmas=False,
multichannel=False)` [source]

    
Robust wavelet-based estimator of the (Gaussian) noise standard deviation.

Parameters

    
`imagendarray`

    
Image for which to estimate the noise standard deviation.

`average_sigmasbool, optional`

    
If true, average the channel estimates of `sigma`. Otherwise return a list of
sigmas corresponding to each channel.

`multichannelbool`

    
Estimate sigma separately for each channel.

Returns

    
`sigmafloat or list`

    
Estimated noise standard deviation(s). If `multichannel` is True and
`average_sigmas` is False, a separate noise estimate for each channel is
returned. Otherwise, the average of the individual channel estimates is
returned.

#### Notes

This function assumes the noise follows a Gaussian distribution. The
estimation algorithm is based on the median absolute deviation of the wavelet
detail coefficients as described in section 4.2 of [1].

#### References

`1`

    
D. L. Donoho and I. M. Johnstone. “Ideal spatial adaptation by wavelet
shrinkage.” Biometrika 81.3 (1994): 425-455. DOI:10.1093/biomet/81.3.425

#### Examples

    
    >>> import skimage.data
    >>> from skimage import img_as_float
    >>> img = img_as_float(skimage.data.camera())
    >>> sigma = 0.1
    >>> img = img + sigma * np.random.standard_normal(img.shape)
    >>> sigma_hat = estimate_sigma(img, multichannel=False)
    
## inpaint_biharmonic

`skimage.restoration.inpaint_biharmonic(image, mask, multichannel=False)`
[source]

    
Inpaint masked points in image with biharmonic equations.

Parameters

    
`image(M[, N[, …, P]][, C]) ndarray`

    
Input image.

`mask(M[, N[, …, P]]) ndarray`

    
Array of pixels to be inpainted. Have to be the same shape as one of the
‘image’ channels. Unknown pixels have to be represented with 1, known pixels -
with 0.

`multichannelboolean, optional`

    
If True, the last `image` dimension is considered as a color channel,
otherwise as spatial.

Returns

    
`out(M[, N[, …, P]][, C]) ndarray`

    
Input image with masked pixels inpainted.

#### References

`1`

    
N.S.Hoang, S.B.Damelin, “On surface completion and image inpainting by
biharmonic functions: numerical aspects”, arXiv:1707.06567

`2`

    
C. K. Chui and H. N. Mhaskar, MRA Contextual-Recovery Extension of Smooth
Functions on Manifolds, Appl. and Comp. Harmonic Anal., 28 (2010), 104-113,
DOI:10.1016/j.acha.2009.04.004

#### Examples

    
    >>> img = np.tile(np.square(np.linspace(0, 1, 5)), (5, 1))
    >>> mask = np.zeros_like(img)
    >>> mask[2, 2:] = 1
    >>> mask[1, 3:] = 1
    >>> mask[0, 4:] = 1
    >>> out = inpaint_biharmonic(img, mask)
    
## richardson_lucy

`skimage.restoration.richardson_lucy(image, psf, iterations=50, clip=True,
filter_epsilon=None)` [source]

    
Richardson-Lucy deconvolution.

Parameters

    
`imagendarray`

    
Input degraded image (can be N dimensional).

`psfndarray`

    
The point spread function.

`iterationsint, optional`

    
Number of iterations. This parameter plays the role of regularisation.

`clipboolean, optional`

    
True by default. If true, pixel value of the result above 1 or under -1 are
thresholded for skimage pipeline compatibility.

filter_epsilon: float, optional

    
Value below which intermediate results become 0 to avoid division by small
numbers.

Returns

    
`im_deconvndarray`

    
The deconvolved image.

#### References

`1`

    
https://en.wikipedia.org/wiki/Richardson%E2%80%93Lucy_deconvolution

#### Examples

    
    >>> from skimage import img_as_float, data, restoration
    >>> camera = img_as_float(data.camera())
    >>> from scipy.signal import convolve2d
    >>> psf = np.ones((5, 5)) / 25
    >>> camera = convolve2d(camera, psf, 'same')
    >>> camera += 0.1 * camera.std() * np.random.standard_normal(camera.shape)
    >>> deconvolved = restoration.richardson_lucy(camera, psf, 5)
    
## rolling_ball

`skimage.restoration.rolling_ball(image, *, radius=100, kernel=None,
nansafe=False, num_threads=None)` [source]

    
Estimate background intensity by rolling/translating a kernel.

This rolling ball algorithm estimates background intensity for a ndimage in
case of uneven exposure. It is a generalization of the frequently used rolling
ball algorithm [1].

Parameters

    
`imagendarray`

    
The image to be filtered.

`radiusint, optional`

    
Radius of a ball shaped kernel to be rolled/translated in the image. Used if
`kernel = None`.

`kernelndarray, optional`

    
The kernel to be rolled/translated in the image. It must have the same number
of dimensions as `image`. Kernel is filled with the intensity of the kernel at
that position.

nansafe: bool, optional

    
If `False` (default) assumes that none of the values in `image` are `np.nan`,
and uses a faster implementation.

num_threads: int, optional

    
The maximum number of threads to use. If `None` use the OpenMP default value;
typically equal to the maximum number of virtual cores. Note: This is an upper
limit to the number of threads. The exact number is determined by the system’s
OpenMP library.

Returns

    
`backgroundndarray`

    
The estimated background of the image.

#### Notes

For the pixel that has its background intensity estimated (without loss of
generality at `center`) the rolling ball method centers `kernel` under it and
raises the kernel until the surface touches the image umbra at some
`pos=(y,x)`. The background intensity is then estimated using the image
intensity at that position (`image[pos]`) plus the difference of
`kernel[center] - kernel[pos]`.

This algorithm assumes that dark pixels correspond to the background. If you
have a bright background, invert the image before passing it to the function,
e.g., using `utils.invert`. See the gallery example for details.

This algorithm is sensitive to noise (in particular salt-and-pepper noise). If
this is a problem in your image, you can apply mild gaussian smoothing before
passing the image to this function.

#### References

`1`

    
Sternberg, Stanley R. “Biomedical image processing.” Computer 1 (1983): 22-34.
DOI:10.1109/MC.1983.1654163

#### Examples

    
    >>> import numpy as np
    >>> from skimage import data
    >>> from skimage.restoration import rolling_ball
    >>> image = data.coins()
    >>> background = rolling_ball(data.coins())
    >>> filtered_image = image - background
    
    
    >>> import numpy as np
    >>> from skimage import data
    >>> from skimage.restoration import rolling_ball, ellipsoid_kernel
    >>> image = data.coins()
    >>> kernel = ellipsoid_kernel((101, 101), 75)
    >>> background = rolling_ball(data.coins(), kernel=kernel)
    >>> filtered_image = image - background
    
### Examples using `skimage.restoration.rolling_ball`

![Use rolling-ball algorithm for estimating background
intensity](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARgAAADECAMAAABz285eAAAA+VBMVEX///8nJycrKysUFBQYGBglJSUaGhogICAjIyMdHR0vLy84ODgpKSktLS1LS0sxMTE7OzszMzNZWVlAQEBra2sQEBBnZ2d6enpFRUU1NTVISEhPT093d3eOjo50dHSLi4ugoKA9PT2RkZGIiIiqqqqCgoKFhYVdXV2bm5ulpaVSUlJCQkLu7u6np6f09PTs7OxiYmJvb2+0tLRWVlaioqKZmZkLCwtUVFS2traXl5e5ubnExMR/f39fX1/BwcF+fn6dnZ2UlJRkZGRxcXHx8fGwsLD+/v69vb2tra2ysrLW1tbHx8fMzMwDAwP5+fnk5OTS0tLd3d3p6ekYGc44AAAgAElEQVR42uyWaXeqWBaG0cRoHFCRgAOTgKImDjiUIiqKEyIt4v//Mb0PmNzbVasrt3LzoXut8yxRQHM4PLx7nxAEBoPBYDAYDAaDwWAwGAwGg8FgMBgMBoPBYDAYDAaDwWAwGAwGg8FgMBgMBoPBYDAYDAaDwWAwX6DnX9CH56N31/04fYZt9TsD9/3+++7hePlvvzIvXxv94vuHn49v3uHwrV5cmqXBySESE3yI8bcgxvy4s7/sfD5zTaGP0e8Ph0EP9qL9Pw1B978279WIZaOxovHO4mr2rWYYk9hbpm60gzPNqmdzz+lmTxTONw6euRTorLzRdx5r9X2dVQ4tQfrVq/cYfyIdOeUSbK1Av4l+VxC8Nae26c1FPqyOKkufe6xF7b4279mEoFxZmPUXrDsOfOnKW+TsG71cYGI+0xV64ooO1uLQkTeucPDGjM9CalhP65NXw9mtuLY49AbmYF4LflXMtEkdb8fBijvvLkt9dbP7wpztukyfOwqHvapIXkPd+NO3r0382KGFsXCaDhn3snCDxlVW15dvFHPQAsLbOm2Cn9PEmZ85k+OONQVJC8VYXoPQd/uxwVsbK9hxqu04v/qEezoR2Iv14ET3CKJT6wcCMZk33CtLbFSOUFXeuzX545dLad70uAbnDHszfaYEweIqO91v7TEnemx7qkSIZ1Gk+ZNqzN+4uWBMfSFMDEswO1VqGrQ8FETNp7tO71fFjFS2ue3W5mO269MmHdCtznFx7TGGfbM2lCqeYXh7Uv5iKQ1lYqNz6ixoN9YOywpX0WSu32rmegoI3yeCXW+mtG43v39xD+bZvUAbvri7gLhebv5u7vmH1Vgg/JP3qz3mYJ6OB3/u9YnVsXclXN+f6edgR9zgev359Ra8wSW81fWL+e8HxM4NTu5uvrpcjl6wCw7H7xXzwZnV0fL0nzf+48hv0OZvje9wbI/4f+Sw+/sw9H6zt112/9v33/sH7H7mT4cR/dDW4cefXBBh7A6Iyw9+3v/gfpm3PnD7IHpC0fXe7vT/Iehv/jrTv8nFWhRFRWkqiiK+E+4qotJsvLNYLBoLi2W5HwhoE4Qt/QOdtutnNOhOhPFEXjbWY/U0N6/QP+Ce+34QuNerFwIfZ3N1PM7nw9MecRoOT864Zch8YzuYkqVMOptKPj0+vLy8PIX/bBKNgT1YahRFjabTGll9rWcqlUqhXiq9vpZKdfiEd/SKDuuFOqJQgO+rZJXsTKeUthzYDAMz3erM6/wTMRsL3bJlhfcebRYcwQs8CEIkIWRLM3Q4rA4bg/YYmCmFZgqvEaUNqFHVC8U0rUWjqYhgpu2EYiAHbzfkBXzcMcHKbHbaO2q33e524W08kcXmwuIYiqwX46mnh5c//vgX8EckhuuMpp0aSZLVcrlUqBTjsUQikc2l88V8PhfPpRFwBKTj8RycCXfTxSLYKyBB5SpJdjrTEbW0lxRpfiaGBQls5ALpgYM7nLAFhDtbHTwwdzHMnYFGjTo1yrapGjnS4Gl23EhM6IXfTKTuHsT4KMYQmMiLCYCYFXgZ3r2M22Np3ZrISsNi4QFotddMLpF8vJt5F1PrhF5ATAnSko7FEqlEDIzk07k4UgGkkZh0LpvNIlH5SiUPW6YOCcqAnTpJaSMSZrrUtKn3iRie/RlkJSoTjtu+l4mOAC1LSKJ9NxICwR7Vpo21pEoiQ07hgVbDJXKnhF5kowWldDy7ftgyguDuZbVamaiO5qGX9ngsSdLE2GzACytAHBmtUy5AJYWRATMvkZgtWQMvVZQX8IICk0qlElkwE49DdmIgKgEHufCLGDqfL1byYCcDeclkMpWCLhtdNNMRVCP5qRjuo3XAZxgUiAcKCnIBN79chlXDLClIIVQpyLEHKB2o3KnOUtqPlaEqTYRah6yWru89BrxAYNrObOUFPjTQMC+gA/oKEmOaEBjoLpAX8IJaC7S10AsMTnWqqJaeHyMz72KqNaTltVQvZIr5eCyWQiAD2Vgq+fz89PSYTMSy2Vjy+eHxGb7I5YvFPApRJVMBLyVFmrD7rtSC6NWqpc/EyMgHqhRdh44CWRGipKCMLDUaTg00FJPldApSqFANqqBaDbWz0Wjd5TeyKhkTg66W64VIDB96+ei9PoC8RN0WOK7M1XwIcYm8TDZ82OpZgWaga4WtNZOOhWZAzUMkRoceCloKmQrqIhCQVBKAzGRjieenWLFSfH5IotOPj2Al+RwDMajKQkOQmobBKs12C820XK5nzp8lJlxeaGYLswI12ygoNgrJYKBAyKW1oMF6QNHNtbGRhakGGaJGNkeDm2mHUw3FWLR5wxDZUqaQCcX0NrwceunuITCuGwRh34WQoLYC689sDnV0T0voBbTAEoC8QFyi+y/GE8nIzGMkhn5FVVRJZ+rFLOovkJKnR4hGAgWmClMcaJXnBEhKkzCMVk7F8/liOl7okJVcOpPRjCYn6i1YERSrVMkUPxMjos5KC7whdQ1O38JCxnCNBa3BCmTz7a7jqGOJWQ4ohlfaLak13qImOxJEWEDYUa1jSCJvWF3IB98oFwtRYnoGaJmAF2d4PF+vLnANvaDicZxwbd6rbXDearUmyEsDrYGcfvfyCsUCuYjMPLw8R2KY+utrvVKYQoBH+WQikXp6yhUK2acUJKZDR1NPp2KpNNXZwnMVyjHoxHGSgfPLerGwkC1LpFuKIouNcq5S+VQMtBNdUE/dzdqRWFhx9IkDT1OE8lms19Ae4RZkTVs2m8Z8rar7CWoudNMwNuNGszZtr3nZ4uctGboEmX8XszZaa6mNvJhn+J/lGnaX0AtUD+A43fEa+q0cEnpBNUzbyEvUW2ENBjMpaB0PqUiMXUBry5alRxSt5ZOpZGpKwxJRg/77atvROqpBy+lMbVFn2aYAS3W+vBRYTmT0zL8Zs9ImNbE2WqIosigg7b4AsrgUUyoaxbZb0HLEJG8qNf//x7znuRczmfni3KpOVXdahcN5zvK07mZ+MD7dsinkrKEazZfAQE2u9v3oRd52NoLIpt+O981tM720sy2eOc58DsJkmZfbM++4WwOZaXo7bqPdaNWfeeBMdsvTWWIPmrrDgdna23nk3Q538h/EuXfuzY+cmzMOxpLkFicIpsGJssEaTxb60l+SiiCSQDa1Eg2M+Be71JUBGq2CEzOCBgQmnnb8zrAzKAkmMhshMx421R6eaDC8nt1rH1696rjpdBQMF8YU1xlMozmeYNooGcZ/AMby88f8AW7Pd1Z7zLTx+PCsSzb3cH94xmnbtBIwP/d227Sz369GiffI00fW1jtH2564PsRi5uo9nbvSH0A5vz2O9/udQfMJruSMK/R7u90uIVgClqgREBCdhsymOWEceA6CiaqymAYx0QpgEFha12F7vIYImqWaPPT9YALFbgrheAjiEzK6oK/xdkEAosSCplvjSZIFdmCql0ey8ydDPEF30lSbLxkzxQWdMfePKNqldvvS+cRtUMSwVtPNbTbbgjK7D7Od7Oz0cLAT97JYmK4XRekxT0OnkW/meTK92XP7KuuFK/3YQEWOzwMneiCuMKF9zg/BcuI5gaVrpGrKBkQYhFrgUmKH8qymGhyYUNVUHfwety2kbFFSgIqPqOwrwgA8ssbI7deepq+BkJudr9ZS1QxrNBkFmPeBpti4yOzs7dLEqgmy9ir5BpRlEVBvEV7nXy6W9+3+CdeIYEz5e2570S33Y3M/xdM+Hu2Rv0AKWHveLtlkk25XCaFC28x73BIInMNH6cedyMIt6LE5cKElmd1lbjFAPpseCgksQLJ2gby4h8IosBJVZKckyHBhhwMTS/Ci0LrCKi7triQKaxc3PRl18DvnmT8+w41Dral9wOJ2s5O10nD7jdHIP9v+GYGwARbbo3meZ02pJKivgcHI+l4eeffjCFkuHB7fP79/vw9X7Q/r8P2Apz1FkNvH04isdWQ2kDJaq1Ew8kYNvevIjYl3yMEXA5bo8FH68ZRaWBA86AalnWF6cCivsG5K0Z86F28XhAtlxpgpTBOJjVItAj8iSE/pcmAWdUmqO9Z4vQ78GCYt6UHi2qnb13pNfRK57mR6QdiV5cuUeu9aLwlCqba8rsfJWVd7cs3x5w8I6bqEtKOWXgEDkiBTraeJnZ6pfa4+xhn0BNll9RHHxML2wgzDcNFYnYdrs9+nruL0nEHcUJSW05NFUV+YLbUuUvYuGAO1LWQlggVFJLUYHxyWV1jvYKKC+cEAITVR3AUuC+AC4SXCMGCoI/aUPt8DD6rIc1WtEbbBF4kibuvSHl77AgKuoJqdYbulNhVFb5ac0BzoJYklv3LNcBRRkmUKflp/oNTfkP9Kqvjij2R/nnmZj1F09iErQPE+XiziD1DbHBAOgxglKYwHXRT4brePVI70KaO84iIUQ2MBFTlLlXu/RgkN8cDrIQ7HhY9QcOJtbEidlDcOgI4w/UEFnSnvL74wyvwGTKNCSRfJH7GOsj8aUg2/KKI/G5pYx/+Jsg6ZMzSJJWJMIgWht7dylUYH1l95+/K/L29lZEK89hUwp+Li2OLgY1VsPGDJxOzFAMl/gR/wnE6g4Cx1PFakSvRW+AfrKfWaKDQVVHsOzPtveouOmBSR3/f5LqPo6uyDWecK6dHgE0hgNNxCjR0CRvgNmCr7IbCp1+h/BJWsi/YOMgMTcwdDBzAyqMKzMWJQpVKpUm/At4hECNLlSg04aS815lzgAmBiSvv44vXQ/AXMHmfB1iDI6nQ43QUqrxoPYTUGjNPtf+XAUOCn2pymgGZGkZ/vuViOY2L7/Fh6IAQOwYIi0JMp4BPUuH26IYjMExj6CSMNBwY4sLAjU1GEjbHVDLSaLL7EWSdSaygTFHhXXr3KZeCEd5Vf2fXpg7oPySutuMICoz1g4mshBg36PgYIo8TWZA5wwWOVNKoiRJgqMUY2/gbmfiDCEC6U+bPJM8EhS5ITsUpETyKmj9rvAc2+KAKGVjTlapWgkciXuoXG4FuJA4OPU3+tpugfWlqpAttZsUuSCBaiF8bu7e0NXVss9oFlNlja6+R7DhmPMeCDRWwSRPvF8+Ah9kllaDlElw0NadEyzFh+4N4GoDHHhdgqasi9yyUfpUPOCiL3IrSq81Nr20VtNwl1TscFLdWoCOg9lGEZDGTviPesgiGiKhvL34EBKICtVmJ7KYH2L4SLKjF2aU2WlvGkJJo5kEQeQAWW9Tq9ku1JSXFETTaEV6PUYWqyH5jhoL8wmbCQmLClENUWElzAs1SgcLJCG0JHMYNRZqdZLHFcyjhVUUPuXRaV4Baxhsi9iHApAtyK7Vwp+fMdJb4GBAzPu3SDakkscCmAKWnN5V+/A1OR1Hq5TsDIz+Um5ogAI0HWNJUxo1pjLOkOg0mSjBZl8KxSKX/BAX1oD6F+vgSG7Zuuc8+2GmykGv2VZXa7dOFOT4H1AJul3lhP/FAx9OVSCX3fdrM0Ga1oJ1Iv94buValpPYBYlEiPFpUMFngRcGGawuaUEkGh5KTjtIYFcf7hRk9gKv8Ghigg1XWEfaeqQlqQFFoNHc8fL6yWibZQZEEyzOG6X6vgG6kxHiZo/9kkrJPYfFGv7tWoSBjP5sscMyQLMqcIqfd3l7SwEc7f7wd3AKV1up0otVq9VktvYyai4wSUUZzOxE7GyfY2R4SUahVlPLHvnqkptJ/nwMyfsFBHPBFfVoXZmSTu8YCtXFrM/yHm3X+6Ee3iCsZgPuTmc5RIjKUFTN+dWbT1VnXEcbtjlIRSXQpHU1Otl1RpgASZRCey8pJ1SjLLtfNtppHYaOvJDFcqaTD4l640hvTt0Rwfh89vX7O9uTcP35Dmv826/eXq/vPz53u0UPTY3mbp8X7sGEqvH+y8zN0e73nWxV00s06yPW7yBgHDNeYPm4ILYws5NN8/QWVJTWI+rF0ScZ39fUPn4UMVeUgh0eXAMPf5l/g6I3c6SuzHWEB1Th7z7fw2UVXRse/552HWksSWmyGUP/IxRMYYunN3Yh/vt6yLQRLdTmbjSvuCYTRfasyQ7Ae/fkO/+fqO4T99pzX152e8bHz+3ByQ7jNd78zT7dw7bmxFacaJvYlstKB859SkapgnM+9wO457jt7qFvuYrGAL4cL3T0+1BTRoit0WR0Tp0d6FtvnApQCkUn+6Erky7LoAZkGTtIZkZW6SR4j+5gZRyfZuS1Hd3u3tZvOYqGI7cdF3H16K+Lf8P6PW2pyoskULfACCCuILDdICEjsZqjIMTIQxBpKiwMSpmnP//4+5e3ej8cy9VYlfUrEiaVfvx1prbzspwxxOWm7NdneyrNM0jOpopUHF7n9efAGZMipBN1an7PHH0n6vKvjlfWp+f8tKdGf9e3VzjOsclHIwVIeDtN45DokPGRHhkr9HiV/u6mhj6fq8ASZxz6KIG5ZNF8J6gt0OepzJjXscAYmst2C1gluFF0OG8RhG8IwzwXvEArQBkVakqZ8Ph/3x0ffhunaP8rKiW7+MjrEhj8M0LkDcb2RNVm0aeR6Jf1VUg0x6iJKwPvrlBkrRsP+FVHpcJkDhs0P2J1jeDbw/h0P163S6XT+comNWnU6+aX2v/G1aHY6DoWX0NlFGnTipDhsUL0+nPCEQcFMDAqZJpZQzXWa33DBjjrehASu1yHCZeYkyGgsutpOGizFkupzJwfvXwCzhDWmapFD3i3KqDbWXCtRYWVUDeZ4RQuuqinvy6BgX7u5wXADZlVbHXejFyeGXB2VrsjzlxbassxfMz09T6Tvc4WD66wi194+PTfrl9HY6nN4cODvJ6uz99DYDdUiy/JgdbvoQ9KLuZSGpjlEiAl1Q+rSqaVjZQ+hYc/MCTMDkIgjGFcukK2A4DWBk7lxvQRNyf7fVhMxFEyC/nl8kgSypW9tJ89qBLq2Zu8MODvgMxCUIUxodTjeApRtBRB9msgbSWtxnfl7tdkRsA+oSVN44zmwN5ZX2FWCWCxed2WwAPXphzt5Pv8rv0KVVs/zz5+2fQrWsnu6Wp3dITsswoEuOvNDPZnIbz97V7arKHFEw1hcek2LA7Pd8egfAoLgYnF+MRa+5/pQYy1UahtI6I9MA02gC8z8fwLSfKC3LbUfpiJp0W2ZHcgt/pcjp4fB+stEJFYP6BAgJQIo63e4yCP3DszzBojURA+gfTkcRQOh9BZglFMMn7/l2cI8y0bQGD7f3Io40e/PV+GUENBFaY38wMoEAQKUECtVWVF3E8yOx6HbV0b0kaQYQmSZiCsdDy6WZV0HEXAPD9PkaVdEHl4MnXQHDUulcZfq9D2CQphlPI1VAXSjI7f5iLk6Q1ba029FywQ6kyPePawUnb/D89qQ1VAWku+iqTyb9u3WrJQnAAT5PJQzuhYmzOnO+YNoZKOhQxZclYr0TmQLRQCsKfT4CBdnB75XRMUa12wqqyAswTDQ2VtT4OpWQ193jPoJqXJUVljxN7W1qzFlGQpVpgFl2GXpI69sN4Yf/3ObUh5HalsJEUrfFBm+oRvksE3DpKkwp/fz9+yeoSCgyXwQG6BZyLXZmFdcrODCAAuiRHooYpJco8uF3ztq77NyMp07aPX2ua6J1BsYG1YjT+fH17J/P4xmvQ13RrHkwJ4Ahc1V8m4DhKrK/vkiCJvOaNDvTHvwFwEBXiBmiABqaMQhMoxsxJjkwk85QNyRF+xowbCKM4YL6Wdcty4ByC/CAPEKl1jMAIeZPd1Ci8H/IiSkrDd07J0ko9QbDM49xNqwbcX30xJ0dHi73ZkPqLO5wMV03YVHSEF4uBf5PxNwp3IxR0J5iAcOAQYAk5rvgWBI3IDrNUJtFNns8ezpIgsk8SIuYBHO5N/wMmFe2QgCYYBaZOiY/JM5QR9XY7FcwJ0hko2L0zUT+jdo8buWuFtDC3YZ+7T/oc74G4u0ZLg/cAXvktgXzcs7ETregaVyAYUfHb9kAfrZd/lVj0PPFMygyCwqZXU+72xHlD64sM1gkeIbMDDy2MHF++qT7TF07pdSnt+KntgMHhsc3O7c6RG/Dgp/AmzWmWHHrROsYi6WONwjVBtSr3EaLEG0Or06ShJS45fLYbDsESHdfnrgO4Lsb5pn8M2anqsZ5ANuETPfjdelJGDAfXekR2zdzLZH5IDhd/KQsIDDtppvBB2SlPx+oCpwODvrz96Q7+dlibLo1q4EbJmVMtmTwBR7DNnHwqEDQTMBDXE6ng77GLR+4NoEZQNbYpTg7wmBtC6+U3ECXgOSSRhHBUTVJakI3DTDPrw15ucTKGtm/YWDtYuNXw/g7Yv4HmcYNv/CYR5nVDwwrCT1cqLjqaLRW2pLEF0YmWFY1TXyxw5De9BRErjslZDVv4d+0BkeSOq67LWiazD4FZoz3ea/fjWdTdP11w/J2vu+7cwGN9fl4upa0odEzZk6y9cqjB41K6cflPnDrZzyf5pSx7bmuW+/IthhwYG7GlxYND0e5qKIJhaFnGOf9p79qzN/AMDdbu2K+d3AnQkex7h4eJQWvRFrVhMSODuHQnlhPTwa0KIBy5STEOwKPg7el7fF5Y/sbVon2JXH2oGzDMrU9/TM/ZrxYgHSZphQehXscQwfoNalLX4cUmpV1tJtB9xanSe4USb2LR4rcHVPPCcPd24sAdTkNaeo5eVH7wNZvOTCvbPuHmy7MsWxcKKhQ+BOHjJr4V1dSlO6VemQ6AbPYUPXBOWLgnc5i7xJ/LwJIyk2Zpin1QwM+Nw5BBt10IEpu09xJk7oKb0E3PtHAozR6myoQSg4l7n6TOpQCMV9UnwOzmE+TbVoU/srQrUGW12WUxeWN1g8yn5Tv71Og0LjNQGt6zG/gLlebOonr3emgQvFx4jDxnNQta3jGCwPm2/iJudusOfMkYqoI98E0rdNMRoR/8RjehRoejOHCl8Vwga4BZoQrQosAxel2KgmyVRcU5CvxbxRltQu3/uF92pY7IL5tWtJdPoOHj2dhSvzo9G51tM5zToo9qFAau15wd/i0XQMwdlnHru3nqjocZ26NHcZ3RbOqcz/LKtLrq7nr2XEakzzodC13s/U8/5i9j4BBTlNieyB5j8QubB4x36YNLqbJ98KwXJ3xuAxHOg0y7SvdKF1kNZr+yBrWpt5MIkcQZMIryd3NLCkA3h8RBAMFgV1I/ahO6G5XxYIkFPbGJmkcbz25JTjPyWZPy+w06gjSyE6gXW6CEDdVB18B5j6Ab7VNw9hUh9MqsRM/8ktXMCsCqr7KalXsJ7Eb5lm0LQLI8jB/nc02ZVb96A0100vt1HUcCoXN4zXm2wsyXWZG6U11ucjFjnzhbp1r4ciHAuc/wk0HzCL2+YbgjeA9YRq7e8dLEkuQH7MiKMIy9Aupt8vzOMyy0pAkO7bhpBkpABiNkPFqNauzDIBRhjM7sL3nWeE8BzP98+KLqURjiJg4BaI+qMp058fhAcS5H5G6zo5JrydPI7rNjzEtXuBuH/xXt7B3GTH+y7iVNqeKbdECQRAEJwKiTDIcQdt6EuUqaXIFU3a0qv//7+m9z8GYvu/W831JZSgJLPaw1t7rKJAiRkmioiyJ6/om60p/bLHwzhhpsUcKkxESY2yMr3YpbWZ0lFVf9td2M4uNEH1zuMHS1Acwfb1pGnIq3REnq6/X8Laps0+z26tfgxjutOZFYfe6T+vXLC4NYDa7Te670e24x+VDd+lblhv5TkKq9+cEDyJ+tgrrfVhGxkhVeet4/BlvLvGoL23/PF4+j5czp/U19xa8vkLm8lAIhINVpPvyjfRxW2F7rl8GIdyA0Y42/9iuVjrdn7GA4XFBeueyTDh2v3Tjg+ExQse1WYQuVGZ8UBgw73AdRT25DYmsdyjEPeN2+Rln14smdVZ/vt0+3y4mFF+JvO6Pb/FbpnVArOheCal+i/APgnxOLBKSilRne/RcEkDnWOgfvpscgK0A7zI2t+xWDEVgYM41uGVLGZJb4oz081Z4/Q4VeKpJPl8PCo9JIg/GHtCDyNkNJy0w7/eAafvRd2Aeglq6r3oYw2sVAM8MuiriMqD6g2/9MVSn2UurcqYy9OWegFbaS6p2gcgZ1/qyWaLI6nTN4vMtdfov8F86L8rydDzO5R7Vn73Z1iLklM+hqP9vYP76y0Q5oCogAG0kDbge5yf6RIb+Box6NJvI1BwgdwXeHklUv9PdIzecgPBWFHQfy+p0NZ8CDZoxYP6DwLRTOpvZo/4LGIF+/536titZaHQjpMaIC83Arvit+MJ9SJqMCz6cKUjqVIXHBfL2wq8XvRfqh3h5kRWlh0JAoMD3NBuYOrJjUObyYLIe8rw6UZ9FDAADTAMknUgZLsSuSF2iEt1qCvSGqTjptd2D1glaKZjlQEPhjTNIdTHVp1/A4FiXslymuO4L6W8R02NM/iuVJDbjRbNAGy/tYEJi5sQdBeY+8RBxSf+CepkKIQGZr9CKRfglXhETVmg5MfuP9LOSqNmL6eJpxExACNg4TZPF1jEsftkomJGBqWg2xO/ij1TW0yqJyAAvhs+N1MUaBPrfbSqxnS7iMmLF996V2l1At8vIXItMq0npKhFtHQjNgGcM8H76BCQBpDQVzLiYx+t12cti0xYcPHSoDr1PSFuxfv8RoEdA+4q9gGd+GjHITW3N1nf6pK+hjqGtlYYJ3YQ/xtOUm3bZHuxhYcGpBK2UEwBm/XdbfL8Dg6t/aliW2ACnpbdtSrVDO6qMuT7r0yiqbA3FMc5QWmc4JXhQQYez4aDbRUEps/UwZAxe7YUuYGlwdNhVWaC037+0GpMf4S559n8AM5suRjtSpnXjTFE6ajSZ6PCwL/ZEfWuYK0VgyMCtYnyirsZsEhVFlDX6flWQoNPWof8LMAN27uE+9255zH1zj9Cw4SZrSTzN6JGtcDQ4HmcJdhzwmN7E8d3QN1SBxgyOFWhHgzLTXS/P5znPkOmwso6Jhuj+ELAOocZE8YWx/RQYA4AZmhUQaVLWiQrwiI8AAAgCSURBVM7D6+VlZBUCygt5kUdR0Oybd5pBILYnRlItAS9I8aFBQrfaDehUC97x5AuY8+FbjbFpb7kDQ60/0qMGt7KxlUdURGnU5oKHLCgud2DG6IOa5w6JnKhxFl1MTgFj5AeUVkkYmEmSNkH53u2wQFTPJ2sMBRkg4pdWRDwdjTHop8FquH4KzExfn6PEckgSlollDwbwWlYkMXQR8nHkRFUVlpumMSgv5fKyqbNNM5KBeSaR64OIN9DFNJqsdvp6egdm9+hKqvoLMIzF3ed1bdG666cvYAZ9qfvv80pjbtDXcf7leInvfPAypNrLujqZ014HgtcgwN6auAlzGofdcxgWwT4ENtOZgg5ISOhvOWii2nA+nsMr/Pk8lWYWSU7OKfFPVqJrA6C5cR03xBFl0WxAkkVp0BB/KMErWgZZWGRvP11e1qMw8oOiaEp9oa6tJksbZzVkwJj0RADjMeqXj+GxE+EeJhgaKmwcSXHBSQMevlLYQa5vJ9wOkAdnes7OO30Y3hQ+KIyzYtMkniR0x9T6WAZNEg0FqD3zArRb8PrpysKwikBUhy7xJwNFtco4SKvd4ikwM/1AooRYyQnwibaKwk3rJorCrDakQeKnpe+6gW+RgyRKkzKryyKOL7cxZ0XAfoPrpQzeh5Nkk11AtyVtxBjLHXWO0akd0leODWK/lkX9Rw2WqAGT2XrRPEdFkqoCnxL+ffTvwGlq7uWe+ZEbjmeNJblrl2GS+PvC6IgOFgM/CoDwH6AaKy6Oz0BjXneCkYRNWgYbv9lpthXHb/F1706fzmP0+cH1iWM4DgmixFRsLYE6XO0vNehrTDE3dIvKs3aQPV4apU1RZPtrPiJumTTxJi4DU82zTQki9FKO2WHR/P1LXdMhMjId2uHbtSP/zWiHewA2o+m3e2xatH4HjGJ7zoe5O5uea3nvEicB33ed9Fq44sDyDIv4fnnKPQTGLE+hGzZBneWyRVwrCtLaD7f8dn9Ng/Tytt9+PgdmZVWVYeaVFfnVHMpl6DrX6+ulSdVF4jjAoUkYnj50uS/nAaRq3WRxth2CUHUrcr245WEYFummiOtjcWbAeK05CIeakyGbUnHcvcVDSvTFb+Gj4Q6i3e1rqAdAVf8emMG7aexWY8PwrI8pAE18I4sv17AYaVYOGVadXNcxpgDMMrWsqPHrrF5yFjnBcwTZyde1KE2v9S37mRnPgdF1k7pMrQ+LOLg5TUovvhzfynLALZ0qcS2niizTBmDWpU/C1C3icqg4URnvwyj0o+GwCvx9GRT7wGTAOCab4OmtK3jEHp27G+G/OVa5PkOFtosBdcmiLfY3wKzkfn+GjunleWl6pgZ9MQ/NfXw7NiUvrACsyPuwEmerdHodxSWnqCHuPlR65skPSuLAQyq8t3ezegNS/OMZMKY+1w/JKfQT+JKs7KGqzFNrH18umSnLo9zxT+9J6lhzLJk9owkb12/Cg8iNEygydZM0pqouswKiNqiv4y9g2CoJd77rduL7GGoyHnw3rIKSwt8hLq0amKzx5N+vxXcu89rIPFuOkZunfC1xnDQM83IfX4OtIEjbPLHGVuo5OlQu4ccYApokPtE7nalnQWUmeQINf56l5T7bZMft2/NU0qfjqoG27IZjLHu2eChKx2+8vsxJ6hmCyWqSJQfaSezJTpG6ZT2W+6Jm/NPOufWmDQRRuME2YMc2BNvcXJLSKk2FKyU0aiIqpASIKvWV//9jMmdmAYeqQnnu+Z6IjMiyrMdz5iam/vl5sYFF2Kwmi9Xq03X3cCvtN8Y1rI1cmgoWJThYGNxXrtHETktX/HWRtcnZ8eP6EWXL4nJd5vnH66GqJS+7muTLyTz0/CLobcQyf37qtXy4wUUfpVWLWeF7zd58I57Fl7t2HCX5avJNrORk+uuUVtIixHR9uVz2s0RrnBIEEgY9PfStdna3yWej0JI6Yat8+ppX4inFQXy/vBrMZ0kH/l2+WC0m89TCP2ZjZm5fLKl0rsVTWpobxfUwXmwtOLGmEBDiRZnotObf7Ry8Uhy8uJ2kN3n+2PAsK1mE4/68VFlQeBe9vJ8mIi98dXuzy6e7c/jBnlflg/7N1G8hTLL+uRAfv7w4MY/o93qsaSUomqChidmOqDeEpVFhgoIBz2qr24i4QRKEKI+M8cSN4aAkCEB2kvMsrbLUikRfNm82ZtfkqFVlEQLA/96Y7hT7MuzW/Lv9rdTCwyyE9/ZQuACxmCG02WJNppWgAXzP8vcPprhVbWvTaZBACY4y8STKxo8TJ2ZdWeZnlKjh60SilbVwBamrINi1qsIquOZm02JnAbxZbSiy4ILcBMPUcxtzyJ6gSFhPDHY8UgubHE5M2GqbE2O6WpMCyOTWbe9+Y0KTrqHFEGQdTS3twKFoqky0PXKK3UlKz7ceZe0hUImKZpDxzP9zMoKnVXH4BqI51SmbolkTzgT0gZiARqSlDzocAJ+M/m71aeW5Wmn5QoXBCePyvvTMxgxyl6CdWd23PbkzN5tiWqu906CUC8DIxWqstWjlULuL3Vds7iRBpBoqES2JIgz5cVwuBgcbIQU5f1qF4Gy79lbI0T7TYIF1pst/wUp7j8UJ4/vh5bY2deR4+MgWs0reMYnkdmtjUt4MNHnfVJP927fHY1K+20qwou3+ev1tttbDNXtV++PvlRJCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQgghhBBCCCGEEEIIIYQQQggh5D/jFZY9MFsLtJLFAAAAAElFTkSuQmCC)

Use rolling-ball algorithm for estimating background intensity

## unsupervised_wiener

`skimage.restoration.unsupervised_wiener(image, psf, reg=None,
user_params=None, is_real=True, clip=True)` [source]

    
Unsupervised Wiener-Hunt deconvolution.

Return the deconvolution with a Wiener-Hunt approach, where the
hyperparameters are automatically estimated. The algorithm is a stochastic
iterative process (Gibbs sampler) described in the reference below. See also
`wiener` function.

Parameters

    
`image(M, N) ndarray`

    
The input degraded image.

`psfndarray`

    
The impulse response (input image’s space) or the transfer function (Fourier
space). Both are accepted. The transfer function is automatically recognized
as being complex (`np.iscomplexobj(psf)`).

`regndarray, optional`

    
The regularisation operator. The Laplacian by default. It can be an impulse
response or a transfer function, as for the psf.

`user_paramsdict, optional`

    
Dictionary of parameters for the Gibbs sampler. See below.

`clipboolean, optional`

    
True by default. If true, pixel values of the result above 1 or under -1 are
thresholded for skimage pipeline compatibility.

Returns

    
`x_postmean(M, N) ndarray`

    
The deconvolved image (the posterior mean).

`chainsdict`

    
The keys `noise` and `prior` contain the chain list of noise and prior
precision respectively.

Other Parameters

    
The keys of ``user_params`` are:

`thresholdfloat`

    
The stopping criterion: the norm of the difference between to successive
approximated solution (empirical mean of object samples, see Notes section).
1e-4 by default.

`burninint`

    
The number of sample to ignore to start computation of the mean. 15 by
default.

`min_iterint`

    
The minimum number of iterations. 30 by default.

`max_iterint`

    
The maximum number of iterations if `threshold` is not satisfied. 200 by
default.

`callbackcallable (None by default)`

    
A user provided callable to which is passed, if the function exists, the
current image sample for whatever purpose. The user can store the sample, or
compute other moments than the mean. It has no influence on the algorithm
execution and is only for inspection.

#### Notes

The estimated image is design as the posterior mean of a probability law (from
a Bayesian analysis). The mean is defined as a sum over all the possible
images weighted by their respective probability. Given the size of the
problem, the exact sum is not tractable. This algorithm use of MCMC to draw
image under the posterior law. The practical idea is to only draw highly
probable images since they have the biggest contribution to the mean. At the
opposite, the less probable images are drawn less often since their
contribution is low. Finally the empirical mean of these samples give us an
estimation of the mean, and an exact computation with an infinite sample set.

#### References

`1`

    
François Orieux, Jean-François Giovannelli, and Thomas Rodet, “Bayesian
estimation of regularization and point spread function parameters for Wiener-
Hunt deconvolution”, J. Opt. Soc. Am. A 27, 1593-1607 (2010)

https://www.osapublishing.org/josaa/abstract.cfm?URI=josaa-27-7-1593

http://research.orieux.fr/files/papers/OGR-JOSA10.pdf

#### Examples

    
    >>> from skimage import color, data, restoration
    >>> img = color.rgb2gray(data.astronaut())
    >>> from scipy.signal import convolve2d
    >>> psf = np.ones((5, 5)) / 25
    >>> img = convolve2d(img, psf, 'same')
    >>> img += 0.1 * img.std() * np.random.standard_normal(img.shape)
    >>> deconvolved_img = restoration.unsupervised_wiener(img, psf)
    
## unwrap_phase

`skimage.restoration.unwrap_phase(image, wrap_around=False, seed=None)`
[source]

    
Recover the original from a wrapped phase image.

From an image wrapped to lie in the interval [-pi, pi), recover the original,
unwrapped image.

Parameters

    
`image1D, 2D or 3D ndarray of floats, optionally a masked array`

    
The values should be in the range [-pi, pi). If a masked array is provided,
the masked entries will not be changed, and their values will not be used to
guide the unwrapping of neighboring, unmasked values. Masked 1D arrays are not
allowed, and will raise a `ValueError`.

`wrap_aroundbool or sequence of bool, optional`

    
When an element of the sequence is `True`, the unwrapping process will regard
the edges along the corresponding axis of the image to be connected and use
this connectivity to guide the phase unwrapping process. If only a single
boolean is given, it will apply to all axes. Wrap around is not supported for
1D arrays.

`seedint, optional`

    
Unwrapping 2D or 3D images uses random initialization. This sets the seed of
the PRNG to achieve deterministic behavior.

Returns

    
`image_unwrappedarray_like, double`

    
Unwrapped image of the same shape as the input. If the input `image` was a
masked array, the mask will be preserved.

Raises

    
ValueError

    
If called with a masked 1D array or called with a 1D array and
`wrap_around=True`.

#### References

`1`

    
Miguel Arevallilo Herraez, David R. Burton, Michael J. Lalor, and Munther A.
Gdeisat, “Fast two-dimensional phase-unwrapping algorithm based on sorting by
reliability following a noncontinuous path”, Journal Applied Optics, Vol. 41,
No. 35 (2002) 7437,

`2`

    
Abdul-Rahman, H., Gdeisat, M., Burton, D., & Lalor, M., “Fast three-
dimensional phase-unwrapping algorithm based on sorting by reliability
following a non-continuous path. In W. Osten, C. Gorecki, & E. L. Novak
(Eds.), Optical Metrology (2005) 32–40, International Society for Optics and
Photonics.

#### Examples

    
    >>> c0, c1 = np.ogrid[-1:1:128j, -1:1:128j]
    >>> image = 12 * np.pi * np.exp(-(c0**2 + c1**2))
    >>> image_wrapped = np.angle(np.exp(1j * image))
    >>> image_unwrapped = unwrap_phase(image_wrapped)
    >>> np.std(image_unwrapped - image) < 1e-6   # A constant offset is normal
    True
    
### Examples using `skimage.restoration.unwrap_phase`

![Phase
Unwrapping](data:image/png;base64,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)

Phase Unwrapping

## wiener

`skimage.restoration.wiener(image, psf, balance, reg=None, is_real=True,
clip=True)` [source]

    
Wiener-Hunt deconvolution

Return the deconvolution with a Wiener-Hunt approach (i.e. with Fourier
diagonalisation).

Parameters

    
`image(M, N) ndarray`

    
Input degraded image

`psfndarray`

    
Point Spread Function. This is assumed to be the impulse response (input image
space) if the data-type is real, or the transfer function (Fourier space) if
the data-type is complex. There is no constraints on the shape of the impulse
response. The transfer function must be of shape `(M, N)` if `is_real is
True`, `(M, N // 2 + 1)` otherwise (see `np.fft.rfftn`).

`balancefloat`

    
The regularisation parameter value that tunes the balance between the data
adequacy that improve frequency restoration and the prior adequacy that reduce
frequency restoration (to avoid noise artifacts).

`regndarray, optional`

    
The regularisation operator. The Laplacian by default. It can be an impulse
response or a transfer function, as for the psf. Shape constraint is the same
as for the `psf` parameter.

`is_realboolean, optional`

    
True by default. Specify if `psf` and `reg` are provided with hermitian
hypothesis, that is only half of the frequency plane is provided (due to the
redundancy of Fourier transform of real signal). It’s apply only if `psf`
and/or `reg` are provided as transfer function. For the hermitian property see
`uft` module or `np.fft.rfftn`.

`clipboolean, optional`

    
True by default. If True, pixel values of the result above 1 or under -1 are
thresholded for skimage pipeline compatibility.

Returns

    
`im_deconv(M, N) ndarray`

    
The deconvolved image.

#### Notes

This function applies the Wiener filter to a noisy and degraded image by an
impulse response (or PSF). If the data model is

\\[y = Hx + n\\]

where \\(n\\) is noise, \\(H\\) the PSF and \\(x\\) the unknown original
image, the Wiener filter is

\\[\hat x = F^\dagger (|\Lambda_H|^2 + \lambda |\Lambda_D|^2)
\Lambda_H^\dagger F y\\]

where \\(F\\) and \\(F^\dagger\\) are the Fourier and inverse Fourier
transforms respectively, \\(\Lambda_H\\) the transfer function (or the Fourier
transform of the PSF, see [Hunt] below) and \\(\Lambda_D\\) the filter to
penalize the restored image frequencies (Laplacian by default, that is
penalization of high frequency). The parameter \\(\lambda\\) tunes the balance
between the data (that tends to increase high frequency, even those coming
from noise), and the regularization.

These methods are then specific to a prior model. Consequently, the
application or the true image nature must corresponds to the prior model. By
default, the prior model (Laplacian) introduce image smoothness or pixel
correlation. It can also be interpreted as high-frequency penalization to
compensate the instability of the solution with respect to the data (sometimes
called noise amplification or “explosive” solution).

Finally, the use of Fourier space implies a circulant property of \\(H\\), see
[Hunt].

#### References

`1`

    
François Orieux, Jean-François Giovannelli, and Thomas Rodet, “Bayesian
estimation of regularization and point spread function parameters for Wiener-
Hunt deconvolution”, J. Opt. Soc. Am. A 27, 1593-1607 (2010)

https://www.osapublishing.org/josaa/abstract.cfm?URI=josaa-27-7-1593

http://research.orieux.fr/files/papers/OGR-JOSA10.pdf

`2`

    
B. R. Hunt “A matrix theory proof of the discrete convolution theorem”, IEEE
Trans. on Audio and Electroacoustics, vol. au-19, no. 4, pp. 285-288, dec.
1971

#### Examples

    
    >>> from skimage import color, data, restoration
    >>> img = color.rgb2gray(data.astronaut())
    >>> from scipy.signal import convolve2d
    >>> psf = np.ones((5, 5)) / 25
    >>> img = convolve2d(img, psf, 'same')
    >>> img += 0.1 * img.std() * np.random.standard_normal(img.shape)
    >>> deconvolved_img = restoration.wiener(img, psf, 1100)
    
© 2019 the scikit-image team  
Licensed under the BSD 3-clause License.  
https://scikit-image.org/docs/0.18.x/api/skimage.restoration.html

  *[ISP]: Internet Service Provider
  *[LIFO]: last-in, first-out
  *[FIFO]: first-in, first-out

