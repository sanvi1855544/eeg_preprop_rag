# 6.3. Preprocessing data

The `sklearn.preprocessing` package provides several common utility functions
and transformer classes to change raw feature vectors into a representation
that is more suitable for the downstream estimators.

In general, learning algorithms benefit from standardization of the data set.
If some outliers are present in the set, robust scalers or transformers are
more appropriate. The behaviors of the different scalers, transformers, and
normalizers on a dataset containing marginal outliers is highlighted in
Compare the effect of different scalers on data with outliers.

##  6.3.1. Standardization, or mean removal and variance scaling

Standardization of datasets is a common requirement for many machine learning
estimators implemented in scikit-learn; they might behave badly if the
individual features do not more or less look like standard normally
distributed data: Gaussian with zero mean and unit variance.

In practice we often ignore the shape of the distribution and just transform
the data to center it by removing the mean value of each feature, then scale
it by dividing non-constant features by their standard deviation.

For instance, many elements used in the objective function of a learning
algorithm (such as the RBF kernel of Support Vector Machines or the l1 and l2
regularizers of linear models) assume that all features are centered around
zero and have variance in the same order. If a feature has a variance that is
orders of magnitude larger than others, it might dominate the objective
function and make the estimator unable to learn from other features correctly
as expected.

The `preprocessing` module provides the `StandardScaler` utility class, which
is a quick and easy way to perform the following operation on an array-like
dataset:

    
    >>> from sklearn import preprocessing
    >>> import numpy as np
    >>> X_train = np.array([[ 1., -1.,  2.],
    ...                     [ 2.,  0.,  0.],
    ...                     [ 0.,  1., -1.]])
    >>> scaler = preprocessing.StandardScaler().fit(X_train)
    >>> scaler
    StandardScaler()
    
    >>> scaler.mean_
    array([1. ..., 0. ..., 0.33...])
    
    >>> scaler.scale_
    array([0.81..., 0.81..., 1.24...])
    
    >>> X_scaled = scaler.transform(X_train)
    >>> X_scaled
    array([[ 0.  ..., -1.22...,  1.33...],
           [ 1.22...,  0.  ..., -0.26...],
           [-1.22...,  1.22..., -1.06...]])
    
Scaled data has zero mean and unit variance:

    
    >>> X_scaled.mean(axis=0)
    array([0., 0., 0.])
    
    >>> X_scaled.std(axis=0)
    array([1., 1., 1.])
    
This class implements the `Transformer` API to compute the mean and standard
deviation on a training set so as to be able to later re-apply the same
transformation on the testing set. This class is hence suitable for use in the
early steps of a `Pipeline`:

    
    >>> from sklearn.datasets import make_classification
    >>> from sklearn.linear_model import LogisticRegression
    >>> from sklearn.model_selection import train_test_split
    >>> from sklearn.pipeline import make_pipeline
    >>> from sklearn.preprocessing import StandardScaler
    
    >>> X, y = make_classification(random_state=42)
    >>> X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=42)
    >>> pipe = make_pipeline(StandardScaler(), LogisticRegression())
    >>> pipe.fit(X_train, y_train)  # apply scaling on training data
    Pipeline(steps=[('standardscaler', StandardScaler()),
                    ('logisticregression', LogisticRegression())])
    
    >>> pipe.score(X_test, y_test)  # apply scaling on testing data, without leaking training data.
    0.96
    
It is possible to disable either centering or scaling by either passing
`with_mean=False` or `with_std=False` to the constructor of `StandardScaler`.

###  6.3.1.1. Scaling features to a range

An alternative standardization is scaling features to lie between a given
minimum and maximum value, often between zero and one, or so that the maximum
absolute value of each feature is scaled to unit size. This can be achieved
using `MinMaxScaler` or `MaxAbsScaler`, respectively.

The motivation to use this scaling include robustness to very small standard
deviations of features and preserving zero entries in sparse data.

Here is an example to scale a toy data matrix to the `[0, 1]` range:

    
    >>> X_train = np.array([[ 1., -1.,  2.],
    ...                     [ 2.,  0.,  0.],
    ...                     [ 0.,  1., -1.]])
    ...
    >>> min_max_scaler = preprocessing.MinMaxScaler()
    >>> X_train_minmax = min_max_scaler.fit_transform(X_train)
    >>> X_train_minmax
    array([[0.5       , 0.        , 1.        ],
           [1.        , 0.5       , 0.33333333],
           [0.        , 1.        , 0.        ]])
    
The same instance of the transformer can then be applied to some new test data
unseen during the fit call: the same scaling and shifting operations will be
applied to be consistent with the transformation performed on the train data:

    
    >>> X_test = np.array([[-3., -1.,  4.]])
    >>> X_test_minmax = min_max_scaler.transform(X_test)
    >>> X_test_minmax
    array([[-1.5       ,  0.        ,  1.66666667]])
    
It is possible to introspect the scaler attributes to find about the exact
nature of the transformation learned on the training data:

    
    >>> min_max_scaler.scale_
    array([0.5       , 0.5       , 0.33...])
    
    >>> min_max_scaler.min_
    array([0.        , 0.5       , 0.33...])
    
If `MinMaxScaler` is given an explicit `feature_range=(min, max)` the full
formula is:

    
    X_std = (X - X.min(axis=0)) / (X.max(axis=0) - X.min(axis=0))
    
    X_scaled = X_std * (max - min) + min
    
`MaxAbsScaler` works in a very similar fashion, but scales in a way that the
training data lies within the range `[-1, 1]` by dividing through the largest
maximum value in each feature. It is meant for data that is already centered
at zero or sparse data.

Here is how to use the toy data from the previous example with this scaler:

    
    >>> X_train = np.array([[ 1., -1.,  2.],
    ...                     [ 2.,  0.,  0.],
    ...                     [ 0.,  1., -1.]])
    ...
    >>> max_abs_scaler = preprocessing.MaxAbsScaler()
    >>> X_train_maxabs = max_abs_scaler.fit_transform(X_train)
    >>> X_train_maxabs
    array([[ 0.5, -1. ,  1. ],
           [ 1. ,  0. ,  0. ],
           [ 0. ,  1. , -0.5]])
    >>> X_test = np.array([[ -3., -1.,  4.]])
    >>> X_test_maxabs = max_abs_scaler.transform(X_test)
    >>> X_test_maxabs
    array([[-1.5, -1. ,  2. ]])
    >>> max_abs_scaler.scale_
    array([2.,  1.,  2.])
    
###  6.3.1.2. Scaling sparse data

Centering sparse data would destroy the sparseness structure in the data, and
thus rarely is a sensible thing to do. However, it can make sense to scale
sparse inputs, especially if features are on different scales.

`MaxAbsScaler` was specifically designed for scaling sparse data, and is the
recommended way to go about this. However, `StandardScaler` can accept
`scipy.sparse` matrices as input, as long as `with_mean=False` is explicitly
passed to the constructor. Otherwise a `ValueError` will be raised as silently
centering would break the sparsity and would often crash the execution by
allocating excessive amounts of memory unintentionally. `RobustScaler` cannot
be fitted to sparse inputs, but you can use the `transform` method on sparse
inputs.

Note that the scalers accept both Compressed Sparse Rows and Compressed Sparse
Columns format (see `scipy.sparse.csr_matrix` and `scipy.sparse.csc_matrix`).
Any other sparse input will be converted to the Compressed Sparse Rows
representation. To avoid unnecessary memory copies, it is recommended to
choose the CSR or CSC representation upstream.

Finally, if the centered data is expected to be small enough, explicitly
converting the input to an array using the `toarray` method of sparse matrices
is another option.

###  6.3.1.3. Scaling data with outliers

If your data contains many outliers, scaling using the mean and variance of
the data is likely to not work very well. In these cases, you can use
`RobustScaler` as a drop-in replacement instead. It uses more robust estimates
for the center and range of your data.

References:

Further discussion on the importance of centering and scaling data is
available on this FAQ: Should I normalize/standardize/rescale the data?

Scaling vs Whitening

It is sometimes not enough to center and scale the features independently,
since a downstream model can further make some assumption on the linear
independence of the features.

To address this issue you can use `PCA` with `whiten=True` to further remove
the linear correlation across features.

###  6.3.1.4. Centering kernel matrices

If you have a kernel matrix of a kernel \\(K\\) that computes a dot product in
a feature space defined by function \\(\phi\\), a `KernelCenterer` can
transform the kernel matrix so that it contains inner products in the feature
space defined by \\(\phi\\) followed by removal of the mean in that space.

##  6.3.2. Non-linear transformation

Two types of transformations are available: quantile transforms and power
transforms. Both quantile and power transforms are based on monotonic
transformations of the features and thus preserve the rank of the values along
each feature.

Quantile transforms put all features into the same desired distribution based
on the formula \\(G^{-1}(F(X))\\) where \\(F\\) is the cumulative distribution
function of the feature and \\(G^{-1}\\) the quantile function of the desired
output distribution \\(G\\). This formula is using the two following facts:
(i) if \\(X\\) is a random variable with a continuous cumulative distribution
function \\(F\\) then \\(F(X)\\) is uniformly distributed on \\([0,1]\\); (ii)
if \\(U\\) is a random variable with uniform distribution on \\([0,1]\\) then
\\(G^{-1}(U)\\) has distribution \\(G\\). By performing a rank transformation,
a quantile transform smooths out unusual distributions and is less influenced
by outliers than scaling methods. It does, however, distort correlations and
distances within and across features.

Power transforms are a family of parametric transformations that aim to map
data from any distribution to as close to a Gaussian distribution.

###  6.3.2.1. Mapping to a Uniform distribution

`QuantileTransformer` provides a non-parametric transformation to map the data
to a uniform distribution with values between 0 and 1:

    
    >>> from sklearn.datasets import load_iris
    >>> from sklearn.model_selection import train_test_split
    >>> X, y = load_iris(return_X_y=True)
    >>> X_train, X_test, y_train, y_test = train_test_split(X, y, random_state=0)
    >>> quantile_transformer = preprocessing.QuantileTransformer(random_state=0)
    >>> X_train_trans = quantile_transformer.fit_transform(X_train)
    >>> X_test_trans = quantile_transformer.transform(X_test)
    >>> np.percentile(X_train[:, 0], [0, 25, 50, 75, 100]) 
    array([ 4.3,  5.1,  5.8,  6.5,  7.9])
    
This feature corresponds to the sepal length in cm. Once the quantile
transformation applied, those landmarks approach closely the percentiles
previously defined:

    
    >>> np.percentile(X_train_trans[:, 0], [0, 25, 50, 75, 100])
    ... 
    array([ 0.00... ,  0.24...,  0.49...,  0.73...,  0.99... ])
    
This can be confirmed on a independent testing set with similar remarks:

    
    >>> np.percentile(X_test[:, 0], [0, 25, 50, 75, 100])
    ... 
    array([ 4.4  ,  5.125,  5.75 ,  6.175,  7.3  ])
    >>> np.percentile(X_test_trans[:, 0], [0, 25, 50, 75, 100])
    ... 
    array([ 0.01...,  0.25...,  0.46...,  0.60... ,  0.94...])
    
###  6.3.2.2. Mapping to a Gaussian distribution

In many modeling scenarios, normality of the features in a dataset is
desirable. Power transforms are a family of parametric, monotonic
transformations that aim to map data from any distribution to as close to a
Gaussian distribution as possible in order to stabilize variance and minimize
skewness.

`PowerTransformer` currently provides two such power transformations, the Yeo-
Johnson transform and the Box-Cox transform.

The Yeo-Johnson transform is given by:

\\[\begin{split}x_i^{(\lambda)} = \begin{cases} [(x_i + 1)^\lambda - 1] /
\lambda & \text{if } \lambda \neq 0, x_i \geq 0, \\\\[8pt] \ln{(x_i + 1)} &
\text{if } \lambda = 0, x_i \geq 0 \\\\[8pt] -[(-x_i + 1)^{2 - \lambda} - 1] /
(2 - \lambda) & \text{if } \lambda \neq 2, x_i < 0, \\\\[8pt] - \ln (- x_i +
1) & \text{if } \lambda = 2, x_i < 0 \end{cases}\end{split}\\]

while the Box-Cox transform is given by:

\\[\begin{split}x_i^{(\lambda)} = \begin{cases} \dfrac{x_i^\lambda -
1}{\lambda} & \text{if } \lambda \neq 0, \\\\[8pt] \ln{(x_i)} & \text{if }
\lambda = 0, \end{cases}\end{split}\\]

Box-Cox can only be applied to strictly positive data. In both methods, the
transformation is parameterized by \\(\lambda\\), which is determined through
maximum likelihood estimation. Here is an example of using Box-Cox to map
samples drawn from a lognormal distribution to a normal distribution:

    
    >>> pt = preprocessing.PowerTransformer(method='box-cox', standardize=False)
    >>> X_lognormal = np.random.RandomState(616).lognormal(size=(3, 3))
    >>> X_lognormal
    array([[1.28..., 1.18..., 0.84...],
           [0.94..., 1.60..., 0.38...],
           [1.35..., 0.21..., 1.09...]])
    >>> pt.fit_transform(X_lognormal)
    array([[ 0.49...,  0.17..., -0.15...],
           [-0.05...,  0.58..., -0.57...],
           [ 0.69..., -0.84...,  0.10...]])
    
While the above example sets the `standardize` option to `False`,
`PowerTransformer` will apply zero-mean, unit-variance normalization to the
transformed output by default.

Below are examples of Box-Cox and Yeo-Johnson applied to various probability
distributions. Note that when applied to certain distributions, the power
transforms achieve very Gaussian-like results, but with others, they are
ineffective. This highlights the importance of visualizing the data before and
after transformation.

![../_images/sphx_glr_plot_map_data_to_normal_0011.png](data:image/png;base64,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)

It is also possible to map data to a normal distribution using
`QuantileTransformer` by setting `output_distribution='normal'`. Using the
earlier example with the iris dataset:

    
    >>> quantile_transformer = preprocessing.QuantileTransformer(
    ...     output_distribution='normal', random_state=0)
    >>> X_trans = quantile_transformer.fit_transform(X)
    >>> quantile_transformer.quantiles_
    array([[4.3, 2. , 1. , 0.1],
           [4.4, 2.2, 1.1, 0.1],
           [4.4, 2.2, 1.2, 0.1],
           ...,
           [7.7, 4.1, 6.7, 2.5],
           [7.7, 4.2, 6.7, 2.5],
           [7.9, 4.4, 6.9, 2.5]])
    
Thus the median of the input becomes the mean of the output, centered at 0.
The normal output is clipped so that the input’s minimum and maximum —
corresponding to the 1e-7 and 1 - 1e-7 quantiles respectively — do not become
infinite under the transformation.

##  6.3.3. Normalization

Normalization is the process of scaling individual samples to have unit norm.
This process can be useful if you plan to use a quadratic form such as the
dot-product or any other kernel to quantify the similarity of any pair of
samples.

This assumption is the base of the Vector Space Model often used in text
classification and clustering contexts.

The function `normalize` provides a quick and easy way to perform this
operation on a single array-like dataset, either using the `l1`, `l2`, or
`max` norms:

    
    >>> X = [[ 1., -1.,  2.],
    ...      [ 2.,  0.,  0.],
    ...      [ 0.,  1., -1.]]
    >>> X_normalized = preprocessing.normalize(X, norm='l2')
    
    >>> X_normalized
    array([[ 0.40..., -0.40...,  0.81...],
           [ 1.  ...,  0.  ...,  0.  ...],
           [ 0.  ...,  0.70..., -0.70...]])
    
The `preprocessing` module further provides a utility class `Normalizer` that
implements the same operation using the `Transformer` API (even though the
`fit` method is useless in this case: the class is stateless as this operation
treats samples independently).

This class is hence suitable for use in the early steps of a `Pipeline`:

    
    >>> normalizer = preprocessing.Normalizer().fit(X)  # fit does nothing
    >>> normalizer
    Normalizer()
    
The normalizer instance can then be used on sample vectors as any transformer:

    
    >>> normalizer.transform(X)
    array([[ 0.40..., -0.40...,  0.81...],
           [ 1.  ...,  0.  ...,  0.  ...],
           [ 0.  ...,  0.70..., -0.70...]])
    
    >>> normalizer.transform([[-1.,  1., 0.]])
    array([[-0.70...,  0.70...,  0.  ...]])
    
Note: L2 normalization is also known as spatial sign preprocessing.

Sparse input

`normalize` and `Normalizer` accept both dense array-like and sparse matrices
from scipy.sparse as input.

For sparse input the data is converted to the Compressed Sparse Rows
representation (see `scipy.sparse.csr_matrix`) before being fed to efficient
Cython routines. To avoid unnecessary memory copies, it is recommended to
choose the CSR representation upstream.

##  6.3.4. Encoding categorical features

Often features are not given as continuous values but categorical. For example
a person could have features `["male", "female"]`, `["from Europe", "from US",
"from Asia"]`, `["uses Firefox", "uses Chrome", "uses Safari", "uses Internet
Explorer"]`. Such features can be efficiently coded as integers, for instance
`["male", "from US", "uses Internet Explorer"]` could be expressed as `[0, 1,
3]` while `["female", "from Asia", "uses Chrome"]` would be `[1, 2, 1]`.

To convert categorical features to such integer codes, we can use the
`OrdinalEncoder`. This estimator transforms each categorical feature to one
new feature of integers (0 to n_categories - 1):

    
    >>> enc = preprocessing.OrdinalEncoder()
    >>> X = [['male', 'from US', 'uses Safari'], ['female', 'from Europe', 'uses Firefox']]
    >>> enc.fit(X)
    OrdinalEncoder()
    >>> enc.transform([['female', 'from US', 'uses Safari']])
    array([[0., 1., 1.]])
    
Such integer representation can, however, not be used directly with all
scikit-learn estimators, as these expect continuous input, and would interpret
the categories as being ordered, which is often not desired (i.e. the set of
browsers was ordered arbitrarily).

Another possibility to convert categorical features to features that can be
used with scikit-learn estimators is to use a one-of-K, also known as one-hot
or dummy encoding. This type of encoding can be obtained with the
`OneHotEncoder`, which transforms each categorical feature with `n_categories`
possible values into `n_categories` binary features, with one of them 1, and
all others 0.

Continuing the example above:

    
    >>> enc = preprocessing.OneHotEncoder()
    >>> X = [['male', 'from US', 'uses Safari'], ['female', 'from Europe', 'uses Firefox']]
    >>> enc.fit(X)
    OneHotEncoder()
    >>> enc.transform([['female', 'from US', 'uses Safari'],
    ...                ['male', 'from Europe', 'uses Safari']]).toarray()
    array([[1., 0., 0., 1., 0., 1.],
           [0., 1., 1., 0., 0., 1.]])
    
By default, the values each feature can take is inferred automatically from
the dataset and can be found in the `categories_` attribute:

    
    >>> enc.categories_
    [array(['female', 'male'], dtype=object), array(['from Europe', 'from US'], dtype=object), array(['uses Firefox', 'uses Safari'], dtype=object)]
    
It is possible to specify this explicitly using the parameter `categories`.
There are two genders, four possible continents and four web browsers in our
dataset:

    
    >>> genders = ['female', 'male']
    >>> locations = ['from Africa', 'from Asia', 'from Europe', 'from US']
    >>> browsers = ['uses Chrome', 'uses Firefox', 'uses IE', 'uses Safari']
    >>> enc = preprocessing.OneHotEncoder(categories=[genders, locations, browsers])
    >>> # Note that for there are missing categorical values for the 2nd and 3rd
    >>> # feature
    >>> X = [['male', 'from US', 'uses Safari'], ['female', 'from Europe', 'uses Firefox']]
    >>> enc.fit(X)
    OneHotEncoder(categories=[['female', 'male'],
                              ['from Africa', 'from Asia', 'from Europe',
                               'from US'],
                              ['uses Chrome', 'uses Firefox', 'uses IE',
                               'uses Safari']])
    >>> enc.transform([['female', 'from Asia', 'uses Chrome']]).toarray()
    array([[1., 0., 0., 1., 0., 0., 1., 0., 0., 0.]])
    
If there is a possibility that the training data might have missing
categorical features, it can often be better to specify
`handle_unknown='ignore'` instead of setting the `categories` manually as
above. When `handle_unknown='ignore'` is specified and unknown categories are
encountered during transform, no error will be raised but the resulting one-
hot encoded columns for this feature will be all zeros
(`handle_unknown='ignore'` is only supported for one-hot encoding):

    
    >>> enc = preprocessing.OneHotEncoder(handle_unknown='ignore')
    >>> X = [['male', 'from US', 'uses Safari'], ['female', 'from Europe', 'uses Firefox']]
    >>> enc.fit(X)
    OneHotEncoder(handle_unknown='ignore')
    >>> enc.transform([['female', 'from Asia', 'uses Chrome']]).toarray()
    array([[1., 0., 0., 0., 0., 0.]])
    
It is also possible to encode each column into `n_categories - 1` columns
instead of `n_categories` columns by using the `drop` parameter. This
parameter allows the user to specify a category for each feature to be
dropped. This is useful to avoid co-linearity in the input matrix in some
classifiers. Such functionality is useful, for example, when using non-
regularized regression (`LinearRegression`), since co-linearity would cause
the covariance matrix to be non-invertible. When this parameter is not None,
`handle_unknown` must be set to `error`:

    
    >>> X = [['male', 'from US', 'uses Safari'],
    ...      ['female', 'from Europe', 'uses Firefox']]
    >>> drop_enc = preprocessing.OneHotEncoder(drop='first').fit(X)
    >>> drop_enc.categories_
    [array(['female', 'male'], dtype=object), array(['from Europe', 'from US'], dtype=object), array(['uses Firefox', 'uses Safari'], dtype=object)]
    >>> drop_enc.transform(X).toarray()
    array([[1., 1., 1.],
           [0., 0., 0.]])
    
One might want to drop one of the two columns only for features with 2
categories. In this case, you can set the parameter `drop='if_binary'`.

    
    >>> X = [['male', 'US', 'Safari'],
    ...      ['female', 'Europe', 'Firefox'],
    ...      ['female', 'Asia', 'Chrome']]
    >>> drop_enc = preprocessing.OneHotEncoder(drop='if_binary').fit(X)
    >>> drop_enc.categories_
    [array(['female', 'male'], dtype=object), array(['Asia', 'Europe', 'US'], dtype=object), array(['Chrome', 'Firefox', 'Safari'], dtype=object)]
    >>> drop_enc.transform(X).toarray()
    array([[1., 0., 0., 1., 0., 0., 1.],
           [0., 0., 1., 0., 0., 1., 0.],
           [0., 1., 0., 0., 1., 0., 0.]])
    
In the transformed `X`, the first column is the encoding of the feature with
categories “male”/”female”, while the remaining 6 columns is the encoding of
the 2 features with respectively 3 categories each.

`OneHotEncoder` supports categorical features with missing values by
considering the missing values as an additional category:

    
    >>> X = [['male', 'Safari'],
    ...      ['female', None],
    ...      [np.nan, 'Firefox']]
    >>> enc = preprocessing.OneHotEncoder(handle_unknown='error').fit(X)
    >>> enc.categories_
    [array(['female', 'male', nan], dtype=object),
     array(['Firefox', 'Safari', None], dtype=object)]
    >>> enc.transform(X).toarray()
    array([[0., 1., 0., 0., 1., 0.],
           [1., 0., 0., 0., 0., 1.],
           [0., 0., 1., 1., 0., 0.]])
    
If a feature contains both `np.nan` and `None`, they will be considered
separate categories:

    
    >>> X = [['Safari'], [None], [np.nan], ['Firefox']]
    >>> enc = preprocessing.OneHotEncoder(handle_unknown='error').fit(X)
    >>> enc.categories_
    [array(['Firefox', 'Safari', None, nan], dtype=object)]
    >>> enc.transform(X).toarray()
    array([[0., 1., 0., 0.],
           [0., 0., 1., 0.],
           [0., 0., 0., 1.],
           [1., 0., 0., 0.]])
    
See Loading features from dicts for categorical features that are represented
as a dict, not as scalars.

##  6.3.5. Discretization

Discretization (otherwise known as quantization or binning) provides a way to
partition continuous features into discrete values. Certain datasets with
continuous features may benefit from discretization, because discretization
can transform the dataset of continuous attributes to one with only nominal
attributes.

One-hot encoded discretized features can make a model more expressive, while
maintaining interpretability. For instance, pre-processing with a discretizer
can introduce nonlinearity to linear models.

###  6.3.5.1. K-bins discretization

`KBinsDiscretizer` discretizes features into `k` bins:

    
    >>> X = np.array([[ -3., 5., 15 ],
    ...               [  0., 6., 14 ],
    ...               [  6., 3., 11 ]])
    >>> est = preprocessing.KBinsDiscretizer(n_bins=[3, 2, 2], encode='ordinal').fit(X)
    
By default the output is one-hot encoded into a sparse matrix (See Encoding
categorical features) and this can be configured with the `encode` parameter.
For each feature, the bin edges are computed during `fit` and together with
the number of bins, they will define the intervals. Therefore, for the current
example, these intervals are defined as:

  * feature 1: \\({[-\infty, -1), [-1, 2), [2, \infty)}\\)
  * feature 2: \\({[-\infty, 5), [5, \infty)}\\)
  * feature 3: \\({[-\infty, 14), [14, \infty)}\\)

Based on these bin intervals, `X` is transformed as follows:

    
    >>> est.transform(X)                      
    array([[ 0., 1., 1.],
           [ 1., 1., 1.],
           [ 2., 0., 0.]])
    
The resulting dataset contains ordinal attributes which can be further used in
a `Pipeline`.

Discretization is similar to constructing histograms for continuous data.
However, histograms focus on counting features which fall into particular
bins, whereas discretization focuses on assigning feature values to these
bins.

`KBinsDiscretizer` implements different binning strategies, which can be
selected with the `strategy` parameter. The ‘uniform’ strategy uses constant-
width bins. The ‘quantile’ strategy uses the quantiles values to have equally
populated bins in each feature. The ‘kmeans’ strategy defines bins based on a
k-means clustering procedure performed on each feature independently.

Be aware that one can specify custom bins by passing a callable defining the
discretization strategy to `FunctionTransformer`. For instance, we can use the
Pandas function `pandas.cut`:

    
    >>> import pandas as pd
    >>> import numpy as np
    >>> bins = [0, 1, 13, 20, 60, np.inf]
    >>> labels = ['infant', 'kid', 'teen', 'adult', 'senior citizen']
    >>> transformer = preprocessing.FunctionTransformer(
    ...     pd.cut, kw_args={'bins': bins, 'labels': labels, 'retbins': False}
    ... )
    >>> X = np.array([0.2, 2, 15, 25, 97])
    >>> transformer.fit_transform(X)
    ['infant', 'kid', 'teen', 'adult', 'senior citizen']
    Categories (5, object): ['infant' < 'kid' < 'teen' < 'adult' < 'senior citizen']
    
Examples:

  * Using KBinsDiscretizer to discretize continuous features
  * Feature discretization
  * Demonstrating the different strategies of KBinsDiscretizer

###  6.3.5.2. Feature binarization

Feature binarization is the process of thresholding numerical features to get
boolean values. This can be useful for downstream probabilistic estimators
that make assumption that the input data is distributed according to a multi-
variate Bernoulli distribution. For instance, this is the case for the
`BernoulliRBM`.

It is also common among the text processing community to use binary feature
values (probably to simplify the probabilistic reasoning) even if normalized
counts (a.k.a. term frequencies) or TF-IDF valued features often perform
slightly better in practice.

As for the `Normalizer`, the utility class `Binarizer` is meant to be used in
the early stages of `Pipeline`. The `fit` method does nothing as each sample
is treated independently of others:

    
    >>> X = [[ 1., -1.,  2.],
    ...      [ 2.,  0.,  0.],
    ...      [ 0.,  1., -1.]]
    
    >>> binarizer = preprocessing.Binarizer().fit(X)  # fit does nothing
    >>> binarizer
    Binarizer()
    
    >>> binarizer.transform(X)
    array([[1., 0., 1.],
           [1., 0., 0.],
           [0., 1., 0.]])
    
It is possible to adjust the threshold of the binarizer:

    
    >>> binarizer = preprocessing.Binarizer(threshold=1.1)
    >>> binarizer.transform(X)
    array([[0., 0., 1.],
           [1., 0., 0.],
           [0., 0., 0.]])
    
As for the `Normalizer` class, the preprocessing module provides a companion
function `binarize` to be used when the transformer API is not necessary.

Note that the `Binarizer` is similar to the `KBinsDiscretizer` when `k = 2`,
and when the bin edge is at the value `threshold`.

Sparse input

`binarize` and `Binarizer` accept both dense array-like and sparse matrices
from scipy.sparse as input.

For sparse input the data is converted to the Compressed Sparse Rows
representation (see `scipy.sparse.csr_matrix`). To avoid unnecessary memory
copies, it is recommended to choose the CSR representation upstream.

##  6.3.6. Imputation of missing values

Tools for imputing missing values are discussed at Imputation of missing
values.

##  6.3.7. Generating polynomial features

Often it’s useful to add complexity to the model by considering nonlinear
features of the input data. A simple and common method to use is polynomial
features, which can get features’ high-order and interaction terms. It is
implemented in `PolynomialFeatures`:

    
    >>> import numpy as np
    >>> from sklearn.preprocessing import PolynomialFeatures
    >>> X = np.arange(6).reshape(3, 2)
    >>> X
    array([[0, 1],
           [2, 3],
           [4, 5]])
    >>> poly = PolynomialFeatures(2)
    >>> poly.fit_transform(X)
    array([[ 1.,  0.,  1.,  0.,  0.,  1.],
           [ 1.,  2.,  3.,  4.,  6.,  9.],
           [ 1.,  4.,  5., 16., 20., 25.]])
    
The features of X have been transformed from \\((X_1, X_2)\\) to \\((1, X_1,
X_2, X_1^2, X_1X_2, X_2^2)\\).

In some cases, only interaction terms among features are required, and it can
be gotten with the setting `interaction_only=True`:

    
    >>> X = np.arange(9).reshape(3, 3)
    >>> X
    array([[0, 1, 2],
           [3, 4, 5],
           [6, 7, 8]])
    >>> poly = PolynomialFeatures(degree=3, interaction_only=True)
    >>> poly.fit_transform(X)
    array([[  1.,   0.,   1.,   2.,   0.,   0.,   2.,   0.],
           [  1.,   3.,   4.,   5.,  12.,  15.,  20.,  60.],
           [  1.,   6.,   7.,   8.,  42.,  48.,  56., 336.]])
    
The features of X have been transformed from \\((X_1, X_2, X_3)\\) to \\((1,
X_1, X_2, X_3, X_1X_2, X_1X_3, X_2X_3, X_1X_2X_3)\\).

Note that polynomial features are used implicitly in kernel methods (e.g.,
`SVC`, `KernelPCA`) when using polynomial Kernel functions.

See Polynomial interpolation for Ridge regression using created polynomial
features.

##  6.3.8. Custom transformers

Often, you will want to convert an existing Python function into a transformer
to assist in data cleaning or processing. You can implement a transformer from
an arbitrary function with `FunctionTransformer`. For example, to build a
transformer that applies a log transformation in a pipeline, do:

    
    >>> import numpy as np
    >>> from sklearn.preprocessing import FunctionTransformer
    >>> transformer = FunctionTransformer(np.log1p, validate=True)
    >>> X = np.array([[0, 1], [2, 3]])
    >>> transformer.transform(X)
    array([[0.        , 0.69314718],
           [1.09861229, 1.38629436]])
    
You can ensure that `func` and `inverse_func` are the inverse of each other by
setting `check_inverse=True` and calling `fit` before `transform`. Please note
that a warning is raised and can be turned into an error with a
`filterwarnings`:

    
    >>> import warnings
    >>> warnings.filterwarnings("error", message=".*check_inverse*.",
    ...                         category=UserWarning, append=False)
    
For a full code example that demonstrates using a `FunctionTransformer` to
extract features from text data see Column Transformer with Heterogeneous Data
Sources

© 2007–2020 The scikit-learn developers  
Licensed under the 3-clause BSD License.  
https://scikit-learn.org/0.24/modules/preprocessing.html

