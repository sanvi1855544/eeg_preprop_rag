# pathlib — Object-oriented filesystem paths

New in version 3.4.

Source code: Lib/pathlib.py

This module offers classes representing filesystem paths with semantics
appropriate for different operating systems. Path classes are divided between
pure paths, which provide purely computational operations without I/O, and
concrete paths, which inherit from pure paths but also provide I/O operations.

![../_images/pathlib-
inheritance.png](data:image/png;base64,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)

If you’ve never used this module before or just aren’t sure which class is
right for your task, `Path` is most likely what you need. It instantiates a
concrete path for the platform the code is running on.

Pure paths are useful in some special cases; for example:

  1. If you want to manipulate Windows paths on a Unix machine (or vice versa). You cannot instantiate a `WindowsPath` when running on Unix, but you can instantiate `PureWindowsPath`.
  2. You want to make sure that your code only manipulates paths without actually accessing the OS. In this case, instantiating one of the pure classes may be useful since those simply don’t have any OS-accessing operations.

See also

PEP 428: The pathlib module – object-oriented filesystem paths.

See also

For low-level path manipulation on strings, you can also use the `os.path`
module.

## Basic use

Importing the main class:

    
    >>> from pathlib import Path
    
Listing subdirectories:

    
    >>> p = Path('.')
    >>> [x for x in p.iterdir() if x.is_dir()]
    [PosixPath('.hg'), PosixPath('docs'), PosixPath('dist'),
     PosixPath('__pycache__'), PosixPath('build')]
    
Listing Python source files in this directory tree:

    
    >>> list(p.glob('**/*.py'))
    [PosixPath('test_pathlib.py'), PosixPath('setup.py'),
     PosixPath('pathlib.py'), PosixPath('docs/conf.py'),
     PosixPath('build/lib/pathlib.py')]
    
Navigating inside a directory tree:

    
    >>> p = Path('/etc')
    >>> q = p / 'init.d' / 'reboot'
    >>> q
    PosixPath('/etc/init.d/reboot')
    >>> q.resolve()
    PosixPath('/etc/rc.d/init.d/halt')
    
Querying path properties:

    
    >>> q.exists()
    True
    >>> q.is_dir()
    False
    
Opening a file:

    
    >>> with q.open() as f: f.readline()
    ...
    '#!/bin/bash\n'
    
## Pure paths

Pure path objects provide path-handling operations which don’t actually access
a filesystem. There are three ways to access these classes, which we also call
flavours:

`class pathlib.PurePath(*pathsegments)`

    
A generic class that represents the system’s path flavour (instantiating it
creates either a `PurePosixPath` or a `PureWindowsPath`):

    
    >>> PurePath('setup.py')      # Running on a Unix machine
    PurePosixPath('setup.py')
    
Each element of pathsegments can be either a string representing a path
segment, an object implementing the `os.PathLike` interface which returns a
string, or another path object:

    
    >>> PurePath('foo', 'some/path', 'bar')
    PurePosixPath('foo/some/path/bar')
    >>> PurePath(Path('foo'), Path('bar'))
    PurePosixPath('foo/bar')
    
When pathsegments is empty, the current directory is assumed:

    
    >>> PurePath()
    PurePosixPath('.')
    
When several absolute paths are given, the last is taken as an anchor
(mimicking `os.path.join()`’s behaviour):

    
    >>> PurePath('/etc', '/usr', 'lib64')
    PurePosixPath('/usr/lib64')
    >>> PureWindowsPath('c:/Windows', 'd:bar')
    PureWindowsPath('d:bar')
    
However, in a Windows path, changing the local root doesn’t discard the
previous drive setting:

    
    >>> PureWindowsPath('c:/Windows', '/Program Files')
    PureWindowsPath('c:/Program Files')
    
Spurious slashes and single dots are collapsed, but double dots (`'..'`) are
not, since this would change the meaning of a path in the face of symbolic
links:

    
    >>> PurePath('foo//bar')
    PurePosixPath('foo/bar')
    >>> PurePath('foo/./bar')
    PurePosixPath('foo/bar')
    >>> PurePath('foo/../bar')
    PurePosixPath('foo/../bar')
    
(a naïve approach would make `PurePosixPath('foo/../bar')` equivalent to
`PurePosixPath('bar')`, which is wrong if `foo` is a symbolic link to another
directory)

Pure path objects implement the `os.PathLike` interface, allowing them to be
used anywhere the interface is accepted.

Changed in version 3.6: Added support for the `os.PathLike` interface.

`class pathlib.PurePosixPath(*pathsegments)`

    
A subclass of `PurePath`, this path flavour represents non-Windows filesystem
paths:

    
    >>> PurePosixPath('/etc')
    PurePosixPath('/etc')
    
pathsegments is specified similarly to `PurePath`.

`class pathlib.PureWindowsPath(*pathsegments)`

    
A subclass of `PurePath`, this path flavour represents Windows filesystem
paths:

    
    >>> PureWindowsPath('c:/Program Files/')
    PureWindowsPath('c:/Program Files')
    
pathsegments is specified similarly to `PurePath`.

Regardless of the system you’re running on, you can instantiate all of these
classes, since they don’t provide any operation that does system calls.

### General properties

Paths are immutable and hashable. Paths of a same flavour are comparable and
orderable. These properties respect the flavour’s case-folding semantics:

    
    >>> PurePosixPath('foo') == PurePosixPath('FOO')
    False
    >>> PureWindowsPath('foo') == PureWindowsPath('FOO')
    True
    >>> PureWindowsPath('FOO') in { PureWindowsPath('foo') }
    True
    >>> PureWindowsPath('C:') < PureWindowsPath('d:')
    True
    
Paths of a different flavour compare unequal and cannot be ordered:

    
    >>> PureWindowsPath('foo') == PurePosixPath('foo')
    False
    >>> PureWindowsPath('foo') < PurePosixPath('foo')
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
    TypeError: '<' not supported between instances of 'PureWindowsPath' and 'PurePosixPath'
    
### Operators

The slash operator helps create child paths, similarly to `os.path.join()`:

    
    >>> p = PurePath('/etc')
    >>> p
    PurePosixPath('/etc')
    >>> p / 'init.d' / 'apache2'
    PurePosixPath('/etc/init.d/apache2')
    >>> q = PurePath('bin')
    >>> '/usr' / q
    PurePosixPath('/usr/bin')
    
A path object can be used anywhere an object implementing `os.PathLike` is
accepted:

    
    >>> import os
    >>> p = PurePath('/etc')
    >>> os.fspath(p)
    '/etc'
    
The string representation of a path is the raw filesystem path itself (in
native form, e.g. with backslashes under Windows), which you can pass to any
function taking a file path as a string:

    
    >>> p = PurePath('/etc')
    >>> str(p)
    '/etc'
    >>> p = PureWindowsPath('c:/Program Files')
    >>> str(p)
    'c:\\Program Files'
    
Similarly, calling `bytes` on a path gives the raw filesystem path as a bytes
object, as encoded by `os.fsencode()`:

    
    >>> bytes(p)
    b'/etc'
    
Note

Calling `bytes` is only recommended under Unix. Under Windows, the unicode
form is the canonical representation of filesystem paths.

### Accessing individual parts

To access the individual “parts” (components) of a path, use the following
property:

`PurePath.parts`

    
A tuple giving access to the path’s various components:

    
    >>> p = PurePath('/usr/bin/python3')
    >>> p.parts
    ('/', 'usr', 'bin', 'python3')
    
    >>> p = PureWindowsPath('c:/Program Files/PSF')
    >>> p.parts
    ('c:\\', 'Program Files', 'PSF')
    
(note how the drive and local root are regrouped in a single part)

### Methods and properties

Pure paths provide the following methods and properties:

`PurePath.drive`

    
A string representing the drive letter or name, if any:

    
    >>> PureWindowsPath('c:/Program Files/').drive
    'c:'
    >>> PureWindowsPath('/Program Files/').drive
    ''
    >>> PurePosixPath('/etc').drive
    ''
    
UNC shares are also considered drives:

    
    >>> PureWindowsPath('//host/share/foo.txt').drive
    '\\\\host\\share'
    
`PurePath.root`

    
A string representing the (local or global) root, if any:

    
    >>> PureWindowsPath('c:/Program Files/').root
    '\\'
    >>> PureWindowsPath('c:Program Files/').root
    ''
    >>> PurePosixPath('/etc').root
    '/'
    
UNC shares always have a root:

    
    >>> PureWindowsPath('//host/share').root
    '\\'
    
`PurePath.anchor`

    
The concatenation of the drive and root:

    
    >>> PureWindowsPath('c:/Program Files/').anchor
    'c:\\'
    >>> PureWindowsPath('c:Program Files/').anchor
    'c:'
    >>> PurePosixPath('/etc').anchor
    '/'
    >>> PureWindowsPath('//host/share').anchor
    '\\\\host\\share\\'
    
`PurePath.parents`

    
An immutable sequence providing access to the logical ancestors of the path:

    
    >>> p = PureWindowsPath('c:/foo/bar/setup.py')
    >>> p.parents[0]
    PureWindowsPath('c:/foo/bar')
    >>> p.parents[1]
    PureWindowsPath('c:/foo')
    >>> p.parents[2]
    PureWindowsPath('c:/')
    
`PurePath.parent`

    
The logical parent of the path:

    
    >>> p = PurePosixPath('/a/b/c/d')
    >>> p.parent
    PurePosixPath('/a/b/c')
    
You cannot go past an anchor, or empty path:

    
    >>> p = PurePosixPath('/')
    >>> p.parent
    PurePosixPath('/')
    >>> p = PurePosixPath('.')
    >>> p.parent
    PurePosixPath('.')
    
Note

This is a purely lexical operation, hence the following behaviour:

    
    >>> p = PurePosixPath('foo/..')
    >>> p.parent
    PurePosixPath('foo')
    
If you want to walk an arbitrary filesystem path upwards, it is recommended to
first call `Path.resolve()` so as to resolve symlinks and eliminate `“..”`
components.

`PurePath.name`

    
A string representing the final path component, excluding the drive and root,
if any:

    
    >>> PurePosixPath('my/library/setup.py').name
    'setup.py'
    
UNC drive names are not considered:

    
    >>> PureWindowsPath('//some/share/setup.py').name
    'setup.py'
    >>> PureWindowsPath('//some/share').name
    ''
    
`PurePath.suffix`

    
The file extension of the final component, if any:

    
    >>> PurePosixPath('my/library/setup.py').suffix
    '.py'
    >>> PurePosixPath('my/library.tar.gz').suffix
    '.gz'
    >>> PurePosixPath('my/library').suffix
    ''
    
`PurePath.suffixes`

    
A list of the path’s file extensions:

    
    >>> PurePosixPath('my/library.tar.gar').suffixes
    ['.tar', '.gar']
    >>> PurePosixPath('my/library.tar.gz').suffixes
    ['.tar', '.gz']
    >>> PurePosixPath('my/library').suffixes
    []
    
`PurePath.stem`

    
The final path component, without its suffix:

    
    >>> PurePosixPath('my/library.tar.gz').stem
    'library.tar'
    >>> PurePosixPath('my/library.tar').stem
    'library'
    >>> PurePosixPath('my/library').stem
    'library'
    
`PurePath.as_posix()`

    
Return a string representation of the path with forward slashes (`/`):

    
    >>> p = PureWindowsPath('c:\\windows')
    >>> str(p)
    'c:\\windows'
    >>> p.as_posix()
    'c:/windows'
    
`PurePath.as_uri()`

    
Represent the path as a `file` URI. `ValueError` is raised if the path isn’t
absolute.

    
    >>> p = PurePosixPath('/etc/passwd')
    >>> p.as_uri()
    'file:///etc/passwd'
    >>> p = PureWindowsPath('c:/Windows')
    >>> p.as_uri()
    'file:///c:/Windows'
    
`PurePath.is_absolute()`

    
Return whether the path is absolute or not. A path is considered absolute if
it has both a root and (if the flavour allows) a drive:

    
    >>> PurePosixPath('/a/b').is_absolute()
    True
    >>> PurePosixPath('a/b').is_absolute()
    False
    
    >>> PureWindowsPath('c:/a/b').is_absolute()
    True
    >>> PureWindowsPath('/a/b').is_absolute()
    False
    >>> PureWindowsPath('c:').is_absolute()
    False
    >>> PureWindowsPath('//some/share').is_absolute()
    True
    
`PurePath.is_relative_to(*other)`

    
Return whether or not this path is relative to the other path.

    
    >>> p = PurePath('/etc/passwd')
    >>> p.is_relative_to('/etc')
    True
    >>> p.is_relative_to('/usr')
    False
    
New in version 3.9.

`PurePath.is_reserved()`

    
With `PureWindowsPath`, return `True` if the path is considered reserved under
Windows, `False` otherwise. With `PurePosixPath`, `False` is always returned.

    
    >>> PureWindowsPath('nul').is_reserved()
    True
    >>> PurePosixPath('nul').is_reserved()
    False
    
File system calls on reserved paths can fail mysteriously or have unintended
effects.

`PurePath.joinpath(*other)`

    
Calling this method is equivalent to combining the path with each of the other
arguments in turn:

    
    >>> PurePosixPath('/etc').joinpath('passwd')
    PurePosixPath('/etc/passwd')
    >>> PurePosixPath('/etc').joinpath(PurePosixPath('passwd'))
    PurePosixPath('/etc/passwd')
    >>> PurePosixPath('/etc').joinpath('init.d', 'apache2')
    PurePosixPath('/etc/init.d/apache2')
    >>> PureWindowsPath('c:').joinpath('/Program Files')
    PureWindowsPath('c:/Program Files')
    
`PurePath.match(pattern)`

    
Match this path against the provided glob-style pattern. Return `True` if
matching is successful, `False` otherwise.

If pattern is relative, the path can be either relative or absolute, and
matching is done from the right:

    
    >>> PurePath('a/b.py').match('*.py')
    True
    >>> PurePath('/a/b/c.py').match('b/*.py')
    True
    >>> PurePath('/a/b/c.py').match('a/*.py')
    False
    
If pattern is absolute, the path must be absolute, and the whole path must
match:

    
    >>> PurePath('/a.py').match('/*.py')
    True
    >>> PurePath('a/b.py').match('/*.py')
    False
    
As with other methods, case-sensitivity follows platform defaults:

    
    >>> PurePosixPath('b.py').match('*.PY')
    False
    >>> PureWindowsPath('b.py').match('*.PY')
    True
    
`PurePath.relative_to(*other)`

    
Compute a version of this path relative to the path represented by other. If
it’s impossible, ValueError is raised:

    
    >>> p = PurePosixPath('/etc/passwd')
    >>> p.relative_to('/')
    PurePosixPath('etc/passwd')
    >>> p.relative_to('/etc')
    PurePosixPath('passwd')
    >>> p.relative_to('/usr')
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
      File "pathlib.py", line 694, in relative_to
        .format(str(self), str(formatted)))
    ValueError: '/etc/passwd' is not in the subpath of '/usr' OR one path is relative and the other absolute.
    
NOTE: This function is part of `PurePath` and works with strings. It does not
check or access the underlying file structure.

`PurePath.with_name(name)`

    
Return a new path with the `name` changed. If the original path doesn’t have a
name, ValueError is raised:

    
    >>> p = PureWindowsPath('c:/Downloads/pathlib.tar.gz')
    >>> p.with_name('setup.py')
    PureWindowsPath('c:/Downloads/setup.py')
    >>> p = PureWindowsPath('c:/')
    >>> p.with_name('setup.py')
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
      File "/home/antoine/cpython/default/Lib/pathlib.py", line 751, in with_name
        raise ValueError("%r has an empty name" % (self,))
    ValueError: PureWindowsPath('c:/') has an empty name
    
`PurePath.with_stem(stem)`

    
Return a new path with the `stem` changed. If the original path doesn’t have a
name, ValueError is raised:

    
    >>> p = PureWindowsPath('c:/Downloads/draft.txt')
    >>> p.with_stem('final')
    PureWindowsPath('c:/Downloads/final.txt')
    >>> p = PureWindowsPath('c:/Downloads/pathlib.tar.gz')
    >>> p.with_stem('lib')
    PureWindowsPath('c:/Downloads/lib.gz')
    >>> p = PureWindowsPath('c:/')
    >>> p.with_stem('')
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
      File "/home/antoine/cpython/default/Lib/pathlib.py", line 861, in with_stem
        return self.with_name(stem + self.suffix)
      File "/home/antoine/cpython/default/Lib/pathlib.py", line 851, in with_name
        raise ValueError("%r has an empty name" % (self,))
    ValueError: PureWindowsPath('c:/') has an empty name
    
New in version 3.9.

`PurePath.with_suffix(suffix)`

    
Return a new path with the `suffix` changed. If the original path doesn’t have
a suffix, the new suffix is appended instead. If the suffix is an empty
string, the original suffix is removed:

    
    >>> p = PureWindowsPath('c:/Downloads/pathlib.tar.gz')
    >>> p.with_suffix('.bz2')
    PureWindowsPath('c:/Downloads/pathlib.tar.bz2')
    >>> p = PureWindowsPath('README')
    >>> p.with_suffix('.txt')
    PureWindowsPath('README.txt')
    >>> p = PureWindowsPath('README.txt')
    >>> p.with_suffix('')
    PureWindowsPath('README')
    
## Concrete paths

Concrete paths are subclasses of the pure path classes. In addition to
operations provided by the latter, they also provide methods to do system
calls on path objects. There are three ways to instantiate concrete paths:

`class pathlib.Path(*pathsegments)`

    
A subclass of `PurePath`, this class represents concrete paths of the system’s
path flavour (instantiating it creates either a `PosixPath` or a
`WindowsPath`):

    
    >>> Path('setup.py')
    PosixPath('setup.py')
    
pathsegments is specified similarly to `PurePath`.

`class pathlib.PosixPath(*pathsegments)`

    
A subclass of `Path` and `PurePosixPath`, this class represents concrete non-
Windows filesystem paths:

    
    >>> PosixPath('/etc')
    PosixPath('/etc')
    
pathsegments is specified similarly to `PurePath`.

`class pathlib.WindowsPath(*pathsegments)`

    
A subclass of `Path` and `PureWindowsPath`, this class represents concrete
Windows filesystem paths:

    
    >>> WindowsPath('c:/Program Files/')
    WindowsPath('c:/Program Files')
    
pathsegments is specified similarly to `PurePath`.

You can only instantiate the class flavour that corresponds to your system
(allowing system calls on non-compatible path flavours could lead to bugs or
failures in your application):

    
    >>> import os
    >>> os.name
    'posix'
    >>> Path('setup.py')
    PosixPath('setup.py')
    >>> PosixPath('setup.py')
    PosixPath('setup.py')
    >>> WindowsPath('setup.py')
    Traceback (most recent call last):
      File "<stdin>", line 1, in <module>
      File "pathlib.py", line 798, in __new__
        % (cls.__name__,))
    NotImplementedError: cannot instantiate 'WindowsPath' on your system
    
### Methods

Concrete paths provide the following methods in addition to pure paths
methods. Many of these methods can raise an `OSError` if a system call fails
(for example because the path doesn’t exist).

Changed in version 3.8: `exists()`, `is_dir()`, `is_file()`, `is_mount()`,
`is_symlink()`, `is_block_device()`, `is_char_device()`, `is_fifo()`,
`is_socket()` now return `False` instead of raising an exception for paths
that contain characters unrepresentable at the OS level.

`classmethod Path.cwd()`

    
Return a new path object representing the current directory (as returned by
`os.getcwd()`):

    
    >>> Path.cwd()
    PosixPath('/home/antoine/pathlib')
    
`classmethod Path.home()`

    
Return a new path object representing the user’s home directory (as returned
by `os.path.expanduser()` with `~` construct):

    
    >>> Path.home()
    PosixPath('/home/antoine')
    
New in version 3.5.

`Path.stat()`

    
Return a `os.stat_result` object containing information about this path, like
`os.stat()`. The result is looked up at each call to this method.

    
    >>> p = Path('setup.py')
    >>> p.stat().st_size
    956
    >>> p.stat().st_mtime
    1327883547.852554
    
`Path.chmod(mode)`

    
Change the file mode and permissions, like `os.chmod()`:

    
    >>> p = Path('setup.py')
    >>> p.stat().st_mode
    33277
    >>> p.chmod(0o444)
    >>> p.stat().st_mode
    33060
    
`Path.exists()`

    
Whether the path points to an existing file or directory:

    
    >>> Path('.').exists()
    True
    >>> Path('setup.py').exists()
    True
    >>> Path('/etc').exists()
    True
    >>> Path('nonexistentfile').exists()
    False
    
Note

If the path points to a symlink, `exists()` returns whether the symlink points
to an existing file or directory.

`Path.expanduser()`

    
Return a new path with expanded `~` and `~user` constructs, as returned by
`os.path.expanduser()`:

    
    >>> p = PosixPath('~/films/Monty Python')
    >>> p.expanduser()
    PosixPath('/home/eric/films/Monty Python')
    
New in version 3.5.

`Path.glob(pattern)`

    
Glob the given relative pattern in the directory represented by this path,
yielding all matching files (of any kind):

    
    >>> sorted(Path('.').glob('*.py'))
    [PosixPath('pathlib.py'), PosixPath('setup.py'), PosixPath('test_pathlib.py')]
    >>> sorted(Path('.').glob('*/*.py'))
    [PosixPath('docs/conf.py')]
    
The “`**`” pattern means “this directory and all subdirectories, recursively”.
In other words, it enables recursive globbing:

    
    >>> sorted(Path('.').glob('**/*.py'))
    [PosixPath('build/lib/pathlib.py'),
     PosixPath('docs/conf.py'),
     PosixPath('pathlib.py'),
     PosixPath('setup.py'),
     PosixPath('test_pathlib.py')]
    
Note

Using the “`**`” pattern in large directory trees may consume an inordinate
amount of time.

Raises an auditing event `pathlib.Path.glob` with arguments `self`, `pattern`.

`Path.group()`

    
Return the name of the group owning the file. `KeyError` is raised if the
file’s gid isn’t found in the system database.

`Path.is_dir()`

    
Return `True` if the path points to a directory (or a symbolic link pointing
to a directory), `False` if it points to another kind of file.

`False` is also returned if the path doesn’t exist or is a broken symlink;
other errors (such as permission errors) are propagated.

`Path.is_file()`

    
Return `True` if the path points to a regular file (or a symbolic link
pointing to a regular file), `False` if it points to another kind of file.

`False` is also returned if the path doesn’t exist or is a broken symlink;
other errors (such as permission errors) are propagated.

`Path.is_mount()`

    
Return `True` if the path is a mount point: a point in a file system where a
different file system has been mounted. On POSIX, the function checks whether
path’s parent, `path/..`, is on a different device than path, or whether
`path/..` and path point to the same i-node on the same device — this should
detect mount points for all Unix and POSIX variants. Not implemented on
Windows.

New in version 3.7.

`Path.is_symlink()`

    
Return `True` if the path points to a symbolic link, `False` otherwise.

`False` is also returned if the path doesn’t exist; other errors (such as
permission errors) are propagated.

`Path.is_socket()`

    
Return `True` if the path points to a Unix socket (or a symbolic link pointing
to a Unix socket), `False` if it points to another kind of file.

`False` is also returned if the path doesn’t exist or is a broken symlink;
other errors (such as permission errors) are propagated.

`Path.is_fifo()`

    
Return `True` if the path points to a FIFO (or a symbolic link pointing to a
FIFO), `False` if it points to another kind of file.

`False` is also returned if the path doesn’t exist or is a broken symlink;
other errors (such as permission errors) are propagated.

`Path.is_block_device()`

    
Return `True` if the path points to a block device (or a symbolic link
pointing to a block device), `False` if it points to another kind of file.

`False` is also returned if the path doesn’t exist or is a broken symlink;
other errors (such as permission errors) are propagated.

`Path.is_char_device()`

    
Return `True` if the path points to a character device (or a symbolic link
pointing to a character device), `False` if it points to another kind of file.

`False` is also returned if the path doesn’t exist or is a broken symlink;
other errors (such as permission errors) are propagated.

`Path.iterdir()`

    
When the path points to a directory, yield path objects of the directory
contents:

    
    >>> p = Path('docs')
    >>> for child in p.iterdir(): child
    ...
    PosixPath('docs/conf.py')
    PosixPath('docs/_templates')
    PosixPath('docs/make.bat')
    PosixPath('docs/index.rst')
    PosixPath('docs/_build')
    PosixPath('docs/_static')
    PosixPath('docs/Makefile')
    
The children are yielded in arbitrary order, and the special entries `'.'` and
`'..'` are not included. If a file is removed from or added to the directory
after creating the iterator, whether an path object for that file be included
is unspecified.

`Path.lchmod(mode)`

    
Like `Path.chmod()` but, if the path points to a symbolic link, the symbolic
link’s mode is changed rather than its target’s.

`Path.lstat()`

    
Like `Path.stat()` but, if the path points to a symbolic link, return the
symbolic link’s information rather than its target’s.

`Path.mkdir(mode=0o777, parents=False, exist_ok=False)`

    
Create a new directory at this given path. If mode is given, it is combined
with the process’ `umask` value to determine the file mode and access flags.
If the path already exists, `FileExistsError` is raised.

If parents is true, any missing parents of this path are created as needed;
they are created with the default permissions without taking mode into account
(mimicking the POSIX `mkdir -p` command).

If parents is false (the default), a missing parent raises
`FileNotFoundError`.

If exist_ok is false (the default), `FileExistsError` is raised if the target
directory already exists.

If exist_ok is true, `FileExistsError` exceptions will be ignored (same
behavior as the POSIX `mkdir -p` command), but only if the last path component
is not an existing non-directory file.

Changed in version 3.5: The exist_ok parameter was added.

`Path.open(mode='r', buffering=-1, encoding=None, errors=None, newline=None)`

    
Open the file pointed to by the path, like the built-in `open()` function
does:

    
    >>> p = Path('setup.py')
    >>> with p.open() as f:
    ...     f.readline()
    ...
    '#!/usr/bin/env python3\n'
    
`Path.owner()`

    
Return the name of the user owning the file. `KeyError` is raised if the
file’s uid isn’t found in the system database.

`Path.read_bytes()`

    
Return the binary contents of the pointed-to file as a bytes object:

    
    >>> p = Path('my_binary_file')
    >>> p.write_bytes(b'Binary file contents')
    20
    >>> p.read_bytes()
    b'Binary file contents'
    
New in version 3.5.

`Path.read_text(encoding=None, errors=None)`

    
Return the decoded contents of the pointed-to file as a string:

    
    >>> p = Path('my_text_file')
    >>> p.write_text('Text file contents')
    18
    >>> p.read_text()
    'Text file contents'
    
The file is opened and then closed. The optional parameters have the same
meaning as in `open()`.

New in version 3.5.

`Path.readlink()`

    
Return the path to which the symbolic link points (as returned by
`os.readlink()`):

    
    >>> p = Path('mylink')
    >>> p.symlink_to('setup.py')
    >>> p.readlink()
    PosixPath('setup.py')
    
New in version 3.9.

`Path.rename(target)`

    
Rename this file or directory to the given target, and return a new Path
instance pointing to target. On Unix, if target exists and is a file, it will
be replaced silently if the user has permission. target can be either a string
or another path object:

    
    >>> p = Path('foo')
    >>> p.open('w').write('some text')
    9
    >>> target = Path('bar')
    >>> p.rename(target)
    PosixPath('bar')
    >>> target.open().read()
    'some text'
    
The target path may be absolute or relative. Relative paths are interpreted
relative to the current working directory, not the directory of the Path
object.

Changed in version 3.8: Added return value, return the new Path instance.

`Path.replace(target)`

    
Rename this file or directory to the given target, and return a new Path
instance pointing to target. If target points to an existing file or
directory, it will be unconditionally replaced.

The target path may be absolute or relative. Relative paths are interpreted
relative to the current working directory, not the directory of the Path
object.

Changed in version 3.8: Added return value, return the new Path instance.

`Path.resolve(strict=False)`

    
Make the path absolute, resolving any symlinks. A new path object is returned:

    
    >>> p = Path()
    >>> p
    PosixPath('.')
    >>> p.resolve()
    PosixPath('/home/antoine/pathlib')
    
“`..`” components are also eliminated (this is the only method to do so):

    
    >>> p = Path('docs/../setup.py')
    >>> p.resolve()
    PosixPath('/home/antoine/pathlib/setup.py')
    
If the path doesn’t exist and strict is `True`, `FileNotFoundError` is raised.
If strict is `False`, the path is resolved as far as possible and any
remainder is appended without checking whether it exists. If an infinite loop
is encountered along the resolution path, `RuntimeError` is raised.

New in version 3.6: The strict argument (pre-3.6 behavior is strict).

`Path.rglob(pattern)`

    
This is like calling `Path.glob()` with “`**/`” added in front of the given
relative pattern:

    
    >>> sorted(Path().rglob("*.py"))
    [PosixPath('build/lib/pathlib.py'),
     PosixPath('docs/conf.py'),
     PosixPath('pathlib.py'),
     PosixPath('setup.py'),
     PosixPath('test_pathlib.py')]
    
Raises an auditing event `pathlib.Path.rglob` with arguments `self`,
`pattern`.

`Path.rmdir()`

    
Remove this directory. The directory must be empty.

`Path.samefile(other_path)`

    
Return whether this path points to the same file as other_path, which can be
either a Path object, or a string. The semantics are similar to
`os.path.samefile()` and `os.path.samestat()`.

An `OSError` can be raised if either file cannot be accessed for some reason.

    
    >>> p = Path('spam')
    >>> q = Path('eggs')
    >>> p.samefile(q)
    False
    >>> p.samefile('spam')
    True
    
New in version 3.5.

`Path.symlink_to(target, target_is_directory=False)`

    
Make this path a symbolic link to target. Under Windows, target_is_directory
must be true (default `False`) if the link’s target is a directory. Under
POSIX, target_is_directory’s value is ignored.

    
    >>> p = Path('mylink')
    >>> p.symlink_to('setup.py')
    >>> p.resolve()
    PosixPath('/home/antoine/pathlib/setup.py')
    >>> p.stat().st_size
    956
    >>> p.lstat().st_size
    8
    
Note

The order of arguments (link, target) is the reverse of `os.symlink()`’s.

`Path.link_to(target)`

    
Make target a hard link to this path.

Warning

This function does not make this path a hard link to target, despite the
implication of the function and argument names. The argument order (target,
link) is the reverse of `Path.symlink_to()`, but matches that of `os.link()`.

New in version 3.8.

`Path.touch(mode=0o666, exist_ok=True)`

    
Create a file at this given path. If mode is given, it is combined with the
process’ `umask` value to determine the file mode and access flags. If the
file already exists, the function succeeds if exist_ok is true (and its
modification time is updated to the current time), otherwise `FileExistsError`
is raised.

`Path.unlink(missing_ok=False)`

    
Remove this file or symbolic link. If the path points to a directory, use
`Path.rmdir()` instead.

If missing_ok is false (the default), `FileNotFoundError` is raised if the
path does not exist.

If missing_ok is true, `FileNotFoundError` exceptions will be ignored (same
behavior as the POSIX `rm -f` command).

Changed in version 3.8: The missing_ok parameter was added.

`Path.write_bytes(data)`

    
Open the file pointed to in bytes mode, write data to it, and close the file:

    
    >>> p = Path('my_binary_file')
    >>> p.write_bytes(b'Binary file contents')
    20
    >>> p.read_bytes()
    b'Binary file contents'
    
An existing file of the same name is overwritten.

New in version 3.5.

`Path.write_text(data, encoding=None, errors=None)`

    
Open the file pointed to in text mode, write data to it, and close the file:

    
    >>> p = Path('my_text_file')
    >>> p.write_text('Text file contents')
    18
    >>> p.read_text()
    'Text file contents'
    
An existing file of the same name is overwritten. The optional parameters have
the same meaning as in `open()`.

New in version 3.5.

## Correspondence to tools in the os module

Below is a table mapping various `os` functions to their corresponding
`PurePath`/`Path` equivalent.

Note

Although `os.path.relpath()` and `PurePath.relative_to()` have some
overlapping use-cases, their semantics differ enough to warrant not
considering them equivalent.

os and os.path | pathlib  
---|---  
`os.path.abspath()` | `Path.resolve()`  
`os.chmod()` | `Path.chmod()`  
`os.mkdir()` | `Path.mkdir()`  
`os.makedirs()` | `Path.mkdir()`  
`os.rename()` | `Path.rename()`  
`os.replace()` | `Path.replace()`  
`os.rmdir()` | `Path.rmdir()`  
`os.remove()`, `os.unlink()` | `Path.unlink()`  
`os.getcwd()` | `Path.cwd()`  
`os.path.exists()` | `Path.exists()`  
`os.path.expanduser()` | `Path.expanduser()` and `Path.home()`  
`os.listdir()` | `Path.iterdir()`  
`os.path.isdir()` | `Path.is_dir()`  
`os.path.isfile()` | `Path.is_file()`  
`os.path.islink()` | `Path.is_symlink()`  
`os.link()` | `Path.link_to()`  
`os.symlink()` | `Path.symlink_to()`  
`os.readlink()` | `Path.readlink()`  
`os.stat()` | `Path.stat()`, `Path.owner()`, `Path.group()`  
`os.path.isabs()` | `PurePath.is_absolute()`  
`os.path.join()` | `PurePath.joinpath()`  
`os.path.basename()` | `PurePath.name`  
`os.path.dirname()` | `PurePath.parent`  
`os.path.samefile()` | `Path.samefile()`  
`os.path.splitext()` | `PurePath.suffix`  
© 2001–2021 Python Software Foundation  
Licensed under the PSF License.  
https://docs.python.org/3.9/library/pathlib.html

  *[ISP]: Internet Service Provider
  *[LIFO]: last-in, first-out
  *[FIFO]: first-in, first-out

