# Reshaping and pivot tables

## Reshaping by pivoting DataFrame objects

![../_images/reshaping_pivot.png](data:image/png;base64,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)

Data is often stored in so-called “stacked” or “record” format:

    
    In [1]: df
    Out[1]: 
             date variable     value
    0  2000-01-03        A  0.469112
    1  2000-01-04        A -0.282863
    2  2000-01-05        A -1.509059
    3  2000-01-03        B -1.135632
    4  2000-01-04        B  1.212112
    5  2000-01-05        B -0.173215
    6  2000-01-03        C  0.119209
    7  2000-01-04        C -1.044236
    8  2000-01-05        C -0.861849
    9  2000-01-03        D -2.104569
    10 2000-01-04        D -0.494929
    11 2000-01-05        D  1.071804
    
For the curious here is how the above `DataFrame` was created:

    
    import pandas._testing as tm
    
    
    def unpivot(frame):
        N, K = frame.shape
        data = {
            "value": frame.to_numpy().ravel("F"),
            "variable": np.asarray(frame.columns).repeat(N),
            "date": np.tile(np.asarray(frame.index), K),
        }
        return pd.DataFrame(data, columns=["date", "variable", "value"])
    
    
    df = unpivot(tm.makeTimeDataFrame(3))
    
To select out everything for variable `A` we could do:

    
    In [2]: df[df["variable"] == "A"]
    Out[2]: 
            date variable     value
    0 2000-01-03        A  0.469112
    1 2000-01-04        A -0.282863
    2 2000-01-05        A -1.509059
    
But suppose we wish to do time series operations with the variables. A better
representation would be where the `columns` are the unique variables and an
`index` of dates identifies individual observations. To reshape the data into
this form, we use the `DataFrame.pivot()` method (also implemented as a top
level function `pivot()`):

    
    In [3]: df.pivot(index="date", columns="variable", values="value")
    Out[3]: 
    variable           A         B         C         D
    date                                              
    2000-01-03  0.469112 -1.135632  0.119209 -2.104569
    2000-01-04 -0.282863  1.212112 -1.044236 -0.494929
    2000-01-05 -1.509059 -0.173215 -0.861849  1.071804
    
If the `values` argument is omitted, and the input `DataFrame` has more than
one column of values which are not used as column or index inputs to `pivot`,
then the resulting “pivoted” `DataFrame` will have hierarchical columns whose
topmost level indicates the respective value column:

    
    In [4]: df["value2"] = df["value"] * 2
    
    In [5]: pivoted = df.pivot(index="date", columns="variable")
    
    In [6]: pivoted
    Out[6]: 
                   value                                  value2                              
    variable           A         B         C         D         A         B         C         D
    date                                                                                      
    2000-01-03  0.469112 -1.135632  0.119209 -2.104569  0.938225 -2.271265  0.238417 -4.209138
    2000-01-04 -0.282863  1.212112 -1.044236 -0.494929 -0.565727  2.424224 -2.088472 -0.989859
    2000-01-05 -1.509059 -0.173215 -0.861849  1.071804 -3.018117 -0.346429 -1.723698  2.143608
    
You can then select subsets from the pivoted `DataFrame`:

    
    In [7]: pivoted["value2"]
    Out[7]: 
    variable           A         B         C         D
    date                                              
    2000-01-03  0.938225 -2.271265  0.238417 -4.209138
    2000-01-04 -0.565727  2.424224 -2.088472 -0.989859
    2000-01-05 -3.018117 -0.346429 -1.723698  2.143608
    
Note that this returns a view on the underlying data in the case where the
data are homogeneously-typed.

Note

`pivot()` will error with a `ValueError: Index contains duplicate entries,
cannot reshape` if the index/column pair is not unique. In this case, consider
using `pivot_table()` which is a generalization of pivot that can handle
duplicate values for one index/column pair.

## Reshaping by stacking and unstacking

![../_images/reshaping_stack.png](data:image/png;base64,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)

Closely related to the `pivot()` method are the related `stack()` and
`unstack()` methods available on `Series` and `DataFrame`. These methods are
designed to work together with `MultiIndex` objects (see the section on
hierarchical indexing). Here are essentially what these methods do:

  * `stack`: “pivot” a level of the (possibly hierarchical) column labels, returning a `DataFrame` with an index with a new inner-most level of row labels.
  * `unstack`: (inverse operation of `stack`) “pivot” a level of the (possibly hierarchical) row index to the column axis, producing a reshaped `DataFrame` with a new inner-most level of column labels.

![../_images/reshaping_unstack.png](data:image/png;base64,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)

The clearest way to explain is by example. Let’s take a prior example data set
from the hierarchical indexing section:

    
    In [8]: tuples = list(
       ...:     zip(
       ...:         *[
       ...:             ["bar", "bar", "baz", "baz", "foo", "foo", "qux", "qux"],
       ...:             ["one", "two", "one", "two", "one", "two", "one", "two"],
       ...:         ]
       ...:     )
       ...: )
       ...: 
    
    In [9]: index = pd.MultiIndex.from_tuples(tuples, names=["first", "second"])
    
    In [10]: df = pd.DataFrame(np.random.randn(8, 2), index=index, columns=["A", "B"])
    
    In [11]: df2 = df[:4]
    
    In [12]: df2
    Out[12]: 
                         A         B
    first second                    
    bar   one     0.721555 -0.706771
          two    -1.039575  0.271860
    baz   one    -0.424972  0.567020
          two     0.276232 -1.087401
    
The `stack` function “compresses” a level in the `DataFrame`’s columns to
produce either:

  * A `Series`, in the case of a simple column Index.
  * A `DataFrame`, in the case of a `MultiIndex` in the columns.

If the columns have a `MultiIndex`, you can choose which level to stack. The
stacked level becomes the new lowest level in a `MultiIndex` on the columns:

    
    In [13]: stacked = df2.stack()
    
    In [14]: stacked
    Out[14]: 
    first  second   
    bar    one     A    0.721555
                   B   -0.706771
           two     A   -1.039575
                   B    0.271860
    baz    one     A   -0.424972
                   B    0.567020
           two     A    0.276232
                   B   -1.087401
    dtype: float64
    
With a “stacked” `DataFrame` or `Series` (having a `MultiIndex` as the
`index`), the inverse operation of `stack` is `unstack`, which by default
unstacks the last level:

    
    In [15]: stacked.unstack()
    Out[15]: 
                         A         B
    first second                    
    bar   one     0.721555 -0.706771
          two    -1.039575  0.271860
    baz   one    -0.424972  0.567020
          two     0.276232 -1.087401
    
    In [16]: stacked.unstack(1)
    Out[16]: 
    second        one       two
    first                      
    bar   A  0.721555 -1.039575
          B -0.706771  0.271860
    baz   A -0.424972  0.276232
          B  0.567020 -1.087401
    
    In [17]: stacked.unstack(0)
    Out[17]: 
    first          bar       baz
    second                      
    one    A  0.721555 -0.424972
           B -0.706771  0.567020
    two    A -1.039575  0.276232
           B  0.271860 -1.087401
    
![../_images/reshaping_unstack_1.png](data:image/png;base64,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)

If the indexes have names, you can use the level names instead of specifying
the level numbers:

    
    In [18]: stacked.unstack("second")
    Out[18]: 
    second        one       two
    first                      
    bar   A  0.721555 -1.039575
          B -0.706771  0.271860
    baz   A -0.424972  0.276232
          B  0.567020 -1.087401
    
![../_images/reshaping_unstack_0.png](data:image/png;base64,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)

Notice that the `stack` and `unstack` methods implicitly sort the index levels
involved. Hence a call to `stack` and then `unstack`, or vice versa, will
result in a sorted copy of the original `DataFrame` or `Series`:

    
    In [19]: index = pd.MultiIndex.from_product([[2, 1], ["a", "b"]])
    
    In [20]: df = pd.DataFrame(np.random.randn(4), index=index, columns=["A"])
    
    In [21]: df
    Out[21]: 
                A
    2 a -0.370647
      b -1.157892
    1 a -1.344312
      b  0.844885
    
    In [22]: all(df.unstack().stack() == df.sort_index())
    Out[22]: True
    
The above code will raise a `TypeError` if the call to `sort_index` is
removed.

### Multiple levels

You may also stack or unstack more than one level at a time by passing a list
of levels, in which case the end result is as if each level in the list were
processed individually.

    
    In [23]: columns = pd.MultiIndex.from_tuples(
       ....:     [
       ....:         ("A", "cat", "long"),
       ....:         ("B", "cat", "long"),
       ....:         ("A", "dog", "short"),
       ....:         ("B", "dog", "short"),
       ....:     ],
       ....:     names=["exp", "animal", "hair_length"],
       ....: )
       ....: 
    
    In [24]: df = pd.DataFrame(np.random.randn(4, 4), columns=columns)
    
    In [25]: df
    Out[25]: 
    exp                 A         B         A         B
    animal            cat       cat       dog       dog
    hair_length      long      long     short     short
    0            1.075770 -0.109050  1.643563 -1.469388
    1            0.357021 -0.674600 -1.776904 -0.968914
    2           -1.294524  0.413738  0.276662 -0.472035
    3           -0.013960 -0.362543 -0.006154 -0.923061
    
    In [26]: df.stack(level=["animal", "hair_length"])
    Out[26]: 
    exp                          A         B
      animal hair_length                    
    0 cat    long         1.075770 -0.109050
      dog    short        1.643563 -1.469388
    1 cat    long         0.357021 -0.674600
      dog    short       -1.776904 -0.968914
    2 cat    long        -1.294524  0.413738
      dog    short        0.276662 -0.472035
    3 cat    long        -0.013960 -0.362543
      dog    short       -0.006154 -0.923061
    
The list of levels can contain either level names or level numbers (but not a
mixture of the two).

    
    # df.stack(level=['animal', 'hair_length'])
    # from above is equivalent to:
    In [27]: df.stack(level=[1, 2])
    Out[27]: 
    exp                          A         B
      animal hair_length                    
    0 cat    long         1.075770 -0.109050
      dog    short        1.643563 -1.469388
    1 cat    long         0.357021 -0.674600
      dog    short       -1.776904 -0.968914
    2 cat    long        -1.294524  0.413738
      dog    short        0.276662 -0.472035
    3 cat    long        -0.013960 -0.362543
      dog    short       -0.006154 -0.923061
    
### Missing data

These functions are intelligent about handling missing data and do not expect
each subgroup within the hierarchical index to have the same set of labels.
They also can handle the index being unsorted (but you can make it sorted by
calling `sort_index`, of course). Here is a more complex example:

    
    In [28]: columns = pd.MultiIndex.from_tuples(
       ....:     [
       ....:         ("A", "cat"),
       ....:         ("B", "dog"),
       ....:         ("B", "cat"),
       ....:         ("A", "dog"),
       ....:     ],
       ....:     names=["exp", "animal"],
       ....: )
       ....: 
    
    In [29]: index = pd.MultiIndex.from_product(
       ....:     [("bar", "baz", "foo", "qux"), ("one", "two")], names=["first", "second"]
       ....: )
       ....: 
    
    In [30]: df = pd.DataFrame(np.random.randn(8, 4), index=index, columns=columns)
    
    In [31]: df2 = df.iloc[[0, 1, 2, 4, 5, 7]]
    
    In [32]: df2
    Out[32]: 
    exp                  A         B                   A
    animal             cat       dog       cat       dog
    first second                                        
    bar   one     0.895717  0.805244 -1.206412  2.565646
          two     1.431256  1.340309 -1.170299 -0.226169
    baz   one     0.410835  0.813850  0.132003 -0.827317
    foo   one    -1.413681  1.607920  1.024180  0.569605
          two     0.875906 -2.211372  0.974466 -2.006747
    qux   two    -1.226825  0.769804 -1.281247 -0.727707
    
As mentioned above, `stack` can be called with a `level` argument to select
which level in the columns to stack:

    
    In [33]: df2.stack("exp")
    Out[33]: 
    animal                 cat       dog
    first second exp                    
    bar   one    A    0.895717  2.565646
                 B   -1.206412  0.805244
          two    A    1.431256 -0.226169
                 B   -1.170299  1.340309
    baz   one    A    0.410835 -0.827317
                 B    0.132003  0.813850
    foo   one    A   -1.413681  0.569605
                 B    1.024180  1.607920
          two    A    0.875906 -2.006747
                 B    0.974466 -2.211372
    qux   two    A   -1.226825 -0.727707
                 B   -1.281247  0.769804
    
    In [34]: df2.stack("animal")
    Out[34]: 
    exp                         A         B
    first second animal                    
    bar   one    cat     0.895717 -1.206412
                 dog     2.565646  0.805244
          two    cat     1.431256 -1.170299
                 dog    -0.226169  1.340309
    baz   one    cat     0.410835  0.132003
                 dog    -0.827317  0.813850
    foo   one    cat    -1.413681  1.024180
                 dog     0.569605  1.607920
          two    cat     0.875906  0.974466
                 dog    -2.006747 -2.211372
    qux   two    cat    -1.226825 -1.281247
                 dog    -0.727707  0.769804
    
Unstacking can result in missing values if subgroups do not have the same set
of labels. By default, missing values will be replaced with the default fill
value for that data type, `NaN` for float, `NaT` for datetimelike, etc. For
integer types, by default data will converted to float and missing values will
be set to `NaN`.

    
    In [35]: df3 = df.iloc[[0, 1, 4, 7], [1, 2]]
    
    In [36]: df3
    Out[36]: 
    exp                  B          
    animal             dog       cat
    first second                    
    bar   one     0.805244 -1.206412
          two     1.340309 -1.170299
    foo   one     1.607920  1.024180
    qux   two     0.769804 -1.281247
    
    In [37]: df3.unstack()
    Out[37]: 
    exp            B                              
    animal       dog                 cat          
    second       one       two       one       two
    first                                         
    bar     0.805244  1.340309 -1.206412 -1.170299
    foo     1.607920       NaN  1.024180       NaN
    qux          NaN  0.769804       NaN -1.281247
    
Alternatively, unstack takes an optional `fill_value` argument, for specifying
the value of missing data.

    
    In [38]: df3.unstack(fill_value=-1e9)
    Out[38]: 
    exp                B                                          
    animal           dog                         cat              
    second           one           two           one           two
    first                                                         
    bar     8.052440e-01  1.340309e+00 -1.206412e+00 -1.170299e+00
    foo     1.607920e+00 -1.000000e+09  1.024180e+00 -1.000000e+09
    qux    -1.000000e+09  7.698036e-01 -1.000000e+09 -1.281247e+00
    
### With a MultiIndex

Unstacking when the columns are a `MultiIndex` is also careful about doing the
right thing:

    
    In [39]: df[:3].unstack(0)
    Out[39]: 
    exp            A                   B                                      A          
    animal       cat                 dog                cat                 dog          
    first        bar       baz       bar      baz       bar       baz       bar       baz
    second                                                                               
    one     0.895717  0.410835  0.805244  0.81385 -1.206412  0.132003  2.565646 -0.827317
    two     1.431256       NaN  1.340309      NaN -1.170299       NaN -0.226169       NaN
    
    In [40]: df2.unstack(1)
    Out[40]: 
    exp            A                   B                                       A          
    animal       cat                 dog                 cat                 dog          
    second       one       two       one       two       one       two       one       two
    first                                                                                 
    bar     0.895717  1.431256  0.805244  1.340309 -1.206412 -1.170299  2.565646 -0.226169
    baz     0.410835       NaN  0.813850       NaN  0.132003       NaN -0.827317       NaN
    foo    -1.413681  0.875906  1.607920 -2.211372  1.024180  0.974466  0.569605 -2.006747
    qux          NaN -1.226825       NaN  0.769804       NaN -1.281247       NaN -0.727707
    
## Reshaping by melt

![../_images/reshaping_melt.png](data:image/png;base64,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g9QW0eTUcviDiLIHRQoGDlHwl0taKBJUQhC09G+655kkar5pJsZ2Gt9vaJzMTKbC4yufL5NPNM61Lqf/W2+WSK/82r7M1M59G9HbHJGDpHx9schg2EoKDyjDfKnwEIs0hPplliv1YYFbRwv9CnUXF1l9n2tFdPEWd/vr3y55q/+ywKcav/nx4tfc+fF2of+q8C+jNN379guNq7E2tkbeXrga60v628VzredGlKH0nUcDb4ay70LmrMa6d+/0sv+rxrUfyOeQ334tavofTzO5ysqsXwcH//5FhddHfqVkgbl4sZXh3KbhwvWRg4ODmb7wU3zYE9Fd/pKZNKUK3EOuqMjfrVl9SnyHAHIzOsqnuaMzkTmBSASBSASBSIhEEIhEEIiESASBSASBSIhEEIiESAQiIRJBIBIiEQQiEQRBEARBEARBEARBEARBEARBEARBEARBEARBEARBEARBEARBEARBEARBEARBEARBEARBEARBEARBEARBEAS5ntQinyiox2dRkI8vstTzaq43tYbrSm39NaTWdNXUXq0eH7lmlSxPbV3lUmusWCASIiESIiESIiESIiESIiESIiESIiESIiESIiESIiESIiESIiESIiESIiESIiESIiESIiESIiESIiESIiESIiESIiESIiESIiESIiESIiESIiESIiESIiESIiESIiESIiESIq9Us42NmoaNBv2KDFRU5MrNFam90PoRGbs5Ip/Y6H7Nff6Xn+2tLW3l6baEC+6/FZyZKUVkS8diPjM7tWQ9P3fS2tKSVpEecmY9d1onM5uro6PVLLKcQpcsspzKaxHpo7nzTztt0czmnMVbhshG6wu9itywUNFCvSRFW3naqLvwgWdEpYi008PLRbafnTRGlquKdNNAZrOLlCoWWVahSxZZTuWvINJGkSJHShTZTI16FTlPtFxTMzI/oluRm+ubxUS2ahfpGnfdTJFlFVo3IncPd2+IyGUv0dROzQ7/q3k5Nb81NcW18/q8T7gbs3Of6OW8dpGh2e7ws5A8D4Xbwgvca1noJkrtuVTk0mLLoipwrbXlwdgab0wsTvDjUmvLw7XvZLM9dRL3VydaSBnbLCjSP9zF+oaHmV/XcJ/RODrsdHaNqgf8RvXpwGifbLJI16Rnks/zO0npGq9WkeUVWqNIbZXPFbkfichoMRLZZ4GROe+BIIxGDo+j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)

The top-level `melt()` function and the corresponding `DataFrame.melt()` are
useful to massage a `DataFrame` into a format where one or more columns are
identifier variables, while all other columns, considered measured variables,
are “unpivoted” to the row axis, leaving just two non-identifier columns,
“variable” and “value”. The names of those columns can be customized by
supplying the `var_name` and `value_name` parameters.

For instance,

    
    In [41]: cheese = pd.DataFrame(
       ....:     {
       ....:         "first": ["John", "Mary"],
       ....:         "last": ["Doe", "Bo"],
       ....:         "height": [5.5, 6.0],
       ....:         "weight": [130, 150],
       ....:     }
       ....: )
       ....: 
    
    In [42]: cheese
    Out[42]: 
      first last  height  weight
    0  John  Doe     5.5     130
    1  Mary   Bo     6.0     150
    
    In [43]: cheese.melt(id_vars=["first", "last"])
    Out[43]: 
      first last variable  value
    0  John  Doe   height    5.5
    1  Mary   Bo   height    6.0
    2  John  Doe   weight  130.0
    3  Mary   Bo   weight  150.0
    
    In [44]: cheese.melt(id_vars=["first", "last"], var_name="quantity")
    Out[44]: 
      first last quantity  value
    0  John  Doe   height    5.5
    1  Mary   Bo   height    6.0
    2  John  Doe   weight  130.0
    3  Mary   Bo   weight  150.0
    
When transforming a DataFrame using `melt()`, the index will be ignored. The
original index values can be kept around by setting the `ignore_index`
parameter to `False` (default is `True`). This will however duplicate them.

New in version 1.1.0.

    
    In [45]: index = pd.MultiIndex.from_tuples([("person", "A"), ("person", "B")])
    
    In [46]: cheese = pd.DataFrame(
       ....:     {
       ....:         "first": ["John", "Mary"],
       ....:         "last": ["Doe", "Bo"],
       ....:         "height": [5.5, 6.0],
       ....:         "weight": [130, 150],
       ....:     },
       ....:     index=index,
       ....: )
       ....: 
    
    In [47]: cheese
    Out[47]: 
             first last  height  weight
    person A  John  Doe     5.5     130
           B  Mary   Bo     6.0     150
    
    In [48]: cheese.melt(id_vars=["first", "last"])
    Out[48]: 
      first last variable  value
    0  John  Doe   height    5.5
    1  Mary   Bo   height    6.0
    2  John  Doe   weight  130.0
    3  Mary   Bo   weight  150.0
    
    In [49]: cheese.melt(id_vars=["first", "last"], ignore_index=False)
    Out[49]: 
             first last variable  value
    person A  John  Doe   height    5.5
           B  Mary   Bo   height    6.0
           A  John  Doe   weight  130.0
           B  Mary   Bo   weight  150.0
    
Another way to transform is to use the `wide_to_long()` panel data convenience
function. It is less flexible than `melt()`, but more user-friendly.

    
    In [50]: dft = pd.DataFrame(
       ....:     {
       ....:         "A1970": {0: "a", 1: "b", 2: "c"},
       ....:         "A1980": {0: "d", 1: "e", 2: "f"},
       ....:         "B1970": {0: 2.5, 1: 1.2, 2: 0.7},
       ....:         "B1980": {0: 3.2, 1: 1.3, 2: 0.1},
       ....:         "X": dict(zip(range(3), np.random.randn(3))),
       ....:     }
       ....: )
       ....: 
    
    In [51]: dft["id"] = dft.index
    
    In [52]: dft
    Out[52]: 
      A1970 A1980  B1970  B1980         X  id
    0     a     d    2.5    3.2 -0.121306   0
    1     b     e    1.2    1.3 -0.097883   1
    2     c     f    0.7    0.1  0.695775   2
    
    In [53]: pd.wide_to_long(dft, ["A", "B"], i="id", j="year")
    Out[53]: 
                    X  A    B
    id year                  
    0  1970 -0.121306  a  2.5
    1  1970 -0.097883  b  1.2
    2  1970  0.695775  c  0.7
    0  1980 -0.121306  d  3.2
    1  1980 -0.097883  e  1.3
    2  1980  0.695775  f  0.1
    
## Combining with stats and GroupBy

It should be no shock that combining `pivot` / `stack` / `unstack` with
GroupBy and the basic Series and DataFrame statistical functions can produce
some very expressive and fast data manipulations.

    
    In [54]: df
    Out[54]: 
    exp                  A         B                   A
    animal             cat       dog       cat       dog
    first second                                        
    bar   one     0.895717  0.805244 -1.206412  2.565646
          two     1.431256  1.340309 -1.170299 -0.226169
    baz   one     0.410835  0.813850  0.132003 -0.827317
          two    -0.076467 -1.187678  1.130127 -1.436737
    foo   one    -1.413681  1.607920  1.024180  0.569605
          two     0.875906 -2.211372  0.974466 -2.006747
    qux   one    -0.410001 -0.078638  0.545952 -1.219217
          two    -1.226825  0.769804 -1.281247 -0.727707
    
    In [55]: df.stack().mean(1).unstack()
    Out[55]: 
    animal             cat       dog
    first second                    
    bar   one    -0.155347  1.685445
          two     0.130479  0.557070
    baz   one     0.271419 -0.006733
          two     0.526830 -1.312207
    foo   one    -0.194750  1.088763
          two     0.925186 -2.109060
    qux   one     0.067976 -0.648927
          two    -1.254036  0.021048
    
    # same result, another way
    In [56]: df.groupby(level=1, axis=1).mean()
    Out[56]: 
    animal             cat       dog
    first second                    
    bar   one    -0.155347  1.685445
          two     0.130479  0.557070
    baz   one     0.271419 -0.006733
          two     0.526830 -1.312207
    foo   one    -0.194750  1.088763
          two     0.925186 -2.109060
    qux   one     0.067976 -0.648927
          two    -1.254036  0.021048
    
    In [57]: df.stack().groupby(level=1).mean()
    Out[57]: 
    exp            A         B
    second                    
    one     0.071448  0.455513
    two    -0.424186 -0.204486
    
    In [58]: df.mean().unstack(0)
    Out[58]: 
    exp            A         B
    animal                    
    cat     0.060843  0.018596
    dog    -0.413580  0.232430
    
## Pivot tables

While `pivot()` provides general purpose pivoting with various data types
(strings, numerics, etc.), pandas also provides `pivot_table()` for pivoting
with aggregation of numeric data.

The function `pivot_table()` can be used to create spreadsheet-style pivot
tables. See the cookbook for some advanced strategies.

It takes a number of arguments:

  * `data`: a DataFrame object.
  * `values`: a column or a list of columns to aggregate.
  * `index`: a column, Grouper, array which has the same length as data, or list of them. Keys to group by on the pivot table index. If an array is passed, it is being used as the same manner as column values.
  * `columns`: a column, Grouper, array which has the same length as data, or list of them. Keys to group by on the pivot table column. If an array is passed, it is being used as the same manner as column values.
  * `aggfunc`: function to use for aggregation, defaulting to `numpy.mean`.

Consider a data set like this:

    
    In [59]: import datetime
    
    In [60]: df = pd.DataFrame(
       ....:     {
       ....:         "A": ["one", "one", "two", "three"] * 6,
       ....:         "B": ["A", "B", "C"] * 8,
       ....:         "C": ["foo", "foo", "foo", "bar", "bar", "bar"] * 4,
       ....:         "D": np.random.randn(24),
       ....:         "E": np.random.randn(24),
       ....:         "F": [datetime.datetime(2013, i, 1) for i in range(1, 13)]
       ....:         + [datetime.datetime(2013, i, 15) for i in range(1, 13)],
       ....:     }
       ....: )
       ....: 
    
    In [61]: df
    Out[61]: 
            A  B    C         D         E          F
    0     one  A  foo  0.341734 -0.317441 2013-01-01
    1     one  B  foo  0.959726 -1.236269 2013-02-01
    2     two  C  foo -1.110336  0.896171 2013-03-01
    3   three  A  bar -0.619976 -0.487602 2013-04-01
    4     one  B  bar  0.149748 -0.082240 2013-05-01
    ..    ... ..  ...       ...       ...        ...
    19  three  B  foo  0.690579 -2.213588 2013-08-15
    20    one  C  foo  0.995761  1.063327 2013-09-15
    21    one  A  bar  2.396780  1.266143 2013-10-15
    22    two  B  bar  0.014871  0.299368 2013-11-15
    23  three  C  bar  3.357427 -0.863838 2013-12-15
    
    [24 rows x 6 columns]
    
We can produce pivot tables from this data very easily:

    
    In [62]: pd.pivot_table(df, values="D", index=["A", "B"], columns=["C"])
    Out[62]: 
    C             bar       foo
    A     B                    
    one   A  1.120915 -0.514058
          B -0.338421  0.002759
          C -0.538846  0.699535
    three A -1.181568       NaN
          B       NaN  0.433512
          C  0.588783       NaN
    two   A       NaN  1.000985
          B  0.158248       NaN
          C       NaN  0.176180
    
    In [63]: pd.pivot_table(df, values="D", index=["B"], columns=["A", "C"], aggfunc=np.sum)
    Out[63]: 
    A       one               three                 two          
    C       bar       foo       bar       foo       bar       foo
    B                                                            
    A  2.241830 -1.028115 -2.363137       NaN       NaN  2.001971
    B -0.676843  0.005518       NaN  0.867024  0.316495       NaN
    C -1.077692  1.399070  1.177566       NaN       NaN  0.352360
    
    In [64]: pd.pivot_table(
       ....:     df, values=["D", "E"],
       ....:     index=["B"],
       ....:     columns=["A", "C"],
       ....:     aggfunc=np.sum,
       ....: )
       ....: 
    Out[64]: 
              D                                                           E                                                  
    A       one               three                 two                 one               three                 two          
    C       bar       foo       bar       foo       bar       foo       bar       foo       bar       foo       bar       foo
    B                                                                                                                        
    A  2.241830 -1.028115 -2.363137       NaN       NaN  2.001971  2.786113 -0.043211  1.922577       NaN       NaN  0.128491
    B -0.676843  0.005518       NaN  0.867024  0.316495       NaN  1.368280 -1.103384       NaN -2.128743 -0.194294       NaN
    C -1.077692  1.399070  1.177566       NaN       NaN  0.352360 -1.976883  1.495717 -0.263660       NaN       NaN  0.872482
    
The result object is a `DataFrame` having potentially hierarchical indexes on
the rows and columns. If the `values` column name is not given, the pivot
table will include all of the data that can be aggregated in an additional
level of hierarchy in the columns:

    
    In [65]: pd.pivot_table(df, index=["A", "B"], columns=["C"])
    Out[65]: 
                    D                   E          
    C             bar       foo       bar       foo
    A     B                                        
    one   A  1.120915 -0.514058  1.393057 -0.021605
          B -0.338421  0.002759  0.684140 -0.551692
          C -0.538846  0.699535 -0.988442  0.747859
    three A -1.181568       NaN  0.961289       NaN
          B       NaN  0.433512       NaN -1.064372
          C  0.588783       NaN -0.131830       NaN
    two   A       NaN  1.000985       NaN  0.064245
          B  0.158248       NaN -0.097147       NaN
          C       NaN  0.176180       NaN  0.436241
    
Also, you can use `Grouper` for `index` and `columns` keywords. For detail of
`Grouper`, see Grouping with a Grouper specification.

    
    In [66]: pd.pivot_table(df, values="D", index=pd.Grouper(freq="M", key="F"), columns="C")
    Out[66]: 
    C                bar       foo
    F                             
    2013-01-31       NaN -0.514058
    2013-02-28       NaN  0.002759
    2013-03-31       NaN  0.176180
    2013-04-30 -1.181568       NaN
    2013-05-31 -0.338421       NaN
    2013-06-30 -0.538846       NaN
    2013-07-31       NaN  1.000985
    2013-08-31       NaN  0.433512
    2013-09-30       NaN  0.699535
    2013-10-31  1.120915       NaN
    2013-11-30  0.158248       NaN
    2013-12-31  0.588783       NaN
    
You can render a nice output of the table omitting the missing values by
calling `to_string` if you wish:

    
    In [67]: table = pd.pivot_table(df, index=["A", "B"], columns=["C"])
    
    In [68]: print(table.to_string(na_rep=""))
                    D                   E          
    C             bar       foo       bar       foo
    A     B                                        
    one   A  1.120915 -0.514058  1.393057 -0.021605
          B -0.338421  0.002759  0.684140 -0.551692
          C -0.538846  0.699535 -0.988442  0.747859
    three A -1.181568            0.961289          
          B            0.433512           -1.064372
          C  0.588783           -0.131830          
    two   A            1.000985            0.064245
          B  0.158248           -0.097147          
          C            0.176180            0.436241
    
Note that `pivot_table` is also available as an instance method on DataFrame,

    
i.e. `DataFrame.pivot_table()`.

### Adding margins

If you pass `margins=True` to `pivot_table`, special `All` columns and rows
will be added with partial group aggregates across the categories on the rows
and columns:

    
    In [69]: table = df.pivot_table(index=["A", "B"], columns="C", margins=True, aggfunc=np.std)
    
    In [70]: table
    Out[70]: 
                    D                             E                    
    C             bar       foo       All       bar       foo       All
    A     B                                                            
    one   A  1.804346  1.210272  1.569879  0.179483  0.418374  0.858005
          B  0.690376  1.353355  0.898998  1.083825  0.968138  1.101401
          C  0.273641  0.418926  0.771139  1.689271  0.446140  1.422136
    three A  0.794212       NaN  0.794212  2.049040       NaN  2.049040
          B       NaN  0.363548  0.363548       NaN  1.625237  1.625237
          C  3.915454       NaN  3.915454  1.035215       NaN  1.035215
    two   A       NaN  0.442998  0.442998       NaN  0.447104  0.447104
          B  0.202765       NaN  0.202765  0.560757       NaN  0.560757
          C       NaN  1.819408  1.819408       NaN  0.650439  0.650439
    All      1.556686  0.952552  1.246608  1.250924  0.899904  1.059389
    
Additionally, you can call `DataFrame.stack()` to display a pivoted DataFrame
as having a multi-level index:

    
    In [71]: table.stack()
    Out[71]: 
                      D         E
    A   B C                      
    one A All  1.569879  0.858005
          bar  1.804346  0.179483
          foo  1.210272  0.418374
        B All  0.898998  1.101401
          bar  0.690376  1.083825
    ...             ...       ...
    two C All  1.819408  0.650439
          foo  1.819408  0.650439
    All   All  1.246608  1.059389
          bar  1.556686  1.250924
          foo  0.952552  0.899904
    
    [24 rows x 2 columns]
    
## Cross tabulations

Use `crosstab()` to compute a cross-tabulation of two (or more) factors. By
default `crosstab` computes a frequency table of the factors unless an array
of values and an aggregation function are passed.

It takes a number of arguments

  * `index`: array-like, values to group by in the rows.
  * `columns`: array-like, values to group by in the columns.
  * `values`: array-like, optional, array of values to aggregate according to the factors.
  * `aggfunc`: function, optional, If no values array is passed, computes a frequency table.
  * `rownames`: sequence, default `None`, must match number of row arrays passed.
  * `colnames`: sequence, default `None`, if passed, must match number of column arrays passed.
  * `margins`: boolean, default `False`, Add row/column margins (subtotals)
  * `normalize`: boolean, {‘all’, ‘index’, ‘columns’}, or {0,1}, default `False`. Normalize by dividing all values by the sum of values.

Any `Series` passed will have their name attributes used unless row or column
names for the cross-tabulation are specified

For example:

    
    In [72]: foo, bar, dull, shiny, one, two = "foo", "bar", "dull", "shiny", "one", "two"
    
    In [73]: a = np.array([foo, foo, bar, bar, foo, foo], dtype=object)
    
    In [74]: b = np.array([one, one, two, one, two, one], dtype=object)
    
    In [75]: c = np.array([dull, dull, shiny, dull, dull, shiny], dtype=object)
    
    In [76]: pd.crosstab(a, [b, c], rownames=["a"], colnames=["b", "c"])
    Out[76]: 
    b    one        two      
    c   dull shiny dull shiny
    a                        
    bar    1     0    0     1
    foo    2     1    1     0
    
If `crosstab` receives only two Series, it will provide a frequency table.

    
    In [77]: df = pd.DataFrame(
       ....:     {"A": [1, 2, 2, 2, 2], "B": [3, 3, 4, 4, 4], "C": [1, 1, np.nan, 1, 1]}
       ....: )
       ....: 
    
    In [78]: df
    Out[78]: 
       A  B    C
    0  1  3  1.0
    1  2  3  1.0
    2  2  4  NaN
    3  2  4  1.0
    4  2  4  1.0
    
    In [79]: pd.crosstab(df["A"], df["B"])
    Out[79]: 
    B  3  4
    A      
    1  1  0
    2  1  3
    
`crosstab` can also be implemented to `Categorical` data.

    
    In [80]: foo = pd.Categorical(["a", "b"], categories=["a", "b", "c"])
    
    In [81]: bar = pd.Categorical(["d", "e"], categories=["d", "e", "f"])
    
    In [82]: pd.crosstab(foo, bar)
    Out[82]: 
    col_0  d  e
    row_0      
    a      1  0
    b      0  1
    
If you want to include all of data categories even if the actual data does not
contain any instances of a particular category, you should set `dropna=False`.

For example:

    
    In [83]: pd.crosstab(foo, bar, dropna=False)
    Out[83]: 
    col_0  d  e  f
    row_0         
    a      1  0  0
    b      0  1  0
    c      0  0  0
    
### Normalization

Frequency tables can also be normalized to show percentages rather than counts
using the `normalize` argument:

    
    In [84]: pd.crosstab(df["A"], df["B"], normalize=True)
    Out[84]: 
    B    3    4
    A          
    1  0.2  0.0
    2  0.2  0.6
    
`normalize` can also normalize values within each row or within each column:

    
    In [85]: pd.crosstab(df["A"], df["B"], normalize="columns")
    Out[85]: 
    B    3    4
    A          
    1  0.5  0.0
    2  0.5  1.0
    
`crosstab` can also be passed a third `Series` and an aggregation function
(`aggfunc`) that will be applied to the values of the third `Series` within
each group defined by the first two `Series`:

    
    In [86]: pd.crosstab(df["A"], df["B"], values=df["C"], aggfunc=np.sum)
    Out[86]: 
    B    3    4
    A          
    1  1.0  NaN
    2  1.0  2.0
    
### Adding margins

Finally, one can also add margins or normalize this output.

    
    In [87]: pd.crosstab(
       ....:     df["A"], df["B"], values=df["C"], aggfunc=np.sum, normalize=True, margins=True
       ....: )
       ....: 
    Out[87]: 
    B       3    4   All
    A                   
    1    0.25  0.0  0.25
    2    0.25  0.5  0.75
    All  0.50  0.5  1.00
    
## Tiling

The `cut()` function computes groupings for the values of the input array and
is often used to transform continuous variables to discrete or categorical
variables:

    
    In [88]: ages = np.array([10, 15, 13, 12, 23, 25, 28, 59, 60])
    
    In [89]: pd.cut(ages, bins=3)
    Out[89]: 
    [(9.95, 26.667], (9.95, 26.667], (9.95, 26.667], (9.95, 26.667], (9.95, 26.667], (9.95, 26.667], (26.667, 43.333], (43.333, 60.0], (43.333, 60.0]]
    Categories (3, interval[float64, right]): [(9.95, 26.667] < (26.667, 43.333] < (43.333, 60.0]]
    
If the `bins` keyword is an integer, then equal-width bins are formed.
Alternatively we can specify custom bin-edges:

    
    In [90]: c = pd.cut(ages, bins=[0, 18, 35, 70])
    
    In [91]: c
    Out[91]: 
    [(0, 18], (0, 18], (0, 18], (0, 18], (18, 35], (18, 35], (18, 35], (35, 70], (35, 70]]
    Categories (3, interval[int64, right]): [(0, 18] < (18, 35] < (35, 70]]
    
If the `bins` keyword is an `IntervalIndex`, then these will be used to bin
the passed data.:

    
    pd.cut([25, 20, 50], bins=c.categories)
    
## Computing indicator / dummy variables

To convert a categorical variable into a “dummy” or “indicator” `DataFrame`,
for example a column in a `DataFrame` (a `Series`) which has `k` distinct
values, can derive a `DataFrame` containing `k` columns of 1s and 0s using
`get_dummies()`:

    
    In [92]: df = pd.DataFrame({"key": list("bbacab"), "data1": range(6)})
    
    In [93]: pd.get_dummies(df["key"])
    Out[93]: 
       a  b  c
    0  0  1  0
    1  0  1  0
    2  1  0  0
    3  0  0  1
    4  1  0  0
    5  0  1  0
    
Sometimes it’s useful to prefix the column names, for example when merging the
result with the original `DataFrame`:

    
    In [94]: dummies = pd.get_dummies(df["key"], prefix="key")
    
    In [95]: dummies
    Out[95]: 
       key_a  key_b  key_c
    0      0      1      0
    1      0      1      0
    2      1      0      0
    3      0      0      1
    4      1      0      0
    5      0      1      0
    
    In [96]: df[["data1"]].join(dummies)
    Out[96]: 
       data1  key_a  key_b  key_c
    0      0      0      1      0
    1      1      0      1      0
    2      2      1      0      0
    3      3      0      0      1
    4      4      1      0      0
    5      5      0      1      0
    
This function is often used along with discretization functions like `cut`:

    
    In [97]: values = np.random.randn(10)
    
    In [98]: values
    Out[98]: 
    array([ 0.4082, -1.0481, -0.0257, -0.9884,  0.0941,  1.2627,  1.29  ,
            0.0824, -0.0558,  0.5366])
    
    In [99]: bins = [0, 0.2, 0.4, 0.6, 0.8, 1]
    
    In [100]: pd.get_dummies(pd.cut(values, bins))
    Out[100]: 
       (0.0, 0.2]  (0.2, 0.4]  (0.4, 0.6]  (0.6, 0.8]  (0.8, 1.0]
    0           0           0           1           0           0
    1           0           0           0           0           0
    2           0           0           0           0           0
    3           0           0           0           0           0
    4           1           0           0           0           0
    5           0           0           0           0           0
    6           0           0           0           0           0
    7           1           0           0           0           0
    8           0           0           0           0           0
    9           0           0           1           0           0
    
See also `Series.str.get_dummies`.

`get_dummies()` also accepts a `DataFrame`. By default all categorical
variables (categorical in the statistical sense, those with `object` or
`categorical` dtype) are encoded as dummy variables.

    
    In [101]: df = pd.DataFrame({"A": ["a", "b", "a"], "B": ["c", "c", "b"], "C": [1, 2, 3]})
    
    In [102]: pd.get_dummies(df)
    Out[102]: 
       C  A_a  A_b  B_b  B_c
    0  1    1    0    0    1
    1  2    0    1    0    1
    2  3    1    0    1    0
    
All non-object columns are included untouched in the output. You can control
the columns that are encoded with the `columns` keyword.

    
    In [103]: pd.get_dummies(df, columns=["A"])
    Out[103]: 
       B  C  A_a  A_b
    0  c  1    1    0
    1  c  2    0    1
    2  b  3    1    0
    
Notice that the `B` column is still included in the output, it just hasn’t
been encoded. You can drop `B` before calling `get_dummies` if you don’t want
to include it in the output.

As with the `Series` version, you can pass values for the `prefix` and
`prefix_sep`. By default the column name is used as the prefix, and ‘_’ as the
prefix separator. You can specify `prefix` and `prefix_sep` in 3 ways:

  * string: Use the same value for `prefix` or `prefix_sep` for each column to be encoded.
  * list: Must be the same length as the number of columns being encoded.
  * dict: Mapping column name to prefix.

    
    In [104]: simple = pd.get_dummies(df, prefix="new_prefix")
    
    In [105]: simple
    Out[105]: 
       C  new_prefix_a  new_prefix_b  new_prefix_b  new_prefix_c
    0  1             1             0             0             1
    1  2             0             1             0             1
    2  3             1             0             1             0
    
    In [106]: from_list = pd.get_dummies(df, prefix=["from_A", "from_B"])
    
    In [107]: from_list
    Out[107]: 
       C  from_A_a  from_A_b  from_B_b  from_B_c
    0  1         1         0         0         1
    1  2         0         1         0         1
    2  3         1         0         1         0
    
    In [108]: from_dict = pd.get_dummies(df, prefix={"B": "from_B", "A": "from_A"})
    
    In [109]: from_dict
    Out[109]: 
       C  from_A_a  from_A_b  from_B_b  from_B_c
    0  1         1         0         0         1
    1  2         0         1         0         1
    2  3         1         0         1         0
    
Sometimes it will be useful to only keep k-1 levels of a categorical variable
to avoid collinearity when feeding the result to statistical models. You can
switch to this mode by turn on `drop_first`.

    
    In [110]: s = pd.Series(list("abcaa"))
    
    In [111]: pd.get_dummies(s)
    Out[111]: 
       a  b  c
    0  1  0  0
    1  0  1  0
    2  0  0  1
    3  1  0  0
    4  1  0  0
    
    In [112]: pd.get_dummies(s, drop_first=True)
    Out[112]: 
       b  c
    0  0  0
    1  1  0
    2  0  1
    3  0  0
    4  0  0
    
When a column contains only one level, it will be omitted in the result.

    
    In [113]: df = pd.DataFrame({"A": list("aaaaa"), "B": list("ababc")})
    
    In [114]: pd.get_dummies(df)
    Out[114]: 
       A_a  B_a  B_b  B_c
    0    1    1    0    0
    1    1    0    1    0
    2    1    1    0    0
    3    1    0    1    0
    4    1    0    0    1
    
    In [115]: pd.get_dummies(df, drop_first=True)
    Out[115]: 
       B_b  B_c
    0    0    0
    1    1    0
    2    0    0
    3    1    0
    4    0    1
    
By default new columns will have `np.uint8` dtype. To choose another dtype,
use the `dtype` argument:

    
    In [116]: df = pd.DataFrame({"A": list("abc"), "B": [1.1, 2.2, 3.3]})
    
    In [117]: pd.get_dummies(df, dtype=bool).dtypes
    Out[117]: 
    B      float64
    A_a       bool
    A_b       bool
    A_c       bool
    dtype: object
    
## Factorizing values

To encode 1-d values as an enumerated type use `factorize()`:

    
    In [118]: x = pd.Series(["A", "A", np.nan, "B", 3.14, np.inf])
    
    In [119]: x
    Out[119]: 
    0       A
    1       A
    2     NaN
    3       B
    4    3.14
    5     inf
    dtype: object
    
    In [120]: labels, uniques = pd.factorize(x)
    
    In [121]: labels
    Out[121]: array([ 0,  0, -1,  1,  2,  3])
    
    In [122]: uniques
    Out[122]: Index(['A', 'B', 3.14, inf], dtype='object')
    
Note that `factorize` is similar to `numpy.unique`, but differs in its
handling of NaN:

Note

The following `numpy.unique` will fail under Python 3 with a `TypeError`
because of an ordering bug. See also here.

    
    In [1]: x = pd.Series(['A', 'A', np.nan, 'B', 3.14, np.inf])
    In [2]: pd.factorize(x, sort=True)
    Out[2]:
    (array([ 2,  2, -1,  3,  0,  1]),
     Index([3.14, inf, 'A', 'B'], dtype='object'))
    
    In [3]: np.unique(x, return_inverse=True)[::-1]
    Out[3]: (array([3, 3, 0, 4, 1, 2]), array([nan, 3.14, inf, 'A', 'B'], dtype=object))
    
Note

If you just want to handle one column as a categorical variable (like R’s
factor), you can use `df["cat_col"] = pd.Categorical(df["col"])` or
`df["cat_col"] = df["col"].astype("category")`. For full docs on
`Categorical`, see the Categorical introduction and the API documentation.

## Examples

In this section, we will review frequently asked questions and examples. The
column names and relevant column values are named to correspond with how this
DataFrame will be pivoted in the answers below.

    
    In [123]: np.random.seed([3, 1415])
    
    In [124]: n = 20
    
    In [125]: cols = np.array(["key", "row", "item", "col"])
    
    In [126]: df = cols + pd.DataFrame(
       .....:     (np.random.randint(5, size=(n, 4)) // [2, 1, 2, 1]).astype(str)
       .....: )
       .....: 
    
    In [127]: df.columns = cols
    
    In [128]: df = df.join(pd.DataFrame(np.random.rand(n, 2).round(2)).add_prefix("val"))
    
    In [129]: df
    Out[129]: 
         key   row   item   col  val0  val1
    0   key0  row3  item1  col3  0.81  0.04
    1   key1  row2  item1  col2  0.44  0.07
    2   key1  row0  item1  col0  0.77  0.01
    3   key0  row4  item0  col2  0.15  0.59
    4   key1  row0  item2  col1  0.81  0.64
    ..   ...   ...    ...   ...   ...   ...
    15  key0  row3  item1  col1  0.31  0.23
    16  key0  row0  item2  col3  0.86  0.01
    17  key0  row4  item0  col3  0.64  0.21
    18  key2  row2  item2  col0  0.13  0.45
    19  key0  row2  item0  col4  0.37  0.70
    
    [20 rows x 6 columns]
    
### Pivoting with single aggregations

Suppose we wanted to pivot `df` such that the `col` values are columns, `row`
values are the index, and the mean of `val0` are the values? In particular,
the resulting DataFrame should look like:

    
    col   col0   col1   col2   col3  col4
    row
    row0  0.77  0.605    NaN  0.860  0.65
    row2  0.13    NaN  0.395  0.500  0.25
    row3   NaN  0.310    NaN  0.545   NaN
    row4   NaN  0.100  0.395  0.760  0.24
    
This solution uses `pivot_table()`. Also note that `aggfunc='mean'` is the
default. It is included here to be explicit.

    
    In [130]: df.pivot_table(values="val0", index="row", columns="col", aggfunc="mean")
    Out[130]: 
    col   col0   col1   col2   col3  col4
    row                                  
    row0  0.77  0.605    NaN  0.860  0.65
    row2  0.13    NaN  0.395  0.500  0.25
    row3   NaN  0.310    NaN  0.545   NaN
    row4   NaN  0.100  0.395  0.760  0.24
    
Note that we can also replace the missing values by using the `fill_value`
parameter.

    
    In [131]: df.pivot_table(
       .....:     values="val0",
       .....:     index="row",
       .....:     columns="col",
       .....:     aggfunc="mean",
       .....:     fill_value=0,
       .....: )
       .....: 
    Out[131]: 
    col   col0   col1   col2   col3  col4
    row                                  
    row0  0.77  0.605  0.000  0.860  0.65
    row2  0.13  0.000  0.395  0.500  0.25
    row3  0.00  0.310  0.000  0.545  0.00
    row4  0.00  0.100  0.395  0.760  0.24
    
Also note that we can pass in other aggregation functions as well. For
example, we can also pass in `sum`.

    
    In [132]: df.pivot_table(
       .....:     values="val0",
       .....:     index="row",
       .....:     columns="col",
       .....:     aggfunc="sum",
       .....:     fill_value=0,
       .....: )
       .....: 
    Out[132]: 
    col   col0  col1  col2  col3  col4
    row                               
    row0  0.77  1.21  0.00  0.86  0.65
    row2  0.13  0.00  0.79  0.50  0.50
    row3  0.00  0.31  0.00  1.09  0.00
    row4  0.00  0.10  0.79  1.52  0.24
    
Another aggregation we can do is calculate the frequency in which the columns
and rows occur together a.k.a. “cross tabulation”. To do this, we can pass
`size` to the `aggfunc` parameter.

    
    In [133]: df.pivot_table(index="row", columns="col", fill_value=0, aggfunc="size")
    Out[133]: 
    col   col0  col1  col2  col3  col4
    row                               
    row0     1     2     0     1     1
    row2     1     0     2     1     2
    row3     0     1     0     2     0
    row4     0     1     2     2     1
    
### Pivoting with multiple aggregations

We can also perform multiple aggregations. For example, to perform both a
`sum` and `mean`, we can pass in a list to the `aggfunc` argument.

    
    In [134]: df.pivot_table(
       .....:     values="val0",
       .....:     index="row",
       .....:     columns="col",
       .....:     aggfunc=["mean", "sum"],
       .....: )
       .....: 
    Out[134]: 
          mean                              sum                        
    col   col0   col1   col2   col3  col4  col0  col1  col2  col3  col4
    row                                                                
    row0  0.77  0.605    NaN  0.860  0.65  0.77  1.21   NaN  0.86  0.65
    row2  0.13    NaN  0.395  0.500  0.25  0.13   NaN  0.79  0.50  0.50
    row3   NaN  0.310    NaN  0.545   NaN   NaN  0.31   NaN  1.09   NaN
    row4   NaN  0.100  0.395  0.760  0.24   NaN  0.10  0.79  1.52  0.24
    
Note to aggregate over multiple value columns, we can pass in a list to the
`values` parameter.

    
    In [135]: df.pivot_table(
       .....:     values=["val0", "val1"],
       .....:     index="row",
       .....:     columns="col",
       .....:     aggfunc=["mean"],
       .....: )
       .....: 
    Out[135]: 
          mean                                                           
          val0                             val1                          
    col   col0   col1   col2   col3  col4  col0   col1  col2   col3  col4
    row                                                                  
    row0  0.77  0.605    NaN  0.860  0.65  0.01  0.745   NaN  0.010  0.02
    row2  0.13    NaN  0.395  0.500  0.25  0.45    NaN  0.34  0.440  0.79
    row3   NaN  0.310    NaN  0.545   NaN   NaN  0.230   NaN  0.075   NaN
    row4   NaN  0.100  0.395  0.760  0.24   NaN  0.070  0.42  0.300  0.46
    
Note to subdivide over multiple columns we can pass in a list to the `columns`
parameter.

    
    In [136]: df.pivot_table(
       .....:     values=["val0"],
       .....:     index="row",
       .....:     columns=["item", "col"],
       .....:     aggfunc=["mean"],
       .....: )
       .....: 
    Out[136]: 
          mean                                                                   
          val0                                                                   
    item item0             item1                         item2                   
    col   col2  col3  col4  col0  col1  col2  col3  col4  col0   col1  col3  col4
    row                                                                          
    row0   NaN   NaN   NaN  0.77   NaN   NaN   NaN   NaN   NaN  0.605  0.86  0.65
    row2  0.35   NaN  0.37   NaN   NaN  0.44   NaN   NaN  0.13    NaN  0.50  0.13
    row3   NaN   NaN   NaN   NaN  0.31   NaN  0.81   NaN   NaN    NaN  0.28   NaN
    row4  0.15  0.64   NaN   NaN  0.10  0.64  0.88  0.24   NaN    NaN   NaN   NaN
    
## Exploding a list-like column

New in version 0.25.0.

Sometimes the values in a column are list-like.

    
    In [137]: keys = ["panda1", "panda2", "panda3"]
    
    In [138]: values = [["eats", "shoots"], ["shoots", "leaves"], ["eats", "leaves"]]
    
    In [139]: df = pd.DataFrame({"keys": keys, "values": values})
    
    In [140]: df
    Out[140]: 
         keys            values
    0  panda1    [eats, shoots]
    1  panda2  [shoots, leaves]
    2  panda3    [eats, leaves]
    
We can ‘explode’ the `values` column, transforming each list-like to a
separate row, by using `explode()`. This will replicate the index values from
the original row:

    
    In [141]: df["values"].explode()
    Out[141]: 
    0      eats
    0    shoots
    1    shoots
    1    leaves
    2      eats
    2    leaves
    Name: values, dtype: object
    
You can also explode the column in the `DataFrame`.

    
    In [142]: df.explode("values")
    Out[142]: 
         keys  values
    0  panda1    eats
    0  panda1  shoots
    1  panda2  shoots
    1  panda2  leaves
    2  panda3    eats
    2  panda3  leaves
    
`Series.explode()` will replace empty lists with `np.nan` and preserve scalar
entries. The dtype of the resulting `Series` is always `object`.

    
    In [143]: s = pd.Series([[1, 2, 3], "foo", [], ["a", "b"]])
    
    In [144]: s
    Out[144]: 
    0    [1, 2, 3]
    1          foo
    2           []
    3       [a, b]
    dtype: object
    
    In [145]: s.explode()
    Out[145]: 
    0      1
    0      2
    0      3
    1    foo
    2    NaN
    3      a
    3      b
    dtype: object
    
Here is a typical usecase. You have comma separated strings in a column and
want to expand this.

    
    In [146]: df = pd.DataFrame([{"var1": "a,b,c", "var2": 1}, {"var1": "d,e,f", "var2": 2}])
    
    In [147]: df
    Out[147]: 
        var1  var2
    0  a,b,c     1
    1  d,e,f     2
    
Creating a long form DataFrame is now straightforward using explode and
chained operations

    
    In [148]: df.assign(var1=df.var1.str.split(",")).explode("var1")
    Out[148]: 
      var1  var2
    0    a     1
    0    b     1
    0    c     1
    1    d     2
    1    e     2
    1    f     2
    
© 2008–2022, AQR Capital Management, LLC, Lambda Foundry, Inc. and PyData
Development Team  
Licensed under the 3-clause BSD License.  
https://pandas.pydata.org/pandas-docs/version/1.4.0/user_guide/reshaping.html

