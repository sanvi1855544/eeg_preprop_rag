# matplotlib.ticker

## Tick locating and formatting

This module contains classes for configuring tick locating and formatting.
Generic tick locators and formatters are provided, as well as domain specific
custom ones.

Although the locators know nothing about major or minor ticks, they are used
by the Axis class to support major and minor tick locating and formatting.

### Tick locating

The Locator class is the base class for all tick locators. The locators handle
autoscaling of the view limits based on the data limits, and the choosing of
tick locations. A useful semi-automatic tick locator is `MultipleLocator`. It
is initialized with a base, e.g., 10, and it picks axis limits and ticks that
are multiples of that base.

The Locator subclasses defined here are:

`AutoLocator` | `MaxNLocator` with simple defaults. This is the default tick locator for most plotting.  
---|---  
`MaxNLocator` | Finds up to a max number of intervals with ticks at nice locations.  
`LinearLocator` | Space ticks evenly from min to max.  
`LogLocator` | Space ticks logarithmically from min to max.  
`MultipleLocator` | Ticks and range are a multiple of base; either integer or float.  
`FixedLocator` | Tick locations are fixed.  
`IndexLocator` | Locator for index plots (e.g., where `x = range(len(y))`).  
`NullLocator` | No ticks.  
`SymmetricalLogLocator` | Locator for use with with the symlog norm; works like `LogLocator` for the part outside of the threshold and adds 0 if inside the limits.  
`LogitLocator` | Locator for logit scaling.  
`AutoMinorLocator` | Locator for minor ticks when the axis is linear and the major ticks are uniformly spaced. Subdivides the major tick interval into a specified number of minor intervals, defaulting to 4 or 5 depending on the major interval.  
There are a number of locators specialized for date locations - see the
`dates` module.

You can define your own locator by deriving from Locator. You must override
the `__call__` method, which returns a sequence of locations, and you will
probably want to override the autoscale method to set the view limits from the
data limits.

If you want to override the default locator, use one of the above or a custom
locator and pass it to the x or y axis instance. The relevant methods are:

    
    ax.xaxis.set_major_locator(xmajor_locator)
    ax.xaxis.set_minor_locator(xminor_locator)
    ax.yaxis.set_major_locator(ymajor_locator)
    ax.yaxis.set_minor_locator(yminor_locator)
    
The default minor locator is `NullLocator`, i.e., no minor ticks on by
default.

Note

`Locator` instances should not be used with more than one `Axis` or `Axes`. So
instead of:

    
    locator = MultipleLocator(5)
    ax.xaxis.set_major_locator(locator)
    ax2.xaxis.set_major_locator(locator)
    
do the following instead:

    
    ax.xaxis.set_major_locator(MultipleLocator(5))
    ax2.xaxis.set_major_locator(MultipleLocator(5))
    
### Tick formatting

Tick formatting is controlled by classes derived from Formatter. The formatter
operates on a single tick value and returns a string to the axis.

`NullFormatter` | No labels on the ticks.  
---|---  
`FixedFormatter` | Set the strings manually for the labels.  
`FuncFormatter` | User defined function sets the labels.  
`StrMethodFormatter` | Use string `format` method.  
`FormatStrFormatter` | Use an old-style sprintf format string.  
`ScalarFormatter` | Default formatter for scalars: autopick the format string.  
`LogFormatter` | Formatter for log axes.  
`LogFormatterExponent` | Format values for log axis using `exponent = log_base(value)`.  
`LogFormatterMathtext` | Format values for log axis using `exponent = log_base(value)` using Math text.  
`LogFormatterSciNotation` | Format values for log axis using scientific notation.  
`LogitFormatter` | Probability formatter.  
`EngFormatter` | Format labels in engineering notation.  
`PercentFormatter` | Format labels as a percentage.  
You can derive your own formatter from the Formatter base class by simply
overriding the `__call__` method. The formatter class has access to the axis
view and data limits.

To control the major and minor tick label formats, use one of the following
methods:

    
    ax.xaxis.set_major_formatter(xmajor_formatter)
    ax.xaxis.set_minor_formatter(xminor_formatter)
    ax.yaxis.set_major_formatter(ymajor_formatter)
    ax.yaxis.set_minor_formatter(yminor_formatter)
    
In addition to a `Formatter` instance, `set_major_formatter` and
`set_minor_formatter` also accept a `str` or function. `str` input will be
internally replaced with an autogenerated `StrMethodFormatter` with the input
`str`. For function input, a `FuncFormatter` with the input function will be
generated and used.

See Major and minor ticks for an example of setting major and minor ticks. See
the `matplotlib.dates` module for more information and examples of using date
locators and formatters.

classmatplotlib.ticker.AutoLocator[source]

    
Bases: `matplotlib.ticker.MaxNLocator`

Dynamically find major tick positions. This is actually a subclass of
`MaxNLocator`, with parameters nbins = 'auto' and steps = [1, 2, 2.5, 5, 10].

To know the values of the non-public parameters, please have a look to the
defaults of `MaxNLocator`.

classmatplotlib.ticker.AutoMinorLocator(n=None)[source]

    
Bases: `matplotlib.ticker.Locator`

Dynamically find minor tick positions based on the positions of major ticks.
The scale must be linear with major ticks evenly spaced.

n is the number of subdivisions of the interval between major ticks; e.g., n=2
will place a single minor tick midway between major ticks.

If n is omitted or None, it will be set to 5 or 4.

tick_values(vmin, vmax)[source]

    
Return the values of the located ticks given vmin and vmax.

Note

To get tick locations with the vmin and vmax values defined automatically for
the associated `axis` simply call the Locator instance:

    
    >>> print(type(loc))
    <type 'Locator'>
    >>> print(loc())
    [1, 2, 3, 4]
    
classmatplotlib.ticker.EngFormatter(unit='', places=None, sep=' ', *,
usetex=None, useMathText=None)[source]

    
Bases: `matplotlib.ticker.Formatter`

Format axis values using engineering prefixes to represent powers of 1000,
plus a specified unit, e.g., 10 MHz instead of 1e7.

Parameters

    
unitstr, default: ""

    
Unit symbol to use, suitable for use with single-letter representations of
powers of 1000. For example, 'Hz' or 'm'.

placesint, default: None

    
Precision with which to display the number, specified in digits after the
decimal point (there will be between one and three digits before the decimal
point). If it is None, the formatting falls back to the floating point format
'%g', which displays up to 6 significant digits, i.e. the equivalent value for
places varies between 0 and 5 (inclusive).

sepstr, default: " "

    
Separator used between the value and the prefix/unit. For example, one get
'3.14 mV' if `sep` is " " (default) and '3.14mV' if `sep` is "". Besides the
default behavior, some other useful options may be:

  * `sep=""` to append directly the prefix/unit to the value;
  * `sep="\N{THIN SPACE}"` (`U+2009`);
  * `sep="\N{NARROW NO-BREAK SPACE}"` (`U+202F`);
  * `sep="\N{NO-BREAK SPACE}"` (`U+00A0`).

usetexbool, default: `rcParams["text.usetex"]` (default: `False`)

    
To enable/disable the use of TeX's math mode for rendering the numbers in the
formatter.

useMathTextbool, default: `rcParams["axes.formatter.use_mathtext"]` (default:
`False`)

    
To enable/disable the use mathtext for rendering the numbers in the formatter.

ENG_PREFIXES={-24: 'y', -21: 'z', -18: 'a', -15: 'f', -12: 'p', -9: 'n', -6:
'µ', -3: 'm', 0: '', 3: 'k', 6: 'M', 9: 'G', 12: 'T', 15: 'P', 18: 'E', 21:
'Z', 24: 'Y'}

format_eng(num)[source]

    
Format a number in engineering notation, appending a letter representing the
power of 1000 of the original number. Some examples:

    
    >>> format_eng(0)       # for self.places = 0
    '0'
    
    
    >>> format_eng(1000000) # for self.places = 1
    '1.0 M'
    
    
    >>> format_eng("-1e-6") # for self.places = 2
    '-1.00 µ'
    
get_useMathText()[source]

get_usetex()[source]

set_useMathText(val)[source]

set_usetex(val)[source]

propertyuseMathText

propertyusetex

classmatplotlib.ticker.FixedFormatter(seq)[source]

    
Bases: `matplotlib.ticker.Formatter`

Return fixed strings for tick labels based only on position, not value.

Note

`FixedFormatter` should only be used together with `FixedLocator`. Otherwise,
the labels may end up in unexpected positions.

Set the sequence seq of strings that will be used for labels.

get_offset()[source]

set_offset_string(ofs)[source]

classmatplotlib.ticker.FixedLocator(locs, nbins=None)[source]

    
Bases: `matplotlib.ticker.Locator`

Tick locations are fixed. If nbins is not None, the array of possible
positions will be subsampled to keep the number of ticks <= nbins +1. The
subsampling will be done so as to include the smallest absolute value; for
example, if zero is included in the array of possibilities, then it is
guaranteed to be one of the chosen ticks.

set_params(nbins=None)[source]

    
Set parameters within this locator.

tick_values(vmin, vmax)[source]

    
Return the locations of the ticks.

Note

Because the values are fixed, vmin and vmax are not used in this method.

classmatplotlib.ticker.FormatStrFormatter(fmt)[source]

    
Bases: `matplotlib.ticker.Formatter`

Use an old-style ('%' operator) format string to format the tick.

The format string should have a single variable format (%) in it. It will be
applied to the value (not the position) of the tick.

Negative numeric values will use a dash not a unicode minus, use mathtext to
get a unicode minus by wrappping the format specifier with $ (e.g. "$%g$").

classmatplotlib.ticker.Formatter[source]

    
Bases: `matplotlib.ticker.TickHelper`

Create a string based on a tick value and location.

staticfix_minus(s)[source]

    
Some classes may want to replace a hyphen for minus with the proper unicode
symbol (U+2212) for typographical correctness. This is a helper method to
perform such a replacement when it is enabled via
`rcParams["axes.unicode_minus"]` (default: `True`).

format_data(value)[source]

    
Return the full string representation of the value with the position
unspecified.

format_data_short(value)[source]

    
Return a short string version of the tick value.

Defaults to the position-independent long value.

format_ticks(values)[source]

    
Return the tick labels for all the ticks at once.

get_offset()[source]

locs=[]

set_locs(locs)[source]

    
Set the locations of the ticks.

This method is called before computing the tick labels because some formatters
need to know all tick locations to do so.

classmatplotlib.ticker.FuncFormatter(func)[source]

    
Bases: `matplotlib.ticker.Formatter`

Use a user-defined function for formatting.

The function should take in two inputs (a tick value `x` and a position
`pos`), and return a string containing the corresponding tick label.

get_offset()[source]

set_offset_string(ofs)[source]

classmatplotlib.ticker.IndexLocator(base, offset)[source]

    
Bases: `matplotlib.ticker.Locator`

Place a tick on every multiple of some base number of points plotted, e.g., on
every 5th point. It is assumed that you are doing index plotting; i.e., the
axis is 0, len(data). This is mainly useful for x ticks.

Place ticks every base data point, starting at offset.

set_params(base=None, offset=None)[source]

    
Set parameters within this locator

tick_values(vmin, vmax)[source]

    
Return the values of the located ticks given vmin and vmax.

Note

To get tick locations with the vmin and vmax values defined automatically for
the associated `axis` simply call the Locator instance:

    
    >>> print(type(loc))
    <type 'Locator'>
    >>> print(loc())
    [1, 2, 3, 4]
    
classmatplotlib.ticker.LinearLocator(numticks=None, presets=None)[source]

    
Bases: `matplotlib.ticker.Locator`

Determine the tick locations

The first time this function is called it will try to set the number of ticks
to make a nice tick partitioning. Thereafter the number of ticks will be fixed
so that interactive navigation will be nice

Use presets to set locs based on lom. A dict mapping vmin, vmax->locs

propertynumticks

set_params(numticks=None, presets=None)[source]

    
Set parameters within this locator.

tick_values(vmin, vmax)[source]

    
Return the values of the located ticks given vmin and vmax.

Note

To get tick locations with the vmin and vmax values defined automatically for
the associated `axis` simply call the Locator instance:

    
    >>> print(type(loc))
    <type 'Locator'>
    >>> print(loc())
    [1, 2, 3, 4]
    
view_limits(vmin, vmax)[source]

    
Try to choose the view limits intelligently.

classmatplotlib.ticker.Locator[source]

    
Bases: `matplotlib.ticker.TickHelper`

Determine the tick locations;

Note that the same locator should not be used across multiple `Axis` because
the locator stores references to the Axis data and view limits.

MAXTICKS=1000

nonsingular(v0, v1)[source]

    
Adjust a range as needed to avoid singularities.

This method gets called during autoscaling, with `(v0, v1)` set to the data
limits on the axes if the axes contains any data, or `(-inf, +inf)` if not.

  * If `v0 == v1` (possibly up to some floating point slop), this method returns an expanded interval around this value.
  * If `(v0, v1) == (-inf, +inf)`, this method returns appropriate default view limits.
  * Otherwise, `(v0, v1)` is returned without modification.

raise_if_exceeds(locs)[source]

    
Log at WARNING level if locs is longer than `Locator.MAXTICKS`.

This is intended to be called immediately before returning locs from
`__call__` to inform users in case their Locator returns a huge number of
ticks, causing Matplotlib to run out of memory.

The "strange" name of this method dates back to when it would raise an
exception instead of emitting a log.

set_params(**kwargs)[source]

    
Do nothing, and raise a warning. Any locator class not supporting the
set_params() function will call this.

tick_values(vmin, vmax)[source]

    
Return the values of the located ticks given vmin and vmax.

Note

To get tick locations with the vmin and vmax values defined automatically for
the associated `axis` simply call the Locator instance:

    
    >>> print(type(loc))
    <type 'Locator'>
    >>> print(loc())
    [1, 2, 3, 4]
    
view_limits(vmin, vmax)[source]

    
Select a scale for the range from vmin to vmax.

Subclasses should override this method to change locator behaviour.

classmatplotlib.ticker.LogFormatter(base=10.0, labelOnlyBase=False,
minor_thresholds=None, linthresh=None)[source]

    
Bases: `matplotlib.ticker.Formatter`

Base class for formatting ticks on a log or symlog scale.

It may be instantiated directly, or subclassed.

Parameters

    
basefloat, default: 10.

    
Base of the logarithm used in all calculations.

labelOnlyBasebool, default: False

    
If True, label ticks only at integer powers of base. This is normally True for
major ticks and False for minor ticks.

minor_thresholds(subset, all), default: (1, 0.4)

    
If labelOnlyBase is False, these two numbers control the labeling of ticks
that are not at integer powers of base; normally these are the minor ticks.
The controlling parameter is the log of the axis data range. In the typical
case where base is 10 it is the number of decades spanned by the axis, so we
can call it 'numdec'. If `numdec <= all`, all minor ticks will be labeled. If
`all < numdec <= subset`, then only a subset of minor ticks will be labeled,
so as to avoid crowding. If `numdec > subset` then no minor ticks will be
labeled.

linthreshNone or float, default: None

    
If a symmetric log scale is in use, its `linthresh` parameter must be supplied
here.

#### Notes

The `set_locs` method must be called to enable the subsetting logic controlled
by the `minor_thresholds` parameter.

In some cases such as the colorbar, there is no distinction between major and
minor ticks; the tick locations might be set manually, or by a locator that
puts ticks at integer powers of base and at intermediate locations. For this
situation, disable the minor_thresholds logic by using
`minor_thresholds=(np.inf, np.inf)`, so that all ticks will be labeled.

To disable labeling of minor ticks when 'labelOnlyBase' is False, use
`minor_thresholds=(0, 0)`. This is the default for the "classic" style.

#### Examples

To label a subset of minor ticks when the view limits span up to 2 decades,
and all of the ticks when zoomed in to 0.5 decades or less, use
`minor_thresholds=(2, 0.5)`.

To label all minor ticks when the view limits span up to 1.5 decades, use
`minor_thresholds=(1.5, 1.5)`.

base(base)[source]

    
Change the base for labeling.

Warning

Should always match the base used for `LogLocator`

format_data(value)[source]

    
Return the full string representation of the value with the position
unspecified.

format_data_short(value)[source]

    
Return a short string version of the tick value.

Defaults to the position-independent long value.

label_minor(labelOnlyBase)[source]

    
Switch minor tick labeling on or off.

Parameters

    
labelOnlyBasebool

    
If True, label ticks only at integer powers of base.

set_locs(locs=None)[source]

    
Use axis view limits to control which ticks are labeled.

The locs parameter is ignored in the present algorithm.

classmatplotlib.ticker.LogFormatterExponent(base=10.0, labelOnlyBase=False,
minor_thresholds=None, linthresh=None)[source]

    
Bases: `matplotlib.ticker.LogFormatter`

Format values for log axis using `exponent = log_base(value)`.

classmatplotlib.ticker.LogFormatterMathtext(base=10.0, labelOnlyBase=False,
minor_thresholds=None, linthresh=None)[source]

    
Bases: `matplotlib.ticker.LogFormatter`

Format values for log axis using `exponent = log_base(value)`.

classmatplotlib.ticker.LogFormatterSciNotation(base=10.0, labelOnlyBase=False,
minor_thresholds=None, linthresh=None)[source]

    
Bases: `matplotlib.ticker.LogFormatterMathtext`

Format values following scientific notation in a logarithmic axis.

classmatplotlib.ticker.LogLocator(base=10.0, subs=(1.0,), numdecs=4,
numticks=None)[source]

    
Bases: `matplotlib.ticker.Locator`

Determine the tick locations for log axes

Place ticks on the locations : subs[j] * base**i

Parameters

    
basefloat, default: 10.0

    
The base of the log used, so ticks are placed at `base**n`.

subsNone or str or sequence of float, default: (1.0,)

    
Gives the multiples of integer powers of the base at which to place ticks. The
default places ticks only at integer powers of the base. The permitted string
values are `'auto'` and `'all'`, both of which use an algorithm based on the
axis view limits to determine whether and how to put ticks between integer
powers of the base. With `'auto'`, ticks are placed only between integer
powers; with `'all'`, the integer powers are included. A value of None is
equivalent to `'auto'`.

numticksNone or int, default: None

    
The maximum number of ticks to allow on a given axis. The default of `None`
will try to choose intelligently as long as this Locator has already been
assigned to an axis using `get_tick_space`, but otherwise falls back to 9.

base(base)[source]

    
Set the log base (major tick every `base**i`, i integer).

nonsingular(vmin, vmax)[source]

    
Adjust a range as needed to avoid singularities.

This method gets called during autoscaling, with `(v0, v1)` set to the data
limits on the axes if the axes contains any data, or `(-inf, +inf)` if not.

  * If `v0 == v1` (possibly up to some floating point slop), this method returns an expanded interval around this value.
  * If `(v0, v1) == (-inf, +inf)`, this method returns appropriate default view limits.
  * Otherwise, `(v0, v1)` is returned without modification.

set_params(base=None, subs=None, numdecs=None, numticks=None)[source]

    
Set parameters within this locator.

subs(subs)[source]

    
Set the minor ticks for the log scaling every `base**i*subs[j]`.

tick_values(vmin, vmax)[source]

    
Return the values of the located ticks given vmin and vmax.

Note

To get tick locations with the vmin and vmax values defined automatically for
the associated `axis` simply call the Locator instance:

    
    >>> print(type(loc))
    <type 'Locator'>
    >>> print(loc())
    [1, 2, 3, 4]
    
view_limits(vmin, vmax)[source]

    
Try to choose the view limits intelligently.

classmatplotlib.ticker.LogitFormatter(*, use_overline=False,
one_half='\x0crac{1}{2}', minor=False, minor_threshold=25,
minor_number=6)[source]

    
Bases: `matplotlib.ticker.Formatter`

Probability formatter (using Math text).

Parameters

    
use_overlinebool, default: False

    
If x > 1/2, with x = 1-v, indicate if x should be displayed as $overline{v}$.
The default is to display $1-v$.

one_halfstr, default: r"frac{1}{2}"

    
The string used to represent 1/2.

minorbool, default: False

    
Indicate if the formatter is formatting minor ticks or not. Basically minor
ticks are not labelled, except when only few ticks are provided, ticks with
most space with neighbor ticks are labelled. See other parameters to change
the default behavior.

minor_thresholdint, default: 25

    
Maximum number of locs for labelling some minor ticks. This parameter have no
effect if minor is False.

minor_numberint, default: 6

    
Number of ticks which are labelled when the number of ticks is below the
threshold.

format_data_short(value)[source]

    
Return a short string version of the tick value.

Defaults to the position-independent long value.

set_locs(locs)[source]

    
Set the locations of the ticks.

This method is called before computing the tick labels because some formatters
need to know all tick locations to do so.

set_minor_number(minor_number)[source]

    
Set the number of minor ticks to label when some minor ticks are labelled.

Parameters

    
minor_numberint

    
Number of ticks which are labelled when the number of ticks is below the
threshold.

set_minor_threshold(minor_threshold)[source]

    
Set the threshold for labelling minors ticks.

Parameters

    
minor_thresholdint

    
Maximum number of locations for labelling some minor ticks. This parameter
have no effect if minor is False.

set_one_half(one_half)[source]

    
Set the way one half is displayed.

one_halfstr, default: r"frac{1}{2}"

    
The string used to represent 1/2.

use_overline(use_overline)[source]

    
Switch display mode with overline for labelling p>1/2.

Parameters

    
use_overlinebool, default: False

    
If x > 1/2, with x = 1-v, indicate if x should be displayed as $overline{v}$.
The default is to display $1-v$.

classmatplotlib.ticker.LogitLocator(minor=False, *, nbins='auto')[source]

    
Bases: `matplotlib.ticker.MaxNLocator`

Determine the tick locations for logit axes

Place ticks on the logit locations

Parameters

    
nbinsint or 'auto', optional

    
Number of ticks. Only used if minor is False.

minorbool, default: False

    
Indicate if this locator is for minor ticks or not.

propertyminor

nonsingular(vmin, vmax)[source]

    
Adjust a range as needed to avoid singularities.

This method gets called during autoscaling, with `(v0, v1)` set to the data
limits on the axes if the axes contains any data, or `(-inf, +inf)` if not.

  * If `v0 == v1` (possibly up to some floating point slop), this method returns an expanded interval around this value.
  * If `(v0, v1) == (-inf, +inf)`, this method returns appropriate default view limits.
  * Otherwise, `(v0, v1)` is returned without modification.

set_params(minor=None, **kwargs)[source]

    
Set parameters within this locator.

tick_values(vmin, vmax)[source]

    
Return the values of the located ticks given vmin and vmax.

Note

To get tick locations with the vmin and vmax values defined automatically for
the associated `axis` simply call the Locator instance:

    
    >>> print(type(loc))
    <type 'Locator'>
    >>> print(loc())
    [1, 2, 3, 4]
    
classmatplotlib.ticker.MaxNLocator(nbins=None, **kwargs)[source]

    
Bases: `matplotlib.ticker.Locator`

Find nice tick locations with no more than N being within the view limits.
Locations beyond the limits are added to support autoscaling.

Parameters

    
nbinsint or 'auto', default: 10

    
Maximum number of intervals; one less than max number of ticks. If the string
'auto', the number of bins will be automatically determined based on the
length of the axis.

stepsarray-like, optional

    
Sequence of nice numbers starting with 1 and ending with 10; e.g., [1, 2, 4,
5, 10], where the values are acceptable tick multiples. i.e. for the example,
20, 40, 60 would be an acceptable set of ticks, as would 0.4, 0.6, 0.8,
because they are multiples of 2. However, 30, 60, 90 would not be allowed
because 3 does not appear in the list of steps.

integerbool, default: False

    
If True, ticks will take only integer values, provided at least min_n_ticks
integers are found within the view limits.

symmetricbool, default: False

    
If True, autoscaling will result in a range symmetric about zero.

prune{'lower', 'upper', 'both', None}, default: None

    
Remove edge ticks -- useful for stacked or ganged plots where the upper tick
of one axes overlaps with the lower tick of the axes above it, primarily when
`rcParams["axes.autolimit_mode"]` (default: `'data'`) is `'round_numbers'`. If
`prune=='lower'`, the smallest tick will be removed. If `prune == 'upper'`,
the largest tick will be removed. If `prune == 'both'`, the largest and
smallest ticks will be removed. If prune is None, no ticks will be removed.

min_n_ticksint, default: 2

    
Relax nbins and integer constraints if necessary to obtain this minimum number
of ticks.

default_params={'integer': False, 'min_n_ticks': 2, 'nbins': 10, 'prune':
None, 'steps': None, 'symmetric': False}

set_params(**kwargs)[source]

    
Set parameters for this locator.

Parameters

    
nbinsint or 'auto', optional

    
see `MaxNLocator`

stepsarray-like, optional

    
see `MaxNLocator`

integerbool, optional

    
see `MaxNLocator`

symmetricbool, optional

    
see `MaxNLocator`

prune{'lower', 'upper', 'both', None}, optional

    
see `MaxNLocator`

min_n_ticksint, optional

    
see `MaxNLocator`

tick_values(vmin, vmax)[source]

    
Return the values of the located ticks given vmin and vmax.

Note

To get tick locations with the vmin and vmax values defined automatically for
the associated `axis` simply call the Locator instance:

    
    >>> print(type(loc))
    <type 'Locator'>
    >>> print(loc())
    [1, 2, 3, 4]
    
view_limits(dmin, dmax)[source]

    
Select a scale for the range from vmin to vmax.

Subclasses should override this method to change locator behaviour.

classmatplotlib.ticker.MultipleLocator(base=1.0)[source]

    
Bases: `matplotlib.ticker.Locator`

Set a tick on each integer multiple of a base within the view interval.

set_params(base)[source]

    
Set parameters within this locator.

tick_values(vmin, vmax)[source]

    
Return the values of the located ticks given vmin and vmax.

Note

To get tick locations with the vmin and vmax values defined automatically for
the associated `axis` simply call the Locator instance:

    
    >>> print(type(loc))
    <type 'Locator'>
    >>> print(loc())
    [1, 2, 3, 4]
    
view_limits(dmin, dmax)[source]

    
Set the view limits to the nearest multiples of base that contain the data.

classmatplotlib.ticker.NullFormatter[source]

    
Bases: `matplotlib.ticker.Formatter`

Always return the empty string.

classmatplotlib.ticker.NullLocator[source]

    
Bases: `matplotlib.ticker.Locator`

No ticks

tick_values(vmin, vmax)[source]

    
Return the locations of the ticks.

Note

Because the values are Null, vmin and vmax are not used in this method.

classmatplotlib.ticker.PercentFormatter(xmax=100, decimals=None, symbol='%',
is_latex=False)[source]

    
Bases: `matplotlib.ticker.Formatter`

Format numbers as a percentage.

Parameters

    
xmaxfloat

    
Determines how the number is converted into a percentage. xmax is the data
value that corresponds to 100%. Percentages are computed as `x / xmax * 100`.
So if the data is already scaled to be percentages, xmax will be 100. Another
common situation is where xmax is 1.0.

decimalsNone or int

    
The number of decimal places to place after the point. If None (the default),
the number will be computed automatically.

symbolstr or None

    
A string that will be appended to the label. It may be None or empty to
indicate that no symbol should be used. LaTeX special characters are escaped
in symbol whenever latex mode is enabled, unless is_latex is True.

is_latexbool

    
If False, reserved LaTeX characters in symbol will be escaped.

convert_to_pct(x)[source]

format_pct(x, display_range)[source]

    
Format the number as a percentage number with the correct number of decimals
and adds the percent symbol, if any.

If `self.decimals` is `None`, the number of digits after the decimal point is
set based on the display_range of the axis as follows:

display_range | decimals | sample  
---|---|---  
>50 | 0 | `x = 34.5` => 35%  
>5 | 1 | `x = 34.5` => 34.5%  
>0.5 | 2 | `x = 34.5` => 34.50%  
... | ... | ...  
This method will not be very good for tiny axis ranges or extremely large
ones. It assumes that the values on the chart are percentages displayed on a
reasonable scale.

propertysymbol

    
The configured percent symbol as a string.

If LaTeX is enabled via `rcParams["text.usetex"]` (default: `False`), the
special characters `{'#', '$', '%', '&', '~', '_', '^', '\', '{', '}'}` are
automatically escaped in the string.

classmatplotlib.ticker.ScalarFormatter(useOffset=None, useMathText=None,
useLocale=None)[source]

    
Bases: `matplotlib.ticker.Formatter`

Format tick values as a number.

Parameters

    
useOffsetbool or float, default: `rcParams["axes.formatter.useoffset"]`
(default: `True`)

    
Whether to use offset notation. See `set_useOffset`.

useMathTextbool, default: `rcParams["axes.formatter.use_mathtext"]` (default:
`False`)

    
Whether to use fancy math formatting. See `set_useMathText`.

useLocalebool, default: `rcParams["axes.formatter.use_locale"]` (default:
`False`).

    
Whether to use locale settings for decimal sign and positive sign. See
`set_useLocale`.

#### Notes

In addition to the parameters above, the formatting of scientific vs. floating
point representation can be configured via `set_scientific` and
`set_powerlimits`).

Offset notation and scientific notation

Offset notation and scientific notation look quite similar at first sight.
Both split some information from the formatted tick values and display it at
the end of the axis.

  * The scientific notation splits up the order of magnitude, i.e. a multiplicative scaling factor, e.g. `1e6`.
  * The offset notation separates an additive constant, e.g. `+1e6`. The offset notation label is always prefixed with a `+` or `-` sign and is thus distinguishable from the order of magnitude label.

The following plot with x limits `1_000_000` to `1_000_010` illustrates the
different formatting. Note the labels at the right edge of the x axis.

(Source code, png, pdf)

![../_images/ticker_api-1.png](data:image/png;base64,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)

format_data(value)[source]

    
Return the full string representation of the value with the position
unspecified.

format_data_short(value)[source]

    
Return a short string version of the tick value.

Defaults to the position-independent long value.

get_offset()[source]

    
Return scientific notation, plus offset.

get_useLocale()[source]

    
Return whether locale settings are used for formatting.

See also

`ScalarFormatter.set_useLocale`

get_useMathText()[source]

    
Return whether to use fancy math formatting.

See also

`ScalarFormatter.set_useMathText`

get_useOffset()[source]

    
Return whether automatic mode for offset notation is active.

This returns True if `set_useOffset(True)`; it returns False if an explicit
offset was set, e.g. `set_useOffset(1000)`.

See also

`ScalarFormatter.set_useOffset`

set_locs(locs)[source]

    
Set the locations of the ticks.

This method is called before computing the tick labels because some formatters
need to know all tick locations to do so.

set_powerlimits(lims)[source]

    
Set size thresholds for scientific notation.

Parameters

    
lims(int, int)

    
A tuple (min_exp, max_exp) containing the powers of 10 that determine the
switchover threshold. For a number representable as \\(a \times
10^\mathrm{exp}\\) with \\(1 <= |a| < 10\\), scientific notation will be used
if `exp <= min_exp` or `exp >= max_exp`.

The default limits are controlled by `rcParams["axes.formatter.limits"]`
(default: `[-5, 6]`).

In particular numbers with exp equal to the thresholds are written in
scientific notation.

Typically, min_exp will be negative and max_exp will be positive.

For example, `formatter.set_powerlimits((-3, 4))` will provide the following
formatting: \\(1 \times 10^{-3}, 9.9 \times 10^{-3}, 0.01,\\) \\(9999, 1
\times 10^4\\).

See also

`ScalarFormatter.set_scientific`

set_scientific(b)[source]

    
Turn scientific notation on or off.

See also

`ScalarFormatter.set_powerlimits`

set_useLocale(val)[source]

    
Set whether to use locale settings for decimal sign and positive sign.

Parameters

    
valbool or None

    
None resets to `rcParams["axes.formatter.use_locale"]` (default: `False`).

set_useMathText(val)[source]

    
Set whether to use fancy math formatting.

If active, scientific notation is formatted as \\(1.2 \times 10^3\\).

Parameters

    
valbool or None

    
None resets to `rcParams["axes.formatter.use_mathtext"]` (default: `False`).

set_useOffset(val)[source]

    
Set whether to use offset notation.

When formatting a set numbers whose value is large compared to their range,
the formatter can separate an additive constant. This can shorten the
formatted numbers so that they are less likely to overlap when drawn on an
axis.

Parameters

    
valbool or float

    
  * If False, do not use offset notation.
  * If True (=automatic mode), use offset notation if it can make the residual numbers significantly shorter. The exact behavior is controlled by `rcParams["axes.formatter.offset_threshold"]` (default: `4`).
  * If a number, force an offset of the given value.

#### Examples

With active offset notation, the values

`100_000, 100_002, 100_004, 100_006, 100_008`

will be formatted as `0, 2, 4, 6, 8` plus an offset `+1e5`, which is written
to the edge of the axis.

propertyuseLocale

    
Return whether locale settings are used for formatting.

See also

`ScalarFormatter.set_useLocale`

propertyuseMathText

    
Return whether to use fancy math formatting.

See also

`ScalarFormatter.set_useMathText`

propertyuseOffset

    
Return whether automatic mode for offset notation is active.

This returns True if `set_useOffset(True)`; it returns False if an explicit
offset was set, e.g. `set_useOffset(1000)`.

See also

`ScalarFormatter.set_useOffset`

classmatplotlib.ticker.StrMethodFormatter(fmt)[source]

    
Bases: `matplotlib.ticker.Formatter`

Use a new-style format string (as used by `str.format`) to format the tick.

The field used for the tick value must be labeled x and the field used for the
tick position must be labeled pos.

classmatplotlib.ticker.SymmetricalLogLocator(transform=None, subs=None,
linthresh=None, base=None)[source]

    
Bases: `matplotlib.ticker.Locator`

Determine the tick locations for symmetric log axes.

Parameters

    
transform`SymmetricalLogTransform`, optional

    
If set, defines the base and linthresh of the symlog transform.

base, linthreshfloat, optional

    
The base and linthresh of the symlog transform, as documented for
`SymmetricalLogScale`. These parameters are only used if transform is not set.

subssequence of float, default: [1]

    
The multiples of integer powers of the base where ticks are placed, i.e.,
ticks are placed at `[sub * base**i for i in ... for sub in subs]`.

#### Notes

Either transform, or both base and linthresh, must be given.

set_params(subs=None, numticks=None)[source]

    
Set parameters within this locator.

tick_values(vmin, vmax)[source]

    
Return the values of the located ticks given vmin and vmax.

Note

To get tick locations with the vmin and vmax values defined automatically for
the associated `axis` simply call the Locator instance:

    
    >>> print(type(loc))
    <type 'Locator'>
    >>> print(loc())
    [1, 2, 3, 4]
    
view_limits(vmin, vmax)[source]

    
Try to choose the view limits intelligently.

classmatplotlib.ticker.TickHelper[source]

    
Bases: `object`

axis=None

create_dummy_axis(**kwargs)[source]

set_axis(axis)[source]

set_bounds(vmin, vmax)[source]

    
[Deprecated]

#### Notes

Deprecated since version 3.5:

set_data_interval(vmin, vmax)[source]

    
[Deprecated]

#### Notes

Deprecated since version 3.5:

set_view_interval(vmin, vmax)[source]

    
[Deprecated]

#### Notes

Deprecated since version 3.5:

![Inheritance diagram of
matplotlib.ticker](data:image/png;base64,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)

© 2012–2021 Matplotlib Development Team. All rights reserved.  
Licensed under the Matplotlib License Agreement.  
https://matplotlib.org/3.5.1/api/ticker_api.html

