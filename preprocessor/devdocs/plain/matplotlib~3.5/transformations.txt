# matplotlib.transforms

![Inheritance diagram of
matplotlib.transforms](data:image/png;base64,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)

Matplotlib includes a framework for arbitrary geometric transformations that
is used determine the final position of all elements drawn on the canvas.

Transforms are composed into trees of `TransformNode` objects whose actual
value depends on their children. When the contents of children change, their
parents are automatically invalidated. The next time an invalidated transform
is accessed, it is recomputed to reflect those changes. This
invalidation/caching approach prevents unnecessary recomputations of
transforms, and contributes to better interactive performance.

For example, here is a graph of the transform tree used to plot data to the
graph:

![../_images/transforms.png](data:image/png;base64,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)

The framework can be used for both affine and non-affine transformations.
However, for speed, we want use the backend renderers to perform affine
transformations whenever possible. Therefore, it is possible to perform just
the affine or non-affine part of a transformation on a set of data. The affine
is always assumed to occur after the non-affine. For any transform:

    
    full transform == non-affine part + affine part
    
The backends are not expected to handle non-affine transformations themselves.

classmatplotlib.transforms.Affine2D(matrix=None, **kwargs)[source]

    
Bases: `matplotlib.transforms.Affine2DBase`

A mutable 2D affine transformation.

Initialize an Affine transform from a 3x3 numpy float array:

    
    a c e
    b d f
    0 0 1
    
If matrix is None, initialize with the identity transform.

__init__(matrix=None, **kwargs)[source]

    
Initialize an Affine transform from a 3x3 numpy float array:

    
    a c e
    b d f
    0 0 1
    
If matrix is None, initialize with the identity transform.

__module__='matplotlib.transforms'

__str__()[source]

    
Return str(self).

clear()[source]

    
Reset the underlying matrix to the identity transform.

staticfrom_values(a, b, c, d, e, f)[source]

    
Create a new Affine2D instance from the given values:

    
    a c e
    b d f
    0 0 1
    
.

get_matrix()[source]

    
Get the underlying transformation matrix as a 3x3 numpy array:

    
    a c e
    b d f
    0 0 1
    
.

staticidentity()[source]

    
Return a new `Affine2D` object that is the identity transform.

Unless this transform will be mutated later on, consider using the faster
`IdentityTransform` class instead.

rotate(theta)[source]

    
Add a rotation (in radians) to this transform in place.

Returns self, so this method can easily be chained with more calls to
`rotate()`, `rotate_deg()`, `translate()` and `scale()`.

rotate_around(x, y, theta)[source]

    
Add a rotation (in radians) around the point (x, y) in place.

Returns self, so this method can easily be chained with more calls to
`rotate()`, `rotate_deg()`, `translate()` and `scale()`.

rotate_deg(degrees)[source]

    
Add a rotation (in degrees) to this transform in place.

Returns self, so this method can easily be chained with more calls to
`rotate()`, `rotate_deg()`, `translate()` and `scale()`.

rotate_deg_around(x, y, degrees)[source]

    
Add a rotation (in degrees) around the point (x, y) in place.

Returns self, so this method can easily be chained with more calls to
`rotate()`, `rotate_deg()`, `translate()` and `scale()`.

scale(sx, sy=None)[source]

    
Add a scale in place.

If sy is None, the same scale is applied in both the x\- and y-directions.

Returns self, so this method can easily be chained with more calls to
`rotate()`, `rotate_deg()`, `translate()` and `scale()`.

set(other)[source]

    
Set this transformation from the frozen copy of another `Affine2DBase` object.

set_matrix(mtx)[source]

    
Set the underlying transformation matrix from a 3x3 numpy array:

    
    a c e
    b d f
    0 0 1
    
.

skew(xShear, yShear)[source]

    
Add a skew in place.

xShear and yShear are the shear angles along the x\- and y-axes, respectively,
in radians.

Returns self, so this method can easily be chained with more calls to
`rotate()`, `rotate_deg()`, `translate()` and `scale()`.

skew_deg(xShear, yShear)[source]

    
Add a skew in place.

xShear and yShear are the shear angles along the x\- and y-axes, respectively,
in degrees.

Returns self, so this method can easily be chained with more calls to
`rotate()`, `rotate_deg()`, `translate()` and `scale()`.

translate(tx, ty)[source]

    
Add a translation in place.

Returns self, so this method can easily be chained with more calls to
`rotate()`, `rotate_deg()`, `translate()` and `scale()`.

classmatplotlib.transforms.Affine2DBase(*args, **kwargs)[source]

    
Bases: `matplotlib.transforms.AffineBase`

The base class of all 2D affine transformations.

2D affine transformations are performed using a 3x3 numpy array:

    
    a c e
    b d f
    0 0 1
    
This class provides the read-only interface. For a mutable 2D affine
transformation, use `Affine2D`.

Subclasses of this class will generally only need to override a constructor
and `get_matrix()` that generates a custom 3x3 matrix.

Parameters

    
shorthand_namestr

    
A string representing the "name" of the transform. The name carries no
significance other than to improve the readability of `str(transform)` when
DEBUG=True.

__module__='matplotlib.transforms'

frozen()[source]

    
Return a frozen copy of this transform node. The frozen copy will not be
updated when its children change. Useful for storing a previously known state
of a transform where `copy.deepcopy()` might normally be used.

has_inverse=True

    
True if this transform has a corresponding inverse transform.

input_dims=2

    
The number of input dimensions of this transform. Must be overridden (with
integers) in the subclass.

inverted()[source]

    
Return the corresponding inverse transformation.

It holds `x == self.inverted().transform(self.transform(x))`.

The return value of this method should be treated as temporary. An update to
self does not cause a corresponding update to its inverted copy.

propertyis_separable

    
bool(x) -> bool

Returns True when the argument x is true, False otherwise. The builtins True
and False are the only two instances of the class bool. The class bool is a
subclass of the class int, and cannot be subclassed.

output_dims=2

    
The number of output dimensions of this transform. Must be overridden (with
integers) in the subclass.

to_values()[source]

    
Return the values of the matrix as an `(a, b, c, d, e, f)` tuple.

transform_affine(points)[source]

    
Apply only the affine part of this transformation on the given array of
values.

`transform(values)` is always equivalent to
`transform_affine(transform_non_affine(values))`.

In non-affine transformations, this is generally a no-op. In affine
transformations, this is equivalent to `transform(values)`.

Parameters

    
valuesarray

    
The input values as NumPy array of length `input_dims` or shape (N x
`input_dims`).

Returns

    
array

    
The output values as NumPy array of length `input_dims` or shape (N x
`output_dims`), depending on the input.

classmatplotlib.transforms.AffineBase(*args, **kwargs)[source]

    
Bases: `matplotlib.transforms.Transform`

The base class of all affine transformations of any number of dimensions.

Parameters

    
shorthand_namestr

    
A string representing the "name" of the transform. The name carries no
significance other than to improve the readability of `str(transform)` when
DEBUG=True.

__array__(*args, **kwargs)[source]

    
Array interface to get at this Transform's affine matrix.

__eq__(other)[source]

    
Return self==value.

__hash__=None

__init__(*args, **kwargs)[source]

    
Parameters

    
shorthand_namestr

    
A string representing the "name" of the transform. The name carries no
significance other than to improve the readability of `str(transform)` when
DEBUG=True.

__module__='matplotlib.transforms'

get_affine()[source]

    
Get the affine part of this transform.

is_affine=True

transform(values)[source]

    
Apply this transformation on the given array of values.

Parameters

    
valuesarray

    
The input values as NumPy array of length `input_dims` or shape (N x
`input_dims`).

Returns

    
array

    
The output values as NumPy array of length `input_dims` or shape (N x
`output_dims`), depending on the input.

transform_affine(values)[source]

    
Apply only the affine part of this transformation on the given array of
values.

`transform(values)` is always equivalent to
`transform_affine(transform_non_affine(values))`.

In non-affine transformations, this is generally a no-op. In affine
transformations, this is equivalent to `transform(values)`.

Parameters

    
valuesarray

    
The input values as NumPy array of length `input_dims` or shape (N x
`input_dims`).

Returns

    
array

    
The output values as NumPy array of length `input_dims` or shape (N x
`output_dims`), depending on the input.

transform_non_affine(points)[source]

    
Apply only the non-affine part of this transformation.

`transform(values)` is always equivalent to
`transform_affine(transform_non_affine(values))`.

In non-affine transformations, this is generally equivalent to
`transform(values)`. In affine transformations, this is always a no-op.

Parameters

    
valuesarray

    
The input values as NumPy array of length `input_dims` or shape (N x
`input_dims`).

Returns

    
array

    
The output values as NumPy array of length `input_dims` or shape (N x
`output_dims`), depending on the input.

transform_path(path)[source]

    
Apply the transform to `Path` path, returning a new `Path`.

In some cases, this transform may insert curves into the path that began as
line segments.

transform_path_affine(path)[source]

    
Apply the affine part of this transform to `Path` path, returning a new
`Path`.

`transform_path(path)` is equivalent to
`transform_path_affine(transform_path_non_affine(values))`.

transform_path_non_affine(path)[source]

    
Apply the non-affine part of this transform to `Path` path, returning a new
`Path`.

`transform_path(path)` is equivalent to
`transform_path_affine(transform_path_non_affine(values))`.

classmatplotlib.transforms.AffineDeltaTransform(transform, **kwargs)[source]

    
Bases: `matplotlib.transforms.Affine2DBase`

A transform wrapper for transforming displacements between pairs of points.

This class is intended to be used to transform displacements ("position
deltas") between pairs of points (e.g., as the `offset_transform` of
`Collection`s): given a transform `t` such that `t = AffineDeltaTransform(t) +
offset`, `AffineDeltaTransform` satisfies `AffineDeltaTransform(a - b) ==
AffineDeltaTransform(a) - AffineDeltaTransform(b)`.

This is implemented by forcing the offset components of the transform matrix
to zero.

This class is experimental as of 3.3, and the API may change.

Parameters

    
shorthand_namestr

    
A string representing the "name" of the transform. The name carries no
significance other than to improve the readability of `str(transform)` when
DEBUG=True.

__init__(transform, **kwargs)[source]

    
Parameters

    
shorthand_namestr

    
A string representing the "name" of the transform. The name carries no
significance other than to improve the readability of `str(transform)` when
DEBUG=True.

__module__='matplotlib.transforms'

__str__()[source]

    
Return str(self).

get_matrix()[source]

    
Get the matrix for the affine part of this transform.

classmatplotlib.transforms.Bbox(points, **kwargs)[source]

    
Bases: `matplotlib.transforms.BboxBase`

A mutable bounding box.

#### Examples

Create from known bounds

The default constructor takes the boundary "points" `[[xmin, ymin], [xmax,
ymax]]`.

    
    >>> Bbox([[1, 1], [3, 7]])
    Bbox([[1.0, 1.0], [3.0, 7.0]])
    
Alternatively, a Bbox can be created from the flattened points array, the so-
called "extents" `(xmin, ymin, xmax, ymax)`

    
    >>> Bbox.from_extents(1, 1, 3, 7)
    Bbox([[1.0, 1.0], [3.0, 7.0]])
    
or from the "bounds" `(xmin, ymin, width, height)`.

    
    >>> Bbox.from_bounds(1, 1, 2, 6)
    Bbox([[1.0, 1.0], [3.0, 7.0]])
    
Create from collections of points

The "empty" object for accumulating Bboxs is the null bbox, which is a stand-
in for the empty set.

    
    >>> Bbox.null()
    Bbox([[inf, inf], [-inf, -inf]])
    
Adding points to the null bbox will give you the bbox of those points.

    
    >>> box = Bbox.null()
    >>> box.update_from_data_xy([[1, 1]])
    >>> box
    Bbox([[1.0, 1.0], [1.0, 1.0]])
    >>> box.update_from_data_xy([[2, 3], [3, 2]], ignore=False)
    >>> box
    Bbox([[1.0, 1.0], [3.0, 3.0]])
    
Setting `ignore=True` is equivalent to starting over from a null bbox.

    
    >>> box.update_from_data_xy([[1, 1]], ignore=True)
    >>> box
    Bbox([[1.0, 1.0], [1.0, 1.0]])
    
Warning

It is recommended to always specify `ignore` explicitly. If not, the default
value of `ignore` can be changed at any time by code with access to your Bbox,
for example using the method `ignore`.

Properties of the ``null`` bbox

Note

The current behavior of `Bbox.null()` may be surprising as it does not have
all of the properties of the "empty set", and as such does not behave like a
"zero" object in the mathematical sense. We may change that in the future
(with a deprecation period).

The null bbox is the identity for intersections

    
    >>> Bbox.intersection(Bbox([[1, 1], [3, 7]]), Bbox.null())
    Bbox([[1.0, 1.0], [3.0, 7.0]])
    
except with itself, where it returns the full space.

    
    >>> Bbox.intersection(Bbox.null(), Bbox.null())
    Bbox([[-inf, -inf], [inf, inf]])
    
A union containing null will always return the full space (not the other set!)

    
    >>> Bbox.union([Bbox([[0, 0], [0, 0]]), Bbox.null()])
    Bbox([[-inf, -inf], [inf, inf]])
    
Parameters

    
pointsndarray

    
A 2x2 numpy array of the form `[[x0, y0], [x1, y1]]`.

__format__(fmt)[source]

    
Default object formatter.

__init__(points, **kwargs)[source]

    
Parameters

    
pointsndarray

    
A 2x2 numpy array of the form `[[x0, y0], [x1, y1]]`.

__module__='matplotlib.transforms'

__repr__()[source]

    
Return repr(self).

__str__()[source]

    
Return str(self).

propertybounds

    
Return (`x0`, `y0`, `width`, `height`).

staticfrom_bounds(x0, y0, width, height)[source]

    
Create a new `Bbox` from x0, y0, width and height.

width and height may be negative.

staticfrom_extents(*args, minpos=None)[source]

    
Create a new Bbox from left, bottom, right and top.

The y-axis increases upwards.

Parameters

    
left, bottom, right, topfloat

    
The four extents of the bounding box.

minposfloat or None

    
If this is supplied, the Bbox will have a minimum positive value set. This is
useful when dealing with logarithmic scales and other scales where negative
bounds result in floating point errors.

frozen()[source]

    
The base class for anything that participates in the transform tree and needs
to invalidate its parents or be invalidated. This includes classes that are
not really transforms, such as bounding boxes, since some transforms depend on
bounding boxes to compute their values.

get_points()[source]

    
Get the points of the bounding box directly as a numpy array of the form:
`[[x0, y0], [x1, y1]]`.

ignore(value)[source]

    
Set whether the existing bounds of the box should be ignored by subsequent
calls to `update_from_data_xy()`.

valuebool

    
  * When `True`, subsequent calls to `update_from_data_xy()` will ignore the existing bounds of the `Bbox`.
  * When `False`, subsequent calls to `update_from_data_xy()` will include the existing bounds of the `Bbox`.

propertyintervalx

    
The pair of x coordinates that define the bounding box.

This is not guaranteed to be sorted from left to right.

propertyintervaly

    
The pair of y coordinates that define the bounding box.

This is not guaranteed to be sorted from bottom to top.

propertyminpos

    
The minimum positive value in both directions within the Bbox.

This is useful when dealing with logarithmic scales and other scales where
negative bounds result in floating point errors, and will be used as the
minimum extent instead of p0.

propertyminposx

    
The minimum positive value in the x-direction within the Bbox.

This is useful when dealing with logarithmic scales and other scales where
negative bounds result in floating point errors, and will be used as the
minimum x-extent instead of x0.

propertyminposy

    
The minimum positive value in the y-direction within the Bbox.

This is useful when dealing with logarithmic scales and other scales where
negative bounds result in floating point errors, and will be used as the
minimum y-extent instead of y0.

mutated()[source]

    
Return whether the bbox has changed since init.

mutatedx()[source]

    
Return whether the x-limits have changed since init.

mutatedy()[source]

    
Return whether the y-limits have changed since init.

staticnull()[source]

    
Create a new null `Bbox` from (inf, inf) to (-inf, -inf).

propertyp0

    
The first pair of (x, y) coordinates that define the bounding box.

This is not guaranteed to be the bottom-left corner (for that, use `min`).

propertyp1

    
The second pair of (x, y) coordinates that define the bounding box.

This is not guaranteed to be the top-right corner (for that, use `max`).

set(other)[source]

    
Set this bounding box from the "frozen" bounds of another `Bbox`.

set_points(points)[source]

    
Set the points of the bounding box directly from a numpy array of the form:
`[[x0, y0], [x1, y1]]`. No error checking is performed, as this method is
mainly for internal use.

staticunit()[source]

    
Create a new unit `Bbox` from (0, 0) to (1, 1).

update_from_data_x(x, ignore=None)[source]

    
Update the x-bounds of the `Bbox` based on the passed in data. After updating,
the bounds will have positive width, and x0 will be the minimal value.

Parameters

    
xndarray

    
Array of x-values.

ignorebool, optional

    
  * When `True`, ignore the existing bounds of the `Bbox`.
  * When `False`, include the existing bounds of the `Bbox`.
  * When `None`, use the last value passed to `ignore()`.

update_from_data_xy(xy, ignore=None, updatex=True, updatey=True)[source]

    
Update the bounds of the `Bbox` based on the passed in data. After updating,
the bounds will have positive width and height; x0 and y0 will be the minimal
values.

Parameters

    
xyndarray

    
A numpy array of 2D points.

ignorebool, optional

    
  * When `True`, ignore the existing bounds of the `Bbox`.
  * When `False`, include the existing bounds of the `Bbox`.
  * When `None`, use the last value passed to `ignore()`.

updatex, updateybool, default: True

    
When `True`, update the x/y values.

update_from_data_y(y, ignore=None)[source]

    
Update the y-bounds of the `Bbox` based on the passed in data. After updating,
the bounds will have positive height, and y0 will be the minimal value.

Parameters

    
yndarray

    
Array of y-values.

ignorebool, optional

    
  * When `True`, ignore the existing bounds of the `Bbox`.
  * When `False`, include the existing bounds of the `Bbox`.
  * When `None`, use the last value passed to `ignore()`.

update_from_path(path, ignore=None, updatex=True, updatey=True)[source]

    
Update the bounds of the `Bbox` to contain the vertices of the provided path.
After updating, the bounds will have positive width and height; x0 and y0 will
be the minimal values.

Parameters

    
path`Path`

ignorebool, optional

    
  * when `True`, ignore the existing bounds of the `Bbox`.
  * when `False`, include the existing bounds of the `Bbox`.
  * when `None`, use the last value passed to `ignore()`.

updatex, updateybool, default: True

    
When `True`, update the x/y values.

propertyx0

    
The first of the pair of x coordinates that define the bounding box.

This is not guaranteed to be less than `x1` (for that, use `xmin`).

propertyx1

    
The second of the pair of x coordinates that define the bounding box.

This is not guaranteed to be greater than `x0` (for that, use `xmax`).

propertyy0

    
The first of the pair of y coordinates that define the bounding box.

This is not guaranteed to be less than `y1` (for that, use `ymin`).

propertyy1

    
The second of the pair of y coordinates that define the bounding box.

This is not guaranteed to be greater than `y0` (for that, use `ymax`).

classmatplotlib.transforms.BboxBase(shorthand_name=None)[source]

    
Bases: `matplotlib.transforms.TransformNode`

The base class of all bounding boxes.

This class is immutable; `Bbox` is a mutable subclass.

The canonical representation is as two points, with no restrictions on their
ordering. Convenience properties are provided to get the left, bottom, right
and top edges and width and height, but these are not stored explicitly.

Parameters

    
shorthand_namestr

    
A string representing the "name" of the transform. The name carries no
significance other than to improve the readability of `str(transform)` when
DEBUG=True.

__array__(*args, **kwargs)[source]

__module__='matplotlib.transforms'

anchored(c, container=None)[source]

    
Return a copy of the `Bbox` anchored to c within container.

Parameters

    
c(float, float) or {'C', 'SW', 'S', 'SE', 'E', 'NE', ...}

    
Either an (x, y) pair of relative coordinates (0 is left or bottom, 1 is right
or top), 'C' (center), or a cardinal direction ('SW', southwest, is bottom
left, etc.).

container`Bbox`, optional

    
The box within which the `Bbox` is positioned; it defaults to the initial
`Bbox`.

See also

`Axes.set_anchor`

propertybounds

    
Return (`x0`, `y0`, `width`, `height`).

coefs={'C': (0.5, 0.5), 'E': (1.0, 0.5), 'N': (0.5, 1.0), 'NE': (1.0, 1.0),
'NW': (0, 1.0), 'S': (0.5, 0), 'SE': (1.0, 0), 'SW': (0, 0), 'W': (0, 0.5)}

contains(x, y)[source]

    
Return whether `(x, y)` is in the bounding box or on its edge.

containsx(x)[source]

    
Return whether x is in the closed (`x0`, `x1`) interval.

containsy(y)[source]

    
Return whether y is in the closed (`y0`, `y1`) interval.

corners()[source]

    
Return the corners of this rectangle as an array of points.

Specifically, this returns the array `[[x0, y0], [x0, y1], [x1, y0], [x1,
y1]]`.

count_contains(vertices)[source]

    
Count the number of vertices contained in the `Bbox`. Any vertices with a non-
finite x or y value are ignored.

Parameters

    
verticesNx2 Numpy array.

count_overlaps(bboxes)[source]

    
Count the number of bounding boxes that overlap this one.

Parameters

    
bboxessequence of `BboxBase`

expanded(sw, sh)[source]

    
Construct a `Bbox` by expanding this one around its center by the factors sw
and sh.

propertyextents

    
Return (`x0`, `y0`, `x1`, `y1`).

frozen()[source]

    
The base class for anything that participates in the transform tree and needs
to invalidate its parents or be invalidated. This includes classes that are
not really transforms, such as bounding boxes, since some transforms depend on
bounding boxes to compute their values.

fully_contains(x, y)[source]

    
Return whether `x, y` is in the bounding box, but not on its edge.

fully_containsx(x)[source]

    
Return whether x is in the open (`x0`, `x1`) interval.

fully_containsy(y)[source]

    
Return whether y is in the open (`y0`, `y1`) interval.

fully_overlaps(other)[source]

    
Return whether this bounding box overlaps with the other bounding box, not
including the edges.

Parameters

    
other`BboxBase`

get_points()[source]

propertyheight

    
The (signed) height of the bounding box.

staticintersection(bbox1, bbox2)[source]

    
Return the intersection of bbox1 and bbox2 if they intersect, or None if they
don't.

propertyintervalx

    
The pair of x coordinates that define the bounding box.

This is not guaranteed to be sorted from left to right.

propertyintervaly

    
The pair of y coordinates that define the bounding box.

This is not guaranteed to be sorted from bottom to top.

is_affine=True

is_bbox=True

propertymax

    
The top-right corner of the bounding box.

propertymin

    
The bottom-left corner of the bounding box.

overlaps(other)[source]

    
Return whether this bounding box overlaps with the other bounding box.

Parameters

    
other`BboxBase`

propertyp0

    
The first pair of (x, y) coordinates that define the bounding box.

This is not guaranteed to be the bottom-left corner (for that, use `min`).

propertyp1

    
The second pair of (x, y) coordinates that define the bounding box.

This is not guaranteed to be the top-right corner (for that, use `max`).

padded(p)[source]

    
Construct a `Bbox` by padding this one on all four sides by p.

rotated(radians)[source]

    
Return the axes-aligned bounding box that bounds the result of rotating this
`Bbox` by an angle of radians.

shrunk(mx, my)[source]

    
Return a copy of the `Bbox`, shrunk by the factor mx in the x direction and
the factor my in the y direction. The lower left corner of the box remains
unchanged. Normally mx and my will be less than 1, but this is not enforced.

shrunk_to_aspect(box_aspect, container=None, fig_aspect=1.0)[source]

    
Return a copy of the `Bbox`, shrunk so that it is as large as it can be while
having the desired aspect ratio, box_aspect. If the box coordinates are
relative (i.e. fractions of a larger box such as a figure) then the physical
aspect ratio of that figure is specified with fig_aspect, so that box_aspect
can also be given as a ratio of the absolute dimensions, not the relative
dimensions.

propertysize

    
The (signed) width and height of the bounding box.

splitx(*args)[source]

    
Return a list of new `Bbox` objects formed by splitting the original one with
vertical lines at fractional positions given by args.

splity(*args)[source]

    
Return a list of new `Bbox` objects formed by splitting the original one with
horizontal lines at fractional positions given by args.

transformed(transform)[source]

    
Construct a `Bbox` by statically transforming this one by transform.

translated(tx, ty)[source]

    
Construct a `Bbox` by translating this one by tx and ty.

staticunion(bboxes)[source]

    
Return a `Bbox` that contains all of the given bboxes.

propertywidth

    
The (signed) width of the bounding box.

propertyx0

    
The first of the pair of x coordinates that define the bounding box.

This is not guaranteed to be less than `x1` (for that, use `xmin`).

propertyx1

    
The second of the pair of x coordinates that define the bounding box.

This is not guaranteed to be greater than `x0` (for that, use `xmax`).

propertyxmax

    
The right edge of the bounding box.

propertyxmin

    
The left edge of the bounding box.

propertyy0

    
The first of the pair of y coordinates that define the bounding box.

This is not guaranteed to be less than `y1` (for that, use `ymin`).

propertyy1

    
The second of the pair of y coordinates that define the bounding box.

This is not guaranteed to be greater than `y0` (for that, use `ymax`).

propertyymax

    
The top edge of the bounding box.

propertyymin

    
The bottom edge of the bounding box.

classmatplotlib.transforms.BboxTransform(boxin, boxout, **kwargs)[source]

    
Bases: `matplotlib.transforms.Affine2DBase`

`BboxTransform` linearly transforms points from one `Bbox` to another.

Create a new `BboxTransform` that linearly transforms points from boxin to
boxout.

__init__(boxin, boxout, **kwargs)[source]

    
Create a new `BboxTransform` that linearly transforms points from boxin to
boxout.

__module__='matplotlib.transforms'

__str__()[source]

    
Return str(self).

get_matrix()[source]

    
Get the matrix for the affine part of this transform.

is_separable=True

    
True if this transform is separable in the x- and y- dimensions.

classmatplotlib.transforms.BboxTransformFrom(boxin, **kwargs)[source]

    
Bases: `matplotlib.transforms.Affine2DBase`

`BboxTransformFrom` linearly transforms points from a given `Bbox` to the unit
bounding box.

Parameters

    
shorthand_namestr

    
A string representing the "name" of the transform. The name carries no
significance other than to improve the readability of `str(transform)` when
DEBUG=True.

__init__(boxin, **kwargs)[source]

    
Parameters

    
shorthand_namestr

    
A string representing the "name" of the transform. The name carries no
significance other than to improve the readability of `str(transform)` when
DEBUG=True.

__module__='matplotlib.transforms'

__str__()[source]

    
Return str(self).

get_matrix()[source]

    
Get the matrix for the affine part of this transform.

is_separable=True

    
True if this transform is separable in the x- and y- dimensions.

classmatplotlib.transforms.BboxTransformTo(boxout, **kwargs)[source]

    
Bases: `matplotlib.transforms.Affine2DBase`

`BboxTransformTo` is a transformation that linearly transforms points from the
unit bounding box to a given `Bbox`.

Create a new `BboxTransformTo` that linearly transforms points from the unit
bounding box to boxout.

__init__(boxout, **kwargs)[source]

    
Create a new `BboxTransformTo` that linearly transforms points from the unit
bounding box to boxout.

__module__='matplotlib.transforms'

__str__()[source]

    
Return str(self).

get_matrix()[source]

    
Get the matrix for the affine part of this transform.

is_separable=True

    
True if this transform is separable in the x- and y- dimensions.

classmatplotlib.transforms.BboxTransformToMaxOnly(boxout, **kwargs)[source]

    
Bases: `matplotlib.transforms.BboxTransformTo`

`BboxTransformTo` is a transformation that linearly transforms points from the
unit bounding box to a given `Bbox` with a fixed upper left of (0, 0).

Create a new `BboxTransformTo` that linearly transforms points from the unit
bounding box to boxout.

__module__='matplotlib.transforms'

get_matrix()[source]

    
Get the matrix for the affine part of this transform.

classmatplotlib.transforms.BlendedAffine2D(x_transform, y_transform,
**kwargs)[source]

    
Bases: `matplotlib.transforms._BlendedMixin`,
`matplotlib.transforms.Affine2DBase`

A "blended" transform uses one transform for the x-direction, and another
transform for the y-direction.

This version is an optimization for the case where both child transforms are
of type `Affine2DBase`.

Create a new "blended" transform using x_transform to transform the x-axis and
y_transform to transform the y-axis.

Both x_transform and y_transform must be 2D affine transforms.

You will generally not call this constructor directly but use the
`blended_transform_factory` function instead, which can determine
automatically which kind of blended transform to create.

__init__(x_transform, y_transform, **kwargs)[source]

    
Create a new "blended" transform using x_transform to transform the x-axis and
y_transform to transform the y-axis.

Both x_transform and y_transform must be 2D affine transforms.

You will generally not call this constructor directly but use the
`blended_transform_factory` function instead, which can determine
automatically which kind of blended transform to create.

__module__='matplotlib.transforms'

get_matrix()[source]

    
Get the matrix for the affine part of this transform.

is_separable=True

    
True if this transform is separable in the x- and y- dimensions.

classmatplotlib.transforms.BlendedGenericTransform(x_transform, y_transform,
**kwargs)[source]

    
Bases: `matplotlib.transforms._BlendedMixin`,
`matplotlib.transforms.Transform`

A "blended" transform uses one transform for the x-direction, and another
transform for the y-direction.

This "generic" version can handle any given child transform in the x\- and
y-directions.

Create a new "blended" transform using x_transform to transform the x-axis and
y_transform to transform the y-axis.

You will generally not call this constructor directly but use the
`blended_transform_factory` function instead, which can determine
automatically which kind of blended transform to create.

__init__(x_transform, y_transform, **kwargs)[source]

    
Create a new "blended" transform using x_transform to transform the x-axis and
y_transform to transform the y-axis.

You will generally not call this constructor directly but use the
`blended_transform_factory` function instead, which can determine
automatically which kind of blended transform to create.

__module__='matplotlib.transforms'

contains_branch(other)[source]

    
Return whether the given transform is a sub-tree of this transform.

This routine uses transform equality to identify sub-trees, therefore in many
situations it is object id which will be used.

For the case where the given transform represents the whole of this transform,
returns True.

propertydepth

    
Return the number of transforms which have been chained together to form this
Transform instance.

Note

For the special case of a Composite transform, the maximum depth of the two is
returned.

frozen()[source]

    
Return a frozen copy of this transform node. The frozen copy will not be
updated when its children change. Useful for storing a previously known state
of a transform where `copy.deepcopy()` might normally be used.

get_affine()[source]

    
Get the affine part of this transform.

propertyhas_inverse

    
bool(x) -> bool

Returns True when the argument x is true, False otherwise. The builtins True
and False are the only two instances of the class bool. The class bool is a
subclass of the class int, and cannot be subclassed.

input_dims=2

    
The number of input dimensions of this transform. Must be overridden (with
integers) in the subclass.

inverted()[source]

    
Return the corresponding inverse transformation.

It holds `x == self.inverted().transform(self.transform(x))`.

The return value of this method should be treated as temporary. An update to
self does not cause a corresponding update to its inverted copy.

propertyis_affine

    
bool(x) -> bool

Returns True when the argument x is true, False otherwise. The builtins True
and False are the only two instances of the class bool. The class bool is a
subclass of the class int, and cannot be subclassed.

is_separable=True

    
True if this transform is separable in the x- and y- dimensions.

output_dims=2

    
The number of output dimensions of this transform. Must be overridden (with
integers) in the subclass.

pass_through=True

    
If pass_through is True, all ancestors will always be invalidated, even if
'self' is already invalid.

transform_non_affine(points)[source]

    
Apply only the non-affine part of this transformation.

`transform(values)` is always equivalent to
`transform_affine(transform_non_affine(values))`.

In non-affine transformations, this is generally equivalent to
`transform(values)`. In affine transformations, this is always a no-op.

Parameters

    
valuesarray

    
The input values as NumPy array of length `input_dims` or shape (N x
`input_dims`).

Returns

    
array

    
The output values as NumPy array of length `input_dims` or shape (N x
`output_dims`), depending on the input.

classmatplotlib.transforms.CompositeAffine2D(a, b, **kwargs)[source]

    
Bases: `matplotlib.transforms.Affine2DBase`

A composite transform formed by applying transform a then transform b.

This version is an optimization that handles the case where both a and b are
2D affines.

Create a new composite transform that is the result of applying `Affine2DBase`
a then `Affine2DBase` b.

You will generally not call this constructor directly but write `a + b`
instead, which will automatically choose the best kind of composite transform
instance to create.

__init__(a, b, **kwargs)[source]

    
Create a new composite transform that is the result of applying `Affine2DBase`
a then `Affine2DBase` b.

You will generally not call this constructor directly but write `a + b`
instead, which will automatically choose the best kind of composite transform
instance to create.

__module__='matplotlib.transforms'

__str__()[source]

    
Return str(self).

propertydepth

    
Return the number of transforms which have been chained together to form this
Transform instance.

Note

For the special case of a Composite transform, the maximum depth of the two is
returned.

get_matrix()[source]

    
Get the matrix for the affine part of this transform.

classmatplotlib.transforms.CompositeGenericTransform(a, b, **kwargs)[source]

    
Bases: `matplotlib.transforms.Transform`

A composite transform formed by applying transform a then transform b.

This "generic" version can handle any two arbitrary transformations.

Create a new composite transform that is the result of applying transform a
then transform b.

You will generally not call this constructor directly but write `a + b`
instead, which will automatically choose the best kind of composite transform
instance to create.

__eq__(other)[source]

    
Return self==value.

__hash__=None

__init__(a, b, **kwargs)[source]

    
Create a new composite transform that is the result of applying transform a
then transform b.

You will generally not call this constructor directly but write `a + b`
instead, which will automatically choose the best kind of composite transform
instance to create.

__module__='matplotlib.transforms'

__str__()[source]

    
Return str(self).

propertydepth

    
Return the number of transforms which have been chained together to form this
Transform instance.

Note

For the special case of a Composite transform, the maximum depth of the two is
returned.

frozen()[source]

    
Return a frozen copy of this transform node. The frozen copy will not be
updated when its children change. Useful for storing a previously known state
of a transform where `copy.deepcopy()` might normally be used.

get_affine()[source]

    
Get the affine part of this transform.

propertyhas_inverse

    
bool(x) -> bool

Returns True when the argument x is true, False otherwise. The builtins True
and False are the only two instances of the class bool. The class bool is a
subclass of the class int, and cannot be subclassed.

inverted()[source]

    
Return the corresponding inverse transformation.

It holds `x == self.inverted().transform(self.transform(x))`.

The return value of this method should be treated as temporary. An update to
self does not cause a corresponding update to its inverted copy.

propertyis_affine

    
bool(x) -> bool

Returns True when the argument x is true, False otherwise. The builtins True
and False are the only two instances of the class bool. The class bool is a
subclass of the class int, and cannot be subclassed.

propertyis_separable

    
bool(x) -> bool

Returns True when the argument x is true, False otherwise. The builtins True
and False are the only two instances of the class bool. The class bool is a
subclass of the class int, and cannot be subclassed.

pass_through=True

    
If pass_through is True, all ancestors will always be invalidated, even if
'self' is already invalid.

transform_affine(points)[source]

    
Apply only the affine part of this transformation on the given array of
values.

`transform(values)` is always equivalent to
`transform_affine(transform_non_affine(values))`.

In non-affine transformations, this is generally a no-op. In affine
transformations, this is equivalent to `transform(values)`.

Parameters

    
valuesarray

    
The input values as NumPy array of length `input_dims` or shape (N x
`input_dims`).

Returns

    
array

    
The output values as NumPy array of length `input_dims` or shape (N x
`output_dims`), depending on the input.

transform_non_affine(points)[source]

    
Apply only the non-affine part of this transformation.

`transform(values)` is always equivalent to
`transform_affine(transform_non_affine(values))`.

In non-affine transformations, this is generally equivalent to
`transform(values)`. In affine transformations, this is always a no-op.

Parameters

    
valuesarray

    
The input values as NumPy array of length `input_dims` or shape (N x
`input_dims`).

Returns

    
array

    
The output values as NumPy array of length `input_dims` or shape (N x
`output_dims`), depending on the input.

transform_path_non_affine(path)[source]

    
Apply the non-affine part of this transform to `Path` path, returning a new
`Path`.

`transform_path(path)` is equivalent to
`transform_path_affine(transform_path_non_affine(values))`.

classmatplotlib.transforms.IdentityTransform(*args, **kwargs)[source]

    
Bases: `matplotlib.transforms.Affine2DBase`

A special class that does one thing, the identity transform, in a fast way.

Parameters

    
shorthand_namestr

    
A string representing the "name" of the transform. The name carries no
significance other than to improve the readability of `str(transform)` when
DEBUG=True.

__module__='matplotlib.transforms'

__str__()[source]

    
Return str(self).

frozen()[source]

    
Return a frozen copy of this transform node. The frozen copy will not be
updated when its children change. Useful for storing a previously known state
of a transform where `copy.deepcopy()` might normally be used.

get_affine()[source]

    
Get the affine part of this transform.

get_matrix()[source]

    
Get the matrix for the affine part of this transform.

inverted()[source]

    
Return the corresponding inverse transformation.

It holds `x == self.inverted().transform(self.transform(x))`.

The return value of this method should be treated as temporary. An update to
self does not cause a corresponding update to its inverted copy.

transform(points)[source]

    
Apply this transformation on the given array of values.

Parameters

    
valuesarray

    
The input values as NumPy array of length `input_dims` or shape (N x
`input_dims`).

Returns

    
array

    
The output values as NumPy array of length `input_dims` or shape (N x
`output_dims`), depending on the input.

transform_affine(points)[source]

    
Apply only the affine part of this transformation on the given array of
values.

`transform(values)` is always equivalent to
`transform_affine(transform_non_affine(values))`.

In non-affine transformations, this is generally a no-op. In affine
transformations, this is equivalent to `transform(values)`.

Parameters

    
valuesarray

    
The input values as NumPy array of length `input_dims` or shape (N x
`input_dims`).

Returns

    
array

    
The output values as NumPy array of length `input_dims` or shape (N x
`output_dims`), depending on the input.

transform_non_affine(points)[source]

    
Apply only the non-affine part of this transformation.

`transform(values)` is always equivalent to
`transform_affine(transform_non_affine(values))`.

In non-affine transformations, this is generally equivalent to
`transform(values)`. In affine transformations, this is always a no-op.

Parameters

    
valuesarray

    
The input values as NumPy array of length `input_dims` or shape (N x
`input_dims`).

Returns

    
array

    
The output values as NumPy array of length `input_dims` or shape (N x
`output_dims`), depending on the input.

transform_path(path)[source]

    
Apply the transform to `Path` path, returning a new `Path`.

In some cases, this transform may insert curves into the path that began as
line segments.

transform_path_affine(path)[source]

    
Apply the affine part of this transform to `Path` path, returning a new
`Path`.

`transform_path(path)` is equivalent to
`transform_path_affine(transform_path_non_affine(values))`.

transform_path_non_affine(path)[source]

    
Apply the non-affine part of this transform to `Path` path, returning a new
`Path`.

`transform_path(path)` is equivalent to
`transform_path_affine(transform_path_non_affine(values))`.

classmatplotlib.transforms.LockableBbox(bbox, x0=None, y0=None, x1=None,
y1=None, **kwargs)[source]

    
Bases: `matplotlib.transforms.BboxBase`

A `Bbox` where some elements may be locked at certain values.

When the child bounding box changes, the bounds of this bbox will update
accordingly with the exception of the locked elements.

Parameters

    
bbox`Bbox`

    
The child bounding box to wrap.

x0float or None

    
The locked value for x0, or None to leave unlocked.

y0float or None

    
The locked value for y0, or None to leave unlocked.

x1float or None

    
The locked value for x1, or None to leave unlocked.

y1float or None

    
The locked value for y1, or None to leave unlocked.

__init__(bbox, x0=None, y0=None, x1=None, y1=None, **kwargs)[source]

    
Parameters

    
bbox`Bbox`

    
The child bounding box to wrap.

x0float or None

    
The locked value for x0, or None to leave unlocked.

y0float or None

    
The locked value for y0, or None to leave unlocked.

x1float or None

    
The locked value for x1, or None to leave unlocked.

y1float or None

    
The locked value for y1, or None to leave unlocked.

__module__='matplotlib.transforms'

__str__()[source]

    
Return str(self).

get_points()[source]

propertylocked_x0

    
float or None: The value used for the locked x0.

propertylocked_x1

    
float or None: The value used for the locked x1.

propertylocked_y0

    
float or None: The value used for the locked y0.

propertylocked_y1

    
float or None: The value used for the locked y1.

classmatplotlib.transforms.ScaledTranslation(xt, yt, scale_trans,
**kwargs)[source]

    
Bases: `matplotlib.transforms.Affine2DBase`

A transformation that translates by xt and yt, after xt and yt have been
transformed by scale_trans.

Parameters

    
shorthand_namestr

    
A string representing the "name" of the transform. The name carries no
significance other than to improve the readability of `str(transform)` when
DEBUG=True.

__init__(xt, yt, scale_trans, **kwargs)[source]

    
Parameters

    
shorthand_namestr

    
A string representing the "name" of the transform. The name carries no
significance other than to improve the readability of `str(transform)` when
DEBUG=True.

__module__='matplotlib.transforms'

__str__()[source]

    
Return str(self).

get_matrix()[source]

    
Get the matrix for the affine part of this transform.

classmatplotlib.transforms.Transform(shorthand_name=None)[source]

    
Bases: `matplotlib.transforms.TransformNode`

The base class of all `TransformNode` instances that actually perform a
transformation.

All non-affine transformations should be subclasses of this class. New affine
transformations should be subclasses of `Affine2D`.

Subclasses of this class should override the following members (at minimum):

  * `input_dims`
  * `output_dims`
  * `transform()`
  * `inverted()` (if an inverse exists)

The following attributes may be overridden if the default is unsuitable:

  * `is_separable` (defaults to True for 1D -> 1D transforms, False otherwise)
  * `has_inverse` (defaults to True if `inverted()` is overridden, False otherwise)

If the transform needs to do something non-standard with
`matplotlib.path.Path` objects, such as adding curves where there were once
line segments, it should override:

  * `transform_path()`

Parameters

    
shorthand_namestr

    
A string representing the "name" of the transform. The name carries no
significance other than to improve the readability of `str(transform)` when
DEBUG=True.

__add__(other)[source]

    
Compose two transforms together so that self is followed by other.

`A + B` returns a transform `C` so that `C.transform(x) ==
B.transform(A.transform(x))`.

__array__(*args, **kwargs)[source]

    
Array interface to get at this Transform's affine matrix.

classmethod__init_subclass__()[source]

    
This method is called when a class is subclassed.

The default implementation does nothing. It may be overridden to extend
subclasses.

__module__='matplotlib.transforms'

__sub__(other)[source]

    
Compose self with the inverse of other, cancelling identical terms if any:

    
    # In general:
    A - B == A + B.inverted()
    # (but see note regarding frozen transforms below).
    
    # If A "ends with" B (i.e. A == A' + B for some A') we can cancel
    # out B:
    (A' + B) - B == A'
    
    # Likewise, if B "starts with" A (B = A + B'), we can cancel out A:
    A - (A + B') == B'.inverted() == B'^-1
    
Cancellation (rather than naively returning `A + B.inverted()`) is important
for multiple reasons:

  * It avoids floating-point inaccuracies when computing the inverse of B: `B - B` is guaranteed to cancel out exactly (resulting in the identity transform), whereas `B + B.inverted()` may differ by a small epsilon.
  * `B.inverted()` always returns a frozen transform: if one computes `A + B + B.inverted()` and later mutates `B`, then `B.inverted()` won't be updated and the last two terms won't cancel out anymore; on the other hand, `A + B - B` will always be equal to `A` even if `B` is mutated.

contains_branch(other)[source]

    
Return whether the given transform is a sub-tree of this transform.

This routine uses transform equality to identify sub-trees, therefore in many
situations it is object id which will be used.

For the case where the given transform represents the whole of this transform,
returns True.

contains_branch_seperately(other_transform)[source]

    
Return whether the given branch is a sub-tree of this transform on each
separate dimension.

A common use for this method is to identify if a transform is a blended
transform containing an axes' data transform. e.g.:

    
    x_isdata, y_isdata = trans.contains_branch_seperately(ax.transData)
    
propertydepth

    
Return the number of transforms which have been chained together to form this
Transform instance.

Note

For the special case of a Composite transform, the maximum depth of the two is
returned.

get_affine()[source]

    
Get the affine part of this transform.

get_matrix()[source]

    
Get the matrix for the affine part of this transform.

has_inverse=False

    
True if this transform has a corresponding inverse transform.

input_dims=None

    
The number of input dimensions of this transform. Must be overridden (with
integers) in the subclass.

inverted()[source]

    
Return the corresponding inverse transformation.

It holds `x == self.inverted().transform(self.transform(x))`.

The return value of this method should be treated as temporary. An update to
self does not cause a corresponding update to its inverted copy.

is_separable=False

    
True if this transform is separable in the x- and y- dimensions.

output_dims=None

    
The number of output dimensions of this transform. Must be overridden (with
integers) in the subclass.

transform(values)[source]

    
Apply this transformation on the given array of values.

Parameters

    
valuesarray

    
The input values as NumPy array of length `input_dims` or shape (N x
`input_dims`).

Returns

    
array

    
The output values as NumPy array of length `input_dims` or shape (N x
`output_dims`), depending on the input.

transform_affine(values)[source]

    
Apply only the affine part of this transformation on the given array of
values.

`transform(values)` is always equivalent to
`transform_affine(transform_non_affine(values))`.

In non-affine transformations, this is generally a no-op. In affine
transformations, this is equivalent to `transform(values)`.

Parameters

    
valuesarray

    
The input values as NumPy array of length `input_dims` or shape (N x
`input_dims`).

Returns

    
array

    
The output values as NumPy array of length `input_dims` or shape (N x
`output_dims`), depending on the input.

transform_angles(angles, pts, radians=False, pushoff=1e-05)[source]

    
Transform a set of angles anchored at specific locations.

Parameters

    
angles(N,) array-like

    
The angles to transform.

pts(N, 2) array-like

    
The points where the angles are anchored.

radiansbool, default: False

    
Whether angles are radians or degrees.

pushofffloat

    
For each point in pts and angle in angles, the transformed angle is computed
by transforming a segment of length pushoff starting at that point and making
that angle relative to the horizontal axis, and measuring the angle between
the horizontal axis and the transformed segment.

Returns

    
(N,) array

transform_bbox(bbox)[source]

    
Transform the given bounding box.

For smarter transforms including caching (a common requirement in Matplotlib),
see `TransformedBbox`.

transform_non_affine(values)[source]

    
Apply only the non-affine part of this transformation.

`transform(values)` is always equivalent to
`transform_affine(transform_non_affine(values))`.

In non-affine transformations, this is generally equivalent to
`transform(values)`. In affine transformations, this is always a no-op.

Parameters

    
valuesarray

    
The input values as NumPy array of length `input_dims` or shape (N x
`input_dims`).

Returns

    
array

    
The output values as NumPy array of length `input_dims` or shape (N x
`output_dims`), depending on the input.

transform_path(path)[source]

    
Apply the transform to `Path` path, returning a new `Path`.

In some cases, this transform may insert curves into the path that began as
line segments.

transform_path_affine(path)[source]

    
Apply the affine part of this transform to `Path` path, returning a new
`Path`.

`transform_path(path)` is equivalent to
`transform_path_affine(transform_path_non_affine(values))`.

transform_path_non_affine(path)[source]

    
Apply the non-affine part of this transform to `Path` path, returning a new
`Path`.

`transform_path(path)` is equivalent to
`transform_path_affine(transform_path_non_affine(values))`.

transform_point(point)[source]

    
Return a transformed point.

This function is only kept for backcompatibility; the more general `transform`
method is capable of transforming both a list of points and a single point.

The point is given as a sequence of length `input_dims`. The transformed point
is returned as a sequence of length `output_dims`.

classmatplotlib.transforms.TransformNode(shorthand_name=None)[source]

    
Bases: `object`

The base class for anything that participates in the transform tree and needs
to invalidate its parents or be invalidated. This includes classes that are
not really transforms, such as bounding boxes, since some transforms depend on
bounding boxes to compute their values.

Parameters

    
shorthand_namestr

    
A string representing the "name" of the transform. The name carries no
significance other than to improve the readability of `str(transform)` when
DEBUG=True.

INVALID=3

INVALID_AFFINE=2

INVALID_NON_AFFINE=1

__copy__()[source]

__deepcopy__(memo)[source]

__dict__=mappingproxy({'__module__': 'matplotlib.transforms', '__doc__': '\n
The base class for anything that participates in the transform tree\n and
needs to invalidate its parents or be invalidated. This includes\n classes
that are not really transforms, such as bounding boxes, since some\n
transforms depend on bounding boxes to compute their values.\n ',
'INVALID_NON_AFFINE': 1, 'INVALID_AFFINE': 2, 'INVALID': 3, 'is_affine':
False, 'is_bbox': False, 'pass_through': False, '__init__': <function
TransformNode.__init__>, '__getstate__': <function
TransformNode.__getstate__>, '__setstate__': <function
TransformNode.__setstate__>, '__copy__': <function TransformNode.__copy__>,
'__deepcopy__': <function TransformNode.__deepcopy__>, 'invalidate': <function
TransformNode.invalidate>, '_invalidate_internal': <function
TransformNode._invalidate_internal>, 'set_children': <function
TransformNode.set_children>, 'frozen': <function TransformNode.frozen>,
'__dict__': <attribute '__dict__' of 'TransformNode' objects>, '__weakref__':
<attribute '__weakref__' of 'TransformNode' objects>, '__annotations__': {}})

__getstate__()[source]

__init__(shorthand_name=None)[source]

    
Parameters

    
shorthand_namestr

    
A string representing the "name" of the transform. The name carries no
significance other than to improve the readability of `str(transform)` when
DEBUG=True.

__module__='matplotlib.transforms'

__setstate__(data_dict)[source]

__weakref__

    
list of weak references to the object (if defined)

frozen()[source]

    
Return a frozen copy of this transform node. The frozen copy will not be
updated when its children change. Useful for storing a previously known state
of a transform where `copy.deepcopy()` might normally be used.

invalidate()[source]

    
Invalidate this `TransformNode` and triggers an invalidation of its ancestors.
Should be called any time the transform changes.

is_affine=False

is_bbox=False

pass_through=False

    
If pass_through is True, all ancestors will always be invalidated, even if
'self' is already invalid.

set_children(*children)[source]

    
Set the children of the transform, to let the invalidation system know which
transforms can invalidate this transform. Should be called from the
constructor of any transforms that depend on other transforms.

classmatplotlib.transforms.TransformWrapper(child)[source]

    
Bases: `matplotlib.transforms.Transform`

A helper class that holds a single child transform and acts equivalently to
it.

This is useful if a node of the transform tree must be replaced at run time
with a transform of a different type. This class allows that replacement to
correctly trigger invalidation.

`TransformWrapper` instances must have the same input and output dimensions
during their entire lifetime, so the child transform may only be replaced with
another child transform of the same dimensions.

child: A `Transform` instance. This child may later be replaced with `set()`.

__eq__(other)[source]

    
Return self==value.

__hash__=None

__init__(child)[source]

    
child: A `Transform` instance. This child may later be replaced with `set()`.

__module__='matplotlib.transforms'

__str__()[source]

    
Return str(self).

frozen()[source]

    
Return a frozen copy of this transform node. The frozen copy will not be
updated when its children change. Useful for storing a previously known state
of a transform where `copy.deepcopy()` might normally be used.

propertyhas_inverse

    
bool(x) -> bool

Returns True when the argument x is true, False otherwise. The builtins True
and False are the only two instances of the class bool. The class bool is a
subclass of the class int, and cannot be subclassed.

propertyis_affine

    
bool(x) -> bool

Returns True when the argument x is true, False otherwise. The builtins True
and False are the only two instances of the class bool. The class bool is a
subclass of the class int, and cannot be subclassed.

propertyis_separable

    
bool(x) -> bool

Returns True when the argument x is true, False otherwise. The builtins True
and False are the only two instances of the class bool. The class bool is a
subclass of the class int, and cannot be subclassed.

pass_through=True

    
If pass_through is True, all ancestors will always be invalidated, even if
'self' is already invalid.

set(child)[source]

    
Replace the current child of this transform with another one.

The new child must have the same number of input and output dimensions as the
current child.

classmatplotlib.transforms.TransformedBbox(bbox, transform, **kwargs)[source]

    
Bases: `matplotlib.transforms.BboxBase`

A `Bbox` that is automatically transformed by a given transform. When either
the child bounding box or transform changes, the bounds of this bbox will
update accordingly.

Parameters

    
bbox`Bbox`

transform`Transform`

__init__(bbox, transform, **kwargs)[source]

    
Parameters

    
bbox`Bbox`

transform`Transform`

__module__='matplotlib.transforms'

__str__()[source]

    
Return str(self).

get_points()[source]

classmatplotlib.transforms.TransformedPatchPath(patch)[source]

    
Bases: `matplotlib.transforms.TransformedPath`

A `TransformedPatchPath` caches a non-affine transformed copy of the `Patch`.
This cached copy is automatically updated when the non-affine part of the
transform or the patch changes.

Parameters

    
patch`Patch`

__init__(patch)[source]

    
Parameters

    
patch`Patch`

__module__='matplotlib.transforms'

classmatplotlib.transforms.TransformedPath(path, transform)[source]

    
Bases: `matplotlib.transforms.TransformNode`

A `TransformedPath` caches a non-affine transformed copy of the `Path`. This
cached copy is automatically updated when the non-affine part of the transform
changes.

Note

Paths are considered immutable by this class. Any update to the path's
vertices/codes will not trigger a transform recomputation.

Parameters

    
path`Path`

transform`Transform`

__init__(path, transform)[source]

    
Parameters

    
path`Path`

transform`Transform`

__module__='matplotlib.transforms'

get_affine()[source]

get_fully_transformed_path()[source]

    
Return a fully-transformed copy of the child path.

get_transformed_path_and_affine()[source]

    
Return a copy of the child path, with the non-affine part of the transform
already applied, along with the affine part of the path necessary to complete
the transformation.

get_transformed_points_and_affine()[source]

    
Return a copy of the child path, with the non-affine part of the transform
already applied, along with the affine part of the path necessary to complete
the transformation. Unlike `get_transformed_path_and_affine()`, no
interpolation will be performed.

matplotlib.transforms.blended_transform_factory(x_transform,
y_transform)[source]

    
Create a new "blended" transform using x_transform to transform the x-axis and
y_transform to transform the y-axis.

A faster version of the blended transform is returned for the case where both
child transforms are affine.

matplotlib.transforms.composite_transform_factory(a, b)[source]

    
Create a new composite transform that is the result of applying transform a
then transform b.

Shortcut versions of the blended transform are provided for the case where
both child transforms are affine, or one or the other is the identity
transform.

Composite transforms may also be created using the '+' operator, e.g.:

    
    c = a + b
    
matplotlib.transforms.interval_contains(interval, val)[source]

    
Check, inclusively, whether an interval includes a given value.

Parameters

    
interval(float, float)

    
The endpoints of the interval.

valfloat

    
Value to check is within interval.

Returns

    
bool

    
Whether val is within the interval.

matplotlib.transforms.interval_contains_open(interval, val)[source]

    
Check, excluding endpoints, whether an interval includes a given value.

Parameters

    
interval(float, float)

    
The endpoints of the interval.

valfloat

    
Value to check is within interval.

Returns

    
bool

    
Whether val is within the interval.

matplotlib.transforms.nonsingular(vmin, vmax, expander=0.001, tiny=1e-15,
increasing=True)[source]

    
Modify the endpoints of a range as needed to avoid singularities.

Parameters

    
vmin, vmaxfloat

    
The initial endpoints.

expanderfloat, default: 0.001

    
Fractional amount by which vmin and vmax are expanded if the original interval
is too small, based on tiny.

tinyfloat, default: 1e-15

    
Threshold for the ratio of the interval to the maximum absolute value of its
endpoints. If the interval is smaller than this, it will be expanded. This
value should be around 1e-15 or larger; otherwise the interval will be
approaching the double precision resolution limit.

increasingbool, default: True

    
If True, swap vmin, vmax if vmin > vmax.

Returns

    
vmin, vmaxfloat

    
Endpoints, expanded and/or swapped if necessary. If either input is inf or
NaN, or if both inputs are 0 or very close to zero, it returns -expander,
expander.

matplotlib.transforms.offset_copy(trans, fig=None, x=0.0, y=0.0,
units='inches')[source]

    
Return a new transform with an added offset.

Parameters

    
trans`Transform` subclass

    
Any transform, to which offset will be applied.

fig`Figure`, default: None

    
Current figure. It can be None if units are 'dots'.

x, yfloat, default: 0.0

    
The offset to apply.

units{'inches', 'points', 'dots'}, default: 'inches'

    
Units of the offset.

Returns

    
`Transform` subclass

    
Transform with applied offset.

© 2012–2021 Matplotlib Development Team. All rights reserved.  
Licensed under the Matplotlib License Agreement.  
https://matplotlib.org/3.5.1/api/transformations.html

