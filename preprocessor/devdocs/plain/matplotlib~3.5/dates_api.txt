# matplotlib.dates

![Inheritance diagram of
matplotlib.dates](data:image/png;base64,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)

Matplotlib provides sophisticated date plotting capabilities, standing on the
shoulders of python `datetime` and the add-on module `dateutil`.

By default, Matplotlib uses the units machinery described in `units` to
convert `datetime.datetime`, and `numpy.datetime64` objects when plotted on an
x- or y-axis. The user does not need to do anything for dates to be formatted,
but dates often have strict formatting needs, so this module provides many
axis locators and formatters. A basic example using `numpy.datetime64` is:

    
    import numpy as np
    
    times = np.arange(np.datetime64('2001-01-02'),
                      np.datetime64('2002-02-03'), np.timedelta64(75, 'm'))
    y = np.random.randn(len(times))
    
    fig, ax = plt.subplots()
    ax.plot(times, y)
    
See also

  * Date tick labels
  * Formatting date ticks using ConciseDateFormatter
  * Date Demo Convert

## Matplotlib date format

Matplotlib represents dates using floating point numbers specifying the number
of days since a default epoch of 1970-01-01 UTC; for example, 1970-01-01,
06:00 is the floating point number 0.25. The formatters and locators require
the use of `datetime.datetime` objects, so only dates between year 0001 and
9999 can be represented. Microsecond precision is achievable for
(approximately) 70 years on either side of the epoch, and 20 microseconds for
the rest of the allowable range of dates (year 0001 to 9999). The epoch can be
changed at import time via `dates.set_epoch` or `rcParams["dates.epoch"]` to
other dates if necessary; see Date Precision and Epochs for a discussion.

Note

Before Matplotlib 3.3, the epoch was 0000-12-31 which lost modern microsecond
precision and also made the default axis limit of 0 an invalid datetime. In
3.3 the epoch was changed as above. To convert old ordinal floats to the new
epoch, users can do:

    
    new_ordinal = old_ordinal + mdates.date2num(np.datetime64('0000-12-31'))
    
There are a number of helper functions to convert between `datetime` objects
and Matplotlib dates:

`datestr2num` | Convert a date string to a datenum using `dateutil.parser.parse`.  
---|---  
`date2num` | Convert datetime objects to Matplotlib dates.  
`num2date` | Convert Matplotlib dates to `datetime` objects.  
`num2timedelta` | Convert number of days to a `timedelta` object.  
`drange` | Return a sequence of equally spaced Matplotlib dates.  
`set_epoch` | Set the epoch (origin for dates) for datetime calculations.  
`get_epoch` | Get the epoch used by `dates`.  
Note

Like Python's `datetime.datetime`, Matplotlib uses the Gregorian calendar for
all conversions between dates and floating point numbers. This practice is not
universal, and calendar differences can cause confusing differences between
what Python and Matplotlib give as the number of days since 0001-01-01 and
what other software and databases yield. For example, the US Naval Observatory
uses a calendar that switches from Julian to Gregorian in October, 1582.
Hence, using their calculator, the number of days between 0001-01-01 and
2006-04-01 is 732403, whereas using the Gregorian calendar via the datetime
module we find:

    
    In [1]: date(2006, 4, 1).toordinal() - date(1, 1, 1).toordinal()
    Out[1]: 732401
    
All the Matplotlib date converters, tickers and formatters are timezone aware.
If no explicit timezone is provided, `rcParams["timezone"]` (default: `'UTC'`)
is assumed. If you want to use a custom time zone, pass a `datetime.tzinfo`
instance with the tz keyword argument to `num2date`, `Axis.axis_date`, and any
custom date tickers or locators you create.

A wide range of specific and general purpose date tick locators and formatters
are provided in this module. See `matplotlib.ticker` for general information
on tick locators and formatters. These are described below.

The dateutil module provides additional code to handle date ticking, making it
easy to place ticks on any kinds of dates. See examples below.

## Date tickers

Most of the date tickers can locate single or multiple values. For example:

    
    # import constants for the days of the week
    from matplotlib.dates import MO, TU, WE, TH, FR, SA, SU
    
    # tick on mondays every week
    loc = WeekdayLocator(byweekday=MO, tz=tz)
    
    # tick on mondays and saturdays
    loc = WeekdayLocator(byweekday=(MO, SA))
    
In addition, most of the constructors take an interval argument:

    
    # tick on mondays every second week
    loc = WeekdayLocator(byweekday=MO, interval=2)
    
The rrule locator allows completely general date ticking:

    
    # tick every 5th easter
    rule = rrulewrapper(YEARLY, byeaster=1, interval=5)
    loc = RRuleLocator(rule)
    
The available date tickers are:

  * `MicrosecondLocator`: Locate microseconds.
  * `SecondLocator`: Locate seconds.
  * `MinuteLocator`: Locate minutes.
  * `HourLocator`: Locate hours.
  * `DayLocator`: Locate specified days of the month.
  * `WeekdayLocator`: Locate days of the week, e.g., MO, TU.
  * `MonthLocator`: Locate months, e.g., 7 for July.
  * `YearLocator`: Locate years that are multiples of base.
  * `RRuleLocator`: Locate using a `matplotlib.dates.rrulewrapper`. `rrulewrapper` is a simple wrapper around dateutil's `dateutil.rrule` which allow almost arbitrary date tick specifications. See rrule example.
  * `AutoDateLocator`: On autoscale, this class picks the best `DateLocator` (e.g., `RRuleLocator`) to set the view limits and the tick locations. If called with `interval_multiples=True` it will make ticks line up with sensible multiples of the tick intervals. E.g. if the interval is 4 hours, it will pick hours 0, 4, 8, etc as ticks. This behaviour is not guaranteed by default.

## Date formatters

The available date formatters are:

  * `AutoDateFormatter`: attempts to figure out the best format to use. This is most useful when used with the `AutoDateLocator`.
  * `ConciseDateFormatter`: also attempts to figure out the best format to use, and to make the format as compact as possible while still having complete date information. This is most useful when used with the `AutoDateLocator`.
  * `DateFormatter`: use `strftime` format strings.

classmatplotlib.dates.AutoDateFormatter(locator, tz=None,
defaultfmt='%Y-%m-%d', *, usetex=None)[source]

    
Bases: `matplotlib.ticker.Formatter`

A `Formatter` which attempts to figure out the best format to use. This is
most useful when used with the `AutoDateLocator`.

`AutoDateFormatter` has a `.scale` dictionary that maps tick scales (the
interval in days between one major tick) to format strings; this dictionary
defaults to

    
    self.scaled = {
        DAYS_PER_YEAR: rcParams['date.autoformat.year'],
        DAYS_PER_MONTH: rcParams['date.autoformat.month'],
        1: rcParams['date.autoformat.day'],
        1 / HOURS_PER_DAY: rcParams['date.autoformat.hour'],
        1 / MINUTES_PER_DAY: rcParams['date.autoformat.minute'],
        1 / SEC_PER_DAY: rcParams['date.autoformat.second'],
        1 / MUSECONDS_PER_DAY: rcParams['date.autoformat.microsecond'],
    }
    
The formatter uses the format string corresponding to the lowest key in the
dictionary that is greater or equal to the current scale. Dictionary entries
can be customized:

    
    locator = AutoDateLocator()
    formatter = AutoDateFormatter(locator)
    formatter.scaled[1/(24*60)] = '%M:%S' # only show min and sec
    
Custom callables can also be used instead of format strings. The following
example shows how to use a custom format function to strip trailing zeros from
decimal seconds and adds the date to the first ticklabel:

    
    def my_format_function(x, pos=None):
        x = matplotlib.dates.num2date(x)
        if pos == 0:
            fmt = '%D %H:%M:%S.%f'
        else:
            fmt = '%H:%M:%S.%f'
        label = x.strftime(fmt)
        label = label.rstrip("0")
        label = label.rstrip(".")
        return label
    
    formatter.scaled[1/(24*60)] = my_format_function
    
Autoformat the date labels.

Parameters

    
locator`ticker.Locator`

    
Locator that this axis is using.

tzstr, optional

    
Passed to `dates.date2num`.

defaultfmtstr

    
The default format to use if none of the values in `self.scaled` are greater
than the unit returned by `locator._get_unit()`.

usetexbool, default: `rcParams["text.usetex"]` (default: `False`)

    
To enable/disable the use of TeX's math mode for rendering the results of the
formatter. If any entries in `self.scaled` are set as functions, then it is up
to the customized function to enable or disable TeX's math mode itself.

classmatplotlib.dates.AutoDateLocator(tz=None, minticks=5, maxticks=None,
interval_multiples=True)[source]

    
Bases: `matplotlib.dates.DateLocator`

On autoscale, this class picks the best `DateLocator` to set the view limits
and the tick locations.

Attributes

    
intervalddict

    
Mapping of tick frequencies to multiples allowed for that ticking. The default
is

    
    self.intervald = {
        YEARLY  : [1, 2, 4, 5, 10, 20, 40, 50, 100, 200, 400, 500,
                   1000, 2000, 4000, 5000, 10000],
        MONTHLY : [1, 2, 3, 4, 6],
        DAILY   : [1, 2, 3, 7, 14, 21],
        HOURLY  : [1, 2, 3, 4, 6, 12],
        MINUTELY: [1, 5, 10, 15, 30],
        SECONDLY: [1, 5, 10, 15, 30],
        MICROSECONDLY: [1, 2, 5, 10, 20, 50, 100, 200, 500,
                        1000, 2000, 5000, 10000, 20000, 50000,
                        100000, 200000, 500000, 1000000],
    }
    
where the keys are defined in `dateutil.rrule`.

The interval is used to specify multiples that are appropriate for the
frequency of ticking. For instance, every 7 days is sensible for daily ticks,
but for minutes/seconds, 15 or 30 make sense.

When customizing, you should only modify the values for the existing keys. You
should not add or delete entries.

Example for forcing ticks every 3 hours:

    
    locator = AutoDateLocator()
    locator.intervald[HOURLY] = [3]  # only show every 3 hours
    
Parameters

    
tz`datetime.tzinfo`

    
Ticks timezone.

minticksint

    
The minimum number of ticks desired; controls whether ticks occur yearly,
monthly, etc.

maxticksint

    
The maximum number of ticks desired; controls the interval between ticks
(ticking every other, every 3, etc.). For fine-grained control, this can be a
dictionary mapping individual rrule frequency constants (YEARLY, MONTHLY,
etc.) to their own maximum number of ticks. This can be used to keep the
number of ticks appropriate to the format chosen in `AutoDateFormatter`. Any
frequency not specified in this dictionary is given a default value.

interval_multiplesbool, default: True

    
Whether ticks should be chosen to be multiple of the interval, locking them to
'nicer' locations. For example, this will force the ticks to be at hours 0, 6,
12, 18 when hourly ticking is done at 6 hour intervals.

get_locator(dmin, dmax)[source]

    
Pick the best locator based on a distance.

nonsingular(vmin, vmax)[source]

    
Given the proposed upper and lower extent, adjust the range if it is too close
to being singular (i.e. a range of ~0).

tick_values(vmin, vmax)[source]

    
Return the values of the located ticks given vmin and vmax.

Note

To get tick locations with the vmin and vmax values defined automatically for
the associated `axis` simply call the Locator instance:

    
    >>> print(type(loc))
    <type 'Locator'>
    >>> print(loc())
    [1, 2, 3, 4]
    
classmatplotlib.dates.ConciseDateConverter(formats=None, zero_formats=None,
offset_formats=None, show_offset=True, *, interval_multiples=True)[source]

    
Bases: `matplotlib.dates.DateConverter`

axisinfo(unit, axis)[source]

    
Return the `AxisInfo` for unit.

unit is a tzinfo instance or None. The axis argument is required but not used.

classmatplotlib.dates.ConciseDateFormatter(locator, tz=None, formats=None,
offset_formats=None, zero_formats=None, show_offset=True, *,
usetex=None)[source]

    
Bases: `matplotlib.ticker.Formatter`

A `Formatter` which attempts to figure out the best format to use for the
date, and to make it as compact as possible, but still be complete. This is
most useful when used with the `AutoDateLocator`:

    
    >>> locator = AutoDateLocator()
    >>> formatter = ConciseDateFormatter(locator)
    
Parameters

    
locator`ticker.Locator`

    
Locator that this axis is using.

tzstr, optional

    
Passed to `dates.date2num`.

formatslist of 6 strings, optional

    
Format strings for 6 levels of tick labelling: mostly years, months, days,
hours, minutes, and seconds. Strings use the same format codes as `strftime`.
Default is `['%Y', '%b', '%d', '%H:%M', '%H:%M', '%S.%f']`

zero_formatslist of 6 strings, optional

    
Format strings for tick labels that are "zeros" for a given tick level. For
instance, if most ticks are months, ticks around 1 Jan 2005 will be labeled
"Dec", "2005", "Feb". The default is `['', '%Y', '%b', '%b-%d', '%H:%M',
'%H:%M']`

offset_formatslist of 6 strings, optional

    
Format strings for the 6 levels that is applied to the "offset" string found
on the right side of an x-axis, or top of a y-axis. Combined with the tick
labels this should completely specify the date. The default is:

    
    ['', '%Y', '%Y-%b', '%Y-%b-%d', '%Y-%b-%d', '%Y-%b-%d %H:%M']
    
show_offsetbool, default: True

    
Whether to show the offset or not.

usetexbool, default: `rcParams["text.usetex"]` (default: `False`)

    
To enable/disable the use of TeX's math mode for rendering the results of the
formatter.

#### Examples

See Formatting date ticks using ConciseDateFormatter

(Source code, png, pdf)

![../_images/dates_api-1.png](data:image/png;base64,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)

Autoformat the date labels. The default format is used to form an initial
string, and then redundant elements are removed.

format_data_short(value)[source]

    
Return a short string version of the tick value.

Defaults to the position-independent long value.

format_ticks(values)[source]

    
Return the tick labels for all the ticks at once.

get_offset()[source]

classmatplotlib.dates.DateConverter(*, interval_multiples=True)[source]

    
Bases: `matplotlib.units.ConversionInterface`

Converter for `datetime.date` and `datetime.datetime` data, or for date/time
data represented as it would be converted by `date2num`.

The 'unit' tag for such data is None or a tzinfo instance.

axisinfo(unit, axis)[source]

    
Return the `AxisInfo` for unit.

unit is a tzinfo instance or None. The axis argument is required but not used.

staticconvert(value, unit, axis)[source]

    
If value is not already a number or sequence of numbers, convert it with
`date2num`.

The unit and axis arguments are not used.

staticdefault_units(x, axis)[source]

    
Return the tzinfo instance of x or of its first element, or None

classmatplotlib.dates.DateFormatter(fmt, tz=None, *, usetex=None)[source]

    
Bases: `matplotlib.ticker.Formatter`

Format a tick (in days since the epoch) with a `strftime` format string.

Parameters

    
fmtstr

    
`strftime` format string

tz`datetime.tzinfo`, default: `rcParams["timezone"]` (default: `'UTC'`)

    
Ticks timezone.

usetexbool, default: `rcParams["text.usetex"]` (default: `False`)

    
To enable/disable the use of TeX's math mode for rendering the results of the
formatter.

set_tzinfo(tz)[source]

classmatplotlib.dates.DateLocator(tz=None)[source]

    
Bases: `matplotlib.ticker.Locator`

Determines the tick locations when plotting dates.

This class is subclassed by other Locators and is not meant to be used on its
own.

Parameters

    
tz`datetime.tzinfo`

datalim_to_dt()[source]

    
Convert axis data interval to datetime objects.

hms0d={'byhour': 0, 'byminute': 0, 'bysecond': 0}

nonsingular(vmin, vmax)[source]

    
Given the proposed upper and lower extent, adjust the range if it is too close
to being singular (i.e. a range of ~0).

set_tzinfo(tz)[source]

    
Set time zone info.

viewlim_to_dt()[source]

    
Convert the view interval to datetime objects.

classmatplotlib.dates.DayLocator(bymonthday=None, interval=1, tz=None)[source]

    
Bases: `matplotlib.dates.RRuleLocator`

Make ticks on occurrences of each day of the month. For example, 1, 15, 30.

Mark every day in bymonthday; bymonthday can be an int or sequence.

Default is to tick every day of the month: `bymonthday=range(1, 32)`.

classmatplotlib.dates.HourLocator(byhour=None, interval=1, tz=None)[source]

    
Bases: `matplotlib.dates.RRuleLocator`

Make ticks on occurrences of each hour.

Mark every hour in byhour; byhour can be an int or sequence. Default is to
tick every hour: `byhour=range(24)`

interval is the interval between each iteration. For example, if `interval=2`,
mark every second occurrence.

classmatplotlib.dates.MicrosecondLocator(interval=1, tz=None)[source]

    
Bases: `matplotlib.dates.DateLocator`

Make ticks on regular intervals of one or more microsecond(s).

Note

By default, Matplotlib uses a floating point representation of time in days
since the epoch, so plotting data with microsecond time resolution does not
work well for dates that are far (about 70 years) from the epoch (check with
`get_epoch`).

If you want sub-microsecond resolution time plots, it is strongly recommended
to use floating point seconds, not datetime-like time representation.

If you really must use datetime.datetime() or similar and still need
microsecond precision, change the time origin via `dates.set_epoch` to
something closer to the dates being plotted. See Date Precision and Epochs.

interval is the interval between each iteration. For example, if `interval=2`,
mark every second microsecond.

set_axis(axis)[source]

set_data_interval(vmin, vmax)[source]

    
[Deprecated]

#### Notes

Deprecated since version 3.5:

set_view_interval(vmin, vmax)[source]

    
[Deprecated]

#### Notes

Deprecated since version 3.5:

tick_values(vmin, vmax)[source]

    
Return the values of the located ticks given vmin and vmax.

Note

To get tick locations with the vmin and vmax values defined automatically for
the associated `axis` simply call the Locator instance:

    
    >>> print(type(loc))
    <type 'Locator'>
    >>> print(loc())
    [1, 2, 3, 4]
    
classmatplotlib.dates.MinuteLocator(byminute=None, interval=1,
tz=None)[source]

    
Bases: `matplotlib.dates.RRuleLocator`

Make ticks on occurrences of each minute.

Mark every minute in byminute; byminute can be an int or sequence. Default is
to tick every minute: `byminute=range(60)`

interval is the interval between each iteration. For example, if `interval=2`,
mark every second occurrence.

classmatplotlib.dates.MonthLocator(bymonth=None, bymonthday=1, interval=1,
tz=None)[source]

    
Bases: `matplotlib.dates.RRuleLocator`

Make ticks on occurrences of each month, e.g., 1, 3, 12.

Mark every month in bymonth; bymonth can be an int or sequence. Default is
`range(1, 13)`, i.e. every month.

interval is the interval between each iteration. For example, if `interval=2`,
mark every second occurrence.

classmatplotlib.dates.RRuleLocator(o, tz=None)[source]

    
Bases: `matplotlib.dates.DateLocator`

Parameters

    
tz`datetime.tzinfo`

staticget_unit_generic(freq)[source]

tick_values(vmin, vmax)[source]

    
Return the values of the located ticks given vmin and vmax.

Note

To get tick locations with the vmin and vmax values defined automatically for
the associated `axis` simply call the Locator instance:

    
    >>> print(type(loc))
    <type 'Locator'>
    >>> print(loc())
    [1, 2, 3, 4]
    
classmatplotlib.dates.SecondLocator(bysecond=None, interval=1,
tz=None)[source]

    
Bases: `matplotlib.dates.RRuleLocator`

Make ticks on occurrences of each second.

Mark every second in bysecond; bysecond can be an int or sequence. Default is
to tick every second: `bysecond = range(60)`

interval is the interval between each iteration. For example, if `interval=2`,
mark every second occurrence.

classmatplotlib.dates.WeekdayLocator(byweekday=1, interval=1, tz=None)[source]

    
Bases: `matplotlib.dates.RRuleLocator`

Make ticks on occurrences of each weekday.

Mark every weekday in byweekday; byweekday can be a number or sequence.

Elements of byweekday must be one of MO, TU, WE, TH, FR, SA, SU, the constants
from `dateutil.rrule`, which have been imported into the `matplotlib.dates`
namespace.

interval specifies the number of weeks to skip. For example, `interval=2`
plots every second week.

classmatplotlib.dates.YearLocator(base=1, month=1, day=1, tz=None)[source]

    
Bases: `matplotlib.dates.RRuleLocator`

Make ticks on a given day of each year that is a multiple of base.

Examples:

    
    # Tick every year on Jan 1st
    locator = YearLocator()
    
    # Tick every 5 years on July 4th
    locator = YearLocator(5, month=7, day=4)
    
Mark years that are multiple of base on a given month and day (default jan 1).

matplotlib.dates.date2num(d)[source]

    
Convert datetime objects to Matplotlib dates.

Parameters

    
d`datetime.datetime` or `numpy.datetime64` or sequences of these

Returns

    
float or sequence of floats

    
Number of days since the epoch. See `get_epoch` for the epoch, which can be
changed by `rcParams["date.epoch"]` (default: `'1970-01-01T00:00:00'`) or
`set_epoch`. If the epoch is "1970-01-01T00:00:00" (default) then noon Jan 1
1970 ("1970-01-01T12:00:00") returns 0.5.

#### Notes

The Gregorian calendar is assumed; this is not universal practice. For details
see the module docstring.

matplotlib.dates.datestr2num(d, default=None)[source]

    
Convert a date string to a datenum using `dateutil.parser.parse`.

Parameters

    
dstr or sequence of str

    
The dates to convert.

defaultdatetime.datetime, optional

    
The default date to use when fields are missing in d.

matplotlib.dates.drange(dstart, dend, delta)[source]

    
Return a sequence of equally spaced Matplotlib dates.

The dates start at dstart and reach up to, but not including dend. They are
spaced by delta.

Parameters

    
dstart, dend`datetime`

    
The date limits.

delta`datetime.timedelta`

    
Spacing of the dates.

Returns

    
`numpy.array`

    
A list floats representing Matplotlib dates.

matplotlib.dates.epoch2num(e)[source]

    
[Deprecated] Convert UNIX time to days since Matplotlib epoch.

Parameters

    
elist of floats

    
Time in seconds since 1970-01-01.

Returns

    
`numpy.array`

    
Time in days since Matplotlib epoch (see `get_epoch()`).

#### Notes

Deprecated since version 3.5.

matplotlib.dates.get_epoch()[source]

    
Get the epoch used by `dates`.

Returns

    
epochstr

    
String for the epoch (parsable by `numpy.datetime64`).

matplotlib.dates.num2date(x, tz=None)[source]

    
Convert Matplotlib dates to `datetime` objects.

Parameters

    
xfloat or sequence of floats

    
Number of days (fraction part represents hours, minutes, seconds) since the
epoch. See `get_epoch` for the epoch, which can be changed by
`rcParams["date.epoch"]` (default: `'1970-01-01T00:00:00'`) or `set_epoch`.

tzstr, default: `rcParams["timezone"]` (default: `'UTC'`)

    
Timezone of x.

Returns

    
`datetime` or sequence of `datetime`

    
Dates are returned in timezone tz.

If x is a sequence, a sequence of `datetime` objects will be returned.

#### Notes

The addition of one here is a historical artifact. Also, note that the
Gregorian calendar is assumed; this is not universal practice. For details,
see the module docstring.

matplotlib.dates.num2epoch(d)[source]

    
[Deprecated] Convert days since Matplotlib epoch to UNIX time.

Parameters

    
dlist of floats

    
Time in days since Matplotlib epoch (see `get_epoch()`).

Returns

    
`numpy.array`

    
Time in seconds since 1970-01-01.

#### Notes

Deprecated since version 3.5.

matplotlib.dates.num2timedelta(x)[source]

    
Convert number of days to a `timedelta` object.

If x is a sequence, a sequence of `timedelta` objects will be returned.

Parameters

    
xfloat, sequence of floats

    
Number of days. The fraction part represents hours, minutes, seconds.

Returns

    
`datetime.timedelta` or list[`datetime.timedelta`]

classmatplotlib.dates.relativedelta(dt1=None, dt2=None, years=0, months=0,
days=0, leapdays=0, weeks=0, hours=0, minutes=0, seconds=0, microseconds=0,
year=None, month=None, day=None, weekday=None, yearday=None, nlyearday=None,
hour=None, minute=None, second=None, microsecond=None)

    
Bases: `object`

The relativedelta type is designed to be applied to an existing datetime and
can replace specific components of that datetime, or represents an interval of
time.

It is based on the specification of the excellent work done by M.-A. Lemburg
in his mx.DateTime extension. However, notice that this type does NOT
implement the same algorithm as his work. Do NOT expect it to behave like
mx.DateTime's counterpart.

There are two different ways to build a relativedelta instance. The first one
is passing it two date/datetime classes:

    
    relativedelta(datetime1, datetime2)
    
The second one is passing it any number of the following keyword arguments:

    
    relativedelta(arg1=x,arg2=y,arg3=z...)
    
    year, month, day, hour, minute, second, microsecond:
        Absolute information (argument is singular); adding or subtracting a
        relativedelta with absolute information does not perform an arithmetic
        operation, but rather REPLACES the corresponding value in the
        original datetime with the value(s) in relativedelta.
    
    years, months, weeks, days, hours, minutes, seconds, microseconds:
        Relative information, may be negative (argument is plural); adding
        or subtracting a relativedelta with relative information performs
        the corresponding arithmetic operation on the original datetime value
        with the information in the relativedelta.
    
    weekday: 
        One of the weekday instances (MO, TU, etc) available in the
        relativedelta module. These instances may receive a parameter N,
        specifying the Nth weekday, which could be positive or negative
        (like MO(+1) or MO(-2)). Not specifying it is the same as specifying
        +1. You can also use an integer, where 0=MO. This argument is always
        relative e.g. if the calculated date is already Monday, using MO(1)
        or MO(-1) won't change the day. To effectively make it absolute, use
        it in combination with the day argument (e.g. day=1, MO(1) for first
        Monday of the month).
    
    leapdays:
        Will add given days to the date found, if year is a leap
        year, and the date found is post 28 of february.
    
    yearday, nlyearday:
        Set the yearday or the non-leap year day (jump leap days).
        These are converted to day/month/leapdays information.
    
There are relative and absolute forms of the keyword arguments. The plural is
relative, and the singular is absolute. For each argument in the order below,
the absolute form is applied first (by setting each attribute to that value)
and then the relative form (by adding the value to the attribute).

The order of attributes considered when this relativedelta is added to a
datetime is:

  1. Year
  2. Month
  3. Day
  4. Hours
  5. Minutes
  6. Seconds
  7. Microseconds

Finally, weekday is applied, using the rule described above.

For example

    
    >>> from datetime import datetime
    >>> from dateutil.relativedelta import relativedelta, MO
    >>> dt = datetime(2018, 4, 9, 13, 37, 0)
    >>> delta = relativedelta(hours=25, day=1, weekday=MO(1))
    >>> dt + delta
    datetime.datetime(2018, 4, 2, 14, 37)
    
First, the day is set to 1 (the first of the month), then 25 hours are added,
to get to the 2nd day and 14th hour, finally the weekday is applied, but since
the 2nd is already a Monday there is no effect.

normalized()

    
Return a version of this object represented entirely using integer values for
the relative attributes.

    
    >>> relativedelta(days=1.5, hours=2).normalized()
    relativedelta(days=+1, hours=+14)
    
Returns

    
Returns a `dateutil.relativedelta.relativedelta` object.

propertyweeks

classmatplotlib.dates.rrule(freq, dtstart=None, interval=1, wkst=None,
count=None, until=None, bysetpos=None, bymonth=None, bymonthday=None,
byyearday=None, byeaster=None, byweekno=None, byweekday=None, byhour=None,
byminute=None, bysecond=None, cache=False)

    
Bases: `dateutil.rrule.rrulebase`

That's the base of the rrule operation. It accepts all the keywords defined in
the RFC as its constructor parameters (except byday, which was renamed to
byweekday) and more. The constructor prototype is:

    
    rrule(freq)
    
Where freq must be one of YEARLY, MONTHLY, WEEKLY, DAILY, HOURLY, MINUTELY, or
SECONDLY.

Note

Per RFC section 3.3.10, recurrence instances falling on invalid dates and
times are ignored rather than coerced:

Recurrence rules may generate recurrence instances with an invalid date (e.g.,
February 30) or nonexistent local time (e.g., 1:30 AM on a day where the local
time is moved forward by an hour at 1:00 AM). Such recurrence instances MUST
be ignored and MUST NOT be counted as part of the recurrence set.

This can lead to possibly surprising behavior when, for example, the start
date occurs at the end of the month:

    
    >>> from dateutil.rrule import rrule, MONTHLY
    >>> from datetime import datetime
    >>> start_date = datetime(2014, 12, 31)
    >>> list(rrule(freq=MONTHLY, count=4, dtstart=start_date))
    ... 
    [datetime.datetime(2014, 12, 31, 0, 0),
     datetime.datetime(2015, 1, 31, 0, 0),
     datetime.datetime(2015, 3, 31, 0, 0),
     datetime.datetime(2015, 5, 31, 0, 0)]
    
Additionally, it supports the following keyword arguments:

Parameters

    
  * dtstart \-- The recurrence start. Besides being the base for the recurrence, missing parameters in the final recurrence instances will also be extracted from this date. If not given, datetime.now() will be used instead.
  * interval \-- The interval between each freq iteration. For example, when using YEARLY, an interval of 2 means once every two years, but with HOURLY, it means once every two hours. The default interval is 1.
  * wkst \-- The week start day. Must be one of the MO, TU, WE constants, or an integer, specifying the first day of the week. This will affect recurrences based on weekly periods. The default week start is got from calendar.firstweekday(), and may be modified by calendar.setfirstweekday().
  * count \-- 
If given, this determines how many occurrences will be generated.

Note

As of version 2.5.0, the use of the keyword `until` in conjunction with
`count` is deprecated, to make sure `dateutil` is fully compliant with
RFC-5545 Sec. 3.3.10. Therefore, `until` and `count` must not occur in the
same call to `rrule`.

  * until \-- 
If given, this must be a datetime instance specifying the upper-bound limit of
the recurrence. The last recurrence in the rule is the greatest datetime that
is less than or equal to the value specified in the `until` parameter.

Note

As of version 2.5.0, the use of the keyword `until` in conjunction with
`count` is deprecated, to make sure `dateutil` is fully compliant with
RFC-5545 Sec. 3.3.10. Therefore, `until` and `count` must not occur in the
same call to `rrule`.

  * bysetpos \-- If given, it must be either an integer, or a sequence of integers, positive or negative. Each given integer will specify an occurrence number, corresponding to the nth occurrence of the rule inside the frequency period. For example, a bysetpos of -1 if combined with a MONTHLY frequency, and a byweekday of (MO, TU, WE, TH, FR), will result in the last work day of every month.
  * bymonth \-- If given, it must be either an integer, or a sequence of integers, meaning the months to apply the recurrence to.
  * bymonthday \-- If given, it must be either an integer, or a sequence of integers, meaning the month days to apply the recurrence to.
  * byyearday \-- If given, it must be either an integer, or a sequence of integers, meaning the year days to apply the recurrence to.
  * byeaster \-- If given, it must be either an integer, or a sequence of integers, positive or negative. Each integer will define an offset from the Easter Sunday. Passing the offset 0 to byeaster will yield the Easter Sunday itself. This is an extension to the RFC specification.
  * byweekno \-- If given, it must be either an integer, or a sequence of integers, meaning the week numbers to apply the recurrence to. Week numbers have the meaning described in ISO8601, that is, the first week of the year is that containing at least four days of the new year.
  * byweekday \-- If given, it must be either an integer (0 == MO), a sequence of integers, one of the weekday constants (MO, TU, etc), or a sequence of these constants. When given, these variables will define the weekdays where the recurrence will be applied. It's also possible to use an argument n for the weekday instances, which will mean the nth occurrence of this weekday in the period. For example, with MONTHLY, or with YEARLY and BYMONTH, using FR(+1) in byweekday will specify the first friday of the month where the recurrence happens. Notice that in the RFC documentation, this is specified as BYDAY, but was renamed to avoid the ambiguity of that keyword.
  * byhour \-- If given, it must be either an integer, or a sequence of integers, meaning the hours to apply the recurrence to.
  * byminute \-- If given, it must be either an integer, or a sequence of integers, meaning the minutes to apply the recurrence to.
  * bysecond \-- If given, it must be either an integer, or a sequence of integers, meaning the seconds to apply the recurrence to.
  * cache \-- If given, it must be a boolean value specifying to enable or disable caching of results. If you will use the same rrule instance multiple times, enabling caching will improve the performance considerably.

replace(**kwargs)

    
Return new rrule with same attributes except for those attributes given new
values by whichever keyword arguments are specified.

matplotlib.dates.set_epoch(epoch)[source]

    
Set the epoch (origin for dates) for datetime calculations.

The default epoch is `rcParams["dates.epoch"]` (by default 1970-01-01T00:00).

If microsecond accuracy is desired, the date being plotted needs to be within
approximately 70 years of the epoch. Matplotlib internally represents dates as
days since the epoch, so floating point dynamic range needs to be within a
factor of 2^52.

`set_epoch` must be called before any dates are converted (i.e. near the
import section) or a RuntimeError will be raised.

See also Date Precision and Epochs.

Parameters

    
epochstr

    
valid UTC date parsable by `numpy.datetime64` (do not include timezone).

© 2012–2021 Matplotlib Development Team. All rights reserved.  
Licensed under the Matplotlib License Agreement.  
https://matplotlib.org/3.5.1/api/dates_api.html

