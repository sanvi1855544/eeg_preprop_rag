# backend_agg

An Anti-Grain Geometry (AGG) backend.

Features that are implemented:

  * capstyles and join styles
  * dashes
  * linewidth
  * lines, rectangles, ellipses
  * clipping to a rectangle
  * output to RGBA and Pillow-supported image formats
  * alpha blending
  * DPI scaling properly - everything scales properly (dashes, linewidths, etc)
  * draw polygon
  * freetype2 w/ ft2font

Still TODO:

  * integrate screen dpi w/ ppi and text

matplotlib.backends.backend_agg.FigureCanvas[source]

    
alias of `matplotlib.backends.backend_agg.FigureCanvasAgg`

classmatplotlib.backends.backend_agg.FigureCanvasAgg(figure=None)[source]

    
Bases: `matplotlib.backend_bases.FigureCanvasBase`

buffer_rgba()[source]

    
Get the image as a `memoryview` to the renderer's buffer.

`draw` must be called at least once before this function will work and to
update the renderer for any subsequent changes to the Figure.

copy_from_bbox(bbox)[source]

draw()[source]

    
Render the `Figure`.

It is important that this method actually walk the artist tree even if not
output is produced because this will trigger deferred work (like computing
limits auto-limits and tick values) that users may want access to before
saving to disk.

get_renderer(cleared=False)[source]

print_jpeg(filename_or_obj, *args, pil_kwargs=None, **kwargs)[source]

    
Write the figure to a JPEG file.

Parameters

    
filename_or_objstr or path-like or file-like

    
The file to write to.

Other Parameters

    
pil_kwargsdict, optional

    
Additional keyword arguments that are passed to `PIL.Image.Image.save` when
saving the figure.

print_jpg(filename_or_obj, *args, pil_kwargs=None, **kwargs)[source]

    
Write the figure to a JPEG file.

Parameters

    
filename_or_objstr or path-like or file-like

    
The file to write to.

Other Parameters

    
pil_kwargsdict, optional

    
Additional keyword arguments that are passed to `PIL.Image.Image.save` when
saving the figure.

print_png(filename_or_obj, *args, metadata=None, pil_kwargs=None)[source]

    
Write the figure to a PNG file.

Parameters

    
filename_or_objstr or path-like or file-like

    
The file to write to.

metadatadict, optional

    
Metadata in the PNG file as key-value pairs of bytes or latin-1 encodable
strings. According to the PNG specification, keys must be shorter than 79
chars.

The PNG specification defines some common keywords that may be used as
appropriate:

  * Title: Short (one line) title or caption for image.
  * Author: Name of image's creator.
  * Description: Description of image (possibly long).
  * Copyright: Copyright notice.
  * Creation Time: Time of original image creation (usually RFC 1123 format).
  * Software: Software used to create the image.
  * Disclaimer: Legal disclaimer.
  * Warning: Warning of nature of content.
  * Source: Device used to create the image.
  * Comment: Miscellaneous comment; conversion from other image format.

Other keywords may be invented for other purposes.

If 'Software' is not given, an autogenerated value for Matplotlib will be
used. This can be removed by setting it to None.

For more details see the PNG specification.

pil_kwargsdict, optional

    
Keyword arguments passed to `PIL.Image.Image.save`.

If the 'pnginfo' key is present, it completely overrides metadata, including
the default 'Software' key.

print_raw(filename_or_obj, *args)[source]

print_rgba(filename_or_obj, *args)[source]

print_tif(filename_or_obj, *, pil_kwargs=None)[source]

print_tiff(filename_or_obj, *, pil_kwargs=None)[source]

print_to_buffer()[source]

restore_region(region, bbox=None, xy=None)[source]

tostring_argb()[source]

    
Get the image as ARGB `bytes`.

`draw` must be called at least once before this function will work and to
update the renderer for any subsequent changes to the Figure.

tostring_rgb()[source]

    
Get the image as RGB `bytes`.

`draw` must be called at least once before this function will work and to
update the renderer for any subsequent changes to the Figure.

classmatplotlib.backends.backend_agg.RendererAgg(width, height, dpi)[source]

    
Bases: `matplotlib.backend_bases.RendererBase`

The renderer handles all the drawing primitives using a graphics context
instance that controls the colors/styles

buffer_rgba()[source]

clear()[source]

draw_mathtext(gc, x, y, s, prop, angle)[source]

    
Draw mathtext using `matplotlib.mathtext`.

draw_path(gc, path, transform, rgbFace=None)[source]

    
Draw a `Path` instance using the given affine transform.

draw_tex(gc, x, y, s, prop, angle, *, mtext=None)[source]

draw_text(gc, x, y, s, prop, angle, ismath=False, mtext=None)[source]

    
Draw the text instance.

Parameters

    
gc`GraphicsContextBase`

    
The graphics context.

xfloat

    
The x location of the text in display coords.

yfloat

    
The y location of the text baseline in display coords.

sstr

    
The text string.

prop`matplotlib.font_manager.FontProperties`

    
The font properties.

anglefloat

    
The rotation angle in degrees anti-clockwise.

mtext`matplotlib.text.Text`

    
The original text object to be rendered.

#### Notes

Note for backend implementers:

When you are trying to determine if you have gotten your bounding box right
(which is what enables the text layout/alignment to work properly), it helps
to change the line in text.py:

    
    if 0: bbox_artist(self, renderer)
    
to if 1, and then the actual bounding box will be plotted along with your
text.

get_canvas_width_height()[source]

    
Return the canvas width and height in display coords.

get_content_extents()[source]

    
[Deprecated]

#### Notes

Deprecated since version 3.4:

get_text_width_height_descent(s, prop, ismath)[source]

    
Get the width, height, and descent (offset from the bottom to the baseline),
in display coords, of the string s with `FontProperties` prop.

lock=<unlocked _thread.RLock object owner=0 count=0>

option_image_nocomposite()[source]

    
Return whether image composition by Matplotlib should be skipped.

Raster backends should usually return False (letting the C-level rasterizer
take care of image composition); vector backends should usually return `not
rcParams["image.composite_image"]`.

option_scale_image()[source]

    
Return whether arbitrary affine transformations in `draw_image()` are
supported (True for most vector backends).

points_to_pixels(points)[source]

    
Convert points to display units.

You need to override this function (unless your backend doesn't have a dpi,
e.g., postscript or svg). Some imaging systems assume some value for pixels
per inch:

    
    points to pixels = points * pixels_per_inch/72 * dpi/72
    
Parameters

    
pointsfloat or array-like

    
a float or a numpy array of float

Returns

    
Points converted to pixels

restore_region(region, bbox=None, xy=None)[source]

    
Restore the saved region. If bbox (instance of BboxBase, or its extents) is
given, only the region specified by the bbox will be restored. xy (a pair of
floats) optionally specifies the new position (the LLC of the original region,
not the LLC of the bbox) where the region will be restored.

    
    >>> region = renderer.copy_from_bbox()
    >>> x1, y1, x2, y2 = region.get_extents()
    >>> renderer.restore_region(region, bbox=(x1+dx, y1, x2, y2),
    ...                         xy=(x1-dx, y1))
    
start_filter()[source]

    
Start filtering. It simply create a new canvas (the old one is saved).

stop_filter(post_processing)[source]

    
Save the plot in the current canvas as a image and apply the post_processing
function.

def post_processing(image, dpi):

    
# ny, nx, depth = image.shape # image (numpy array) has RGBA channels and has
a depth of 4. ... # create a new_image (numpy array of 4 channels, size can be
# different). The resulting image may have offsets from # lower-left corner of
the original image return new_image, offset_x, offset_y

The saved renderer is restored and the returned image from post_processing is
plotted (using draw_image) on it.

tostring_argb()[source]

tostring_rgb()[source]

tostring_rgba_minimized()[source]

    
[Deprecated]

#### Notes

Deprecated since version 3.4:

matplotlib.backends.backend_agg.get_hinting_flag()[source]

© 2012–2021 Matplotlib Development Team. All rights reserved.  
Licensed under the Matplotlib License Agreement.  
https://matplotlib.org/3.5.1/api/backend_agg_api.html

