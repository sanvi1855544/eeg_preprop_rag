{"_id": "pyprep_prep_pipeline.py___init___doc", "text": "Initialize PREP class.", "metadata": {}}
{"_id": "pyprep_prep_pipeline.py_raw_doc", "text": "Return a version of self.raw_eeg that includes the non-eeg channels.", "metadata": {}}
{"_id": "pyprep_prep_pipeline.py_fit_doc", "text": "Run the whole PREP pipeline.", "metadata": {}}
{"_id": "pyprep_removeTrend.py_removeTrend_doc", "text": "Remove trends (i.e., slow drifts in baseline) from an array of EEG data.\n\nParameters\n----------\nEEG : np.ndarray\n    A 2-D array of EEG data to detrend.\nsample_rate : float\n    The sample rate (in Hz) of the input EEG data.\ndetrendType : str, optional\n    Type of detrending to be performed: must be one of 'high pass',\n    'high pass sinc, or 'local detrend'. Defaults to 'high pass'.\ndetrendCutoff : float, optional\n    The high-pass cutoff frequency (in Hz) to use for detrending. Defaults\n    to 1.0 Hz.\ndetrendChannels : {list, None}, optional\n    List of the indices of all channels that require detrending/filtering.\n    If ``None``, all channels are used (default).\nmatlab_strict : bool, optional\n    Whether or not detrending should strictly follow MATLAB PREP's internal\n    math, ignoring any improvements made in PyPREP over the original code\n    (see :ref:`matlab-diffs` for more details). Defaults to ``False``.\n\nReturns\n-------\nEEG : np.ndarray\n    A 2-D array containing the filtered/detrended EEG data.\n\nNotes\n-----\nHigh-pass filtering is implemented using the MNE filter function\n:func:``mne.filter.filter_data`` unless `matlab_strict` is ``True``, in\nwhich case it is performed using a minimal re-implementation of EEGLAB's\n``pop_eegfiltnew``. Local detrending is performed using a Python\nre-implementation of the ``runline`` function from the Chronux package for\nMATLAB [1]_.\n\nReferences\n----------\n.. [1] http://chronux.org/", "metadata": {}}
{"_id": "pyprep_removeTrend.py_runline_doc", "text": "Perform local linear regression on a channel of EEG data.\n\nA re-implementation of the ``runline`` function from the Chronux package\nfor MATLAB [1]_.\n\nParameters\n----------\ny : np.ndarray\n    A 1-D array of data from a single EEG channel.\nn : int\n    Length of the detrending window.\ndn : int\n    Length of the window step size.\n\nReturns\n-------\ny: np.ndarray\n   The detrended signal for the given EEG channel.\n\nReferences\n----------\n.. [1] http://chronux.org/", "metadata": {}}
{"_id": "pyprep_reference.py___init___doc", "text": "Initialize the class.", "metadata": {}}
{"_id": "pyprep_reference.py_perform_reference_doc", "text": "Estimate the true signal mean and interpolate bad channels.\n\nParameters\n----------\nmax_iterations : int, optional\n    The maximum number of iterations of noisy channel removal to perform\n    during robust referencing. Defaults to ``4``.\n\nThis function implements the functionality of the `performReference` function\nas part of the PREP pipeline on mne raw object.\n\nNotes\n-----\nThis function calls ``robust_reference`` first.\nCurrently this function only implements the functionality of default\nsettings, i.e., ``doRobustPost``.", "metadata": {}}
{"_id": "pyprep_reference.py_robust_reference_doc", "text": "Detect bad channels and estimate the robust reference signal.\n\nThis function implements the functionality of the `robustReference` function\nas part of the PREP pipeline on mne raw object.\n\nParameters\n----------\nmax_iterations : int, optional\n    The maximum number of iterations of noisy channel removal to perform\n    during robust referencing. Defaults to ``4``.\n\nReturns\n-------\nnoisy_channels: dict\n    A dictionary of names of noisy channels detected from all methods\n    after referencing.\nreference_signal: np.ndarray, shape(n, )\n    Estimation of the 'true' signal mean", "metadata": {}}
{"_id": "pyprep_reference.py_remove_reference_doc", "text": "Remove the reference signal from the original EEG signal.\n\nThis function implements the functionality of the `removeReference` function\nas part of the PREP pipeline on mne raw object.\n\nParameters\n----------\nsignal : np.ndarray, shape(channels, times)\n    The original EEG signal.\nreference : np.ndarray, shape(times,)\n    The reference signal.\nindex : {list, None}, optional\n    A list of channel indices from which the reference signal should be\n    subtracted. Defaults to all channels in `signal`.\n\nReturns\n-------\nnp.ndarray, shape(channels, times)\n    The referenced EEG signal.", "metadata": {}}
{"_id": "pyprep_utils.py__union_doc", "text": "", "metadata": {}}
{"_id": "pyprep_utils.py__set_diff_doc", "text": "", "metadata": {}}
{"_id": "pyprep_utils.py__mat_round_doc", "text": "Round a number to the nearest whole number.\n\nParameters\n----------\nx : float\n    The number to round.\n\nReturns\n-------\nrounded : float\n    The input value, rounded to the nearest whole number.\n\nNotes\n-----\nMATLAB rounds all numbers ending in .5 up to the nearest integer, whereas\nPython (and Numpy) rounds them to the nearest even number. This function\nmimics MATLAB's behaviour.", "metadata": {}}
{"_id": "pyprep_utils.py__mat_quantile_doc", "text": "Calculate the numeric value at quantile (`q`) for a given distribution.\n\nParameters\n----------\narr : np.ndarray\n    Input array containing samples from the distribution to summarize. Must\n    be either a 1-D or 2-D array.\nq : float\n    The quantile to calculate for the input data. Must be between 0 and 1,\n    inclusive.\naxis : {int, tuple of int, None}, optional\n    Axis along which quantile values should be calculated. Defaults to\n    calculating the value at the given quantile for the entire array.\n\nReturns\n-------\nquantile : scalar or np.ndarray\n    If no axis is specified, returns the value at quantile (q) for the full\n    input array as a single numeric value. Otherwise, returns an\n    ``np.ndarray`` containing the values at quantile (q) for each row along\n    the specified axis.\n\nNotes\n-----\nMATLAB calculates quantiles using different logic than Numpy: Numpy treats\nthe provided values as a whole population, whereas MATLAB treats them as a\nsample from a population of unknown size and adjusts quantiles accordingly.\nThis function mimics MATLAB's logic to produce identical results.", "metadata": {}}
{"_id": "pyprep_utils.py__mat_iqr_doc", "text": "Calculate the inter-quartile range (IQR) for a given distribution.\n\nParameters\n----------\narr : np.ndarray\n    Input array containing samples from the distribution to summarize.\naxis : {int, tuple of int, None}, optional\n    Axis along which IQRs should be calculated. Defaults to calculating the\n    IQR for the entire array.\n\nReturns\n-------\niqr : scalar or np.ndarray\n    If no axis is specified, returns the IQR for the full input array as a\n    single numeric value. Otherwise, returns an ``np.ndarray`` containing\n    the IQRs for each row along the specified axis.\n\nNotes\n-----\nSee notes for :func:`utils._mat_quantile`.", "metadata": {}}
{"_id": "pyprep_utils.py__eeglab_create_highpass_doc", "text": "Create a high-pass FIR filter using Hamming windows.\n\nParameters\n----------\ncutoff : float\n    The lower pass-band edge of the filter, in Hz.\nsrate : float\n    The sampling rate of the EEG signal, in Hz.\n\nReturns\n-------\nfilter : np.ndarray\n    A 1-dimensional array of FIR filter coefficients.\n\nNotes\n-----\nIn MATLAB PREP, the internal ``removeTrend`` function uses EEGLAB's\n``pop_eegfiltnew`` to high-pass the EEG data to remove slow drifts.\nBecause MNE's ``mne.filter.filter_data`` and EEGLAB's ``pop_eegfiltnew``\ncalculate filter parameters slightly differently, this function is\nused to precisely match EEGLAB & MATLAB PREP's filtering method.", "metadata": {}}
{"_id": "pyprep_utils.py__eeglab_fir_filter_doc", "text": "Apply an FIR filter to a 2-D array of EEG data.\n\nParameters\n----------\ndata : np.ndarray\n    A 2-D array of EEG data to filter.\nfilt : np.ndarray\n    A 1-D array of FIR filter coefficients.\n\nReturns\n-------\nfiltered : np.ndarray\n    A 2-D array of FIR-filtered EEG data.\n\nNotes\n-----\nProduces identical output to EEGLAB's ``firfilt`` function (for non-epoched\ndata). For internal use within :mod:`pyprep.removeTrend`.", "metadata": {}}
{"_id": "pyprep_utils.py__eeglab_calc_g_doc", "text": "Calculate spherical spline g function between points on a sphere.\n\nParameters\n----------\npos_from : np.ndarray of float, shape(n_good_sensors, 3)\n    The electrode positions to interpolate from.\npos_to : np.ndarray of float, shape(n_bad_sensors, 3)\n    The electrode positions to interpolate.\nstiffness : float\n    Stiffness of the spline.\nnum_lterms : int\n    Number of Legendre terms to evaluate.\n\nReturns\n-------\nG : np.ndarray of float, shape(n_channels, n_channels)\n    The G matrix.\n\nNotes\n-----\nProduces identical output to the private ``computeg`` function in EEGLAB's\n``eeg_interp.m``.", "metadata": {}}
{"_id": "pyprep_utils.py__eeglab_interpolate_doc", "text": "Interpolate bad channels using EEGLAB's custom method.\n\nParameters\n----------\ndata : np.ndarray\n    A 2-D array containing signals from currently-good EEG channels with\n    which to interpolate signals for bad channels.\npos_from : np.ndarray of float, shape(n_good_sensors, 3)\n    The electrode positions to interpolate from.\npos_to : np.ndarray of float, shape(n_bad_sensors, 3)\n    The electrode positions to interpolate.\n\nReturns\n-------\ninterpolated : np.ndarray\n    The interpolated signals for all bad channels.\n\nNotes\n-----\nProduces identical output to the private ``spheric_spline`` function in\nEEGLAB's ``eeg_interp.m`` (with minor rounding errors).", "metadata": {}}
{"_id": "pyprep_utils.py__eeglab_interpolate_bads_doc", "text": "Interpolate bad channels using EEGLAB's custom method.\n\nThis method modifies the provided Raw object in place.\n\nParameters\n----------\nraw : mne.io.Raw\n    An MNE Raw object for which channels marked as \"bad\" should be\n    interpolated.\n\nNotes\n-----\nProduces identical results as EEGLAB's ``eeg_interp`` function when using\nthe default spheric spline method (with minor rounding errors). This method\nappears to be loosely based on the same general Perrin et al. (1989) method\nas MNE's interpolation, but there are several quirks with the implementation\nthat cause it to produce fairly different numbers.", "metadata": {}}
{"_id": "pyprep_utils.py__get_random_subset_doc", "text": "Get a random subset of items from a list or array, without replacement.\n\nParameters\n----------\nx : list or np.ndarray\n    One-dimensional array of items to sample from.\nsize : int\n    The number of items to sample. Must be less than the number of input\n    items.\nrand_state : np.random.RandomState\n    A random state object to use for random number generation.\n\nReturns\n-------\nsample : list\n    A random subset of the input items.\n\nNotes\n-----\nThis function generates random subsets identical to the internal\n``randsample`` function in MATLAB PREP's ``findNoisyChannels.m``, allowing\nthe same random seed to produce identical results across both PyPREP and\nMATLAB PREP.", "metadata": {}}
{"_id": "pyprep_utils.py__correlate_arrays_doc", "text": "Calculate correlations between two equally-sized 2-D arrays of EEG data.\n\nBoth input arrays must be in the shape (channels, samples).\n\nParameters\n----------\na : np.ndarray\n    A 2-D array to correlate with `a`.\nb : np.ndarray\n    A 2-D array to correlate with `b`.\nmatlab_strict : bool, optional\n    Whether or not correlations should be calculated identically to MATLAB\n    PREP (i.e., without mean subtraction) instead of by traditional Pearson\n    product-moment correlation (see Notes for details). Defaults to\n    ``False`` (Pearson correlation).\n\nReturns\n-------\ncorrelations : np.ndarray\n    A one-dimensional array containing the correlations of the two input arrays\n    along the second axis.\n\nNotes\n-----\nIn MATLAB PREP, RANSAC channel predictions are correlated with actual data\nusing a non-standard method: essentially, it uses the standard Pearson\ncorrelation formula but without subtracting the channel means from each channel\nbefore calculating sums of squares, i.e.,::\n\n   SSa = np.sum(a ** 2)\n   SSb = np.sum(b ** 2)\n   correlation = np.sum(a * b) / (np.sqrt(SSa) * np.sqrt(SSb))\n\nBecause EEG data is roughly mean-centered to begin with, this produces similar\nvalues to normal Pearson correlation. However, to avoid making any assumptions\nabout the signal for any given channel/window, PyPREP defaults to normal\nPearson correlation unless strict MATLAB equivalence is requested.", "metadata": {}}
{"_id": "pyprep_utils.py__filter_design_doc", "text": "Create FIR low-pass filter for EEG data using frequency sampling method.\n\nParameters\n----------\nN_order : int\n    Order of the filter.\namp : list of int\n    Amplitude vector for the frequencies.\nfreq : list of int\n    Frequency vector for which amplitude can be either 0 or 1.\n\nReturns\n-------\nkernel : np.ndarray\n    Filter kernel.", "metadata": {}}
{"_id": "pyprep_utils.py__split_list_doc", "text": "Split list in chunks.\n\nParameters\n----------\nmy_list: list\n    list to split.\nchunk_size: int\n    size of the lists returned.\n\nReturns\n-------\nlist\n    list of the chunked lists.\n\nSee: https://stackoverflow.com/a/312466/5201771", "metadata": {}}
{"_id": "pyprep_utils.py__verify_free_ram_doc", "text": "Check if enough memory is free to run RANSAC with the given parameters.\n\nParameters\n----------\ndata : np.ndarray\n    2-D EEG data\nn_samples : int\n    Number of samples to use for computation of RANSAC.\nn_channels : int\n    Number of channels to process per chunk.\nmax_prop : float\n    The maximum proportion of available memory that RANSAC is allowed to\n    use.\n\nRaises\n------\nMemoryError\n    If insufficient free memory to perform RANSAC with the given data and\n    parameters.", "metadata": {}}
{"_id": "pyprep_ransac.py_find_bad_by_ransac_doc", "text": "Detect channels that are not predicted well by other channels.\n\nHere, a RANSAC approach (see [1]_, and a short discussion in [2]_) is\nadopted to predict a \"clean EEG\" dataset. After identifying clean EEG\nchannels through the other methods, the clean EEG dataset is\nconstructed by repeatedly sampling a small subset of clean EEG channels\nand interpolation the complete data. The median of all those\nrepetitions forms the clean EEG dataset. In a second step, the original\nand the RANSAC-predicted data are correlated and channels, which do not\ncorrelate well with themselves across the two datasets are considered\n`bad_by_ransac`.\n\nParameters\n----------\ndata : np.ndarray\n    A 2-D array of detrended EEG data, with bad-by-flat and bad-by-NaN\n    channels removed.\nsample_rate : float\n    The sample rate (in Hz) of the EEG data.\ncomplete_chn_labs : array_like\n    Labels for all channels in `data`, in the same order as they appear\n    in `data`.\nchn_pos : np.ndarray\n    3-D electrode coordinates for all channels in `data`, in the same order\n    as they appear in `data`.\nexclude : list\n    Labels of channels to exclude as signal predictors during RANSAC\n    (i.e., channels already flagged as bad by metrics other than HF noise).\nn_samples : int, optional\n    Number of random channel samples to use for RANSAC. Defaults to ``50``.\nsample_prop : float, optional\n    Proportion of total channels to use for signal prediction per RANSAC\n    sample. This needs to be in the range [0, 1], where 0 would mean no\n    channels would be used and 1 would mean all channels would be used\n    (neither of which would be useful values). Defaults to ``0.25`` (e.g.,\n    16 channels per sample for a 64-channel dataset).\ncorr_thresh : float, optional\n    The minimum predicted vs. actual signal correlation for a channel to\n    be considered good within a given RANSAC window. Defaults to ``0.75``.\nfrac_bad : float, optional\n    The minimum fraction of bad (i.e., below-threshold) RANSAC windows for a\n    channel to be considered bad-by-RANSAC. Defaults to ``0.4``.\ncorr_window_secs : float, optional\n    The duration (in seconds) of each RANSAC correlation window. Defaults to\n    5 seconds.\nchannel_wise : bool, optional\n    Whether RANSAC should predict signals for chunks of channels over the\n    entire signal length (\"channel-wise RANSAC\", see `max_chunk_size`\n    parameter). If ``False``, RANSAC will instead predict signals for all\n    channels at once but over a number of smaller time windows instead of\n    over the entire signal length (\"window-wise RANSAC\"). Channel-wise\n    RANSAC generally has higher RAM demands than window-wise RANSAC\n    (especially if `max_chunk_size` is ``None``), but can be faster on\n    systems with lots of RAM to spare. Defaults to ``False``.\nmax_chunk_size : {int, None}, optional\n    The maximum number of channels to predict at once during channel-wise\n    RANSAC. If ``None``, RANSAC will use the largest chunk size that will\n    fit into the available RAM, which may slow down other programs on the\n    host system. If using window-wise RANSAC (the default), this parameter\n    has no effect. Defaults to ``None``.\nrandom_state : {int, None, np.random.RandomState}, optional\n    The random seed with which to generate random samples of channels during\n    RANSAC. If random_state is an int, it will be used as a seed for RandomState.\n    If ``None``, the seed will be obtained from the operating system\n    (see RandomState for details). Defaults to ``None``.\nmatlab_strict : bool, optional\n    Whether or not RANSAC should strictly follow MATLAB PREP's internal\n    math, ignoring any improvements made in PyPREP over the original code\n    (see :ref:`matlab-diffs` for more details). Defaults to ``False``.\n\nReturns\n-------\nbad_by_ransac : list\n    List containing the labels of all channels flagged as bad by RANSAC.\nchannel_correlations : np.ndarray\n    Array of shape (windows, channels) containing the correlations of\n    the channels with their predicted RANSAC values for each window.\n\nReferences\n----------\n.. [1] Fischler, M.A., Bolles, R.C. (1981). Random sample consensus: A\n    Paradigm for Model Fitting with Applications to Image Analysis and\n    Automated Cartography. Communications of the ACM, 24, 381-395\n.. [2] Jas, M., Engemann, D.A., Bekhti, Y., Raimondo, F., Gramfort, A.\n    (2017). Autoreject: Automated Artifact Rejection for MEG and EEG\n    Data. NeuroImage, 159, 417-429", "metadata": {}}
{"_id": "pyprep_ransac.py__make_interpolation_matrices_doc", "text": "Create an interpolation matrix for each RANSAC sample of channels.\n\nThis function takes the spatial coordinates of random subsets of currently-good\nchannels and uses them to predict what the signal will be at the spatial\ncoordinates of all other currently-good channels. The results of this process are\nreturned as matrices that can be multiplied with EEG data to generate predicted\nsignals.\n\nParameters\n----------\nrandom_ch_picks : list of list of int\n    A list containing multiple random subsets of currently-good channels.\nchn_pos_good : np.ndarray\n    3-D spatial coordinates of all currently-good channels.\n\nReturns\n-------\ninterpolation_mats : list of np.ndarray\n    A list of interpolation matrices, one for each random subset of channels.\n    Each matrix has the shape `[num_good_channels, num_good_channels]`, with the\n    number of good channels being inferred from the size of `ch_pos_good`.\n\nNotes\n-----\nThis function currently makes use of a private MNE function,\n``mne.channels.interpolation._make_interpolation_matrix``, to generate matrices.", "metadata": {}}
{"_id": "pyprep_ransac.py__ransac_by_window_doc", "text": "Calculate correlations of channels with their RANSAC-predicted values.\n\nThis function calculates RANSAC correlations for each RANSAC window\nindividually, requiring RAM equivalent to [channels * sample rate * seconds\nper RANSAC window] to run. Generally, this method will use less RAM than\n:func:`_ransac_by_channel`, with the exception of short recordings with high\nelectrode counts.\n\nParameters\n----------\ndata : np.ndarray\n    A 2-D array containing the EEG signals from all currently-good channels.\ninterpolation_mats : list of np.ndarray\n    A list of interpolation matrices, one for each RANSAC sample of channels.\nwin_size : int\n    Number of frames/samples of EEG data in each RANSAC correlation window.\nwin_count: int\n    Number of RANSAC correlation windows.\nmatlab_strict : bool\n    Whether or not RANSAC should strictly follow MATLAB PREP's internal\n    math, ignoring any improvements made in PyPREP over the original code.\n\nReturns\n-------\ncorrelations : np.ndarray\n    Correlations of the given channels to their predicted values within each\n    RANSAC window.", "metadata": {}}
{"_id": "pyprep_ransac.py__predict_median_signals_doc", "text": "Calculate the median RANSAC-predicted signal for a given window of data.\n\nParameters\n----------\nwindow : np.ndarray\n    A 2-D window of EEG data with the shape `[channels, samples]`.\ninterpolation_mats : list of np.ndarray\n    A set of channel interpolation matrices, one for each RANSAC sample of\n    channels.\nmatlab_strict : bool\n    Whether or not RANSAC should strictly follow MATLAB PREP's internal\n    math, ignoring any improvements made in PyPREP over the original code.\n\nReturns\n-------\npredicted : np.ndarray\n    The median RANSAC-predicted EEG signal for the given window of data.\n\nNotes\n-----\nIn MATLAB PREP, the median signal is calculated by sorting the different\npredictions for each EEG sample/channel from low to high and then taking the value\nat the middle index (as calculated by ``int(n_ransac_samples / 2.0)``) for each.\nBecause this logic only returns the correct result for odd numbers of samples, the\ncurrent function will instead return the true median signal across predictions\nunless strict MATLAB equivalence is requested.", "metadata": {}}
{"_id": "pyprep_ransac.py__ransac_by_channel_doc", "text": "Calculate correlations of channels with their RANSAC-predicted values.\n\nThis function calculates RANSAC correlations on one (or more) full channels\nat once, requiring RAM equivalent to [channels per chunk * sample rate *\nlength of recording in seconds] to run. Generally, this method will use\nmore RAM than :func:`_ransac_by_window`, but may be faster for systems with\nlarge amounts of RAM.\n\nParameters\n----------\ndata : np.ndarray\n    A 2-D array containing the EEG signals from all currently-good channels.\ninterpolation_mats : list of np.ndarray\n    A set of channel interpolation matrices, one for each RANSAC sample of\n    channels.\nwin_size : int\n    Number of frames/samples of EEG data in each RANSAC correlation window.\nwin_count: int\n    Number of RANSAC correlation windows.\nchans_to_predict : list of int\n    Indices of the channels to predict (as they appear in `data`) within the\n    current chunk.\nrandom_ch_picks : list of list of int\n    A list containing multiple random subsets of currently-good channels.\nmatlab_strict : bool\n    Whether or not RANSAC should strictly follow MATLAB PREP's internal\n    math, ignoring any improvements made in PyPREP over the original code.\n\nReturns\n-------\ncorrelations : np.ndarray\n    Correlations of the given channels to their predicted values within each\n    RANSAC window.", "metadata": {}}
{"_id": "pyprep_ransac.py__predict_median_signals_channelwise_doc", "text": "Calculate the median RANSAC-predicted signal for a given chunk of channels.\n\nParameters\n----------\ndata : np.ndarray\n    A 2-D array containing the EEG signals from all currently-good channels.\ninterpolation_mats : list of np.ndarray\n    A set of channel interpolation matrices, one for each RANSAC sample of\n    channels.\nrandom_ch_picks : list of list of int\n    A list containing multiple random subsets of currently-good channels.\nchunk_size : int\n    The number of channels to predict in the current chunk.\nmatlab_strict : bool\n    Whether or not RANSAC should strictly follow MATLAB PREP's internal\n    math, ignoring any improvements made in PyPREP over the original code.\n\nReturns\n-------\npredicted_chans : np.ndarray\n    The median RANSAC-predicted EEG signals for the given chunk of channels.", "metadata": {}}
{"_id": "pyprep_find_noisy_channels.py___init___doc", "text": "", "metadata": {}}
{"_id": "pyprep_find_noisy_channels.py__get_filtered_data_doc", "text": "Apply a [1 Hz - 50 Hz] bandpass filter to the EEG signal.\n\nOnly applied if the sample rate is above 100 Hz to avoid violating the\nNyquist theorem.", "metadata": {}}
{"_id": "pyprep_find_noisy_channels.py_get_bads_doc", "text": "Get the names of all channels currently flagged as bad.\n\nNote that this method does not perform any bad channel detection itself,\nand only reports channels already detected as bad by other methods.\n\nParameters\n----------\nverbose : bool, optional\n    If ``True``, a summary of the channels currently flagged as by bad per\n    category is printed. Defaults to ``False``.\nas_dict: bool, optional\n    If ``True``, this method will return a dict of the channels currently\n    flagged as bad by each individual bad channel type. If ``False``, this\n    method will return a list of all unique bad channels detected so far.\n    Defaults to ``False``.\n\nReturns\n-------\nbads : list or dict\n    The names of all bad channels detected so far, either as a combined\n    list or a dict indicating the channels flagged bad by each type.", "metadata": {}}
{"_id": "pyprep_find_noisy_channels.py_find_all_bads_doc", "text": "Call all the functions to detect bad channels.\n\nThis function calls all the bad-channel detecting functions.\n\nParameters\n----------\nransac : bool, optional\n    Whether RANSAC should be used for bad channel detection, in addition\n    to the other methods. RANSAC can detect bad channels that other\n    methods are unable to catch, but also slows down noisy channel\n    detection considerably. Defaults to ``True``.\nchannel_wise : bool, optional\n    Whether RANSAC should predict signals for chunks of channels over the\n    entire signal length (\"channel-wise RANSAC\", see `max_chunk_size`\n    parameter). If ``False``, RANSAC will instead predict signals for all\n    channels at once but over a number of smaller time windows instead of\n    over the entire signal length (\"window-wise RANSAC\"). Channel-wise\n    RANSAC generally has higher RAM demands than window-wise RANSAC\n    (especially if `max_chunk_size` is ``None``), but can be faster on\n    systems with lots of RAM to spare. Has no effect if not using RANSAC.\n    Defaults to ``False``.\nmax_chunk_size : {int, None}, optional\n    The maximum number of channels to predict at once during\n    channel-wise RANSAC. If ``None``, RANSAC will use the largest chunk\n    size that will fit into the available RAM, which may slow down\n    other programs on the host system. If using window-wise RANSAC\n    (the default) or not using RANSAC at all, this parameter has no\n    effect. Defaults to ``None``.", "metadata": {}}
{"_id": "pyprep_find_noisy_channels.py_find_bad_by_nan_flat_doc", "text": "Detect channels than contain NaN values or have near-flat signals.\n\nA channel is considered flat if its standard deviation or its median\nabsolute deviation from the median (MAD) are below the provided flat\nthreshold (default: ``1e-15`` volts).\n\nThis method is run automatically when a ``NoisyChannels`` object is\ninitialized, preventing flat or NaN-containing channels from interfering\nwith the detection of other types of bad channels.\n\nParameters\n----------\nflat_threshold : float, optional\n    The lowest standard deviation or MAD value for a channel to be\n    considered bad-by-flat. Defaults to ``1e-15`` volts (corresponds to\n    10e-10 µV in MATLAB PREP).", "metadata": {}}
{"_id": "pyprep_find_noisy_channels.py_find_bad_by_deviation_doc", "text": "Detect channels with abnormally high or low overall amplitudes.\n\nA channel is considered \"bad-by-deviation\" if its amplitude deviates\nconsiderably from the median channel amplitude, as calculated using a\nrobust Z-scoring method and the given deviation threshold.\n\nAmplitude Z-scores are calculated using the formula\n``(channel_amplitude - median_amplitude) / amplitude_sd``, where\nchannel amplitudes are calculated using a robust outlier-resistant estimate\nof the signals' standard deviations (IQR scaled to units of SD), and the\namplitude SD is the IQR-based SD of those amplitudes.\n\nParameters\n----------\ndeviation_threshold : float, optional\n    The minimum absolute z-score of a channel for it to be considered\n    bad-by-deviation. Defaults to ``5.0``.", "metadata": {}}
{"_id": "pyprep_find_noisy_channels.py_find_bad_by_hfnoise_doc", "text": "Detect channels with abnormally high amounts of high-frequency noise.\n\nThe noisiness of a channel is defined as the amplitude of its\nhigh-frequency (>50 Hz) components divided by its overall amplitude.\nA channel is considered \"bad-by-high-frequency-noise\" if its noisiness\nis considerably higher than the median channel noisiness, as determined\nby a robust Z-scoring method and the given Z-score threshold.\n\nDue to the Nyquist theorem, this method will only attempt bad channel\ndetection if the sample rate of the given signal is above 100 Hz.\n\nParameters\n----------\nHF_zscore_threshold : float, optional\n    The minimum noisiness z-score of a channel for it to be considered\n    bad-by-high-frequency-noise. Defaults to ``5.0``.", "metadata": {}}
{"_id": "pyprep_find_noisy_channels.py_find_bad_by_correlation_doc", "text": "Detect channels that sometimes don't correlate with any other channels.\n\nChannel correlations are calculated by splitting the recording into\nnon-overlapping windows of time (default: 1 second), getting the absolute\ncorrelations of each usable channel with every other usable channel for\neach window, and then finding the highest correlation each channel has\nwith another channel for each window (by taking the 98th percentile of\nthe absolute correlations).\n\nA correlation window is considered \"bad\" for a channel if its maximum\ncorrelation with another channel is below the provided correlation\nthreshold (default: ``0.4``). A channel is considered \"bad-by-correlation\"\nif its fraction of bad correlation windows is above the bad fraction\nthreshold (default: ``0.01``).\n\nThis method also detects channels with intermittent dropouts (i.e.,\nregions of flat signal). A channel is considered \"bad-by-dropout\" if\nits fraction of correlation windows with a completely flat signal is\nabove the bad fraction threshold (default: ``0.01``).\n\nParameters\n----------\ncorrelation_secs : float, optional\n    The length (in seconds) of each correlation window. Defaults to ``1.0``.\ncorrelation_threshold : float, optional\n    The lowest maximum inter-channel correlation for a channel to be\n    considered \"bad\" within a given window. Defaults to ``0.4``.\nfrac_bad : float, optional\n    The minimum proportion of bad windows for a channel to be considered\n    \"bad-by-correlation\" or \"bad-by-dropout\". Defaults to ``0.01`` (1% of\n    all windows).", "metadata": {}}
{"_id": "pyprep_find_noisy_channels.py_find_bad_by_SNR_doc", "text": "Detect channels that have a low signal-to-noise ratio.\n\nChannels are considered \"bad-by-SNR\" if they are bad by both high-frequency\nnoise and bad by low correlation.", "metadata": {}}
{"_id": "pyprep_find_noisy_channels.py_find_bad_by_ransac_doc", "text": "Detect channels that are predicted poorly by other channels.\n\nThis method uses a random sample consensus approach (RANSAC, see [1]_,\nand a short discussion in [2]_) to try and predict what the signal should\nbe for each channel based on the signals and spatial locations of other\ncurrently-good channels. RANSAC correlations are calculated by splitting\nthe recording into non-overlapping windows of time (default: 5 seconds)\nand correlating each channel's RANSAC-predicted signal with its actual\nsignal within each window.\n\nA RANSAC window is considered \"bad\" for a channel if its predicted signal\nvs. actual signal correlation falls below the given correlation threshold\n(default: ``0.75``). A channel is considered \"bad-by-RANSAC\" if its fraction\nof bad RANSAC windows is above the given threshold (default: ``0.4``).\n\nDue to its random sampling component, the channels identified as\n\"bad-by-RANSAC\" may vary slightly between calls of this method.\nAdditionally, bad channels may vary between different montages given that\nRANSAC's signal predictions are based on the spatial coordinates of each\nelectrode.\n\nThis method is a wrapper for the :func:`~ransac.find_bad_by_ransac`\nfunction.\n\n.. warning:: For optimal performance, RANSAC requires that channels bad by\n             deviation, correlation, and/or dropout have already been\n             flagged. Otherwise RANSAC will attempt to use those channels\n             when making signal predictions, decreasing accuracy and thus\n             increasing the likelihood of false positives.\n\nParameters\n----------\nn_samples : int, optional\n    Number of random channel samples to use for RANSAC. Defaults\n    to ``50``.\nsample_prop : float, optional\n    Proportion of total channels to use for signal prediction per RANSAC\n    sample. This needs to be in the range [0, 1], where 0 would mean no\n    channels would be used and 1 would mean all channels would be used\n    (neither of which would be useful values). Defaults to ``0.25``\n    (e.g., 16 channels per sample for a 64-channel dataset).\ncorr_thresh : float, optional\n    The minimum predicted vs. actual signal correlation for a channel to\n    be considered good within a given RANSAC window. Defaults\n    to ``0.75``.\nfrac_bad : float, optional\n    The minimum fraction of bad (i.e., below-threshold) RANSAC windows\n    for a channel to be considered bad-by-RANSAC. Defaults to ``0.4``.\ncorr_window_secs : float, optional\n    The duration (in seconds) of each RANSAC correlation window. Defaults\n    to 5 seconds.\nchannel_wise : bool, optional\n    Whether RANSAC should predict signals for chunks of channels over the\n    entire signal length (\"channel-wise RANSAC\", see `max_chunk_size`\n    parameter). If ``False``, RANSAC will instead predict signals for all\n    channels at once but over a number of smaller time windows instead of\n    over the entire signal length (\"window-wise RANSAC\"). Channel-wise\n    RANSAC generally has higher RAM demands than window-wise RANSAC\n    (especially if `max_chunk_size` is ``None``), but can be faster on\n    systems with lots of RAM to spare. Defaults to ``False``.\nmax_chunk_size : {int, None}, optional\n    The maximum number of channels to predict at once during\n    channel-wise RANSAC. If ``None``, RANSAC will use the largest chunk\n    size that will fit into the available RAM, which may slow down\n    other programs on the host system. If using window-wise RANSAC\n    (the default), this parameter has no effect. Defaults to ``None``.\n\nReferences\n----------\n.. [1] Fischler, M.A., Bolles, R.C. (1981). Random sample consensus: A\n    Paradigm for Model Fitting with Applications to Image Analysis and\n    Automated Cartography. Communications of the ACM, 24, 381-395\n.. [2] Jas, M., Engemann, D.A., Bekhti, Y., Raimondo, F., Gramfort, A.\n    (2017). Autoreject: Automated Artifact Rejection for MEG and EEG\n    Data. NeuroImage, 159, 417-429", "metadata": {}}
