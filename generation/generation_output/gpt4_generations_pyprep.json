[["rate (default: 5e-4)')\n    parser.add_argument('--weight_decay', type=float, default=5e-4, help='weight decay (default: 5e-4)')\n    args = parser.parse_args()\n\n    setup_seed(args.seed)\n\n    device = torch.device('cuda:' + str(args.cuda) if torch.cuda.is_available() else 'cpu')\n\n    model = CBraMod().to(device)\n    model.load_state_dict(torch.load('pretrained_weights/pretrained_weights.pth', map_location=device))\n    model.proj_out = nn.Identity()\n\n    classifier = nn.Sequential(\n        Rearrange('b c s p -> b (c s p)'),\n        nn.Linear(22 * 4 * 200, 4 * 200),\n        nn.ELU(),\n        nn.Dropout(0.1),\n        nn.Linear(4 * 200, 200),\n        nn.ELU(),\n        nn.Dropout(0.1),\n        nn.Linear(200, 4),\n    ).to(device)\n\n    mock_eeg = torch.randn((8, 22, 4, 200)).to(device)\n\n    logits = classifier(model(mock_eeg))\n\n    print(logits.shape)\n\n\nif __name__ == '__main__':\n    main()"], ["rate (default: 5e-4)')\n    parser.add_argument('--weight_decay', type=float, default=1e-5, help='weight decay (default: 1e-5)')\n    parser.add_argument('--pretrained_weights', type=str, default='pretrained_weights/pretrained_weights.pth', help='path to pretrained weights (default: pretrained_weights/pretrained_weights.pth)')\n    args = parser.parse_args()\n\n    setup_seed(args.seed)\n\n    device = torch.device(f\"cuda:{args.cuda}\" if torch.cuda.is_available() else \"cpu\")\n\n    model = CBraMod().to(device)\n    model.load_state_dict(torch.load(args.pretrained_weights, map_location=device))\n    model.proj_out = nn.Identity()\n\n    classifier = nn.Sequential(\n        Rearrange('b c s p -> b (c s p)'),\n        nn.Linear(22*4*200, 4*200),\n        nn.ELU(),\n        nn.Dropout(0.1),\n        nn.Linear(4 * 200, 200),\n        nn.ELU(),\n        nn.Dropout(0.1),\n        nn.Linear(200, 4),\n    ).to(device)\n\n    mock_eeg = torch.randn((8, 22, 4, 200)).to(device)\n\n    logits = classifier(model(mock_eeg))\n\n    print(logits.shape)\n\n\nif __name__ == '__main__':\n    main()"], ["rate (default: 5e-4)')\n    parser.add_argument('--weight_decay', type=float, default=1e-5, help='weight decay (default: 1e-5)')\n    parser.add_argument('--pretrained_weights', type=str, default='pretrained_weights/pretrained_weights.pth', help='path to pretrained weights (default: pretrained_weights/pretrained_weights.pth)')\n    args = parser.parse_args()\n\n    setup_seed(args.seed)\n\n    device = torch.device(f\"cuda:{args.cuda}\" if torch.cuda.is_available() else \"cpu\")\n\n    model = CBraMod().to(device)\n    model.load_state_dict(torch.load(args.pretrained_weights, map_location=device))\n    model.proj_out = nn.Identity()\n\n    classifier = nn.Sequential(\n        Rearrange('b c s p -> b (c s p)'),\n        nn.Linear(22*4*200, 4*200),\n        nn.ELU(),\n        nn.Dropout(0.1),\n        nn.Linear(4 * 200, 200),\n        nn.ELU(),\n        nn.Dropout(0.1),\n        nn.Linear(200, 4),\n    ).to(device)\n\n    mock_eeg = torch.randn((8, 22, 4, 200)).to(device)\n\n    logits = classifier(model(mock_eeg))\n\n    print(logits.shape)\n\n\nif __name__ == '__main__':\n    main()"], ["rate (default: 5e-4)')\n    parser.add_argument('--weight_decay', type=float, default=1e-5, help='weight decay (default: 1e-5)')\n    args = parser.parse_args()\n\n    setup_seed(args.seed)\n\n    device = torch.device(f\"cuda:{args.cuda}\" if torch.cuda.is_available() else \"cpu\")\n\n    model = CBraMod().to(device)\n    model.load_state_dict(torch.load('pretrained_weights/pretrained_weights.pth', map_location=device))\n    model.proj_out = nn.Identity()\n\n    classifier = nn.Sequential(\n        Rearrange('b c s p -> b (c s p)'),\n        nn.Linear(22*4*200, 4*200),\n        nn.ELU(),\n        nn.Dropout(0.1),\n        nn.Linear(4 * 200, 200),\n        nn.ELU(),\n        nn.Dropout(0.1),\n        nn.Linear(200, 4),\n    ).to(device)\n\n    mock_eeg = torch.randn((8, 22, 4, 200)).to(device)\n\n    logits = classifier(model(mock_eeg))\n\n    print(logits.shape)\n\n\nif __name__ == '__main__':\n    main()"], ["# The code provided loads a pretrained model and defines a classifier to make predictions on EEG data.\n# To use this code to make predictions on new EEG data, follow these steps:\n\n# 1. Load the necessary libraries and functions\nimport torch\nimport torch.nn as nn\nfrom models.cbramod import CBraMod\nfrom einops.layers.torch import Rearrange\n\n# 2. Load the pretrained model\ndevice = torch.device(\"cuda:0\" if torch.cuda.is_available() else \"cpu\")\nmodel = CBraMod().to(device)\nmodel.load_state_dict(torch.load('pretrained_weights/pretrained_weights.pth', map_location=device))\nmodel.proj_out = nn.Identity()\n\n# 3. Define the classifier\nclassifier = nn.Sequential(\n  Rearrange('b c s p -> b (c s p)'),\n  nn.Linear(22*4*200, 4*200),\n  nn.ELU(),\n  nn.Dropout(0.1),\n  nn.Linear(4 * 200, 200),\n  nn.ELU(),\n  nn.Dropout(0.1),\n  nn.Linear(200, 4),\n).to(device)\n\n# 4. Prepare the new EEG data\n# mock_eeg.shape = (batch_size, num_of_channels, time_segments, points_per_patch)\nmock_eeg = torch.randn((8, 22, 4, 200)).to(device)\n\n# 5. Make predictions using the model and classifier\n# logits.shape = (batch_size, num_of_classes)\nlogits = classifier(model(mock_eeg))\n\n# 6. Print the shape of the logits\nprint(logits.shape)"], ["rate (default: 5e-4)')\n    parser.add_argument('--weight_decay', type=float, default=1e-5, help='weight decay (default: 1e-5)')\n    args = parser.parse_args()\n\n    setup_seed(args.seed)\n\n    device = torch.device(f\"cuda:{args.cuda}\" if torch.cuda.is_available() else \"cpu\")\n\n    model = CBraMod().to(device)\n    model.load_state_dict(torch.load('pretrained_weights/pretrained_weights.pth', map_location=device))\n    model.proj_out = nn.Identity()\n\n    classifier = nn.Sequential(\n        Rearrange('b c s p -> b (c s p)'),\n        nn.Linear(22*4*200, 4*200),\n        nn.ELU(),\n        nn.Dropout(0.1),\n        nn.Linear(4 * 200, 200),\n        nn.ELU(),\n        nn.Dropout(0.1),\n        nn.Linear(200, 4),\n    ).to(device)\n\n    mock_eeg = torch.randn((8, 22, 4, 200)).to(device)\n\n    logits = classifier(model(mock_eeg))\n\n    print(logits.shape)\n\n\nif __name__ == '__main__':\n    main()"], ["rate (default: 5e-4)')\n    parser.add_argument('--weight_decay', type=float, default=1e-5, help='weight decay (default: 1e-5)')\n    args = parser.parse_args()\n\n    setup_seed(args.seed)\n\n    device = torch.device('cuda:' + str(args.cuda) if torch.cuda.is_available() else 'cpu')\n\n    model = CBraMod().to(device)\n    model.load_state_dict(torch.load('pretrained_weights/pretrained_weights.pth', map_location=device))\n    model.proj_out = nn.Identity()\n\n    classifier = nn.Sequential(\n        Rearrange('b c s p -> b (c s p)'),\n        nn.Linear(22 * 4 * 200, 4 * 200),\n        nn.ELU(),\n        nn.Dropout(0.1),\n        nn.Linear(4 * 200, 200),\n        nn.ELU(),\n        nn.Dropout(0.1),\n        nn.Linear(200, 4),\n    ).to(device)\n\n    mock_eeg = torch.randn((8, 22, 4, 200)).to(device)\n\n    logits = classifier(model(mock_eeg))\n\n    print(logits.shape)\n\n\nif __name__ == '__main__':\n    main()"], ["# The code provided loads a pretrained model and defines a classifier to make predictions on EEG data.\n# To use this code to make predictions on new EEG data, follow these steps:\n\n# 1. Define the new EEG data in the same format as the mock_eeg data:\nnew_eeg = torch.randn((8, 22, 4, 200)).to(device)\n\n# 2. Use the classifier to make predictions on the new EEG data:\nnew_logits = classifier(model(new_eeg))\n\n# 3. Print the shape of the predicted logits:\nprint(new_logits.shape)"], ["rate (default: 5e-4)')\n    parser.add_argument('--weight_decay', type=float, default=1e-4, help='weight decay (default: 1e-4)')\n    parser.add_argument('--pretrained_weights', type=str, default='pretrained_weights/pretrained_weights.pth', help='path to pretrained weights (default: pretrained_weights/pretrained_weights.pth)')\n    args = parser.parse_args()\n\n    setup_seed(args.seed)\n\n    device = torch.device(f\"cuda:{args.cuda}\" if torch.cuda.is_available() else \"cpu\")\n\n    model = CBraMod().to(device)\n    model.load_state_dict(torch.load(args.pretrained_weights, map_location=device))\n    model.proj_out = nn.Identity()\n\n    classifier = nn.Sequential(\n        Rearrange('b c s p -> b (c s p)'),\n        nn.Linear(22 * 4 * 200, 4 * 200),\n        nn.ELU(),\n        nn.Dropout(0.1),\n        nn.Linear(4 * 200, 200),\n        nn.ELU(),\n        nn.Dropout(0.1),\n        nn.Linear(200, 4),\n    ).to(device)\n\n    mock_eeg = torch.randn((8, 22, 4, 200)).to(device)\n\n    logits = classifier(model(mock_eeg))\n\n    print(logits.shape)\n\n\nif __name__ == '__main__':\n    main()"], ["rate (default: 5e-4)')\n    parser.add_argument('--weight_decay', type=float, default=1e-5, help='weight decay (default: 1e-5)')\n    args = parser.parse_args()\n\n    setup_seed(args.seed)\n\n    device = torch.device('cuda:' + str(args.cuda) if torch.cuda.is_available() else 'cpu')\n\n    model = CBraMod().to(device)\n    model.load_state_dict(torch.load('pretrained_weights/pretrained_weights.pth', map_location=device))\n    model.proj_out = nn.Identity()\n\n    classifier = nn.Sequential(\n        Rearrange('b c s p -> b (c s p)'),\n        nn.Linear(22 * 4 * 200, 4 * 200),\n        nn.ELU(),\n        nn.Dropout(0.1),\n        nn.Linear(4 * 200, 200),\n        nn.ELU(),\n        nn.Dropout(0.1),\n        nn.Linear(200, 4),\n    ).to(device)\n\n    mock_eeg = torch.randn((8, 22, 4, 200)).to(device)\n\n    logits = classifier(model(mock_eeg))\n\n    print(logits.shape)\n\n\nif __name__ == '__main__':\n    main()"]]