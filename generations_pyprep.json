[["\"\"\"Calculate spherical spline g function between points on a sphere.\n\nParameters\n----------\npos_from : np.ndarray of float, shape(n_good_sensors, 3)\n    The electrode positions to interpolate from.\npos_to : np.ndarray of float, shape(n_bad_sensors, 3)\n    The electrode positions to interpolate.\nstiffness : float\n    Stiffness of the spline.\nnum_lterms : int\n    Number of Legendre terms to evaluate.\n\nReturns\n-------\nG : np.ndarray of float, shape(n_channels, n_channels)\n    The G matrix.\n\nNotes\n-----\nProduces identical output to the private ``computeg`` function in EEGLAB's\n``eeg_interp.m``.\"\"\"\n\ndef computeg(pos_from, pos_to, stiffness, num_lterms):\n    \"\"\"Compute spherical spline g function between points on a sphere.\n\n    Parameters\n    ----------\n    pos_from : np.ndarray of float, shape(n_good_sensors, 3)\n        The electrode positions to interpolate from.\n    pos_to : np.ndarray of float, shape(n_bad_sensors, 3)\n        The electrode positions to interpolate.\n    stiffness : float\n        Stiffness of the spline.\n    num_lterms : int\n        Number of Legendre terms to evaluate.\n\n    Returns\n    -------\n    G : np.ndarray of float, shape(n_channels, n_channels)\n        The G matrix.\n    \"\"\"\n    # Compute the distance between the points\n    dist = np.linalg.norm(pos_from - pos_to, axis=1)\n\n    # Compute the angle between the points\n    angle = np.arccos(np.dot(pos_from, pos_to) / np.linalg.norm(pos_from) * np.linalg.norm(pos_to))\n\n    # Compute the angle between the points\n    angle = np.arccos(np.dot(pos_from, pos_to) / np.linalg.norm(pos_from) * np.linalg.norm(pos_to))\n\n    # Compute the angle between the points\n    angle = np.arccos(np.dot(pos_from, pos_to) / np.linalg.norm(pos_from) * np.linalg.norm(pos_to))\n\n    # Compute the angle between the points\n    angle = np.arccos(np.dot(pos_from, pos_to) / np.linalg.norm(pos_from) * np.linalg.norm(pos_to))\n\n    # Compute the angle between the points\n    angle = np.arccos(np.dot(pos_from, pos_to) / np.linalg.norm(pos_from) * np.linalg.norm(pos_to))\n\n    # Compute the angle between the points\n    angle = np.arccos(np.dot(pos_from, pos_to) / np.linalg.norm(pos_from) * np.linalg.norm(pos_to))\n\n    # Compute the angle between the points\n    angle = np.arccos(np.dot(pos_from, pos_to) / np.linalg.norm(pos_from) * np.linalg.norm(pos_to))\n\n    # Compute the angle between the points\n    angle = np.arccos(np.dot(pos_from, pos_to) / np.linalg.norm(pos_from) * np.linalg.norm(pos_to))\n\n    # Compute the angle between the points\n    angle = np.arccos(np.dot(pos_from, pos_to) / np.linalg.norm(pos_from) * np.linalg.norm(pos_to))\n\n    # Compute the angle between the points\n    angle = np.arccos(np.dot(pos_from, pos_to) / np.linalg.norm(pos_from) * np.linalg.norm(pos_to))\n\n    # Compute the angle between the points\n    angle = np.arccos(np.dot(pos_from, pos_to) / np.linalg.norm(pos_from) * np.linalg.norm(pos_to))\n\n    # Compute the angle between the points\n    angle = np.arccos(np.dot(pos_from, pos_to) / np.linalg.norm(pos_from) * np.linalg.norm(pos_to))\n\n    # Compute the angle between the points\n    angle = np.arccos(np.dot(pos_from, pos_to) / np.linalg.norm(pos_from) * np.linalg.norm(pos_to))\n\n    # Compute the angle between the points"], ["\"\"\"Calculate the numeric value at quantile (`q`) for a given distribution.\n\nParameters\n----------\narr : np.ndarray\n    Input array containing samples from the distribution to summarize. Must\n    be either a 1-D or 2-D array.\nq : float\n    The quantile to calculate for the input data. Must be between 0 and 1,\n    inclusive.\naxis : {int, tuple of int, None}, optional\n    Axis along which quantile values should be calculated. Defaults to\n    calculating the value at the given quantile for the entire array.\n\nReturns\n-------\nquantile : scalar or np.ndarray\n    If no axis is specified, returns the value at quantile (q) for the full\n    input array as a single numeric value. Otherwise, returns an\n    ``np.ndarray`` containing the values at quantile (q) for each row along\n    the specified axis.\n\nNotes\n-----\nMATLAB calculates quantiles using different logic than Numpy: Numpy treats\nthe provided values as a whole population, whereas MATLAB treats them as a\nsample from a population of unknown size and adjusts quantiles accordingly.\nThis function mimics MATLAB's logic to produce identical results.\"\"\"\n\ndef quantile(arr, q, axis=None):\n    \"\"\"Calculate the numeric value at quantile (`q`) for a given distribution.\n\nParameters\n----------\narr : np.ndarray\n    Input array containing samples from the distribution to summarize. Must\n    be either a 1-D or 2-D array.\nq : float\n    The quantile to calculate for the input data. Must be between 0 and 1,\n    inclusive.\naxis : {int, tuple of int, None}, optional\n    Axis along which quantile values should be calculated. Defaults to\n    calculating the value at the given quantile for the entire array.\n\nReturns\n-------\nquantile : scalar or np.ndarray\n    If no axis is specified, returns the value at quantile (q) for the full\n    input array as a single numeric value. Otherwise, returns an\n    ``np.ndarray`` containing the values at quantile (q) for each row along\n    the specified axis.\n\nNotes\n-----\nMATLAB calculates quantiles using different logic than Numpy: Numpy treats\nthe provided values as a whole population, whereas MATLAB treats them as a\nsample from a population of unknown size and adjusts quantiles accordingly.\nThis function mimics MATLAB's logic to produce identical results.\"\"\"\n\ndef quantile(arr, q, axis=None):\n    \"\"\"Calculate the numeric value at quantile (`q`) for a given distribution.\n\nParameters\n----------\narr : np.ndarray\n    Input array containing samples from the distribution to summarize. Must\n    be either a 1-D or 2-D array.\nq : float\n    The quantile to calculate for the input data. Must be between 0 and 1,\n    inclusive.\naxis : {int, tuple of int, None}, optional\n    Axis along which quantile values should be calculated. Defaults to\n    calculating the value at the given quantile for the entire array.\n\nReturns\n-------\nquantile : scalar or np.ndarray\n    If no axis is specified, returns the value at quantile (q) for the full\n    input array as a single numeric value. Otherwise, returns an\n    ``np.ndarray`` containing the values at quantile (q) for each row along\n    the specified axis.\n\nNotes\n-----\nMATLAB calculates quantiles using different logic than Numpy: Numpy treats\nthe provided values as a whole population, whereas MATLAB treats them as a\nsample from a population of unknown size and adjusts quantiles accordingly.\nThis function mimics MATLAB's logic to produce identical results.\"\"\"\n\ndef quantile(arr, q, axis=None):\n    \"\"\"Calculate the numeric value at quantile (`q`) for a given distribution.\n\nParameters\n----------\narr : np.ndarray\n    Input array containing samples from the distribution to summarize. Must\n    be either a 1-D or 2-D array.\nq : float\n    The quantile to calculate for the input data. Must be between 0 and 1,\n    inclusive.\naxis : {int, tuple of int, None}, optional\n    Axis along which quantile values should be calculated. Defaults to\n    calculating the value at the given quantile for the entire array.\n\nReturns\n-------\nquantile : scalar or np.ndarray\n    If no axis is specified, returns the value at quantile (q) for the full\n    input array as a single numeric value. Otherwise, returns an\n    ``np.ndarray`` containing the values at quantile (q) for each row along\n    the specified axis.\n\nNotes\n-----\nMATLAB calculates quantiles using different logic"], ["\"\"\"Get a random subset of items from a list or array, without replacement.\n\nParameters\n----------\nx : list or np.ndarray\n    One-dimensional array of items to sample from.\nsize : int\n    The number of items to sample. Must be less than the number of input\n    items.\nrand_state : np.random.RandomState\n    A random state object to use for random number generation.\n\nReturns\n-------\nsample : list\n    A random subset of the input items.\n\nNotes\n-----\nThis function generates random subsets identical to the internal\n``randsample`` function in MATLAB PREP's ``findNoisyChannels.m``, allowing\nthe same random seed to produce identical results across both PyPREP and\nMATLAB PREP.\"\"\"\n\ndef randsample(x, size, rand_state=None):\n    \"\"\"Get a random subset of items from a list or array, without replacement.\n\nParameters\n----------\nx : list or np.ndarray\n    One-dimensional array of items to sample from.\nsize : int\n    The number of items to sample. Must be less than the number of input\n    items.\nrand_state : np.random.RandomState\n    A random state object to use for random number generation.\n\nReturns\n-------\nsample : list\n    A random subset of the input items.\n\nNotes\n-----\nThis function generates random subsets identical to the internal\n``randsample`` function in MATLAB PREP's ``findNoisyChannels.m``, allowing\nthe same random seed to produce identical results across both PyPREP and\nMATLAB PREP.\"\"\"\n\ndef randsample(x, size, rand_state=None):\n    \"\"\"Get a random subset of items from a list or array, without replacement.\n\nParameters\n----------\nx : list or np.ndarray\n    One-dimensional array of items to sample from.\nsize : int\n    The number of items to sample. Must be less than the number of input\n    items.\nrand_state : np.random.RandomState\n    A random state object to use for random number generation.\n\nReturns\n-------\nsample : list\n    A random subset of the input items.\n\nNotes\n-----\nThis function generates random subsets identical to the internal\n``randsample`` function in MATLAB PREP's ``findNoisyChannels.m``, allowing\nthe same random seed to produce identical results across both PyPREP and\nMATLAB PREP.\"\"\"\n\ndef randsample(x, size, rand_state=None):\n    \"\"\"Get a random subset of items from a list or array, without replacement.\n\nParameters\n----------\nx : list or np.ndarray\n    One-dimensional array of items to sample from.\nsize : int\n    The number of items to sample. Must be less than the number of input\n    items.\nrand_state : np.random.RandomState\n    A random state object to use for random number generation.\n\nReturns\n-------\nsample : list\n    A random subset of the input items.\n\nNotes\n-----\nThis function generates random subsets identical to the internal\n``randsample`` function in MATLAB PREP's ``findNoisyChannels.m``, allowing\nthe same random seed to produce identical results across both PyPREP and\nMATLAB PREP.\"\"\"\n\ndef randsample(x, size, rand_state=None):\n    \"\"\"Get a random subset of items from a list or array, without replacement.\n\nParameters\n----------\nx : list or np.ndarray\n    One-dimensional array of items to sample from.\nsize : int\n    The number of items to sample. Must be less than the number of input\n    items.\nrand_state : np.random.RandomState\n    A random state object to use for random number generation.\n\nReturns\n-------\nsample : list\n    A random subset of the input items.\n\nNotes\n-----\nThis function generates random subsets identical to the internal\n``randsample`` function in MATLAB PREP's ``findNoisyChannels.m``, allowing\nthe same random seed to produce identical results across both PyPREP and\nMATLAB PREP.\"\"\"\n\ndef randsample(x, size, rand_state=None):\n    \"\"\"Get a random subset of items from a list or array, without replacement.\n\nParameters\n----------\nx : list or np.ndarray\n    One-dimensional array of items to sample from.\nsize : int\n    The number of items to sample. Must be less than the number of input\n    items.\nrand_state : np.random.RandomState\n    A random state object to use for random number generation.\n\nReturns\n-------\nsample : list\n    A random subset of the input items.\n\nNotes\n-----\nThis function generates random subsets identical to the internal\n``randsample`` function in MATLAB"], ["\"\"\"Calculate the median RANSAC-predicted signal for a given window of data.\n\nParameters\n----------\nwindow : np.ndarray\n    A 2-D window of EEG data with the shape `[channels, samples]`.\ninterpolation_mats : list of np.ndarray\n    A set of channel interpolation matrices, one for each RANSAC sample of\n    channels.\nmatlab_strict : bool\n    Whether or not RANSAC should strictly follow MATLAB PREP's internal\n    math, ignoring any improvements made in PyPREP over the original code.\n\nReturns\n-------\npredicted : np.ndarray\n    The median RANSAC-predicted EEG signal for the given window of data.\n\nNotes\n-----\nIn MATLAB PREP, the median signal is calculated by sorting the different\npredictions for each EEG sample/channel from low to high and then taking the value\nat the middle index (as calculated by ``int(n_ransac_samples / 2.0)``) for each.\nBecause this logic only returns the correct result for odd numbers of samples, the\ncurrent function will instead return the true median signal across predictions\nunless strict MATLAB equivalence is requested.\"\"\"\n\ndef median_signal(window, interpolation_mats, matlab_strict=False):\n    \"\"\"Calculate the median RANSAC-predicted signal for a given window of data.\n\n    Parameters\n    ----------\n    window : np.ndarray\n        A 2-D window of EEG data with the shape `[channels, samples]`.\n    interpolation_mats : list of np.ndarray\n        A set of channel interpolation matrices, one for each RANSAC sample of\n        channels.\n    matlab_strict : bool\n        Whether or not RANSAC should strictly follow MATLAB PREP's internal\n        math, ignoring any improvements made in PyPREP over the original code.\n\n    Returns\n    -------\n    predicted : np.ndarray\n        The median RANSAC-predicted EEG signal for the given window of data.\n\n    Notes\n    -----\n    In MATLAB PREP, the median signal is calculated by sorting the different\n    predictions for each EEG sample/channel from low to high and then taking the value\n    at the middle index (as calculated by ``int(n_ransac_samples / 2.0)``) for each.\n    Because this logic only returns the correct result for odd numbers of samples, the\n    current function will instead return the true median signal across predictions\n    unless strict MATLAB equivalence is requested.\"\"\"\n\n    # Sort the predictions for each channel\n    predictions = np.array([np.sort(np.median(window[:, :, i], axis=0)) for i in range(window.shape[2])])\n\n    # If the number of samples is odd, return the median across predictions\n    if predictions.shape[0] % 2 == 1:\n        return np.median(predictions, axis=0)\n\n    # If the number of samples is even, return the median across predictions\n    else:\n        return np.median(predictions[::2], axis=0)"]]